;/////////////////////////////////////////////////////////////////////////////////
;// Code Generator: BoostC Compiler - http://www.sourceboost.com
;// Version       : 7.03
;// License Type  : Pro License
;// Limitations   : PIC12,PIC16 max code size:Unlimited, max RAM banks:Unlimited
;/////////////////////////////////////////////////////////////////////////////////

//************************************************************************************
//**  
//**  File name:     C:\Users\BlueFlame17\Desktop\NICE2018\Program\EMRA.c
//**  Title:         
//**  Description:   
//**  
//**  Generated by:  Flowcode v5.5.2.1
//**  Date:          Saturday, July 21, 2018 23:25:53
//**  Licence:       Professional
//**  Registered to: xyz
//**  Licence key:   WUK7B9
//**  
//**  
//**  http://www.matrixmultimedia.com
//**  
//************************************************************************************


#define MX_PIC

#define MX_USES_UINT8 1
#define MX_USES_SINT16 0
#define MX_USES_CHAR 0
#define MX_USES_FLOAT 0
#define MX_USES_SINT32 0
#define MX_USES_BOOL 1
#define MX_USES_UINT16 1
#define MX_USES_UINT32 0
//Defines for microcontroller
#define P16F690
#define FC_CAL_PIC
#define MX_ADC
#define MX_ADC_TYPE_3
#define MX_ADC_BITS_10
#define MX_EE
#define MX_EE_TYPE2
#define MX_EE_SIZE 256
#define MX_SPI_1
#define MX_SPI_1_MISO_PORT portb
#define MX_SPI_1_MISO_TRIS trisb
#define MX_SPI_1_MISO_PIN 4
#define MX_SPI_1_MOSI_PORT portc
#define MX_SPI_1_MOSI_TRIS trisc
#define MX_SPI_1_MOSI_PIN 7
#define MX_SPI_1_CLK_PORT portb
#define MX_SPI_1_CLK_TRIS trisb
#define MX_SPI_1_CLK_PIN 6
#define MX_SPI_1_SS_PORT portb
#define MX_SPI_1_SS_TRIS trisb
#define MX_UART_1
#define MX_UART_1_TX_PORT portb
#define MX_UART_1_TX_TRIS trisb
#define MX_UART_1_TX_PIN 7
#define MX_UART_1_RX_PORT portb
#define MX_UART_1_RX_TRIS trisb
#define MX_UART_1_RX_PIN 5
#define MX_I2C
#define MX_MI2C
#define MX_I2C_1
#define MX_I2C_1_SDA_PORT portb
#define MX_I2C_1_SDA_TRIS trisb
#define MX_I2C_1_SDA_PIN 4
#define MX_I2C_1_SCL_PORT portb
#define MX_I2C_1_SCL_TRIS trisb
#define MX_I2C_1_SCL_PIN 6
#define MX_PWM
#define MX_PWM_CNT 1
#define MX_PWM_PSCA1
#define MX_PWM_PSCA4
#define MX_PWM_PSCA16
#define MX_PWM_1_PORT portc
#define MX_PWM_1_TRIS trisc
#define MX_PWM_1_PIN 5

//Functions
#define MX_CLK_SPEED 4000000
#ifdef _BOOSTC
#include <system.h>
#endif
#ifdef HI_TECH_C
#include <pic.h>
#endif

//Configuration data
#ifdef _BOOSTC
#pragma DATA 0x2007, 0x30f4
#endif
#ifdef HI_TECH_C
__CONFIG(0x30f4);
#endif

//Internal functions
#include "C:\Program Files\Flowcode\v5\FCD\internals.c"

//Macro function declarations
void FCM_stored_values();
void FCM_display();
void FCM_clear();
void FCM_Value_OUT();
void FCM_lowbat_detect();
void FCM_int0();


//Variable declarations
#define FCV_FALSE (0)
#define FCV_TRUE (1)
MX_UINT16 FCV_VOLTAGE = (0x0);
010E  01B9  	CLRF gbl_FCV_VOLTAGE
010F  01BA  	CLRF gbl_FCV_VOLTAGE+D'1'

MX_BOOL FCV_DAT;
MX_BOOL FCV_SWITCH = (0);
0110  10C4  	BCF gbl_FCV_SWITCH,1

MX_UINT8 FCV_EEPROM_VAL;
MX_UINT8 FCV_EEPROMREAD_ANALOG = (0x0);
0111  01C5  	CLRF gbl_FCV_EEPROMREAD_ANALOG

MX_UINT8 FCV_TENS;
MX_UINT8 FCV_DIGIT;
MX_UINT8 FCV_COUNT = (0x0);
0112  01C7  	CLRF gbl_FCV_COUNT

MX_BOOL FCV_FLAG = (0);
0113  1144  	BCF gbl_FCV_FLAG,2

MX_UINT8 FCV_HUNDREDS;
MX_UINT8 FCV_ONES;
MX_UINT8 FCV_VALUE;
MX_UINT8 FCV_ANALOG2 = (0x0);
0114  01C9  	CLRF gbl_FCV_ANALOG2

MX_UINT8 FCV_INIT = (0x0);
0115  01CA  	CLRF gbl_FCV_INIT

MX_UINT8 FCV_ANALOG = (0x0);
0116  01CB  	CLRF gbl_FCV_ANALOG


MX_UINT8 FCLV_LOOP1;
MX_UINT8 FCLV_LOOP2;



//LED(0): //Defines:

/**** Macro Substitutions ****
a = Unique Reference
b = LED Port Letter
c = LED Pin Number
d = LED Active Polarity
******************************/

#define LED_1__LED_PORT		porta
#define LED_1__LED_TRIS		trisa
#define LED_1__LED_PIN		0
#define LED_1__LED_POLE		1




//LED(0): //Macro function declarations

void FCD_LED0_LEDOn();
void FCD_LED0_LEDOff();


//LED(1): //Defines:

/**** Macro Substitutions ****
a = Unique Reference
b = LED Port Letter
c = LED Pin Number
d = LED Active Polarity
******************************/

#define LED_2__LED_PORT		portc
#define LED_2__LED_TRIS		trisc
#define LED_2__LED_PIN		1
#define LED_2__LED_POLE		1




//LED(1): //Macro function declarations

void FCD_LED1_LEDOn();
void FCD_LED1_LEDOff();


//ADC(0): //Defines:

/**** Macro Substitutions ****
a = Unique Reference
b = Which ADC Channel
c = Acquisition time
d = Conversion Speed
e = VRef+ Option
f = VRef Voltage x 0.01V
******************************/

//Common Defines

#define ADC_3_MX_ADC_CHANNEL	4
#define ADC_3_MX_ADC_ACTIME	40
#define ADC_3_MX_ADC_CONVSP	3
#define ADC_3_MX_ADC_VREFOP	0
#define ADC_3_MX_ADC_VREFVOL	500

#ifndef MX_ADC_CHANNEL_4
 #define MX_ADC_CHANNEL_4			//Inform CAL ADC channel 4 is now in use.
#endif

#ifndef MX_ADC_REF					//Inform CAL ADC peripheral is now in use
 #define MX_ADC_REF
#endif

extern void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge);
extern MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode);
extern void FC_CAL_Disable_ADC (void);




//ADC(0): //Macro function declarations

void FCD_ADC0_SampleADC();
MX_UINT8 FCD_ADC0_ReadAsByte();
MX_UINT16 FCD_ADC0_ReadAsInt();
MX_FLOAT FCD_ADC0_ReadAsVoltage();
void FCD_ADC0_ReadAsString(MX_CHAR* FCR_RETVAL, MX_UINT8 FCR_RETVAL_SIZE);
void FCD_ADC0_ADC_RAW_Configure_Channel();
MX_UINT8 FCD_ADC0_ADC_RAW_Sample_Channel_Byte();
MX_UINT16 FCD_ADC0_ADC_RAW_Sample_Channel_Int();
MX_UINT8 FCD_ADC0_ADC_RAW_Average_Channel_Byte(MX_UINT8 NumSamples, MX_UINT8 DelayUs);
MX_UINT16 FCD_ADC0_ADC_RAW_Average_Channel_Int(MX_UINT8 NumSamples, MX_UINT8 DelayUs);
void FCD_ADC0_ADC_RAW_Disable_Channel();



//LED(0): //Macro implementations


void FCD_LED0_LEDOn()
{
	
		#if( LED_1__LED_POLE == 1)									//Active high polarity
			FC_CAL_Bit_High_DDR( LED_1__LED_PORT , LED_1__LED_TRIS , LED_1__LED_PIN );
		#else													//Active low polarity
			FC_CAL_Bit_Low_DDR( LED_1__LED_PORT , LED_1__LED_TRIS , LED_1__LED_PIN );
		#endif

}

void FCD_LED0_LEDOff()
{
	
		#if( LED_1__LED_POLE == 1)									//Active high polarity
			FC_CAL_Bit_Low_DDR( LED_1__LED_PORT	, LED_1__LED_TRIS , LED_1__LED_PIN );
		#else													//Active low polarity
			FC_CAL_Bit_High_DDR( LED_1__LED_PORT , LED_1__LED_TRIS , LED_1__LED_PIN );
		#endif

}



//LED(1): //Macro implementations


void FCD_LED1_LEDOn()
{
	
		#if( LED_2__LED_POLE == 1)									//Active high polarity
			FC_CAL_Bit_High_DDR( LED_2__LED_PORT , LED_2__LED_TRIS , LED_2__LED_PIN );
		#else													//Active low polarity
			FC_CAL_Bit_Low_DDR( LED_2__LED_PORT , LED_2__LED_TRIS , LED_2__LED_PIN );
		#endif

}

void FCD_LED1_LEDOff()
{
	
		#if( LED_2__LED_POLE == 1)									//Active high polarity
			FC_CAL_Bit_Low_DDR( LED_2__LED_PORT	, LED_2__LED_TRIS , LED_2__LED_PIN );
		#else													//Active low polarity
			FC_CAL_Bit_High_DDR( LED_2__LED_PORT , LED_2__LED_TRIS , LED_2__LED_PIN );
		#endif

}



//ADC(0): //Macro implementations


void FCD_ADC0_SampleADC()
{
	
	    //unused

}

MX_UINT8 FCD_ADC0_ReadAsByte()
{
	
		MX_UINT8 retVal;

		//Configure & Enable ADC Channel
		FC_CAL_Enable_ADC ( ADC_3_MX_ADC_CHANNEL , ADC_3_MX_ADC_CONVSP , ADC_3_MX_ADC_VREFOP , ADC_3_MX_ADC_ACTIME );

		retVal = FC_CAL_Sample_ADC( 0 );				//Perform Sample - Return as byte

		FC_CAL_Disable_ADC ();

		return (retVal);

}

MX_UINT16 FCD_ADC0_ReadAsInt()
{
	
		MX_UINT16 retVal;

		//Configure & Enable ADC Channel
		FC_CAL_Enable_ADC ( ADC_3_MX_ADC_CHANNEL , ADC_3_MX_ADC_CONVSP , ADC_3_MX_ADC_VREFOP , ADC_3_MX_ADC_ACTIME );

		retVal = FC_CAL_Sample_ADC( 1 );				//Perform Sample - Return as MX_UINT16

		FC_CAL_Disable_ADC ();

		return (retVal);

}

MX_FLOAT FCD_ADC0_ReadAsVoltage()
{
	
		MX_UINT16 iSample;
		MX_FLOAT fSample, fVoltage, fVperDiv;

		//Configure & Enable ADC Channel
		FC_CAL_Enable_ADC ( ADC_3_MX_ADC_CHANNEL , ADC_3_MX_ADC_CONVSP , ADC_3_MX_ADC_VREFOP , ADC_3_MX_ADC_ACTIME );

	  #ifdef MX_ADC_BITS_8
		iSample = FC_CAL_Sample_ADC( 0 );								//Perform Sample - Return as byte
	  #else
		iSample = FC_CAL_Sample_ADC( 1 );								//Perform Sample - Return as MX_UINT16
	  #endif

	  	FC_CAL_Disable_ADC ();											//Switch off ADC peripheral
		fVoltage = flt_fromi( ADC_3_MX_ADC_VREFVOL );						//Convert reference voltage count to floating point (0 - 500 x 10mV)
		fVoltage = flt_mul(fVoltage, 0.01);								//Convert reference voltage count to actual voltage (0 - 5)

	  #ifdef MX_ADC_BITS_8
		fVperDiv = flt_mul(fVoltage, 0.00390625);						//Convert actual voltage to voltage per division (VRef / 256)
	  #endif
	  #ifdef MX_ADC_BITS_10
		fVperDiv = flt_mul(fVoltage, 0.000976);							//Convert actual voltage to voltage per division (VRef / 1024)
	  #endif
	  #ifdef MX_ADC_BITS_12
		fVperDiv = flt_mul(fVoltage, 0.00024414);						//Convert actual voltage to voltage per division (VRef / 4096)
	  #endif

		fSample = flt_fromi(iSample);									//Convert to floating point variable
		fVoltage = flt_mul(fSample, fVperDiv);							//Calculate floating point voltage

		return (fVoltage);

}

void FCD_ADC0_ReadAsString(MX_CHAR* FCR_RETVAL, MX_UINT8 FCR_RETVAL_SIZE)
{
	
		MX_FLOAT fVoltage;

		fVoltage = FCD_ADC0_ReadAsVoltage();
		FCI_FLOAT_TO_STRING(fVoltage, 2, FCR_RETVAL, FCR_RETVAL_SIZE);	//Convert to String

}

void FCD_ADC0_ADC_RAW_Configure_Channel()
{
	
		//Configure & Enable ADC Channel
		FC_CAL_Enable_ADC ( ADC_3_MX_ADC_CHANNEL , ADC_3_MX_ADC_CONVSP , ADC_3_MX_ADC_VREFOP , ADC_3_MX_ADC_ACTIME );

}

MX_UINT8 FCD_ADC0_ADC_RAW_Sample_Channel_Byte()
{
	
		return FC_CAL_Sample_ADC( 0 );									//Perform Sample - Return as byte

}

MX_UINT16 FCD_ADC0_ADC_RAW_Sample_Channel_Int()
{
	
		return FC_CAL_Sample_ADC( 1 );									//Perform Sample - Return as MX_UINT16

}

MX_UINT8 FCD_ADC0_ADC_RAW_Average_Channel_Byte(MX_UINT8 NumSamples, MX_UINT8 DelayUs)
{
	
		MX_UINT32 average = 0;
		MX_UINT8 count;

		for (count=0; count<NumSamples; count++)
		{
			average = average + FC_CAL_Sample_ADC( 0 );					//Perform Sample - Return as byte - add to average

			if (DelayUs)
				delay_us(DelayUs);										//If delay is not 0 then pause between samples
		}
		average = average / count;

		return (average & 0xFF);										//Return average as byte

}

MX_UINT16 FCD_ADC0_ADC_RAW_Average_Channel_Int(MX_UINT8 NumSamples, MX_UINT8 DelayUs)
{
	
		MX_UINT32 average = 0;
		MX_UINT8 count;

		for (count=0; count<NumSamples; count++)
		{
			average = average + FC_CAL_Sample_ADC( 1 );					//Perform Sample - Return as MX_UINT16 - add to average

			if (DelayUs)
				delay_us(DelayUs);										//If delay is not 0 then pause between samples
		}
		average = average / count;

		return (average & 0x1FFF);										//Return average as MX_SINT16

}

void FCD_ADC0_ADC_RAW_Disable_Channel()
{
	
		FC_CAL_Disable_ADC ();											//Disable ADC Channel

}

#include "C:\Program Files\Flowcode\v5\CAL\includes.c"

//Macro implementations


void FCM_stored_values()

{

	//Switch
	//Switch: DIGIT?
	switch (FCV_DIGIT)

	{
		case 1:
001C  1283  	BCF STATUS, RP0
001D  1303  	BCF STATUS, RP1
001E  0846  	MOVF gbl_FCV_DIGIT, W
001F  3A01  	XORLW 0x01
0020  1903  	BTFSC STATUS,Z
0021  283E  	GOTO	label3
003E        label3

		{
			//Calculation
			//Calculation:
			//  VALUE = 0b10011111
			FCV_VALUE = 159;
003E  309F  	MOVLW 0x9F
003F  00C8  	MOVWF gbl_FCV_VALUE


			break;

		}
		case 2:
0022  3A03  	XORLW 0x03
0023  1903  	BTFSC STATUS,Z
0024  2841  	GOTO	label4
0041        label4

		{
			//Calculation
			//Calculation:
			//  VALUE = 0b00100100
			FCV_VALUE = 36;
0041  3024  	MOVLW 0x24
0042  00C8  	MOVWF gbl_FCV_VALUE


			break;

		}
		case 3:
0025  3A01  	XORLW 0x01
0026  1903  	BTFSC STATUS,Z
0027  2844  	GOTO	label5
0044        label5

		{
			//Calculation
			//Calculation:
			//  VALUE = 0b00001101
			FCV_VALUE = 13;
0044  300D  	MOVLW 0x0D
0045  00C8  	MOVWF gbl_FCV_VALUE


			break;

		}
		case 4:
0028  3A07  	XORLW 0x07
0029  1903  	BTFSC STATUS,Z
002A  2847  	GOTO	label6
0047        label6

		{
			//Calculation
			//Calculation:
			//  VALUE = 0b10011001
			FCV_VALUE = 153;
0047  3099  	MOVLW 0x99
0048  00C8  	MOVWF gbl_FCV_VALUE


			break;

		}
		case 5:
002B  3A01  	XORLW 0x01
002C  1903  	BTFSC STATUS,Z
002D  284A  	GOTO	label7
004A        label7

		{
			//Calculation
			//Calculation:
			//  VALUE = 0b01001001
			FCV_VALUE = 73;
004A  3049  	MOVLW 0x49
004B  00C8  	MOVWF gbl_FCV_VALUE


			break;

		}
		case 6:
002E  3A03  	XORLW 0x03
002F  1903  	BTFSC STATUS,Z
0030  284D  	GOTO	label8
004D        label8

		{
			//Calculation
			//Calculation:
			//  VALUE = 0b01000001
			FCV_VALUE = 65;
004D  3041  	MOVLW 0x41
004E  00C8  	MOVWF gbl_FCV_VALUE


			break;

		}
		case 7:
0031  3A01  	XORLW 0x01
0032  1903  	BTFSC STATUS,Z
0033  2850  	GOTO	label9
0050        label9

		{
			//Calculation
			//Calculation:
			//  VALUE = 0b00011111
			FCV_VALUE = 31;
0050  301F  	MOVLW 0x1F
0051  00C8  	MOVWF gbl_FCV_VALUE


			break;

		}
		case 8:
0034  3A0F  	XORLW 0x0F
0035  1903  	BTFSC STATUS,Z
0036  2853  	GOTO	label10
0053        label10

		{
			//Calculation
			//Calculation:
			//  VALUE = 0b00000001
			FCV_VALUE = 1;
0053  3001  	MOVLW 0x01
0054  00C8  	MOVWF gbl_FCV_VALUE


			break;

		}
		case 9:
0037  3A01  	XORLW 0x01
0038  1903  	BTFSC STATUS,Z
0039  2856  	GOTO	label11
0056        label11

		{
			//Calculation
			//Calculation:
			//  VALUE = 0b00001001
			FCV_VALUE = 9;
0056  3009  	MOVLW 0x09
0057  00C8  	MOVWF gbl_FCV_VALUE


			break;

		}
		case 0:
003A  3A09  	XORLW 0x09
003B  1903  	BTFSC STATUS,Z
003C  2859  	GOTO	label12
0059        label12

		{
			//Calculation
			//Calculation:
			//  VALUE = 0b00000011
			FCV_VALUE = 3;
0059  3003  	MOVLW 0x03
005A  00C8  	MOVWF gbl_FCV_VALUE


			break;

		}
		// default:

	}

}
003D  0008  	RETURN
0040  0008  	RETURN
0043  0008  	RETURN
0046  0008  	RETURN
0049  0008  	RETURN
004C  0008  	RETURN
004F  0008  	RETURN
0052  0008  	RETURN
0055  0008  	RETURN
0058  0008  	RETURN
005B  0008  	RETURN



void FCM_display()
{

	//Loop
	//Loop: Loop 8 times
	for (FCLV_LOOP2=0; FCLV_LOOP2<8; FCLV_LOOP2++)
	{

		//Calculation
		//Calculation:
		//  DAT = VALUE AND 1
		//  VALUE = VALUE >> 1
		FCV_DAT = FCV_VALUE & 1;
		FCV_VALUE = FCV_VALUE >> 1;

		//DATA
		//Output: DAT -> C5
		trisc = trisc & 0xDF;
		if ((FCV_DAT))
			portc = (portc & 0xDF) | 0x20;
		else
			portc = portc & 0xDF;

		//CLK
		//Output: 0 -> C4
		trisc = trisc & 0xEF;
		if ((0))
			portc = (portc & 0xEF) | 0x10;
		else
			portc = portc & 0xEF;

		//Delay
		//Delay: 10 ms
		delay_ms(10);

		//CLK
		//Output: 1 -> C4
		trisc = trisc & 0xEF;
		if ((1))
			portc = (portc & 0xEF) | 0x10;
		else
			portc = portc & 0xEF;


	}

	//REG
	//Output: 1 -> C3
	trisc = trisc & 0xF7;
	if ((1))
		portc = (portc & 0xF7) | 0x08;
	else
		portc = portc & 0xF7;

	//Delay
	//Delay: 1 ms
	delay_ms(1);

	//REG
	//Output: 0 -> C3
	trisc = trisc & 0xF7;
	if ((0))
		portc = (portc & 0xF7) | 0x08;
	else
		portc = portc & 0xF7;

}


void FCM_clear()
{

	//Calculation
	//Calculation:
	//  VALUE = 0b11111111
	FCV_VALUE = 255;

	//Call Macro
	//Call Macro: display()
	FCM_display();

}


void FCM_Value_OUT()
{

	//CLK
	//Output: 1 -> C4
	trisc = trisc & 0xEF;
	if ((1))
		portc = (portc & 0xEF) | 0x10;
	else
		portc = portc & 0xEF;

	//REG
	//Output: 0 -> C3
	trisc = trisc & 0xF7;
	if ((0))
		portc = (portc & 0xF7) | 0x08;
	else
		portc = portc & 0xF7;

	//OE
	//Output: 0 -> C2
	trisc = trisc & 0xFB;
	if ((0))
		portc = (portc & 0xFB) | 0x04;
	else
		portc = portc & 0xFB;

	//Output
	//Output: 0 -> A4
	trisa = trisa & 0xEF;
	if ((0))
		porta = (porta & 0xEF) | 0x10;
	else
		porta = porta & 0xEF;

	//Output
	//Output: 1 -> A5
	trisa = trisa & 0xDF;
	if ((1))
		porta = (porta & 0xDF) | 0x20;
	else
		porta = porta & 0xDF;

	//Call Macro
	//Call Macro: clear()
	FCM_clear();

	//Calculation
	//Calculation:
	//  HUNDREDS = COUNT / 100
	//  TENS = (COUNT / 10) MOD 10
	//  ONES = COUNT MOD 10
	FCV_HUNDREDS = FCV_COUNT / 100;
	FCV_TENS = (FCV_COUNT / 10) % 10;
	FCV_ONES = FCV_COUNT % 10;

	//Calculation
	//Calculation:
	//  DIGIT = HUNDREDS
	FCV_DIGIT = FCV_HUNDREDS;

	//Call Macro
	//Call Macro: stored_values()
	FCM_stored_values();

	//Call Macro
	//Call Macro: display()
	FCM_display();

	//Delay
	//Delay: 1 s
	delay_s(1);

	//Calculation
	//Calculation:
	//  DIGIT = TENS
	FCV_DIGIT = FCV_TENS;

	//Call Macro
	//Call Macro: stored_values()
	FCM_stored_values();

	//Call Macro
	//Call Macro: display()
	FCM_display();

	//Delay
	//Delay: 1 s
	delay_s(1);

	//Calculation
	//Calculation:
	//  DIGIT = ONES
	FCV_DIGIT = FCV_ONES;

	//Call Macro
	//Call Macro: stored_values()
	FCM_stored_values();

	//Call Macro
	//Call Macro: display()
	FCM_display();

	//Delay
	//Delay: 1 s
	delay_s(1);

}


void FCM_lowbat_detect()
{

	//Call Component Macro
	//Call Component Macro: analog=ReadAsByte()
	FCV_ANALOG = FCD_ADC0_ReadAsByte();

	//Calculation
	//Calculation:
	//  COUNT = analog
	FCV_COUNT = FCV_ANALOG;

	//Decision
	//Decision: analog < 152?
	if (FCV_ANALOG < 152)
	{

		//Call Component Macro
		//Call Component Macro: LEDOff()
		FCD_LED0_LEDOff();

		//Loop
		//Loop: While analog > 155
		while (!(FCV_ANALOG > 155))
		{

			//Call Component Macro
			//Call Component Macro: analog=ReadAsByte()
			FCV_ANALOG = FCD_ADC0_ReadAsByte();

			//Call Component Macro
			//Call Component Macro: LEDOn()
			FCD_LED1_LEDOn();

			//Delay
			//Delay: 400 ms
			delay_ms(255);
			delay_ms(145);

			//Call Component Macro
			//Call Component Macro: LEDOff()
			FCD_LED1_LEDOff();

			//Input
			//Input: A2 -> switch
			trisa = trisa | 0x04;
			FCV_SWITCH = ((porta & 0x04) == 0x04);

			//Calculation
			//Calculation:
			//  COUNT = analog
			FCV_COUNT = FCV_ANALOG;

			//Call Macro
			//Call Macro: Value_OUT()
			FCM_Value_OUT();


		}

	} else {

		//Call Component Macro
		//Call Component Macro: LEDOn()
		FCD_LED0_LEDOn();

		//Call Component Macro
		//Call Component Macro: LEDOff()
		FCD_LED1_LEDOff();

		//Call Macro
		//Call Macro: Value_OUT()
		FCM_Value_OUT();

	}

}


void FCM_int0()
{

}



void main()

{
	//Initialization
	ansel = 0;
005C  1283  	BCF STATUS, RP0
005D  1703  	BSF STATUS, RP1
005E  019E  	CLRF gbl_ansel

anselh = 0;
005F  019F  	CLRF gbl_anselh



	//Interrupt initialization code
	option_reg = 0xC0;
0060  30C0  	MOVLW 0xC0
0061  1683  	BSF STATUS, RP0
0062  1303  	BCF STATUS, RP1
0063  0081  	MOVWF gbl_option_reg



	//Calculation
	//Calculation:
	//  digit = 2
	FCV_DIGIT = 2;
0064  3002  	MOVLW 0x02
0065  1283  	BCF STATUS, RP0
0066  00C6  	MOVWF gbl_FCV_DIGIT


	//CLK
	//Output: 1 -> C4
	trisc = trisc & 0xEF;
0067  30EF  	MOVLW 0xEF
0068  1683  	BSF STATUS, RP0
0069  0507  	ANDWF gbl_trisc, W
006A  0087  	MOVWF gbl_trisc

	if ((1))
		portc = (portc & 0xEF) | 0x10;
006B  30EF  	MOVLW 0xEF
006C  1283  	BCF STATUS, RP0
006D  0507  	ANDWF gbl_portc, W
006E  00CD  	MOVWF CompTempVar2244
006F  3010  	MOVLW 0x10
0070  044D  	IORWF CompTempVar2244, W
0071  0087  	MOVWF gbl_portc

	else
		portc = portc & 0xEF;

	//REG
	//Output: 0 -> C3
	trisc = trisc & 0xF7;
0072  30F7  	MOVLW 0xF7
0073  1683  	BSF STATUS, RP0
0074  0507  	ANDWF gbl_trisc, W
0075  0087  	MOVWF gbl_trisc

	if ((0))
		portc = (portc & 0xF7) | 0x08;
	else
		portc = portc & 0xF7;
0076  30F7  	MOVLW 0xF7
0077  1283  	BCF STATUS, RP0
0078  0507  	ANDWF gbl_portc, W
0079  0087  	MOVWF gbl_portc


	//OE
	//Output: 0 -> C2
	trisc = trisc & 0xFB;
007A  30FB  	MOVLW 0xFB
007B  1683  	BSF STATUS, RP0
007C  0507  	ANDWF gbl_trisc, W
007D  0087  	MOVWF gbl_trisc

	if ((0))
		portc = (portc & 0xFB) | 0x04;
	else
		portc = portc & 0xFB;
007E  30FB  	MOVLW 0xFB
007F  1283  	BCF STATUS, RP0
0080  0507  	ANDWF gbl_portc, W
0081  0087  	MOVWF gbl_portc


	//Output
	//Output: 0 -> A4
	trisa = trisa & 0xEF;
0082  30EF  	MOVLW 0xEF
0083  1683  	BSF STATUS, RP0
0084  0505  	ANDWF gbl_trisa, W
0085  0085  	MOVWF gbl_trisa

	if ((0))
		porta = (porta & 0xEF) | 0x10;
	else
		porta = porta & 0xEF;
0086  30EF  	MOVLW 0xEF
0087  1283  	BCF STATUS, RP0
0088  0505  	ANDWF gbl_porta, W
0089  0085  	MOVWF gbl_porta


	//Output
	//Output: 1 -> A5
	trisa = trisa & 0xDF;
008A  30DF  	MOVLW 0xDF
008B  1683  	BSF STATUS, RP0
008C  0505  	ANDWF gbl_trisa, W
008D  0085  	MOVWF gbl_trisa

	if ((1))
		porta = (porta & 0xDF) | 0x20;
008E  30DF  	MOVLW 0xDF
008F  1283  	BCF STATUS, RP0
0090  0505  	ANDWF gbl_porta, W
0091  00CD  	MOVWF CompTempVar2245
0092  3020  	MOVLW 0x20
0093  044D  	IORWF CompTempVar2245, W
0094  0085  	MOVWF gbl_porta

	else
		porta = porta & 0xDF;

	//Loop
	//Loop: While 1
	while (1)
0095        label13
00E8  2895  	GOTO	label13

	{

		//Call Macro
		//Call Macro: stored_values()
		FCM_stored_values();
0095  201C  	CALL FCM_stored_00051


		//Loop
		//Loop: Loop 8 times
		for (FCLV_LOOP1=0; FCLV_LOOP1<8; FCLV_LOOP1++)
0096  01CC  	CLRF gbl_FCLV_LOOP1
0097        label14
0097  3008  	MOVLW 0x08
0098  024C  	SUBWF gbl_FCLV_LOOP1, W
0099  1803  	BTFSC STATUS,C
009A  28D2  	GOTO	label17
00D0  0ACC  	INCF gbl_FCLV_LOOP1, F
00D1  2897  	GOTO	label14
00D2        label17

		{

			//Calculation
			//Calculation:
			//  DAT = VALUE AND 1
			//  VALUE = VALUE >> 1
			FCV_DAT = FCV_VALUE & 1;
009B  3001  	MOVLW 0x01
009C  0548  	ANDWF gbl_FCV_VALUE, W
009D  00CD  	MOVWF CompTempVar2246
009E  01CE  	CLRF CompTempVar2247
009F  08CD  	MOVF CompTempVar2246, F
00A0  1D03  	BTFSS STATUS,Z
00A1  144E  	BSF CompTempVar2247,0
00A2  1044  	BCF gbl_FCV_DAT,0
00A3  084E  	MOVF CompTempVar2247, W
00A4  1D03  	BTFSS STATUS,Z
00A5  1444  	BSF gbl_FCV_DAT,0

			FCV_VALUE = FCV_VALUE >> 1;
00A6  08C8  	MOVF gbl_FCV_VALUE, F
00A7  1003  	BCF STATUS,C
00A8  0CC8  	RRF gbl_FCV_VALUE, F


			//DATA
			//Output: DAT -> C5
			trisc = trisc & 0xDF;
00A9  30DF  	MOVLW 0xDF
00AA  1683  	BSF STATUS, RP0
00AB  0507  	ANDWF gbl_trisc, W
00AC  0087  	MOVWF gbl_trisc

			if ((FCV_DAT))
00AD  1283  	BCF STATUS, RP0
00AE  1C44  	BTFSS gbl_FCV_DAT,0
00AF  28B7  	GOTO	label15
00B7        label15

				portc = (portc & 0xDF) | 0x20;
00B0  30DF  	MOVLW 0xDF
00B1  0507  	ANDWF gbl_portc, W
00B2  00CD  	MOVWF CompTempVar2249
00B3  3020  	MOVLW 0x20
00B4  044D  	IORWF CompTempVar2249, W
00B5  0087  	MOVWF gbl_portc

			else
00B6  28BA  	GOTO	label16
00BA        label16

				portc = portc & 0xDF;
00B7  30DF  	MOVLW 0xDF
00B8  0507  	ANDWF gbl_portc, W
00B9  0087  	MOVWF gbl_portc


			//CLK
			//Output: 0 -> C4
			trisc = trisc & 0xEF;
00BA  30EF  	MOVLW 0xEF
00BB  1683  	BSF STATUS, RP0
00BC  0507  	ANDWF gbl_trisc, W
00BD  0087  	MOVWF gbl_trisc

			if ((0))
				portc = (portc & 0xEF) | 0x10;
			else
				portc = portc & 0xEF;
00BE  30EF  	MOVLW 0xEF
00BF  1283  	BCF STATUS, RP0
00C0  0507  	ANDWF gbl_portc, W
00C1  0087  	MOVWF gbl_portc


			//Delay
			//Delay: 10 ms
			delay_ms(10);
00C2  300A  	MOVLW 0x0A
00C3  00CD  	MOVWF delay_ms_00000_arg_del
00C4  2010  	CALL delay_ms_00000


			//CLK
			//Output: 1 -> C4
			trisc = trisc & 0xEF;
00C5  30EF  	MOVLW 0xEF
00C6  1683  	BSF STATUS, RP0
00C7  0507  	ANDWF gbl_trisc, W
00C8  0087  	MOVWF gbl_trisc

			if ((1))
				portc = (portc & 0xEF) | 0x10;
00C9  30EF  	MOVLW 0xEF
00CA  1283  	BCF STATUS, RP0
00CB  0507  	ANDWF gbl_portc, W
00CC  00CD  	MOVWF CompTempVar2250
00CD  3010  	MOVLW 0x10
00CE  044D  	IORWF CompTempVar2250, W
00CF  0087  	MOVWF gbl_portc

			else
				portc = portc & 0xEF;


		}

		//REG
		//Output: 1 -> C3
		trisc = trisc & 0xF7;
00D2  30F7  	MOVLW 0xF7
00D3  1683  	BSF STATUS, RP0
00D4  0507  	ANDWF gbl_trisc, W
00D5  0087  	MOVWF gbl_trisc

		if ((1))
			portc = (portc & 0xF7) | 0x08;
00D6  30F7  	MOVLW 0xF7
00D7  1283  	BCF STATUS, RP0
00D8  0507  	ANDWF gbl_portc, W
00D9  00CD  	MOVWF CompTempVar2251
00DA  3008  	MOVLW 0x08
00DB  044D  	IORWF CompTempVar2251, W
00DC  0087  	MOVWF gbl_portc

		else
			portc = portc & 0xF7;

		//Delay
		//Delay: 1 ms
		delay_ms(1);
00DD  3001  	MOVLW 0x01
00DE  00CD  	MOVWF delay_ms_00000_arg_del
00DF  2010  	CALL delay_ms_00000


		//REG
		//Output: 0 -> C3
		trisc = trisc & 0xF7;
00E0  30F7  	MOVLW 0xF7
00E1  1683  	BSF STATUS, RP0
00E2  0507  	ANDWF gbl_trisc, W
00E3  0087  	MOVWF gbl_trisc

		if ((0))
			portc = (portc & 0xF7) | 0x08;
		else
			portc = portc & 0xF7;
00E4  30F7  	MOVLW 0xF7
00E5  1283  	BCF STATUS, RP0
00E6  0507  	ANDWF gbl_portc, W
00E7  0087  	MOVWF gbl_portc



	}

	mainendloop: goto mainendloop;
}


void MX_INTERRUPT_MACRO(void)

{
}
011A  1283  	BCF STATUS, RP0
011B  1303  	BCF STATUS, RP1
011C  0E36  	SWAPF Int1BContext+D'2', W
011D  0084  	MOVWF FSR
011E  0E35  	SWAPF Int1BContext+D'1', W
011F  008A  	MOVWF PCLATH
0120  0E34  	SWAPF Int1BContext, W
0121  0083  	MOVWF STATUS
0122  0EFF  	SWAPF Int1Context, F
0123  0E7F  	SWAPF Int1Context, W
0124  0009  	RETFIE





////////////////////////////////////////
// Code with no source :-)
////////////////////////////////////////
0000  28E9  	GOTO	_startup

0004  00FF  	MOVWF Int1Context
0005  0E03  	SWAPF STATUS, W
0006  1283  	BCF STATUS, RP0
0007  1303  	BCF STATUS, RP1
0008  00B4  	MOVWF Int1BContext
0009  0E0A  	SWAPF PCLATH, W
000A  00B5  	MOVWF Int1BContext+D'1'
000B  0E04  	SWAPF FSR, W
000C  00B6  	MOVWF Int1BContext+D'2'
000D  118A  	BCF PCLATH,3
000E  120A  	BCF PCLATH,4
000F  291A  	GOTO	interrupt
0010        delay_ms_00000
0010        ; { delay_ms ; function begin
0010  08CD  	MOVF delay_ms_00000_arg_del, F
0011  1D03  	BTFSS STATUS,Z
0012  2814  	GOTO	label1
0013  0008  	RETURN
0014        label1
0014  30F9  	MOVLW 0xF9
0015        label2
0015  3EFF  	ADDLW 0xFF
0016  1D03  	BTFSS STATUS,Z
0017  2815  	GOTO	label2
0018  0000  	NOP
0019  0BCD  	DECFSZ delay_ms_00000_arg_del, F
001A  2814  	GOTO	label1
001B  0008  	RETURN
001C        ; } delay_ms function end


00E9        _startup
00E9  30D5  	MOVLW 0xD5
00EA  1283  	BCF STATUS, RP0
00EB  1303  	BCF STATUS, RP1
00EC  00A0  	MOVWF gbl_14_LSR
00ED  30C4  	MOVLW 0xC4
00EE  00A1  	MOVWF gbl_14_LSR+D'1'
00EF  30BB  	MOVLW 0xBB
00F0  00A2  	MOVWF gbl_14_LSR+D'2'
00F1  30DC  	MOVLW 0xDC
00F2  00A3  	MOVWF gbl_14_LSR+D'3'
00F3  01A4  	CLRF gbl_15_gbl_aSig
00F4  01A5  	CLRF gbl_15_gbl_aSig+D'1'
00F5  01A6  	CLRF gbl_15_gbl_aSig+D'2'
00F6  01A7  	CLRF gbl_15_gbl_aSig+D'3'
00F7  01A8  	CLRF gbl_15_gbl_bSig
00F8  01A9  	CLRF gbl_15_gbl_bSig+D'1'
00F9  01AA  	CLRF gbl_15_gbl_bSig+D'2'
00FA  01AB  	CLRF gbl_15_gbl_bSig+D'3'
00FB  01AC  	CLRF gbl_15_gbl_zSig
00FC  01AD  	CLRF gbl_15_gbl_zSig+D'1'
00FD  01AE  	CLRF gbl_15_gbl_zSig+D'2'
00FE  01AF  	CLRF gbl_15_gbl_zSig+D'3'
00FF  01BE  	CLRF gbl_15_gbl_aExp
0100  01BF  	CLRF gbl_15_gbl_bExp
0101  01B7  	CLRF gbl_15_gbl_zExp
0102  01B8  	CLRF gbl_15_gbl_zExp+D'1'
0103  01C0  	CLRF gbl_15_gbl_aSign
0104  01C1  	CLRF gbl_15_gbl_bSign
0105  01C2  	CLRF gbl_15_gbl_zSign
0106  01C3  	CLRF gbl_15_gbl_zSigZero
0107  01B0  	CLRF gbl_15_gbl_ret
0108  01B1  	CLRF gbl_15_gbl_ret+D'1'
0109  01B2  	CLRF gbl_15_gbl_ret+D'2'
010A  01B3  	CLRF gbl_15_gbl_ret+D'3'
010B  01BC  	CLRF gbl_float_rounding_mode
010C  01BD  	CLRF gbl_float_exception_flags
010D  01BB  	CLRF gbl_float_detect_tininess

0117  118A  	BCF PCLATH,3
0118  120A  	BCF PCLATH,4
0119  285C  	GOTO	main

2007  30F4  	DW 0x30F4
