;/////////////////////////////////////////////////////////////////////////////////
;// Code Generator: BoostC Compiler - http://www.sourceboost.com
;// Version       : 7.03
;// License Type  : Pro License
;// Limitations   : PIC12,PIC16 max code size:Unlimited, max RAM banks:Unlimited
;/////////////////////////////////////////////////////////////////////////////////

//************************************************************************************
//**  
//**  File name:     D:\KennyNeutronsInnovations\NICE2018\Program\EMRA_FINAL.c
//**  Title:         
//**  Description:   
//**  
//**  Generated by:  Flowcode v5.2.0.0
//**  Date:          Wednesday, February 20, 2019 21:17:51
//**  Licence:       Professional
//**  Registered to: xyz
//**  Licence key:   WUK7B9
//**  
//**  
//**  http://www.matrixmultimedia.com
//**  
//************************************************************************************


#define MX_PIC

#define MX_USES_UINT8 1
#define MX_USES_SINT16 0
#define MX_USES_CHAR 0
#define MX_USES_FLOAT 0
#define MX_USES_SINT32 0
#define MX_USES_BOOL 1
#define MX_USES_UINT16 0
#define MX_USES_UINT32 0
//Defines for microcontroller
#define P16F688
#define FC_CAL_PIC
#define MX_ADC
#define MX_ADC_TYPE_3
#define MX_ADC_BITS_10
#define MX_EE
#define MX_EE_SIZE 256
#define MX_UART_1
#define MX_UART_1_TX_PORT portc
#define MX_UART_1_TX_TRIS trisc
#define MX_UART_1_TX_PIN 4
#define MX_UART_1_RX_PORT portc
#define MX_UART_1_RX_TRIS trisc
#define MX_UART_1_RX_PIN 5

//Functions
#define MX_CLK_SPEED 4000000
#ifdef _BOOSTC
#include <system.h>
#endif
#ifdef HI_TECH_C
#include <pic.h>
#endif

//Configuration data
#ifdef _BOOSTC
#pragma DATA 0x2007, 0x33f4
#endif
#ifdef HI_TECH_C
__CONFIG(0x33f4);
#endif

//Internal functions
#include "C:\Program Files (x86)\Flowcode\v5\FCD\internals.c"

//Macro function declarations
void FCM_int();
void FCM_Switch_Check();
void FCM_repel();


//Variable declarations
#define FCV_TRUE (1)
#define FCV_FALSE (0)
MX_BOOL FCV_SWITCH;
MX_UINT8 FCV_COUNTER = (0x0);
013F  01C3  	CLRF gbl_FCV_COUNTER

MX_BOOL FCV_FLAG;
MX_UINT8 FCV_NOTIF = (0x0);
0140  01C4  	CLRF gbl_FCV_NOTIF

MX_BOOL FCV_VC;

MX_UINT8 FCLV_LOOP1;



//LED(0): //Defines:

/**** Macro Substitutions ****
a = Unique Reference
b = LED Port Letter
c = LED Pin Number
d = LED Active Polarity
******************************/

#define LED_1__LED_PORT		portc
#define LED_1__LED_TRIS		trisc
#define LED_1__LED_PIN		5
#define LED_1__LED_POLE		0




//LED(0): //Macro function declarations

void FCD_LED0_LEDOn();
void FCD_LED0_LEDOff();


//LED(1): //Defines:

/**** Macro Substitutions ****
a = Unique Reference
b = LED Port Letter
c = LED Pin Number
d = LED Active Polarity
******************************/

#define LED_2__LED_PORT		portc
#define LED_2__LED_TRIS		trisc
#define LED_2__LED_PIN		4
#define LED_2__LED_POLE		0




//LED(1): //Macro function declarations

void FCD_LED1_LEDOn();
void FCD_LED1_LEDOff();



//LED(0): //Macro implementations


void FCD_LED0_LEDOn()

{
	
		#if( LED_1__LED_POLE == 1)									//Active high polarity
			FC_CAL_Bit_High_DDR( LED_1__LED_PORT , LED_1__LED_TRIS , LED_1__LED_PIN );
		#else													//Active low polarity
			FC_CAL_Bit_Low_DDR( LED_1__LED_PORT , LED_1__LED_TRIS , LED_1__LED_PIN );
007D  1683  	BSF STATUS, RP0
007E  1303  	BCF STATUS, RP1
007F  1287  	BCF gbl_trisc,5
0080  1283  	BCF STATUS, RP0
0081  1287  	BCF gbl_portc,5

		#endif

}
0082  0008  	RETURN


void FCD_LED0_LEDOff()

{
	
		#if( LED_1__LED_POLE == 1)									//Active high polarity
			FC_CAL_Bit_Low_DDR( LED_1__LED_PORT	, LED_1__LED_TRIS , LED_1__LED_PIN );
		#else													//Active low polarity
			FC_CAL_Bit_High_DDR( LED_1__LED_PORT , LED_1__LED_TRIS , LED_1__LED_PIN );
0077  1683  	BSF STATUS, RP0
0078  1303  	BCF STATUS, RP1
0079  1287  	BCF gbl_trisc,5
007A  1283  	BCF STATUS, RP0
007B  1687  	BSF gbl_portc,5

		#endif

}
007C  0008  	RETURN




//LED(1): //Macro implementations


void FCD_LED1_LEDOn()

{
	
		#if( LED_2__LED_POLE == 1)									//Active high polarity
			FC_CAL_Bit_High_DDR( LED_2__LED_PORT , LED_2__LED_TRIS , LED_2__LED_PIN );
		#else													//Active low polarity
			FC_CAL_Bit_Low_DDR( LED_2__LED_PORT , LED_2__LED_TRIS , LED_2__LED_PIN );
0071  1683  	BSF STATUS, RP0
0072  1303  	BCF STATUS, RP1
0073  1207  	BCF gbl_trisc,4
0074  1283  	BCF STATUS, RP0
0075  1207  	BCF gbl_portc,4

		#endif

}
0076  0008  	RETURN


void FCD_LED1_LEDOff()

{
	
		#if( LED_2__LED_POLE == 1)									//Active high polarity
			FC_CAL_Bit_Low_DDR( LED_2__LED_PORT	, LED_2__LED_TRIS , LED_2__LED_PIN );
		#else													//Active low polarity
			FC_CAL_Bit_High_DDR( LED_2__LED_PORT , LED_2__LED_TRIS , LED_2__LED_PIN );
006B  1683  	BSF STATUS, RP0
006C  1303  	BCF STATUS, RP1
006D  1207  	BCF gbl_trisc,4
006E  1283  	BCF STATUS, RP0
006F  1607  	BSF gbl_portc,4

		#endif

}
0070  0008  	RETURN


#include "C:\Program Files (x86)\Flowcode\v5\CAL\includes.c"

//Macro implementations


void FCM_int()

{

}
0035  0008  	RETURN



void FCM_Switch_Check()

{

	//Loop
	//Loop: While switch = 1
	while (!(FCV_SWITCH == 1))
0051        label5
0051  1283  	BCF STATUS, RP0
0052  1303  	BCF STATUS, RP1
0053  01C6  	CLRF CompTempVar2189
0054  1842  	BTFSC gbl_FCV_SWITCH,0
0055  0AC6  	INCF CompTempVar2189, F
0056  08C6  	MOVF CompTempVar2189, F
0057  1D03  	BTFSS STATUS,Z
006A  2851  	GOTO	label5

	{

		//Input
		//Input: A2 -> switch
		trisa = trisa | 0x04;
0059  3004  	MOVLW 0x04
005A  1683  	BSF STATUS, RP0
005B  0405  	IORWF gbl_trisa, W
005C  0085  	MOVWF gbl_trisa

		FCV_SWITCH = ((porta & 0x04) == 0x04);
005D  3004  	MOVLW 0x04
005E  1283  	BCF STATUS, RP0
005F  0505  	ANDWF gbl_porta, W
0060  00C7  	MOVWF CompTempVar2190
0061  01C8  	CLRF CompTempVar2191
0062  3004  	MOVLW 0x04
0063  0247  	SUBWF CompTempVar2190, W
0064  1903  	BTFSC STATUS,Z
0065  0AC8  	INCF CompTempVar2191, F
0066  1042  	BCF gbl_FCV_SWITCH,0
0067  0848  	MOVF CompTempVar2191, W
0068  1D03  	BTFSS STATUS,Z
0069  1442  	BSF gbl_FCV_SWITCH,0



	}

}
0058  0008  	RETURN



void FCM_repel()

{

	//Output
	//Output: 1 -> C3
	trisc = trisc & 0xF7;
0036  30F7  	MOVLW 0xF7
0037  1683  	BSF STATUS, RP0
0038  1303  	BCF STATUS, RP1
0039  0507  	ANDWF gbl_trisc, W
003A  0087  	MOVWF gbl_trisc

	if ((1))
		portc = (portc & 0xF7) | 0x08;
003B  30F7  	MOVLW 0xF7
003C  1283  	BCF STATUS, RP0
003D  0507  	ANDWF gbl_portc, W
003E  00C7  	MOVWF CompTempVar2192
003F  3008  	MOVLW 0x08
0040  0447  	IORWF CompTempVar2192, W
0041  0087  	MOVWF gbl_portc

	else
		portc = portc & 0xF7;

	//Delay
	//Delay: 3 us
	delay_us(3);
0042  3003  	MOVLW 0x03
0043  00C7  	MOVWF delay_us_00000_arg_del
0044  2010  	CALL delay_us_00000


	//Output
	//Output: 0 -> C3
	trisc = trisc & 0xF7;
0045  30F7  	MOVLW 0xF7
0046  1683  	BSF STATUS, RP0
0047  0507  	ANDWF gbl_trisc, W
0048  0087  	MOVWF gbl_trisc

	if ((0))
		portc = (portc & 0xF7) | 0x08;
	else
		portc = portc & 0xF7;
0049  30F7  	MOVLW 0xF7
004A  1283  	BCF STATUS, RP0
004B  0507  	ANDWF gbl_portc, W
004C  0087  	MOVWF gbl_portc


	//Delay
	//Delay: 3 us
	delay_us(3);
004D  3003  	MOVLW 0x03
004E  00C7  	MOVWF delay_us_00000_arg_del
004F  2010  	CALL delay_us_00000


}
0050  0008  	RETURN




void main()

{
	//Initialization
	ansel = 0x00;
0083  1683  	BSF STATUS, RP0
0084  1303  	BCF STATUS, RP1
0085  0191  	CLRF gbl_ansel

cmcon0 = 0x07;
0086  3007  	MOVLW 0x07
0087  1283  	BCF STATUS, RP0
0088  0099  	MOVWF gbl_cmcon0



	//Interrupt initialization code
	option_reg = 0xC0;
0089  30C0  	MOVLW 0xC0
008A  1683  	BSF STATUS, RP0
008B  0081  	MOVWF gbl_option_reg



	//Connection Point
	//Connection Point: [A]: A
FCC_Main_A:
;

	//Interrupt
	//Interrupt: Enable RB0INT
	st_bit(option_reg,INTEDG);
008C  1701  	BSF gbl_option_reg,6

	st_bit(intcon,GIE);
008D  178B  	BSF gbl_intcon,7

	st_bit(intcon, INTE);
008E  160B  	BSF gbl_intcon,4


	//Delay
	//Delay: 100 ms
	delay_ms(100);
008F  3064  	MOVLW 0x64
0090  1283  	BCF STATUS, RP0
0091  00C7  	MOVWF delay_ms_00000_arg_del
0092  201A  	CALL delay_ms_00000


	//C Code
	//C Code:
	/*
	  Enter C code below this comment
	*/
	sleep();
0093  0063  	SLEEP


	//Call Macro
	//Call Macro: Switch_Check()
	FCM_Switch_Check();
0094  2051  	CALL FCM_Switch_00051


	//Calculation
	//Calculation:
	//  switch = 1
	//  flag = 0
	FCV_SWITCH = 1;
0095  1442  	BSF gbl_FCV_SWITCH,0

	FCV_FLAG = 0;
0096  10C2  	BCF gbl_FCV_FLAG,1


	//Calculation
	//Calculation:
	//  counter = 0
	//  notif = 0
	FCV_COUNTER = 0;
0097  01C3  	CLRF gbl_FCV_COUNTER

	FCV_NOTIF = 0;
0098  01C4  	CLRF gbl_FCV_NOTIF


	//Loop
	//Loop: While 1
	while (1)
0099        label6

	{

		//Output
		//Output: 0 -> C1
		trisc = trisc & 0xFD;
0099  30FD  	MOVLW 0xFD
009A  1683  	BSF STATUS, RP0
009B  0507  	ANDWF gbl_trisc, W
009C  0087  	MOVWF gbl_trisc

		if ((0))
			portc = (portc & 0xFD) | 0x02;
		else
			portc = portc & 0xFD;
009D  30FD  	MOVLW 0xFD
009E  1283  	BCF STATUS, RP0
009F  0507  	ANDWF gbl_portc, W
00A0  0087  	MOVWF gbl_portc


		//Output
		//Output: 1 -> C2
		trisc = trisc & 0xFB;
00A1  30FB  	MOVLW 0xFB
00A2  1683  	BSF STATUS, RP0
00A3  0507  	ANDWF gbl_trisc, W
00A4  0087  	MOVWF gbl_trisc

		if ((1))
			portc = (portc & 0xFB) | 0x04;
00A5  30FB  	MOVLW 0xFB
00A6  1283  	BCF STATUS, RP0
00A7  0507  	ANDWF gbl_portc, W
00A8  00C6  	MOVWF CompTempVar2193
00A9  3004  	MOVLW 0x04
00AA  0446  	IORWF CompTempVar2193, W
00AB  0087  	MOVWF gbl_portc

		else
			portc = portc & 0xFB;

		//Input
		//Input: A2 -> switch
		trisa = trisa | 0x04;
00AC  3004  	MOVLW 0x04
00AD  1683  	BSF STATUS, RP0
00AE  0405  	IORWF gbl_trisa, W
00AF  0085  	MOVWF gbl_trisa

		FCV_SWITCH = ((porta & 0x04) == 0x04);
00B0  3004  	MOVLW 0x04
00B1  1283  	BCF STATUS, RP0
00B2  0505  	ANDWF gbl_porta, W
00B3  00C6  	MOVWF CompTempVar2194
00B4  01C7  	CLRF CompTempVar2195
00B5  3004  	MOVLW 0x04
00B6  0246  	SUBWF CompTempVar2194, W
00B7  1903  	BTFSC STATUS,Z
00B8  0AC7  	INCF CompTempVar2195, F
00B9  1042  	BCF gbl_FCV_SWITCH,0
00BA  0847  	MOVF CompTempVar2195, W
00BB  1D03  	BTFSS STATUS,Z
00BC  1442  	BSF gbl_FCV_SWITCH,0


		//Decision
		//Decision: switch = 0?
		if (FCV_SWITCH == 0)
00BD  1842  	BTFSC gbl_FCV_SWITCH,0
00BE  2900  	GOTO	label10
0100        label10

		{

			//Call Component Macro
			//Call Component Macro: LEDOn()
			FCD_LED1_LEDOn();
00BF  2071  	CALL FCD_LED1_L_00054


			//Delay
			//Delay: 2 s
			delay_s(2);
00C0  3002  	MOVLW 0x02
00C1  00C6  	MOVWF delay_s_00000_arg_del
00C2  2026  	CALL delay_s_00000


			//Input
			//Input: A2 -> switch
			trisa = trisa | 0x04;
00C3  3004  	MOVLW 0x04
00C4  1683  	BSF STATUS, RP0
00C5  0405  	IORWF gbl_trisa, W
00C6  0085  	MOVWF gbl_trisa

			FCV_SWITCH = ((porta & 0x04) == 0x04);
00C7  3004  	MOVLW 0x04
00C8  1283  	BCF STATUS, RP0
00C9  0505  	ANDWF gbl_porta, W
00CA  00C6  	MOVWF CompTempVar2196
00CB  01C7  	CLRF CompTempVar2197
00CC  3004  	MOVLW 0x04
00CD  0246  	SUBWF CompTempVar2196, W
00CE  1903  	BTFSC STATUS,Z
00CF  0AC7  	INCF CompTempVar2197, F
00D0  1042  	BCF gbl_FCV_SWITCH,0
00D1  0847  	MOVF CompTempVar2197, W
00D2  1D03  	BTFSS STATUS,Z
00D3  1442  	BSF gbl_FCV_SWITCH,0


			//Decision
			//Decision: switch = 0?
			if (FCV_SWITCH == 0)
00D4  1842  	BTFSC gbl_FCV_SWITCH,0
00D5  28FE  	GOTO	label9
00FE        label9

			{

				//Call Component Macro
				//Call Component Macro: LEDOn()
				FCD_LED0_LEDOn();
00D6  207D  	CALL FCD_LED0_L_00052


				//Delay
				//Delay: 1 s
				delay_s(1);
00D7  3001  	MOVLW 0x01
00D8  00C6  	MOVWF delay_s_00000_arg_del
00D9  2026  	CALL delay_s_00000


				//Call Component Macro
				//Call Component Macro: LEDOff()
				FCD_LED0_LEDOff();
00DA  2077  	CALL FCD_LED0_L_00053


				//Call Component Macro
				//Call Component Macro: LEDOff()
				FCD_LED1_LEDOff();
00DB  206B  	CALL FCD_LED1_L_00055


				//Call Macro
				//Call Macro: Switch_Check()
				FCM_Switch_Check();
00DC  2051  	CALL FCM_Switch_00051


				//Interrupt
				//Interrupt: Enable RB0INT
				st_bit(option_reg,INTEDG);
00DD  1683  	BSF STATUS, RP0
00DE  1701  	BSF gbl_option_reg,6

				st_bit(intcon,GIE);
00DF  178B  	BSF gbl_intcon,7

				st_bit(intcon, INTE);
00E0  160B  	BSF gbl_intcon,4


				//Delay
				//Delay: 3 s
				delay_s(3);
00E1  3003  	MOVLW 0x03
00E2  1283  	BCF STATUS, RP0
00E3  00C6  	MOVWF delay_s_00000_arg_del
00E4  2026  	CALL delay_s_00000


				//Call Component Macro
				//Call Component Macro: LEDOn()
				FCD_LED0_LEDOn();
00E5  207D  	CALL FCD_LED0_L_00052


				//Delay
				//Delay: 100 ms
				delay_ms(100);
00E6  3064  	MOVLW 0x64
00E7  00C7  	MOVWF delay_ms_00000_arg_del
00E8  201A  	CALL delay_ms_00000


				//Call Component Macro
				//Call Component Macro: LEDOff()
				FCD_LED0_LEDOff();
00E9  2077  	CALL FCD_LED0_L_00053


				//C Code
				//C Code:
				/*
				  Enter C code below this comment
				*/
				sleep();
00EA  0063  	SLEEP


				//Loop
				//Loop: Loop 10 times
				for (FCLV_LOOP1=0; FCLV_LOOP1<10; FCLV_LOOP1++)
00EB  01C5  	CLRF gbl_FCLV_LOOP1
00EC        label7
00EC  300A  	MOVLW 0x0A
00ED  0245  	SUBWF gbl_FCLV_LOOP1, W
00EE  1803  	BTFSC STATUS,C
00EF  28FA  	GOTO	label8
00F8  0AC5  	INCF gbl_FCLV_LOOP1, F
00F9  28EC  	GOTO	label7
00FA        label8
0119  2901  	GOTO	label11

				{

					//Call Component Macro
					//Call Component Macro: LEDOn()
					FCD_LED1_LEDOn();
00F0  2071  	CALL FCD_LED1_L_00054


					//Delay
					//Delay: 100 ms
					delay_ms(100);
00F1  3064  	MOVLW 0x64
00F2  00C7  	MOVWF delay_ms_00000_arg_del
00F3  201A  	CALL delay_ms_00000


					//Call Component Macro
					//Call Component Macro: LEDOff()
					FCD_LED1_LEDOff();
00F4  206B  	CALL FCD_LED1_L_00055


					//Delay
					//Delay: 100 ms
					delay_ms(100);
00F5  3064  	MOVLW 0x64
00F6  00C7  	MOVWF delay_ms_00000_arg_del
00F7  201A  	CALL delay_ms_00000



				}

				//Call Macro
				//Call Macro: Switch_Check()
				FCM_Switch_Check();
00FA  2051  	CALL FCM_Switch_00051


				//Calculation
				//Calculation:
				//  counter = 0
				//  notif = 0
				FCV_COUNTER = 0;
00FB  01C3  	CLRF gbl_FCV_COUNTER

				FCV_NOTIF = 0;
00FC  01C4  	CLRF gbl_FCV_NOTIF


			} else {
00FD  2899  	GOTO	label6


				//Call Component Macro
				//Call Component Macro: LEDOff()
				FCD_LED1_LEDOff();
00FE  206B  	CALL FCD_LED1_L_00055


			}

		} else {
00FF  2899  	GOTO	label6


			//Interrupt
			//Interrupt: Disable RB0INT
			cr_bit(intcon, INTE);
0100  120B  	BCF gbl_intcon,4


			//Loop
			//Loop: While switch = 0
			while (!(FCV_SWITCH == 0))
0101        label11
0101  01C6  	CLRF CompTempVar2199
0102  1C42  	BTFSS gbl_FCV_SWITCH,0
0103  0AC6  	INCF CompTempVar2199, F
0104  08C6  	MOVF CompTempVar2199, F
0105  1D03  	BTFSS STATUS,Z
0106  2899  	GOTO	label6

			{

				//Call Macro
				//Call Macro: repel()
				FCM_repel();
0107  2036  	CALL FCM_repel_00000


				//Input
				//Input: A2 -> switch
				trisa = trisa | 0x04;
0108  3004  	MOVLW 0x04
0109  1683  	BSF STATUS, RP0
010A  0405  	IORWF gbl_trisa, W
010B  0085  	MOVWF gbl_trisa

				FCV_SWITCH = ((porta & 0x04) == 0x04);
010C  3004  	MOVLW 0x04
010D  1283  	BCF STATUS, RP0
010E  0505  	ANDWF gbl_porta, W
010F  00C7  	MOVWF CompTempVar2200
0110  01C8  	CLRF CompTempVar2201
0111  3004  	MOVLW 0x04
0112  0247  	SUBWF CompTempVar2200, W
0113  1903  	BTFSC STATUS,Z
0114  0AC8  	INCF CompTempVar2201, F
0115  1042  	BCF gbl_FCV_SWITCH,0
0116  0848  	MOVF CompTempVar2201, W
0117  1D03  	BTFSS STATUS,Z
0118  1442  	BSF gbl_FCV_SWITCH,0



			}

		}


	}

	mainendloop: goto mainendloop;
}


void MX_INTERRUPT_MACRO(void)

{
	//Handler code for [RB0INT]
	#ifndef MX_INTHANDLER_intcon_INTF
	#define MX_INTHANDLER_intcon_INTF
	if (ts_bit(intcon, INTF) && ts_bit(intcon, INTE))
0144  1C8B  	BTFSS gbl_intcon,1
0145  294A  	GOTO	label13
0146  1E0B  	BTFSS gbl_intcon,4
0147  294A  	GOTO	label13
014A        label13

	{
		#ifdef USE_FLOWCODE_ICD
			extern char ICD_Interrupt_Enable = 1;
		#endif	
		FCM_int();
0148  2035  	CALL FCM_int_00000

		cr_bit(intcon, INTF);
0149  108B  	BCF gbl_intcon,1

		#ifdef USE_FLOWCODE_ICD
			extern char ICD_Interrupt_Enable = 0;
		#endif	
	}
	#else
	#warning "This interrupt has previously been enabled, so the macro <int> may never get called."
	#endif


	//Handler code for [RB0INT]
	#ifndef MX_INTHANDLER_intcon_INTF
	#define MX_INTHANDLER_intcon_INTF
	if (ts_bit(intcon, INTF) && ts_bit(intcon, INTE))
	{
		#ifdef USE_FLOWCODE_ICD
			extern char ICD_Interrupt_Enable = 1;
		#endif	
		FCM_int();
		cr_bit(intcon, INTF);
		#ifdef USE_FLOWCODE_ICD
			extern char ICD_Interrupt_Enable = 0;
		#endif	
	}
	#else
	#warning "This interrupt has previously been enabled, so the macro <int> may never get called."
	#endif


}
014A  1283  	BCF STATUS, RP0
014B  1303  	BCF STATUS, RP1
014C  0E36  	SWAPF Int1BContext+D'2', W
014D  0084  	MOVWF FSR
014E  0E35  	SWAPF Int1BContext+D'1', W
014F  008A  	MOVWF PCLATH
0150  0E34  	SWAPF Int1BContext, W
0151  0083  	MOVWF STATUS
0152  0EFF  	SWAPF Int1Context, F
0153  0E7F  	SWAPF Int1Context, W
0154  0009  	RETFIE





////////////////////////////////////////
// Code with no source :-)
////////////////////////////////////////
0000  291A  	GOTO	_startup

0004  00FF  	MOVWF Int1Context
0005  0E03  	SWAPF STATUS, W
0006  1283  	BCF STATUS, RP0
0007  1303  	BCF STATUS, RP1
0008  00B4  	MOVWF Int1BContext
0009  0E0A  	SWAPF PCLATH, W
000A  00B5  	MOVWF Int1BContext+D'1'
000B  0E04  	SWAPF FSR, W
000C  00B6  	MOVWF Int1BContext+D'2'
000D  118A  	BCF PCLATH,3
000E  120A  	BCF PCLATH,4
000F  2944  	GOTO	interrupt
0010        delay_us_00000
0010        ; { delay_us ; function begin
0010  3003  	MOVLW 0x03
0011  07C7  	ADDWF delay_us_00000_arg_del, F
0012  0CC7  	RRF delay_us_00000_arg_del, F
0013  0CC7  	RRF delay_us_00000_arg_del, F
0014  307F  	MOVLW 0x7F
0015  05C7  	ANDWF delay_us_00000_arg_del, F
0016        label1
0016  0000  	NOP
0017  0BC7  	DECFSZ delay_us_00000_arg_del, F
0018  2816  	GOTO	label1
0019  0008  	RETURN
001A        ; } delay_us function end

001A        delay_ms_00000
001A        ; { delay_ms ; function begin
001A  08C7  	MOVF delay_ms_00000_arg_del, F
001B  1D03  	BTFSS STATUS,Z
001C  281E  	GOTO	label2
001D  0008  	RETURN
001E        label2
001E  30F9  	MOVLW 0xF9
001F        label3
001F  3EFF  	ADDLW 0xFF
0020  1D03  	BTFSS STATUS,Z
0021  281F  	GOTO	label3
0022  0000  	NOP
0023  0BC7  	DECFSZ delay_ms_00000_arg_del, F
0024  281E  	GOTO	label2
0025  0008  	RETURN
0026        ; } delay_ms function end

0026        delay_s_00000
0026        ; { delay_s ; function begin
0026        label4
0026  30FA  	MOVLW 0xFA
0027  00C7  	MOVWF delay_ms_00000_arg_del
0028  201A  	CALL delay_ms_00000
0029  30FA  	MOVLW 0xFA
002A  00C7  	MOVWF delay_ms_00000_arg_del
002B  201A  	CALL delay_ms_00000
002C  30FA  	MOVLW 0xFA
002D  00C7  	MOVWF delay_ms_00000_arg_del
002E  201A  	CALL delay_ms_00000
002F  30FA  	MOVLW 0xFA
0030  00C7  	MOVWF delay_ms_00000_arg_del
0031  201A  	CALL delay_ms_00000
0032  0BC6  	DECFSZ delay_s_00000_arg_del, F
0033  2826  	GOTO	label4
0034  0008  	RETURN
0035        ; } delay_s function end


011A        _startup
011A  30D5  	MOVLW 0xD5
011B  1283  	BCF STATUS, RP0
011C  1303  	BCF STATUS, RP1
011D  00A0  	MOVWF gbl_14_LSR
011E  30C4  	MOVLW 0xC4
011F  00A1  	MOVWF gbl_14_LSR+D'1'
0120  30BB  	MOVLW 0xBB
0121  00A2  	MOVWF gbl_14_LSR+D'2'
0122  30DC  	MOVLW 0xDC
0123  00A3  	MOVWF gbl_14_LSR+D'3'
0124  01A4  	CLRF gbl_15_gbl_aSig
0125  01A5  	CLRF gbl_15_gbl_aSig+D'1'
0126  01A6  	CLRF gbl_15_gbl_aSig+D'2'
0127  01A7  	CLRF gbl_15_gbl_aSig+D'3'
0128  01A8  	CLRF gbl_15_gbl_bSig
0129  01A9  	CLRF gbl_15_gbl_bSig+D'1'
012A  01AA  	CLRF gbl_15_gbl_bSig+D'2'
012B  01AB  	CLRF gbl_15_gbl_bSig+D'3'
012C  01AC  	CLRF gbl_15_gbl_zSig
012D  01AD  	CLRF gbl_15_gbl_zSig+D'1'
012E  01AE  	CLRF gbl_15_gbl_zSig+D'2'
012F  01AF  	CLRF gbl_15_gbl_zSig+D'3'
0130  01BC  	CLRF gbl_15_gbl_aExp
0131  01BD  	CLRF gbl_15_gbl_bExp
0132  01B7  	CLRF gbl_15_gbl_zExp
0133  01B8  	CLRF gbl_15_gbl_zExp+D'1'
0134  01BE  	CLRF gbl_15_gbl_aSign
0135  01BF  	CLRF gbl_15_gbl_bSign
0136  01C0  	CLRF gbl_15_gbl_zSign
0137  01C1  	CLRF gbl_15_gbl_zSigZero
0138  01B0  	CLRF gbl_15_gbl_ret
0139  01B1  	CLRF gbl_15_gbl_ret+D'1'
013A  01B2  	CLRF gbl_15_gbl_ret+D'2'
013B  01B3  	CLRF gbl_15_gbl_ret+D'3'
013C  01BA  	CLRF gbl_float_rounding_mode
013D  01BB  	CLRF gbl_float_exception_flags
013E  01B9  	CLRF gbl_float_detect_tininess

0141  118A  	BCF PCLATH,3
0142  120A  	BCF PCLATH,4
0143  2883  	GOTO	main

2007  33F4  	DW 0x33F4
