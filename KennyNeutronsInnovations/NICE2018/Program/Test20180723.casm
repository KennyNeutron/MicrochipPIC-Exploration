;/////////////////////////////////////////////////////////////////////////////////
;// Code Generator: BoostC Compiler - http://www.sourceboost.com
;// Version       : 7.03
;// License Type  : Pro License
;// Limitations   : PIC12,PIC16 max code size:Unlimited, max RAM banks:Unlimited
;/////////////////////////////////////////////////////////////////////////////////

//************************************************************************************
//**  
//**  File name:     C:\Users\BlueFlame17\Desktop\NICE2018\Program\Test20180723.c
//**  Title:         
//**  Description:   
//**  
//**  Generated by:  Flowcode v5.5.2.1
//**  Date:          Tuesday, July 31, 2018 02:33:47
//**  Licence:       Professional
//**  Registered to: xyz
//**  Licence key:   WUK7B9
//**  
//**  
//**  http://www.matrixmultimedia.com
//**  
//************************************************************************************


#define MX_PIC

#define MX_USES_UINT8 1
#define MX_USES_SINT16 0
#define MX_USES_CHAR 0
#define MX_USES_FLOAT 0
#define MX_USES_SINT32 0
#define MX_USES_BOOL 1
#define MX_USES_UINT16 0
#define MX_USES_UINT32 0
//Defines for microcontroller
#define P16F690
#define FC_CAL_PIC
#define MX_ADC
#define MX_ADC_TYPE_3
#define MX_ADC_BITS_10
#define MX_EE
#define MX_EE_TYPE2
#define MX_EE_SIZE 256
#define MX_SPI_1
#define MX_SPI_1_MISO_PORT portb
#define MX_SPI_1_MISO_TRIS trisb
#define MX_SPI_1_MISO_PIN 4
#define MX_SPI_1_MOSI_PORT portc
#define MX_SPI_1_MOSI_TRIS trisc
#define MX_SPI_1_MOSI_PIN 7
#define MX_SPI_1_CLK_PORT portb
#define MX_SPI_1_CLK_TRIS trisb
#define MX_SPI_1_CLK_PIN 6
#define MX_SPI_1_SS_PORT portb
#define MX_SPI_1_SS_TRIS trisb
#define MX_UART_1
#define MX_UART_1_TX_PORT portb
#define MX_UART_1_TX_TRIS trisb
#define MX_UART_1_TX_PIN 7
#define MX_UART_1_RX_PORT portb
#define MX_UART_1_RX_TRIS trisb
#define MX_UART_1_RX_PIN 5
#define MX_I2C
#define MX_MI2C
#define MX_I2C_1
#define MX_I2C_1_SDA_PORT portb
#define MX_I2C_1_SDA_TRIS trisb
#define MX_I2C_1_SDA_PIN 4
#define MX_I2C_1_SCL_PORT portb
#define MX_I2C_1_SCL_TRIS trisb
#define MX_I2C_1_SCL_PIN 6
#define MX_PWM
#define MX_PWM_CNT 1
#define MX_PWM_PSCA1
#define MX_PWM_PSCA4
#define MX_PWM_PSCA16
#define MX_PWM_1_PORT portc
#define MX_PWM_1_TRIS trisc
#define MX_PWM_1_PIN 5

//Functions
#define MX_CLK_SPEED 4000000
#ifdef _BOOSTC
#include <system.h>
#endif
#ifdef HI_TECH_C
#include <pic.h>
#endif

//Configuration data
#ifdef _BOOSTC
#pragma DATA 0x2007, 0x33f4
#endif
#ifdef HI_TECH_C
__CONFIG(0x33f4);
#endif

//Internal functions
#include "C:\Program Files\Flowcode\v5\FCD\internals.c"

//Macro function declarations
void FCM_int();
void FCM_Switch_Check();
void FCM_repel();


//Variable declarations
#define FCV_FALSE (0)
#define FCV_TRUE (1)
MX_BOOL FCV_SWITCH;
MX_UINT8 FCV_COUNTER = (0x0);
01EC  01C3  	CLRF gbl_FCV_COUNTER

MX_BOOL FCV_FLAG;
MX_UINT8 FCV_NOTIF = (0x0);
01ED  01C4  	CLRF gbl_FCV_NOTIF

MX_BOOL FCV_VC = (0);
01EE  1142  	BCF gbl_FCV_VC,2


MX_UINT8 FCLV_LOOP1;
MX_UINT8 FCLV_LOOP2;
MX_UINT8 FCLV_LOOP3;
MX_UINT8 FCLV_LOOP4;



//LED(0): //Defines:

/**** Macro Substitutions ****
a = Unique Reference
b = LED Port Letter
c = LED Pin Number
d = LED Active Polarity
******************************/

#define LED_1__LED_PORT		portc
#define LED_1__LED_TRIS		trisc
#define LED_1__LED_PIN		5
#define LED_1__LED_POLE		1




//LED(0): //Macro function declarations

void FCD_LED0_LEDOn();
void FCD_LED0_LEDOff();


//LED(1): //Defines:

/**** Macro Substitutions ****
a = Unique Reference
b = LED Port Letter
c = LED Pin Number
d = LED Active Polarity
******************************/

#define LED_2__LED_PORT		portc
#define LED_2__LED_TRIS		trisc
#define LED_2__LED_PIN		4
#define LED_2__LED_POLE		1




//LED(1): //Macro function declarations

void FCD_LED1_LEDOn();
void FCD_LED1_LEDOff();



//LED(0): //Macro implementations


void FCD_LED0_LEDOn()

{
	
		#if( LED_1__LED_POLE == 1)									//Active high polarity
			FC_CAL_Bit_High_DDR( LED_1__LED_PORT , LED_1__LED_TRIS , LED_1__LED_PIN );
007D  1683  	BSF STATUS, RP0
007E  1303  	BCF STATUS, RP1
007F  1287  	BCF gbl_trisc,5
0080  1283  	BCF STATUS, RP0
0081  1687  	BSF gbl_portc,5

		#else													//Active low polarity
			FC_CAL_Bit_Low_DDR( LED_1__LED_PORT , LED_1__LED_TRIS , LED_1__LED_PIN );
		#endif

}
0082  0008  	RETURN


void FCD_LED0_LEDOff()

{
	
		#if( LED_1__LED_POLE == 1)									//Active high polarity
			FC_CAL_Bit_Low_DDR( LED_1__LED_PORT	, LED_1__LED_TRIS , LED_1__LED_PIN );
0077  1683  	BSF STATUS, RP0
0078  1303  	BCF STATUS, RP1
0079  1287  	BCF gbl_trisc,5
007A  1283  	BCF STATUS, RP0
007B  1287  	BCF gbl_portc,5

		#else													//Active low polarity
			FC_CAL_Bit_High_DDR( LED_1__LED_PORT , LED_1__LED_TRIS , LED_1__LED_PIN );
		#endif

}
007C  0008  	RETURN




//LED(1): //Macro implementations


void FCD_LED1_LEDOn()

{
	
		#if( LED_2__LED_POLE == 1)									//Active high polarity
			FC_CAL_Bit_High_DDR( LED_2__LED_PORT , LED_2__LED_TRIS , LED_2__LED_PIN );
0071  1683  	BSF STATUS, RP0
0072  1303  	BCF STATUS, RP1
0073  1207  	BCF gbl_trisc,4
0074  1283  	BCF STATUS, RP0
0075  1607  	BSF gbl_portc,4

		#else													//Active low polarity
			FC_CAL_Bit_Low_DDR( LED_2__LED_PORT , LED_2__LED_TRIS , LED_2__LED_PIN );
		#endif

}
0076  0008  	RETURN


void FCD_LED1_LEDOff()

{
	
		#if( LED_2__LED_POLE == 1)									//Active high polarity
			FC_CAL_Bit_Low_DDR( LED_2__LED_PORT	, LED_2__LED_TRIS , LED_2__LED_PIN );
006B  1683  	BSF STATUS, RP0
006C  1303  	BCF STATUS, RP1
006D  1207  	BCF gbl_trisc,4
006E  1283  	BCF STATUS, RP0
006F  1207  	BCF gbl_portc,4

		#else													//Active low polarity
			FC_CAL_Bit_High_DDR( LED_2__LED_PORT , LED_2__LED_TRIS , LED_2__LED_PIN );
		#endif

}
0070  0008  	RETURN


#include "C:\Program Files\Flowcode\v5\CAL\includes.c"

//Macro implementations


void FCM_int()

{

}
0035  0008  	RETURN



void FCM_Switch_Check()

{

	//Loop
	//Loop: While switch = 1
	while (!(FCV_SWITCH == 1))
0051        label5
0051  1283  	BCF STATUS, RP0
0052  1303  	BCF STATUS, RP1
0053  01C9  	CLRF CompTempVar2195
0054  1842  	BTFSC gbl_FCV_SWITCH,0
0055  0AC9  	INCF CompTempVar2195, F
0056  08C9  	MOVF CompTempVar2195, F
0057  1D03  	BTFSS STATUS,Z
006A  2851  	GOTO	label5

	{

		//Input
		//Input: A2 -> switch
		trisa = trisa | 0x04;
0059  3004  	MOVLW 0x04
005A  1683  	BSF STATUS, RP0
005B  0405  	IORWF gbl_trisa, W
005C  0085  	MOVWF gbl_trisa

		FCV_SWITCH = ((porta & 0x04) == 0x04);
005D  3004  	MOVLW 0x04
005E  1283  	BCF STATUS, RP0
005F  0505  	ANDWF gbl_porta, W
0060  00CA  	MOVWF CompTempVar2196
0061  01CB  	CLRF CompTempVar2197
0062  3004  	MOVLW 0x04
0063  024A  	SUBWF CompTempVar2196, W
0064  1903  	BTFSC STATUS,Z
0065  0ACB  	INCF CompTempVar2197, F
0066  1042  	BCF gbl_FCV_SWITCH,0
0067  084B  	MOVF CompTempVar2197, W
0068  1D03  	BTFSS STATUS,Z
0069  1442  	BSF gbl_FCV_SWITCH,0



	}

}
0058  0008  	RETURN



void FCM_repel()

{

	//Output
	//Output: 1 -> C5
	trisc = trisc & 0xDF;
0036  30DF  	MOVLW 0xDF
0037  1683  	BSF STATUS, RP0
0038  1303  	BCF STATUS, RP1
0039  0507  	ANDWF gbl_trisc, W
003A  0087  	MOVWF gbl_trisc

	if ((1))
		portc = (portc & 0xDF) | 0x20;
003B  30DF  	MOVLW 0xDF
003C  1283  	BCF STATUS, RP0
003D  0507  	ANDWF gbl_portc, W
003E  00CA  	MOVWF CompTempVar2198
003F  3020  	MOVLW 0x20
0040  044A  	IORWF CompTempVar2198, W
0041  0087  	MOVWF gbl_portc

	else
		portc = portc & 0xDF;

	//Delay
	//Delay: 15 us
	delay_us(15);
0042  300F  	MOVLW 0x0F
0043  00CA  	MOVWF delay_us_00000_arg_del
0044  2010  	CALL delay_us_00000


	//Output
	//Output: 0 -> C5
	trisc = trisc & 0xDF;
0045  30DF  	MOVLW 0xDF
0046  1683  	BSF STATUS, RP0
0047  0507  	ANDWF gbl_trisc, W
0048  0087  	MOVWF gbl_trisc

	if ((0))
		portc = (portc & 0xDF) | 0x20;
	else
		portc = portc & 0xDF;
0049  30DF  	MOVLW 0xDF
004A  1283  	BCF STATUS, RP0
004B  0507  	ANDWF gbl_portc, W
004C  0087  	MOVWF gbl_portc


	//Delay
	//Delay: 15 us
	delay_us(15);
004D  300F  	MOVLW 0x0F
004E  00CA  	MOVWF delay_us_00000_arg_del
004F  2010  	CALL delay_us_00000


}
0050  0008  	RETURN




void main()

{
	//Initialization
	ansel = 0;
0083  1283  	BCF STATUS, RP0
0084  1703  	BSF STATUS, RP1
0085  019E  	CLRF gbl_ansel

anselh = 0;
0086  019F  	CLRF gbl_anselh



	//Interrupt initialization code
	option_reg = 0xC0;
0087  30C0  	MOVLW 0xC0
0088  1683  	BSF STATUS, RP0
0089  1303  	BCF STATUS, RP1
008A  0081  	MOVWF gbl_option_reg



	//Connection Point
	//Connection Point: [A]: A
FCC_Main_A:
;

	//Interrupt
	//Interrupt: Enable GP2INT
	st_bit(option_reg,INTEDG);
008B  1701  	BSF gbl_option_reg,6

	st_bit(intcon,GIE);
008C  178B  	BSF gbl_intcon,7

	st_bit(intcon, INTE);
008D  160B  	BSF gbl_intcon,4


	//Delay
	//Delay: 100 ms
	delay_ms(100);
008E  3064  	MOVLW 0x64
008F  1283  	BCF STATUS, RP0
0090  00CA  	MOVWF delay_ms_00000_arg_del
0091  201A  	CALL delay_ms_00000


	//C Code
	//C Code:
	/*
	  Enter C code below this comment
	*/
	sleep();
0092  0063  	SLEEP


	//Call Macro
	//Call Macro: Switch_Check()
	FCM_Switch_Check();
0093  2051  	CALL FCM_Switch_00051


	//Calculation
	//Calculation:
	//  switch = 1
	//  flag = 0
	FCV_SWITCH = 1;
0094  1442  	BSF gbl_FCV_SWITCH,0

	FCV_FLAG = 0;
0095  10C2  	BCF gbl_FCV_FLAG,1


	//Calculation
	//Calculation:
	//  counter = 0
	//  notif = 0
	FCV_COUNTER = 0;
0096  01C3  	CLRF gbl_FCV_COUNTER

	FCV_NOTIF = 0;
0097  01C4  	CLRF gbl_FCV_NOTIF


	//Loop
	//Loop: While 1
	while (1)
0098        label6

	{

		//Decision
		//Decision: flag = 0?
		if (FCV_FLAG == 0)
0098  18C2  	BTFSC gbl_FCV_FLAG,1
0099  2946  	GOTO	label17
009A        label7
0146        label17

		{

			//Connection Point
			//Connection Point: [B]: B
FCC_Main_B:

;

			//Loop
			//Loop: Loop 5 times
			for (FCLV_LOOP2=0; FCLV_LOOP2<5; FCLV_LOOP2++)
009A  01C6  	CLRF gbl_FCLV_LOOP2
009B        label8
009B  3005  	MOVLW 0x05
009C  0246  	SUBWF gbl_FCLV_LOOP2, W
009D  1803  	BTFSC STATUS,C
009E  28B0  	GOTO	label9
00AE  0AC6  	INCF gbl_FCLV_LOOP2, F
00AF  289B  	GOTO	label8
00B0        label9
010C  28CD  	GOTO	label10
0145  2898  	GOTO	label6
01C6  29AE  	GOTO	label22

			{

				//Call Component Macro
				//Call Component Macro: LEDOn()
				FCD_LED0_LEDOn();
009F  207D  	CALL FCD_LED0_L_00052


				//Call Component Macro
				//Call Component Macro: LEDOff()
				FCD_LED1_LEDOff();
00A0  206B  	CALL FCD_LED1_L_00055


				//Delay
				//Delay: 300 ms
				delay_ms(255);
00A1  30FF  	MOVLW 0xFF
00A2  00CA  	MOVWF delay_ms_00000_arg_del
00A3  201A  	CALL delay_ms_00000

				delay_ms(45);
00A4  302D  	MOVLW 0x2D
00A5  00CA  	MOVWF delay_ms_00000_arg_del
00A6  201A  	CALL delay_ms_00000


				//Call Component Macro
				//Call Component Macro: LEDOff()
				FCD_LED0_LEDOff();
00A7  2077  	CALL FCD_LED0_L_00053


				//Delay
				//Delay: 300 ms
				delay_ms(255);
00A8  30FF  	MOVLW 0xFF
00A9  00CA  	MOVWF delay_ms_00000_arg_del
00AA  201A  	CALL delay_ms_00000

				delay_ms(45);
00AB  302D  	MOVLW 0x2D
00AC  00CA  	MOVWF delay_ms_00000_arg_del
00AD  201A  	CALL delay_ms_00000



			}

			//Interrupt
			//Interrupt: Enable GP2INT
			st_bit(option_reg,INTEDG);
00B0  1683  	BSF STATUS, RP0
00B1  1701  	BSF gbl_option_reg,6

			st_bit(intcon,GIE);
00B2  178B  	BSF gbl_intcon,7

			st_bit(intcon, INTE);
00B3  160B  	BSF gbl_intcon,4


			//C Code
			//C Code:
			/*
			  Enter C code below this comment
			*/
			sleep();
00B4  0063  	SLEEP


			//Call Component Macro
			//Call Component Macro: LEDOn()
			FCD_LED0_LEDOn();
00B5  207D  	CALL FCD_LED0_L_00052


			//Delay
			//Delay: 1 s
			delay_s(1);
00B6  3001  	MOVLW 0x01
00B7  00C9  	MOVWF delay_s_00000_arg_del
00B8  2026  	CALL delay_s_00000


			//Input
			//Input: A2 -> switch
			trisa = trisa | 0x04;
00B9  3004  	MOVLW 0x04
00BA  1683  	BSF STATUS, RP0
00BB  0405  	IORWF gbl_trisa, W
00BC  0085  	MOVWF gbl_trisa

			FCV_SWITCH = ((porta & 0x04) == 0x04);
00BD  3004  	MOVLW 0x04
00BE  1283  	BCF STATUS, RP0
00BF  0505  	ANDWF gbl_porta, W
00C0  00C9  	MOVWF CompTempVar2199
00C1  01CA  	CLRF CompTempVar2200
00C2  3004  	MOVLW 0x04
00C3  0249  	SUBWF CompTempVar2199, W
00C4  1903  	BTFSC STATUS,Z
00C5  0ACA  	INCF CompTempVar2200, F
00C6  1042  	BCF gbl_FCV_SWITCH,0
00C7  084A  	MOVF CompTempVar2200, W
00C8  1D03  	BTFSS STATUS,Z
00C9  1442  	BSF gbl_FCV_SWITCH,0


			//Decision
			//Decision: switch = 0?
			if (FCV_SWITCH == 0)
00CA  1842  	BTFSC gbl_FCV_SWITCH,0
00CB  289A  	GOTO	label7

			{

				//Loop
				//Loop: Loop 15 times
				for (FCLV_LOOP3=0; FCLV_LOOP3<15; FCLV_LOOP3++)
00CC  01C7  	CLRF gbl_FCLV_LOOP3
00CD        label10
00CD  300F  	MOVLW 0x0F
00CE  0247  	SUBWF gbl_FCLV_LOOP3, W
00CF  1803  	BTFSC STATUS,C
00D0  289A  	GOTO	label7
00D1        label11
010B  0AC7  	INCF gbl_FCLV_LOOP3, F

				{

					//Loop
					//Loop: While switch = 0
					while (FCV_SWITCH == 0)
00D1  1842  	BTFSC gbl_FCV_SWITCH,0
00D2  290B  	GOTO	label13
010A  28D1  	GOTO	label11
010B        label13

					{

						//Input
						//Input: A2 -> switch
						trisa = trisa | 0x04;
00D3  3004  	MOVLW 0x04
00D4  1683  	BSF STATUS, RP0
00D5  0405  	IORWF gbl_trisa, W
00D6  0085  	MOVWF gbl_trisa

						FCV_SWITCH = ((porta & 0x04) == 0x04);
00D7  3004  	MOVLW 0x04
00D8  1283  	BCF STATUS, RP0
00D9  0505  	ANDWF gbl_porta, W
00DA  00C9  	MOVWF CompTempVar2201
00DB  01CA  	CLRF CompTempVar2202
00DC  3004  	MOVLW 0x04
00DD  0249  	SUBWF CompTempVar2201, W
00DE  1903  	BTFSC STATUS,Z
00DF  0ACA  	INCF CompTempVar2202, F
00E0  1042  	BCF gbl_FCV_SWITCH,0
00E1  084A  	MOVF CompTempVar2202, W
00E2  1D03  	BTFSS STATUS,Z
00E3  1442  	BSF gbl_FCV_SWITCH,0


						//Input
						//Input: B6 -> VC
						trisb = trisb | 0x40;
00E4  3040  	MOVLW 0x40
00E5  1683  	BSF STATUS, RP0
00E6  0406  	IORWF gbl_trisb, W
00E7  0086  	MOVWF gbl_trisb

						FCV_VC = ((portb & 0x40) == 0x40);
00E8  3040  	MOVLW 0x40
00E9  1283  	BCF STATUS, RP0
00EA  0506  	ANDWF gbl_portb, W
00EB  00C9  	MOVWF CompTempVar2203
00EC  01CA  	CLRF CompTempVar2204
00ED  3040  	MOVLW 0x40
00EE  0249  	SUBWF CompTempVar2203, W
00EF  1903  	BTFSC STATUS,Z
00F0  0ACA  	INCF CompTempVar2204, F
00F1  1142  	BCF gbl_FCV_VC,2
00F2  084A  	MOVF CompTempVar2204, W
00F3  1D03  	BTFSS STATUS,Z
00F4  1542  	BSF gbl_FCV_VC,2


						//Decision
						//Decision: VC = 1?
						if (FCV_VC == 1)
00F5  1D42  	BTFSS gbl_FCV_VC,2
00F6  2900  	GOTO	label12
0100        label12

						{

							//Call Component Macro
							//Call Component Macro: LEDOn()
							FCD_LED0_LEDOn();
00F7  207D  	CALL FCD_LED0_L_00052


							//Call Component Macro
							//Call Component Macro: LEDOn()
							FCD_LED1_LEDOn();
00F8  2071  	CALL FCD_LED1_L_00054


							//Call Macro
							//Call Macro: Switch_Check()
							FCM_Switch_Check();
00F9  2051  	CALL FCM_Switch_00051


							//Delay
							//Delay: 1 ms
							delay_ms(1);
00FA  3001  	MOVLW 0x01
00FB  00CA  	MOVWF delay_ms_00000_arg_del
00FC  201A  	CALL delay_ms_00000


							//Call Component Macro
							//Call Component Macro: LEDOff()
							FCD_LED0_LEDOff();
00FD  2077  	CALL FCD_LED0_L_00053


							//Call Component Macro
							//Call Component Macro: LEDOff()
							FCD_LED1_LEDOff();
00FE  206B  	CALL FCD_LED1_L_00055


							//Goto Connection Point
							//Goto Connection Point: [C]: C
							goto FCC_Main_C;
00FF  290D  	GOTO	label14


						// } else {

						}

						//Call Component Macro
						//Call Component Macro: LEDOff()
						FCD_LED0_LEDOff();
0100  2077  	CALL FCD_LED0_L_00053


						//Call Component Macro
						//Call Component Macro: LEDOn()
						FCD_LED1_LEDOn();
0101  2071  	CALL FCD_LED1_L_00054


						//Delay
						//Delay: 200 ms
						delay_ms(200);
0102  30C8  	MOVLW 0xC8
0103  00CA  	MOVWF delay_ms_00000_arg_del
0104  201A  	CALL delay_ms_00000


						//Call Component Macro
						//Call Component Macro: LEDOn()
						FCD_LED0_LEDOn();
0105  207D  	CALL FCD_LED0_L_00052


						//Call Component Macro
						//Call Component Macro: LEDOff()
						FCD_LED1_LEDOff();
0106  206B  	CALL FCD_LED1_L_00055


						//Delay
						//Delay: 200 ms
						delay_ms(200);
0107  30C8  	MOVLW 0xC8
0108  00CA  	MOVWF delay_ms_00000_arg_del
0109  201A  	CALL delay_ms_00000



					}


				}

				//Goto Connection Point
				//Goto Connection Point: [B]: B
				goto FCC_Main_B;

				//Connection Point
				//Connection Point: [C]: C
FCC_Main_C:
010D        label14

;

				//Loop
				//Loop: Loop 10 times
				for (FCLV_LOOP4=0; FCLV_LOOP4<10; FCLV_LOOP4++)
010D  01C8  	CLRF gbl_FCLV_LOOP4
010E        label15
010E  300A  	MOVLW 0x0A
010F  0248  	SUBWF gbl_FCLV_LOOP4, W
0110  1803  	BTFSC STATUS,C
0111  291E  	GOTO	label16
011C  0AC8  	INCF gbl_FCLV_LOOP4, F
011D  290E  	GOTO	label15
011E        label16

				{

					//Call Component Macro
					//Call Component Macro: LEDOn()
					FCD_LED0_LEDOn();
0112  207D  	CALL FCD_LED0_L_00052


					//Call Component Macro
					//Call Component Macro: LEDOff()
					FCD_LED1_LEDOff();
0113  206B  	CALL FCD_LED1_L_00055


					//Delay
					//Delay: 100 ms
					delay_ms(100);
0114  3064  	MOVLW 0x64
0115  00CA  	MOVWF delay_ms_00000_arg_del
0116  201A  	CALL delay_ms_00000


					//Call Component Macro
					//Call Component Macro: LEDOff()
					FCD_LED0_LEDOff();
0117  2077  	CALL FCD_LED0_L_00053


					//Call Component Macro
					//Call Component Macro: LEDOn()
					FCD_LED1_LEDOn();
0118  2071  	CALL FCD_LED1_L_00054


					//Delay
					//Delay: 100 ms
					delay_ms(100);
0119  3064  	MOVLW 0x64
011A  00CA  	MOVWF delay_ms_00000_arg_del
011B  201A  	CALL delay_ms_00000



				}

				//Call Component Macro
				//Call Component Macro: LEDOn()
				FCD_LED0_LEDOn();
011E  207D  	CALL FCD_LED0_L_00052


				//Call Component Macro
				//Call Component Macro: LEDOn()
				FCD_LED1_LEDOn();
011F  2071  	CALL FCD_LED1_L_00054


				//Delay
				//Delay: 1 s
				delay_s(1);
0120  3001  	MOVLW 0x01
0121  00C9  	MOVWF delay_s_00000_arg_del
0122  2026  	CALL delay_s_00000


				//Call Component Macro
				//Call Component Macro: LEDOff()
				FCD_LED0_LEDOff();
0123  2077  	CALL FCD_LED0_L_00053


				//Call Component Macro
				//Call Component Macro: LEDOff()
				FCD_LED1_LEDOff();
0124  206B  	CALL FCD_LED1_L_00055


				//Interrupt
				//Interrupt: Enable GP2INT
				st_bit(option_reg,INTEDG);
0125  1683  	BSF STATUS, RP0
0126  1701  	BSF gbl_option_reg,6

				st_bit(intcon,GIE);
0127  178B  	BSF gbl_intcon,7

				st_bit(intcon, INTE);
0128  160B  	BSF gbl_intcon,4


				//C Code
				//C Code:
				/*
				  Enter C code below this comment
				*/
				sleep();
0129  0063  	SLEEP


				//Input
				//Input: B6 -> VC
				trisb = trisb | 0x40;
012A  3040  	MOVLW 0x40
012B  0406  	IORWF gbl_trisb, W
012C  0086  	MOVWF gbl_trisb

				FCV_VC = ((portb & 0x40) == 0x40);
012D  3040  	MOVLW 0x40
012E  1283  	BCF STATUS, RP0
012F  0506  	ANDWF gbl_portb, W
0130  00C9  	MOVWF CompTempVar2205
0131  01CA  	CLRF CompTempVar2206
0132  3040  	MOVLW 0x40
0133  0249  	SUBWF CompTempVar2205, W
0134  1903  	BTFSC STATUS,Z
0135  0ACA  	INCF CompTempVar2206, F
0136  1142  	BCF gbl_FCV_VC,2
0137  084A  	MOVF CompTempVar2206, W
0138  1D03  	BTFSS STATUS,Z
0139  1542  	BSF gbl_FCV_VC,2


				//Decision
				//Decision: VC = 1?
				if (FCV_VC == 1)
013A  1942  	BTFSC gbl_FCV_VC,2

				{

					//Goto Connection Point
					//Goto Connection Point: [C]: C
					goto FCC_Main_C;
013B  290D  	GOTO	label14


				} else {

					//Calculation
					//Calculation:
					//  flag = 1
					FCV_FLAG = 1;
013C  14C2  	BSF gbl_FCV_FLAG,1


					//Call Component Macro
					//Call Component Macro: LEDOn()
					FCD_LED1_LEDOn();
013D  2071  	CALL FCD_LED1_L_00054


					//Delay
					//Delay: 2 s
					delay_s(2);
013E  3002  	MOVLW 0x02
013F  00C9  	MOVWF delay_s_00000_arg_del
0140  2026  	CALL delay_s_00000


					//Call Macro
					//Call Macro: Switch_Check()
					FCM_Switch_Check();
0141  2051  	CALL FCM_Switch_00051


					//Call Component Macro
					//Call Component Macro: LEDOff()
					FCD_LED1_LEDOff();
0142  206B  	CALL FCD_LED1_L_00055


					//Calculation
					//Calculation:
					//  counter = 0
					//  notif = 0
					FCV_COUNTER = 0;
0143  01C3  	CLRF gbl_FCV_COUNTER

					FCV_NOTIF = 0;
0144  01C4  	CLRF gbl_FCV_NOTIF


				}

			} else {

				//Goto Connection Point
				//Goto Connection Point: [B]: B
				goto FCC_Main_B;


			}

		} else {

			//Input
			//Input: B6 -> VC
			trisb = trisb | 0x40;
0146  3040  	MOVLW 0x40
0147  1683  	BSF STATUS, RP0
0148  0406  	IORWF gbl_trisb, W
0149  0086  	MOVWF gbl_trisb

			FCV_VC = ((portb & 0x40) == 0x40);
014A  3040  	MOVLW 0x40
014B  1283  	BCF STATUS, RP0
014C  0506  	ANDWF gbl_portb, W
014D  00C9  	MOVWF CompTempVar2207
014E  01CA  	CLRF CompTempVar2208
014F  3040  	MOVLW 0x40
0150  0249  	SUBWF CompTempVar2207, W
0151  1903  	BTFSC STATUS,Z
0152  0ACA  	INCF CompTempVar2208, F
0153  1142  	BCF gbl_FCV_VC,2
0154  084A  	MOVF CompTempVar2208, W
0155  1D03  	BTFSS STATUS,Z
0156  1542  	BSF gbl_FCV_VC,2


			//Decision
			//Decision: VC = 1?
			if (FCV_VC == 1)
0157  1942  	BTFSC gbl_FCV_VC,2

			{

				//Goto Connection Point
				//Goto Connection Point: [C]: C
				goto FCC_Main_C;
0158  290D  	GOTO	label14


			} else {

				//Input
				//Input: A2 -> switch
				trisa = trisa | 0x04;
0159  3004  	MOVLW 0x04
015A  1683  	BSF STATUS, RP0
015B  0405  	IORWF gbl_trisa, W
015C  0085  	MOVWF gbl_trisa

				FCV_SWITCH = ((porta & 0x04) == 0x04);
015D  3004  	MOVLW 0x04
015E  1283  	BCF STATUS, RP0
015F  0505  	ANDWF gbl_porta, W
0160  00C9  	MOVWF CompTempVar2209
0161  01CA  	CLRF CompTempVar2210
0162  3004  	MOVLW 0x04
0163  0249  	SUBWF CompTempVar2209, W
0164  1903  	BTFSC STATUS,Z
0165  0ACA  	INCF CompTempVar2210, F
0166  1042  	BCF gbl_FCV_SWITCH,0
0167  084A  	MOVF CompTempVar2210, W
0168  1D03  	BTFSS STATUS,Z
0169  1442  	BSF gbl_FCV_SWITCH,0


				//Decision
				//Decision: switch = 0?
				if (FCV_SWITCH == 0)
016A  1842  	BTFSC gbl_FCV_SWITCH,0
016B  29AD  	GOTO	label21
01AD        label21

				{

					//Call Component Macro
					//Call Component Macro: LEDOn()
					FCD_LED1_LEDOn();
016C  2071  	CALL FCD_LED1_L_00054


					//Delay
					//Delay: 2 s
					delay_s(2);
016D  3002  	MOVLW 0x02
016E  00C9  	MOVWF delay_s_00000_arg_del
016F  2026  	CALL delay_s_00000


					//Input
					//Input: A2 -> switch
					trisa = trisa | 0x04;
0170  3004  	MOVLW 0x04
0171  1683  	BSF STATUS, RP0
0172  0405  	IORWF gbl_trisa, W
0173  0085  	MOVWF gbl_trisa

					FCV_SWITCH = ((porta & 0x04) == 0x04);
0174  3004  	MOVLW 0x04
0175  1283  	BCF STATUS, RP0
0176  0505  	ANDWF gbl_porta, W
0177  00C9  	MOVWF CompTempVar2211
0178  01CA  	CLRF CompTempVar2212
0179  3004  	MOVLW 0x04
017A  0249  	SUBWF CompTempVar2211, W
017B  1903  	BTFSC STATUS,Z
017C  0ACA  	INCF CompTempVar2212, F
017D  1042  	BCF gbl_FCV_SWITCH,0
017E  084A  	MOVF CompTempVar2212, W
017F  1D03  	BTFSS STATUS,Z
0180  1442  	BSF gbl_FCV_SWITCH,0


					//Decision
					//Decision: switch = 0?
					if (FCV_SWITCH == 0)
0181  1842  	BTFSC gbl_FCV_SWITCH,0
0182  29AB  	GOTO	label20
01AB        label20

					{

						//Call Component Macro
						//Call Component Macro: LEDOn()
						FCD_LED0_LEDOn();
0183  207D  	CALL FCD_LED0_L_00052


						//Delay
						//Delay: 1 s
						delay_s(1);
0184  3001  	MOVLW 0x01
0185  00C9  	MOVWF delay_s_00000_arg_del
0186  2026  	CALL delay_s_00000


						//Call Component Macro
						//Call Component Macro: LEDOff()
						FCD_LED0_LEDOff();
0187  2077  	CALL FCD_LED0_L_00053


						//Call Component Macro
						//Call Component Macro: LEDOff()
						FCD_LED1_LEDOff();
0188  206B  	CALL FCD_LED1_L_00055


						//Call Macro
						//Call Macro: Switch_Check()
						FCM_Switch_Check();
0189  2051  	CALL FCM_Switch_00051


						//Interrupt
						//Interrupt: Enable GP2INT
						st_bit(option_reg,INTEDG);
018A  1683  	BSF STATUS, RP0
018B  1701  	BSF gbl_option_reg,6

						st_bit(intcon,GIE);
018C  178B  	BSF gbl_intcon,7

						st_bit(intcon, INTE);
018D  160B  	BSF gbl_intcon,4


						//Delay
						//Delay: 3 s
						delay_s(3);
018E  3003  	MOVLW 0x03
018F  1283  	BCF STATUS, RP0
0190  00C9  	MOVWF delay_s_00000_arg_del
0191  2026  	CALL delay_s_00000


						//Call Component Macro
						//Call Component Macro: LEDOn()
						FCD_LED0_LEDOn();
0192  207D  	CALL FCD_LED0_L_00052


						//Delay
						//Delay: 100 ms
						delay_ms(100);
0193  3064  	MOVLW 0x64
0194  00CA  	MOVWF delay_ms_00000_arg_del
0195  201A  	CALL delay_ms_00000


						//Call Component Macro
						//Call Component Macro: LEDOff()
						FCD_LED0_LEDOff();
0196  2077  	CALL FCD_LED0_L_00053


						//C Code
						//C Code:
						/*
						  Enter C code below this comment
						*/
						sleep();
0197  0063  	SLEEP


						//Loop
						//Loop: Loop 10 times
						for (FCLV_LOOP1=0; FCLV_LOOP1<10; FCLV_LOOP1++)
0198  01C5  	CLRF gbl_FCLV_LOOP1
0199        label18
0199  300A  	MOVLW 0x0A
019A  0245  	SUBWF gbl_FCLV_LOOP1, W
019B  1803  	BTFSC STATUS,C
019C  29A7  	GOTO	label19
01A5  0AC5  	INCF gbl_FCLV_LOOP1, F
01A6  2999  	GOTO	label18
01A7        label19

						{

							//Call Component Macro
							//Call Component Macro: LEDOn()
							FCD_LED1_LEDOn();
019D  2071  	CALL FCD_LED1_L_00054


							//Delay
							//Delay: 100 ms
							delay_ms(100);
019E  3064  	MOVLW 0x64
019F  00CA  	MOVWF delay_ms_00000_arg_del
01A0  201A  	CALL delay_ms_00000


							//Call Component Macro
							//Call Component Macro: LEDOff()
							FCD_LED1_LEDOff();
01A1  206B  	CALL FCD_LED1_L_00055


							//Delay
							//Delay: 100 ms
							delay_ms(100);
01A2  3064  	MOVLW 0x64
01A3  00CA  	MOVWF delay_ms_00000_arg_del
01A4  201A  	CALL delay_ms_00000



						}

						//Call Macro
						//Call Macro: Switch_Check()
						FCM_Switch_Check();
01A7  2051  	CALL FCM_Switch_00051


						//Calculation
						//Calculation:
						//  counter = 0
						//  notif = 0
						FCV_COUNTER = 0;
01A8  01C3  	CLRF gbl_FCV_COUNTER

						FCV_NOTIF = 0;
01A9  01C4  	CLRF gbl_FCV_NOTIF


					} else {
01AA  2898  	GOTO	label6


						//Call Component Macro
						//Call Component Macro: LEDOff()
						FCD_LED1_LEDOff();
01AB  206B  	CALL FCD_LED1_L_00055


					}

				} else {
01AC  2898  	GOTO	label6


					//Interrupt
					//Interrupt: Disable GP2INT
					cr_bit(intcon, INTE);
01AD  120B  	BCF gbl_intcon,4


					//Loop
					//Loop: While switch = 0
					while (!(FCV_SWITCH == 0))
01AE        label22
01AE  01C9  	CLRF CompTempVar2214
01AF  1C42  	BTFSS gbl_FCV_SWITCH,0
01B0  0AC9  	INCF CompTempVar2214, F
01B1  08C9  	MOVF CompTempVar2214, F
01B2  1D03  	BTFSS STATUS,Z
01B3  2898  	GOTO	label6

					{

						//Call Macro
						//Call Macro: repel()
						FCM_repel();
01B4  2036  	CALL FCM_repel_00000


						//Input
						//Input: A2 -> switch
						trisa = trisa | 0x04;
01B5  3004  	MOVLW 0x04
01B6  1683  	BSF STATUS, RP0
01B7  0405  	IORWF gbl_trisa, W
01B8  0085  	MOVWF gbl_trisa

						FCV_SWITCH = ((porta & 0x04) == 0x04);
01B9  3004  	MOVLW 0x04
01BA  1283  	BCF STATUS, RP0
01BB  0505  	ANDWF gbl_porta, W
01BC  00CA  	MOVWF CompTempVar2215
01BD  01CB  	CLRF CompTempVar2216
01BE  3004  	MOVLW 0x04
01BF  024A  	SUBWF CompTempVar2215, W
01C0  1903  	BTFSC STATUS,Z
01C1  0ACB  	INCF CompTempVar2216, F
01C2  1042  	BCF gbl_FCV_SWITCH,0
01C3  084B  	MOVF CompTempVar2216, W
01C4  1D03  	BTFSS STATUS,Z
01C5  1442  	BSF gbl_FCV_SWITCH,0



					}

				}

			}

		}


	}

	mainendloop: goto mainendloop;
}


void MX_INTERRUPT_MACRO(void)

{
	//Handler code for [GP2INT]
	#ifndef MX_INTHANDLER_intcon_INTF
	#define MX_INTHANDLER_intcon_INTF
	if (ts_bit(intcon, INTF) && ts_bit(intcon, INTE))
01F2  1C8B  	BTFSS gbl_intcon,1
01F3  29F8  	GOTO	label24
01F4  1E0B  	BTFSS gbl_intcon,4
01F5  29F8  	GOTO	label24
01F8        label24

	{
		#ifdef USE_FLOWCODE_ICD
			extern char ICD_Interrupt_Enable = 1;
		#endif	
		FCM_int();
01F6  2035  	CALL FCM_int_00000

		cr_bit(intcon, INTF);
01F7  108B  	BCF gbl_intcon,1

		#ifdef USE_FLOWCODE_ICD
			extern char ICD_Interrupt_Enable = 0;
		#endif	
	}
	#else
	#warning "This interrupt has previously been enabled, so the macro <int> may never get called."
	#endif


	//Handler code for [GP2INT]
	#ifndef MX_INTHANDLER_intcon_INTF
	#define MX_INTHANDLER_intcon_INTF
	if (ts_bit(intcon, INTF) && ts_bit(intcon, INTE))
	{
		#ifdef USE_FLOWCODE_ICD
			extern char ICD_Interrupt_Enable = 1;
		#endif	
		FCM_int();
		cr_bit(intcon, INTF);
		#ifdef USE_FLOWCODE_ICD
			extern char ICD_Interrupt_Enable = 0;
		#endif	
	}
	#else
	#warning "This interrupt has previously been enabled, so the macro <int> may never get called."
	#endif


	//Handler code for [GP2INT]
	#ifndef MX_INTHANDLER_intcon_INTF
	#define MX_INTHANDLER_intcon_INTF
	if (ts_bit(intcon, INTF) && ts_bit(intcon, INTE))
	{
		#ifdef USE_FLOWCODE_ICD
			extern char ICD_Interrupt_Enable = 1;
		#endif	
		FCM_int();
		cr_bit(intcon, INTF);
		#ifdef USE_FLOWCODE_ICD
			extern char ICD_Interrupt_Enable = 0;
		#endif	
	}
	#else
	#warning "This interrupt has previously been enabled, so the macro <int> may never get called."
	#endif


	//Handler code for [GP2INT]
	#ifndef MX_INTHANDLER_intcon_INTF
	#define MX_INTHANDLER_intcon_INTF
	if (ts_bit(intcon, INTF) && ts_bit(intcon, INTE))
	{
		#ifdef USE_FLOWCODE_ICD
			extern char ICD_Interrupt_Enable = 1;
		#endif	
		FCM_int();
		cr_bit(intcon, INTF);
		#ifdef USE_FLOWCODE_ICD
			extern char ICD_Interrupt_Enable = 0;
		#endif	
	}
	#else
	#warning "This interrupt has previously been enabled, so the macro <int> may never get called."
	#endif


}
01F8  1283  	BCF STATUS, RP0
01F9  1303  	BCF STATUS, RP1
01FA  0E36  	SWAPF Int1BContext+D'2', W
01FB  0084  	MOVWF FSR
01FC  0E35  	SWAPF Int1BContext+D'1', W
01FD  008A  	MOVWF PCLATH
01FE  0E34  	SWAPF Int1BContext, W
01FF  0083  	MOVWF STATUS
0200  0EFF  	SWAPF Int1Context, F
0201  0E7F  	SWAPF Int1Context, W
0202  0009  	RETFIE





////////////////////////////////////////
// Code with no source :-)
////////////////////////////////////////
0000  29C7  	GOTO	_startup

0004  00FF  	MOVWF Int1Context
0005  0E03  	SWAPF STATUS, W
0006  1283  	BCF STATUS, RP0
0007  1303  	BCF STATUS, RP1
0008  00B4  	MOVWF Int1BContext
0009  0E0A  	SWAPF PCLATH, W
000A  00B5  	MOVWF Int1BContext+D'1'
000B  0E04  	SWAPF FSR, W
000C  00B6  	MOVWF Int1BContext+D'2'
000D  118A  	BCF PCLATH,3
000E  120A  	BCF PCLATH,4
000F  29F2  	GOTO	interrupt
0010        delay_us_00000
0010        ; { delay_us ; function begin
0010  3003  	MOVLW 0x03
0011  07CA  	ADDWF delay_us_00000_arg_del, F
0012  0CCA  	RRF delay_us_00000_arg_del, F
0013  0CCA  	RRF delay_us_00000_arg_del, F
0014  307F  	MOVLW 0x7F
0015  05CA  	ANDWF delay_us_00000_arg_del, F
0016        label1
0016  0000  	NOP
0017  0BCA  	DECFSZ delay_us_00000_arg_del, F
0018  2816  	GOTO	label1
0019  0008  	RETURN
001A        ; } delay_us function end

001A        delay_ms_00000
001A        ; { delay_ms ; function begin
001A  08CA  	MOVF delay_ms_00000_arg_del, F
001B  1D03  	BTFSS STATUS,Z
001C  281E  	GOTO	label2
001D  0008  	RETURN
001E        label2
001E  30F9  	MOVLW 0xF9
001F        label3
001F  3EFF  	ADDLW 0xFF
0020  1D03  	BTFSS STATUS,Z
0021  281F  	GOTO	label3
0022  0000  	NOP
0023  0BCA  	DECFSZ delay_ms_00000_arg_del, F
0024  281E  	GOTO	label2
0025  0008  	RETURN
0026        ; } delay_ms function end

0026        delay_s_00000
0026        ; { delay_s ; function begin
0026        label4
0026  30FA  	MOVLW 0xFA
0027  00CA  	MOVWF delay_ms_00000_arg_del
0028  201A  	CALL delay_ms_00000
0029  30FA  	MOVLW 0xFA
002A  00CA  	MOVWF delay_ms_00000_arg_del
002B  201A  	CALL delay_ms_00000
002C  30FA  	MOVLW 0xFA
002D  00CA  	MOVWF delay_ms_00000_arg_del
002E  201A  	CALL delay_ms_00000
002F  30FA  	MOVLW 0xFA
0030  00CA  	MOVWF delay_ms_00000_arg_del
0031  201A  	CALL delay_ms_00000
0032  0BC9  	DECFSZ delay_s_00000_arg_del, F
0033  2826  	GOTO	label4
0034  0008  	RETURN
0035        ; } delay_s function end


01C7        _startup
01C7  30D5  	MOVLW 0xD5
01C8  1283  	BCF STATUS, RP0
01C9  1303  	BCF STATUS, RP1
01CA  00A0  	MOVWF gbl_14_LSR
01CB  30C4  	MOVLW 0xC4
01CC  00A1  	MOVWF gbl_14_LSR+D'1'
01CD  30BB  	MOVLW 0xBB
01CE  00A2  	MOVWF gbl_14_LSR+D'2'
01CF  30DC  	MOVLW 0xDC
01D0  00A3  	MOVWF gbl_14_LSR+D'3'
01D1  01A4  	CLRF gbl_15_gbl_aSig
01D2  01A5  	CLRF gbl_15_gbl_aSig+D'1'
01D3  01A6  	CLRF gbl_15_gbl_aSig+D'2'
01D4  01A7  	CLRF gbl_15_gbl_aSig+D'3'
01D5  01A8  	CLRF gbl_15_gbl_bSig
01D6  01A9  	CLRF gbl_15_gbl_bSig+D'1'
01D7  01AA  	CLRF gbl_15_gbl_bSig+D'2'
01D8  01AB  	CLRF gbl_15_gbl_bSig+D'3'
01D9  01AC  	CLRF gbl_15_gbl_zSig
01DA  01AD  	CLRF gbl_15_gbl_zSig+D'1'
01DB  01AE  	CLRF gbl_15_gbl_zSig+D'2'
01DC  01AF  	CLRF gbl_15_gbl_zSig+D'3'
01DD  01BC  	CLRF gbl_15_gbl_aExp
01DE  01BD  	CLRF gbl_15_gbl_bExp
01DF  01B7  	CLRF gbl_15_gbl_zExp
01E0  01B8  	CLRF gbl_15_gbl_zExp+D'1'
01E1  01BE  	CLRF gbl_15_gbl_aSign
01E2  01BF  	CLRF gbl_15_gbl_bSign
01E3  01C0  	CLRF gbl_15_gbl_zSign
01E4  01C1  	CLRF gbl_15_gbl_zSigZero
01E5  01B0  	CLRF gbl_15_gbl_ret
01E6  01B1  	CLRF gbl_15_gbl_ret+D'1'
01E7  01B2  	CLRF gbl_15_gbl_ret+D'2'
01E8  01B3  	CLRF gbl_15_gbl_ret+D'3'
01E9  01BA  	CLRF gbl_float_rounding_mode
01EA  01BB  	CLRF gbl_float_exception_flags
01EB  01B9  	CLRF gbl_float_detect_tininess

01EF  118A  	BCF PCLATH,3
01F0  120A  	BCF PCLATH,4
01F1  2883  	GOTO	main

2007  33F4  	DW 0x33F4
