;/////////////////////////////////////////////////////////////////////////////////
;// Code Generator: BoostC Compiler - http://www.sourceboost.com
;// Version       : 7.03
;// License Type  : Pro License
;// Limitations   : PIC12,PIC16 max code size:Unlimited, max RAM banks:Unlimited
;/////////////////////////////////////////////////////////////////////////////////

/*********************************************************************
 *                  Flowcode CAL String File
 *
 * File: PIC_CAL_String.c
 *
 * (c) 2011 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * “Company”) for its Flowcode graphical programming language is
 * intended and supplied to you, the Company’s customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 010911 | BR | Created
 * 150911 | JW | Added v5 string functions
 * 270212 | BR | Fixed an issue with ToUpper where the 1st character was being returned as null
 * 120312 | BR | Fixed an issue with some of the float functions not using CAL functions
 */


// Useful call for finding the length of an (uncorrupted) string
#define FCI_GETLENGTH__x(str, max, idx)         for (idx = 0; idx < max; idx++) if (str[idx] == 0) break
#define FCI_STRMOV__x(str, max, dst, dlen, ix)  for (ix = 0; ix < (max) && ix < (dlen) && str[ix] != '\0'; ix++) dst[ix] = str[ix]
#define FCI_CONCATENATE(s0, l0, s1, l1, sd, ld) FCI_SHEAD(s0, l0, s1, l1, sd, ld)


#ifndef MX_USES_UINT32
	#define MX_USES_UINT32 0
#endif
#ifndef MX_USES_SINT32
	#define MX_USES_SINT32 0
#endif


#if (MX_USES_UINT32 || MX_USES_SINT32)
	#define MX_STRF_LONG
	#define MX_ULONG MX_UINT32
	#define MX_SLONG MX_SINT32
#else
	#define MX_ULONG MX_UINT16
	#define MX_SLONG MX_SINT16
#endif


//String function definitions
MX_UINT8 FCI_GETCHAR(MX_STRING sStr1, MX_UINT8 iStr1_len, MX_UINT8 iPos);
MX_UINT8 FCI_GETLENGTH(MX_STRING sStr1, MX_UINT8 iStr1_len);
MX_UINT8 FCI_MIDSTRING(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_UINT8 iStart, MX_UINT8 iCount, MX_STRING sDst, MX_UINT8 iDst_len);
MX_UINT8 FCI_LEFTSTRING(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_UINT8 iCount, MX_STRING sDst, MX_UINT8 iDst_len);
MX_UINT8 FCI_RIGHTSTRING(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_UINT8 iCount, MX_STRING sDst, MX_UINT8 iDst_len);
MX_UINT8 FCI_TOSTRING(MX_SLONG iSrc1, MX_STRING sDst, MX_UINT8 iDst_len);
void FCI_TOLOWER(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len);
void FCI_TOUPPER(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len);
MX_UINT8 FCI_COMPARE(MX_STRING sSrc1, MX_UINT8 iSrc1_len, MX_STRING sSrc2, MX_UINT8 iSrc2_len, MX_UINT8 iNoCase);
MX_UINT8 FCI_FLOAT_TO_STRING(MX_FLOAT Number, MX_UINT8 Precision, MX_STRING String, MX_UINT8 MSZ_String);
MX_UINT8 FCI_NUMBER_TO_HEX(MX_ULONG Number, MX_STRING String, MX_UINT8 MSZ_String);
MX_SINT32 FCI_STRING_TO_INT(MX_STRING String, MX_UINT8 MSZ_String);
MX_FLOAT FCI_STRING_TO_FLOAT(MX_STRING String, MX_UINT8 MSZ_String);

// Functions for contatenation
MX_UINT8 FCI_STRREV(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len);
MX_UINT8 FCI_STRMOV(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len);
void FCI_SHEAD(MX_STRING sSrc1, MX_UINT8 iSrc1_len, MX_STRING sSrc2, MX_UINT8 iSrc2_len, MX_STRING sDst, MX_UINT8 iDst_len);
void FCI_SCOPY(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len);



MX_UINT8 FCI_GETCHAR(MX_STRING sStr1, MX_UINT8 iStr1_len, MX_UINT8 iPos)
{
	MX_UINT8 tmp;
	FCI_GETLENGTH__x(sStr1, iStr1_len, tmp);

	if(iPos < tmp)
		return sStr1[iPos];
	return '\0';
}

MX_UINT8 FCI_GETLENGTH(MX_STRING sStr1, MX_UINT8 iStr1_len)
{
	MX_UINT8 tmp;
	FCI_GETLENGTH__x(sStr1, iStr1_len, tmp);
	return (tmp);
}

MX_UINT8 FCI_MIDSTRING(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_UINT8 iStart, MX_UINT8 iCount, MX_STRING sDst, MX_UINT8 iDst_len)
{
	if (iDst_len == 0) return 0;
	MX_UINT8 idx;
	FCI_GETLENGTH__x(sSrc, iSrc_len, idx);	//find the length of the source string

	if (iStart >= idx)
	{
		*sDst = '\0';						//starting position is beyond string length, so return a null string
	}
	else
	{
		if ((iStart + iCount) >= idx)		//Make sure the required length is not too big
			iCount = idx - iStart;
		if (iCount > (iDst_len))			//make sure the required length is not too big
			iCount = (iDst_len);

		sSrc += iStart;						//Move to the correct place in the source string

		for (idx = 0; idx < iCount; idx++)	//Copy the contents of the source string
		{
			*sDst = *sSrc;
			sDst++;
			sSrc++;
		}
		if (idx < iDst_len)						//add terminating null (if we can)
			*sDst = '\0';
	}
	return (idx);
}

MX_UINT8 FCI_LEFTSTRING(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_UINT8 iCount, MX_STRING sDst, MX_UINT8 iDst_len)
{
	if (iDst_len == 0) return 0;
	MX_UINT8 idx;
	FCI_GETLENGTH__x(sSrc, iSrc_len, idx);	//find the length of the source string

	if (iCount > idx)						//make sure the required length is not too big
		iCount = idx;
	if (iCount > (iDst_len))			//make sure the required length is not too big
		iCount = (iDst_len);

	for (idx = 0; idx < iCount; idx++)		//copy the required MX_UINT8acters
	{
		*sDst = *sSrc;
		sDst++;
		sSrc++;
	}
	if (idx < iDst_len)						//add terminating null (if we can)
		*sDst = '\0';
	return (idx);
}

MX_UINT8 FCI_RIGHTSTRING(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_UINT8 iCount, MX_STRING sDst, MX_UINT8 iDst_len)

{
	if (iDst_len == 0) return 0;
03AD  08FE  	MOVF FCI_RIGHTS_00048_arg_iDst_len, F
03AE  1D03  	BTFSS STATUS,Z
03AF  2BB4  	GOTO	label45
03B0  1683  	BSF STATUS, RP0
03B1  1303  	BCF STATUS, RP1
03B2  01A4  	CLRF CompTempVarRet2006
03B4        label45

	MX_UINT8 idx;
	MX_UINT8 delta;

	FCI_GETLENGTH__x(sSrc, iSrc_len, idx);	//find the length of the source string
03B4  1683  	BSF STATUS, RP0
03B5  1303  	BCF STATUS, RP1
03B6  01A2  	CLRF FCI_RIGHTS_00048_1_idx
03B7        label46
03B7  087C  	MOVF FCI_RIGHTS_00048_arg_iSrc_len, W
03B8  0222  	SUBWF FCI_RIGHTS_00048_1_idx, W
03B9  1803  	BTFSC STATUS,C
03BA  2BC6  	GOTO	label47
03BB  1383  	BCF STATUS,IRP
03BC  187B  	BTFSC FCI_RIGHTS_00048_arg_sSrc+D'1',0
03BD  1783  	BSF STATUS,IRP
03BE  087A  	MOVF FCI_RIGHTS_00048_arg_sSrc, W
03BF  0722  	ADDWF FCI_RIGHTS_00048_1_idx, W
03C0  0084  	MOVWF FSR
03C1  0880  	MOVF INDF, F
03C2  1903  	BTFSC STATUS,Z
03C3  2BC6  	GOTO	label47
03C4  0AA2  	INCF FCI_RIGHTS_00048_1_idx, F
03C5  2BB7  	GOTO	label46
03C6        label47


	if (iCount > idx)						//make sure the required length is not too big
03C6  087D  	MOVF FCI_RIGHTS_00048_arg_iCount, W
03C7  0222  	SUBWF FCI_RIGHTS_00048_1_idx, W
03C8  1803  	BTFSC STATUS,C
03C9  2BCC  	GOTO	label48
03CC        label48

		iCount = idx;
03CA  0822  	MOVF FCI_RIGHTS_00048_1_idx, W
03CB  00FD  	MOVWF FCI_RIGHTS_00048_arg_iCount

	delta = idx - iCount;					//get the offset
03CC  087D  	MOVF FCI_RIGHTS_00048_arg_iCount, W
03CD  0222  	SUBWF FCI_RIGHTS_00048_1_idx, W
03CE  00A3  	MOVWF FCI_RIGHTS_00048_1_delta

	if (iCount > (iDst_len))				//make sure the required length is not too big
03CF  087D  	MOVF FCI_RIGHTS_00048_arg_iCount, W
03D0  027E  	SUBWF FCI_RIGHTS_00048_arg_iDst_len, W
03D1  1803  	BTFSC STATUS,C
03D2  2BD5  	GOTO	label49
03D5        label49

		iCount = (iDst_len);
03D3  087E  	MOVF FCI_RIGHTS_00048_arg_iDst_len, W
03D4  00FD  	MOVWF FCI_RIGHTS_00048_arg_iCount

	sSrc += delta;							//Move to the correct place in the source string
03D5  0823  	MOVF FCI_RIGHTS_00048_1_delta, W
03D6  07FA  	ADDWF FCI_RIGHTS_00048_arg_sSrc, F
03D7  1803  	BTFSC STATUS,C
03D8  0AFB  	INCF FCI_RIGHTS_00048_arg_sSrc+D'1', F


	for(idx = 0; idx < iCount; idx++)		//copy the required MX_UINT8acters
03D9  01A2  	CLRF FCI_RIGHTS_00048_1_idx
03DA        label50
03DA  087D  	MOVF FCI_RIGHTS_00048_arg_iCount, W
03DB  0222  	SUBWF FCI_RIGHTS_00048_1_idx, W
03DC  1803  	BTFSC STATUS,C
03DD  2BF4  	GOTO	label51
03F2  0AA2  	INCF FCI_RIGHTS_00048_1_idx, F
03F3  2BDA  	GOTO	label50
03F4        label51

	{
		*sDst = *sSrc;
03DE  1383  	BCF STATUS,IRP
03DF  187B  	BTFSC FCI_RIGHTS_00048_arg_sSrc+D'1',0
03E0  1783  	BSF STATUS,IRP
03E1  087A  	MOVF FCI_RIGHTS_00048_arg_sSrc, W
03E2  0084  	MOVWF FSR
03E3  0800  	MOVF INDF, W
03E4  00A5  	MOVWF CompTempVar2008
03E5  1383  	BCF STATUS,IRP
03E6  1821  	BTFSC FCI_RIGHTS_00048_arg_sDst+D'1',0
03E7  1783  	BSF STATUS,IRP
03E8  0820  	MOVF FCI_RIGHTS_00048_arg_sDst, W
03E9  0084  	MOVWF FSR
03EA  0825  	MOVF CompTempVar2008, W
03EB  0080  	MOVWF INDF

		sDst++;
03EC  0AA0  	INCF FCI_RIGHTS_00048_arg_sDst, F
03ED  1903  	BTFSC STATUS,Z
03EE  0AA1  	INCF FCI_RIGHTS_00048_arg_sDst+D'1', F

		sSrc++;
03EF  0AFA  	INCF FCI_RIGHTS_00048_arg_sSrc, F
03F0  1903  	BTFSC STATUS,Z
03F1  0AFB  	INCF FCI_RIGHTS_00048_arg_sSrc+D'1', F

	}
	if (idx < iDst_len)						//add terminating null (if we can)
03F4  087E  	MOVF FCI_RIGHTS_00048_arg_iDst_len, W
03F5  0222  	SUBWF FCI_RIGHTS_00048_1_idx, W
03F6  1803  	BTFSC STATUS,C
03F7  2BFF  	GOTO	label52
03FF        label52

		*sDst = '\0';
03F8  1383  	BCF STATUS,IRP
03F9  1821  	BTFSC FCI_RIGHTS_00048_arg_sDst+D'1',0
03FA  1783  	BSF STATUS,IRP
03FB  0820  	MOVF FCI_RIGHTS_00048_arg_sDst, W
03FC  0084  	MOVWF FSR
03FD  3000  	MOVLW 0x00
03FE  0080  	MOVWF INDF

	return (idx);
03FF  0822  	MOVF FCI_RIGHTS_00048_1_idx, W
0400  00A4  	MOVWF CompTempVarRet2006

}
03B3  0008  	RETURN
0401  0008  	RETURN


MX_UINT8 FCI_TOSTRING(MX_SLONG iSrc1, MX_STRING sDst, MX_UINT8 iDst_len)
{
	if (iDst_len == 0) return 0;
	MX_UINT8 tmp1;

	#ifdef MX_STRF_LONG
		unsigned long top = 1000000000; 	// Maximum power of 10 less than 4294967296
	#else
		unsigned short top = 10000; 		// Maximum power of 10 less than 65536
	#endif

	MX_UINT8 idx = 0;

	//copy source 1 into destination:
	//minus sign
	if (iSrc1 < 0)
	{
		sDst[0] = '-';
		idx++;
		iSrc1 = -iSrc1;
	}

	tmp1 = 0;    // Nothing added yet
	if (iSrc1 == 0) // Force showing zero
	{
		tmp1 = 1;
		top = 1;
	}
	while (( idx < iDst_len) && (top > 0))
	{
		#ifdef MX_STRF_LONG
		if (((unsigned long)iSrc1 >= top) || (tmp1))
		#else
		if (((unsigned)iSrc1 >= top) || (tmp1))
		#endif
		{
			#ifdef MX_STRF_LONG
			tmp1 = (unsigned long)iSrc1 / top;	// Top digit
			#else
			tmp1 = (unsigned)iSrc1 / top;	// Top digit
			#endif
			sDst[idx] = '0' + tmp1;			// Add digit to buffer
			idx++;
			iSrc1 -= tmp1 * top;			// Remove digit
			tmp1 = 1;						// Add zeros now
		}
		top /= 10;							// Go to next digit
	}

	if (idx < iDst_len)						//add terminating null (if we can)
		sDst[idx] = '\0';
	return (idx);
}



void FCI_TOLOWER(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len)
{
	if (iDst_len == 0) return;
	MX_UINT8 idx;
	MX_UINT8 ch;

	if (iSrc_len < iDst_len) iSrc_len = iDst_len; // Bound so cant overflow dest
	//copy source into destination and change to lower case
	for (idx=0; idx<iSrc_len; idx++)
	{
		ch = sSrc[idx];
		if ((ch >= 'A') && (ch <= 'Z'))
		{
			ch ^= 0x20;
		}
		sDst[idx] = ch;
		if (ch == 0)
		{
			break;
		}
	}
	if (idx < iDst_len)						//add terminating null (if we can)
		sDst[idx] = '\0';
}

void FCI_TOUPPER(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len)
{
	if (iDst_len == 0) return;
	MX_UINT8 idx;
	MX_UINT8 ch;

	if (iSrc_len < iDst_len) iSrc_len = iDst_len; // Bound so cant overflow dest
	//copy source into destination and change to upper case
	for (idx=0; idx<iSrc_len; idx++)
	{
		ch = sSrc[idx];
		if ((ch >= 'a') && (ch <= 'z'))
		{
			ch ^= 0x20;
		}
		sDst[idx] = ch;
		if (ch == 0)
		{
			break;
		}
	}
	if (idx < iDst_len)						//add terminating null (if we can)
		sDst[idx] = '\0';
}

MX_UINT8 FCI_COMPARE(MX_STRING sSrc1, MX_UINT8 iSrc1_len, MX_STRING sSrc2, MX_UINT8 iSrc2_len, MX_UINT8 iNoCase)
{
	MX_UINT8 iRetVal = 0;
	MX_UINT8 idx;
	MX_UINT8 ch1, ch2;

	for (idx=0; idx < iSrc1_len; idx++)	//compare a byte from the strings
	{
		if (idx < iSrc2_len)
		{
			ch1 = *sSrc1;
			ch2 = *sSrc2;

			if (iNoCase)
			{
				if ((ch1 >= 'a') && (ch1 <= 'z'))
					ch1 = (ch1 & 0xDF);

				if ((ch2 >= 'a') && (ch2 <= 'z'))
					ch2 = (ch2 & 0xDF);

			}

			if (ch1 < ch2)
			{
				return(255);
			}
			else if (ch1 > ch2)
			{
				return(1);
			}

			sSrc1++;
			sSrc2++;
		}
		else
		{
			if (*sSrc1 == 0)
				return (0);				//end of source1 as well, so ok
			else
				return (1);				//reached the end of iSrc2, but still more of iSrc1
		}
	}

	if (iSrc1_len == iSrc2_len)			//reached the end of iSrc1.  If we're also at the end of iSrc2, then return 0
		return (0);
	else
	{
		if (*sSrc2 == 0)
			return (0);					//end of source1 as well, so ok
		else
			return (255);				//not at end of source2, so return -1
	}
}


MX_UINT8 FCI_FLOAT_TO_STRING(MX_FLOAT Number, MX_UINT8 Precision, MX_STRING String, MX_UINT8 MSZ_String)
{
	MX_SINT16 whole;
	MX_UINT8 str_length;
	MX_UINT8 idx;
	MX_UINT8 stringidx = 0;
	MX_FLOAT real, temp;
	MX_UINT8 old;
	MX_UINT8 temp_string[10];

	#ifdef _BOOSTC									//BoostC Floating Point

		float_rounding_mode = 3;					//Always round to zero
		whole = float32_to_int32(Number);			//Convert to whole integer
		temp = float32_from_int32(whole);			//Convert whole number back to floating point

		if (float32_ge(Number,0))
		{
			real = float32_sub(Number, temp);		//Subtract whole number from floating point number
		}
		else
		{
			if (whole == 0)							//Fix -0 bug
			{
				String[stringidx] = '-';
				stringidx = stringidx + 1;
			}

			real = float32_sub(temp, Number);		//Subtract floating point number from whole number
		}
	#endif

	#ifdef HI_TECH_C								//HiTECH Floating Point

		whole = (int)Number;						//Convert to whole integer
		temp = whole;								//Convert whole number back to floating point

		if (Number >= 0)
		{
			real = Number - temp;					//Subtract whole number from floating point number
		}
		else
		{
			if (whole == 0)							//Fix -0 bug
			{
				String[stringidx] = '-';
				stringidx = stringidx + 1;
			}

			real = temp - Number;					//Subtract floating point number from whole number
		}
	#endif

	str_length = FCI_TOSTRING(whole, temp_string, 5);		//Convert integer numbers to strings

	for (idx=0; idx<str_length; idx++)						//Copy whole part of number to string
	{
		if(stringidx < MSZ_String)
		{
			String[stringidx] = temp_string[idx];
			stringidx = stringidx + 1;
		}
	}

	if(stringidx < MSZ_String)						//Add decimal point to string
	{
		String[stringidx] = '.';
		stringidx = stringidx + 1;
	}

	for (idx = 0; idx < Precision; idx++)			//Output Real Part Of Number
	{
		if (stringidx >= MSZ_String)
			break;

		#ifdef _BOOSTC								//BoostC Floating Point
			real = float32_mul(real, 10);
			whole = float32_to_int32(real);			//Convert to whole integer
			temp = float32_from_int32(whole);		//Convert whole number back to floating point
			real = float32_sub(real, temp);			//Subtract whole number from floating point number
		#endif
		#ifdef HI_TECH_C							//HiTECH Floating Point
			real = real * 10;
			whole = (int)real;						//Convert to whole integer
			temp = whole;							//Convert whole number back to floating point
			real = real - temp;						//Subtract whole number from floating point number
		#endif

		String[stringidx] = '0' + whole;
		stringidx = stringidx + 1;
	}

	if(stringidx < MSZ_String)									//Add null termination to string
	{
		String[stringidx] = 0;
	}

	return stringidx;
}











MX_UINT8 FCI_NUMBER_TO_HEX(MX_ULONG Number, MX_STRING String, MX_UINT8 MSZ_String)
{
	MX_UINT8 stringidx;
	MX_UINT8 idx = 0;
	MX_UINT8 temp;
	MX_UINT8 digit[8] = {0,0,0,0,0,0,0,0};

	#ifdef MX_STRF_LONG
		MX_UINT32 num = Number;
	#else
		MX_UINT16 num = Number;
	#endif

	//Check that output string is long enough to store result
	if((Number > 0xFFFF) && (MSZ_String < 10))
		return 0;

	if((Number > 0xFF) && (MSZ_String < 6))
		return 0;

	if((Number <= 0xFF) && (MSZ_String < 4))
		return 0;

	//Initialise start of string with hexadecimal indicator
	String[0] = '0';
	String[1] = 'x';

	//Calculate hex values
	do
	{
		temp = num % 16;
		num = num >> 4;

		if(temp > 9)
		{
			temp = temp - 10;
			digit[idx] = temp + 'A';
		}
		else
			digit[idx] = temp + '0';

		idx = idx + 1;
	} while (num > 0);

	//Copy Hex values over to output string
	for (stringidx = 2; stringidx < (idx + 2); stringidx++)
		String[stringidx] = digit[idx - (stringidx - 1)];

	//Add null termination to string
	if(stringidx < MSZ_String)
	{
		String[stringidx] = 0;
	}

	return stringidx;
}


MX_SINT32 FCI_STRING_TO_INT(MX_STRING String, MX_UINT8 MSZ_String)

{
	MX_UINT8 bNegative = 0;
0314  01FD  	CLRF FCI_STRING_0004F_1_bNegative

	MX_UINT8 idx = 0;
0315  01FE  	CLRF FCI_STRING_0004F_1_idx

	MX_SINT32 RetVal = 0;
0316  1683  	BSF STATUS, RP0
0317  1303  	BCF STATUS, RP1
0318  01A0  	CLRF FCI_STRING_0004F_1_RetVal
0319  01A1  	CLRF FCI_STRING_0004F_1_RetVal+D'1'
031A  01A2  	CLRF FCI_STRING_0004F_1_RetVal+D'2'
031B  01A3  	CLRF FCI_STRING_0004F_1_RetVal+D'3'


	//Is number negative
	if(String[0] == '-')
031C  1383  	BCF STATUS,IRP
031D  187B  	BTFSC FCI_STRING_0004F_arg_String+D'1',0
031E  1783  	BSF STATUS,IRP
031F  087A  	MOVF FCI_STRING_0004F_arg_String, W
0320  0084  	MOVWF FSR
0321  01A4  	CLRF CompTempVar2058
0322  0824  	MOVF CompTempVar2058, W
0323  0784  	ADDWF FSR, F
0324  0800  	MOVF INDF, W
0325  3A2D  	XORLW 0x2D
0326  1D03  	BTFSS STATUS,Z
0327  2B2B  	GOTO	label42
032B        label42

	{
		bNegative = 1;
0328  3001  	MOVLW 0x01
0329  00FD  	MOVWF FCI_STRING_0004F_1_bNegative

		idx = 1;
032A  00FE  	MOVWF FCI_STRING_0004F_1_idx

	}

	//While string contains a valid number
	while (idx < MSZ_String && String[idx] >= '0' && String[idx] <= '9')
032B  087C  	MOVF FCI_STRING_0004F_arg_MSZ_String, W
032C  027E  	SUBWF FCI_STRING_0004F_1_idx, W
032D  1803  	BTFSC STATUS,C
032E  2B86  	GOTO	label43
032F  1383  	BCF STATUS,IRP
0330  187B  	BTFSC FCI_STRING_0004F_arg_String+D'1',0
0331  1783  	BSF STATUS,IRP
0332  087A  	MOVF FCI_STRING_0004F_arg_String, W
0333  077E  	ADDWF FCI_STRING_0004F_1_idx, W
0334  0084  	MOVWF FSR
0335  3030  	MOVLW 0x30
0336  0200  	SUBWF INDF, W
0337  1C03  	BTFSS STATUS,C
0338  2B86  	GOTO	label43
0339  1383  	BCF STATUS,IRP
033A  187B  	BTFSC FCI_STRING_0004F_arg_String+D'1',0
033B  1783  	BSF STATUS,IRP
033C  087A  	MOVF FCI_STRING_0004F_arg_String, W
033D  077E  	ADDWF FCI_STRING_0004F_1_idx, W
033E  0084  	MOVWF FSR
033F  0800  	MOVF INDF, W
0340  3C39  	SUBLW 0x39
0341  1C03  	BTFSS STATUS,C
0342  2B86  	GOTO	label43
0385  2B2B  	GOTO	label42
0386        label43

	{
		//Pull MX_UINT8acter from string and add to running total
		RetVal = (long) RetVal * 10;
0343  0820  	MOVF FCI_STRING_0004F_1_RetVal, W
0344  00A5  	MOVWF __mul_32u__0000F_arg_a
0345  0821  	MOVF FCI_STRING_0004F_1_RetVal+D'1', W
0346  00A6  	MOVWF __mul_32u__0000F_arg_a+D'1'
0347  0822  	MOVF FCI_STRING_0004F_1_RetVal+D'2', W
0348  00A7  	MOVWF __mul_32u__0000F_arg_a+D'2'
0349  0823  	MOVF FCI_STRING_0004F_1_RetVal+D'3', W
034A  00A8  	MOVWF __mul_32u__0000F_arg_a+D'3'
034B  300A  	MOVLW 0x0A
034C  00A9  	MOVWF __mul_32u__0000F_arg_b
034D  01AA  	CLRF __mul_32u__0000F_arg_b+D'1'
034E  01AB  	CLRF __mul_32u__0000F_arg_b+D'2'
034F  01AC  	CLRF __mul_32u__0000F_arg_b+D'3'
0350  2041  	CALL __mul_32u__0000F
0351  0832  	MOVF CompTempVarRet464, W
0352  00AD  	MOVWF CompTempVar2066
0353  0833  	MOVF CompTempVarRet464+D'1', W
0354  00AE  	MOVWF CompTempVar2067
0355  0834  	MOVF CompTempVarRet464+D'2', W
0356  00AF  	MOVWF CompTempVar2068
0357  0835  	MOVF CompTempVarRet464+D'3', W
0358  00B0  	MOVWF CompTempVar2069
0359  082D  	MOVF CompTempVar2066, W
035A  00A0  	MOVWF FCI_STRING_0004F_1_RetVal
035B  082E  	MOVF CompTempVar2067, W
035C  00A1  	MOVWF FCI_STRING_0004F_1_RetVal+D'1'
035D  082F  	MOVF CompTempVar2068, W
035E  00A2  	MOVWF FCI_STRING_0004F_1_RetVal+D'2'
035F  0830  	MOVF CompTempVar2069, W
0360  00A3  	MOVWF FCI_STRING_0004F_1_RetVal+D'3'

		RetVal = (long) RetVal + (String[idx] - '0');
0361  1383  	BCF STATUS,IRP
0362  187B  	BTFSC FCI_STRING_0004F_arg_String+D'1',0
0363  1783  	BSF STATUS,IRP
0364  087A  	MOVF FCI_STRING_0004F_arg_String, W
0365  077E  	ADDWF FCI_STRING_0004F_1_idx, W
0366  0084  	MOVWF FSR
0367  3030  	MOVLW 0x30
0368  0200  	SUBWF INDF, W
0369  00A5  	MOVWF CompTempVar2072
036A  01A6  	CLRF CompTempVar2073
036B  01A7  	CLRF CompTempVar2074
036C  01A8  	CLRF CompTempVar2075
036D  0820  	MOVF FCI_STRING_0004F_1_RetVal, W
036E  07A5  	ADDWF CompTempVar2072, F
036F  0821  	MOVF FCI_STRING_0004F_1_RetVal+D'1', W
0370  1803  	BTFSC STATUS,C
0371  0F21  	INCFSZ FCI_STRING_0004F_1_RetVal+D'1', W
0372  07A6  	ADDWF CompTempVar2073, F
0373  0822  	MOVF FCI_STRING_0004F_1_RetVal+D'2', W
0374  1803  	BTFSC STATUS,C
0375  0F22  	INCFSZ FCI_STRING_0004F_1_RetVal+D'2', W
0376  07A7  	ADDWF CompTempVar2074, F
0377  0823  	MOVF FCI_STRING_0004F_1_RetVal+D'3', W
0378  1803  	BTFSC STATUS,C
0379  0F23  	INCFSZ FCI_STRING_0004F_1_RetVal+D'3', W
037A  07A8  	ADDWF CompTempVar2075, F
037B  0825  	MOVF CompTempVar2072, W
037C  00A0  	MOVWF FCI_STRING_0004F_1_RetVal
037D  0826  	MOVF CompTempVar2073, W
037E  00A1  	MOVWF FCI_STRING_0004F_1_RetVal+D'1'
037F  0827  	MOVF CompTempVar2074, W
0380  00A2  	MOVWF FCI_STRING_0004F_1_RetVal+D'2'
0381  0828  	MOVF CompTempVar2075, W
0382  00A3  	MOVWF FCI_STRING_0004F_1_RetVal+D'3'

		idx = idx + 1;
0383  0A7E  	INCF FCI_STRING_0004F_1_idx, W
0384  00FE  	MOVWF FCI_STRING_0004F_1_idx

	}

	if (bNegative)
0386  08FD  	MOVF FCI_STRING_0004F_1_bNegative, F
0387  1903  	BTFSC STATUS,Z
0388  2BA4  	GOTO	label44
03A4        label44

		RetVal = (long) 0 - RetVal;
0389  0820  	MOVF FCI_STRING_0004F_1_RetVal, W
038A  3C00  	SUBLW 0x00
038B  00A5  	MOVWF CompTempVar2076
038C  3000  	MOVLW 0x00
038D  00A6  	MOVWF CompTempVar2077
038E  00A7  	MOVWF CompTempVar2078
038F  00A8  	MOVWF CompTempVar2079
0390  0821  	MOVF FCI_STRING_0004F_1_RetVal+D'1', W
0391  1C03  	BTFSS STATUS,C
0392  0F21  	INCFSZ FCI_STRING_0004F_1_RetVal+D'1', W
0393  02A6  	SUBWF CompTempVar2077, F
0394  0822  	MOVF FCI_STRING_0004F_1_RetVal+D'2', W
0395  1C03  	BTFSS STATUS,C
0396  0F22  	INCFSZ FCI_STRING_0004F_1_RetVal+D'2', W
0397  02A7  	SUBWF CompTempVar2078, F
0398  0823  	MOVF FCI_STRING_0004F_1_RetVal+D'3', W
0399  1C03  	BTFSS STATUS,C
039A  0F23  	INCFSZ FCI_STRING_0004F_1_RetVal+D'3', W
039B  02A8  	SUBWF CompTempVar2079, F
039C  0825  	MOVF CompTempVar2076, W
039D  00A0  	MOVWF FCI_STRING_0004F_1_RetVal
039E  0826  	MOVF CompTempVar2077, W
039F  00A1  	MOVWF FCI_STRING_0004F_1_RetVal+D'1'
03A0  0827  	MOVF CompTempVar2078, W
03A1  00A2  	MOVWF FCI_STRING_0004F_1_RetVal+D'2'
03A2  0828  	MOVF CompTempVar2079, W
03A3  00A3  	MOVWF FCI_STRING_0004F_1_RetVal+D'3'


	return RetVal;
03A4  0820  	MOVF FCI_STRING_0004F_1_RetVal, W
03A5  00A5  	MOVWF CompTempVarRet2056
03A6  0821  	MOVF FCI_STRING_0004F_1_RetVal+D'1', W
03A7  00A6  	MOVWF CompTempVarRet2056+D'1'
03A8  0822  	MOVF FCI_STRING_0004F_1_RetVal+D'2', W
03A9  00A7  	MOVWF CompTempVarRet2056+D'2'
03AA  0823  	MOVF FCI_STRING_0004F_1_RetVal+D'3', W
03AB  00A8  	MOVWF CompTempVarRet2056+D'3'

}
03AC  0008  	RETURN



MX_FLOAT FCI_STRING_TO_FLOAT(MX_STRING String, MX_UINT8 MSZ_String)
{
	MX_FLOAT RetVal = 0;
	MX_FLOAT real_divider = 1;
	MX_UINT32 whole, real;			//Changed from INT 23/07/10
	MX_UINT8 idx = 0;
	MX_UINT8 idx2 = 0;
	MX_UINT8 offset = 0;
	MX_UINT8 bNegative = 0;
	MX_UINT8 Comp_String[8];

	//Is number negative
	if(String[0] == '-')
	{
		bNegative = 1;
		offset = 1;
	}

	//Scan for decimal point
	for(idx=offset; idx<MSZ_String; idx++)
	{
		if(String[idx] == '.')
			break;
	}

	//Convert whole portion of number from string
	whole = FCI_STRING_TO_INT (String, idx);

	//No decimal point found
	if(idx == MSZ_String)
	{
		#ifdef _BOOSTC
			RetVal = float32_from_int32(whole);
		#endif
		#ifdef HI_TECH_C
			RetVal = (int)whole;
		#endif
		return RetVal;
	}

	//Collect real portion of number into new string
	offset = idx + 1;
	for(idx=offset; idx<MSZ_String; idx++)
	{
		if(String[idx] >= '0' && String[idx] <= '9')
		{
			Comp_String[idx - offset] = String[idx];
			#ifdef _BOOSTC
				real_divider = float32_mul(real_divider, 0.1);
			#endif
			#ifdef HI_TECH_C
				real_divider = real_divider * 0.1;
			#endif
		}
		else
			break;
	}

	//Convert real portion of number from string
	real = FCI_STRING_TO_INT (Comp_String, (idx - offset));

	//Adjust weighting of values and combine into one float variable
	#ifdef _BOOSTC

		RetVal = float32_from_int32(real);
		RetVal = float32_mul(RetVal, real_divider);
		real_divider = float32_from_int32(whole);
		RetVal = float32_add(RetVal, real_divider);

		if (bNegative)
			RetVal = float32_sub(0, RetVal);

	#endif
	#ifdef HI_TECH_C

		RetVal = (MX_FLOAT)real;
		RetVal = RetVal * real_divider;
		real_divider = (MX_FLOAT)whole;
		RetVal = RetVal + real_divider;

		if (bNegative)
			RetVal = 0 - RetVal;
	#endif

	return RetVal;
}



/*=----------------------------------------------------------------------=*\
   Use :Move but do not null-terminate sSrc to sDst, max len iSrc_len
       :This differs from FCI_STRMOV() in that the bytes are copied from the
       :end of the string to the start
       :Returns length of copy
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCI_STRREV(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len)
{
  MX_UINT8 ix, len;
  FCI_GETLENGTH__x(sSrc, iSrc_len, len);
  if (len > iDst_len)
  {
    len = iDst_len;
  }
  ix = len;
  while (ix > 0)
  {
    ix--;
    sDst[ix] = sSrc[ix];
  }
  // No null terminate
  // Return length of string
  return len;
}


/*=----------------------------------------------------------------------=*\
   Use :Move but do not null-terminate sSrc to sDst, max len iSrc_len
       :Returns length of copy
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCI_STRMOV(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len)
{
  MX_UINT8 ix;
  ix = 0;
  while (ix < iSrc_len && ix < iDst_len && sSrc[ix] != '\0')
  {
    sDst[ix] = sSrc[ix];
    ix++;
  }
  // No null terminate
  // Return length of string
  return ix;
}

/*=----------------------------------------------------------------------=*\
   Use :Concatenate sDst = (sSrc1 + sSrc2)
       :sDst is only null terminated if the concat doesnt overflow
       :
\*=----------------------------------------------------------------------=*/
void FCI_SHEAD(MX_STRING sSrc1, MX_UINT8 iSrc1_len, MX_STRING sSrc2, MX_UINT8 iSrc2_len, MX_STRING sDst, MX_UINT8 iDst_len)
{
  MX_UINT8 len, strt;

  len = 0;
  if (sSrc2 == sDst)
  {
    FCI_GETLENGTH__x(sSrc1, iSrc1_len, strt);
    if (strt < iDst_len)
    {
      // Copy second, in reverse
      // len = FCI_STRREV(sSrc2, iSrc2_len, sDst + strt, iDst_len - strt);
      FCI_GETLENGTH__x(sSrc2, iSrc2_len, len);
      if (len > (iDst_len - strt))
      {
        len = (iDst_len - strt); // Length of string to copy to
      }
      iSrc2_len = strt + len; // Use no longer needed var as an offset
      strt = len;
      while (strt > 0)
      {
        strt--;
        iSrc2_len--;
        sDst[iSrc2_len] = sSrc2[strt];
      }
      // Move first
      FCI_STRMOV__x(sSrc1, iSrc1_len, sDst, iDst_len, strt);
      len += strt;
    }
    else
    {
      // Copy first
      FCI_STRMOV__x(sSrc1, iSrc1_len, sDst, iDst_len, len);
    }
  }
  else
  {
    // Copy first
    FCI_STRMOV__x(sSrc1, iSrc1_len, sDst, iDst_len, len);
    // Copy second
    if (len < iDst_len)
    {
      sSrc1 = sDst + len; // make temp copies in no longer used variables
      iSrc1_len = iDst_len - len;
      FCI_STRMOV__x(sSrc2, iSrc2_len, sSrc1, iSrc1_len, strt);
      len += strt;
    }
  }
  // Terminate (only if can)
  if (len < iDst_len)
  {
    sDst[len] = '\0';
  }
}


/*=----------------------------------------------------------------------=*\
   Use :Copy and null-terminate sSrc to sDst, max len iSrc_len
       :sDst is only null terminated if the concat doesnt overflow
       :
\*=----------------------------------------------------------------------=*/
void FCI_SCOPY(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len)
{
  MX_UINT8 len;

  // Move first
  FCI_STRMOV__x(sSrc, iSrc_len, sDst, iDst_len, len);
  // Terminate (only if can)
  if (len < iDst_len)
  {
    sDst[len] = '\0';
  }
}




//************************************************************************************
//**  
//**  File name:     D:\KennyNeutronsInnovations\ScoreBoard\Flowcode\ScoreBoardProgram2.c
//**  Title:         
//**  Description:   
//**  
//**  Generated by:  Flowcode v5.2.0.0
//**  Date:          Wednesday, March 06, 2019 03:42:11
//**  Licence:       Professional
//**  Registered to: xyz
//**  Licence key:   WUK7B9
//**  
//**  
//**  http://www.matrixmultimedia.com
//**  
//************************************************************************************


#define MX_PIC

#define MX_USES_UINT8 1
#define MX_USES_SINT16 1
#define MX_USES_CHAR 2
#define MX_USES_FLOAT 0
#define MX_USES_SINT32 0
#define MX_USES_BOOL 1
#define MX_USES_UINT16 0
#define MX_USES_UINT32 0
//Defines for microcontroller
#define P16F887
#define FC_CAL_PIC
#define MX_ADC
#define MX_ADC_TYPE_7
#define MX_ADC_BITS_10
#define MX_EE
#define MX_EE_TYPE2
#define MX_EE_SIZE 256
#define MX_SPI_1
#define MX_SPI_1_MISO_PORT portc
#define MX_SPI_1_MISO_TRIS trisc
#define MX_SPI_1_MISO_PIN 4
#define MX_SPI_1_MOSI_PORT portc
#define MX_SPI_1_MOSI_TRIS trisc
#define MX_SPI_1_MOSI_PIN 5
#define MX_SPI_1_CLK_PORT portc
#define MX_SPI_1_CLK_TRIS trisc
#define MX_SPI_1_CLK_PIN 3
#define MX_SPI_1_SS_PORT portc
#define MX_SPI_1_SS_TRIS trisc
#define MX_UART_1
#define MX_UART_1_TX_PORT portc
#define MX_UART_1_TX_TRIS trisc
#define MX_UART_1_TX_PIN 6
#define MX_UART_1_RX_PORT portc
#define MX_UART_1_RX_TRIS trisc
#define MX_UART_1_RX_PIN 7
#define MX_I2C
#define MX_MI2C
#define MX_I2C_1
#define MX_I2C_1_SDA_PORT portc
#define MX_I2C_1_SDA_TRIS trisc
#define MX_I2C_1_SDA_PIN 4
#define MX_I2C_1_SCL_PORT portc
#define MX_I2C_1_SCL_TRIS trisc
#define MX_I2C_1_SCL_PIN 3
#define MX_PWM
#define MX_PWM_CNT 2
#define MX_PWM_PSCA1
#define MX_PWM_PSCA4
#define MX_PWM_PSCA16
#define MX_PWM_1_PORT portc
#define MX_PWM_1_TRIS trisc
#define MX_PWM_1_PIN 2
#define MX_PWM_2_PORT portc
#define MX_PWM_2_TRIS trisc
#define MX_PWM_2_PIN 1

//Functions
#define MX_CLK_SPEED 20000000
#ifdef _BOOSTC
#include <system.h>
#endif
#ifdef HI_TECH_C
#include <pic.h>
#endif

//Configuration data
#ifdef _BOOSTC
#pragma DATA 0x2007, 0x20c2
#endif
#ifdef HI_TECH_C
__CONFIG(0x20c2);
#endif
#ifdef _BOOSTC
#pragma DATA 0x2008, 0x3eff
#endif
#ifdef HI_TECH_C
__CONFIG(0x3eff);
#endif

//Internal functions
#include "C:\Program Files (x86)\Flowcode\v5\FCD\internals.c"

//Macro function declarations
void FCM_off_all();
void FCM_data_bank();
void FCM_latch();
void FCM_score_data_register();
void FCM_display_score();
void FCM_display_time();
void FCM_time_data_register();
void FCM_foulperiod_data_register();
void FCM_foulperiod_display();


//Variable declarations
#define FCSZ_STRING_SCORE_HOME 3
#define FCSZ_RECV 18
#define FCSZ_STRING_FOULPERIOD 3
#define FCSZ_STRING_SCORE_AWAY 3
#define FCSZ_STRING_SECONDS 2
#define FCSZ_STRING_MINUTES 2
#define FCV_TRUE (1)
#define FCV_FALSE (0)
MX_CHAR FCV_STRING_SCORE_HOME[FCSZ_STRING_SCORE_HOME] = ("");
0609  01C6  	CLRF gbl_FCV_STRING_SCORE_HOME

MX_UINT8 FCV_HOME_ONES = (0x0);
060A  01E3  	CLRF gbl_FCV_HOME_ONES

MX_SINT16 FCV_FOULPERIOD = (0);
060B  01D4  	CLRF gbl_FCV_FOULPERIOD
060C  01D5  	CLRF gbl_FCV_FOULPERIOD+D'1'

MX_BOOL FCV_DAT;
MX_UINT8 FCV_SECONDS;
MX_UINT8 FCV_PERIOD = (0x0);
060D  01E6  	CLRF gbl_FCV_PERIOD

MX_UINT8 FCV_MINUTES = (0x0);
060E  01E7  	CLRF gbl_FCV_MINUTES

MX_UINT8 FCV_HOME_FOUL = (0x0);
060F  01E8  	CLRF gbl_FCV_HOME_FOUL

MX_UINT8 FCV_AWAY_TENS = (0x0);
0610  01E9  	CLRF gbl_FCV_AWAY_TENS

MX_UINT8 FCV_MINUTE_TENS = (0x0);
0611  01EA  	CLRF gbl_FCV_MINUTE_TENS

MX_CHAR FCV_RECV[FCSZ_RECV] = ("");
0612  01A0  	CLRF gbl_FCV_RECV

MX_UINT8 FCV_BITS = (0x0);
0613  01EB  	CLRF gbl_FCV_BITS

MX_CHAR FCV_STRING_FOULPERIOD[FCSZ_STRING_FOULPERIOD] = ("");
0614  01C9  	CLRF gbl_FCV_STRING_FOULPERIOD

MX_UINT8 FCV_SECONDS_TENS = (0x0);
0615  01EC  	CLRF gbl_FCV_SECONDS_TENS

MX_UINT8 FCV_SCORE_AWAY = (0x0);
0616  01ED  	CLRF gbl_FCV_SCORE_AWAY

MX_UINT8 FCV_DIGIT = (0x0);
0617  01EE  	CLRF gbl_FCV_DIGIT

MX_BOOL FCV_HOME_HUNDRED = (0);
0618  10E4  	BCF gbl_FCV_HOME_HUNDRED,1

MX_UINT8 FCV_AWAY_ONES = (0x0);
0619  01EF  	CLRF gbl_FCV_AWAY_ONES

MX_UINT8 FCV_MINUTE_ONES = (0x0);
061A  01F0  	CLRF gbl_FCV_MINUTE_ONES

MX_UINT8 FCV_HOME_TENS = (0x0);
061B  01F1  	CLRF gbl_FCV_HOME_TENS

MX_UINT8 FCV_HEADER = (0x0);
061C  01F2  	CLRF gbl_FCV_HEADER

MX_UINT8 FCV_SCORE_HOME;
MX_BOOL FCV_AWAY_HUNDREDS = (0);
061D  1164  	BCF gbl_FCV_AWAY_HUNDREDS,2

MX_UINT8 FCV_SECONDS_ONES = (0x0);
061E  01F4  	CLRF gbl_FCV_SECONDS_ONES

MX_CHAR FCV_STRING_SCORE_AWAY[FCSZ_STRING_SCORE_AWAY] = ("");
061F  01CC  	CLRF gbl_FCV_STRING_SCORE_AWAY

MX_UINT8 FCV_IHAP = (0x0);
0620  01F5  	CLRF gbl_FCV_IHAP

MX_CHAR FCV_STRING_SECONDS[FCSZ_STRING_SECONDS] = ("");
0621  01D6  	CLRF gbl_FCV_STRING_SECONDS

MX_UINT8 FCV_AWAY_FOUL = (0x0);
0622  01F6  	CLRF gbl_FCV_AWAY_FOUL

MX_CHAR FCV_STRING_MINUTES[FCSZ_STRING_MINUTES] = ("");
0623  01D8  	CLRF gbl_FCV_STRING_MINUTES


MX_UINT8 FCLV_LOOP1;
MX_UINT8 FCLV_LOOP2;
MX_UINT8 FCLV_LOOP3;



//RS232(0): //Defines:

/**** Macro Substitutions ****
a = Unique Reference
b = Uart Channel		(0-software / 1-4 hardware)
c = tx pin
d = tx port
e = rx pin
f = rx port
g = flow control		(0-Off / 1-On)
h = cts pin
i = cts port
j = rts pin
k = rts port
l = baud rate
m = data bits			(7/8/9) (7 only supported in software modes)
n = return type		(0-byte / 1-MX_UINT16)
o = echo enable		(0-Off / 1-On)
******************************/

//Definitions for RS232 UART slot allocation
#ifndef	MX_UART_REF1
	#define MX_UART_REF1
	#define RS232_1_MX_UART_UREF			1
	#define MX_UART_CHANNEL_1		1
	#define MX_UART_TX_PIN_1		0
	#define MX_UART_TX_PORT_1		porta
	#define MX_UART_TX_TRIS_1		trisa
	#define MX_UART_RX_PIN_1		0
	#define MX_UART_RX_PORT_1		porta
	#define MX_UART_RX_TRIS_1		trisa
	#define MX_UART_FLOWEN_1		0
	#define MX_UART_CTS_PIN_1		4
	#define MX_UART_CTS_PORT_1		portc
	#define MX_UART_CTS_TRIS_1		trisc
	#define MX_UART_RTS_PIN_1		0
	#define MX_UART_RTS_PORT_1		portc
	#define MX_UART_RTS_TRIS_1		trisc
	#define MX_UART_BAUD_1			38400
	#define MX_UART_DBITS_1			8
	#define MX_UART_RETURN_1		0
	#define MX_UART_ECHO_1			0
	#define MX_UART_INT_1			0
#else
 #ifndef	MX_UART_REF2
	#define MX_UART_REF2
	#define RS232_1_MX_UART_UREF			2
	#define MX_UART_CHANNEL_2		1
	#define MX_UART_TX_PIN_2		0
	#define MX_UART_TX_PORT_2		porta
	#define MX_UART_TX_TRIS_2		trisa
	#define MX_UART_RX_PIN_2		0
	#define MX_UART_RX_PORT_2		porta
	#define MX_UART_RX_TRIS_2		trisa
	#define MX_UART_FLOWEN_2		0
	#define MX_UART_CTS_PIN_2		4
	#define MX_UART_CTS_PORT_2		portc
	#define MX_UART_CTS_TRIS_2		trisc
	#define MX_UART_RTS_PIN_2		0
	#define MX_UART_RTS_PORT_2		portc
	#define MX_UART_RTS_TRIS_2		trisc
	#define MX_UART_BAUD_2			38400
	#define MX_UART_DBITS_2			8
	#define MX_UART_RETURN_2		0
	#define MX_UART_ECHO_2			0
	#define MX_UART_INT_2			0
 #else
  #ifndef	MX_UART_REF3
	#define MX_UART_REF3
	#define RS232_1_MX_UART_UREF			3
	#define MX_UART_CHANNEL_3		1
	#define MX_UART_TX_PIN_3		0
	#define MX_UART_TX_PORT_3		porta
	#define MX_UART_TX_TRIS_3		trisa
	#define MX_UART_RX_PIN_3		0
	#define MX_UART_RX_PORT_3		porta
	#define MX_UART_RX_TRIS_3		trisa
	#define MX_UART_FLOWEN_3		0
	#define MX_UART_CTS_PIN_3		4
	#define MX_UART_CTS_PORT_3		portc
	#define MX_UART_CTS_TRIS_3		trisc
	#define MX_UART_RTS_PIN_3		0
	#define MX_UART_RTS_PORT_3		portc
	#define MX_UART_RTS_TRIS_3		trisc
	#define MX_UART_BAUD_3			38400
	#define MX_UART_DBITS_3			8
	#define MX_UART_RETURN_3		0
	#define MX_UART_ECHO_3			0
	#define MX_UART_INT_3			0
  #else
   #ifndef	MX_UART_REF4
	#define MX_UART_REF4
	#define RS232_1_MX_UART_UREF			4
	#define MX_UART_CHANNEL_4		1
	#define MX_UART_TX_PIN_4		0
	#define MX_UART_TX_PORT_4		porta
	#define MX_UART_TX_TRIS_4		trisa
	#define MX_UART_RX_PIN_4		0
	#define MX_UART_RX_PORT_4		porta
	#define MX_UART_RX_TRIS_4		trisa
	#define MX_UART_FLOWEN_4		0
	#define MX_UART_CTS_PIN_4		4
	#define MX_UART_CTS_PORT_4		portc
	#define MX_UART_CTS_TRIS_4		trisc
	#define MX_UART_RTS_PIN_4		0
	#define MX_UART_RTS_PORT_4		portc
	#define MX_UART_RTS_TRIS_4		trisc
	#define MX_UART_BAUD_4			38400
	#define MX_UART_DBITS_4			8
	#define MX_UART_RETURN_4		0
	#define MX_UART_ECHO_4			0
	#define MX_UART_INT_4			0
   #endif
  #endif
 #endif
#endif

#define RS232_1_UART_Init		CAL_APPEND(FC_CAL_UART_Init_, RS232_1_MX_UART_UREF)
#define RS232_1_UART_Send		CAL_APPEND(FC_CAL_UART_Send_, RS232_1_MX_UART_UREF)
#define RS232_1_UART_Receive		CAL_APPEND(FC_CAL_UART_Receive_, RS232_1_MX_UART_UREF)
#define RS232_1_UART_Update_Baud CAL_APPEND(FC_CAL_UART_Update_Baud_, RS232_1_MX_UART_UREF)

extern void RS232_1_UART_Init();
extern void RS232_1_UART_Send(MX_UINT16 nChar);
extern MX_SINT16 RS232_1_UART_Receive(MX_UINT8 nTimeout);
extern void RS232_1_UART_Update_Baud(MX_UINT8 newbaud);




//RS232(0): //Macro function declarations

void FCD_RS2320_SendRS232Char(MX_SINT16 nChar);
void FCD_RS2320_SendRS232String(MX_STRING String, MX_UINT8 MSZ_String);
MX_SINT16 FCD_RS2320_ReceiveRS232Char(MX_UINT8 nTimeout);
void FCD_RS2320_ReceiveRS232String(MX_CHAR* FCR_RETVAL, MX_UINT8 FCR_RETVAL_SIZE, MX_UINT8 nTimeout, MX_UINT8 NumBytes);
void FCD_RS2320_ChangeHWBaud(MX_UINT8 newbaud);



//RS232(0): //Macro implementations


void FCD_RS2320_SendRS232Char(MX_SINT16 nChar)
{
	
		RS232_1_UART_Send ( nChar);

}

void FCD_RS2320_SendRS232String(MX_STRING String, MX_UINT8 MSZ_String)
{
	
		MX_UINT8 idx;
		for(idx = 0; idx < MSZ_String; idx++)
		{
			if (String[idx] == 0)
				break;
			else RS232_1_UART_Send ( String[idx] );
		}

}

MX_SINT16 FCD_RS2320_ReceiveRS232Char(MX_UINT8 nTimeout)

{
	
		return ( RS232_1_UART_Receive ( nTimeout) );
043E  087A  	MOVF FCD_RS2320_00060_arg_nTimeout, W
043F  1683  	BSF STATUS, RP0
0440  1303  	BCF STATUS, RP1
0441  00A5  	MOVWF FC_CAL_UAR_0005B_arg_nTimeout
0442  2064  	CALL FC_CAL_UAR_0005B
0443  082C  	MOVF CompTempVarRet2210, W
0444  00FC  	MOVWF CompTempVarRet2215
0445  082D  	MOVF CompTempVarRet2210+D'1', W
0446  00FD  	MOVWF CompTempVarRet2215+D'1'


}
0447  0008  	RETURN


void FCD_RS2320_ReceiveRS232String(MX_CHAR* FCR_RETVAL, MX_UINT8 FCR_RETVAL_SIZE, MX_UINT8 nTimeout, MX_UINT8 NumBytes)

{
	
		MX_UINT8 idx;
		MX_SINT16 RS232_TO = 255;
0402  30FF  	MOVLW 0xFF
0403  1683  	BSF STATUS, RP0
0404  1303  	BCF STATUS, RP1
0405  00A1  	MOVWF FCD_RS2320_00061_1_RS232_TO
0406  01A2  	CLRF FCD_RS2320_00061_1_RS232_TO+D'1'

		MX_SINT16 in;

		if ( 0 != 0 )
			RS232_TO = 256;

		if (NumBytes > FCR_RETVAL_SIZE)
0407  087E  	MOVF FCD_RS2320_00061_arg_NumBytes, W
0408  027C  	SUBWF FCD_RS2320_00061_arg_FCR_R_00062, W
0409  1803  	BTFSC STATUS,C
040A  2C0D  	GOTO	label53
040D        label53

			NumBytes = FCR_RETVAL_SIZE;
040B  087C  	MOVF FCD_RS2320_00061_arg_FCR_R_00062, W
040C  00FE  	MOVWF FCD_RS2320_00061_arg_NumBytes


		for (idx = 0; idx < NumBytes; idx++)
040D  01A0  	CLRF FCD_RS2320_00061_1_idx
040E        label54
040E  087E  	MOVF FCD_RS2320_00061_arg_NumBytes, W
040F  0220  	SUBWF FCD_RS2320_00061_1_idx, W
0410  1803  	BTFSC STATUS,C
0411  2C31  	GOTO	label56
042F  0AA0  	INCF FCD_RS2320_00061_1_idx, F
0430  2C0E  	GOTO	label54
0431        label56

		{
			in = RS232_1_UART_Receive ( nTimeout);
0412  087D  	MOVF FCD_RS2320_00061_arg_nTimeout, W
0413  00A5  	MOVWF FC_CAL_UAR_0005B_arg_nTimeout
0414  2064  	CALL FC_CAL_UAR_0005B
0415  082C  	MOVF CompTempVarRet2210, W
0416  00A3  	MOVWF FCD_RS2320_00061_1_in
0417  082D  	MOVF CompTempVarRet2210+D'1', W
0418  00A4  	MOVWF FCD_RS2320_00061_1_in+D'1'

			if(in < RS232_TO)
0419  0824  	MOVF FCD_RS2320_00061_1_in+D'1', W
041A  3A80  	XORLW 0x80
041B  00A5  	MOVWF CompTempVar2216
041C  0822  	MOVF FCD_RS2320_00061_1_RS232_TO+D'1', W
041D  3A80  	XORLW 0x80
041E  0225  	SUBWF CompTempVar2216, W
041F  1D03  	BTFSS STATUS,Z
0420  2C23  	GOTO	label55
0421  0821  	MOVF FCD_RS2320_00061_1_RS232_TO, W
0422  0223  	SUBWF FCD_RS2320_00061_1_in, W
0423        label55
0423  1803  	BTFSC STATUS,C
0424  2C31  	GOTO	label56

				FCR_RETVAL[idx] = in & 0xFF;
0425  0823  	MOVF FCD_RS2320_00061_1_in, W
0426  00A5  	MOVWF CompTempVar2218
0427  1383  	BCF STATUS,IRP
0428  187B  	BTFSC FCD_RS2320_00061_arg_FCR_RETVAL+D'1',0
0429  1783  	BSF STATUS,IRP
042A  087A  	MOVF FCD_RS2320_00061_arg_FCR_RETVAL, W
042B  0720  	ADDWF FCD_RS2320_00061_1_idx, W
042C  0084  	MOVWF FSR
042D  0825  	MOVF CompTempVar2218, W
042E  0080  	MOVWF INDF

			else
				break;

		}

		if (idx < FCR_RETVAL_SIZE)
0431  087C  	MOVF FCD_RS2320_00061_arg_FCR_R_00062, W
0432  0220  	SUBWF FCD_RS2320_00061_1_idx, W
0433  1803  	BTFSC STATUS,C

			FCR_RETVAL[idx] = 0;
0435  1383  	BCF STATUS,IRP
0436  187B  	BTFSC FCD_RS2320_00061_arg_FCR_RETVAL+D'1',0
0437  1783  	BSF STATUS,IRP
0438  087A  	MOVF FCD_RS2320_00061_arg_FCR_RETVAL, W
0439  0720  	ADDWF FCD_RS2320_00061_1_idx, W
043A  0084  	MOVWF FSR
043B  3000  	MOVLW 0x00
043C  0080  	MOVWF INDF


}
0434  0008  	RETURN
043D  0008  	RETURN


void FCD_RS2320_ChangeHWBaud(MX_UINT8 newbaud)
{
	
		RS232_1_UART_Update_Baud (newbaud);

}

#include "C:\Program Files (x86)\Flowcode\v5\CAL\includes.c"

//Macro implementations


void FCM_off_all()

{

	//Digit2
	//Output: 0 -> D0
	trisd = trisd & 0xFE;
0132  30FE  	MOVLW 0xFE
0133  1683  	BSF STATUS, RP0
0134  1303  	BCF STATUS, RP1
0135  0508  	ANDWF gbl_trisd, W
0136  0088  	MOVWF gbl_trisd

	if ((0))
		portd = (portd & 0xFE) | 0x01;
	else
		portd = portd & 0xFE;
0137  30FE  	MOVLW 0xFE
0138  1283  	BCF STATUS, RP0
0139  0508  	ANDWF gbl_portd, W
013A  0088  	MOVWF gbl_portd


	//Digit1
	//Output: 0 -> D1
	trisd = trisd & 0xFD;
013B  30FD  	MOVLW 0xFD
013C  1683  	BSF STATUS, RP0
013D  0508  	ANDWF gbl_trisd, W
013E  0088  	MOVWF gbl_trisd

	if ((0))
		portd = (portd & 0xFD) | 0x02;
	else
		portd = portd & 0xFD;
013F  30FD  	MOVLW 0xFD
0140  1283  	BCF STATUS, RP0
0141  0508  	ANDWF gbl_portd, W
0142  0088  	MOVWF gbl_portd


}
0143  0008  	RETURN



void FCM_data_bank()

{

	//Switch
	//Switch: digit?
	switch (FCV_DIGIT)

	{
		case 1:
0194  1283  	BCF STATUS, RP0
0195  1303  	BCF STATUS, RP1
0196  086E  	MOVF gbl_FCV_DIGIT, W
0197  3A01  	XORLW 0x01
0198  1903  	BTFSC STATUS,Z
0199  29B6  	GOTO	label22
01B6        label22

		{
			//Calculation
			//Calculation:
			//  bits = 0b00000110
			FCV_BITS = 6;
01B6  3006  	MOVLW 0x06
01B7  00EB  	MOVWF gbl_FCV_BITS


			break;

		}
		case 2:
019A  3A03  	XORLW 0x03
019B  1903  	BTFSC STATUS,Z
019C  29B9  	GOTO	label23
01B9        label23

		{
			//Calculation
			//Calculation:
			//  bits = 0b01011011
			FCV_BITS = 91;
01B9  305B  	MOVLW 0x5B
01BA  00EB  	MOVWF gbl_FCV_BITS


			break;

		}
		case 3:
019D  3A01  	XORLW 0x01
019E  1903  	BTFSC STATUS,Z
019F  29BC  	GOTO	label24
01BC        label24

		{
			//Calculation
			//Calculation:
			//  bits = 0b01001111
			FCV_BITS = 79;
01BC  304F  	MOVLW 0x4F
01BD  00EB  	MOVWF gbl_FCV_BITS


			break;

		}
		case 4:
01A0  3A07  	XORLW 0x07
01A1  1903  	BTFSC STATUS,Z
01A2  29BF  	GOTO	label25
01BF        label25

		{
			//Calculation
			//Calculation:
			//  bits = 0b01100110
			FCV_BITS = 102;
01BF  3066  	MOVLW 0x66
01C0  00EB  	MOVWF gbl_FCV_BITS


			break;

		}
		case 5:
01A3  3A01  	XORLW 0x01
01A4  1903  	BTFSC STATUS,Z
01A5  29C2  	GOTO	label26
01C2        label26

		{
			//Calculation
			//Calculation:
			//  bits = 0b01101101
			FCV_BITS = 109;
01C2  306D  	MOVLW 0x6D
01C3  00EB  	MOVWF gbl_FCV_BITS


			break;

		}
		case 6:
01A6  3A03  	XORLW 0x03
01A7  1903  	BTFSC STATUS,Z
01A8  29C5  	GOTO	label27
01C5        label27

		{
			//Calculation
			//Calculation:
			//  bits = 0b01111101
			FCV_BITS = 125;
01C5  307D  	MOVLW 0x7D
01C6  00EB  	MOVWF gbl_FCV_BITS


			break;

		}
		case 7:
01A9  3A01  	XORLW 0x01
01AA  1903  	BTFSC STATUS,Z
01AB  29C8  	GOTO	label28
01C8        label28

		{
			//Calculation
			//Calculation:
			//  bits = 0b00000111
			FCV_BITS = 7;
01C8  3007  	MOVLW 0x07
01C9  00EB  	MOVWF gbl_FCV_BITS


			break;

		}
		case 8:
01AC  3A0F  	XORLW 0x0F
01AD  1903  	BTFSC STATUS,Z
01AE  29CB  	GOTO	label29
01CB        label29

		{
			//Calculation
			//Calculation:
			//  bits = 0b01111111
			FCV_BITS = 127;
01CB  307F  	MOVLW 0x7F
01CC  00EB  	MOVWF gbl_FCV_BITS


			break;

		}
		case 9:
01AF  3A01  	XORLW 0x01
01B0  1903  	BTFSC STATUS,Z
01B1  29CE  	GOTO	label30
01CE        label30

		{
			//Calculation
			//Calculation:
			//  bits = 0b01101111
			FCV_BITS = 111;
01CE  306F  	MOVLW 0x6F
01CF  00EB  	MOVWF gbl_FCV_BITS


			break;

		}
		case 0:
01B2  3A09  	XORLW 0x09
01B3  1903  	BTFSC STATUS,Z
01B4  29D1  	GOTO	label31
01D1        label31

		{
			//Calculation
			//Calculation:
			//  bits = 0b00111111
			FCV_BITS = 63;
01D1  303F  	MOVLW 0x3F
01D2  00EB  	MOVWF gbl_FCV_BITS


			break;

		}
		// default:

	}

}
01B5  0008  	RETURN
01B8  0008  	RETURN
01BB  0008  	RETURN
01BE  0008  	RETURN
01C1  0008  	RETURN
01C4  0008  	RETURN
01C7  0008  	RETURN
01CA  0008  	RETURN
01CD  0008  	RETURN
01D0  0008  	RETURN
01D3  0008  	RETURN



void FCM_latch()

{

	//reg
	//Output: 1 -> C1
	trisc = trisc & 0xFD;
0144  30FD  	MOVLW 0xFD
0145  1683  	BSF STATUS, RP0
0146  1303  	BCF STATUS, RP1
0147  0507  	ANDWF gbl_trisc, W
0148  0087  	MOVWF gbl_trisc

	if ((1))
		portc = (portc & 0xFD) | 0x02;
0149  30FD  	MOVLW 0xFD
014A  1283  	BCF STATUS, RP0
014B  0507  	ANDWF gbl_portc, W
014C  00FA  	MOVWF CompTempVar2188
014D  3002  	MOVLW 0x02
014E  047A  	IORWF CompTempVar2188, W
014F  0087  	MOVWF gbl_portc

	else
		portc = portc & 0xFD;

	//reg
	//Output: 0 -> C1
	trisc = trisc & 0xFD;
0150  30FD  	MOVLW 0xFD
0151  1683  	BSF STATUS, RP0
0152  0507  	ANDWF gbl_trisc, W
0153  0087  	MOVWF gbl_trisc

	if ((0))
		portc = (portc & 0xFD) | 0x02;
	else
		portc = portc & 0xFD;
0154  30FD  	MOVLW 0xFD
0155  1283  	BCF STATUS, RP0
0156  0507  	ANDWF gbl_portc, W
0157  0087  	MOVWF gbl_portc


}
0158  0008  	RETURN



void FCM_score_data_register()

{

	//Loop
	//Loop: Loop 8 times
	for (FCLV_LOOP1=0; FCLV_LOOP1<8; FCLV_LOOP1++)
00F7  01F7  	CLRF gbl_FCLV_LOOP1
00F8        label16
00F8  3008  	MOVLW 0x08
00F9  0277  	SUBWF gbl_FCLV_LOOP1, W
00FA  1803  	BTFSC STATUS,C
0130  0AF7  	INCF gbl_FCLV_LOOP1, F
0131  28F8  	GOTO	label16

	{

		//Calculation
		//Calculation:
		//  dat = bits AND 1
		FCV_DAT = FCV_BITS & 1;
00FC  3001  	MOVLW 0x01
00FD  1283  	BCF STATUS, RP0
00FE  1303  	BCF STATUS, RP1
00FF  056B  	ANDWF gbl_FCV_BITS, W
0100  00FA  	MOVWF CompTempVar2189
0101  01FB  	CLRF CompTempVar2190
0102  08FA  	MOVF CompTempVar2189, F
0103  1D03  	BTFSS STATUS,Z
0104  147B  	BSF CompTempVar2190,0
0105  1064  	BCF gbl_FCV_DAT,0
0106  087B  	MOVF CompTempVar2190, W
0107  1D03  	BTFSS STATUS,Z
0108  1464  	BSF gbl_FCV_DAT,0


		//score_data
		//Output: dat -> C3
		trisc = trisc & 0xF7;
0109  30F7  	MOVLW 0xF7
010A  1683  	BSF STATUS, RP0
010B  0507  	ANDWF gbl_trisc, W
010C  0087  	MOVWF gbl_trisc

		if ((FCV_DAT))
010D  1283  	BCF STATUS, RP0
010E  1C64  	BTFSS gbl_FCV_DAT,0
010F  2917  	GOTO	label17
0117        label17

			portc = (portc & 0xF7) | 0x08;
0110  30F7  	MOVLW 0xF7
0111  0507  	ANDWF gbl_portc, W
0112  00FA  	MOVWF CompTempVar2191
0113  3008  	MOVLW 0x08
0114  047A  	IORWF CompTempVar2191, W
0115  0087  	MOVWF gbl_portc

		else
0116  291A  	GOTO	label18
011A        label18

			portc = portc & 0xF7;
0117  30F7  	MOVLW 0xF7
0118  0507  	ANDWF gbl_portc, W
0119  0087  	MOVWF gbl_portc


		//clk
		//Output: 1 -> C0
		trisc = trisc & 0xFE;
011A  30FE  	MOVLW 0xFE
011B  1683  	BSF STATUS, RP0
011C  0507  	ANDWF gbl_trisc, W
011D  0087  	MOVWF gbl_trisc

		if ((1))
			portc = (portc & 0xFE) | 0x01;
011E  30FE  	MOVLW 0xFE
011F  1283  	BCF STATUS, RP0
0120  0507  	ANDWF gbl_portc, W
0121  00FA  	MOVWF CompTempVar2192
0122  3001  	MOVLW 0x01
0123  047A  	IORWF CompTempVar2192, W
0124  0087  	MOVWF gbl_portc

		else
			portc = portc & 0xFE;

		//clk
		//Output: 0 -> C0
		trisc = trisc & 0xFE;
0125  30FE  	MOVLW 0xFE
0126  1683  	BSF STATUS, RP0
0127  0507  	ANDWF gbl_trisc, W
0128  0087  	MOVWF gbl_trisc

		if ((0))
			portc = (portc & 0xFE) | 0x01;
		else
			portc = portc & 0xFE;
0129  30FE  	MOVLW 0xFE
012A  1283  	BCF STATUS, RP0
012B  0507  	ANDWF gbl_portc, W
012C  0087  	MOVWF gbl_portc


		//Calculation
		//Calculation:
		//  bits = bits >> 1
		FCV_BITS = FCV_BITS >> 1;
012D  08EB  	MOVF gbl_FCV_BITS, F
012E  1003  	BCF STATUS,C
012F  0CEB  	RRF gbl_FCV_BITS, F



	}

}
00FB  0008  	RETURN



void FCM_display_score()

{

	//Call Macro
	//Call Macro: off_all()
	FCM_off_all();
02CF  2132  	CALL FCM_off_al_00051


	//Calculation
	//Calculation:
	//  digit = away_ones
	FCV_DIGIT = FCV_AWAY_ONES;
02D0  086F  	MOVF gbl_FCV_AWAY_ONES, W
02D1  00EE  	MOVWF gbl_FCV_DIGIT


	//Call Macro
	//Call Macro: data_bank()
	FCM_data_bank();
02D2  2194  	CALL FCM_data_b_00052


	//Call Macro
	//Call Macro: score_data_register()
	FCM_score_data_register();
02D3  20F7  	CALL FCM_score__00053


	//Calculation
	//Calculation:
	//  digit = home_ones
	FCV_DIGIT = FCV_HOME_ONES;
02D4  1283  	BCF STATUS, RP0
02D5  1303  	BCF STATUS, RP1
02D6  0863  	MOVF gbl_FCV_HOME_ONES, W
02D7  00EE  	MOVWF gbl_FCV_DIGIT


	//Call Macro
	//Call Macro: data_bank()
	FCM_data_bank();
02D8  2194  	CALL FCM_data_b_00052


	//Call Macro
	//Call Macro: score_data_register()
	FCM_score_data_register();
02D9  20F7  	CALL FCM_score__00053


	//Call Macro
	//Call Macro: latch()
	FCM_latch();
02DA  2144  	CALL FCM_latch_00000


	//Digit2
	//Output: 0 -> D0
	trisd = trisd & 0xFE;
02DB  30FE  	MOVLW 0xFE
02DC  1683  	BSF STATUS, RP0
02DD  0508  	ANDWF gbl_trisd, W
02DE  0088  	MOVWF gbl_trisd

	if ((0))
		portd = (portd & 0xFE) | 0x01;
	else
		portd = portd & 0xFE;
02DF  30FE  	MOVLW 0xFE
02E0  1283  	BCF STATUS, RP0
02E1  0508  	ANDWF gbl_portd, W
02E2  0088  	MOVWF gbl_portd


	//Digit1
	//Output: 1 -> D1
	trisd = trisd & 0xFD;
02E3  30FD  	MOVLW 0xFD
02E4  1683  	BSF STATUS, RP0
02E5  0508  	ANDWF gbl_trisd, W
02E6  0088  	MOVWF gbl_trisd

	if ((1))
		portd = (portd & 0xFD) | 0x02;
02E7  30FD  	MOVLW 0xFD
02E8  1283  	BCF STATUS, RP0
02E9  0508  	ANDWF gbl_portd, W
02EA  00FA  	MOVWF CompTempVar2194
02EB  3002  	MOVLW 0x02
02EC  047A  	IORWF CompTempVar2194, W
02ED  0088  	MOVWF gbl_portd

	else
		portd = portd & 0xFD;

	//Delay
	//Delay: 1 ms
	delay_ms(1);
02EE  3001  	MOVLW 0x01
02EF  00FA  	MOVWF delay_ms_00000_arg_del
02F0  2015  	CALL delay_ms_00000


	//Comment:
	//END of Digit1

	//Call Macro
	//Call Macro: off_all()
	FCM_off_all();
02F1  2132  	CALL FCM_off_al_00051


	//Calculation
	//Calculation:
	//  digit = away_tens
	FCV_DIGIT = FCV_AWAY_TENS;
02F2  0869  	MOVF gbl_FCV_AWAY_TENS, W
02F3  00EE  	MOVWF gbl_FCV_DIGIT


	//Call Macro
	//Call Macro: data_bank()
	FCM_data_bank();
02F4  2194  	CALL FCM_data_b_00052


	//Call Macro
	//Call Macro: score_data_register()
	FCM_score_data_register();
02F5  20F7  	CALL FCM_score__00053


	//Calculation
	//Calculation:
	//  digit = home_tens
	FCV_DIGIT = FCV_HOME_TENS;
02F6  0871  	MOVF gbl_FCV_HOME_TENS, W
02F7  1283  	BCF STATUS, RP0
02F8  1303  	BCF STATUS, RP1
02F9  00EE  	MOVWF gbl_FCV_DIGIT


	//Call Macro
	//Call Macro: data_bank()
	FCM_data_bank();
02FA  2194  	CALL FCM_data_b_00052


	//Call Macro
	//Call Macro: score_data_register()
	FCM_score_data_register();
02FB  20F7  	CALL FCM_score__00053


	//Call Macro
	//Call Macro: latch()
	FCM_latch();
02FC  2144  	CALL FCM_latch_00000


	//Digit2
	//Output: 1 -> D0
	trisd = trisd & 0xFE;
02FD  30FE  	MOVLW 0xFE
02FE  1683  	BSF STATUS, RP0
02FF  0508  	ANDWF gbl_trisd, W
0300  0088  	MOVWF gbl_trisd

	if ((1))
		portd = (portd & 0xFE) | 0x01;
0301  30FE  	MOVLW 0xFE
0302  1283  	BCF STATUS, RP0
0303  0508  	ANDWF gbl_portd, W
0304  00FA  	MOVWF CompTempVar2195
0305  3001  	MOVLW 0x01
0306  047A  	IORWF CompTempVar2195, W
0307  0088  	MOVWF gbl_portd

	else
		portd = portd & 0xFE;

	//Digit1
	//Output: 0 -> D1
	trisd = trisd & 0xFD;
0308  30FD  	MOVLW 0xFD
0309  1683  	BSF STATUS, RP0
030A  0508  	ANDWF gbl_trisd, W
030B  0088  	MOVWF gbl_trisd

	if ((0))
		portd = (portd & 0xFD) | 0x02;
	else
		portd = portd & 0xFD;
030C  30FD  	MOVLW 0xFD
030D  1283  	BCF STATUS, RP0
030E  0508  	ANDWF gbl_portd, W
030F  0088  	MOVWF gbl_portd


	//Delay
	//Delay: 1 ms
	delay_ms(1);
0310  3001  	MOVLW 0x01
0311  00FA  	MOVWF delay_ms_00000_arg_del
0312  2015  	CALL delay_ms_00000


}
0313  0008  	RETURN



void FCM_display_time()

{

	//Call Macro
	//Call Macro: off_all()
	FCM_off_all();
028A  2132  	CALL FCM_off_al_00051


	//Calculation
	//Calculation:
	//  digit = minute_ones
	FCV_DIGIT = FCV_MINUTE_ONES;
028B  0870  	MOVF gbl_FCV_MINUTE_ONES, W
028C  00EE  	MOVWF gbl_FCV_DIGIT


	//Call Macro
	//Call Macro: data_bank()
	FCM_data_bank();
028D  2194  	CALL FCM_data_b_00052


	//Call Macro
	//Call Macro: time_data_register()
	FCM_time_data_register();
028E  20BC  	CALL FCM_time_d_00056


	//Calculation
	//Calculation:
	//  digit = seconds_ones
	FCV_DIGIT = FCV_SECONDS_ONES;
028F  0874  	MOVF gbl_FCV_SECONDS_ONES, W
0290  1283  	BCF STATUS, RP0
0291  1303  	BCF STATUS, RP1
0292  00EE  	MOVWF gbl_FCV_DIGIT


	//Call Macro
	//Call Macro: data_bank()
	FCM_data_bank();
0293  2194  	CALL FCM_data_b_00052


	//Call Macro
	//Call Macro: time_data_register()
	FCM_time_data_register();
0294  20BC  	CALL FCM_time_d_00056


	//Call Macro
	//Call Macro: latch()
	FCM_latch();
0295  2144  	CALL FCM_latch_00000


	//Digit2
	//Output: 0 -> D0
	trisd = trisd & 0xFE;
0296  30FE  	MOVLW 0xFE
0297  1683  	BSF STATUS, RP0
0298  0508  	ANDWF gbl_trisd, W
0299  0088  	MOVWF gbl_trisd

	if ((0))
		portd = (portd & 0xFE) | 0x01;
	else
		portd = portd & 0xFE;
029A  30FE  	MOVLW 0xFE
029B  1283  	BCF STATUS, RP0
029C  0508  	ANDWF gbl_portd, W
029D  0088  	MOVWF gbl_portd


	//Digit1
	//Output: 1 -> D1
	trisd = trisd & 0xFD;
029E  30FD  	MOVLW 0xFD
029F  1683  	BSF STATUS, RP0
02A0  0508  	ANDWF gbl_trisd, W
02A1  0088  	MOVWF gbl_trisd

	if ((1))
		portd = (portd & 0xFD) | 0x02;
02A2  30FD  	MOVLW 0xFD
02A3  1283  	BCF STATUS, RP0
02A4  0508  	ANDWF gbl_portd, W
02A5  00FA  	MOVWF CompTempVar2196
02A6  3002  	MOVLW 0x02
02A7  047A  	IORWF CompTempVar2196, W
02A8  0088  	MOVWF gbl_portd

	else
		portd = portd & 0xFD;

	//Delay
	//Delay: 1 ms
	delay_ms(1);
02A9  3001  	MOVLW 0x01
02AA  00FA  	MOVWF delay_ms_00000_arg_del
02AB  2015  	CALL delay_ms_00000


	//Comment:
	//END of Digit1

	//Call Macro
	//Call Macro: off_all()
	FCM_off_all();
02AC  2132  	CALL FCM_off_al_00051


	//Calculation
	//Calculation:
	//  digit = minute_tens
	FCV_DIGIT = FCV_MINUTE_TENS;
02AD  086A  	MOVF gbl_FCV_MINUTE_TENS, W
02AE  00EE  	MOVWF gbl_FCV_DIGIT


	//Call Macro
	//Call Macro: data_bank()
	FCM_data_bank();
02AF  2194  	CALL FCM_data_b_00052


	//Call Macro
	//Call Macro: time_data_register()
	FCM_time_data_register();
02B0  20BC  	CALL FCM_time_d_00056


	//Calculation
	//Calculation:
	//  digit = seconds_tens
	FCV_DIGIT = FCV_SECONDS_TENS;
02B1  1283  	BCF STATUS, RP0
02B2  1303  	BCF STATUS, RP1
02B3  086C  	MOVF gbl_FCV_SECONDS_TENS, W
02B4  00EE  	MOVWF gbl_FCV_DIGIT


	//Call Macro
	//Call Macro: data_bank()
	FCM_data_bank();
02B5  2194  	CALL FCM_data_b_00052


	//Call Macro
	//Call Macro: time_data_register()
	FCM_time_data_register();
02B6  20BC  	CALL FCM_time_d_00056


	//Call Macro
	//Call Macro: latch()
	FCM_latch();
02B7  2144  	CALL FCM_latch_00000


	//Digit2
	//Output: 1 -> D0
	trisd = trisd & 0xFE;
02B8  30FE  	MOVLW 0xFE
02B9  1683  	BSF STATUS, RP0
02BA  0508  	ANDWF gbl_trisd, W
02BB  0088  	MOVWF gbl_trisd

	if ((1))
		portd = (portd & 0xFE) | 0x01;
02BC  30FE  	MOVLW 0xFE
02BD  1283  	BCF STATUS, RP0
02BE  0508  	ANDWF gbl_portd, W
02BF  00FA  	MOVWF CompTempVar2197
02C0  3001  	MOVLW 0x01
02C1  047A  	IORWF CompTempVar2197, W
02C2  0088  	MOVWF gbl_portd

	else
		portd = portd & 0xFE;

	//Digit1
	//Output: 0 -> D1
	trisd = trisd & 0xFD;
02C3  30FD  	MOVLW 0xFD
02C4  1683  	BSF STATUS, RP0
02C5  0508  	ANDWF gbl_trisd, W
02C6  0088  	MOVWF gbl_trisd

	if ((0))
		portd = (portd & 0xFD) | 0x02;
	else
		portd = portd & 0xFD;
02C7  30FD  	MOVLW 0xFD
02C8  1283  	BCF STATUS, RP0
02C9  0508  	ANDWF gbl_portd, W
02CA  0088  	MOVWF gbl_portd


	//Delay
	//Delay: 1 ms
	delay_ms(1);
02CB  3001  	MOVLW 0x01
02CC  00FA  	MOVWF delay_ms_00000_arg_del
02CD  2015  	CALL delay_ms_00000


}
02CE  0008  	RETURN



void FCM_time_data_register()

{

	//Loop
	//Loop: Loop 8 times
	for (FCLV_LOOP2=0; FCLV_LOOP2<8; FCLV_LOOP2++)
00BC  01F8  	CLRF gbl_FCLV_LOOP2
00BD        label13
00BD  3008  	MOVLW 0x08
00BE  0278  	SUBWF gbl_FCLV_LOOP2, W
00BF  1803  	BTFSC STATUS,C
00F5  0AF8  	INCF gbl_FCLV_LOOP2, F
00F6  28BD  	GOTO	label13

	{

		//Calculation
		//Calculation:
		//  dat = bits AND 1
		FCV_DAT = FCV_BITS & 1;
00C1  3001  	MOVLW 0x01
00C2  1283  	BCF STATUS, RP0
00C3  1303  	BCF STATUS, RP1
00C4  056B  	ANDWF gbl_FCV_BITS, W
00C5  00FA  	MOVWF CompTempVar2198
00C6  01FB  	CLRF CompTempVar2199
00C7  08FA  	MOVF CompTempVar2198, F
00C8  1D03  	BTFSS STATUS,Z
00C9  147B  	BSF CompTempVar2199,0
00CA  1064  	BCF gbl_FCV_DAT,0
00CB  087B  	MOVF CompTempVar2199, W
00CC  1D03  	BTFSS STATUS,Z
00CD  1464  	BSF gbl_FCV_DAT,0


		//time_data
		//Output: dat -> C2
		trisc = trisc & 0xFB;
00CE  30FB  	MOVLW 0xFB
00CF  1683  	BSF STATUS, RP0
00D0  0507  	ANDWF gbl_trisc, W
00D1  0087  	MOVWF gbl_trisc

		if ((FCV_DAT))
00D2  1283  	BCF STATUS, RP0
00D3  1C64  	BTFSS gbl_FCV_DAT,0
00D4  28DC  	GOTO	label14
00DC        label14

			portc = (portc & 0xFB) | 0x04;
00D5  30FB  	MOVLW 0xFB
00D6  0507  	ANDWF gbl_portc, W
00D7  00FA  	MOVWF CompTempVar2200
00D8  3004  	MOVLW 0x04
00D9  047A  	IORWF CompTempVar2200, W
00DA  0087  	MOVWF gbl_portc

		else
00DB  28DF  	GOTO	label15
00DF        label15

			portc = portc & 0xFB;
00DC  30FB  	MOVLW 0xFB
00DD  0507  	ANDWF gbl_portc, W
00DE  0087  	MOVWF gbl_portc


		//clk
		//Output: 1 -> C0
		trisc = trisc & 0xFE;
00DF  30FE  	MOVLW 0xFE
00E0  1683  	BSF STATUS, RP0
00E1  0507  	ANDWF gbl_trisc, W
00E2  0087  	MOVWF gbl_trisc

		if ((1))
			portc = (portc & 0xFE) | 0x01;
00E3  30FE  	MOVLW 0xFE
00E4  1283  	BCF STATUS, RP0
00E5  0507  	ANDWF gbl_portc, W
00E6  00FA  	MOVWF CompTempVar2201
00E7  3001  	MOVLW 0x01
00E8  047A  	IORWF CompTempVar2201, W
00E9  0087  	MOVWF gbl_portc

		else
			portc = portc & 0xFE;

		//clk
		//Output: 0 -> C0
		trisc = trisc & 0xFE;
00EA  30FE  	MOVLW 0xFE
00EB  1683  	BSF STATUS, RP0
00EC  0507  	ANDWF gbl_trisc, W
00ED  0087  	MOVWF gbl_trisc

		if ((0))
			portc = (portc & 0xFE) | 0x01;
		else
			portc = portc & 0xFE;
00EE  30FE  	MOVLW 0xFE
00EF  1283  	BCF STATUS, RP0
00F0  0507  	ANDWF gbl_portc, W
00F1  0087  	MOVWF gbl_portc


		//Calculation
		//Calculation:
		//  bits = bits >> 1
		FCV_BITS = FCV_BITS >> 1;
00F2  08EB  	MOVF gbl_FCV_BITS, F
00F3  1003  	BCF STATUS,C
00F4  0CEB  	RRF gbl_FCV_BITS, F



	}

}
00C0  0008  	RETURN



void FCM_foulperiod_data_register()

{

	//Loop
	//Loop: Loop 8 times
	for (FCLV_LOOP3=0; FCLV_LOOP3<8; FCLV_LOOP3++)
0159  01F9  	CLRF gbl_FCLV_LOOP3
015A        label19
015A  3008  	MOVLW 0x08
015B  0279  	SUBWF gbl_FCLV_LOOP3, W
015C  1803  	BTFSC STATUS,C
0192  0AF9  	INCF gbl_FCLV_LOOP3, F
0193  295A  	GOTO	label19

	{

		//Calculation
		//Calculation:
		//  dat = bits AND 1
		FCV_DAT = FCV_BITS & 1;
015E  3001  	MOVLW 0x01
015F  1283  	BCF STATUS, RP0
0160  1303  	BCF STATUS, RP1
0161  056B  	ANDWF gbl_FCV_BITS, W
0162  00FA  	MOVWF CompTempVar2203
0163  01FB  	CLRF CompTempVar2204
0164  08FA  	MOVF CompTempVar2203, F
0165  1D03  	BTFSS STATUS,Z
0166  147B  	BSF CompTempVar2204,0
0167  1064  	BCF gbl_FCV_DAT,0
0168  087B  	MOVF CompTempVar2204, W
0169  1D03  	BTFSS STATUS,Z
016A  1464  	BSF gbl_FCV_DAT,0


		//foulperiod_data
		//Output: dat -> C4
		trisc = trisc & 0xEF;
016B  30EF  	MOVLW 0xEF
016C  1683  	BSF STATUS, RP0
016D  0507  	ANDWF gbl_trisc, W
016E  0087  	MOVWF gbl_trisc

		if ((FCV_DAT))
016F  1283  	BCF STATUS, RP0
0170  1C64  	BTFSS gbl_FCV_DAT,0
0171  2979  	GOTO	label20
0179        label20

			portc = (portc & 0xEF) | 0x10;
0172  30EF  	MOVLW 0xEF
0173  0507  	ANDWF gbl_portc, W
0174  00FA  	MOVWF CompTempVar2205
0175  3010  	MOVLW 0x10
0176  047A  	IORWF CompTempVar2205, W
0177  0087  	MOVWF gbl_portc

		else
0178  297C  	GOTO	label21
017C        label21

			portc = portc & 0xEF;
0179  30EF  	MOVLW 0xEF
017A  0507  	ANDWF gbl_portc, W
017B  0087  	MOVWF gbl_portc


		//clk
		//Output: 1 -> C0
		trisc = trisc & 0xFE;
017C  30FE  	MOVLW 0xFE
017D  1683  	BSF STATUS, RP0
017E  0507  	ANDWF gbl_trisc, W
017F  0087  	MOVWF gbl_trisc

		if ((1))
			portc = (portc & 0xFE) | 0x01;
0180  30FE  	MOVLW 0xFE
0181  1283  	BCF STATUS, RP0
0182  0507  	ANDWF gbl_portc, W
0183  00FA  	MOVWF CompTempVar2206
0184  3001  	MOVLW 0x01
0185  047A  	IORWF CompTempVar2206, W
0186  0087  	MOVWF gbl_portc

		else
			portc = portc & 0xFE;

		//clk
		//Output: 0 -> C0
		trisc = trisc & 0xFE;
0187  30FE  	MOVLW 0xFE
0188  1683  	BSF STATUS, RP0
0189  0507  	ANDWF gbl_trisc, W
018A  0087  	MOVWF gbl_trisc

		if ((0))
			portc = (portc & 0xFE) | 0x01;
		else
			portc = portc & 0xFE;
018B  30FE  	MOVLW 0xFE
018C  1283  	BCF STATUS, RP0
018D  0507  	ANDWF gbl_portc, W
018E  0087  	MOVWF gbl_portc


		//Calculation
		//Calculation:
		//  bits = bits >> 1
		FCV_BITS = FCV_BITS >> 1;
018F  08EB  	MOVF gbl_FCV_BITS, F
0190  1003  	BCF STATUS,C
0191  0CEB  	RRF gbl_FCV_BITS, F



	}

}
015D  0008  	RETURN



void FCM_foulperiod_display()

{

	//Call Macro
	//Call Macro: off_all()
	FCM_off_all();
0245  2132  	CALL FCM_off_al_00051


	//Calculation
	//Calculation:
	//  digit = away_foul
	FCV_DIGIT = FCV_AWAY_FOUL;
0246  0876  	MOVF gbl_FCV_AWAY_FOUL, W
0247  00EE  	MOVWF gbl_FCV_DIGIT


	//Call Macro
	//Call Macro: data_bank()
	FCM_data_bank();
0248  2194  	CALL FCM_data_b_00052


	//Call Macro
	//Call Macro: foulperiod_data_register()
	FCM_foulperiod_data_register();
0249  2159  	CALL FCM_foulpe_00057


	//Calculation
	//Calculation:
	//  digit = period
	FCV_DIGIT = FCV_PERIOD;
024A  1283  	BCF STATUS, RP0
024B  1303  	BCF STATUS, RP1
024C  0866  	MOVF gbl_FCV_PERIOD, W
024D  00EE  	MOVWF gbl_FCV_DIGIT


	//Call Macro
	//Call Macro: data_bank()
	FCM_data_bank();
024E  2194  	CALL FCM_data_b_00052


	//Call Macro
	//Call Macro: foulperiod_data_register()
	FCM_foulperiod_data_register();
024F  2159  	CALL FCM_foulpe_00057


	//Call Macro
	//Call Macro: latch()
	FCM_latch();
0250  2144  	CALL FCM_latch_00000


	//Digit2
	//Output: 0 -> D0
	trisd = trisd & 0xFE;
0251  30FE  	MOVLW 0xFE
0252  1683  	BSF STATUS, RP0
0253  0508  	ANDWF gbl_trisd, W
0254  0088  	MOVWF gbl_trisd

	if ((0))
		portd = (portd & 0xFE) | 0x01;
	else
		portd = portd & 0xFE;
0255  30FE  	MOVLW 0xFE
0256  1283  	BCF STATUS, RP0
0257  0508  	ANDWF gbl_portd, W
0258  0088  	MOVWF gbl_portd


	//Digit1
	//Output: 1 -> D1
	trisd = trisd & 0xFD;
0259  30FD  	MOVLW 0xFD
025A  1683  	BSF STATUS, RP0
025B  0508  	ANDWF gbl_trisd, W
025C  0088  	MOVWF gbl_trisd

	if ((1))
		portd = (portd & 0xFD) | 0x02;
025D  30FD  	MOVLW 0xFD
025E  1283  	BCF STATUS, RP0
025F  0508  	ANDWF gbl_portd, W
0260  00FA  	MOVWF CompTempVar2208
0261  3002  	MOVLW 0x02
0262  047A  	IORWF CompTempVar2208, W
0263  0088  	MOVWF gbl_portd

	else
		portd = portd & 0xFD;

	//Delay
	//Delay: 1 ms
	delay_ms(1);
0264  3001  	MOVLW 0x01
0265  00FA  	MOVWF delay_ms_00000_arg_del
0266  2015  	CALL delay_ms_00000


	//Call Macro
	//Call Macro: off_all()
	FCM_off_all();
0267  2132  	CALL FCM_off_al_00051


	//Calculation
	//Calculation:
	//  digit = home_foul
	FCV_DIGIT = FCV_HOME_FOUL;
0268  0868  	MOVF gbl_FCV_HOME_FOUL, W
0269  00EE  	MOVWF gbl_FCV_DIGIT


	//Call Macro
	//Call Macro: data_bank()
	FCM_data_bank();
026A  2194  	CALL FCM_data_b_00052


	//Call Macro
	//Call Macro: foulperiod_data_register()
	FCM_foulperiod_data_register();
026B  2159  	CALL FCM_foulpe_00057


	//Calculation
	//Calculation:
	//  digit = period
	FCV_DIGIT = FCV_PERIOD;
026C  1283  	BCF STATUS, RP0
026D  1303  	BCF STATUS, RP1
026E  0866  	MOVF gbl_FCV_PERIOD, W
026F  00EE  	MOVWF gbl_FCV_DIGIT


	//Call Macro
	//Call Macro: data_bank()
	FCM_data_bank();
0270  2194  	CALL FCM_data_b_00052


	//Call Macro
	//Call Macro: foulperiod_data_register()
	FCM_foulperiod_data_register();
0271  2159  	CALL FCM_foulpe_00057


	//Call Macro
	//Call Macro: latch()
	FCM_latch();
0272  2144  	CALL FCM_latch_00000


	//Digit2
	//Output: 1 -> D0
	trisd = trisd & 0xFE;
0273  30FE  	MOVLW 0xFE
0274  1683  	BSF STATUS, RP0
0275  0508  	ANDWF gbl_trisd, W
0276  0088  	MOVWF gbl_trisd

	if ((1))
		portd = (portd & 0xFE) | 0x01;
0277  30FE  	MOVLW 0xFE
0278  1283  	BCF STATUS, RP0
0279  0508  	ANDWF gbl_portd, W
027A  00FA  	MOVWF CompTempVar2209
027B  3001  	MOVLW 0x01
027C  047A  	IORWF CompTempVar2209, W
027D  0088  	MOVWF gbl_portd

	else
		portd = portd & 0xFE;

	//Digit1
	//Output: 0 -> D1
	trisd = trisd & 0xFD;
027E  30FD  	MOVLW 0xFD
027F  1683  	BSF STATUS, RP0
0280  0508  	ANDWF gbl_trisd, W
0281  0088  	MOVWF gbl_trisd

	if ((0))
		portd = (portd & 0xFD) | 0x02;
	else
		portd = portd & 0xFD;
0282  30FD  	MOVLW 0xFD
0283  1283  	BCF STATUS, RP0
0284  0508  	ANDWF gbl_portd, W
0285  0088  	MOVWF gbl_portd


	//Delay
	//Delay: 1 ms
	delay_ms(1);
0286  3001  	MOVLW 0x01
0287  00FA  	MOVWF delay_ms_00000_arg_del
0288  2015  	CALL delay_ms_00000


}
0289  0008  	RETURN




void main()

{
	//Initialization
	ansel = 0;
0448  1683  	BSF STATUS, RP0
0449  1703  	BSF STATUS, RP1
044A  0188  	CLRF gbl_ansel

anselh = 0;
044B  0189  	CLRF gbl_anselh


	
		RS232_1_UART_Init( );		//Call initialise function
044C  2236  	CALL FC_CAL_UAR_00059



	//Interrupt initialization code
	option_reg = 0xC0;
044D  30C0  	MOVLW 0xC0
044E  0081  	MOVWF gbl_option_reg



	//Home_ONE
	//Output: 0 -> D2
	trisd = trisd & 0xFB;
044F  30FB  	MOVLW 0xFB
0450  0508  	ANDWF gbl_trisd, W
0451  0088  	MOVWF gbl_trisd

	if ((0))
		portd = (portd & 0xFB) | 0x04;
	else
		portd = portd & 0xFB;
0452  30FB  	MOVLW 0xFB
0453  1283  	BCF STATUS, RP0
0454  0508  	ANDWF gbl_portd, W
0455  0088  	MOVWF gbl_portd


	//Guest_ONE
	//Output: 0 -> D3
	trisd = trisd & 0xF7;
0456  30F7  	MOVLW 0xF7
0457  1683  	BSF STATUS, RP0
0458  0508  	ANDWF gbl_trisd, W
0459  0088  	MOVWF gbl_trisd

	if ((0))
		portd = (portd & 0xF7) | 0x08;
	else
		portd = portd & 0xF7;
045A  30F7  	MOVLW 0xF7
045B  1283  	BCF STATUS, RP0
045C  0508  	ANDWF gbl_portd, W
045D  0088  	MOVWF gbl_portd


	//clk
	//Output: 0 -> C0
	trisc = trisc & 0xFE;
045E  30FE  	MOVLW 0xFE
045F  1683  	BSF STATUS, RP0
0460  0507  	ANDWF gbl_trisc, W
0461  0087  	MOVWF gbl_trisc

	if ((0))
		portc = (portc & 0xFE) | 0x01;
	else
		portc = portc & 0xFE;
0462  30FE  	MOVLW 0xFE
0463  1283  	BCF STATUS, RP0
0464  0507  	ANDWF gbl_portc, W
0465  0087  	MOVWF gbl_portc


	//reg
	//Output: 0 -> C1
	trisc = trisc & 0xFD;
0466  30FD  	MOVLW 0xFD
0467  1683  	BSF STATUS, RP0
0468  0507  	ANDWF gbl_trisc, W
0469  0087  	MOVWF gbl_trisc

	if ((0))
		portc = (portc & 0xFD) | 0x02;
	else
		portc = portc & 0xFD;
046A  30FD  	MOVLW 0xFD
046B  1283  	BCF STATUS, RP0
046C  0507  	ANDWF gbl_portc, W
046D  0087  	MOVWF gbl_portc


	//Digit2
	//Output: 0 -> D0
	trisd = trisd & 0xFE;
046E  30FE  	MOVLW 0xFE
046F  1683  	BSF STATUS, RP0
0470  0508  	ANDWF gbl_trisd, W
0471  0088  	MOVWF gbl_trisd

	if ((0))
		portd = (portd & 0xFE) | 0x01;
	else
		portd = portd & 0xFE;
0472  30FE  	MOVLW 0xFE
0473  1283  	BCF STATUS, RP0
0474  0508  	ANDWF gbl_portd, W
0475  0088  	MOVWF gbl_portd


	//Digit1
	//Output: 1 -> D1
	trisd = trisd & 0xFD;
0476  30FD  	MOVLW 0xFD
0477  1683  	BSF STATUS, RP0
0478  0508  	ANDWF gbl_trisd, W
0479  0088  	MOVWF gbl_trisd

	if ((1))
		portd = (portd & 0xFD) | 0x02;
047A  30FD  	MOVLW 0xFD
047B  1283  	BCF STATUS, RP0
047C  0508  	ANDWF gbl_portd, W
047D  00FA  	MOVWF CompTempVar2220
047E  3002  	MOVLW 0x02
047F  047A  	IORWF CompTempVar2220, W
0480  0088  	MOVWF gbl_portd

	else
		portd = portd & 0xFD;

	//Dot
	//Output: 0 -> D5
	trisd = trisd & 0xDF;
0481  30DF  	MOVLW 0xDF
0482  1683  	BSF STATUS, RP0
0483  0508  	ANDWF gbl_trisd, W
0484  0088  	MOVWF gbl_trisd

	if ((0))
		portd = (portd & 0xDF) | 0x20;
	else
		portd = portd & 0xDF;
0485  30DF  	MOVLW 0xDF
0486  1283  	BCF STATUS, RP0
0487  0508  	ANDWF gbl_portd, W
0488  0088  	MOVWF gbl_portd


	//Colon
	//Output: 1 -> D4
	trisd = trisd & 0xEF;
0489  30EF  	MOVLW 0xEF
048A  1683  	BSF STATUS, RP0
048B  0508  	ANDWF gbl_trisd, W
048C  0088  	MOVWF gbl_trisd

	if ((1))
		portd = (portd & 0xEF) | 0x10;
048D  30EF  	MOVLW 0xEF
048E  1283  	BCF STATUS, RP0
048F  0508  	ANDWF gbl_portd, W
0490  00FA  	MOVWF CompTempVar2221
0491  3010  	MOVLW 0x10
0492  047A  	IORWF CompTempVar2221, W
0493  0088  	MOVWF gbl_portd

	else
		portd = portd & 0xEF;

	//home_one
	//Output: 1 -> D2
	trisd = trisd & 0xFB;
0494  30FB  	MOVLW 0xFB
0495  1683  	BSF STATUS, RP0
0496  0508  	ANDWF gbl_trisd, W
0497  0088  	MOVWF gbl_trisd

	if ((1))
		portd = (portd & 0xFB) | 0x04;
0498  30FB  	MOVLW 0xFB
0499  1283  	BCF STATUS, RP0
049A  0508  	ANDWF gbl_portd, W
049B  00FA  	MOVWF CompTempVar2222
049C  3004  	MOVLW 0x04
049D  047A  	IORWF CompTempVar2222, W
049E  0088  	MOVWF gbl_portd

	else
		portd = portd & 0xFB;

	//away_one
	//Output: 1 -> D3
	trisd = trisd & 0xF7;
049F  30F7  	MOVLW 0xF7
04A0  1683  	BSF STATUS, RP0
04A1  0508  	ANDWF gbl_trisd, W
04A2  0088  	MOVWF gbl_trisd

	if ((1))
		portd = (portd & 0xF7) | 0x08;
04A3  30F7  	MOVLW 0xF7
04A4  1283  	BCF STATUS, RP0
04A5  0508  	ANDWF gbl_portd, W
04A6  00FA  	MOVWF CompTempVar2223
04A7  3008  	MOVLW 0x08
04A8  047A  	IORWF CompTempVar2223, W
04A9  0088  	MOVWF gbl_portd

	else
		portd = portd & 0xF7;

	//Loop
	//Loop: While 1
	while (1)
04AA        label57
05E3  2CAA  	GOTO	label57

	{

		//Call Component Macro
		//Call Component Macro: header=ReceiveRS232Char(1)
		FCV_HEADER = FCD_RS2320_ReceiveRS232Char(1);
04AA  3001  	MOVLW 0x01
04AB  00FA  	MOVWF FCD_RS2320_00060_arg_nTimeout
04AC  243E  	CALL FCD_RS2320_00060
04AD  087C  	MOVF CompTempVarRet2215, W
04AE  00F2  	MOVWF gbl_FCV_HEADER


		//Decision
		//Decision: header = ':'?
		if (FCV_HEADER == ':')
04AF  0872  	MOVF gbl_FCV_HEADER, W
04B0  3A3A  	XORLW 0x3A
04B1  1D03  	BTFSS STATUS,Z
04B2  2CAA  	GOTO	label57

		{

			//Call Component Macro
			//Call Component Macro: recv=ReceiveRS232String(1, 18)
			FCD_RS2320_ReceiveRS232String(FCV_RECV,FCSZ_RECV, 1, 18);
04B3  3000  	MOVLW HIGH(gbl_FCV_RECV+D'0')
04B4  00FB  	MOVWF FCD_RS2320_00061_arg_FCR_RETVAL+D'1'
04B5  3020  	MOVLW LOW(gbl_FCV_RECV+D'0')
04B6  00FA  	MOVWF FCD_RS2320_00061_arg_FCR_RETVAL
04B7  3012  	MOVLW 0x12
04B8  00FC  	MOVWF FCD_RS2320_00061_arg_FCR_R_00062
04B9  3001  	MOVLW 0x01
04BA  00FD  	MOVWF FCD_RS2320_00061_arg_nTimeout
04BB  3012  	MOVLW 0x12
04BC  00FE  	MOVWF FCD_RS2320_00061_arg_NumBytes
04BD  2402  	CALL FCD_RS2320_00061


			//Calculation
			//Calculation:
			//  string_minutes = Right$ (recv,17)
			//  string_seconds = Right$ (recv,14)
			//  string_foulperiod = Right$ (recv,11)
			//  string_score_away = Right$ (recv,7)
			//  string_score_home = Right$ (recv,3)
			FCI_RIGHTSTRING(FCV_RECV, FCSZ_RECV, 17, FCV_STRING_MINUTES,FCSZ_STRING_MINUTES);
04BE  3000  	MOVLW HIGH(gbl_FCV_RECV+D'0')
04BF  00FB  	MOVWF FCI_RIGHTS_00048_arg_sSrc+D'1'
04C0  3020  	MOVLW LOW(gbl_FCV_RECV+D'0')
04C1  00FA  	MOVWF FCI_RIGHTS_00048_arg_sSrc
04C2  3012  	MOVLW 0x12
04C3  00FC  	MOVWF FCI_RIGHTS_00048_arg_iSrc_len
04C4  3011  	MOVLW 0x11
04C5  00FD  	MOVWF FCI_RIGHTS_00048_arg_iCount
04C6  3000  	MOVLW HIGH(gbl_FCV_STRING_MINUTES+D'0')
04C7  00A1  	MOVWF FCI_RIGHTS_00048_arg_sDst+D'1'
04C8  3058  	MOVLW LOW(gbl_FCV_STRING_MINUTES+D'0')
04C9  00A0  	MOVWF FCI_RIGHTS_00048_arg_sDst
04CA  3002  	MOVLW 0x02
04CB  00FE  	MOVWF FCI_RIGHTS_00048_arg_iDst_len
04CC  23AD  	CALL FCI_RIGHTS_00048

			FCI_RIGHTSTRING(FCV_RECV, FCSZ_RECV, 14, FCV_STRING_SECONDS,FCSZ_STRING_SECONDS);
04CD  3000  	MOVLW HIGH(gbl_FCV_RECV+D'0')
04CE  00FB  	MOVWF FCI_RIGHTS_00048_arg_sSrc+D'1'
04CF  3020  	MOVLW LOW(gbl_FCV_RECV+D'0')
04D0  00FA  	MOVWF FCI_RIGHTS_00048_arg_sSrc
04D1  3012  	MOVLW 0x12
04D2  00FC  	MOVWF FCI_RIGHTS_00048_arg_iSrc_len
04D3  300E  	MOVLW 0x0E
04D4  00FD  	MOVWF FCI_RIGHTS_00048_arg_iCount
04D5  3000  	MOVLW HIGH(gbl_FCV_STRING_SECONDS+D'0')
04D6  00A1  	MOVWF FCI_RIGHTS_00048_arg_sDst+D'1'
04D7  3056  	MOVLW LOW(gbl_FCV_STRING_SECONDS+D'0')
04D8  00A0  	MOVWF FCI_RIGHTS_00048_arg_sDst
04D9  3002  	MOVLW 0x02
04DA  00FE  	MOVWF FCI_RIGHTS_00048_arg_iDst_len
04DB  23AD  	CALL FCI_RIGHTS_00048

			FCI_RIGHTSTRING(FCV_RECV, FCSZ_RECV, 11, FCV_STRING_FOULPERIOD,FCSZ_STRING_FOULPERIOD);
04DC  3000  	MOVLW HIGH(gbl_FCV_RECV+D'0')
04DD  00FB  	MOVWF FCI_RIGHTS_00048_arg_sSrc+D'1'
04DE  3020  	MOVLW LOW(gbl_FCV_RECV+D'0')
04DF  00FA  	MOVWF FCI_RIGHTS_00048_arg_sSrc
04E0  3012  	MOVLW 0x12
04E1  00FC  	MOVWF FCI_RIGHTS_00048_arg_iSrc_len
04E2  300B  	MOVLW 0x0B
04E3  00FD  	MOVWF FCI_RIGHTS_00048_arg_iCount
04E4  3000  	MOVLW HIGH(gbl_FCV_STRING_FOULPERIOD+D'0')
04E5  00A1  	MOVWF FCI_RIGHTS_00048_arg_sDst+D'1'
04E6  3049  	MOVLW LOW(gbl_FCV_STRING_FOULPERIOD+D'0')
04E7  00A0  	MOVWF FCI_RIGHTS_00048_arg_sDst
04E8  3003  	MOVLW 0x03
04E9  00FE  	MOVWF FCI_RIGHTS_00048_arg_iDst_len
04EA  23AD  	CALL FCI_RIGHTS_00048

			FCI_RIGHTSTRING(FCV_RECV, FCSZ_RECV, 7, FCV_STRING_SCORE_AWAY,FCSZ_STRING_SCORE_AWAY);
04EB  3000  	MOVLW HIGH(gbl_FCV_RECV+D'0')
04EC  00FB  	MOVWF FCI_RIGHTS_00048_arg_sSrc+D'1'
04ED  3020  	MOVLW LOW(gbl_FCV_RECV+D'0')
04EE  00FA  	MOVWF FCI_RIGHTS_00048_arg_sSrc
04EF  3012  	MOVLW 0x12
04F0  00FC  	MOVWF FCI_RIGHTS_00048_arg_iSrc_len
04F1  3007  	MOVLW 0x07
04F2  00FD  	MOVWF FCI_RIGHTS_00048_arg_iCount
04F3  3000  	MOVLW HIGH(gbl_FCV_STRING_SCORE_AWAY+D'0')
04F4  00A1  	MOVWF FCI_RIGHTS_00048_arg_sDst+D'1'
04F5  304C  	MOVLW LOW(gbl_FCV_STRING_SCORE_AWAY+D'0')
04F6  00A0  	MOVWF FCI_RIGHTS_00048_arg_sDst
04F7  3003  	MOVLW 0x03
04F8  00FE  	MOVWF FCI_RIGHTS_00048_arg_iDst_len
04F9  23AD  	CALL FCI_RIGHTS_00048

			FCI_RIGHTSTRING(FCV_RECV, FCSZ_RECV, 3, FCV_STRING_SCORE_HOME,FCSZ_STRING_SCORE_HOME);
04FA  3000  	MOVLW HIGH(gbl_FCV_RECV+D'0')
04FB  00FB  	MOVWF FCI_RIGHTS_00048_arg_sSrc+D'1'
04FC  3020  	MOVLW LOW(gbl_FCV_RECV+D'0')
04FD  00FA  	MOVWF FCI_RIGHTS_00048_arg_sSrc
04FE  3012  	MOVLW 0x12
04FF  00FC  	MOVWF FCI_RIGHTS_00048_arg_iSrc_len
0500  3003  	MOVLW 0x03
0501  00FD  	MOVWF FCI_RIGHTS_00048_arg_iCount
0502  3000  	MOVLW HIGH(gbl_FCV_STRING_SCORE_HOME+D'0')
0503  00A1  	MOVWF FCI_RIGHTS_00048_arg_sDst+D'1'
0504  3046  	MOVLW LOW(gbl_FCV_STRING_SCORE_HOME+D'0')
0505  00A0  	MOVWF FCI_RIGHTS_00048_arg_sDst
0506  3003  	MOVLW 0x03
0507  00FE  	MOVWF FCI_RIGHTS_00048_arg_iDst_len
0508  23AD  	CALL FCI_RIGHTS_00048


			//Calculation
			//Calculation:
			//  score_home = StringToInt$ (string_score_away)
			//  score_away = StringToInt$ (string_score_home)
			//  foulperiod = StringToInt$ (string_foulperiod)
			//  minutes = StringToInt$ (string_minutes)
			//  seconds = StringToInt$ (string_seconds)
			FCV_SCORE_HOME = FCI_STRING_TO_INT(FCV_STRING_SCORE_AWAY, FCSZ_STRING_SCORE_AWAY);
0509  3000  	MOVLW HIGH(gbl_FCV_STRING_SCORE_AWAY+D'0')
050A  00FB  	MOVWF FCI_STRING_0004F_arg_String+D'1'
050B  304C  	MOVLW LOW(gbl_FCV_STRING_SCORE_AWAY+D'0')
050C  00FA  	MOVWF FCI_STRING_0004F_arg_String
050D  3003  	MOVLW 0x03
050E  00FC  	MOVWF FCI_STRING_0004F_arg_MSZ_String
050F  2314  	CALL FCI_STRING_0004F
0510  0825  	MOVF CompTempVarRet2056, W
0511  00F3  	MOVWF gbl_FCV_SCORE_HOME

			FCV_SCORE_AWAY = FCI_STRING_TO_INT(FCV_STRING_SCORE_HOME, FCSZ_STRING_SCORE_HOME);
0512  3000  	MOVLW HIGH(gbl_FCV_STRING_SCORE_HOME+D'0')
0513  00FB  	MOVWF FCI_STRING_0004F_arg_String+D'1'
0514  3046  	MOVLW LOW(gbl_FCV_STRING_SCORE_HOME+D'0')
0515  00FA  	MOVWF FCI_STRING_0004F_arg_String
0516  3003  	MOVLW 0x03
0517  00FC  	MOVWF FCI_STRING_0004F_arg_MSZ_String
0518  2314  	CALL FCI_STRING_0004F
0519  0825  	MOVF CompTempVarRet2056, W
051A  1283  	BCF STATUS, RP0
051B  00ED  	MOVWF gbl_FCV_SCORE_AWAY

			FCV_FOULPERIOD = FCI_STRING_TO_INT(FCV_STRING_FOULPERIOD, FCSZ_STRING_FOULPERIOD);
051C  3000  	MOVLW HIGH(gbl_FCV_STRING_FOULPERIOD+D'0')
051D  00FB  	MOVWF FCI_STRING_0004F_arg_String+D'1'
051E  3049  	MOVLW LOW(gbl_FCV_STRING_FOULPERIOD+D'0')
051F  00FA  	MOVWF FCI_STRING_0004F_arg_String
0520  3003  	MOVLW 0x03
0521  00FC  	MOVWF FCI_STRING_0004F_arg_MSZ_String
0522  2314  	CALL FCI_STRING_0004F
0523  0825  	MOVF CompTempVarRet2056, W
0524  1283  	BCF STATUS, RP0
0525  00D4  	MOVWF gbl_FCV_FOULPERIOD
0526  1683  	BSF STATUS, RP0
0527  0826  	MOVF CompTempVarRet2056+D'1', W
0528  1283  	BCF STATUS, RP0
0529  00D5  	MOVWF gbl_FCV_FOULPERIOD+D'1'

			FCV_MINUTES = FCI_STRING_TO_INT(FCV_STRING_MINUTES, FCSZ_STRING_MINUTES);
052A  3000  	MOVLW HIGH(gbl_FCV_STRING_MINUTES+D'0')
052B  00FB  	MOVWF FCI_STRING_0004F_arg_String+D'1'
052C  3058  	MOVLW LOW(gbl_FCV_STRING_MINUTES+D'0')
052D  00FA  	MOVWF FCI_STRING_0004F_arg_String
052E  3002  	MOVLW 0x02
052F  00FC  	MOVWF FCI_STRING_0004F_arg_MSZ_String
0530  2314  	CALL FCI_STRING_0004F
0531  0825  	MOVF CompTempVarRet2056, W
0532  1283  	BCF STATUS, RP0
0533  00E7  	MOVWF gbl_FCV_MINUTES

			FCV_SECONDS = FCI_STRING_TO_INT(FCV_STRING_SECONDS, FCSZ_STRING_SECONDS);
0534  3000  	MOVLW HIGH(gbl_FCV_STRING_SECONDS+D'0')
0535  00FB  	MOVWF FCI_STRING_0004F_arg_String+D'1'
0536  3056  	MOVLW LOW(gbl_FCV_STRING_SECONDS+D'0')
0537  00FA  	MOVWF FCI_STRING_0004F_arg_String
0538  3002  	MOVLW 0x02
0539  00FC  	MOVWF FCI_STRING_0004F_arg_MSZ_String
053A  2314  	CALL FCI_STRING_0004F
053B  0825  	MOVF CompTempVarRet2056, W
053C  1283  	BCF STATUS, RP0
053D  00E5  	MOVWF gbl_FCV_SECONDS


			//Calculation
			//Calculation:
			//  away_tens = score_away / 10
			//  away_ones = score_away % 10
			//  home_tens = score_home / 10
			//  home_ones = score_home % 10
			FCV_AWAY_TENS = FCV_SCORE_AWAY / 10;
053E  086D  	MOVF gbl_FCV_SCORE_AWAY, W
053F  00FA  	MOVWF __div_8_8_00000_arg_a
0540  300A  	MOVLW 0x0A
0541  00FB  	MOVWF __div_8_8_00000_arg_b
0542  2206  	CALL __div_8_8_00000
0543  087E  	MOVF CompTempVarRet218, W
0544  00E9  	MOVWF gbl_FCV_AWAY_TENS

			FCV_AWAY_ONES = FCV_SCORE_AWAY % 10;
0545  086D  	MOVF gbl_FCV_SCORE_AWAY, W
0546  00FA  	MOVWF __rem_8_8_00000_arg_a
0547  300A  	MOVLW 0x0A
0548  00FB  	MOVWF __rem_8_8_00000_arg_b
0549  21D4  	CALL __rem_8_8_00000
054A  087E  	MOVF CompTempVarRet220, W
054B  00EF  	MOVWF gbl_FCV_AWAY_ONES

			FCV_HOME_TENS = FCV_SCORE_HOME / 10;
054C  0873  	MOVF gbl_FCV_SCORE_HOME, W
054D  00FA  	MOVWF __div_8_8_00000_arg_a
054E  300A  	MOVLW 0x0A
054F  00FB  	MOVWF __div_8_8_00000_arg_b
0550  2206  	CALL __div_8_8_00000
0551  087E  	MOVF CompTempVarRet218, W
0552  00F1  	MOVWF gbl_FCV_HOME_TENS

			FCV_HOME_ONES = FCV_SCORE_HOME % 10;
0553  0873  	MOVF gbl_FCV_SCORE_HOME, W
0554  00FA  	MOVWF __rem_8_8_00000_arg_a
0555  300A  	MOVLW 0x0A
0556  00FB  	MOVWF __rem_8_8_00000_arg_b
0557  21D4  	CALL __rem_8_8_00000
0558  087E  	MOVF CompTempVarRet220, W
0559  00E3  	MOVWF gbl_FCV_HOME_ONES


			//Calculation
			//Calculation:
			//  home_foul = foulperiod / 100
			//  period = (foulperiod % 100) / 10
			//  away_foul = foulperiod % 10
			FCV_HOME_FOUL = FCV_FOULPERIOD / 100;
055A  01FA  	CLRF CompTempVar2241
055B  0854  	MOVF gbl_FCV_FOULPERIOD, W
055C  1683  	BSF STATUS, RP0
055D  00A0  	MOVWF __div_16_1_00003_arg_a
055E  1283  	BCF STATUS, RP0
055F  0855  	MOVF gbl_FCV_FOULPERIOD+D'1', W
0560  1683  	BSF STATUS, RP0
0561  00A1  	MOVWF __div_16_1_00003_arg_a+D'1'
0562  1283  	BCF STATUS, RP0
0563  1FD5  	BTFSS gbl_FCV_FOULPERIOD+D'1',7
0564  2D6C  	GOTO	label58
0565  1683  	BSF STATUS, RP0
0566  09A0  	COMF __div_16_1_00003_arg_a, F
0567  09A1  	COMF __div_16_1_00003_arg_a+D'1', F
0568  0AA0  	INCF __div_16_1_00003_arg_a, F
0569  1903  	BTFSC STATUS,Z
056A  0AA1  	INCF __div_16_1_00003_arg_a+D'1', F
056B  0AFA  	INCF CompTempVar2241, F
056C        label58
056C  3064  	MOVLW 0x64
056D  1683  	BSF STATUS, RP0
056E  00A2  	MOVWF __div_16_1_00003_arg_b
056F  01A3  	CLRF __div_16_1_00003_arg_b+D'1'
0570  2217  	CALL __div_16_1_00003
0571  0828  	MOVF CompTempVarRet214, W
0572  1283  	BCF STATUS, RP0
0573  00E8  	MOVWF gbl_FCV_HOME_FOUL
0574  1C7A  	BTFSS CompTempVar2241,0
0575  2D78  	GOTO	label59
0576  09E8  	COMF gbl_FCV_HOME_FOUL, F
0577  0AE8  	INCF gbl_FCV_HOME_FOUL, F
0578        label59

			FCV_PERIOD = (FCV_FOULPERIOD % 100) / 10;
0578  0854  	MOVF gbl_FCV_FOULPERIOD, W
0579  00FA  	MOVWF __rem_16_1_00004_arg_a
057A  0855  	MOVF gbl_FCV_FOULPERIOD+D'1', W
057B  00FB  	MOVWF __rem_16_1_00004_arg_a+D'1'
057C  1FD5  	BTFSS gbl_FCV_FOULPERIOD+D'1',7
057D  2D83  	GOTO	label60
057E  09FA  	COMF __rem_16_1_00004_arg_a, F
057F  09FB  	COMF __rem_16_1_00004_arg_a+D'1', F
0580  0AFA  	INCF __rem_16_1_00004_arg_a, F
0581  1903  	BTFSC STATUS,Z
0582  0AFB  	INCF __rem_16_1_00004_arg_a+D'1', F
0583        label60
0583  3064  	MOVLW 0x64
0584  00FC  	MOVWF __rem_16_1_00004_arg_b
0585  01FD  	CLRF __rem_16_1_00004_arg_b+D'1'
0586  21E5  	CALL __rem_16_1_00004
0587  0827  	MOVF CompTempVarRet216, W
0588  00A0  	MOVWF __div_16_1_00003_arg_a
0589  0828  	MOVF CompTempVarRet216+D'1', W
058A  00FE  	MOVWF CompTempVar2243
058B  1283  	BCF STATUS, RP0
058C  1FD5  	BTFSS gbl_FCV_FOULPERIOD+D'1',7
058D  2D94  	GOTO	label61
058E  1683  	BSF STATUS, RP0
058F  09A0  	COMF __div_16_1_00003_arg_a, F
0590  09FE  	COMF CompTempVar2243, F
0591  0AA0  	INCF __div_16_1_00003_arg_a, F
0592  1903  	BTFSC STATUS,Z
0593  0AFE  	INCF CompTempVar2243, F
0594        label61
0594  1683  	BSF STATUS, RP0
0595  01A4  	CLRF CompTempVar2245
0596  087E  	MOVF CompTempVar2243, W
0597  00A1  	MOVWF __div_16_1_00003_arg_a+D'1'
0598  1FFE  	BTFSS CompTempVar2243,7
0599  2DA0  	GOTO	label62
059A  09A0  	COMF __div_16_1_00003_arg_a, F
059B  09A1  	COMF __div_16_1_00003_arg_a+D'1', F
059C  0AA0  	INCF __div_16_1_00003_arg_a, F
059D  1903  	BTFSC STATUS,Z
059E  0AA1  	INCF __div_16_1_00003_arg_a+D'1', F
059F  0AA4  	INCF CompTempVar2245, F
05A0        label62
05A0  300A  	MOVLW 0x0A
05A1  00A2  	MOVWF __div_16_1_00003_arg_b
05A2  01A3  	CLRF __div_16_1_00003_arg_b+D'1'
05A3  2217  	CALL __div_16_1_00003
05A4  0828  	MOVF CompTempVarRet214, W
05A5  1283  	BCF STATUS, RP0
05A6  00E6  	MOVWF gbl_FCV_PERIOD
05A7  1683  	BSF STATUS, RP0
05A8  1C24  	BTFSS CompTempVar2245,0
05A9  2DAD  	GOTO	label63
05AA  1283  	BCF STATUS, RP0
05AB  09E6  	COMF gbl_FCV_PERIOD, F
05AC  0AE6  	INCF gbl_FCV_PERIOD, F
05AD        label63

			FCV_AWAY_FOUL = FCV_FOULPERIOD % 10;
05AD  1283  	BCF STATUS, RP0
05AE  0854  	MOVF gbl_FCV_FOULPERIOD, W
05AF  00FA  	MOVWF __rem_16_1_00004_arg_a
05B0  0855  	MOVF gbl_FCV_FOULPERIOD+D'1', W
05B1  00FB  	MOVWF __rem_16_1_00004_arg_a+D'1'
05B2  1FD5  	BTFSS gbl_FCV_FOULPERIOD+D'1',7
05B3  2DB9  	GOTO	label64
05B4  09FA  	COMF __rem_16_1_00004_arg_a, F
05B5  09FB  	COMF __rem_16_1_00004_arg_a+D'1', F
05B6  0AFA  	INCF __rem_16_1_00004_arg_a, F
05B7  1903  	BTFSC STATUS,Z
05B8  0AFB  	INCF __rem_16_1_00004_arg_a+D'1', F
05B9        label64
05B9  300A  	MOVLW 0x0A
05BA  00FC  	MOVWF __rem_16_1_00004_arg_b
05BB  01FD  	CLRF __rem_16_1_00004_arg_b+D'1'
05BC  21E5  	CALL __rem_16_1_00004
05BD  0827  	MOVF CompTempVarRet216, W
05BE  00F6  	MOVWF gbl_FCV_AWAY_FOUL
05BF  1283  	BCF STATUS, RP0
05C0  1FD5  	BTFSS gbl_FCV_FOULPERIOD+D'1',7
05C1  2DC4  	GOTO	label65
05C2  09F6  	COMF gbl_FCV_AWAY_FOUL, F
05C3  0AF6  	INCF gbl_FCV_AWAY_FOUL, F
05C4        label65


			//Calculation
			//Calculation:
			//  minute_tens = minutes / 10
			//  minute_ones = minutes % 10
			//  seconds_tens = seconds / 10
			//  seconds_ones = seconds % 10
			FCV_MINUTE_TENS = FCV_MINUTES / 10;
05C4  0867  	MOVF gbl_FCV_MINUTES, W
05C5  00FA  	MOVWF __div_8_8_00000_arg_a
05C6  300A  	MOVLW 0x0A
05C7  00FB  	MOVWF __div_8_8_00000_arg_b
05C8  2206  	CALL __div_8_8_00000
05C9  087E  	MOVF CompTempVarRet218, W
05CA  00EA  	MOVWF gbl_FCV_MINUTE_TENS

			FCV_MINUTE_ONES = FCV_MINUTES % 10;
05CB  0867  	MOVF gbl_FCV_MINUTES, W
05CC  00FA  	MOVWF __rem_8_8_00000_arg_a
05CD  300A  	MOVLW 0x0A
05CE  00FB  	MOVWF __rem_8_8_00000_arg_b
05CF  21D4  	CALL __rem_8_8_00000
05D0  087E  	MOVF CompTempVarRet220, W
05D1  00F0  	MOVWF gbl_FCV_MINUTE_ONES

			FCV_SECONDS_TENS = FCV_SECONDS / 10;
05D2  0865  	MOVF gbl_FCV_SECONDS, W
05D3  00FA  	MOVWF __div_8_8_00000_arg_a
05D4  300A  	MOVLW 0x0A
05D5  00FB  	MOVWF __div_8_8_00000_arg_b
05D6  2206  	CALL __div_8_8_00000
05D7  087E  	MOVF CompTempVarRet218, W
05D8  00EC  	MOVWF gbl_FCV_SECONDS_TENS

			FCV_SECONDS_ONES = FCV_SECONDS % 10;
05D9  0865  	MOVF gbl_FCV_SECONDS, W
05DA  00FA  	MOVWF __rem_8_8_00000_arg_a
05DB  300A  	MOVLW 0x0A
05DC  00FB  	MOVWF __rem_8_8_00000_arg_b
05DD  21D4  	CALL __rem_8_8_00000
05DE  087E  	MOVF CompTempVarRet220, W
05DF  00F4  	MOVWF gbl_FCV_SECONDS_ONES


			//Call Macro
			//Call Macro: display_score()
			FCM_display_score();
05E0  22CF  	CALL FCM_displa_00054


			//Call Macro
			//Call Macro: display_time()
			FCM_display_time();
05E1  228A  	CALL FCM_displa_00055


			//Call Macro
			//Call Macro: foulperiod_display()
			FCM_foulperiod_display();
05E2  2245  	CALL FCM_foulpe_00058


		// } else {

		}


	}

	//Loop
	//Loop: While 1
	while (1)
	{

		//Calculation
		//Calculation:
		//  score_home = 71
		//  score_away = 89
		//  minutes = 10
		//  seconds = 35
		//  home_foul = 2
		//  away_foul = 4
		//  period = 3
		FCV_SCORE_HOME = 71;

		FCV_SCORE_AWAY = 89;

		FCV_MINUTES = 10;

		FCV_SECONDS = 35;

		FCV_HOME_FOUL = 2;

		FCV_AWAY_FOUL = 4;

		FCV_PERIOD = 3;


		//Calculation
		//Calculation:
		//  away_tens = score_away / 10
		//  away_ones = score_away % 10
		//  home_tens = score_home / 10
		//  home_ones = score_home % 10
		FCV_AWAY_TENS = FCV_SCORE_AWAY / 10;

		FCV_AWAY_ONES = FCV_SCORE_AWAY % 10;

		FCV_HOME_TENS = FCV_SCORE_HOME / 10;

		FCV_HOME_ONES = FCV_SCORE_HOME % 10;


		//Calculation
		//Calculation:
		//  minute_tens = minutes / 10
		//  minute_ones = minutes % 10
		//  seconds_tens = seconds / 10
		//  seconds_ones = seconds % 10
		FCV_MINUTE_TENS = FCV_MINUTES / 10;

		FCV_MINUTE_ONES = FCV_MINUTES % 10;

		FCV_SECONDS_TENS = FCV_SECONDS / 10;

		FCV_SECONDS_ONES = FCV_SECONDS % 10;


		//Call Macro
		//Call Macro: display_score()
		FCM_display_score();


		//Call Macro
		//Call Macro: display_time()
		FCM_display_time();


		//Call Macro
		//Call Macro: foulperiod_display()
		FCM_foulperiod_display();



	}

	//score_data
	//Output: dat -> C3
	trisc = trisc & 0xF7;

	if ((FCV_DAT))
		portc = (portc & 0xF7) | 0x08;

	else
		portc = portc & 0xF7;


	//time_data
	//Output: dat -> C2
	trisc = trisc & 0xFB;

	if ((FCV_DAT))
		portc = (portc & 0xFB) | 0x04;

	else
		portc = portc & 0xFB;


	mainendloop: goto mainendloop;
}


void MX_INTERRUPT_MACRO(void)

{
}
0627  1283  	BCF STATUS, RP0
0628  1303  	BCF STATUS, RP1
0629  0E51  	SWAPF Int1BContext+D'2', W
062A  0084  	MOVWF FSR
062B  0E50  	SWAPF Int1BContext+D'1', W
062C  008A  	MOVWF PCLATH
062D  0E4F  	SWAPF Int1BContext, W
062E  0083  	MOVWF STATUS
062F  0EFF  	SWAPF Int1Context, F
0630  0E7F  	SWAPF Int1Context, W
0631  0009  	RETFIE





/*********************************************************************
 *                  Flowcode CAL UART File
 *
 * File: PIC_CAL_UART.c
 *
 * (c) 2011 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * “Company”) for its Flowcode graphical programming language is
 * intended and supplied to you, the Company’s customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 010911 | BR | Created
 * 020911 | BR | Updated variables with typedef alternatives
 * 011211 | BR | Converted to new dynamic defines mechanism
 * 160112 | BR | Fixed issues with rx return type and low bauds on fast devices
 * 020212 | ST | Added <MX_UART_2_PIE4> routing to account for differences in 16F and 18F devices with 2 UARTs
 * 270212 | BR | Fixed a bug in the receive functionality
 * 280212 | BR | Sorted out auto echo functionality
 * 160412 | BR | Addition of HW change baud function
 */



#ifndef MX_UART_SW_DEFS
	#define MX_UART_SW_DEFS

	#ifdef _BOOSTC
		#define INST_COUNT	45	//65 for lower speeds or 40 for higher speeds.
	#endif
	#ifdef HI_TECH_C
		#define INST_COUNT	315
	#endif

	//Work out number of nops for software baud rate
	#define MX_INSTRUCTION_SPEED 	(MX_CLK_SPEED / 4)
	#define MX_OVERHEAD				(MX_INSTRUCTION_SPEED / INST_COUNT)
	#define SW_OFFSET				(1000000 / MX_OVERHEAD)

	//Work out software baud rates if required
	#define SW_1200_BAUD	(832 - SW_OFFSET)
	#define SW_2400_BAUD	(416 - SW_OFFSET)
	#define SW_4800_BAUD	(208 - SW_OFFSET)
	#define SW_9600_BAUD	(104 - SW_OFFSET)
	#define SW_19200_BAUD	(52 - SW_OFFSET)
	#define SW_31250_BAUD	(32 - SW_OFFSET)
	#define SW_115200_BAUD	(8 - SW_OFFSET)
#endif

 #if defined(MX_UART_CHANNEL_1) && (MX_UART_NUM==1)
	#if (MX_UART_CHANNEL_1 == 0)
		#if (MX_UART_BAUD_1 == 1200)
			#define MX_SOFT_BAUD_1	SW_1200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 1200 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_1 == 2400)
			#define MX_SOFT_BAUD_1	SW_2400_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 2400 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_1 == 4800)
			#define MX_SOFT_BAUD_1	SW_4800_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 4800 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_1 == 9600)
			#define MX_SOFT_BAUD_1	SW_9600_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 9600 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_1 == 19200)
			#define MX_SOFT_BAUD_1	SW_19200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 19200 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_1 == 31250)
			#define MX_SOFT_BAUD_1	SW_31250_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 31250 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_1 == 115200)
			#define MX_SOFT_BAUD_1	SW_115200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 115200 Not Available At This Clock Speed"
			#endif
		#endif
		#ifndef MX_SOFT_BAUD_1
			#error "UART Baud Rate not supported in Software Mode"
		#endif
	#else
		#define MX_SOFT_BAUD_1	1
		#define MX_HARD_BAUD_1	(((MX_CLK_SPEED / MX_UART_BAUD_1) - 16) / 16)
		#define MX_HARD_SLOW_1	0

		#if (MX_HARD_BAUD_1 > 255)
			#undef MX_HARD_BAUD_1
			#undef MX_HARD_SLOW_1
			#define MX_HARD_BAUD_1	(((MX_CLK_SPEED / MX_UART_BAUD_1) - 16)	/ 64)
			#define MX_HARD_SLOW_1	1
		#endif

	#endif
 #endif
 #if defined(MX_UART_CHANNEL_2) && (MX_UART_NUM==2)
	#if (MX_UART_CHANNEL_2 == 0)
		#if (MX_UART_BAUD_2 == 1200)
			#define MX_SOFT_BAUD_2	SW_1200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 1200 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_2 == 2400)
			#define MX_SOFT_BAUD_2	SW_2400_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 2400 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_2 == 4800)
			#define MX_SOFT_BAUD_2	SW_4800_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 4800 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_2 == 9600)
			#define MX_SOFT_BAUD_2	SW_9600_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 9600 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_2 == 19200)
			#define MX_SOFT_BAUD_2	SW_19200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 19200 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_2 == 31250)
			#define MX_SOFT_BAUD_2	SW_31250_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 31250 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_2 == 115200)
			#define MX_SOFT_BAUD_2	SW_115200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 115200 Not Available At This Clock Speed"
			#endif
		#endif
		#ifndef MX_SOFT_BAUD_2
			#error "UART Baud Rate not supported in Software Mode"
		#endif
	#else
		#define MX_SOFT_BAUD_2	1
		#define MX_HARD_BAUD_2	(((MX_CLK_SPEED / MX_UART_BAUD_2) - 16) / 16)
		#define MX_HARD_SLOW_2	0

		#if (MX_HARD_BAUD_2 > 255)
			#undef MX_HARD_BAUD_2
			#undef MX_HARD_SLOW_2
			#define MX_HARD_BAUD_2	(((MX_CLK_SPEED / MX_UART_BAUD_2) - 16)	/ 64)
			#define MX_HARD_SLOW_2	1
		#endif
 	#endif
 #endif
 #if defined(MX_UART_CHANNEL_3) && (MX_UART_NUM==3)
	#if (MX_UART_CHANNEL_3 == 0)
		#if (MX_UART_BAUD_3 == 1200)
			#define MX_SOFT_BAUD_3	SW_1200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 1200 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_3 == 2400)
			#define MX_SOFT_BAUD_3	SW_2400_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 2400 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_3 == 4800)
			#define MX_SOFT_BAUD_3	SW_4800_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 4800 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_3 == 9600)
			#define MX_SOFT_BAUD_3	SW_9600_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 9600 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_3 == 19200)
			#define MX_SOFT_BAUD_3	SW_19200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 19200 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_3 == 31250)
			#define MX_SOFT_BAUD_3	SW_31250_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 31250 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_3 == 115200)
			#define MX_SOFT_BAUD_3	SW_115200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 115200 Not Available At This Clock Speed"
			#endif
		#endif
		#ifndef MX_SOFT_BAUD_3
			#error "UART Baud Rate not supported in Software Mode"
		#endif
	#else
		#define MX_SOFT_BAUD_3	1
		#define MX_HARD_BAUD_3	(((MX_CLK_SPEED / MX_UART_BAUD_3) - 16) / 16)
		#define MX_HARD_SLOW_3	0

		#if (MX_HARD_BAUD_3 > 255)
			#undef MX_HARD_BAUD_3
			#undef MX_HARD_SLOW_3
			#define MX_HARD_BAUD_3	(((MX_CLK_SPEED / MX_UART_BAUD_3) - 16)	/ 64)
			#define MX_HARD_SLOW_3	1
		#endif
	#endif
 #endif
 #if defined(MX_UART_CHANNEL_4) && (MX_UART_NUM==4)
	#if (MX_UART_CHANNEL_4 == 0)
		#if (MX_UART_BAUD_4 == 1200)
			#define MX_SOFT_BAUD_4	SW_1200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 1200 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_4 == 2400)
			#define MX_SOFT_BAUD_4	SW_2400_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 2400 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_4 == 4800)
			#define MX_SOFT_BAUD_4	SW_4800_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 4800 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_4 == 9600)
			#define MX_SOFT_BAUD_4	SW_9600_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 9600 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_4 == 19200)
			#define MX_SOFT_BAUD_4	SW_19200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 19200 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_4 == 31250)
			#define MX_SOFT_BAUD_4	SW_31250_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 31250 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_4 == 115200)
			#define MX_SOFT_BAUD_4	SW_115200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 115200 Not Available At This Clock Speed"
			#endif
		#endif
		#ifndef MX_SOFT_BAUD_4
			#error "UART Baud Rate not supported in Software Mode"
		#endif
	#else
		#define MX_SOFT_BAUD_4	1
		#define MX_HARD_BAUD_4	(((MX_CLK_SPEED / MX_UART_BAUD_4) - 16) / 16)
		#define MX_HARD_SLOW_4	0

		#if (MX_HARD_BAUD_4 > 255)
			#undef MX_HARD_BAUD_4
			#undef MX_HARD_SLOW_4
			#define MX_HARD_BAUD_4	(((MX_CLK_SPEED / MX_UART_BAUD_4) - 16)	/ 64)
			#define MX_HARD_SLOW_4	1
		#endif
	#endif
 #endif


//Hardware Baud update definitions
#ifndef MX_HARD_BAUD_CHANGE_DEFS
	#define MX_HARD_BAUD_CHANGE_DEFS

	#define MX_HARD_BAUD_1200	(((MX_CLK_SPEED / 1200) - 16) / 16)
	#if (MX_HARD_BAUD_1200 > 255)
		#undef MX_HARD_BAUD_1200
		#define MX_HARD_BAUD_1200	(((MX_CLK_SPEED / 1200) - 16) / 64)
		#define MX_HARD_SLOW_1200	1
	#else
		#define MX_HARD_SLOW_1200	0
	#endif

	#define MX_HARD_BAUD_2400	(((MX_CLK_SPEED / 2400) - 16) / 16)
	#if (MX_HARD_BAUD_2400 > 255)
		#undef MX_HARD_BAUD_2400
		#define MX_HARD_BAUD_2400	(((MX_CLK_SPEED / 2400) - 16) / 64)
		#define MX_HARD_SLOW_2400	1
	#else
		#define MX_HARD_SLOW_2400	0
	#endif

	#define MX_HARD_BAUD_4800	(((MX_CLK_SPEED / 4800) - 16) / 16)
	#if (MX_HARD_BAUD_4800 > 255)
		#undef MX_HARD_BAUD_4800
		#define MX_HARD_BAUD_4800	(((MX_CLK_SPEED / 4800) - 16) / 64)
		#define MX_HARD_SLOW_4800	1
	#else
		#define MX_HARD_SLOW_4800	0
	#endif

	#define MX_HARD_BAUD_9600	(((MX_CLK_SPEED / 9600) - 16) / 16)
	#if (MX_HARD_BAUD_9600 > 255)
		#undef MX_HARD_BAUD_9600
		#define MX_HARD_BAUD_9600	(((MX_CLK_SPEED / 9600) - 16) / 64)
		#define MX_HARD_SLOW_9600	1
	#else
		#define MX_HARD_SLOW_9600	0
	#endif

	#define MX_HARD_BAUD_19200	(((MX_CLK_SPEED / 19200) - 16) / 16)
	#if (MX_HARD_BAUD_19200 > 255)
		#undef MX_HARD_BAUD_19200
		#define MX_HARD_BAUD_19200	(((MX_CLK_SPEED / 19200) - 16) / 64)
		#define MX_HARD_SLOW_19200	1
	#else
		#define MX_HARD_SLOW_19200	0
	#endif

	#define MX_HARD_BAUD_38400	(((MX_CLK_SPEED / 38400) - 16) / 16)
	#if (MX_HARD_BAUD_38400 > 255)
		#undef MX_HARD_BAUD_38400
		#define MX_HARD_BAUD_38400	(((MX_CLK_SPEED / 38400) - 16) / 64)
		#define MX_HARD_SLOW_38400	1
	#else
		#define MX_HARD_SLOW_38400	0
	#endif

	#define MX_HARD_BAUD_57600	(((MX_CLK_SPEED / 57600) - 16) / 16)
	#if (MX_HARD_BAUD_57600 > 255)
		#undef MX_HARD_BAUD_57600
		#define MX_HARD_BAUD_57600	(((MX_CLK_SPEED / 57600) - 16) / 64)
		#define MX_HARD_SLOW_57600	1
	#else
		#define MX_HARD_SLOW_57600	0
	#endif

	#define MX_HARD_BAUD_115200	(((MX_CLK_SPEED / 115200) - 16) / 16)
	#if (MX_HARD_BAUD_115200 > 255)
		#undef MX_HARD_BAUD_115200
		#define MX_HARD_BAUD_115200	(((MX_CLK_SPEED / 115200) - 16) / 64)
		#define MX_HARD_SLOW_115200	1
	#else
		#define MX_HARD_SLOW_115200	0
	#endif
#endif


//Dynamic function naming based on defines and index number
#define MX_UART_CHANNEL_X	CAL_APPEND(MX_UART_CHANNEL_, MX_UART_NUM)
#define MX_UART_TX_PIN_X	CAL_APPEND(MX_UART_TX_PIN_, MX_UART_NUM)
#define MX_UART_TX_PORT_X	CAL_APPEND(MX_UART_TX_PORT_, MX_UART_NUM)
#define MX_UART_TX_TRIS_X	CAL_APPEND(MX_UART_TX_TRIS_, MX_UART_NUM)
#define MX_UART_RX_PIN_X	CAL_APPEND(MX_UART_RX_PIN_, MX_UART_NUM)
#define MX_UART_RX_PORT_X	CAL_APPEND(MX_UART_RX_PORT_, MX_UART_NUM)
#define MX_UART_RX_TRIS_X	CAL_APPEND(MX_UART_RX_TRIS_, MX_UART_NUM)
#define MX_UART_FLOWEN_X	CAL_APPEND(MX_UART_FLOWEN_, MX_UART_NUM)
#define MX_UART_CTS_PIN_X	CAL_APPEND(MX_UART_CTS_PIN_, MX_UART_NUM)
#define MX_UART_CTS_PORT_X	CAL_APPEND(MX_UART_CTS_PORT_, MX_UART_NUM)
#define MX_UART_CTS_TRIS_X	CAL_APPEND(MX_UART_CTS_TRIS_, MX_UART_NUM)
#define MX_UART_RTS_PIN_X	CAL_APPEND(MX_UART_RTS_PIN_, MX_UART_NUM)
#define MX_UART_RTS_PORT_X	CAL_APPEND(MX_UART_RTS_PORT_, MX_UART_NUM)
#define MX_UART_RTS_TRIS_X	CAL_APPEND(MX_UART_RTS_TRIS_, MX_UART_NUM)
#define MX_UART_DBITS_X		CAL_APPEND(MX_UART_DBITS_, MX_UART_NUM)
#define MX_UART_RETURN_X	CAL_APPEND(MX_UART_RETURN_, MX_UART_NUM)
#define MX_UART_ECHO_X		CAL_APPEND(MX_UART_ECHO_, MX_UART_NUM)
#define MX_UART_INT_X		CAL_APPEND(MX_UART_INT_, MX_UART_NUM)
#define MX_UART_BAUD_X		CAL_APPEND(MX_HARD_BAUD_, MX_UART_NUM)
#define MX_SOFT_BAUD_X		CAL_APPEND(MX_SOFT_BAUD_, MX_UART_NUM)
#define MX_HARD_SLOW_X		CAL_APPEND(MX_HARD_SLOW_, MX_UART_NUM)

#define UART_Delay_CAL		CAL_APPEND(FC_CAL_UART_Delay_, MX_UART_NUM)
#define UART_Send			CAL_APPEND(FC_CAL_UART_Send_, MX_UART_NUM)
#define UART_Uninit			CAL_APPEND(FC_CAL_UART_Uninit_, MX_UART_NUM)


//Component Definitions
#define UART_STATUS_LOOP	0
#define UART_STATUS_TIMEOUT	1
#define UART_STATUS_RXBYTE	2


//Interrupt Definitions
#ifdef MX_UART_2_PIE4
  #define MX_UART2_PIE pie4
  #define MX_UART2_PIR pir4
  #define MX_UART2_TXSTA tx2sta
  #define MX_UART2_RCSTA rc2sta
  #define MX_UART2_TXREG tx2reg
  #define MX_UART2_RCREG rc2reg
#else
  #define MX_UART2_PIE pie3
  #define MX_UART2_PIR pir3
  #define MX_UART2_TXSTA txsta2
  #define MX_UART2_RCSTA rcsta2
  #define MX_UART2_TXREG txreg2
  #define MX_UART2_RCREG rcreg2
#endif

#if (MX_UART_INT_X == 1)

	#ifndef MX_UART_INT_DEFS
	#define MX_UART_INT_DEFS

		#define MX_UART_INT_CH1_FUNC
		#define MX_UART_INT_CH2_FUNC
		#define MX_UART_INT_FUNC_END

		#define MX_UART_INT_CH1_DET		ts_bit(pir1, RCIF) && ts_bit(pie1, RCIE)
		#define MX_UART_INT_CH2_DET		ts_bit(MX_UART2_PIR, RC2IF) && ts_bit(MX_UART2_PIE, RC2IE)

		#define MX_UART_INT_CH1_EN		st_bit (pie1, RCIE)
		#define MX_UART_INT_CH2_EN		st_bit (MX_UART2_PIE, RC2IE)

		#define MX_UART_INT_CH1_DIS		cr_bit (pie1, RCIE)
		#define MX_UART_INT_CH2_DIS		cr_bit (MX_UART2_PIE, RC2IE)

		#define MX_UART_INT_CH1_CLR		cr_bit (pir1, RCIF)
		#define MX_UART_INT_CH2_CLR		cr_bit (MX_UART2_PIR, RC2IF)

	#endif
#endif


//Function Prototypes
CALFUNCTION(void, FC_CAL_UART_Init_, (void));
CALFUNCTION(void, FC_CAL_UART_Uninit_, (void));
CALFUNCTION(void, FC_CAL_UART_Send_, (MX_UINT16 nChar));
CALFUNCTION(MX_SINT16, FC_CAL_UART_Receive_, (MX_UINT8 nTimeout));
CALFUNCTION(void, FC_CAL_UART_Delay_, (void));


//Peripheral Functions
CALFUNCTION(void, FC_CAL_UART_Init_, (void))

{

	#if (MX_UART_CHANNEL_X == 0)
		FC_CAL_Bit_In_DDR 	(MX_UART_RX_PORT_X, MX_UART_RX_TRIS_X, MX_UART_RX_PIN_X);		// Receive pin is a input
		FC_CAL_Bit_High_DDR (MX_UART_TX_PORT_X, MX_UART_TX_TRIS_X, MX_UART_TX_PIN_X);		// Transmit pin is default high
	#endif

	#if (MX_UART_CHANNEL_X == 1)
	  #ifndef MX_UART_1
	  	  #error "UART channel 1 not available on this device"
	  #else
		  #if (MX_HARD_SLOW_X == 1)
			cr_bit(txsta, BRGH);						//Low Speed
		  #else
			st_bit(txsta, BRGH);						//High Speed
0236  1683  	BSF STATUS, RP0
0237  1303  	BCF STATUS, RP1
0238  1518  	BSF gbl_txsta,2

		  #endif
			spbrg = MX_UART_BAUD_X;   					// set the baud rate
0239  301F  	MOVLW 0x1F
023A  0099  	MOVWF gbl_spbrg

			rcsta = 0;                    				// 8-bit, disabled
023B  1283  	BCF STATUS, RP0
023C  0198  	CLRF gbl_rcsta


			#if(MX_UART_DBITS_X == 9)
				st_bit(txsta, TX9);   					// 9-bit TX
				st_bit(rcsta, RX9);                    	// 9-bit RX
			#endif

			st_bit(rcsta, SPEN);         				// turn on serial interface
023D  1798  	BSF gbl_rcsta,7

			st_bit(txsta, TXEN);
023E  1683  	BSF STATUS, RP0
023F  1698  	BSF gbl_txsta,5

			st_bit(rcsta, CREN);
0240  1283  	BCF STATUS, RP0
0241  1618  	BSF gbl_rcsta,4


			#if (MX_UART_INT_X == 1)
				MX_UART_INT_CH1_EN;
				st_bit(intcon, PEIE);
				st_bit(intcon, GIE);
			#else
				cr_bit (pie1, RCIE);
0242  1683  	BSF STATUS, RP0
0243  128C  	BCF gbl_pie1,5

			#endif
	  #endif
	#endif


	#if (MX_UART_CHANNEL_X == 2)

	  #ifndef MX_UART_2
		  #error "UART channel 2 not available on this device"
	  #else
		  #ifdef MX_UART_2_REMAPPABLE
			RPOR9 = 5;									//TX2 - RP9 - RB6
			RPINR16	= 10;								//RX2 - RP10 - RB7
		  #endif
		  #if (MX_HARD_SLOW_X == 1)
			cr_bit(MX_UART2_TXSTA, BRGH);						//Low Speed
		  #else
			st_bit(MX_UART2_TXSTA, BRGH);						//High Speed
		  #endif
			spbrg2 = MX_UART_BAUD_X;   				// set the baud rate
			MX_UART2_RCSTA = 0;                    				// 8-bit, disabled

			#if(MX_UART_DBITS_X == 9)
				st_bit(MX_UART2_TXSTA, TX9);   					// 9-bit TX
				st_bit(MX_UART2_RCSTA, RX9);                    // 9-bit RX
			#endif

			st_bit(MX_UART2_RCSTA, SPEN);         				// turn on serial interface
			st_bit(MX_UART2_TXSTA, TXEN);
			st_bit(MX_UART2_RCSTA, CREN);

			#if (MX_UART_INT_X == 1)
				MX_UART_INT_CH2_EN;
				st_bit(intcon, PEIE);
				st_bit(intcon, GIE);
			#else
				cr_bit (MX_UART2_PIE, RC2IE);
			#endif
	  #endif
	#endif

	#if (MX_UART_FLOWEN_X == 1)						//Flowcontrol enabled?
		FC_CAL_Bit_In_DDR (MX_UART_CTS_PORT_X, MX_UART_CTS_TRIS_X, MX_UART_CTS_PIN_X);	// CTS pin is a input
		FC_CAL_Bit_High_DDR (MX_UART_RTS_PORT_X, MX_UART_RTS_TRIS_X, MX_UART_RTS_PIN_X);	// RTS not ready to accept data
	#endif

}
0244  0008  	RETURN




CALFUNCTION(void, FC_CAL_UART_Uninit_, (void))
{

	#if (MX_UART_CHANNEL_X == 0)
		FC_CAL_Bit_In_DDR (MX_UART_RX_PORT_X, MX_UART_RX_TRIS_X, MX_UART_RX_PIN_X);		// Receive pin is a input
		FC_CAL_Bit_In_DDR (MX_UART_TX_PORT_X, MX_UART_TX_TRIS_X, MX_UART_TX_PIN_X);		// Transmit pin is default high
	#endif

	#if (MX_UART_CHANNEL_X == 1)
			rcsta = 0;                    								// 8-bit, disabled
			txsta = 0;
		  #ifdef MX_UART_RXINT
			MX_UART_INT_CH1_DIS;
		  #endif
	#endif

	#if (MX_UART_CHANNEL_X == 2)
			MX_UART2_RCSTA = 0;                    								// 8-bit, disabled
			MX_UART2_TXSTA = 0;
		  #ifdef MX_UART_RXINT
			MX_UART_INT_CH2_DIS;
		  #endif
	#endif

	#if (MX_UART_FLOWEN_X == 1)										//Flowcontrol enabled?
		FC_CAL_Bit_In_DDR (MX_UART_CTS_PORT_X, MX_UART_CTS_TRIS_X, MX_UART_CTS_PIN_X);		// CTS pin is a input
		FC_CAL_Bit_In_DDR (MX_UART_RTS_PORT_X, MX_UART_RTS_TRIS_X, MX_UART_RTS_PIN_X);		// RTS not ready to accept data
	#endif
}



CALFUNCTION(void, FC_CAL_UART_Send_, (MX_UINT16 nChar))
{
	#if (MX_UART_FLOWEN_X == 1)
		while (FC_CAL_Bit_In(MX_UART_CTS_PORT_X, MX_UART_CTS_PIN_X) != 0);	// Wait until CTS is low
	#endif

	#if (MX_UART_CHANNEL_X == 0)													// Software UART TX
		MX_UINT8 idx;
		FC_CAL_Bit_Low(MX_UART_TX_PORT_X, MX_UART_TX_PIN_X);					// Send Start bit
		UART_Delay_CAL();
		for (idx = 0; idx < MX_UART_DBITS_X; idx++)
		{
			if (nChar & 0x01)														// Mask off data bit
				FC_CAL_Bit_High(MX_UART_TX_PORT_X, MX_UART_TX_PIN_X);
			else
				FC_CAL_Bit_Low(MX_UART_TX_PORT_X, MX_UART_TX_PIN_X);
			UART_Delay_CAL();
			nChar = nChar >> 1;														// Move to next data bit
		}
		FC_CAL_Bit_High(MX_UART_TX_PORT_X, MX_UART_TX_PIN_X);					// Send Stop bit
		UART_Delay_CAL();
	#endif

	#if (MX_UART_CHANNEL_X == 1)
		while (ts_bit(pir1, TXIF) == 0);

		#if (MX_UART_DBITS_X == 9)
			if (test_bit(nChar, 8))
				st_bit(txsta, TX9D);
			else
				cr_bit(txsta, TX9D);
	  	#endif
		txreg = nChar;
	#endif

	#if (MX_UART_CHANNEL_X == 2)
		while (ts_bit(pir3, TX2IF) == 0);

		#if (MX_UART_DBITS_X == 9)
			if (test_bit(nChar, 8))
				st_bit(MX_UART2_TXSTA, TX9D);
			else
				cr_bit(MX_UART2_TXSTA, TX9D);
		#endif
		MX_UART2_TXREG = nChar;
	#endif
}


CALFUNCTION(MX_SINT16, FC_CAL_UART_Receive_, (MX_UINT8 nTimeout))

{
  #if (MX_UART_RETURN_X == 1)
	MX_UINT16 retVal = 512;
  #else
  	MX_UINT8 retVal = 255;
0064  30FF  	MOVLW 0xFF
0065  00A6  	MOVWF FC_CAL_UAR_0005B_1_retVal

  #endif

	MX_UINT8 delay1 = 0;
0066  01A7  	CLRF FC_CAL_UAR_0005B_1_delay1

	MX_UINT8 regcheck = 0;
0067  01A8  	CLRF FC_CAL_UAR_0005B_1_regcheck

	MX_UINT8 bWaitForever = 0;
0068  01A9  	CLRF FC_CAL_UAR_0005B_1_bWaitForever

	MX_UINT8 rxStatus = UART_STATUS_LOOP;
0069  01AA  	CLRF FC_CAL_UAR_0005B_1_rxStatus


  #if (MX_UART_CHANNEL_X == 0)
  	MX_UINT8 idx;
  #else
  	MX_UINT8 dummy = 0;
006A  01AB  	CLRF FC_CAL_UAR_0005B_1_dummy

  #endif

	if (nTimeout == 255)
006B  0A25  	INCF FC_CAL_UAR_0005B_arg_nTimeout, W
006C  1D03  	BTFSS STATUS,Z
006D  2870  	GOTO	label6
0070        label6

		bWaitForever = 1;
006E  3001  	MOVLW 0x01
006F  00A9  	MOVWF FC_CAL_UAR_0005B_1_bWaitForever


	#if (MX_UART_FLOWEN_X == 1)
		FC_CAL_Bit_Low (MX_UART_RTS_PORT_X, MX_UART_RTS_PIN_X);			// Ready to accept data
	#endif

	while (rxStatus == UART_STATUS_LOOP)
0070  08AA  	MOVF FC_CAL_UAR_0005B_1_rxStatus, F
0071  1D03  	BTFSS STATUS,Z
0072  2894  	GOTO	label9
0093  2870  	GOTO	label6
0094        label9

	{
		if (bWaitForever == 0)
0073  08A9  	MOVF FC_CAL_UAR_0005B_1_bWaitForever, F
0074  1D03  	BTFSS STATUS,Z
0075  2889  	GOTO	label8

		{
			if (nTimeout == 0)							//don't wait forever, so do timeout thing...
0076  08A5  	MOVF FC_CAL_UAR_0005B_arg_nTimeout, F
0077  1D03  	BTFSS STATUS,Z
0078  287C  	GOTO	label7
007C        label7

			{
				rxStatus = UART_STATUS_TIMEOUT;
0079  3001  	MOVLW 0x01
007A  00AA  	MOVWF FC_CAL_UAR_0005B_1_rxStatus

			}
			else
007B  2889  	GOTO	label8

			{
				delay_us(10);
007C  300A  	MOVLW 0x0A
007D  00AC  	MOVWF delay_us_00000_arg_del
007E  2010  	CALL delay_us_00000

				delay1 = delay1 + 1;
007F  0A27  	INCF FC_CAL_UAR_0005B_1_delay1, W
0080  00A7  	MOVWF FC_CAL_UAR_0005B_1_delay1

				if(delay1 == 100)
0081  0827  	MOVF FC_CAL_UAR_0005B_1_delay1, W
0082  3A64  	XORLW 0x64
0083  1D03  	BTFSS STATUS,Z
0084  2889  	GOTO	label8
0089        label8

				{
					nTimeout = nTimeout - 1;
0085  0325  	DECF FC_CAL_UAR_0005B_arg_nTimeout, W
0086  00A5  	MOVWF FC_CAL_UAR_0005B_arg_nTimeout

					MX_CLEAR_WATCHDOG;
0087  0064  	CLRWDT

					delay1 = 0;
0088  01A7  	CLRF FC_CAL_UAR_0005B_1_delay1

				}
			}
		}

		#if (MX_UART_CHANNEL_X == 0)
			regcheck = FC_CAL_Bit_In(MX_UART_RX_PORT_1, MX_UART_RX_PIN_1);	//Test for start bit
			if (regcheck == 0)
				rxStatus = UART_STATUS_RXBYTE;
		#endif

		#if (MX_UART_CHANNEL_X == 1)
			regcheck = ts_bit(pir1, RCIF);
0089  3020  	MOVLW 0x20
008A  1283  	BCF STATUS, RP0
008B  050C  	ANDWF gbl_pir1, W
008C  1683  	BSF STATUS, RP0
008D  00A8  	MOVWF FC_CAL_UAR_0005B_1_regcheck

			if (regcheck != 0)
008E  08A8  	MOVF FC_CAL_UAR_0005B_1_regcheck, F
008F  1903  	BTFSC STATUS,Z
0090  2870  	GOTO	label6

				rxStatus = UART_STATUS_RXBYTE;
0091  3002  	MOVLW 0x02
0092  00AA  	MOVWF FC_CAL_UAR_0005B_1_rxStatus

		#endif

		#if (MX_UART_CHANNEL_X == 2)
			regcheck = ts_bit(MX_UART2_PIR, RC2IF);
			if (regcheck != 0)
				rxStatus = UART_STATUS_RXBYTE;
		#endif

	}

	if (rxStatus == UART_STATUS_RXBYTE)
0094  082A  	MOVF FC_CAL_UAR_0005B_1_rxStatus, W
0095  3A02  	XORLW 0x02
0096  1D03  	BTFSS STATUS,Z
0097  28B7  	GOTO	label12

	{
		#if (MX_UART_CHANNEL_X == 0)

			retVal = 0;
			UART_Delay_CAL();

			for (idx = 0; idx < MX_UART_DBITS_X; idx++)
			{
				if (FC_CAL_Bit_In(MX_UART_RX_PORT_X, MX_UART_RX_PIN_X))
					retVal = retVal | (0x01 << idx);

				UART_Delay_CAL();
			}
		#endif

		#if (MX_UART_CHANNEL_X == 1)
			regcheck = ts_bit(rcsta, FERR);
0098  3004  	MOVLW 0x04
0099  1283  	BCF STATUS, RP0
009A  0518  	ANDWF gbl_rcsta, W
009B  1683  	BSF STATUS, RP0
009C  00A8  	MOVWF FC_CAL_UAR_0005B_1_regcheck

			if (regcheck != 0)
009D  08A8  	MOVF FC_CAL_UAR_0005B_1_regcheck, F
009E  1903  	BTFSC STATUS,Z
009F  28A5  	GOTO	label10
00A5        label10

			{
				dummy = rcreg;						//need to read the rcreg to clear FERR
00A0  1283  	BCF STATUS, RP0
00A1  081A  	MOVF gbl_rcreg, W
00A2  1683  	BSF STATUS, RP0
00A3  00AB  	MOVWF FC_CAL_UAR_0005B_1_dummy

				#if (MX_UART_RETURN_X == 1)
					retVal = 0x400;					//Framing Error Flag
				#endif
			}
			else
00A4  28B7  	GOTO	label12

			{
				regcheck = ts_bit(rcsta, OERR);
00A5  3002  	MOVLW 0x02
00A6  1283  	BCF STATUS, RP0
00A7  0518  	ANDWF gbl_rcsta, W
00A8  1683  	BSF STATUS, RP0
00A9  00A8  	MOVWF FC_CAL_UAR_0005B_1_regcheck

				if (regcheck != 0)
00AA  08A8  	MOVF FC_CAL_UAR_0005B_1_regcheck, F
00AB  1903  	BTFSC STATUS,Z
00AC  28B1  	GOTO	label11
00B1        label11

				{
					cr_bit(rcsta, CREN);			//Reset receiver to clear error
00AD  1283  	BCF STATUS, RP0
00AE  1218  	BCF gbl_rcsta,4

					st_bit(rcsta, CREN);
00AF  1618  	BSF gbl_rcsta,4


					#if (MX_UART_RETURN_X == 1)
						retVal = 0x800;				//Overrun Error Flag
					#endif
				}
				else
00B0  28B7  	GOTO	label12
00B7        label12

				{
					retVal = 0;
00B1  01A6  	CLRF FC_CAL_UAR_0005B_1_retVal


					#if (MX_UART_DBITS_X == 9)
						if(ts_bit(rcsta, RX9D))
							retVal = 0x100;
					#endif

					retVal = retVal | rcreg; 			//no error, so rx byte is valid
00B2  1283  	BCF STATUS, RP0
00B3  081A  	MOVF gbl_rcreg, W
00B4  1683  	BSF STATUS, RP0
00B5  0426  	IORWF FC_CAL_UAR_0005B_1_retVal, W
00B6  00A6  	MOVWF FC_CAL_UAR_0005B_1_retVal

				}
			}
		#endif

		#if (MX_UART_CHANNEL_X == 2)
			regcheck = ts_bit(MX_UART2_RCSTA, FERR);
			if (regcheck != 0)
			{
				dummy = MX_UART2_RCREG;			//need to read the rcreg to clear FERR
				#if (MX_UART_RETURN_X == 1)
					retVal = 0x400;					//Framing Error Flag
				#endif
			}
			else
			{
				regcheck = ts_bit(MX_UART2_RCSTA, OERR);
				if (regcheck != 0)
				{
					cr_bit(MX_UART2_RCSTA, CREN);	//Reset receiver to clear error
					st_bit(MX_UART2_RCSTA, CREN);
					#if (MX_UART_RETURN_X == 1)
						retVal = 0x800;				//Overrun Error Flag
					#endif
				}
				else
				{
					retVal = 0;

					#if (MX_UART_DBITS_X == 9)
						if(ts_bit(MX_UART2_RCSTA, RX9D))
							retVal = 0x100;
					#endif

					retVal = retVal | MX_UART2_RCREG; 			//no error, so rx byte is valid
				}
			}

		#endif

		#if (MX_UART_ECHO_X == 1)
			UART_Send(retVal);
		#endif
	}

	#if (MX_UART_FLOWEN_X == 1)
		FC_CAL_Bit_High(MX_UART_RTS_PORT_X, MX_UART_RTS_PIN_X);		//not ready to accept data
	#endif

	return (retVal);
00B7  1683  	BSF STATUS, RP0
00B8  0826  	MOVF FC_CAL_UAR_0005B_1_retVal, W
00B9  00AC  	MOVWF CompTempVarRet2210
00BA  01AD  	CLRF CompTempVarRet2210+D'1'

}
00BB  0008  	RETURN



CALFUNCTION(void, FC_CAL_UART_Delay_, (void))
{
  #if (MX_UART_CHANNEL_X == 0)

	MX_UINT16 delay = MX_SOFT_BAUD_X;

	while (delay > 255)
	{
		delay_us(255);
		delay = delay - 255;
		MX_CLEAR_WATCHDOG;
	}
	delay_us(delay);
	MX_CLEAR_WATCHDOG;

  #endif
}


CALFUNCTION(void, FC_CAL_UART_Update_Baud_, (MX_UINT8 new_baud))
{
	//Baud Rates - Function compatible with hardware mode only
	/*
	0 - 1200
	1 - 2400
	2 - 4800
	3 - 9600
	4 - 19200
	5 - 38400
	6 - 57600
	7 - 115200
	*/

	MX_UINT8 baudrate, baudmode;

	if (new_baud > 7)
		return;

	if (new_baud == 0)
	{
		baudrate = MX_HARD_BAUD_1200;
		baudmode = MX_HARD_SLOW_1200;
	}
	else if (new_baud == 1)
	{
		baudrate = MX_HARD_BAUD_2400;
		baudmode = MX_HARD_SLOW_2400;
	}
	else if (new_baud == 2)
	{
		baudrate = MX_HARD_BAUD_4800;
		baudmode = MX_HARD_SLOW_4800;
	}
	else if (new_baud == 3)
	{
		baudrate = MX_HARD_BAUD_9600;
		baudmode = MX_HARD_SLOW_9600;
	}
	else if (new_baud == 4)
	{
		baudrate = MX_HARD_BAUD_19200;
		baudmode = MX_HARD_SLOW_19200;
	}
	else if (new_baud == 5)
	{
		baudrate = MX_HARD_BAUD_38400;
		baudmode = MX_HARD_SLOW_38400;
	}
	else if (new_baud == 6)
	{
		baudrate = MX_HARD_BAUD_57600;
		baudmode = MX_HARD_SLOW_57600;
	}
	else if (new_baud == 7)
	{
		baudrate = MX_HARD_BAUD_115200;
		baudmode = MX_HARD_SLOW_115200;
	}

	UART_Uninit();

	#if (MX_UART_CHANNEL_X == 1)

	    if (baudmode == 1)
			cr_bit(txsta, BRGH);					//Low Speed
	    else
			st_bit(txsta, BRGH);					//High Speed

		spbrg = baudrate;   						// set the baud rate
		rcsta = 0;                    				// 8-bit, disabled

		#if(MX_UART_DBITS_X == 9)
			st_bit(txsta, TX9);   					// 9-bit TX
			st_bit(rcsta, RX9);                    	// 9-bit RX
		#endif

		st_bit(rcsta, SPEN);         				// turn on serial interface
		st_bit(txsta, TXEN);
		st_bit(rcsta, CREN);

		#if (MX_UART_INT_X == 1)
			MX_UART_INT_CH1_EN;
			st_bit(intcon, PEIE);
			st_bit(intcon, GIE);
		#else
			cr_bit (pie1, RCIE);
		#endif
	#endif

	#if (MX_UART_CHANNEL_X == 2)

	  	if (baudmode == 1)
			cr_bit(MX_UART2_TXSTA, BRGH);			//Low Speed
	  	else
			st_bit(MX_UART2_TXSTA, BRGH);			//High Speed

		spbrg2 = baudrate;   						// set the baud rate
		MX_UART2_RCSTA = 0;                    		// 8-bit, disabled

		#if(MX_UART_DBITS_X == 9)
			st_bit(MX_UART2_TXSTA, TX9);   			// 9-bit TX
			st_bit(MX_UART2_RCSTA, RX9);            // 9-bit RX
		#endif

		st_bit(MX_UART2_RCSTA, SPEN);         		// turn on serial interface
		st_bit(MX_UART2_TXSTA, TXEN);
		st_bit(MX_UART2_RCSTA, CREN);

		#if (MX_UART_INT_X == 1)
			MX_UART_INT_CH2_EN;
			st_bit(intcon, PEIE);
			st_bit(intcon, GIE);
		#else
			cr_bit (MX_UART2_PIE, RC2IE);
		#endif
	#endif

	#if (MX_UART_FLOWEN_X == 1)						//Flowcontrol enabled?
		FC_CAL_Bit_In_DDR (MX_UART_CTS_PORT_X, MX_UART_CTS_TRIS_X, MX_UART_CTS_PIN_X);	// CTS pin is a input
		FC_CAL_Bit_High_DDR (MX_UART_RTS_PORT_X, MX_UART_RTS_TRIS_X, MX_UART_RTS_PIN_X);	// RTS not ready to accept data
	#endif

}

////////////////////////////////////////
// Code with no source :-)
////////////////////////////////////////
0000  2DE4  	GOTO	_startup

0004  00FF  	MOVWF Int1Context
0005  0E03  	SWAPF STATUS, W
0006  1283  	BCF STATUS, RP0
0007  1303  	BCF STATUS, RP1
0008  00CF  	MOVWF Int1BContext
0009  0E0A  	SWAPF PCLATH, W
000A  00D0  	MOVWF Int1BContext+D'1'
000B  0E04  	SWAPF FSR, W
000C  00D1  	MOVWF Int1BContext+D'2'
000D  118A  	BCF PCLATH,3
000E  120A  	BCF PCLATH,4
000F  2E27  	GOTO	interrupt
0010        delay_us_00000
0010        ; { delay_us ; function begin
0010        label1
0010  0000  	NOP
0011  0000  	NOP
0012  0BAC  	DECFSZ delay_us_00000_arg_del, F
0013  2810  	GOTO	label1
0014  0008  	RETURN
0015        ; } delay_us function end

0015        delay_ms_00000
0015        ; { delay_ms ; function begin
0015  08FA  	MOVF delay_ms_00000_arg_del, F
0016  1D03  	BTFSS STATUS,Z
0017  2819  	GOTO	label2
0018  0008  	RETURN
0019        label2
0019  30F9  	MOVLW 0xF9
001A        label3
001A  0000  	NOP
001B  0000  	NOP
001C  0000  	NOP
001D  0000  	NOP
001E  0000  	NOP
001F  0000  	NOP
0020  0000  	NOP
0021  0000  	NOP
0022  0000  	NOP
0023  0000  	NOP
0024  0000  	NOP
0025  0000  	NOP
0026  0000  	NOP
0027  0000  	NOP
0028  0000  	NOP
0029  0000  	NOP
002A  3EFF  	ADDLW 0xFF
002B  1D03  	BTFSS STATUS,Z
002C  281A  	GOTO	label3
002D  0000  	NOP
002E  0000  	NOP
002F  0000  	NOP
0030  0000  	NOP
0031  0000  	NOP
0032  0000  	NOP
0033  0000  	NOP
0034  0000  	NOP
0035  0000  	NOP
0036  0000  	NOP
0037  0000  	NOP
0038  0000  	NOP
0039  0000  	NOP
003A  0000  	NOP
003B  0000  	NOP
003C  0000  	NOP
003D  0000  	NOP
003E  0BFA  	DECFSZ delay_ms_00000_arg_del, F
003F  2819  	GOTO	label2
0040  0008  	RETURN
0041        ; } delay_ms function end

0041        __mul_32u__0000F
0041        ; { __mul_32u_32u ; function begin
0041  01B1  	CLRF __mul_32u__0000F_1_i
0042  01B2  	CLRF CompTempVarRet464
0043  01B3  	CLRF CompTempVarRet464+D'1'
0044  01B4  	CLRF CompTempVarRet464+D'2'
0045  01B5  	CLRF CompTempVarRet464+D'3'
0046        label4
0046  1AB1  	BTFSC __mul_32u__0000F_1_i,5
0047  0008  	RETURN
0048  1C29  	BTFSS __mul_32u__0000F_arg_b,0
0049  2858  	GOTO	label5
004A  0825  	MOVF __mul_32u__0000F_arg_a, W
004B  07B2  	ADDWF CompTempVarRet464, F
004C  0826  	MOVF __mul_32u__0000F_arg_a+D'1', W
004D  1803  	BTFSC gbl_status,0
004E  0F26  	INCFSZ __mul_32u__0000F_arg_a+D'1', W
004F  07B3  	ADDWF CompTempVarRet464+D'1', F
0050  0827  	MOVF __mul_32u__0000F_arg_a+D'2', W
0051  1803  	BTFSC gbl_status,0
0052  0F27  	INCFSZ __mul_32u__0000F_arg_a+D'2', W
0053  07B4  	ADDWF CompTempVarRet464+D'2', F
0054  0828  	MOVF __mul_32u__0000F_arg_a+D'3', W
0055  1803  	BTFSC gbl_status,0
0056  0F28  	INCFSZ __mul_32u__0000F_arg_a+D'3', W
0057  07B5  	ADDWF CompTempVarRet464+D'3', F
0058        label5
0058  1003  	BCF gbl_status,0
0059  0CAC  	RRF __mul_32u__0000F_arg_b+D'3', F
005A  0CAB  	RRF __mul_32u__0000F_arg_b+D'2', F
005B  0CAA  	RRF __mul_32u__0000F_arg_b+D'1', F
005C  0CA9  	RRF __mul_32u__0000F_arg_b, F
005D  1003  	BCF gbl_status,0
005E  0DA5  	RLF __mul_32u__0000F_arg_a, F
005F  0DA6  	RLF __mul_32u__0000F_arg_a+D'1', F
0060  0DA7  	RLF __mul_32u__0000F_arg_a+D'2', F
0061  0DA8  	RLF __mul_32u__0000F_arg_a+D'3', F
0062  0AB1  	INCF __mul_32u__0000F_1_i, F
0063  2846  	GOTO	label4
0064        ; } __mul_32u_32u function end


01D4        __rem_8_8_00000
01D4        ; { __rem_8_8 ; function begin
01D4  01FE  	CLRF CompTempVarRet220
01D5  01FC  	CLRF __rem_8_8_00000_1_c
01D6  01FD  	CLRF __rem_8_8_00000_1_i
01D7        label32
01D7  19FD  	BTFSC __rem_8_8_00000_1_i,3
01D8  0008  	RETURN
01D9  1003  	BCF STATUS,C
01DA  0DFC  	RLF __rem_8_8_00000_1_c, F
01DB  0DFA  	RLF __rem_8_8_00000_arg_a, F
01DC  0DFE  	RLF CompTempVarRet220, F
01DD  087B  	MOVF __rem_8_8_00000_arg_b, W
01DE  027E  	SUBWF CompTempVarRet220, W
01DF  1C03  	BTFSS STATUS,C
01E0  29E3  	GOTO	label33
01E1  00FE  	MOVWF CompTempVarRet220
01E2  147C  	BSF __rem_8_8_00000_1_c,0
01E3        label33
01E3  0AFD  	INCF __rem_8_8_00000_1_i, F
01E4  29D7  	GOTO	label32
01E5        ; } __rem_8_8 function end

01E5        __rem_16_1_00004
01E5        ; { __rem_16_16 ; function begin
01E5  1683  	BSF STATUS, RP0
01E6  1303  	BCF STATUS, RP1
01E7  01A7  	CLRF CompTempVarRet216
01E8  01A8  	CLRF CompTempVarRet216+D'1'
01E9  01A4  	CLRF __rem_16_1_00004_1_c
01EA  01A5  	CLRF __rem_16_1_00004_1_c+D'1'
01EB  01A6  	CLRF __rem_16_1_00004_1_i
01EC        label34
01EC  1A26  	BTFSC __rem_16_1_00004_1_i,4
01ED  0008  	RETURN
01EE  1003  	BCF STATUS,C
01EF  0DA4  	RLF __rem_16_1_00004_1_c, F
01F0  0DA5  	RLF __rem_16_1_00004_1_c+D'1', F
01F1  0DFA  	RLF __rem_16_1_00004_arg_a, F
01F2  0DFB  	RLF __rem_16_1_00004_arg_a+D'1', F
01F3  0DA7  	RLF CompTempVarRet216, F
01F4  0DA8  	RLF CompTempVarRet216+D'1', F
01F5  087D  	MOVF __rem_16_1_00004_arg_b+D'1', W
01F6  0228  	SUBWF CompTempVarRet216+D'1', W
01F7  1D03  	BTFSS STATUS,Z
01F8  29FB  	GOTO	label35
01F9  087C  	MOVF __rem_16_1_00004_arg_b, W
01FA  0227  	SUBWF CompTempVarRet216, W
01FB        label35
01FB  1C03  	BTFSS STATUS,C
01FC  2A04  	GOTO	label36
01FD  087C  	MOVF __rem_16_1_00004_arg_b, W
01FE  02A7  	SUBWF CompTempVarRet216, F
01FF  087D  	MOVF __rem_16_1_00004_arg_b+D'1', W
0200  1C03  	BTFSS STATUS,C
0201  03A8  	DECF CompTempVarRet216+D'1', F
0202  02A8  	SUBWF CompTempVarRet216+D'1', F
0203  1424  	BSF __rem_16_1_00004_1_c,0
0204        label36
0204  0AA6  	INCF __rem_16_1_00004_1_i, F
0205  29EC  	GOTO	label34
0206        ; } __rem_16_16 function end

0206        __div_8_8_00000
0206        ; { __div_8_8 ; function begin
0206  01FC  	CLRF __div_8_8_00000_1_r
0207  01FE  	CLRF CompTempVarRet218
0208  01FD  	CLRF __div_8_8_00000_1_i
0209        label37
0209  19FD  	BTFSC __div_8_8_00000_1_i,3
020A  0008  	RETURN
020B  1003  	BCF STATUS,C
020C  0DFE  	RLF CompTempVarRet218, F
020D  0DFA  	RLF __div_8_8_00000_arg_a, F
020E  0DFC  	RLF __div_8_8_00000_1_r, F
020F  087B  	MOVF __div_8_8_00000_arg_b, W
0210  027C  	SUBWF __div_8_8_00000_1_r, W
0211  1C03  	BTFSS STATUS,C
0212  2A15  	GOTO	label38
0213  00FC  	MOVWF __div_8_8_00000_1_r
0214  147E  	BSF CompTempVarRet218,0
0215        label38
0215  0AFD  	INCF __div_8_8_00000_1_i, F
0216  2A09  	GOTO	label37
0217        ; } __div_8_8 function end

0217        __div_16_1_00003
0217        ; { __div_16_16 ; function begin
0217  01A5  	CLRF __div_16_1_00003_1_r
0218  01A6  	CLRF __div_16_1_00003_1_r+D'1'
0219  01A8  	CLRF CompTempVarRet214
021A  01A9  	CLRF CompTempVarRet214+D'1'
021B  01A7  	CLRF __div_16_1_00003_1_i
021C        label39
021C  1A27  	BTFSC __div_16_1_00003_1_i,4
021D  0008  	RETURN
021E  1003  	BCF STATUS,C
021F  0DA8  	RLF CompTempVarRet214, F
0220  0DA9  	RLF CompTempVarRet214+D'1', F
0221  0DA0  	RLF __div_16_1_00003_arg_a, F
0222  0DA1  	RLF __div_16_1_00003_arg_a+D'1', F
0223  0DA5  	RLF __div_16_1_00003_1_r, F
0224  0DA6  	RLF __div_16_1_00003_1_r+D'1', F
0225  0823  	MOVF __div_16_1_00003_arg_b+D'1', W
0226  0226  	SUBWF __div_16_1_00003_1_r+D'1', W
0227  1D03  	BTFSS STATUS,Z
0228  2A2B  	GOTO	label40
0229  0822  	MOVF __div_16_1_00003_arg_b, W
022A  0225  	SUBWF __div_16_1_00003_1_r, W
022B        label40
022B  1C03  	BTFSS STATUS,C
022C  2A34  	GOTO	label41
022D  0822  	MOVF __div_16_1_00003_arg_b, W
022E  02A5  	SUBWF __div_16_1_00003_1_r, F
022F  0823  	MOVF __div_16_1_00003_arg_b+D'1', W
0230  1C03  	BTFSS STATUS,C
0231  03A6  	DECF __div_16_1_00003_1_r+D'1', F
0232  02A6  	SUBWF __div_16_1_00003_1_r+D'1', F
0233  1428  	BSF CompTempVarRet214,0
0234        label41
0234  0AA7  	INCF __div_16_1_00003_1_i, F
0235  2A1C  	GOTO	label39
0236        ; } __div_16_16 function end


05E4        _startup
05E4  30D5  	MOVLW 0xD5
05E5  1283  	BCF STATUS, RP0
05E6  1303  	BCF STATUS, RP1
05E7  00B2  	MOVWF gbl_14_LSR
05E8  30C4  	MOVLW 0xC4
05E9  00B3  	MOVWF gbl_14_LSR+D'1'
05EA  30BB  	MOVLW 0xBB
05EB  00B4  	MOVWF gbl_14_LSR+D'2'
05EC  30DC  	MOVLW 0xDC
05ED  00B5  	MOVWF gbl_14_LSR+D'3'
05EE  01B6  	CLRF gbl_15_gbl_aSig
05EF  01B7  	CLRF gbl_15_gbl_aSig+D'1'
05F0  01B8  	CLRF gbl_15_gbl_aSig+D'2'
05F1  01B9  	CLRF gbl_15_gbl_aSig+D'3'
05F2  01BA  	CLRF gbl_15_gbl_bSig
05F3  01BB  	CLRF gbl_15_gbl_bSig+D'1'
05F4  01BC  	CLRF gbl_15_gbl_bSig+D'2'
05F5  01BD  	CLRF gbl_15_gbl_bSig+D'3'
05F6  01BE  	CLRF gbl_15_gbl_zSig
05F7  01BF  	CLRF gbl_15_gbl_zSig+D'1'
05F8  01C0  	CLRF gbl_15_gbl_zSig+D'2'
05F9  01C1  	CLRF gbl_15_gbl_zSig+D'3'
05FA  01DD  	CLRF gbl_15_gbl_aExp
05FB  01DE  	CLRF gbl_15_gbl_bExp
05FC  01D2  	CLRF gbl_15_gbl_zExp
05FD  01D3  	CLRF gbl_15_gbl_zExp+D'1'
05FE  01DF  	CLRF gbl_15_gbl_aSign
05FF  01E0  	CLRF gbl_15_gbl_bSign
0600  01E1  	CLRF gbl_15_gbl_zSign
0601  01E2  	CLRF gbl_15_gbl_zSigZero
0602  01C2  	CLRF gbl_15_gbl_ret
0603  01C3  	CLRF gbl_15_gbl_ret+D'1'
0604  01C4  	CLRF gbl_15_gbl_ret+D'2'
0605  01C5  	CLRF gbl_15_gbl_ret+D'3'
0606  01DB  	CLRF gbl_float_rounding_mode
0607  01DC  	CLRF gbl_float_exception_flags
0608  01DA  	CLRF gbl_float_detect_tininess

0624  118A  	BCF PCLATH,3
0625  120A  	BCF PCLATH,4
0626  2C48  	GOTO	main

2007  20C2  	DW 0x20C2
2008  3EFF  	DW 0x3EFF
