;/////////////////////////////////////////////////////////////////////////////////
;// Code Generator: BoostC Compiler - http://www.sourceboost.com
;// Version       : 7.03
;// License Type  : Pro License
;// Limitations   : PIC12,PIC16 max code size:Unlimited, max RAM banks:Unlimited
;/////////////////////////////////////////////////////////////////////////////////

//************************************************************************************
//**  
//**  File name:     D:\KennyNeutronsInnovations\ScoreBoard\Flowcode\dm135Test2.c
//**  Title:         
//**  Description:   
//**  
//**  Generated by:  Flowcode v5.2.0.0
//**  Date:          Monday, January 28, 2019 20:48:12
//**  Licence:       Professional
//**  Registered to: xyz
//**  Licence key:   WUK7B9
//**  
//**  
//**  http://www.matrixmultimedia.com
//**  
//************************************************************************************


#define MX_PIC

#define MX_USES_UINT8 3
#define MX_USES_SINT16 0
#define MX_USES_CHAR 0
#define MX_USES_FLOAT 0
#define MX_USES_SINT32 0
#define MX_USES_BOOL 1
#define MX_USES_UINT16 0
#define MX_USES_UINT32 0
//Defines for microcontroller
#define P16F690
#define FC_CAL_PIC
#define MX_ADC
#define MX_ADC_TYPE_3
#define MX_ADC_BITS_10
#define MX_EE
#define MX_EE_TYPE2
#define MX_EE_SIZE 256
#define MX_SPI_1
#define MX_SPI_1_MISO_PORT portb
#define MX_SPI_1_MISO_TRIS trisb
#define MX_SPI_1_MISO_PIN 4
#define MX_SPI_1_MOSI_PORT portc
#define MX_SPI_1_MOSI_TRIS trisc
#define MX_SPI_1_MOSI_PIN 7
#define MX_SPI_1_CLK_PORT portb
#define MX_SPI_1_CLK_TRIS trisb
#define MX_SPI_1_CLK_PIN 6
#define MX_SPI_1_SS_PORT portb
#define MX_SPI_1_SS_TRIS trisb
#define MX_UART_1
#define MX_UART_1_TX_PORT portb
#define MX_UART_1_TX_TRIS trisb
#define MX_UART_1_TX_PIN 7
#define MX_UART_1_RX_PORT portb
#define MX_UART_1_RX_TRIS trisb
#define MX_UART_1_RX_PIN 5
#define MX_I2C
#define MX_MI2C
#define MX_I2C_1
#define MX_I2C_1_SDA_PORT portb
#define MX_I2C_1_SDA_TRIS trisb
#define MX_I2C_1_SDA_PIN 4
#define MX_I2C_1_SCL_PORT portb
#define MX_I2C_1_SCL_TRIS trisb
#define MX_I2C_1_SCL_PIN 6
#define MX_PWM
#define MX_PWM_CNT 1
#define MX_PWM_PSCA1
#define MX_PWM_PSCA4
#define MX_PWM_PSCA16
#define MX_PWM_1_PORT portc
#define MX_PWM_1_TRIS trisc
#define MX_PWM_1_PIN 5

//Functions
#define MX_CLK_SPEED 4000000
#ifdef _BOOSTC
#include <system.h>
#endif
#ifdef HI_TECH_C
#include <pic.h>
#endif

//Configuration data
#ifdef _BOOSTC
#pragma DATA 0x2007, 0x30d4
#endif
#ifdef HI_TECH_C
__CONFIG(0x30d4);
#endif

//Internal functions
#include "C:\Program Files (x86)\Flowcode\v5\FCD\internals.c"

//Macro function declarations
void FCM_databank();
void FCM_display();
void FCM_Data_recv();


//Variable declarations
#define FCV_FALSE (0)
#define FCV_TRUE (1)
MX_UINT8 FCV_RECIEVE;
MX_UINT8 FCV_TEMO_TENS = (0x0);
01E3  01C8  	CLRF gbl_FCV_TEMO_TENS

MX_BOOL FCV_DAT = (0);
01E4  1049  	BCF gbl_FCV_DAT,0

MX_UINT8 FCV_RECV[5];
MX_UINT8 FCV_BIT1;
MX_UINT8 FCV_BITS;
MX_UINT8 FCV_TEMP_ONES = (0x0);
01E5  01CB  	CLRF gbl_FCV_TEMP_ONES

MX_UINT8 FCV_TENS = (0x0);
01E6  01CC  	CLRF gbl_FCV_TENS

MX_UINT8 FCV_BIT2;
MX_UINT8 FCV_DIGIT;
MX_UINT8 FCV_COUNT = (0x0);
01E7  01CE  	CLRF gbl_FCV_COUNT

MX_UINT8 FCV_ONES = (0x0);
01E8  01CF  	CLRF gbl_FCV_ONES

MX_UINT8 FCV_RX_COUNT = (0x0);
01E9  01D0  	CLRF gbl_FCV_RX_COUNT


MX_UINT8 FCLV_LOOP1;
MX_UINT8 FCLV_LOOP2;
MX_UINT8 FCLV_LOOP3;



//RS232(0): //Defines:

/**** Macro Substitutions ****
a = Unique Reference
b = Uart Channel		(0-software / 1-4 hardware)
c = tx pin
d = tx port
e = rx pin
f = rx port
g = flow control		(0-Off / 1-On)
h = cts pin
i = cts port
j = rts pin
k = rts port
l = baud rate
m = data bits			(7/8/9) (7 only supported in software modes)
n = return type		(0-byte / 1-MX_UINT16)
o = echo enable		(0-Off / 1-On)
******************************/

//Definitions for RS232 UART slot allocation
#ifndef	MX_UART_REF1
	#define MX_UART_REF1
	#define RS232_1_MX_UART_UREF			1
	#define MX_UART_CHANNEL_1		1
	#define MX_UART_TX_PIN_1		0
	#define MX_UART_TX_PORT_1		porta
	#define MX_UART_TX_TRIS_1		trisa
	#define MX_UART_RX_PIN_1		0
	#define MX_UART_RX_PORT_1		porta
	#define MX_UART_RX_TRIS_1		trisa
	#define MX_UART_FLOWEN_1		0
	#define MX_UART_CTS_PIN_1		4
	#define MX_UART_CTS_PORT_1		portc
	#define MX_UART_CTS_TRIS_1		trisc
	#define MX_UART_RTS_PIN_1		0
	#define MX_UART_RTS_PORT_1		portc
	#define MX_UART_RTS_TRIS_1		trisc
	#define MX_UART_BAUD_1			9600
	#define MX_UART_DBITS_1			8
	#define MX_UART_RETURN_1		0
	#define MX_UART_ECHO_1			0
	#define MX_UART_INT_1			0
#else
 #ifndef	MX_UART_REF2
	#define MX_UART_REF2
	#define RS232_1_MX_UART_UREF			2
	#define MX_UART_CHANNEL_2		1
	#define MX_UART_TX_PIN_2		0
	#define MX_UART_TX_PORT_2		porta
	#define MX_UART_TX_TRIS_2		trisa
	#define MX_UART_RX_PIN_2		0
	#define MX_UART_RX_PORT_2		porta
	#define MX_UART_RX_TRIS_2		trisa
	#define MX_UART_FLOWEN_2		0
	#define MX_UART_CTS_PIN_2		4
	#define MX_UART_CTS_PORT_2		portc
	#define MX_UART_CTS_TRIS_2		trisc
	#define MX_UART_RTS_PIN_2		0
	#define MX_UART_RTS_PORT_2		portc
	#define MX_UART_RTS_TRIS_2		trisc
	#define MX_UART_BAUD_2			9600
	#define MX_UART_DBITS_2			8
	#define MX_UART_RETURN_2		0
	#define MX_UART_ECHO_2			0
	#define MX_UART_INT_2			0
 #else
  #ifndef	MX_UART_REF3
	#define MX_UART_REF3
	#define RS232_1_MX_UART_UREF			3
	#define MX_UART_CHANNEL_3		1
	#define MX_UART_TX_PIN_3		0
	#define MX_UART_TX_PORT_3		porta
	#define MX_UART_TX_TRIS_3		trisa
	#define MX_UART_RX_PIN_3		0
	#define MX_UART_RX_PORT_3		porta
	#define MX_UART_RX_TRIS_3		trisa
	#define MX_UART_FLOWEN_3		0
	#define MX_UART_CTS_PIN_3		4
	#define MX_UART_CTS_PORT_3		portc
	#define MX_UART_CTS_TRIS_3		trisc
	#define MX_UART_RTS_PIN_3		0
	#define MX_UART_RTS_PORT_3		portc
	#define MX_UART_RTS_TRIS_3		trisc
	#define MX_UART_BAUD_3			9600
	#define MX_UART_DBITS_3			8
	#define MX_UART_RETURN_3		0
	#define MX_UART_ECHO_3			0
	#define MX_UART_INT_3			0
  #else
   #ifndef	MX_UART_REF4
	#define MX_UART_REF4
	#define RS232_1_MX_UART_UREF			4
	#define MX_UART_CHANNEL_4		1
	#define MX_UART_TX_PIN_4		0
	#define MX_UART_TX_PORT_4		porta
	#define MX_UART_TX_TRIS_4		trisa
	#define MX_UART_RX_PIN_4		0
	#define MX_UART_RX_PORT_4		porta
	#define MX_UART_RX_TRIS_4		trisa
	#define MX_UART_FLOWEN_4		0
	#define MX_UART_CTS_PIN_4		4
	#define MX_UART_CTS_PORT_4		portc
	#define MX_UART_CTS_TRIS_4		trisc
	#define MX_UART_RTS_PIN_4		0
	#define MX_UART_RTS_PORT_4		portc
	#define MX_UART_RTS_TRIS_4		trisc
	#define MX_UART_BAUD_4			9600
	#define MX_UART_DBITS_4			8
	#define MX_UART_RETURN_4		0
	#define MX_UART_ECHO_4			0
	#define MX_UART_INT_4			0
   #endif
  #endif
 #endif
#endif

#define RS232_1_UART_Init		CAL_APPEND(FC_CAL_UART_Init_, RS232_1_MX_UART_UREF)
#define RS232_1_UART_Send		CAL_APPEND(FC_CAL_UART_Send_, RS232_1_MX_UART_UREF)
#define RS232_1_UART_Receive		CAL_APPEND(FC_CAL_UART_Receive_, RS232_1_MX_UART_UREF)
#define RS232_1_UART_Update_Baud CAL_APPEND(FC_CAL_UART_Update_Baud_, RS232_1_MX_UART_UREF)

extern void RS232_1_UART_Init();
extern void RS232_1_UART_Send(MX_UINT16 nChar);
extern MX_SINT16 RS232_1_UART_Receive(MX_UINT8 nTimeout);
extern void RS232_1_UART_Update_Baud(MX_UINT8 newbaud);




//RS232(0): //Macro function declarations

void FCD_RS2320_SendRS232Char(MX_SINT16 nChar);
void FCD_RS2320_SendRS232String(MX_STRING String, MX_UINT8 MSZ_String);
MX_SINT16 FCD_RS2320_ReceiveRS232Char(MX_UINT8 nTimeout);
void FCD_RS2320_ReceiveRS232String(MX_CHAR* FCR_RETVAL, MX_UINT8 FCR_RETVAL_SIZE, MX_UINT8 nTimeout, MX_UINT8 NumBytes);
void FCD_RS2320_ChangeHWBaud(MX_UINT8 newbaud);



//RS232(0): //Macro implementations


void FCD_RS2320_SendRS232Char(MX_SINT16 nChar)

{
	
		RS232_1_UART_Send ( nChar);
0153  0854  	MOVF FCD_RS2320_00055_arg_nChar, W
0154  00D6  	MOVWF FC_CAL_UAR_00057_arg_nChar
0155  0855  	MOVF FCD_RS2320_00055_arg_nChar+D'1', W
0156  00D7  	MOVWF FC_CAL_UAR_00057_arg_nChar+D'1'
0157  2066  	CALL FC_CAL_UAR_00057


}
0158  0008  	RETURN


void FCD_RS2320_SendRS232String(MX_STRING String, MX_UINT8 MSZ_String)
{
	
		MX_UINT8 idx;
		for(idx = 0; idx < MSZ_String; idx++)
		{
			if (String[idx] == 0)
				break;
			else RS232_1_UART_Send ( String[idx] );
		}

}

MX_SINT16 FCD_RS2320_ReceiveRS232Char(MX_UINT8 nTimeout)

{
	
		return ( RS232_1_UART_Receive ( nTimeout) );
0159  0854  	MOVF FCD_RS2320_00054_arg_nTimeout, W
015A  00D5  	MOVWF FC_CAL_UAR_00058_arg_nTimeout
015B  201A  	CALL FC_CAL_UAR_00058
015C  085C  	MOVF CompTempVarRet2204, W
015D  00D6  	MOVWF CompTempVarRet2203
015E  085D  	MOVF CompTempVarRet2204+D'1', W
015F  00D7  	MOVWF CompTempVarRet2203+D'1'


}
0160  0008  	RETURN


void FCD_RS2320_ReceiveRS232String(MX_CHAR* FCR_RETVAL, MX_UINT8 FCR_RETVAL_SIZE, MX_UINT8 nTimeout, MX_UINT8 NumBytes)
{
	
		MX_UINT8 idx;
		MX_SINT16 RS232_TO = 255;
		MX_SINT16 in;

		if ( 0 != 0 )
			RS232_TO = 256;

		if (NumBytes > FCR_RETVAL_SIZE)
			NumBytes = FCR_RETVAL_SIZE;

		for (idx = 0; idx < NumBytes; idx++)
		{
			in = RS232_1_UART_Receive ( nTimeout);
			if(in < RS232_TO)
				FCR_RETVAL[idx] = in & 0xFF;
			else
				break;
		}

		if (idx < FCR_RETVAL_SIZE)
			FCR_RETVAL[idx] = 0;

}

void FCD_RS2320_ChangeHWBaud(MX_UINT8 newbaud)
{
	
		RS232_1_UART_Update_Baud (newbaud);

}

#include "C:\Program Files (x86)\Flowcode\v5\CAL\includes.c"

//Macro implementations


void FCM_databank()

{

	//Switch
	//Switch: digit?
	switch (FCV_DIGIT)

	{
		case 1:
006B  1283  	BCF STATUS, RP0
006C  1303  	BCF STATUS, RP1
006D  084D  	MOVF gbl_FCV_DIGIT, W
006E  3A01  	XORLW 0x01
006F  1903  	BTFSC STATUS,Z
0070  288D  	GOTO	label10
008D        label10

		{
			//Calculation
			//Calculation:
			//  bits = 48
			FCV_BITS = 48;
008D  3030  	MOVLW 0x30
008E  00CA  	MOVWF gbl_FCV_BITS


			break;

		}
		case 2:
0071  3A03  	XORLW 0x03
0072  1903  	BTFSC STATUS,Z
0073  2890  	GOTO	label11
0090        label11

		{
			//Calculation
			//Calculation:
			//  bits = 91
			FCV_BITS = 91;
0090  305B  	MOVLW 0x5B
0091  00CA  	MOVWF gbl_FCV_BITS


			break;

		}
		case 3:
0074  3A01  	XORLW 0x01
0075  1903  	BTFSC STATUS,Z
0076  2893  	GOTO	label12
0093        label12

		{
			//Calculation
			//Calculation:
			//  bits = 121
			FCV_BITS = 121;
0093  3079  	MOVLW 0x79
0094  00CA  	MOVWF gbl_FCV_BITS


			break;

		}
		case 4:
0077  3A07  	XORLW 0x07
0078  1903  	BTFSC STATUS,Z
0079  2896  	GOTO	label13
0096        label13

		{
			//Calculation
			//Calculation:
			//  bits = 116
			FCV_BITS = 116;
0096  3074  	MOVLW 0x74
0097  00CA  	MOVWF gbl_FCV_BITS


			break;

		}
		case 5:
007A  3A01  	XORLW 0x01
007B  1903  	BTFSC STATUS,Z
007C  2899  	GOTO	label14
0099        label14

		{
			//Calculation
			//Calculation:
			//  bits = 109
			FCV_BITS = 109;
0099  306D  	MOVLW 0x6D
009A  00CA  	MOVWF gbl_FCV_BITS


			break;

		}
		case 6:
007D  3A03  	XORLW 0x03
007E  1903  	BTFSC STATUS,Z
007F  289C  	GOTO	label15
009C        label15

		{
			//Calculation
			//Calculation:
			//  bits = 111
			FCV_BITS = 111;
009C  306F  	MOVLW 0x6F
009D  00CA  	MOVWF gbl_FCV_BITS


			break;

		}
		case 7:
0080  3A01  	XORLW 0x01
0081  1903  	BTFSC STATUS,Z
0082  289F  	GOTO	label16
009F        label16

		{
			//Calculation
			//Calculation:
			//  bits = 56
			FCV_BITS = 56;
009F  3038  	MOVLW 0x38
00A0  00CA  	MOVWF gbl_FCV_BITS


			break;

		}
		case 8:
0083  3A0F  	XORLW 0x0F
0084  1903  	BTFSC STATUS,Z
0085  28A2  	GOTO	label17
00A2        label17

		{
			//Calculation
			//Calculation:
			//  bits = 127
			FCV_BITS = 127;
00A2  307F  	MOVLW 0x7F
00A3  00CA  	MOVWF gbl_FCV_BITS


			break;

		}
		case 9:
0086  3A01  	XORLW 0x01
0087  1903  	BTFSC STATUS,Z
0088  28A5  	GOTO	label18
00A5        label18

		{
			//Calculation
			//Calculation:
			//  bits = 125
			FCV_BITS = 125;
00A5  307D  	MOVLW 0x7D
00A6  00CA  	MOVWF gbl_FCV_BITS


			break;

		}
		case 0:
0089  3A09  	XORLW 0x09
008A  1903  	BTFSC STATUS,Z
008B  28A8  	GOTO	label19
00A8        label19

		{
			//Calculation
			//Calculation:
			//  bits = 63
			FCV_BITS = 63;
00A8  303F  	MOVLW 0x3F
00A9  00CA  	MOVWF gbl_FCV_BITS


			break;

		}
		// default:

	}

}
008C  0008  	RETURN
008F  0008  	RETURN
0092  0008  	RETURN
0095  0008  	RETURN
0098  0008  	RETURN
009B  0008  	RETURN
009E  0008  	RETURN
00A1  0008  	RETURN
00A4  0008  	RETURN
00A7  0008  	RETURN
00AA  0008  	RETURN



void FCM_display()

{

	//Calculation
	//Calculation:
	//  digit = tens - 48
	FCV_DIGIT = FCV_TENS - 48;
00AB  3030  	MOVLW 0x30
00AC  1283  	BCF STATUS, RP0
00AD  1303  	BCF STATUS, RP1
00AE  024C  	SUBWF gbl_FCV_TENS, W
00AF  00CD  	MOVWF gbl_FCV_DIGIT


	//Call Macro
	//Call Macro: databank()
	FCM_databank();
00B0  206B  	CALL FCM_databa_00051


	//Loop
	//Loop: Loop 8 times
	for (FCLV_LOOP1=0; FCLV_LOOP1<8; FCLV_LOOP1++)
00B1  01D1  	CLRF gbl_FCLV_LOOP1
00B2        label20
00B2  3008  	MOVLW 0x08
00B3  0251  	SUBWF gbl_FCLV_LOOP1, W
00B4  1803  	BTFSC STATUS,C
00B5  28F3  	GOTO	label23
00F1  0AD1  	INCF gbl_FCLV_LOOP1, F
00F2  28B2  	GOTO	label20
00F3        label23

	{

		//Calculation
		//Calculation:
		//  dat = bits AND 1
		FCV_DAT = FCV_BITS & 1;
00B6  3001  	MOVLW 0x01
00B7  054A  	ANDWF gbl_FCV_BITS, W
00B8  00D4  	MOVWF CompTempVar2188
00B9  01D5  	CLRF CompTempVar2189
00BA  08D4  	MOVF CompTempVar2188, F
00BB  1D03  	BTFSS STATUS,Z
00BC  1455  	BSF CompTempVar2189,0
00BD  1049  	BCF gbl_FCV_DAT,0
00BE  0855  	MOVF CompTempVar2189, W
00BF  1D03  	BTFSS STATUS,Z
00C0  1449  	BSF gbl_FCV_DAT,0


		//data
		//Output: dat -> C2
		trisc = trisc & 0xFB;
00C1  30FB  	MOVLW 0xFB
00C2  1683  	BSF STATUS, RP0
00C3  0507  	ANDWF gbl_trisc, W
00C4  0087  	MOVWF gbl_trisc

		if ((FCV_DAT))
00C5  1283  	BCF STATUS, RP0
00C6  1C49  	BTFSS gbl_FCV_DAT,0
00C7  28CF  	GOTO	label21
00CF        label21

			portc = (portc & 0xFB) | 0x04;
00C8  30FB  	MOVLW 0xFB
00C9  0507  	ANDWF gbl_portc, W
00CA  00D4  	MOVWF CompTempVar2190
00CB  3004  	MOVLW 0x04
00CC  0454  	IORWF CompTempVar2190, W
00CD  0087  	MOVWF gbl_portc

		else
00CE  28D2  	GOTO	label22
00D2        label22

			portc = portc & 0xFB;
00CF  30FB  	MOVLW 0xFB
00D0  0507  	ANDWF gbl_portc, W
00D1  0087  	MOVWF gbl_portc


		//Delay
		//Delay: 1 us
		delay_us(1);
00D2  3001  	MOVLW 0x01
00D3  00DC  	MOVWF delay_us_00000_arg_del
00D4  2010  	CALL delay_us_00000


		//clk
		//Output: 1 -> C0
		trisc = trisc & 0xFE;
00D5  30FE  	MOVLW 0xFE
00D6  1683  	BSF STATUS, RP0
00D7  0507  	ANDWF gbl_trisc, W
00D8  0087  	MOVWF gbl_trisc

		if ((1))
			portc = (portc & 0xFE) | 0x01;
00D9  30FE  	MOVLW 0xFE
00DA  1283  	BCF STATUS, RP0
00DB  0507  	ANDWF gbl_portc, W
00DC  00D4  	MOVWF CompTempVar2191
00DD  3001  	MOVLW 0x01
00DE  0454  	IORWF CompTempVar2191, W
00DF  0087  	MOVWF gbl_portc

		else
			portc = portc & 0xFE;

		//Delay
		//Delay: 1 us
		delay_us(1);
00E0  3001  	MOVLW 0x01
00E1  00DC  	MOVWF delay_us_00000_arg_del
00E2  2010  	CALL delay_us_00000


		//clk
		//Output: 0 -> C0
		trisc = trisc & 0xFE;
00E3  30FE  	MOVLW 0xFE
00E4  1683  	BSF STATUS, RP0
00E5  0507  	ANDWF gbl_trisc, W
00E6  0087  	MOVWF gbl_trisc

		if ((0))
			portc = (portc & 0xFE) | 0x01;
		else
			portc = portc & 0xFE;
00E7  30FE  	MOVLW 0xFE
00E8  1283  	BCF STATUS, RP0
00E9  0507  	ANDWF gbl_portc, W
00EA  0087  	MOVWF gbl_portc


		//Delay
		//Delay: 1 us
		delay_us(1);
00EB  3001  	MOVLW 0x01
00EC  00DC  	MOVWF delay_us_00000_arg_del
00ED  2010  	CALL delay_us_00000


		//Calculation
		//Calculation:
		//  bits = bits >> 1
		FCV_BITS = FCV_BITS >> 1;
00EE  08CA  	MOVF gbl_FCV_BITS, F
00EF  1003  	BCF STATUS,C
00F0  0CCA  	RRF gbl_FCV_BITS, F



	}

	//Calculation
	//Calculation:
	//  digit = ones - 48
	FCV_DIGIT = FCV_ONES - 48;
00F3  3030  	MOVLW 0x30
00F4  024F  	SUBWF gbl_FCV_ONES, W
00F5  00CD  	MOVWF gbl_FCV_DIGIT


	//Call Macro
	//Call Macro: databank()
	FCM_databank();
00F6  206B  	CALL FCM_databa_00051


	//Loop
	//Loop: Loop 8 times
	for (FCLV_LOOP2=0; FCLV_LOOP2<8; FCLV_LOOP2++)
00F7  01D2  	CLRF gbl_FCLV_LOOP2
00F8        label24
00F8  3008  	MOVLW 0x08
00F9  0252  	SUBWF gbl_FCLV_LOOP2, W
00FA  1803  	BTFSC STATUS,C
00FB  2939  	GOTO	label27
0137  0AD2  	INCF gbl_FCLV_LOOP2, F
0138  28F8  	GOTO	label24
0139        label27

	{

		//Calculation
		//Calculation:
		//  dat = bits AND 1
		FCV_DAT = FCV_BITS & 1;
00FC  3001  	MOVLW 0x01
00FD  054A  	ANDWF gbl_FCV_BITS, W
00FE  00D4  	MOVWF CompTempVar2193
00FF  01D5  	CLRF CompTempVar2194
0100  08D4  	MOVF CompTempVar2193, F
0101  1D03  	BTFSS STATUS,Z
0102  1455  	BSF CompTempVar2194,0
0103  1049  	BCF gbl_FCV_DAT,0
0104  0855  	MOVF CompTempVar2194, W
0105  1D03  	BTFSS STATUS,Z
0106  1449  	BSF gbl_FCV_DAT,0


		//data
		//Output: dat -> C2
		trisc = trisc & 0xFB;
0107  30FB  	MOVLW 0xFB
0108  1683  	BSF STATUS, RP0
0109  0507  	ANDWF gbl_trisc, W
010A  0087  	MOVWF gbl_trisc

		if ((FCV_DAT))
010B  1283  	BCF STATUS, RP0
010C  1C49  	BTFSS gbl_FCV_DAT,0
010D  2915  	GOTO	label25
0115        label25

			portc = (portc & 0xFB) | 0x04;
010E  30FB  	MOVLW 0xFB
010F  0507  	ANDWF gbl_portc, W
0110  00D4  	MOVWF CompTempVar2195
0111  3004  	MOVLW 0x04
0112  0454  	IORWF CompTempVar2195, W
0113  0087  	MOVWF gbl_portc

		else
0114  2918  	GOTO	label26
0118        label26

			portc = portc & 0xFB;
0115  30FB  	MOVLW 0xFB
0116  0507  	ANDWF gbl_portc, W
0117  0087  	MOVWF gbl_portc


		//Delay
		//Delay: 1 us
		delay_us(1);
0118  3001  	MOVLW 0x01
0119  00DC  	MOVWF delay_us_00000_arg_del
011A  2010  	CALL delay_us_00000


		//clk
		//Output: 1 -> C0
		trisc = trisc & 0xFE;
011B  30FE  	MOVLW 0xFE
011C  1683  	BSF STATUS, RP0
011D  0507  	ANDWF gbl_trisc, W
011E  0087  	MOVWF gbl_trisc

		if ((1))
			portc = (portc & 0xFE) | 0x01;
011F  30FE  	MOVLW 0xFE
0120  1283  	BCF STATUS, RP0
0121  0507  	ANDWF gbl_portc, W
0122  00D4  	MOVWF CompTempVar2196
0123  3001  	MOVLW 0x01
0124  0454  	IORWF CompTempVar2196, W
0125  0087  	MOVWF gbl_portc

		else
			portc = portc & 0xFE;

		//Delay
		//Delay: 1 us
		delay_us(1);
0126  3001  	MOVLW 0x01
0127  00DC  	MOVWF delay_us_00000_arg_del
0128  2010  	CALL delay_us_00000


		//clk
		//Output: 0 -> C0
		trisc = trisc & 0xFE;
0129  30FE  	MOVLW 0xFE
012A  1683  	BSF STATUS, RP0
012B  0507  	ANDWF gbl_trisc, W
012C  0087  	MOVWF gbl_trisc

		if ((0))
			portc = (portc & 0xFE) | 0x01;
		else
			portc = portc & 0xFE;
012D  30FE  	MOVLW 0xFE
012E  1283  	BCF STATUS, RP0
012F  0507  	ANDWF gbl_portc, W
0130  0087  	MOVWF gbl_portc


		//Delay
		//Delay: 1 us
		delay_us(1);
0131  3001  	MOVLW 0x01
0132  00DC  	MOVWF delay_us_00000_arg_del
0133  2010  	CALL delay_us_00000


		//Calculation
		//Calculation:
		//  bits = bits >> 1
		FCV_BITS = FCV_BITS >> 1;
0134  08CA  	MOVF gbl_FCV_BITS, F
0135  1003  	BCF STATUS,C
0136  0CCA  	RRF gbl_FCV_BITS, F



	}

	//reg
	//Output: 1 -> C1
	trisc = trisc & 0xFD;
0139  30FD  	MOVLW 0xFD
013A  1683  	BSF STATUS, RP0
013B  0507  	ANDWF gbl_trisc, W
013C  0087  	MOVWF gbl_trisc

	if ((1))
		portc = (portc & 0xFD) | 0x02;
013D  30FD  	MOVLW 0xFD
013E  1283  	BCF STATUS, RP0
013F  0507  	ANDWF gbl_portc, W
0140  00D4  	MOVWF CompTempVar2198
0141  3002  	MOVLW 0x02
0142  0454  	IORWF CompTempVar2198, W
0143  0087  	MOVWF gbl_portc

	else
		portc = portc & 0xFD;

	//Delay
	//Delay: 1 us
	delay_us(1);
0144  3001  	MOVLW 0x01
0145  00DC  	MOVWF delay_us_00000_arg_del
0146  2010  	CALL delay_us_00000


	//reg
	//Output: 0 -> C1
	trisc = trisc & 0xFD;
0147  30FD  	MOVLW 0xFD
0148  1683  	BSF STATUS, RP0
0149  0507  	ANDWF gbl_trisc, W
014A  0087  	MOVWF gbl_trisc

	if ((0))
		portc = (portc & 0xFD) | 0x02;
	else
		portc = portc & 0xFD;
014B  30FD  	MOVLW 0xFD
014C  1283  	BCF STATUS, RP0
014D  0507  	ANDWF gbl_portc, W
014E  0087  	MOVWF gbl_portc


	//Delay
	//Delay: 1 us
	delay_us(1);
014F  3001  	MOVLW 0x01
0150  00DC  	MOVWF delay_us_00000_arg_del
0151  2010  	CALL delay_us_00000


}
0152  0008  	RETURN



void FCM_Data_recv()

{

	//Calculation
	//Calculation:
	//  rx_count = 0
	FCV_RX_COUNT = 0;
0170  1283  	BCF STATUS, RP0
0171  1303  	BCF STATUS, RP1
0172  01D0  	CLRF gbl_FCV_RX_COUNT


	//Loop
	//Loop: Loop 3 times
	for (FCLV_LOOP3=0; FCLV_LOOP3<3; FCLV_LOOP3++)
0173  01D3  	CLRF gbl_FCLV_LOOP3
0174        label28
0174  3003  	MOVLW 0x03
0175  0253  	SUBWF gbl_FCLV_LOOP3, W
0176  1803  	BTFSC STATUS,C
0177  2988  	GOTO	label29
0186  0AD3  	INCF gbl_FCLV_LOOP3, F
0187  2974  	GOTO	label28
0188        label29

	{

		//Call Component Macro
		//Call Component Macro: recieve=ReceiveRS232Char(25)
		FCV_RECIEVE = FCD_RS2320_ReceiveRS232Char(25);
0178  3019  	MOVLW 0x19
0179  00D4  	MOVWF FCD_RS2320_00054_arg_nTimeout
017A  2159  	CALL FCD_RS2320_00054
017B  0856  	MOVF CompTempVarRet2203, W
017C  00C7  	MOVWF gbl_FCV_RECIEVE


		//Calculation
		//Calculation:
		//  recv[rx_count] = recieve
		//  rx_count = rx_count + 1
		FCV_RECV[FCV_RX_COUNT] = FCV_RECIEVE;
017D  1383  	BCF	STATUS,IRP
017E  3020  	MOVLW LOW(gbl_FCV_RECV+D'0')
017F  0084  	MOVWF FSR
0180  0850  	MOVF gbl_FCV_RX_COUNT, W
0181  0784  	ADDWF FSR, F
0182  0847  	MOVF gbl_FCV_RECIEVE, W
0183  0080  	MOVWF INDF

		FCV_RX_COUNT = FCV_RX_COUNT + 1;
0184  0A50  	INCF gbl_FCV_RX_COUNT, W
0185  00D0  	MOVWF gbl_FCV_RX_COUNT



	}

	//Decision
	//Decision: recv[1] = 'o'?
	if (FCV_RECV[1] == 'o')
0188  0821  	MOVF gbl_FCV_RECV+D'1', W
0189  3A6F  	XORLW 0x6F
018A  1D03  	BTFSS STATUS,Z

	{

		//
		//Calculation:
		//  tens = recv[0]
		//  ones = recv[2]
		FCV_TENS = FCV_RECV[0];
018C  0820  	MOVF gbl_FCV_RECV, W
018D  00CC  	MOVWF gbl_FCV_TENS

		FCV_ONES = FCV_RECV[2];
018E  0822  	MOVF gbl_FCV_RECV+D'2', W
018F  00CF  	MOVWF gbl_FCV_ONES


		//Call Component Macro
		//Call Component Macro: SendRS232Char(ones)
		FCD_RS2320_SendRS232Char(FCV_ONES);
0190  084F  	MOVF gbl_FCV_ONES, W
0191  00D4  	MOVWF FCD_RS2320_00055_arg_nChar
0192  01D5  	CLRF FCD_RS2320_00055_arg_nChar+D'1'
0193  2153  	CALL FCD_RS2320_00055


		//Call Component Macro
		//Call Component Macro: SendRS232Char(tens)
		FCD_RS2320_SendRS232Char(FCV_TENS);
0194  084C  	MOVF gbl_FCV_TENS, W
0195  00D4  	MOVWF FCD_RS2320_00055_arg_nChar
0196  01D5  	CLRF FCD_RS2320_00055_arg_nChar+D'1'
0197  2153  	CALL FCD_RS2320_00055


		//Call Macro
		//Call Macro: display()
		FCM_display();
0198  20AB  	CALL FCM_displa_00052


	// } else {

	}

}
018B  0008  	RETURN
0199  0008  	RETURN




void main()

{
	//Initialization
	ansel = 0;
019A  1283  	BCF STATUS, RP0
019B  1703  	BSF STATUS, RP1
019C  019E  	CLRF gbl_ansel

anselh = 0;
019D  019F  	CLRF gbl_anselh


	
		RS232_1_UART_Init( );		//Call initialise function
019E  2161  	CALL FC_CAL_UAR_00056



	//Interrupt initialization code
	option_reg = 0xC0;
019F  30C0  	MOVLW 0xC0
01A0  0081  	MOVWF gbl_option_reg



	//clk
	//Output: 0 -> C0
	trisc = trisc & 0xFE;
01A1  30FE  	MOVLW 0xFE
01A2  0507  	ANDWF gbl_trisc, W
01A3  0087  	MOVWF gbl_trisc

	if ((0))
		portc = (portc & 0xFE) | 0x01;
	else
		portc = portc & 0xFE;
01A4  30FE  	MOVLW 0xFE
01A5  1283  	BCF STATUS, RP0
01A6  0507  	ANDWF gbl_portc, W
01A7  0087  	MOVWF gbl_portc


	//reg
	//Output: 0 -> C1
	trisc = trisc & 0xFD;
01A8  30FD  	MOVLW 0xFD
01A9  1683  	BSF STATUS, RP0
01AA  0507  	ANDWF gbl_trisc, W
01AB  0087  	MOVWF gbl_trisc

	if ((0))
		portc = (portc & 0xFD) | 0x02;
	else
		portc = portc & 0xFD;
01AC  30FD  	MOVLW 0xFD
01AD  1283  	BCF STATUS, RP0
01AE  0507  	ANDWF gbl_portc, W
01AF  0087  	MOVWF gbl_portc


	//Calculation
	//Calculation:
	//  tens = 9
	//  ones = 9
	FCV_TENS = 9;
01B0  3009  	MOVLW 0x09
01B1  00CC  	MOVWF gbl_FCV_TENS

	FCV_ONES = 9;
01B2  00CF  	MOVWF gbl_FCV_ONES


	//Call Macro
	//Call Macro: display()
	FCM_display();
01B3  20AB  	CALL FCM_displa_00052


	//Loop
	//Loop: While 1
	while (1)
01B4        label30
01BD  29B4  	GOTO	label30

	{

		//Call Component Macro
		//Call Component Macro: recieve=ReceiveRS232Char(100)
		FCV_RECIEVE = FCD_RS2320_ReceiveRS232Char(100);
01B4  3064  	MOVLW 0x64
01B5  00D4  	MOVWF FCD_RS2320_00054_arg_nTimeout
01B6  2159  	CALL FCD_RS2320_00054
01B7  0856  	MOVF CompTempVarRet2203, W
01B8  00C7  	MOVWF gbl_FCV_RECIEVE


		//Decision
		//Decision: recieve = 't'?
		if (FCV_RECIEVE == 't')
01B9  0847  	MOVF gbl_FCV_RECIEVE, W
01BA  3A74  	XORLW 0x74
01BB  1903  	BTFSC STATUS,Z

		{

			//Call Macro
			//Call Macro: Data_recv()
			FCM_Data_recv();
01BC  2170  	CALL FCM_Data_r_00053


		// } else {

		}


	}

	mainendloop: goto mainendloop;
}


void MX_INTERRUPT_MACRO(void)

{
}
01ED  1283  	BCF STATUS, RP0
01EE  1303  	BCF STATUS, RP1
01EF  0E3B  	SWAPF Int1BContext+D'2', W
01F0  0084  	MOVWF FSR
01F1  0E3A  	SWAPF Int1BContext+D'1', W
01F2  008A  	MOVWF PCLATH
01F3  0E39  	SWAPF Int1BContext, W
01F4  0083  	MOVWF STATUS
01F5  0EFF  	SWAPF Int1Context, F
01F6  0E7F  	SWAPF Int1Context, W
01F7  0009  	RETFIE





/*********************************************************************
 *                  Flowcode CAL UART File
 *
 * File: PIC_CAL_UART.c
 *
 * (c) 2011 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * “Company”) for its Flowcode graphical programming language is
 * intended and supplied to you, the Company’s customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 010911 | BR | Created
 * 020911 | BR | Updated variables with typedef alternatives
 * 011211 | BR | Converted to new dynamic defines mechanism
 * 160112 | BR | Fixed issues with rx return type and low bauds on fast devices
 * 020212 | ST | Added <MX_UART_2_PIE4> routing to account for differences in 16F and 18F devices with 2 UARTs
 * 270212 | BR | Fixed a bug in the receive functionality
 * 280212 | BR | Sorted out auto echo functionality
 * 160412 | BR | Addition of HW change baud function
 */



#ifndef MX_UART_SW_DEFS
	#define MX_UART_SW_DEFS

	#ifdef _BOOSTC
		#define INST_COUNT	45	//65 for lower speeds or 40 for higher speeds.
	#endif
	#ifdef HI_TECH_C
		#define INST_COUNT	315
	#endif

	//Work out number of nops for software baud rate
	#define MX_INSTRUCTION_SPEED 	(MX_CLK_SPEED / 4)
	#define MX_OVERHEAD				(MX_INSTRUCTION_SPEED / INST_COUNT)
	#define SW_OFFSET				(1000000 / MX_OVERHEAD)

	//Work out software baud rates if required
	#define SW_1200_BAUD	(832 - SW_OFFSET)
	#define SW_2400_BAUD	(416 - SW_OFFSET)
	#define SW_4800_BAUD	(208 - SW_OFFSET)
	#define SW_9600_BAUD	(104 - SW_OFFSET)
	#define SW_19200_BAUD	(52 - SW_OFFSET)
	#define SW_31250_BAUD	(32 - SW_OFFSET)
	#define SW_115200_BAUD	(8 - SW_OFFSET)
#endif

 #if defined(MX_UART_CHANNEL_1) && (MX_UART_NUM==1)
	#if (MX_UART_CHANNEL_1 == 0)
		#if (MX_UART_BAUD_1 == 1200)
			#define MX_SOFT_BAUD_1	SW_1200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 1200 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_1 == 2400)
			#define MX_SOFT_BAUD_1	SW_2400_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 2400 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_1 == 4800)
			#define MX_SOFT_BAUD_1	SW_4800_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 4800 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_1 == 9600)
			#define MX_SOFT_BAUD_1	SW_9600_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 9600 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_1 == 19200)
			#define MX_SOFT_BAUD_1	SW_19200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 19200 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_1 == 31250)
			#define MX_SOFT_BAUD_1	SW_31250_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 31250 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_1 == 115200)
			#define MX_SOFT_BAUD_1	SW_115200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 115200 Not Available At This Clock Speed"
			#endif
		#endif
		#ifndef MX_SOFT_BAUD_1
			#error "UART Baud Rate not supported in Software Mode"
		#endif
	#else
		#define MX_SOFT_BAUD_1	1
		#define MX_HARD_BAUD_1	(((MX_CLK_SPEED / MX_UART_BAUD_1) - 16) / 16)
		#define MX_HARD_SLOW_1	0

		#if (MX_HARD_BAUD_1 > 255)
			#undef MX_HARD_BAUD_1
			#undef MX_HARD_SLOW_1
			#define MX_HARD_BAUD_1	(((MX_CLK_SPEED / MX_UART_BAUD_1) - 16)	/ 64)
			#define MX_HARD_SLOW_1	1
		#endif

	#endif
 #endif
 #if defined(MX_UART_CHANNEL_2) && (MX_UART_NUM==2)
	#if (MX_UART_CHANNEL_2 == 0)
		#if (MX_UART_BAUD_2 == 1200)
			#define MX_SOFT_BAUD_2	SW_1200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 1200 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_2 == 2400)
			#define MX_SOFT_BAUD_2	SW_2400_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 2400 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_2 == 4800)
			#define MX_SOFT_BAUD_2	SW_4800_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 4800 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_2 == 9600)
			#define MX_SOFT_BAUD_2	SW_9600_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 9600 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_2 == 19200)
			#define MX_SOFT_BAUD_2	SW_19200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 19200 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_2 == 31250)
			#define MX_SOFT_BAUD_2	SW_31250_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 31250 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_2 == 115200)
			#define MX_SOFT_BAUD_2	SW_115200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 115200 Not Available At This Clock Speed"
			#endif
		#endif
		#ifndef MX_SOFT_BAUD_2
			#error "UART Baud Rate not supported in Software Mode"
		#endif
	#else
		#define MX_SOFT_BAUD_2	1
		#define MX_HARD_BAUD_2	(((MX_CLK_SPEED / MX_UART_BAUD_2) - 16) / 16)
		#define MX_HARD_SLOW_2	0

		#if (MX_HARD_BAUD_2 > 255)
			#undef MX_HARD_BAUD_2
			#undef MX_HARD_SLOW_2
			#define MX_HARD_BAUD_2	(((MX_CLK_SPEED / MX_UART_BAUD_2) - 16)	/ 64)
			#define MX_HARD_SLOW_2	1
		#endif
 	#endif
 #endif
 #if defined(MX_UART_CHANNEL_3) && (MX_UART_NUM==3)
	#if (MX_UART_CHANNEL_3 == 0)
		#if (MX_UART_BAUD_3 == 1200)
			#define MX_SOFT_BAUD_3	SW_1200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 1200 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_3 == 2400)
			#define MX_SOFT_BAUD_3	SW_2400_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 2400 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_3 == 4800)
			#define MX_SOFT_BAUD_3	SW_4800_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 4800 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_3 == 9600)
			#define MX_SOFT_BAUD_3	SW_9600_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 9600 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_3 == 19200)
			#define MX_SOFT_BAUD_3	SW_19200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 19200 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_3 == 31250)
			#define MX_SOFT_BAUD_3	SW_31250_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 31250 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_3 == 115200)
			#define MX_SOFT_BAUD_3	SW_115200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 115200 Not Available At This Clock Speed"
			#endif
		#endif
		#ifndef MX_SOFT_BAUD_3
			#error "UART Baud Rate not supported in Software Mode"
		#endif
	#else
		#define MX_SOFT_BAUD_3	1
		#define MX_HARD_BAUD_3	(((MX_CLK_SPEED / MX_UART_BAUD_3) - 16) / 16)
		#define MX_HARD_SLOW_3	0

		#if (MX_HARD_BAUD_3 > 255)
			#undef MX_HARD_BAUD_3
			#undef MX_HARD_SLOW_3
			#define MX_HARD_BAUD_3	(((MX_CLK_SPEED / MX_UART_BAUD_3) - 16)	/ 64)
			#define MX_HARD_SLOW_3	1
		#endif
	#endif
 #endif
 #if defined(MX_UART_CHANNEL_4) && (MX_UART_NUM==4)
	#if (MX_UART_CHANNEL_4 == 0)
		#if (MX_UART_BAUD_4 == 1200)
			#define MX_SOFT_BAUD_4	SW_1200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 1200 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_4 == 2400)
			#define MX_SOFT_BAUD_4	SW_2400_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 2400 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_4 == 4800)
			#define MX_SOFT_BAUD_4	SW_4800_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 4800 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_4 == 9600)
			#define MX_SOFT_BAUD_4	SW_9600_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 9600 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_4 == 19200)
			#define MX_SOFT_BAUD_4	SW_19200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 19200 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_4 == 31250)
			#define MX_SOFT_BAUD_4	SW_31250_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 31250 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_4 == 115200)
			#define MX_SOFT_BAUD_4	SW_115200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 115200 Not Available At This Clock Speed"
			#endif
		#endif
		#ifndef MX_SOFT_BAUD_4
			#error "UART Baud Rate not supported in Software Mode"
		#endif
	#else
		#define MX_SOFT_BAUD_4	1
		#define MX_HARD_BAUD_4	(((MX_CLK_SPEED / MX_UART_BAUD_4) - 16) / 16)
		#define MX_HARD_SLOW_4	0

		#if (MX_HARD_BAUD_4 > 255)
			#undef MX_HARD_BAUD_4
			#undef MX_HARD_SLOW_4
			#define MX_HARD_BAUD_4	(((MX_CLK_SPEED / MX_UART_BAUD_4) - 16)	/ 64)
			#define MX_HARD_SLOW_4	1
		#endif
	#endif
 #endif


//Hardware Baud update definitions
#ifndef MX_HARD_BAUD_CHANGE_DEFS
	#define MX_HARD_BAUD_CHANGE_DEFS

	#define MX_HARD_BAUD_1200	(((MX_CLK_SPEED / 1200) - 16) / 16)
	#if (MX_HARD_BAUD_1200 > 255)
		#undef MX_HARD_BAUD_1200
		#define MX_HARD_BAUD_1200	(((MX_CLK_SPEED / 1200) - 16) / 64)
		#define MX_HARD_SLOW_1200	1
	#else
		#define MX_HARD_SLOW_1200	0
	#endif

	#define MX_HARD_BAUD_2400	(((MX_CLK_SPEED / 2400) - 16) / 16)
	#if (MX_HARD_BAUD_2400 > 255)
		#undef MX_HARD_BAUD_2400
		#define MX_HARD_BAUD_2400	(((MX_CLK_SPEED / 2400) - 16) / 64)
		#define MX_HARD_SLOW_2400	1
	#else
		#define MX_HARD_SLOW_2400	0
	#endif

	#define MX_HARD_BAUD_4800	(((MX_CLK_SPEED / 4800) - 16) / 16)
	#if (MX_HARD_BAUD_4800 > 255)
		#undef MX_HARD_BAUD_4800
		#define MX_HARD_BAUD_4800	(((MX_CLK_SPEED / 4800) - 16) / 64)
		#define MX_HARD_SLOW_4800	1
	#else
		#define MX_HARD_SLOW_4800	0
	#endif

	#define MX_HARD_BAUD_9600	(((MX_CLK_SPEED / 9600) - 16) / 16)
	#if (MX_HARD_BAUD_9600 > 255)
		#undef MX_HARD_BAUD_9600
		#define MX_HARD_BAUD_9600	(((MX_CLK_SPEED / 9600) - 16) / 64)
		#define MX_HARD_SLOW_9600	1
	#else
		#define MX_HARD_SLOW_9600	0
	#endif

	#define MX_HARD_BAUD_19200	(((MX_CLK_SPEED / 19200) - 16) / 16)
	#if (MX_HARD_BAUD_19200 > 255)
		#undef MX_HARD_BAUD_19200
		#define MX_HARD_BAUD_19200	(((MX_CLK_SPEED / 19200) - 16) / 64)
		#define MX_HARD_SLOW_19200	1
	#else
		#define MX_HARD_SLOW_19200	0
	#endif

	#define MX_HARD_BAUD_38400	(((MX_CLK_SPEED / 38400) - 16) / 16)
	#if (MX_HARD_BAUD_38400 > 255)
		#undef MX_HARD_BAUD_38400
		#define MX_HARD_BAUD_38400	(((MX_CLK_SPEED / 38400) - 16) / 64)
		#define MX_HARD_SLOW_38400	1
	#else
		#define MX_HARD_SLOW_38400	0
	#endif

	#define MX_HARD_BAUD_57600	(((MX_CLK_SPEED / 57600) - 16) / 16)
	#if (MX_HARD_BAUD_57600 > 255)
		#undef MX_HARD_BAUD_57600
		#define MX_HARD_BAUD_57600	(((MX_CLK_SPEED / 57600) - 16) / 64)
		#define MX_HARD_SLOW_57600	1
	#else
		#define MX_HARD_SLOW_57600	0
	#endif

	#define MX_HARD_BAUD_115200	(((MX_CLK_SPEED / 115200) - 16) / 16)
	#if (MX_HARD_BAUD_115200 > 255)
		#undef MX_HARD_BAUD_115200
		#define MX_HARD_BAUD_115200	(((MX_CLK_SPEED / 115200) - 16) / 64)
		#define MX_HARD_SLOW_115200	1
	#else
		#define MX_HARD_SLOW_115200	0
	#endif
#endif


//Dynamic function naming based on defines and index number
#define MX_UART_CHANNEL_X	CAL_APPEND(MX_UART_CHANNEL_, MX_UART_NUM)
#define MX_UART_TX_PIN_X	CAL_APPEND(MX_UART_TX_PIN_, MX_UART_NUM)
#define MX_UART_TX_PORT_X	CAL_APPEND(MX_UART_TX_PORT_, MX_UART_NUM)
#define MX_UART_TX_TRIS_X	CAL_APPEND(MX_UART_TX_TRIS_, MX_UART_NUM)
#define MX_UART_RX_PIN_X	CAL_APPEND(MX_UART_RX_PIN_, MX_UART_NUM)
#define MX_UART_RX_PORT_X	CAL_APPEND(MX_UART_RX_PORT_, MX_UART_NUM)
#define MX_UART_RX_TRIS_X	CAL_APPEND(MX_UART_RX_TRIS_, MX_UART_NUM)
#define MX_UART_FLOWEN_X	CAL_APPEND(MX_UART_FLOWEN_, MX_UART_NUM)
#define MX_UART_CTS_PIN_X	CAL_APPEND(MX_UART_CTS_PIN_, MX_UART_NUM)
#define MX_UART_CTS_PORT_X	CAL_APPEND(MX_UART_CTS_PORT_, MX_UART_NUM)
#define MX_UART_CTS_TRIS_X	CAL_APPEND(MX_UART_CTS_TRIS_, MX_UART_NUM)
#define MX_UART_RTS_PIN_X	CAL_APPEND(MX_UART_RTS_PIN_, MX_UART_NUM)
#define MX_UART_RTS_PORT_X	CAL_APPEND(MX_UART_RTS_PORT_, MX_UART_NUM)
#define MX_UART_RTS_TRIS_X	CAL_APPEND(MX_UART_RTS_TRIS_, MX_UART_NUM)
#define MX_UART_DBITS_X		CAL_APPEND(MX_UART_DBITS_, MX_UART_NUM)
#define MX_UART_RETURN_X	CAL_APPEND(MX_UART_RETURN_, MX_UART_NUM)
#define MX_UART_ECHO_X		CAL_APPEND(MX_UART_ECHO_, MX_UART_NUM)
#define MX_UART_INT_X		CAL_APPEND(MX_UART_INT_, MX_UART_NUM)
#define MX_UART_BAUD_X		CAL_APPEND(MX_HARD_BAUD_, MX_UART_NUM)
#define MX_SOFT_BAUD_X		CAL_APPEND(MX_SOFT_BAUD_, MX_UART_NUM)
#define MX_HARD_SLOW_X		CAL_APPEND(MX_HARD_SLOW_, MX_UART_NUM)

#define UART_Delay_CAL		CAL_APPEND(FC_CAL_UART_Delay_, MX_UART_NUM)
#define UART_Send			CAL_APPEND(FC_CAL_UART_Send_, MX_UART_NUM)
#define UART_Uninit			CAL_APPEND(FC_CAL_UART_Uninit_, MX_UART_NUM)


//Component Definitions
#define UART_STATUS_LOOP	0
#define UART_STATUS_TIMEOUT	1
#define UART_STATUS_RXBYTE	2


//Interrupt Definitions
#ifdef MX_UART_2_PIE4
  #define MX_UART2_PIE pie4
  #define MX_UART2_PIR pir4
  #define MX_UART2_TXSTA tx2sta
  #define MX_UART2_RCSTA rc2sta
  #define MX_UART2_TXREG tx2reg
  #define MX_UART2_RCREG rc2reg
#else
  #define MX_UART2_PIE pie3
  #define MX_UART2_PIR pir3
  #define MX_UART2_TXSTA txsta2
  #define MX_UART2_RCSTA rcsta2
  #define MX_UART2_TXREG txreg2
  #define MX_UART2_RCREG rcreg2
#endif

#if (MX_UART_INT_X == 1)

	#ifndef MX_UART_INT_DEFS
	#define MX_UART_INT_DEFS

		#define MX_UART_INT_CH1_FUNC
		#define MX_UART_INT_CH2_FUNC
		#define MX_UART_INT_FUNC_END

		#define MX_UART_INT_CH1_DET		ts_bit(pir1, RCIF) && ts_bit(pie1, RCIE)
		#define MX_UART_INT_CH2_DET		ts_bit(MX_UART2_PIR, RC2IF) && ts_bit(MX_UART2_PIE, RC2IE)

		#define MX_UART_INT_CH1_EN		st_bit (pie1, RCIE)
		#define MX_UART_INT_CH2_EN		st_bit (MX_UART2_PIE, RC2IE)

		#define MX_UART_INT_CH1_DIS		cr_bit (pie1, RCIE)
		#define MX_UART_INT_CH2_DIS		cr_bit (MX_UART2_PIE, RC2IE)

		#define MX_UART_INT_CH1_CLR		cr_bit (pir1, RCIF)
		#define MX_UART_INT_CH2_CLR		cr_bit (MX_UART2_PIR, RC2IF)

	#endif
#endif


//Function Prototypes
CALFUNCTION(void, FC_CAL_UART_Init_, (void));
CALFUNCTION(void, FC_CAL_UART_Uninit_, (void));
CALFUNCTION(void, FC_CAL_UART_Send_, (MX_UINT16 nChar));
CALFUNCTION(MX_SINT16, FC_CAL_UART_Receive_, (MX_UINT8 nTimeout));
CALFUNCTION(void, FC_CAL_UART_Delay_, (void));


//Peripheral Functions
CALFUNCTION(void, FC_CAL_UART_Init_, (void))

{

	#if (MX_UART_CHANNEL_X == 0)
		FC_CAL_Bit_In_DDR 	(MX_UART_RX_PORT_X, MX_UART_RX_TRIS_X, MX_UART_RX_PIN_X);		// Receive pin is a input
		FC_CAL_Bit_High_DDR (MX_UART_TX_PORT_X, MX_UART_TX_TRIS_X, MX_UART_TX_PIN_X);		// Transmit pin is default high
	#endif

	#if (MX_UART_CHANNEL_X == 1)
	  #ifndef MX_UART_1
	  	  #error "UART channel 1 not available on this device"
	  #else
		  #if (MX_HARD_SLOW_X == 1)
			cr_bit(txsta, BRGH);						//Low Speed
		  #else
			st_bit(txsta, BRGH);						//High Speed
0161  1683  	BSF STATUS, RP0
0162  1303  	BCF STATUS, RP1
0163  1518  	BSF gbl_txsta,2

		  #endif
			spbrg = MX_UART_BAUD_X;   					// set the baud rate
0164  3019  	MOVLW 0x19
0165  0099  	MOVWF gbl_spbrg

			rcsta = 0;                    				// 8-bit, disabled
0166  1283  	BCF STATUS, RP0
0167  0198  	CLRF gbl_rcsta


			#if(MX_UART_DBITS_X == 9)
				st_bit(txsta, TX9);   					// 9-bit TX
				st_bit(rcsta, RX9);                    	// 9-bit RX
			#endif

			st_bit(rcsta, SPEN);         				// turn on serial interface
0168  1798  	BSF gbl_rcsta,7

			st_bit(txsta, TXEN);
0169  1683  	BSF STATUS, RP0
016A  1698  	BSF gbl_txsta,5

			st_bit(rcsta, CREN);
016B  1283  	BCF STATUS, RP0
016C  1618  	BSF gbl_rcsta,4


			#if (MX_UART_INT_X == 1)
				MX_UART_INT_CH1_EN;
				st_bit(intcon, PEIE);
				st_bit(intcon, GIE);
			#else
				cr_bit (pie1, RCIE);
016D  1683  	BSF STATUS, RP0
016E  128C  	BCF gbl_pie1,5

			#endif
	  #endif
	#endif


	#if (MX_UART_CHANNEL_X == 2)

	  #ifndef MX_UART_2
		  #error "UART channel 2 not available on this device"
	  #else
		  #ifdef MX_UART_2_REMAPPABLE
			RPOR9 = 5;									//TX2 - RP9 - RB6
			RPINR16	= 10;								//RX2 - RP10 - RB7
		  #endif
		  #if (MX_HARD_SLOW_X == 1)
			cr_bit(MX_UART2_TXSTA, BRGH);						//Low Speed
		  #else
			st_bit(MX_UART2_TXSTA, BRGH);						//High Speed
		  #endif
			spbrg2 = MX_UART_BAUD_X;   				// set the baud rate
			MX_UART2_RCSTA = 0;                    				// 8-bit, disabled

			#if(MX_UART_DBITS_X == 9)
				st_bit(MX_UART2_TXSTA, TX9);   					// 9-bit TX
				st_bit(MX_UART2_RCSTA, RX9);                    // 9-bit RX
			#endif

			st_bit(MX_UART2_RCSTA, SPEN);         				// turn on serial interface
			st_bit(MX_UART2_TXSTA, TXEN);
			st_bit(MX_UART2_RCSTA, CREN);

			#if (MX_UART_INT_X == 1)
				MX_UART_INT_CH2_EN;
				st_bit(intcon, PEIE);
				st_bit(intcon, GIE);
			#else
				cr_bit (MX_UART2_PIE, RC2IE);
			#endif
	  #endif
	#endif

	#if (MX_UART_FLOWEN_X == 1)						//Flowcontrol enabled?
		FC_CAL_Bit_In_DDR (MX_UART_CTS_PORT_X, MX_UART_CTS_TRIS_X, MX_UART_CTS_PIN_X);	// CTS pin is a input
		FC_CAL_Bit_High_DDR (MX_UART_RTS_PORT_X, MX_UART_RTS_TRIS_X, MX_UART_RTS_PIN_X);	// RTS not ready to accept data
	#endif

}
016F  0008  	RETURN




CALFUNCTION(void, FC_CAL_UART_Uninit_, (void))
{

	#if (MX_UART_CHANNEL_X == 0)
		FC_CAL_Bit_In_DDR (MX_UART_RX_PORT_X, MX_UART_RX_TRIS_X, MX_UART_RX_PIN_X);		// Receive pin is a input
		FC_CAL_Bit_In_DDR (MX_UART_TX_PORT_X, MX_UART_TX_TRIS_X, MX_UART_TX_PIN_X);		// Transmit pin is default high
	#endif

	#if (MX_UART_CHANNEL_X == 1)
			rcsta = 0;                    								// 8-bit, disabled
			txsta = 0;
		  #ifdef MX_UART_RXINT
			MX_UART_INT_CH1_DIS;
		  #endif
	#endif

	#if (MX_UART_CHANNEL_X == 2)
			MX_UART2_RCSTA = 0;                    								// 8-bit, disabled
			MX_UART2_TXSTA = 0;
		  #ifdef MX_UART_RXINT
			MX_UART_INT_CH2_DIS;
		  #endif
	#endif

	#if (MX_UART_FLOWEN_X == 1)										//Flowcontrol enabled?
		FC_CAL_Bit_In_DDR (MX_UART_CTS_PORT_X, MX_UART_CTS_TRIS_X, MX_UART_CTS_PIN_X);		// CTS pin is a input
		FC_CAL_Bit_In_DDR (MX_UART_RTS_PORT_X, MX_UART_RTS_TRIS_X, MX_UART_RTS_PIN_X);		// RTS not ready to accept data
	#endif
}



CALFUNCTION(void, FC_CAL_UART_Send_, (MX_UINT16 nChar))

{
	#if (MX_UART_FLOWEN_X == 1)
		while (FC_CAL_Bit_In(MX_UART_CTS_PORT_X, MX_UART_CTS_PIN_X) != 0);	// Wait until CTS is low
	#endif

	#if (MX_UART_CHANNEL_X == 0)													// Software UART TX
		MX_UINT8 idx;
		FC_CAL_Bit_Low(MX_UART_TX_PORT_X, MX_UART_TX_PIN_X);					// Send Start bit
		UART_Delay_CAL();
		for (idx = 0; idx < MX_UART_DBITS_X; idx++)
		{
			if (nChar & 0x01)														// Mask off data bit
				FC_CAL_Bit_High(MX_UART_TX_PORT_X, MX_UART_TX_PIN_X);
			else
				FC_CAL_Bit_Low(MX_UART_TX_PORT_X, MX_UART_TX_PIN_X);
			UART_Delay_CAL();
			nChar = nChar >> 1;														// Move to next data bit
		}
		FC_CAL_Bit_High(MX_UART_TX_PORT_X, MX_UART_TX_PIN_X);					// Send Stop bit
		UART_Delay_CAL();
	#endif

	#if (MX_UART_CHANNEL_X == 1)
		while (ts_bit(pir1, TXIF) == 0);
0066        label9
0066  1E0C  	BTFSS gbl_pir1,4
0067  2866  	GOTO	label9


		#if (MX_UART_DBITS_X == 9)
			if (test_bit(nChar, 8))
				st_bit(txsta, TX9D);
			else
				cr_bit(txsta, TX9D);
	  	#endif
		txreg = nChar;
0068  0856  	MOVF FC_CAL_UAR_00057_arg_nChar, W
0069  0099  	MOVWF gbl_txreg

	#endif

	#if (MX_UART_CHANNEL_X == 2)
		while (ts_bit(pir3, TX2IF) == 0);

		#if (MX_UART_DBITS_X == 9)
			if (test_bit(nChar, 8))
				st_bit(MX_UART2_TXSTA, TX9D);
			else
				cr_bit(MX_UART2_TXSTA, TX9D);
		#endif
		MX_UART2_TXREG = nChar;
	#endif
}
006A  0008  	RETURN



CALFUNCTION(MX_SINT16, FC_CAL_UART_Receive_, (MX_UINT8 nTimeout))

{
  #if (MX_UART_RETURN_X == 1)
	MX_UINT16 retVal = 512;
  #else
  	MX_UINT8 retVal = 255;
001A  30FF  	MOVLW 0xFF
001B  00D6  	MOVWF FC_CAL_UAR_00058_1_retVal

  #endif

	MX_UINT8 delay1 = 0;
001C  01D7  	CLRF FC_CAL_UAR_00058_1_delay1

	MX_UINT8 regcheck = 0;
001D  01D8  	CLRF FC_CAL_UAR_00058_1_regcheck

	MX_UINT8 bWaitForever = 0;
001E  01D9  	CLRF FC_CAL_UAR_00058_1_bWaitForever

	MX_UINT8 rxStatus = UART_STATUS_LOOP;
001F  01DA  	CLRF FC_CAL_UAR_00058_1_rxStatus


  #if (MX_UART_CHANNEL_X == 0)
  	MX_UINT8 idx;
  #else
  	MX_UINT8 dummy = 0;
0020  01DB  	CLRF FC_CAL_UAR_00058_1_dummy

  #endif

	if (nTimeout == 255)
0021  0A55  	INCF FC_CAL_UAR_00058_arg_nTimeout, W
0022  1D03  	BTFSS STATUS,Z
0023  2826  	GOTO	label2
0026        label2

		bWaitForever = 1;
0024  3001  	MOVLW 0x01
0025  00D9  	MOVWF FC_CAL_UAR_00058_1_bWaitForever


	#if (MX_UART_FLOWEN_X == 1)
		FC_CAL_Bit_Low (MX_UART_RTS_PORT_X, MX_UART_RTS_PIN_X);			// Ready to accept data
	#endif

	while (rxStatus == UART_STATUS_LOOP)
0026  08DA  	MOVF FC_CAL_UAR_00058_1_rxStatus, F
0027  1D03  	BTFSS STATUS,Z
0028  2848  	GOTO	label5
0047  2826  	GOTO	label2
0048        label5

	{
		if (bWaitForever == 0)
0029  08D9  	MOVF FC_CAL_UAR_00058_1_bWaitForever, F
002A  1D03  	BTFSS STATUS,Z
002B  283F  	GOTO	label4

		{
			if (nTimeout == 0)							//don't wait forever, so do timeout thing...
002C  08D5  	MOVF FC_CAL_UAR_00058_arg_nTimeout, F
002D  1D03  	BTFSS STATUS,Z
002E  2832  	GOTO	label3
0032        label3

			{
				rxStatus = UART_STATUS_TIMEOUT;
002F  3001  	MOVLW 0x01
0030  00DA  	MOVWF FC_CAL_UAR_00058_1_rxStatus

			}
			else
0031  283F  	GOTO	label4

			{
				delay_us(10);
0032  300A  	MOVLW 0x0A
0033  00DC  	MOVWF delay_us_00000_arg_del
0034  2010  	CALL delay_us_00000

				delay1 = delay1 + 1;
0035  0A57  	INCF FC_CAL_UAR_00058_1_delay1, W
0036  00D7  	MOVWF FC_CAL_UAR_00058_1_delay1

				if(delay1 == 100)
0037  0857  	MOVF FC_CAL_UAR_00058_1_delay1, W
0038  3A64  	XORLW 0x64
0039  1D03  	BTFSS STATUS,Z
003A  283F  	GOTO	label4
003F        label4

				{
					nTimeout = nTimeout - 1;
003B  0355  	DECF FC_CAL_UAR_00058_arg_nTimeout, W
003C  00D5  	MOVWF FC_CAL_UAR_00058_arg_nTimeout

					MX_CLEAR_WATCHDOG;
003D  0064  	CLRWDT

					delay1 = 0;
003E  01D7  	CLRF FC_CAL_UAR_00058_1_delay1

				}
			}
		}

		#if (MX_UART_CHANNEL_X == 0)
			regcheck = FC_CAL_Bit_In(MX_UART_RX_PORT_1, MX_UART_RX_PIN_1);	//Test for start bit
			if (regcheck == 0)
				rxStatus = UART_STATUS_RXBYTE;
		#endif

		#if (MX_UART_CHANNEL_X == 1)
			regcheck = ts_bit(pir1, RCIF);
003F  3020  	MOVLW 0x20
0040  050C  	ANDWF gbl_pir1, W
0041  00D8  	MOVWF FC_CAL_UAR_00058_1_regcheck

			if (regcheck != 0)
0042  08D8  	MOVF FC_CAL_UAR_00058_1_regcheck, F
0043  1903  	BTFSC STATUS,Z
0044  2826  	GOTO	label2

				rxStatus = UART_STATUS_RXBYTE;
0045  3002  	MOVLW 0x02
0046  00DA  	MOVWF FC_CAL_UAR_00058_1_rxStatus

		#endif

		#if (MX_UART_CHANNEL_X == 2)
			regcheck = ts_bit(MX_UART2_PIR, RC2IF);
			if (regcheck != 0)
				rxStatus = UART_STATUS_RXBYTE;
		#endif

	}

	if (rxStatus == UART_STATUS_RXBYTE)
0048  085A  	MOVF FC_CAL_UAR_00058_1_rxStatus, W
0049  3A02  	XORLW 0x02
004A  1D03  	BTFSS STATUS,Z
004B  2862  	GOTO	label8

	{
		#if (MX_UART_CHANNEL_X == 0)

			retVal = 0;
			UART_Delay_CAL();

			for (idx = 0; idx < MX_UART_DBITS_X; idx++)
			{
				if (FC_CAL_Bit_In(MX_UART_RX_PORT_X, MX_UART_RX_PIN_X))
					retVal = retVal | (0x01 << idx);

				UART_Delay_CAL();
			}
		#endif

		#if (MX_UART_CHANNEL_X == 1)
			regcheck = ts_bit(rcsta, FERR);
004C  3004  	MOVLW 0x04
004D  0518  	ANDWF gbl_rcsta, W
004E  00D8  	MOVWF FC_CAL_UAR_00058_1_regcheck

			if (regcheck != 0)
004F  08D8  	MOVF FC_CAL_UAR_00058_1_regcheck, F
0050  1903  	BTFSC STATUS,Z
0051  2855  	GOTO	label6
0055        label6

			{
				dummy = rcreg;						//need to read the rcreg to clear FERR
0052  081A  	MOVF gbl_rcreg, W
0053  00DB  	MOVWF FC_CAL_UAR_00058_1_dummy

				#if (MX_UART_RETURN_X == 1)
					retVal = 0x400;					//Framing Error Flag
				#endif
			}
			else
0054  2862  	GOTO	label8

			{
				regcheck = ts_bit(rcsta, OERR);
0055  3002  	MOVLW 0x02
0056  0518  	ANDWF gbl_rcsta, W
0057  00D8  	MOVWF FC_CAL_UAR_00058_1_regcheck

				if (regcheck != 0)
0058  08D8  	MOVF FC_CAL_UAR_00058_1_regcheck, F
0059  1903  	BTFSC STATUS,Z
005A  285E  	GOTO	label7
005E        label7

				{
					cr_bit(rcsta, CREN);			//Reset receiver to clear error
005B  1218  	BCF gbl_rcsta,4

					st_bit(rcsta, CREN);
005C  1618  	BSF gbl_rcsta,4


					#if (MX_UART_RETURN_X == 1)
						retVal = 0x800;				//Overrun Error Flag
					#endif
				}
				else
005D  2862  	GOTO	label8
0062        label8

				{
					retVal = 0;
005E  01D6  	CLRF FC_CAL_UAR_00058_1_retVal


					#if (MX_UART_DBITS_X == 9)
						if(ts_bit(rcsta, RX9D))
							retVal = 0x100;
					#endif

					retVal = retVal | rcreg; 			//no error, so rx byte is valid
005F  081A  	MOVF gbl_rcreg, W
0060  0456  	IORWF FC_CAL_UAR_00058_1_retVal, W
0061  00D6  	MOVWF FC_CAL_UAR_00058_1_retVal

				}
			}
		#endif

		#if (MX_UART_CHANNEL_X == 2)
			regcheck = ts_bit(MX_UART2_RCSTA, FERR);
			if (regcheck != 0)
			{
				dummy = MX_UART2_RCREG;			//need to read the rcreg to clear FERR
				#if (MX_UART_RETURN_X == 1)
					retVal = 0x400;					//Framing Error Flag
				#endif
			}
			else
			{
				regcheck = ts_bit(MX_UART2_RCSTA, OERR);
				if (regcheck != 0)
				{
					cr_bit(MX_UART2_RCSTA, CREN);	//Reset receiver to clear error
					st_bit(MX_UART2_RCSTA, CREN);
					#if (MX_UART_RETURN_X == 1)
						retVal = 0x800;				//Overrun Error Flag
					#endif
				}
				else
				{
					retVal = 0;

					#if (MX_UART_DBITS_X == 9)
						if(ts_bit(MX_UART2_RCSTA, RX9D))
							retVal = 0x100;
					#endif

					retVal = retVal | MX_UART2_RCREG; 			//no error, so rx byte is valid
				}
			}

		#endif

		#if (MX_UART_ECHO_X == 1)
			UART_Send(retVal);
		#endif
	}

	#if (MX_UART_FLOWEN_X == 1)
		FC_CAL_Bit_High(MX_UART_RTS_PORT_X, MX_UART_RTS_PIN_X);		//not ready to accept data
	#endif

	return (retVal);
0062  0856  	MOVF FC_CAL_UAR_00058_1_retVal, W
0063  00DC  	MOVWF CompTempVarRet2204
0064  01DD  	CLRF CompTempVarRet2204+D'1'

}
0065  0008  	RETURN



CALFUNCTION(void, FC_CAL_UART_Delay_, (void))
{
  #if (MX_UART_CHANNEL_X == 0)

	MX_UINT16 delay = MX_SOFT_BAUD_X;

	while (delay > 255)
	{
		delay_us(255);
		delay = delay - 255;
		MX_CLEAR_WATCHDOG;
	}
	delay_us(delay);
	MX_CLEAR_WATCHDOG;

  #endif
}


CALFUNCTION(void, FC_CAL_UART_Update_Baud_, (MX_UINT8 new_baud))
{
	//Baud Rates - Function compatible with hardware mode only
	/*
	0 - 1200
	1 - 2400
	2 - 4800
	3 - 9600
	4 - 19200
	5 - 38400
	6 - 57600
	7 - 115200
	*/

	MX_UINT8 baudrate, baudmode;

	if (new_baud > 7)
		return;

	if (new_baud == 0)
	{
		baudrate = MX_HARD_BAUD_1200;
		baudmode = MX_HARD_SLOW_1200;
	}
	else if (new_baud == 1)
	{
		baudrate = MX_HARD_BAUD_2400;
		baudmode = MX_HARD_SLOW_2400;
	}
	else if (new_baud == 2)
	{
		baudrate = MX_HARD_BAUD_4800;
		baudmode = MX_HARD_SLOW_4800;
	}
	else if (new_baud == 3)
	{
		baudrate = MX_HARD_BAUD_9600;
		baudmode = MX_HARD_SLOW_9600;
	}
	else if (new_baud == 4)
	{
		baudrate = MX_HARD_BAUD_19200;
		baudmode = MX_HARD_SLOW_19200;
	}
	else if (new_baud == 5)
	{
		baudrate = MX_HARD_BAUD_38400;
		baudmode = MX_HARD_SLOW_38400;
	}
	else if (new_baud == 6)
	{
		baudrate = MX_HARD_BAUD_57600;
		baudmode = MX_HARD_SLOW_57600;
	}
	else if (new_baud == 7)
	{
		baudrate = MX_HARD_BAUD_115200;
		baudmode = MX_HARD_SLOW_115200;
	}

	UART_Uninit();

	#if (MX_UART_CHANNEL_X == 1)

	    if (baudmode == 1)
			cr_bit(txsta, BRGH);					//Low Speed
	    else
			st_bit(txsta, BRGH);					//High Speed

		spbrg = baudrate;   						// set the baud rate
		rcsta = 0;                    				// 8-bit, disabled

		#if(MX_UART_DBITS_X == 9)
			st_bit(txsta, TX9);   					// 9-bit TX
			st_bit(rcsta, RX9);                    	// 9-bit RX
		#endif

		st_bit(rcsta, SPEN);         				// turn on serial interface
		st_bit(txsta, TXEN);
		st_bit(rcsta, CREN);

		#if (MX_UART_INT_X == 1)
			MX_UART_INT_CH1_EN;
			st_bit(intcon, PEIE);
			st_bit(intcon, GIE);
		#else
			cr_bit (pie1, RCIE);
		#endif
	#endif

	#if (MX_UART_CHANNEL_X == 2)

	  	if (baudmode == 1)
			cr_bit(MX_UART2_TXSTA, BRGH);			//Low Speed
	  	else
			st_bit(MX_UART2_TXSTA, BRGH);			//High Speed

		spbrg2 = baudrate;   						// set the baud rate
		MX_UART2_RCSTA = 0;                    		// 8-bit, disabled

		#if(MX_UART_DBITS_X == 9)
			st_bit(MX_UART2_TXSTA, TX9);   			// 9-bit TX
			st_bit(MX_UART2_RCSTA, RX9);            // 9-bit RX
		#endif

		st_bit(MX_UART2_RCSTA, SPEN);         		// turn on serial interface
		st_bit(MX_UART2_TXSTA, TXEN);
		st_bit(MX_UART2_RCSTA, CREN);

		#if (MX_UART_INT_X == 1)
			MX_UART_INT_CH2_EN;
			st_bit(intcon, PEIE);
			st_bit(intcon, GIE);
		#else
			cr_bit (MX_UART2_PIE, RC2IE);
		#endif
	#endif

	#if (MX_UART_FLOWEN_X == 1)						//Flowcontrol enabled?
		FC_CAL_Bit_In_DDR (MX_UART_CTS_PORT_X, MX_UART_CTS_TRIS_X, MX_UART_CTS_PIN_X);	// CTS pin is a input
		FC_CAL_Bit_High_DDR (MX_UART_RTS_PORT_X, MX_UART_RTS_TRIS_X, MX_UART_RTS_PIN_X);	// RTS not ready to accept data
	#endif

}

////////////////////////////////////////
// Code with no source :-)
////////////////////////////////////////
0000  29BE  	GOTO	_startup

0004  00FF  	MOVWF Int1Context
0005  0E03  	SWAPF STATUS, W
0006  1283  	BCF STATUS, RP0
0007  1303  	BCF STATUS, RP1
0008  00B9  	MOVWF Int1BContext
0009  0E0A  	SWAPF PCLATH, W
000A  00BA  	MOVWF Int1BContext+D'1'
000B  0E04  	SWAPF FSR, W
000C  00BB  	MOVWF Int1BContext+D'2'
000D  118A  	BCF PCLATH,3
000E  120A  	BCF PCLATH,4
000F  29ED  	GOTO	interrupt
0010        delay_us_00000
0010        ; { delay_us ; function begin
0010  3003  	MOVLW 0x03
0011  07DC  	ADDWF delay_us_00000_arg_del, F
0012  0CDC  	RRF delay_us_00000_arg_del, F
0013  0CDC  	RRF delay_us_00000_arg_del, F
0014  307F  	MOVLW 0x7F
0015  05DC  	ANDWF delay_us_00000_arg_del, F
0016        label1
0016  0000  	NOP
0017  0BDC  	DECFSZ delay_us_00000_arg_del, F
0018  2816  	GOTO	label1
0019  0008  	RETURN
001A        ; } delay_us function end


01BE        _startup
01BE  30D5  	MOVLW 0xD5
01BF  1283  	BCF STATUS, RP0
01C0  1303  	BCF STATUS, RP1
01C1  00A5  	MOVWF gbl_14_LSR
01C2  30C4  	MOVLW 0xC4
01C3  00A6  	MOVWF gbl_14_LSR+D'1'
01C4  30BB  	MOVLW 0xBB
01C5  00A7  	MOVWF gbl_14_LSR+D'2'
01C6  30DC  	MOVLW 0xDC
01C7  00A8  	MOVWF gbl_14_LSR+D'3'
01C8  01A9  	CLRF gbl_15_gbl_aSig
01C9  01AA  	CLRF gbl_15_gbl_aSig+D'1'
01CA  01AB  	CLRF gbl_15_gbl_aSig+D'2'
01CB  01AC  	CLRF gbl_15_gbl_aSig+D'3'
01CC  01AD  	CLRF gbl_15_gbl_bSig
01CD  01AE  	CLRF gbl_15_gbl_bSig+D'1'
01CE  01AF  	CLRF gbl_15_gbl_bSig+D'2'
01CF  01B0  	CLRF gbl_15_gbl_bSig+D'3'
01D0  01B1  	CLRF gbl_15_gbl_zSig
01D1  01B2  	CLRF gbl_15_gbl_zSig+D'1'
01D2  01B3  	CLRF gbl_15_gbl_zSig+D'2'
01D3  01B4  	CLRF gbl_15_gbl_zSig+D'3'
01D4  01C1  	CLRF gbl_15_gbl_aExp
01D5  01C2  	CLRF gbl_15_gbl_bExp
01D6  01BC  	CLRF gbl_15_gbl_zExp
01D7  01BD  	CLRF gbl_15_gbl_zExp+D'1'
01D8  01C3  	CLRF gbl_15_gbl_aSign
01D9  01C4  	CLRF gbl_15_gbl_bSign
01DA  01C5  	CLRF gbl_15_gbl_zSign
01DB  01C6  	CLRF gbl_15_gbl_zSigZero
01DC  01B5  	CLRF gbl_15_gbl_ret
01DD  01B6  	CLRF gbl_15_gbl_ret+D'1'
01DE  01B7  	CLRF gbl_15_gbl_ret+D'2'
01DF  01B8  	CLRF gbl_15_gbl_ret+D'3'
01E0  01BF  	CLRF gbl_float_rounding_mode
01E1  01C0  	CLRF gbl_float_exception_flags
01E2  01BE  	CLRF gbl_float_detect_tininess

01EA  118A  	BCF PCLATH,3
01EB  120A  	BCF PCLATH,4
01EC  299A  	GOTO	main

2007  30D4  	DW 0x30D4
