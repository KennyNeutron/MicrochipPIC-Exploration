;/////////////////////////////////////////////////////////////////////////////////
;// Code Generator: BoostC Compiler - http://www.sourceboost.com
;// Version       : 7.03
;// License Type  : Pro License
;// Limitations   : PIC12,PIC16 max code size:Unlimited, max RAM banks:Unlimited
;/////////////////////////////////////////////////////////////////////////////////

//************************************************************************************
//**  
//**  File name:     D:\KennyNeutronsInnovations\ScoreBoard\Flowcode\ScoreBoardProgram.c
//**  Title:         
//**  Description:   
//**  
//**  Generated by:  Flowcode v5.2.0.0
//**  Date:          Wednesday, March 06, 2019 01:17:19
//**  Licence:       Professional
//**  Registered to: xyz
//**  Licence key:   WUK7B9
//**  
//**  
//**  http://www.matrixmultimedia.com
//**  
//************************************************************************************


#define MX_PIC

#define MX_USES_UINT8 1
#define MX_USES_SINT16 0
#define MX_USES_CHAR 0
#define MX_USES_FLOAT 0
#define MX_USES_SINT32 0
#define MX_USES_BOOL 1
#define MX_USES_UINT16 0
#define MX_USES_UINT32 0
//Defines for microcontroller
#define P16F887
#define FC_CAL_PIC
#define MX_ADC
#define MX_ADC_TYPE_7
#define MX_ADC_BITS_10
#define MX_EE
#define MX_EE_TYPE2
#define MX_EE_SIZE 256
#define MX_SPI_1
#define MX_SPI_1_MISO_PORT portc
#define MX_SPI_1_MISO_TRIS trisc
#define MX_SPI_1_MISO_PIN 4
#define MX_SPI_1_MOSI_PORT portc
#define MX_SPI_1_MOSI_TRIS trisc
#define MX_SPI_1_MOSI_PIN 5
#define MX_SPI_1_CLK_PORT portc
#define MX_SPI_1_CLK_TRIS trisc
#define MX_SPI_1_CLK_PIN 3
#define MX_SPI_1_SS_PORT portc
#define MX_SPI_1_SS_TRIS trisc
#define MX_UART_1
#define MX_UART_1_TX_PORT portc
#define MX_UART_1_TX_TRIS trisc
#define MX_UART_1_TX_PIN 6
#define MX_UART_1_RX_PORT portc
#define MX_UART_1_RX_TRIS trisc
#define MX_UART_1_RX_PIN 7
#define MX_I2C
#define MX_MI2C
#define MX_I2C_1
#define MX_I2C_1_SDA_PORT portc
#define MX_I2C_1_SDA_TRIS trisc
#define MX_I2C_1_SDA_PIN 4
#define MX_I2C_1_SCL_PORT portc
#define MX_I2C_1_SCL_TRIS trisc
#define MX_I2C_1_SCL_PIN 3
#define MX_PWM
#define MX_PWM_CNT 2
#define MX_PWM_PSCA1
#define MX_PWM_PSCA4
#define MX_PWM_PSCA16
#define MX_PWM_1_PORT portc
#define MX_PWM_1_TRIS trisc
#define MX_PWM_1_PIN 2
#define MX_PWM_2_PORT portc
#define MX_PWM_2_TRIS trisc
#define MX_PWM_2_PIN 1

//Functions
#define MX_CLK_SPEED 20000000
#ifdef _BOOSTC
#include <system.h>
#endif
#ifdef HI_TECH_C
#include <pic.h>
#endif

//Configuration data
#ifdef _BOOSTC
#pragma DATA 0x2007, 0x20c2
#endif
#ifdef HI_TECH_C
__CONFIG(0x20c2);
#endif
#ifdef _BOOSTC
#pragma DATA 0x2008, 0x3eff
#endif
#ifdef HI_TECH_C
__CONFIG(0x3eff);
#endif

//Internal functions
#include "C:\Program Files (x86)\Flowcode\v5\FCD\internals.c"

//Macro function declarations
void FCM_off_all();
void FCM_data_bank();
void FCM_latch();
void FCM_score_data_register();
void FCM_display_score();
void FCM_display_time();
void FCM_time_data_register();
void FCM_foulperiod_data_register();
void FCM_foulperiod_display();


//Variable declarations
#define FCV_TRUE (1)
#define FCV_FALSE (0)
MX_UINT8 FCV_HOME_ONES = (0x0);
03C8  01C2  	CLRF gbl_FCV_HOME_ONES

MX_BOOL FCV_DAT;
MX_UINT8 FCV_SECONDS;
MX_UINT8 FCV_PERIOD = (0x0);
03C9  01C4  	CLRF gbl_FCV_PERIOD

MX_UINT8 FCV_MINUTES = (0x0);
03CA  01C5  	CLRF gbl_FCV_MINUTES

MX_UINT8 FCV_HOME_FOUL = (0x0);
03CB  01C6  	CLRF gbl_FCV_HOME_FOUL

MX_UINT8 FCV_MINUTE_TENS;
MX_UINT8 FCV_AWAY_TENS = (0x0);
03CC  01C8  	CLRF gbl_FCV_AWAY_TENS

MX_UINT8 FCV_BITS = (0x0);
03CD  01C9  	CLRF gbl_FCV_BITS

MX_UINT8 FCV_RX = (0x0);
03CE  01CA  	CLRF gbl_FCV_RX

MX_UINT8 FCV_SECONDS_TENS;
MX_UINT8 FCV_SCORE_AWAY = (0x0);
03CF  01CC  	CLRF gbl_FCV_SCORE_AWAY

MX_UINT8 FCV_DIGIT = (0x0);
03D0  01CD  	CLRF gbl_FCV_DIGIT

MX_BOOL FCV_HOME_HUNDRED = (0);
03D1  10C3  	BCF gbl_FCV_HOME_HUNDRED,1

MX_UINT8 FCV_MINUTE_ONES;
MX_UINT8 FCV_AWAY_ONES;
MX_UINT8 FCV_HOME_TENS = (0x0);
03D2  01D0  	CLRF gbl_FCV_HOME_TENS

MX_BOOL FCV_FLAG = (0);
03D3  1143  	BCF gbl_FCV_FLAG,2

MX_UINT8 FCV_SECONDS_ONES;
MX_BOOL FCV_AWAY_HUNDREDS = (0);
03D4  11C3  	BCF gbl_FCV_AWAY_HUNDREDS,3

MX_UINT8 FCV_SCORE_HOME = (0x0);
03D5  01D2  	CLRF gbl_FCV_SCORE_HOME

MX_UINT8 FCV_IHAP = (0x0);
03D6  01D3  	CLRF gbl_FCV_IHAP

MX_UINT8 FCV_AWAY_FOUL = (0x0);
03D7  01D4  	CLRF gbl_FCV_AWAY_FOUL


MX_UINT8 FCLV_LOOP1;
MX_UINT8 FCLV_LOOP2;
MX_UINT8 FCLV_LOOP3;



//RS232(0): //Defines:

/**** Macro Substitutions ****
a = Unique Reference
b = Uart Channel		(0-software / 1-4 hardware)
c = tx pin
d = tx port
e = rx pin
f = rx port
g = flow control		(0-Off / 1-On)
h = cts pin
i = cts port
j = rts pin
k = rts port
l = baud rate
m = data bits			(7/8/9) (7 only supported in software modes)
n = return type		(0-byte / 1-MX_UINT16)
o = echo enable		(0-Off / 1-On)
******************************/

//Definitions for RS232 UART slot allocation
#ifndef	MX_UART_REF1
	#define MX_UART_REF1
	#define RS232_1_MX_UART_UREF			1
	#define MX_UART_CHANNEL_1		1
	#define MX_UART_TX_PIN_1		0
	#define MX_UART_TX_PORT_1		porta
	#define MX_UART_TX_TRIS_1		trisa
	#define MX_UART_RX_PIN_1		0
	#define MX_UART_RX_PORT_1		porta
	#define MX_UART_RX_TRIS_1		trisa
	#define MX_UART_FLOWEN_1		0
	#define MX_UART_CTS_PIN_1		4
	#define MX_UART_CTS_PORT_1		portc
	#define MX_UART_CTS_TRIS_1		trisc
	#define MX_UART_RTS_PIN_1		0
	#define MX_UART_RTS_PORT_1		portc
	#define MX_UART_RTS_TRIS_1		trisc
	#define MX_UART_BAUD_1			9600
	#define MX_UART_DBITS_1			8
	#define MX_UART_RETURN_1		0
	#define MX_UART_ECHO_1			0
	#define MX_UART_INT_1			0
#else
 #ifndef	MX_UART_REF2
	#define MX_UART_REF2
	#define RS232_1_MX_UART_UREF			2
	#define MX_UART_CHANNEL_2		1
	#define MX_UART_TX_PIN_2		0
	#define MX_UART_TX_PORT_2		porta
	#define MX_UART_TX_TRIS_2		trisa
	#define MX_UART_RX_PIN_2		0
	#define MX_UART_RX_PORT_2		porta
	#define MX_UART_RX_TRIS_2		trisa
	#define MX_UART_FLOWEN_2		0
	#define MX_UART_CTS_PIN_2		4
	#define MX_UART_CTS_PORT_2		portc
	#define MX_UART_CTS_TRIS_2		trisc
	#define MX_UART_RTS_PIN_2		0
	#define MX_UART_RTS_PORT_2		portc
	#define MX_UART_RTS_TRIS_2		trisc
	#define MX_UART_BAUD_2			9600
	#define MX_UART_DBITS_2			8
	#define MX_UART_RETURN_2		0
	#define MX_UART_ECHO_2			0
	#define MX_UART_INT_2			0
 #else
  #ifndef	MX_UART_REF3
	#define MX_UART_REF3
	#define RS232_1_MX_UART_UREF			3
	#define MX_UART_CHANNEL_3		1
	#define MX_UART_TX_PIN_3		0
	#define MX_UART_TX_PORT_3		porta
	#define MX_UART_TX_TRIS_3		trisa
	#define MX_UART_RX_PIN_3		0
	#define MX_UART_RX_PORT_3		porta
	#define MX_UART_RX_TRIS_3		trisa
	#define MX_UART_FLOWEN_3		0
	#define MX_UART_CTS_PIN_3		4
	#define MX_UART_CTS_PORT_3		portc
	#define MX_UART_CTS_TRIS_3		trisc
	#define MX_UART_RTS_PIN_3		0
	#define MX_UART_RTS_PORT_3		portc
	#define MX_UART_RTS_TRIS_3		trisc
	#define MX_UART_BAUD_3			9600
	#define MX_UART_DBITS_3			8
	#define MX_UART_RETURN_3		0
	#define MX_UART_ECHO_3			0
	#define MX_UART_INT_3			0
  #else
   #ifndef	MX_UART_REF4
	#define MX_UART_REF4
	#define RS232_1_MX_UART_UREF			4
	#define MX_UART_CHANNEL_4		1
	#define MX_UART_TX_PIN_4		0
	#define MX_UART_TX_PORT_4		porta
	#define MX_UART_TX_TRIS_4		trisa
	#define MX_UART_RX_PIN_4		0
	#define MX_UART_RX_PORT_4		porta
	#define MX_UART_RX_TRIS_4		trisa
	#define MX_UART_FLOWEN_4		0
	#define MX_UART_CTS_PIN_4		4
	#define MX_UART_CTS_PORT_4		portc
	#define MX_UART_CTS_TRIS_4		trisc
	#define MX_UART_RTS_PIN_4		0
	#define MX_UART_RTS_PORT_4		portc
	#define MX_UART_RTS_TRIS_4		trisc
	#define MX_UART_BAUD_4			9600
	#define MX_UART_DBITS_4			8
	#define MX_UART_RETURN_4		0
	#define MX_UART_ECHO_4			0
	#define MX_UART_INT_4			0
   #endif
  #endif
 #endif
#endif

#define RS232_1_UART_Init		CAL_APPEND(FC_CAL_UART_Init_, RS232_1_MX_UART_UREF)
#define RS232_1_UART_Send		CAL_APPEND(FC_CAL_UART_Send_, RS232_1_MX_UART_UREF)
#define RS232_1_UART_Receive		CAL_APPEND(FC_CAL_UART_Receive_, RS232_1_MX_UART_UREF)
#define RS232_1_UART_Update_Baud CAL_APPEND(FC_CAL_UART_Update_Baud_, RS232_1_MX_UART_UREF)

extern void RS232_1_UART_Init();
extern void RS232_1_UART_Send(MX_UINT16 nChar);
extern MX_SINT16 RS232_1_UART_Receive(MX_UINT8 nTimeout);
extern void RS232_1_UART_Update_Baud(MX_UINT8 newbaud);




//RS232(0): //Macro function declarations

void FCD_RS2320_SendRS232Char(MX_SINT16 nChar);
void FCD_RS2320_SendRS232String(MX_STRING String, MX_UINT8 MSZ_String);
MX_SINT16 FCD_RS2320_ReceiveRS232Char(MX_UINT8 nTimeout);
void FCD_RS2320_ReceiveRS232String(MX_CHAR* FCR_RETVAL, MX_UINT8 FCR_RETVAL_SIZE, MX_UINT8 nTimeout, MX_UINT8 NumBytes);
void FCD_RS2320_ChangeHWBaud(MX_UINT8 newbaud);



//RS232(0): //Macro implementations


void FCD_RS2320_SendRS232Char(MX_SINT16 nChar)
{
	
		RS232_1_UART_Send ( nChar);

}

void FCD_RS2320_SendRS232String(MX_STRING String, MX_UINT8 MSZ_String)
{
	
		MX_UINT8 idx;
		for(idx = 0; idx < MSZ_String; idx++)
		{
			if (String[idx] == 0)
				break;
			else RS232_1_UART_Send ( String[idx] );
		}

}

MX_SINT16 FCD_RS2320_ReceiveRS232Char(MX_UINT8 nTimeout)

{
	
		return ( RS232_1_UART_Receive ( nTimeout) );
025B  0860  	MOVF FCD_RS2320_00060_arg_nTimeout, W
025C  00E1  	MOVWF FC_CAL_UAR_0005B_arg_nTimeout
025D  2015  	CALL FC_CAL_UAR_0005B
025E  0868  	MOVF CompTempVarRet2210, W
025F  00E1  	MOVWF CompTempVarRet2215
0260  0869  	MOVF CompTempVarRet2210+D'1', W
0261  00E2  	MOVWF CompTempVarRet2215+D'1'


}
0262  0008  	RETURN


void FCD_RS2320_ReceiveRS232String(MX_CHAR* FCR_RETVAL, MX_UINT8 FCR_RETVAL_SIZE, MX_UINT8 nTimeout, MX_UINT8 NumBytes)
{
	
		MX_UINT8 idx;
		MX_SINT16 RS232_TO = 255;
		MX_SINT16 in;

		if ( 0 != 0 )
			RS232_TO = 256;

		if (NumBytes > FCR_RETVAL_SIZE)
			NumBytes = FCR_RETVAL_SIZE;

		for (idx = 0; idx < NumBytes; idx++)
		{
			in = RS232_1_UART_Receive ( nTimeout);
			if(in < RS232_TO)
				FCR_RETVAL[idx] = in & 0xFF;
			else
				break;
		}

		if (idx < FCR_RETVAL_SIZE)
			FCR_RETVAL[idx] = 0;

}

void FCD_RS2320_ChangeHWBaud(MX_UINT8 newbaud)
{
	
		RS232_1_UART_Update_Baud (newbaud);

}

#include "C:\Program Files (x86)\Flowcode\v5\CAL\includes.c"

//Macro implementations


void FCM_off_all()

{

	//Digit2
	//Output: 0 -> D0
	trisd = trisd & 0xFE;
00D7  30FE  	MOVLW 0xFE
00D8  1683  	BSF STATUS, RP0
00D9  1303  	BCF STATUS, RP1
00DA  0508  	ANDWF gbl_trisd, W
00DB  0088  	MOVWF gbl_trisd

	if ((0))
		portd = (portd & 0xFE) | 0x01;
	else
		portd = portd & 0xFE;
00DC  30FE  	MOVLW 0xFE
00DD  1283  	BCF STATUS, RP0
00DE  0508  	ANDWF gbl_portd, W
00DF  0088  	MOVWF gbl_portd


	//Digit1
	//Output: 0 -> D1
	trisd = trisd & 0xFD;
00E0  30FD  	MOVLW 0xFD
00E1  1683  	BSF STATUS, RP0
00E2  0508  	ANDWF gbl_trisd, W
00E3  0088  	MOVWF gbl_trisd

	if ((0))
		portd = (portd & 0xFD) | 0x02;
	else
		portd = portd & 0xFD;
00E4  30FD  	MOVLW 0xFD
00E5  1283  	BCF STATUS, RP0
00E6  0508  	ANDWF gbl_portd, W
00E7  0088  	MOVWF gbl_portd


}
00E8  0008  	RETURN



void FCM_data_bank()

{

	//Switch
	//Switch: digit?
	switch (FCV_DIGIT)

	{
		case 1:
0139  1283  	BCF STATUS, RP0
013A  1303  	BCF STATUS, RP1
013B  084D  	MOVF gbl_FCV_DIGIT, W
013C  3A01  	XORLW 0x01
013D  1903  	BTFSC STATUS,Z
013E  295B  	GOTO	label18
015B        label18

		{
			//Calculation
			//Calculation:
			//  bits = 0b00000110
			FCV_BITS = 6;
015B  3006  	MOVLW 0x06
015C  00C9  	MOVWF gbl_FCV_BITS


			break;

		}
		case 2:
013F  3A03  	XORLW 0x03
0140  1903  	BTFSC STATUS,Z
0141  295E  	GOTO	label19
015E        label19

		{
			//Calculation
			//Calculation:
			//  bits = 0b01011011
			FCV_BITS = 91;
015E  305B  	MOVLW 0x5B
015F  00C9  	MOVWF gbl_FCV_BITS


			break;

		}
		case 3:
0142  3A01  	XORLW 0x01
0143  1903  	BTFSC STATUS,Z
0144  2961  	GOTO	label20
0161        label20

		{
			//Calculation
			//Calculation:
			//  bits = 0b01001111
			FCV_BITS = 79;
0161  304F  	MOVLW 0x4F
0162  00C9  	MOVWF gbl_FCV_BITS


			break;

		}
		case 4:
0145  3A07  	XORLW 0x07
0146  1903  	BTFSC STATUS,Z
0147  2964  	GOTO	label21
0164        label21

		{
			//Calculation
			//Calculation:
			//  bits = 0b01100110
			FCV_BITS = 102;
0164  3066  	MOVLW 0x66
0165  00C9  	MOVWF gbl_FCV_BITS


			break;

		}
		case 5:
0148  3A01  	XORLW 0x01
0149  1903  	BTFSC STATUS,Z
014A  2967  	GOTO	label22
0167        label22

		{
			//Calculation
			//Calculation:
			//  bits = 0b01101101
			FCV_BITS = 109;
0167  306D  	MOVLW 0x6D
0168  00C9  	MOVWF gbl_FCV_BITS


			break;

		}
		case 6:
014B  3A03  	XORLW 0x03
014C  1903  	BTFSC STATUS,Z
014D  296A  	GOTO	label23
016A        label23

		{
			//Calculation
			//Calculation:
			//  bits = 0b01111101
			FCV_BITS = 125;
016A  307D  	MOVLW 0x7D
016B  00C9  	MOVWF gbl_FCV_BITS


			break;

		}
		case 7:
014E  3A01  	XORLW 0x01
014F  1903  	BTFSC STATUS,Z
0150  296D  	GOTO	label24
016D        label24

		{
			//Calculation
			//Calculation:
			//  bits = 0b00000111
			FCV_BITS = 7;
016D  3007  	MOVLW 0x07
016E  00C9  	MOVWF gbl_FCV_BITS


			break;

		}
		case 8:
0151  3A0F  	XORLW 0x0F
0152  1903  	BTFSC STATUS,Z
0153  2970  	GOTO	label25
0170        label25

		{
			//Calculation
			//Calculation:
			//  bits = 0b01111111
			FCV_BITS = 127;
0170  307F  	MOVLW 0x7F
0171  00C9  	MOVWF gbl_FCV_BITS


			break;

		}
		case 9:
0154  3A01  	XORLW 0x01
0155  1903  	BTFSC STATUS,Z
0156  2973  	GOTO	label26
0173        label26

		{
			//Calculation
			//Calculation:
			//  bits = 0b01101111
			FCV_BITS = 111;
0173  306F  	MOVLW 0x6F
0174  00C9  	MOVWF gbl_FCV_BITS


			break;

		}
		case 0:
0157  3A09  	XORLW 0x09
0158  1903  	BTFSC STATUS,Z
0159  2976  	GOTO	label27
0176        label27

		{
			//Calculation
			//Calculation:
			//  bits = 0b00111111
			FCV_BITS = 63;
0176  303F  	MOVLW 0x3F
0177  00C9  	MOVWF gbl_FCV_BITS


			break;

		}
		// default:

	}

}
015A  0008  	RETURN
015D  0008  	RETURN
0160  0008  	RETURN
0163  0008  	RETURN
0166  0008  	RETURN
0169  0008  	RETURN
016C  0008  	RETURN
016F  0008  	RETURN
0172  0008  	RETURN
0175  0008  	RETURN
0178  0008  	RETURN



void FCM_latch()

{

	//reg
	//Output: 1 -> C1
	trisc = trisc & 0xFD;
00E9  30FD  	MOVLW 0xFD
00EA  1683  	BSF STATUS, RP0
00EB  1303  	BCF STATUS, RP1
00EC  0507  	ANDWF gbl_trisc, W
00ED  0087  	MOVWF gbl_trisc

	if ((1))
		portc = (portc & 0xFD) | 0x02;
00EE  30FD  	MOVLW 0xFD
00EF  1283  	BCF STATUS, RP0
00F0  0507  	ANDWF gbl_portc, W
00F1  00DA  	MOVWF CompTempVar2188
00F2  3002  	MOVLW 0x02
00F3  045A  	IORWF CompTempVar2188, W
00F4  0087  	MOVWF gbl_portc

	else
		portc = portc & 0xFD;

	//reg
	//Output: 0 -> C1
	trisc = trisc & 0xFD;
00F5  30FD  	MOVLW 0xFD
00F6  1683  	BSF STATUS, RP0
00F7  0507  	ANDWF gbl_trisc, W
00F8  0087  	MOVWF gbl_trisc

	if ((0))
		portc = (portc & 0xFD) | 0x02;
	else
		portc = portc & 0xFD;
00F9  30FD  	MOVLW 0xFD
00FA  1283  	BCF STATUS, RP0
00FB  0507  	ANDWF gbl_portc, W
00FC  0087  	MOVWF gbl_portc


}
00FD  0008  	RETURN



void FCM_score_data_register()

{

	//Loop
	//Loop: Loop 8 times
	for (FCLV_LOOP1=0; FCLV_LOOP1<8; FCLV_LOOP1++)
009C  1283  	BCF STATUS, RP0
009D  1303  	BCF STATUS, RP1
009E  01D5  	CLRF gbl_FCLV_LOOP1
009F        label12
009F  3008  	MOVLW 0x08
00A0  0255  	SUBWF gbl_FCLV_LOOP1, W
00A1  1803  	BTFSC STATUS,C
00D5  0AD5  	INCF gbl_FCLV_LOOP1, F
00D6  289F  	GOTO	label12

	{

		//Calculation
		//Calculation:
		//  dat = bits AND 1
		FCV_DAT = FCV_BITS & 1;
00A3  3001  	MOVLW 0x01
00A4  0549  	ANDWF gbl_FCV_BITS, W
00A5  00DA  	MOVWF CompTempVar2189
00A6  01DB  	CLRF CompTempVar2190
00A7  08DA  	MOVF CompTempVar2189, F
00A8  1D03  	BTFSS STATUS,Z
00A9  145B  	BSF CompTempVar2190,0
00AA  1043  	BCF gbl_FCV_DAT,0
00AB  085B  	MOVF CompTempVar2190, W
00AC  1D03  	BTFSS STATUS,Z
00AD  1443  	BSF gbl_FCV_DAT,0


		//score_data
		//Output: dat -> C3
		trisc = trisc & 0xF7;
00AE  30F7  	MOVLW 0xF7
00AF  1683  	BSF STATUS, RP0
00B0  0507  	ANDWF gbl_trisc, W
00B1  0087  	MOVWF gbl_trisc

		if ((FCV_DAT))
00B2  1283  	BCF STATUS, RP0
00B3  1C43  	BTFSS gbl_FCV_DAT,0
00B4  28BC  	GOTO	label13
00BC        label13

			portc = (portc & 0xF7) | 0x08;
00B5  30F7  	MOVLW 0xF7
00B6  0507  	ANDWF gbl_portc, W
00B7  00DA  	MOVWF CompTempVar2191
00B8  3008  	MOVLW 0x08
00B9  045A  	IORWF CompTempVar2191, W
00BA  0087  	MOVWF gbl_portc

		else
00BB  28BF  	GOTO	label14
00BF        label14

			portc = portc & 0xF7;
00BC  30F7  	MOVLW 0xF7
00BD  0507  	ANDWF gbl_portc, W
00BE  0087  	MOVWF gbl_portc


		//clk
		//Output: 1 -> C0
		trisc = trisc & 0xFE;
00BF  30FE  	MOVLW 0xFE
00C0  1683  	BSF STATUS, RP0
00C1  0507  	ANDWF gbl_trisc, W
00C2  0087  	MOVWF gbl_trisc

		if ((1))
			portc = (portc & 0xFE) | 0x01;
00C3  30FE  	MOVLW 0xFE
00C4  1283  	BCF STATUS, RP0
00C5  0507  	ANDWF gbl_portc, W
00C6  00DA  	MOVWF CompTempVar2192
00C7  3001  	MOVLW 0x01
00C8  045A  	IORWF CompTempVar2192, W
00C9  0087  	MOVWF gbl_portc

		else
			portc = portc & 0xFE;

		//clk
		//Output: 0 -> C0
		trisc = trisc & 0xFE;
00CA  30FE  	MOVLW 0xFE
00CB  1683  	BSF STATUS, RP0
00CC  0507  	ANDWF gbl_trisc, W
00CD  0087  	MOVWF gbl_trisc

		if ((0))
			portc = (portc & 0xFE) | 0x01;
		else
			portc = portc & 0xFE;
00CE  30FE  	MOVLW 0xFE
00CF  1283  	BCF STATUS, RP0
00D0  0507  	ANDWF gbl_portc, W
00D1  0087  	MOVWF gbl_portc


		//Calculation
		//Calculation:
		//  bits = bits >> 1
		FCV_BITS = FCV_BITS >> 1;
00D2  08C9  	MOVF gbl_FCV_BITS, F
00D3  1003  	BCF STATUS,C
00D4  0CC9  	RRF gbl_FCV_BITS, F



	}

}
00A2  0008  	RETURN



void FCM_display_score()

{

	//Call Macro
	//Call Macro: off_all()
	FCM_off_all();
0220  20D7  	CALL FCM_off_al_00051


	//Calculation
	//Calculation:
	//  digit = away_ones
	FCV_DIGIT = FCV_AWAY_ONES;
0221  084F  	MOVF gbl_FCV_AWAY_ONES, W
0222  00CD  	MOVWF gbl_FCV_DIGIT


	//Call Macro
	//Call Macro: data_bank()
	FCM_data_bank();
0223  2139  	CALL FCM_data_b_00052


	//Call Macro
	//Call Macro: score_data_register()
	FCM_score_data_register();
0224  209C  	CALL FCM_score__00053


	//Calculation
	//Calculation:
	//  digit = home_ones
	FCV_DIGIT = FCV_HOME_ONES;
0225  0842  	MOVF gbl_FCV_HOME_ONES, W
0226  00CD  	MOVWF gbl_FCV_DIGIT


	//Call Macro
	//Call Macro: data_bank()
	FCM_data_bank();
0227  2139  	CALL FCM_data_b_00052


	//Call Macro
	//Call Macro: score_data_register()
	FCM_score_data_register();
0228  209C  	CALL FCM_score__00053


	//Call Macro
	//Call Macro: latch()
	FCM_latch();
0229  20E9  	CALL FCM_latch_00000


	//Digit2
	//Output: 0 -> D0
	trisd = trisd & 0xFE;
022A  30FE  	MOVLW 0xFE
022B  1683  	BSF STATUS, RP0
022C  0508  	ANDWF gbl_trisd, W
022D  0088  	MOVWF gbl_trisd

	if ((0))
		portd = (portd & 0xFE) | 0x01;
	else
		portd = portd & 0xFE;
022E  30FE  	MOVLW 0xFE
022F  1283  	BCF STATUS, RP0
0230  0508  	ANDWF gbl_portd, W
0231  0088  	MOVWF gbl_portd


	//Digit1
	//Output: 1 -> D1
	trisd = trisd & 0xFD;
0232  30FD  	MOVLW 0xFD
0233  1683  	BSF STATUS, RP0
0234  0508  	ANDWF gbl_trisd, W
0235  0088  	MOVWF gbl_trisd

	if ((1))
		portd = (portd & 0xFD) | 0x02;
0236  30FD  	MOVLW 0xFD
0237  1283  	BCF STATUS, RP0
0238  0508  	ANDWF gbl_portd, W
0239  00DA  	MOVWF CompTempVar2194
023A  3002  	MOVLW 0x02
023B  045A  	IORWF CompTempVar2194, W
023C  0088  	MOVWF gbl_portd

	else
		portd = portd & 0xFD;

	//Comment:
	//END of Digit1

	//Call Macro
	//Call Macro: off_all()
	FCM_off_all();
023D  20D7  	CALL FCM_off_al_00051


	//Calculation
	//Calculation:
	//  digit = away_tens
	FCV_DIGIT = FCV_AWAY_TENS;
023E  0848  	MOVF gbl_FCV_AWAY_TENS, W
023F  00CD  	MOVWF gbl_FCV_DIGIT


	//Call Macro
	//Call Macro: data_bank()
	FCM_data_bank();
0240  2139  	CALL FCM_data_b_00052


	//Call Macro
	//Call Macro: score_data_register()
	FCM_score_data_register();
0241  209C  	CALL FCM_score__00053


	//Calculation
	//Calculation:
	//  digit = home_tens
	FCV_DIGIT = FCV_HOME_TENS;
0242  0850  	MOVF gbl_FCV_HOME_TENS, W
0243  00CD  	MOVWF gbl_FCV_DIGIT


	//Call Macro
	//Call Macro: data_bank()
	FCM_data_bank();
0244  2139  	CALL FCM_data_b_00052


	//Call Macro
	//Call Macro: score_data_register()
	FCM_score_data_register();
0245  209C  	CALL FCM_score__00053


	//Call Macro
	//Call Macro: latch()
	FCM_latch();
0246  20E9  	CALL FCM_latch_00000


	//Digit2
	//Output: 1 -> D0
	trisd = trisd & 0xFE;
0247  30FE  	MOVLW 0xFE
0248  1683  	BSF STATUS, RP0
0249  0508  	ANDWF gbl_trisd, W
024A  0088  	MOVWF gbl_trisd

	if ((1))
		portd = (portd & 0xFE) | 0x01;
024B  30FE  	MOVLW 0xFE
024C  1283  	BCF STATUS, RP0
024D  0508  	ANDWF gbl_portd, W
024E  00DA  	MOVWF CompTempVar2195
024F  3001  	MOVLW 0x01
0250  045A  	IORWF CompTempVar2195, W
0251  0088  	MOVWF gbl_portd

	else
		portd = portd & 0xFE;

	//Digit1
	//Output: 0 -> D1
	trisd = trisd & 0xFD;
0252  30FD  	MOVLW 0xFD
0253  1683  	BSF STATUS, RP0
0254  0508  	ANDWF gbl_trisd, W
0255  0088  	MOVWF gbl_trisd

	if ((0))
		portd = (portd & 0xFD) | 0x02;
	else
		portd = portd & 0xFD;
0256  30FD  	MOVLW 0xFD
0257  1283  	BCF STATUS, RP0
0258  0508  	ANDWF gbl_portd, W
0259  0088  	MOVWF gbl_portd


}
025A  0008  	RETURN



void FCM_display_time()

{

	//Call Macro
	//Call Macro: off_all()
	FCM_off_all();
01E5  20D7  	CALL FCM_off_al_00051


	//Calculation
	//Calculation:
	//  digit = minute_ones
	FCV_DIGIT = FCV_MINUTE_ONES;
01E6  084E  	MOVF gbl_FCV_MINUTE_ONES, W
01E7  00CD  	MOVWF gbl_FCV_DIGIT


	//Call Macro
	//Call Macro: data_bank()
	FCM_data_bank();
01E8  2139  	CALL FCM_data_b_00052


	//Call Macro
	//Call Macro: time_data_register()
	FCM_time_data_register();
01E9  2061  	CALL FCM_time_d_00056


	//Calculation
	//Calculation:
	//  digit = seconds_ones
	FCV_DIGIT = FCV_SECONDS_ONES;
01EA  0851  	MOVF gbl_FCV_SECONDS_ONES, W
01EB  00CD  	MOVWF gbl_FCV_DIGIT


	//Call Macro
	//Call Macro: data_bank()
	FCM_data_bank();
01EC  2139  	CALL FCM_data_b_00052


	//Call Macro
	//Call Macro: time_data_register()
	FCM_time_data_register();
01ED  2061  	CALL FCM_time_d_00056


	//Call Macro
	//Call Macro: latch()
	FCM_latch();
01EE  20E9  	CALL FCM_latch_00000


	//Digit2
	//Output: 0 -> D0
	trisd = trisd & 0xFE;
01EF  30FE  	MOVLW 0xFE
01F0  1683  	BSF STATUS, RP0
01F1  0508  	ANDWF gbl_trisd, W
01F2  0088  	MOVWF gbl_trisd

	if ((0))
		portd = (portd & 0xFE) | 0x01;
	else
		portd = portd & 0xFE;
01F3  30FE  	MOVLW 0xFE
01F4  1283  	BCF STATUS, RP0
01F5  0508  	ANDWF gbl_portd, W
01F6  0088  	MOVWF gbl_portd


	//Digit1
	//Output: 1 -> D1
	trisd = trisd & 0xFD;
01F7  30FD  	MOVLW 0xFD
01F8  1683  	BSF STATUS, RP0
01F9  0508  	ANDWF gbl_trisd, W
01FA  0088  	MOVWF gbl_trisd

	if ((1))
		portd = (portd & 0xFD) | 0x02;
01FB  30FD  	MOVLW 0xFD
01FC  1283  	BCF STATUS, RP0
01FD  0508  	ANDWF gbl_portd, W
01FE  00DA  	MOVWF CompTempVar2196
01FF  3002  	MOVLW 0x02
0200  045A  	IORWF CompTempVar2196, W
0201  0088  	MOVWF gbl_portd

	else
		portd = portd & 0xFD;

	//Comment:
	//END of Digit1

	//Call Macro
	//Call Macro: off_all()
	FCM_off_all();
0202  20D7  	CALL FCM_off_al_00051


	//Calculation
	//Calculation:
	//  digit = minute_tens
	FCV_DIGIT = FCV_MINUTE_TENS;
0203  0847  	MOVF gbl_FCV_MINUTE_TENS, W
0204  00CD  	MOVWF gbl_FCV_DIGIT


	//Call Macro
	//Call Macro: data_bank()
	FCM_data_bank();
0205  2139  	CALL FCM_data_b_00052


	//Call Macro
	//Call Macro: time_data_register()
	FCM_time_data_register();
0206  2061  	CALL FCM_time_d_00056


	//Calculation
	//Calculation:
	//  digit = seconds_tens
	FCV_DIGIT = FCV_SECONDS_TENS;
0207  084B  	MOVF gbl_FCV_SECONDS_TENS, W
0208  00CD  	MOVWF gbl_FCV_DIGIT


	//Call Macro
	//Call Macro: data_bank()
	FCM_data_bank();
0209  2139  	CALL FCM_data_b_00052


	//Call Macro
	//Call Macro: time_data_register()
	FCM_time_data_register();
020A  2061  	CALL FCM_time_d_00056


	//Call Macro
	//Call Macro: latch()
	FCM_latch();
020B  20E9  	CALL FCM_latch_00000


	//Digit2
	//Output: 1 -> D0
	trisd = trisd & 0xFE;
020C  30FE  	MOVLW 0xFE
020D  1683  	BSF STATUS, RP0
020E  0508  	ANDWF gbl_trisd, W
020F  0088  	MOVWF gbl_trisd

	if ((1))
		portd = (portd & 0xFE) | 0x01;
0210  30FE  	MOVLW 0xFE
0211  1283  	BCF STATUS, RP0
0212  0508  	ANDWF gbl_portd, W
0213  00DA  	MOVWF CompTempVar2197
0214  3001  	MOVLW 0x01
0215  045A  	IORWF CompTempVar2197, W
0216  0088  	MOVWF gbl_portd

	else
		portd = portd & 0xFE;

	//Digit1
	//Output: 0 -> D1
	trisd = trisd & 0xFD;
0217  30FD  	MOVLW 0xFD
0218  1683  	BSF STATUS, RP0
0219  0508  	ANDWF gbl_trisd, W
021A  0088  	MOVWF gbl_trisd

	if ((0))
		portd = (portd & 0xFD) | 0x02;
	else
		portd = portd & 0xFD;
021B  30FD  	MOVLW 0xFD
021C  1283  	BCF STATUS, RP0
021D  0508  	ANDWF gbl_portd, W
021E  0088  	MOVWF gbl_portd


}
021F  0008  	RETURN



void FCM_time_data_register()

{

	//Loop
	//Loop: Loop 8 times
	for (FCLV_LOOP2=0; FCLV_LOOP2<8; FCLV_LOOP2++)
0061  1283  	BCF STATUS, RP0
0062  1303  	BCF STATUS, RP1
0063  01D6  	CLRF gbl_FCLV_LOOP2
0064        label9
0064  3008  	MOVLW 0x08
0065  0256  	SUBWF gbl_FCLV_LOOP2, W
0066  1803  	BTFSC STATUS,C
009A  0AD6  	INCF gbl_FCLV_LOOP2, F
009B  2864  	GOTO	label9

	{

		//Calculation
		//Calculation:
		//  dat = bits AND 1
		FCV_DAT = FCV_BITS & 1;
0068  3001  	MOVLW 0x01
0069  0549  	ANDWF gbl_FCV_BITS, W
006A  00DA  	MOVWF CompTempVar2198
006B  01DB  	CLRF CompTempVar2199
006C  08DA  	MOVF CompTempVar2198, F
006D  1D03  	BTFSS STATUS,Z
006E  145B  	BSF CompTempVar2199,0
006F  1043  	BCF gbl_FCV_DAT,0
0070  085B  	MOVF CompTempVar2199, W
0071  1D03  	BTFSS STATUS,Z
0072  1443  	BSF gbl_FCV_DAT,0


		//time_data
		//Output: dat -> C2
		trisc = trisc & 0xFB;
0073  30FB  	MOVLW 0xFB
0074  1683  	BSF STATUS, RP0
0075  0507  	ANDWF gbl_trisc, W
0076  0087  	MOVWF gbl_trisc

		if ((FCV_DAT))
0077  1283  	BCF STATUS, RP0
0078  1C43  	BTFSS gbl_FCV_DAT,0
0079  2881  	GOTO	label10
0081        label10

			portc = (portc & 0xFB) | 0x04;
007A  30FB  	MOVLW 0xFB
007B  0507  	ANDWF gbl_portc, W
007C  00DA  	MOVWF CompTempVar2200
007D  3004  	MOVLW 0x04
007E  045A  	IORWF CompTempVar2200, W
007F  0087  	MOVWF gbl_portc

		else
0080  2884  	GOTO	label11
0084        label11

			portc = portc & 0xFB;
0081  30FB  	MOVLW 0xFB
0082  0507  	ANDWF gbl_portc, W
0083  0087  	MOVWF gbl_portc


		//clk
		//Output: 1 -> C0
		trisc = trisc & 0xFE;
0084  30FE  	MOVLW 0xFE
0085  1683  	BSF STATUS, RP0
0086  0507  	ANDWF gbl_trisc, W
0087  0087  	MOVWF gbl_trisc

		if ((1))
			portc = (portc & 0xFE) | 0x01;
0088  30FE  	MOVLW 0xFE
0089  1283  	BCF STATUS, RP0
008A  0507  	ANDWF gbl_portc, W
008B  00DA  	MOVWF CompTempVar2201
008C  3001  	MOVLW 0x01
008D  045A  	IORWF CompTempVar2201, W
008E  0087  	MOVWF gbl_portc

		else
			portc = portc & 0xFE;

		//clk
		//Output: 0 -> C0
		trisc = trisc & 0xFE;
008F  30FE  	MOVLW 0xFE
0090  1683  	BSF STATUS, RP0
0091  0507  	ANDWF gbl_trisc, W
0092  0087  	MOVWF gbl_trisc

		if ((0))
			portc = (portc & 0xFE) | 0x01;
		else
			portc = portc & 0xFE;
0093  30FE  	MOVLW 0xFE
0094  1283  	BCF STATUS, RP0
0095  0507  	ANDWF gbl_portc, W
0096  0087  	MOVWF gbl_portc


		//Calculation
		//Calculation:
		//  bits = bits >> 1
		FCV_BITS = FCV_BITS >> 1;
0097  08C9  	MOVF gbl_FCV_BITS, F
0098  1003  	BCF STATUS,C
0099  0CC9  	RRF gbl_FCV_BITS, F



	}

}
0067  0008  	RETURN



void FCM_foulperiod_data_register()

{

	//Loop
	//Loop: Loop 8 times
	for (FCLV_LOOP3=0; FCLV_LOOP3<8; FCLV_LOOP3++)
00FE  1283  	BCF STATUS, RP0
00FF  1303  	BCF STATUS, RP1
0100  01D7  	CLRF gbl_FCLV_LOOP3
0101        label15
0101  3008  	MOVLW 0x08
0102  0257  	SUBWF gbl_FCLV_LOOP3, W
0103  1803  	BTFSC STATUS,C
0137  0AD7  	INCF gbl_FCLV_LOOP3, F
0138  2901  	GOTO	label15

	{

		//Calculation
		//Calculation:
		//  dat = bits AND 1
		FCV_DAT = FCV_BITS & 1;
0105  3001  	MOVLW 0x01
0106  0549  	ANDWF gbl_FCV_BITS, W
0107  00DA  	MOVWF CompTempVar2203
0108  01DB  	CLRF CompTempVar2204
0109  08DA  	MOVF CompTempVar2203, F
010A  1D03  	BTFSS STATUS,Z
010B  145B  	BSF CompTempVar2204,0
010C  1043  	BCF gbl_FCV_DAT,0
010D  085B  	MOVF CompTempVar2204, W
010E  1D03  	BTFSS STATUS,Z
010F  1443  	BSF gbl_FCV_DAT,0


		//foulperiod_data
		//Output: dat -> C4
		trisc = trisc & 0xEF;
0110  30EF  	MOVLW 0xEF
0111  1683  	BSF STATUS, RP0
0112  0507  	ANDWF gbl_trisc, W
0113  0087  	MOVWF gbl_trisc

		if ((FCV_DAT))
0114  1283  	BCF STATUS, RP0
0115  1C43  	BTFSS gbl_FCV_DAT,0
0116  291E  	GOTO	label16
011E        label16

			portc = (portc & 0xEF) | 0x10;
0117  30EF  	MOVLW 0xEF
0118  0507  	ANDWF gbl_portc, W
0119  00DA  	MOVWF CompTempVar2205
011A  3010  	MOVLW 0x10
011B  045A  	IORWF CompTempVar2205, W
011C  0087  	MOVWF gbl_portc

		else
011D  2921  	GOTO	label17
0121        label17

			portc = portc & 0xEF;
011E  30EF  	MOVLW 0xEF
011F  0507  	ANDWF gbl_portc, W
0120  0087  	MOVWF gbl_portc


		//clk
		//Output: 1 -> C0
		trisc = trisc & 0xFE;
0121  30FE  	MOVLW 0xFE
0122  1683  	BSF STATUS, RP0
0123  0507  	ANDWF gbl_trisc, W
0124  0087  	MOVWF gbl_trisc

		if ((1))
			portc = (portc & 0xFE) | 0x01;
0125  30FE  	MOVLW 0xFE
0126  1283  	BCF STATUS, RP0
0127  0507  	ANDWF gbl_portc, W
0128  00DA  	MOVWF CompTempVar2206
0129  3001  	MOVLW 0x01
012A  045A  	IORWF CompTempVar2206, W
012B  0087  	MOVWF gbl_portc

		else
			portc = portc & 0xFE;

		//clk
		//Output: 0 -> C0
		trisc = trisc & 0xFE;
012C  30FE  	MOVLW 0xFE
012D  1683  	BSF STATUS, RP0
012E  0507  	ANDWF gbl_trisc, W
012F  0087  	MOVWF gbl_trisc

		if ((0))
			portc = (portc & 0xFE) | 0x01;
		else
			portc = portc & 0xFE;
0130  30FE  	MOVLW 0xFE
0131  1283  	BCF STATUS, RP0
0132  0507  	ANDWF gbl_portc, W
0133  0087  	MOVWF gbl_portc


		//Calculation
		//Calculation:
		//  bits = bits >> 1
		FCV_BITS = FCV_BITS >> 1;
0134  08C9  	MOVF gbl_FCV_BITS, F
0135  1003  	BCF STATUS,C
0136  0CC9  	RRF gbl_FCV_BITS, F



	}

}
0104  0008  	RETURN



void FCM_foulperiod_display()

{

	//Call Macro
	//Call Macro: off_all()
	FCM_off_all();
01AA  20D7  	CALL FCM_off_al_00051


	//Calculation
	//Calculation:
	//  digit = away_foul
	FCV_DIGIT = FCV_AWAY_FOUL;
01AB  0854  	MOVF gbl_FCV_AWAY_FOUL, W
01AC  00CD  	MOVWF gbl_FCV_DIGIT


	//Call Macro
	//Call Macro: data_bank()
	FCM_data_bank();
01AD  2139  	CALL FCM_data_b_00052


	//Call Macro
	//Call Macro: foulperiod_data_register()
	FCM_foulperiod_data_register();
01AE  20FE  	CALL FCM_foulpe_00057


	//Calculation
	//Calculation:
	//  digit = period
	FCV_DIGIT = FCV_PERIOD;
01AF  0844  	MOVF gbl_FCV_PERIOD, W
01B0  00CD  	MOVWF gbl_FCV_DIGIT


	//Call Macro
	//Call Macro: data_bank()
	FCM_data_bank();
01B1  2139  	CALL FCM_data_b_00052


	//Call Macro
	//Call Macro: foulperiod_data_register()
	FCM_foulperiod_data_register();
01B2  20FE  	CALL FCM_foulpe_00057


	//Call Macro
	//Call Macro: latch()
	FCM_latch();
01B3  20E9  	CALL FCM_latch_00000


	//Digit2
	//Output: 0 -> D0
	trisd = trisd & 0xFE;
01B4  30FE  	MOVLW 0xFE
01B5  1683  	BSF STATUS, RP0
01B6  0508  	ANDWF gbl_trisd, W
01B7  0088  	MOVWF gbl_trisd

	if ((0))
		portd = (portd & 0xFE) | 0x01;
	else
		portd = portd & 0xFE;
01B8  30FE  	MOVLW 0xFE
01B9  1283  	BCF STATUS, RP0
01BA  0508  	ANDWF gbl_portd, W
01BB  0088  	MOVWF gbl_portd


	//Digit1
	//Output: 1 -> D1
	trisd = trisd & 0xFD;
01BC  30FD  	MOVLW 0xFD
01BD  1683  	BSF STATUS, RP0
01BE  0508  	ANDWF gbl_trisd, W
01BF  0088  	MOVWF gbl_trisd

	if ((1))
		portd = (portd & 0xFD) | 0x02;
01C0  30FD  	MOVLW 0xFD
01C1  1283  	BCF STATUS, RP0
01C2  0508  	ANDWF gbl_portd, W
01C3  00DA  	MOVWF CompTempVar2208
01C4  3002  	MOVLW 0x02
01C5  045A  	IORWF CompTempVar2208, W
01C6  0088  	MOVWF gbl_portd

	else
		portd = portd & 0xFD;

	//Call Macro
	//Call Macro: off_all()
	FCM_off_all();
01C7  20D7  	CALL FCM_off_al_00051


	//Calculation
	//Calculation:
	//  digit = home_foul
	FCV_DIGIT = FCV_HOME_FOUL;
01C8  0846  	MOVF gbl_FCV_HOME_FOUL, W
01C9  00CD  	MOVWF gbl_FCV_DIGIT


	//Call Macro
	//Call Macro: data_bank()
	FCM_data_bank();
01CA  2139  	CALL FCM_data_b_00052


	//Call Macro
	//Call Macro: foulperiod_data_register()
	FCM_foulperiod_data_register();
01CB  20FE  	CALL FCM_foulpe_00057


	//Calculation
	//Calculation:
	//  digit = period
	FCV_DIGIT = FCV_PERIOD;
01CC  0844  	MOVF gbl_FCV_PERIOD, W
01CD  00CD  	MOVWF gbl_FCV_DIGIT


	//Call Macro
	//Call Macro: data_bank()
	FCM_data_bank();
01CE  2139  	CALL FCM_data_b_00052


	//Call Macro
	//Call Macro: foulperiod_data_register()
	FCM_foulperiod_data_register();
01CF  20FE  	CALL FCM_foulpe_00057


	//Call Macro
	//Call Macro: latch()
	FCM_latch();
01D0  20E9  	CALL FCM_latch_00000


	//Digit2
	//Output: 1 -> D0
	trisd = trisd & 0xFE;
01D1  30FE  	MOVLW 0xFE
01D2  1683  	BSF STATUS, RP0
01D3  0508  	ANDWF gbl_trisd, W
01D4  0088  	MOVWF gbl_trisd

	if ((1))
		portd = (portd & 0xFE) | 0x01;
01D5  30FE  	MOVLW 0xFE
01D6  1283  	BCF STATUS, RP0
01D7  0508  	ANDWF gbl_portd, W
01D8  00DA  	MOVWF CompTempVar2209
01D9  3001  	MOVLW 0x01
01DA  045A  	IORWF CompTempVar2209, W
01DB  0088  	MOVWF gbl_portd

	else
		portd = portd & 0xFE;

	//Digit1
	//Output: 0 -> D1
	trisd = trisd & 0xFD;
01DC  30FD  	MOVLW 0xFD
01DD  1683  	BSF STATUS, RP0
01DE  0508  	ANDWF gbl_trisd, W
01DF  0088  	MOVWF gbl_trisd

	if ((0))
		portd = (portd & 0xFD) | 0x02;
	else
		portd = portd & 0xFD;
01E0  30FD  	MOVLW 0xFD
01E1  1283  	BCF STATUS, RP0
01E2  0508  	ANDWF gbl_portd, W
01E3  0088  	MOVWF gbl_portd


}
01E4  0008  	RETURN




void main()

{
	//Initialization
	ansel = 0;
0263  1683  	BSF STATUS, RP0
0264  1703  	BSF STATUS, RP1
0265  0188  	CLRF gbl_ansel

anselh = 0;
0266  0189  	CLRF gbl_anselh


	
		RS232_1_UART_Init( );		//Call initialise function
0267  219B  	CALL FC_CAL_UAR_00059



	//Interrupt initialization code
	option_reg = 0xC0;
0268  30C0  	MOVLW 0xC0
0269  0081  	MOVWF gbl_option_reg



	//Home_ONE
	//Output: 0 -> D2
	trisd = trisd & 0xFB;
026A  30FB  	MOVLW 0xFB
026B  0508  	ANDWF gbl_trisd, W
026C  0088  	MOVWF gbl_trisd

	if ((0))
		portd = (portd & 0xFB) | 0x04;
	else
		portd = portd & 0xFB;
026D  30FB  	MOVLW 0xFB
026E  1283  	BCF STATUS, RP0
026F  0508  	ANDWF gbl_portd, W
0270  0088  	MOVWF gbl_portd


	//Guest_ONE
	//Output: 0 -> D3
	trisd = trisd & 0xF7;
0271  30F7  	MOVLW 0xF7
0272  1683  	BSF STATUS, RP0
0273  0508  	ANDWF gbl_trisd, W
0274  0088  	MOVWF gbl_trisd

	if ((0))
		portd = (portd & 0xF7) | 0x08;
	else
		portd = portd & 0xF7;
0275  30F7  	MOVLW 0xF7
0276  1283  	BCF STATUS, RP0
0277  0508  	ANDWF gbl_portd, W
0278  0088  	MOVWF gbl_portd


	//clk
	//Output: 0 -> C0
	trisc = trisc & 0xFE;
0279  30FE  	MOVLW 0xFE
027A  1683  	BSF STATUS, RP0
027B  0507  	ANDWF gbl_trisc, W
027C  0087  	MOVWF gbl_trisc

	if ((0))
		portc = (portc & 0xFE) | 0x01;
	else
		portc = portc & 0xFE;
027D  30FE  	MOVLW 0xFE
027E  1283  	BCF STATUS, RP0
027F  0507  	ANDWF gbl_portc, W
0280  0087  	MOVWF gbl_portc


	//reg
	//Output: 0 -> C1
	trisc = trisc & 0xFD;
0281  30FD  	MOVLW 0xFD
0282  1683  	BSF STATUS, RP0
0283  0507  	ANDWF gbl_trisc, W
0284  0087  	MOVWF gbl_trisc

	if ((0))
		portc = (portc & 0xFD) | 0x02;
	else
		portc = portc & 0xFD;
0285  30FD  	MOVLW 0xFD
0286  1283  	BCF STATUS, RP0
0287  0507  	ANDWF gbl_portc, W
0288  0087  	MOVWF gbl_portc


	//Digit2
	//Output: 0 -> D0
	trisd = trisd & 0xFE;
0289  30FE  	MOVLW 0xFE
028A  1683  	BSF STATUS, RP0
028B  0508  	ANDWF gbl_trisd, W
028C  0088  	MOVWF gbl_trisd

	if ((0))
		portd = (portd & 0xFE) | 0x01;
	else
		portd = portd & 0xFE;
028D  30FE  	MOVLW 0xFE
028E  1283  	BCF STATUS, RP0
028F  0508  	ANDWF gbl_portd, W
0290  0088  	MOVWF gbl_portd


	//Digit1
	//Output: 1 -> D1
	trisd = trisd & 0xFD;
0291  30FD  	MOVLW 0xFD
0292  1683  	BSF STATUS, RP0
0293  0508  	ANDWF gbl_trisd, W
0294  0088  	MOVWF gbl_trisd

	if ((1))
		portd = (portd & 0xFD) | 0x02;
0295  30FD  	MOVLW 0xFD
0296  1283  	BCF STATUS, RP0
0297  0508  	ANDWF gbl_portd, W
0298  00D8  	MOVWF CompTempVar2220
0299  3002  	MOVLW 0x02
029A  0458  	IORWF CompTempVar2220, W
029B  0088  	MOVWF gbl_portd

	else
		portd = portd & 0xFD;

	//Dot
	//Output: 0 -> D5
	trisd = trisd & 0xDF;
029C  30DF  	MOVLW 0xDF
029D  1683  	BSF STATUS, RP0
029E  0508  	ANDWF gbl_trisd, W
029F  0088  	MOVWF gbl_trisd

	if ((0))
		portd = (portd & 0xDF) | 0x20;
	else
		portd = portd & 0xDF;
02A0  30DF  	MOVLW 0xDF
02A1  1283  	BCF STATUS, RP0
02A2  0508  	ANDWF gbl_portd, W
02A3  0088  	MOVWF gbl_portd


	//Colon
	//Output: 1 -> D4
	trisd = trisd & 0xEF;
02A4  30EF  	MOVLW 0xEF
02A5  1683  	BSF STATUS, RP0
02A6  0508  	ANDWF gbl_trisd, W
02A7  0088  	MOVWF gbl_trisd

	if ((1))
		portd = (portd & 0xEF) | 0x10;
02A8  30EF  	MOVLW 0xEF
02A9  1283  	BCF STATUS, RP0
02AA  0508  	ANDWF gbl_portd, W
02AB  00D8  	MOVWF CompTempVar2221
02AC  3010  	MOVLW 0x10
02AD  0458  	IORWF CompTempVar2221, W
02AE  0088  	MOVWF gbl_portd

	else
		portd = portd & 0xEF;

	//home_one
	//Output: 1 -> D2
	trisd = trisd & 0xFB;
02AF  30FB  	MOVLW 0xFB
02B0  1683  	BSF STATUS, RP0
02B1  0508  	ANDWF gbl_trisd, W
02B2  0088  	MOVWF gbl_trisd

	if ((1))
		portd = (portd & 0xFB) | 0x04;
02B3  30FB  	MOVLW 0xFB
02B4  1283  	BCF STATUS, RP0
02B5  0508  	ANDWF gbl_portd, W
02B6  00D8  	MOVWF CompTempVar2222
02B7  3004  	MOVLW 0x04
02B8  0458  	IORWF CompTempVar2222, W
02B9  0088  	MOVWF gbl_portd

	else
		portd = portd & 0xFB;

	//away_one
	//Output: 1 -> D3
	trisd = trisd & 0xF7;
02BA  30F7  	MOVLW 0xF7
02BB  1683  	BSF STATUS, RP0
02BC  0508  	ANDWF gbl_trisd, W
02BD  0088  	MOVWF gbl_trisd

	if ((1))
		portd = (portd & 0xF7) | 0x08;
02BE  30F7  	MOVLW 0xF7
02BF  1283  	BCF STATUS, RP0
02C0  0508  	ANDWF gbl_portd, W
02C1  00D8  	MOVWF CompTempVar2223
02C2  3008  	MOVLW 0x08
02C3  0458  	IORWF CompTempVar2223, W
02C4  0088  	MOVWF gbl_portd

	else
		portd = portd & 0xF7;

	//Calculation
	//Calculation:
	//  flag = 0
	FCV_FLAG = 0;
02C5  1143  	BCF gbl_FCV_FLAG,2


	//Calculation
	//Calculation:
	//  period = 1
	FCV_PERIOD = 1;
02C6  3001  	MOVLW 0x01
02C7  00C4  	MOVWF gbl_FCV_PERIOD


	//Loop
	//Loop: While 1
	while (1)
02C8        label32
03A2  2AC8  	GOTO	label32

	{

		//Connection Point
		//Connection Point: [A]: A
FCC_Main_A:

;

		//Call Component Macro
		//Call Component Macro: rx=ReceiveRS232Char(1)
		FCV_RX = FCD_RS2320_ReceiveRS232Char(1);
02C8  3001  	MOVLW 0x01
02C9  00E0  	MOVWF FCD_RS2320_00060_arg_nTimeout
02CA  225B  	CALL FCD_RS2320_00060
02CB  0861  	MOVF CompTempVarRet2215, W
02CC  00CA  	MOVWF gbl_FCV_RX


		//Decision
		//Decision: rx > 48 AND rx < 90?
		if (FCV_RX > 48 & FCV_RX < 90)
02CD  01D9  	CLRF CompTempVar2225
02CE  084A  	MOVF gbl_FCV_RX, W
02CF  3C30  	SUBLW 0x30
02D0  1C03  	BTFSS STATUS,C
02D1  0AD9  	INCF CompTempVar2225, F
02D2  01D8  	CLRF CompTempVar2224
02D3  305A  	MOVLW 0x5A
02D4  024A  	SUBWF gbl_FCV_RX, W
02D5  1C03  	BTFSS STATUS,C
02D6  0AD8  	INCF CompTempVar2224, F
02D7  0858  	MOVF CompTempVar2224, W
02D8  0559  	ANDWF CompTempVar2225, W
02D9  1903  	BTFSC STATUS,Z
02DA  2B83  	GOTO	label41
0383        label41

		{

			//Decision
			//Decision: rx = 'A'?
			if (FCV_RX == 'A')
02DB  084A  	MOVF gbl_FCV_RX, W
02DC  3A41  	XORLW 0x41
02DD  1D03  	BTFSS STATUS,Z
02DE  2AC8  	GOTO	label32
0340        label37
035F        label39

			{

				//Call Component Macro
				//Call Component Macro: rx=ReceiveRS232Char(1)
				FCV_RX = FCD_RS2320_ReceiveRS232Char(1);
02DF  3001  	MOVLW 0x01
02E0  00E0  	MOVWF FCD_RS2320_00060_arg_nTimeout
02E1  225B  	CALL FCD_RS2320_00060
02E2  0861  	MOVF CompTempVarRet2215, W
02E3  00CA  	MOVWF gbl_FCV_RX


				//Decision
				//Decision: rx > 47 AND rx < 58?
				if (FCV_RX > 47 & FCV_RX < 58)
02E4  01DB  	CLRF CompTempVar2227
02E5  084A  	MOVF gbl_FCV_RX, W
02E6  3C2F  	SUBLW 0x2F
02E7  1C03  	BTFSS STATUS,C
02E8  0ADB  	INCF CompTempVar2227, F
02E9  01DA  	CLRF CompTempVar2226
02EA  303A  	MOVLW 0x3A
02EB  024A  	SUBWF gbl_FCV_RX, W
02EC  1C03  	BTFSS STATUS,C
02ED  0ADA  	INCF CompTempVar2226, F
02EE  085A  	MOVF CompTempVar2226, W
02EF  055B  	ANDWF CompTempVar2227, W
02F0  1903  	BTFSC STATUS,Z
02F1  2AF5  	GOTO	label33
02F5        label33

				{

					//Calculation
					//Calculation:
					//  minute_tens = rx - 48
					FCV_MINUTE_TENS = FCV_RX - 48;
02F2  3030  	MOVLW 0x30
02F3  024A  	SUBWF gbl_FCV_RX, W
02F4  00C7  	MOVWF gbl_FCV_MINUTE_TENS


				// } else {

				}

				//Call Component Macro
				//Call Component Macro: rx=ReceiveRS232Char(1)
				FCV_RX = FCD_RS2320_ReceiveRS232Char(1);
02F5  3001  	MOVLW 0x01
02F6  00E0  	MOVWF FCD_RS2320_00060_arg_nTimeout
02F7  225B  	CALL FCD_RS2320_00060
02F8  0861  	MOVF CompTempVarRet2215, W
02F9  00CA  	MOVWF gbl_FCV_RX


				//Decision
				//Decision: rx > 47 AND rx < 58?
				if (FCV_RX > 47 & FCV_RX < 58)
02FA  01DD  	CLRF CompTempVar2229
02FB  084A  	MOVF gbl_FCV_RX, W
02FC  3C2F  	SUBLW 0x2F
02FD  1C03  	BTFSS STATUS,C
02FE  0ADD  	INCF CompTempVar2229, F
02FF  01DC  	CLRF CompTempVar2228
0300  303A  	MOVLW 0x3A
0301  024A  	SUBWF gbl_FCV_RX, W
0302  1C03  	BTFSS STATUS,C
0303  0ADC  	INCF CompTempVar2228, F
0304  085C  	MOVF CompTempVar2228, W
0305  055D  	ANDWF CompTempVar2229, W
0306  1903  	BTFSC STATUS,Z
0307  2B0B  	GOTO	label34
030B        label34

				{

					//Calculation
					//Calculation:
					//  minute_ones = rx - 48
					FCV_MINUTE_ONES = FCV_RX - 48;
0308  3030  	MOVLW 0x30
0309  024A  	SUBWF gbl_FCV_RX, W
030A  00CE  	MOVWF gbl_FCV_MINUTE_ONES


				// } else {

				}

				//Connection Point
				//Connection Point: [B]: B
FCC_Main_B:
;

				//Call Component Macro
				//Call Component Macro: rx=ReceiveRS232Char(1)
				FCV_RX = FCD_RS2320_ReceiveRS232Char(1);
030B  3001  	MOVLW 0x01
030C  00E0  	MOVWF FCD_RS2320_00060_arg_nTimeout
030D  225B  	CALL FCD_RS2320_00060
030E  0861  	MOVF CompTempVarRet2215, W
030F  00CA  	MOVWF gbl_FCV_RX


				//Decision
				//Decision: rx = 'B'?
				if (FCV_RX == 'B')
0310  084A  	MOVF gbl_FCV_RX, W
0311  3A42  	XORLW 0x42
0312  1D03  	BTFSS STATUS,Z
0313  2B0B  	GOTO	label34
0314        label35

				{

					//Loop
					//Loop: While rx > 47 AND rx < 58
					while (1)
0326  2B14  	GOTO	label35

					{

						//Call Component Macro
						//Call Component Macro: rx=ReceiveRS232Char(1)
						FCV_RX = FCD_RS2320_ReceiveRS232Char(1);
0314  3001  	MOVLW 0x01
0315  00E0  	MOVWF FCD_RS2320_00060_arg_nTimeout
0316  225B  	CALL FCD_RS2320_00060
0317  0861  	MOVF CompTempVarRet2215, W
0318  00CA  	MOVWF gbl_FCV_RX



						if ((FCV_RX > 47 & FCV_RX < 58) != 0) break;
0319  01DF  	CLRF CompTempVar2231
031A  084A  	MOVF gbl_FCV_RX, W
031B  3C2F  	SUBLW 0x2F
031C  1C03  	BTFSS STATUS,C
031D  0ADF  	INCF CompTempVar2231, F
031E  01DE  	CLRF CompTempVar2230
031F  303A  	MOVLW 0x3A
0320  024A  	SUBWF gbl_FCV_RX, W
0321  1C03  	BTFSS STATUS,C
0322  0ADE  	INCF CompTempVar2230, F
0323  085E  	MOVF CompTempVar2230, W
0324  055F  	ANDWF CompTempVar2231, W
0325  1903  	BTFSC STATUS,Z

					}

					//Calculation
					//Calculation:
					//  seconds_tens = rx - 48
					FCV_SECONDS_TENS = FCV_RX - 48;
0327  3030  	MOVLW 0x30
0328  024A  	SUBWF gbl_FCV_RX, W
0329  00CB  	MOVWF gbl_FCV_SECONDS_TENS


					//Loop
					//Loop: While rx > 47 AND rx < 58
					while (1)
032A        label36
033C  2B2A  	GOTO	label36

					{

						//Call Component Macro
						//Call Component Macro: rx=ReceiveRS232Char(1)
						FCV_RX = FCD_RS2320_ReceiveRS232Char(1);
032A  3001  	MOVLW 0x01
032B  00E0  	MOVWF FCD_RS2320_00060_arg_nTimeout
032C  225B  	CALL FCD_RS2320_00060
032D  0861  	MOVF CompTempVarRet2215, W
032E  00CA  	MOVWF gbl_FCV_RX



						if ((FCV_RX > 47 & FCV_RX < 58) != 0) break;
032F  01DF  	CLRF CompTempVar2233
0330  084A  	MOVF gbl_FCV_RX, W
0331  3C2F  	SUBLW 0x2F
0332  1C03  	BTFSS STATUS,C
0333  0ADF  	INCF CompTempVar2233, F
0334  01DE  	CLRF CompTempVar2232
0335  303A  	MOVLW 0x3A
0336  024A  	SUBWF gbl_FCV_RX, W
0337  1C03  	BTFSS STATUS,C
0338  0ADE  	INCF CompTempVar2232, F
0339  085E  	MOVF CompTempVar2232, W
033A  055F  	ANDWF CompTempVar2233, W
033B  1903  	BTFSC STATUS,Z

					}

					//Calculation
					//Calculation:
					//  seconds_ones = rx - 48
					FCV_SECONDS_ONES = FCV_RX - 48;
033D  3030  	MOVLW 0x30
033E  024A  	SUBWF gbl_FCV_RX, W
033F  00D1  	MOVWF gbl_FCV_SECONDS_ONES


				} else {

					//Goto Connection Point
					//Goto Connection Point: [B]: B
					goto FCC_Main_B;


				}

				//Connection Point
				//Connection Point: [C]: C
FCC_Main_C:
;

				//Call Component Macro
				//Call Component Macro: rx=ReceiveRS232Char(1)
				FCV_RX = FCD_RS2320_ReceiveRS232Char(1);
0340  3001  	MOVLW 0x01
0341  00E0  	MOVWF FCD_RS2320_00060_arg_nTimeout
0342  225B  	CALL FCD_RS2320_00060
0343  0861  	MOVF CompTempVarRet2215, W
0344  00CA  	MOVWF gbl_FCV_RX


				//Decision
				//Decision: rx = 'C'?
				if (FCV_RX == 'C')
0345  084A  	MOVF gbl_FCV_RX, W
0346  3A43  	XORLW 0x43
0347  1D03  	BTFSS STATUS,Z
0348  2B40  	GOTO	label37
0349        label38

				{

					//Loop
					//Loop: While rx > 47 AND rx < 58
					while (1)
035B  2B49  	GOTO	label38

					{

						//Call Component Macro
						//Call Component Macro: rx=ReceiveRS232Char(1)
						FCV_RX = FCD_RS2320_ReceiveRS232Char(1);
0349  3001  	MOVLW 0x01
034A  00E0  	MOVWF FCD_RS2320_00060_arg_nTimeout
034B  225B  	CALL FCD_RS2320_00060
034C  0861  	MOVF CompTempVarRet2215, W
034D  00CA  	MOVWF gbl_FCV_RX



						if ((FCV_RX > 47 & FCV_RX < 58) != 0) break;
034E  01DF  	CLRF CompTempVar2235
034F  084A  	MOVF gbl_FCV_RX, W
0350  3C2F  	SUBLW 0x2F
0351  1C03  	BTFSS STATUS,C
0352  0ADF  	INCF CompTempVar2235, F
0353  01DE  	CLRF CompTempVar2234
0354  303A  	MOVLW 0x3A
0355  024A  	SUBWF gbl_FCV_RX, W
0356  1C03  	BTFSS STATUS,C
0357  0ADE  	INCF CompTempVar2234, F
0358  085E  	MOVF CompTempVar2234, W
0359  055F  	ANDWF CompTempVar2235, W
035A  1903  	BTFSC STATUS,Z

					}

					//Calculation
					//Calculation:
					//  home_foul = rx - 48
					FCV_HOME_FOUL = FCV_RX - 48;
035C  3030  	MOVLW 0x30
035D  024A  	SUBWF gbl_FCV_RX, W
035E  00C6  	MOVWF gbl_FCV_HOME_FOUL


				} else {

					//Goto Connection Point
					//Goto Connection Point: [C]: C
					goto FCC_Main_C;


				}

				//Connection Point
				//Connection Point: [D]: D
FCC_Main_D:
;

				//Call Component Macro
				//Call Component Macro: rx=ReceiveRS232Char(1)
				FCV_RX = FCD_RS2320_ReceiveRS232Char(1);
035F  3001  	MOVLW 0x01
0360  00E0  	MOVWF FCD_RS2320_00060_arg_nTimeout
0361  225B  	CALL FCD_RS2320_00060
0362  0861  	MOVF CompTempVarRet2215, W
0363  00CA  	MOVWF gbl_FCV_RX


				//Decision
				//Decision: rx = 'D'?
				if (FCV_RX == 'D')
0364  084A  	MOVF gbl_FCV_RX, W
0365  3A44  	XORLW 0x44
0366  1D03  	BTFSS STATUS,Z
0367  2B5F  	GOTO	label39
0368        label40

				{

					//Loop
					//Loop: While rx > 47 AND rx < 58
					while (1)
037A  2B68  	GOTO	label40

					{

						//Call Component Macro
						//Call Component Macro: rx=ReceiveRS232Char(1)
						FCV_RX = FCD_RS2320_ReceiveRS232Char(1);
0368  3001  	MOVLW 0x01
0369  00E0  	MOVWF FCD_RS2320_00060_arg_nTimeout
036A  225B  	CALL FCD_RS2320_00060
036B  0861  	MOVF CompTempVarRet2215, W
036C  00CA  	MOVWF gbl_FCV_RX



						if ((FCV_RX > 47 & FCV_RX < 58) != 0) break;
036D  01DF  	CLRF CompTempVar2237
036E  084A  	MOVF gbl_FCV_RX, W
036F  3C2F  	SUBLW 0x2F
0370  1C03  	BTFSS STATUS,C
0371  0ADF  	INCF CompTempVar2237, F
0372  01DE  	CLRF CompTempVar2236
0373  303A  	MOVLW 0x3A
0374  024A  	SUBWF gbl_FCV_RX, W
0375  1C03  	BTFSS STATUS,C
0376  0ADE  	INCF CompTempVar2236, F
0377  085E  	MOVF CompTempVar2236, W
0378  055F  	ANDWF CompTempVar2237, W
0379  1903  	BTFSC STATUS,Z

					}

					//Calculation
					//Calculation:
					//  period = rx - 48
					FCV_PERIOD = FCV_RX - 48;
037B  3030  	MOVLW 0x30
037C  024A  	SUBWF gbl_FCV_RX, W
037D  00C4  	MOVWF gbl_FCV_PERIOD


				} else {

					//Goto Connection Point
					//Goto Connection Point: [D]: D
					goto FCC_Main_D;


				}

			} else {

				//Goto Connection Point
				//Goto Connection Point: [A]: A
				goto FCC_Main_A;


			}

			//Calculation
			//Calculation:
			//  score_away = 89
			//  score_home = 71
			//  flag = 1
			FCV_SCORE_AWAY = 89;
037E  3059  	MOVLW 0x59
037F  00CC  	MOVWF gbl_FCV_SCORE_AWAY

			FCV_SCORE_HOME = 71;
0380  3047  	MOVLW 0x47
0381  00D2  	MOVWF gbl_FCV_SCORE_HOME

			FCV_FLAG = 1;
0382  1543  	BSF gbl_FCV_FLAG,2


		// } else {

		}

		//Calculation
		//Calculation:
		//  away_tens = score_away / 10
		//  away_ones = score_away % 10
		//  home_tens = score_home / 10
		//  home_ones = score_home % 10
		FCV_AWAY_TENS = FCV_SCORE_AWAY / 10;
0383  084C  	MOVF gbl_FCV_SCORE_AWAY, W
0384  00DA  	MOVWF __div_8_8_00000_arg_a
0385  300A  	MOVLW 0x0A
0386  00DB  	MOVWF __div_8_8_00000_arg_b
0387  218A  	CALL __div_8_8_00000
0388  085E  	MOVF CompTempVarRet218, W
0389  00C8  	MOVWF gbl_FCV_AWAY_TENS

		FCV_AWAY_ONES = FCV_SCORE_AWAY % 10;
038A  084C  	MOVF gbl_FCV_SCORE_AWAY, W
038B  00DA  	MOVWF __rem_8_8_00000_arg_a
038C  300A  	MOVLW 0x0A
038D  00DB  	MOVWF __rem_8_8_00000_arg_b
038E  2179  	CALL __rem_8_8_00000
038F  085E  	MOVF CompTempVarRet220, W
0390  00CF  	MOVWF gbl_FCV_AWAY_ONES

		FCV_HOME_TENS = FCV_SCORE_HOME / 10;
0391  0852  	MOVF gbl_FCV_SCORE_HOME, W
0392  00DA  	MOVWF __div_8_8_00000_arg_a
0393  300A  	MOVLW 0x0A
0394  00DB  	MOVWF __div_8_8_00000_arg_b
0395  218A  	CALL __div_8_8_00000
0396  085E  	MOVF CompTempVarRet218, W
0397  00D0  	MOVWF gbl_FCV_HOME_TENS

		FCV_HOME_ONES = FCV_SCORE_HOME % 10;
0398  0852  	MOVF gbl_FCV_SCORE_HOME, W
0399  00DA  	MOVWF __rem_8_8_00000_arg_a
039A  300A  	MOVLW 0x0A
039B  00DB  	MOVWF __rem_8_8_00000_arg_b
039C  2179  	CALL __rem_8_8_00000
039D  085E  	MOVF CompTempVarRet220, W
039E  00C2  	MOVWF gbl_FCV_HOME_ONES


		//Call Macro
		//Call Macro: display_score()
		FCM_display_score();
039F  2220  	CALL FCM_displa_00054


		//Call Macro
		//Call Macro: display_time()
		FCM_display_time();
03A0  21E5  	CALL FCM_displa_00055


		//Call Macro
		//Call Macro: foulperiod_display()
		FCM_foulperiod_display();
03A1  21AA  	CALL FCM_foulpe_00058



	}

	//score_data
	//Output: dat -> C3
	trisc = trisc & 0xF7;

	if ((FCV_DAT))
		portc = (portc & 0xF7) | 0x08;

	else
		portc = portc & 0xF7;


	//time_data
	//Output: dat -> C2
	trisc = trisc & 0xFB;

	if ((FCV_DAT))
		portc = (portc & 0xFB) | 0x04;

	else
		portc = portc & 0xFB;


	mainendloop: goto mainendloop;
}


void MX_INTERRUPT_MACRO(void)

{
}
03DB  1283  	BCF STATUS, RP0
03DC  1303  	BCF STATUS, RP1
03DD  0E36  	SWAPF Int1BContext+D'2', W
03DE  0084  	MOVWF FSR
03DF  0E35  	SWAPF Int1BContext+D'1', W
03E0  008A  	MOVWF PCLATH
03E1  0E34  	SWAPF Int1BContext, W
03E2  0083  	MOVWF STATUS
03E3  0EFF  	SWAPF Int1Context, F
03E4  0E7F  	SWAPF Int1Context, W
03E5  0009  	RETFIE





/*********************************************************************
 *                  Flowcode CAL UART File
 *
 * File: PIC_CAL_UART.c
 *
 * (c) 2011 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * Company) for its Flowcode graphical programming language is
 * intended and supplied to you, the Companys customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 010911 | BR | Created
 * 020911 | BR | Updated variables with typedef alternatives
 * 011211 | BR | Converted to new dynamic defines mechanism
 * 160112 | BR | Fixed issues with rx return type and low bauds on fast devices
 * 020212 | ST | Added <MX_UART_2_PIE4> routing to account for differences in 16F and 18F devices with 2 UARTs
 * 270212 | BR | Fixed a bug in the receive functionality
 * 280212 | BR | Sorted out auto echo functionality
 * 160412 | BR | Addition of HW change baud function
 */



#ifndef MX_UART_SW_DEFS
	#define MX_UART_SW_DEFS

	#ifdef _BOOSTC
		#define INST_COUNT	45	//65 for lower speeds or 40 for higher speeds.
	#endif
	#ifdef HI_TECH_C
		#define INST_COUNT	315
	#endif

	//Work out number of nops for software baud rate
	#define MX_INSTRUCTION_SPEED 	(MX_CLK_SPEED / 4)
	#define MX_OVERHEAD				(MX_INSTRUCTION_SPEED / INST_COUNT)
	#define SW_OFFSET				(1000000 / MX_OVERHEAD)

	//Work out software baud rates if required
	#define SW_1200_BAUD	(832 - SW_OFFSET)
	#define SW_2400_BAUD	(416 - SW_OFFSET)
	#define SW_4800_BAUD	(208 - SW_OFFSET)
	#define SW_9600_BAUD	(104 - SW_OFFSET)
	#define SW_19200_BAUD	(52 - SW_OFFSET)
	#define SW_31250_BAUD	(32 - SW_OFFSET)
	#define SW_115200_BAUD	(8 - SW_OFFSET)
#endif

 #if defined(MX_UART_CHANNEL_1) && (MX_UART_NUM==1)
	#if (MX_UART_CHANNEL_1 == 0)
		#if (MX_UART_BAUD_1 == 1200)
			#define MX_SOFT_BAUD_1	SW_1200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 1200 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_1 == 2400)
			#define MX_SOFT_BAUD_1	SW_2400_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 2400 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_1 == 4800)
			#define MX_SOFT_BAUD_1	SW_4800_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 4800 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_1 == 9600)
			#define MX_SOFT_BAUD_1	SW_9600_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 9600 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_1 == 19200)
			#define MX_SOFT_BAUD_1	SW_19200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 19200 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_1 == 31250)
			#define MX_SOFT_BAUD_1	SW_31250_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 31250 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_1 == 115200)
			#define MX_SOFT_BAUD_1	SW_115200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 115200 Not Available At This Clock Speed"
			#endif
		#endif
		#ifndef MX_SOFT_BAUD_1
			#error "UART Baud Rate not supported in Software Mode"
		#endif
	#else
		#define MX_SOFT_BAUD_1	1
		#define MX_HARD_BAUD_1	(((MX_CLK_SPEED / MX_UART_BAUD_1) - 16) / 16)
		#define MX_HARD_SLOW_1	0

		#if (MX_HARD_BAUD_1 > 255)
			#undef MX_HARD_BAUD_1
			#undef MX_HARD_SLOW_1
			#define MX_HARD_BAUD_1	(((MX_CLK_SPEED / MX_UART_BAUD_1) - 16)	/ 64)
			#define MX_HARD_SLOW_1	1
		#endif

	#endif
 #endif
 #if defined(MX_UART_CHANNEL_2) && (MX_UART_NUM==2)
	#if (MX_UART_CHANNEL_2 == 0)
		#if (MX_UART_BAUD_2 == 1200)
			#define MX_SOFT_BAUD_2	SW_1200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 1200 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_2 == 2400)
			#define MX_SOFT_BAUD_2	SW_2400_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 2400 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_2 == 4800)
			#define MX_SOFT_BAUD_2	SW_4800_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 4800 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_2 == 9600)
			#define MX_SOFT_BAUD_2	SW_9600_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 9600 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_2 == 19200)
			#define MX_SOFT_BAUD_2	SW_19200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 19200 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_2 == 31250)
			#define MX_SOFT_BAUD_2	SW_31250_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 31250 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_2 == 115200)
			#define MX_SOFT_BAUD_2	SW_115200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 115200 Not Available At This Clock Speed"
			#endif
		#endif
		#ifndef MX_SOFT_BAUD_2
			#error "UART Baud Rate not supported in Software Mode"
		#endif
	#else
		#define MX_SOFT_BAUD_2	1
		#define MX_HARD_BAUD_2	(((MX_CLK_SPEED / MX_UART_BAUD_2) - 16) / 16)
		#define MX_HARD_SLOW_2	0

		#if (MX_HARD_BAUD_2 > 255)
			#undef MX_HARD_BAUD_2
			#undef MX_HARD_SLOW_2
			#define MX_HARD_BAUD_2	(((MX_CLK_SPEED / MX_UART_BAUD_2) - 16)	/ 64)
			#define MX_HARD_SLOW_2	1
		#endif
 	#endif
 #endif
 #if defined(MX_UART_CHANNEL_3) && (MX_UART_NUM==3)
	#if (MX_UART_CHANNEL_3 == 0)
		#if (MX_UART_BAUD_3 == 1200)
			#define MX_SOFT_BAUD_3	SW_1200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 1200 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_3 == 2400)
			#define MX_SOFT_BAUD_3	SW_2400_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 2400 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_3 == 4800)
			#define MX_SOFT_BAUD_3	SW_4800_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 4800 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_3 == 9600)
			#define MX_SOFT_BAUD_3	SW_9600_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 9600 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_3 == 19200)
			#define MX_SOFT_BAUD_3	SW_19200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 19200 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_3 == 31250)
			#define MX_SOFT_BAUD_3	SW_31250_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 31250 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_3 == 115200)
			#define MX_SOFT_BAUD_3	SW_115200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 115200 Not Available At This Clock Speed"
			#endif
		#endif
		#ifndef MX_SOFT_BAUD_3
			#error "UART Baud Rate not supported in Software Mode"
		#endif
	#else
		#define MX_SOFT_BAUD_3	1
		#define MX_HARD_BAUD_3	(((MX_CLK_SPEED / MX_UART_BAUD_3) - 16) / 16)
		#define MX_HARD_SLOW_3	0

		#if (MX_HARD_BAUD_3 > 255)
			#undef MX_HARD_BAUD_3
			#undef MX_HARD_SLOW_3
			#define MX_HARD_BAUD_3	(((MX_CLK_SPEED / MX_UART_BAUD_3) - 16)	/ 64)
			#define MX_HARD_SLOW_3	1
		#endif
	#endif
 #endif
 #if defined(MX_UART_CHANNEL_4) && (MX_UART_NUM==4)
	#if (MX_UART_CHANNEL_4 == 0)
		#if (MX_UART_BAUD_4 == 1200)
			#define MX_SOFT_BAUD_4	SW_1200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 1200 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_4 == 2400)
			#define MX_SOFT_BAUD_4	SW_2400_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 2400 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_4 == 4800)
			#define MX_SOFT_BAUD_4	SW_4800_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 4800 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_4 == 9600)
			#define MX_SOFT_BAUD_4	SW_9600_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 9600 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_4 == 19200)
			#define MX_SOFT_BAUD_4	SW_19200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 19200 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_4 == 31250)
			#define MX_SOFT_BAUD_4	SW_31250_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 31250 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_4 == 115200)
			#define MX_SOFT_BAUD_4	SW_115200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 115200 Not Available At This Clock Speed"
			#endif
		#endif
		#ifndef MX_SOFT_BAUD_4
			#error "UART Baud Rate not supported in Software Mode"
		#endif
	#else
		#define MX_SOFT_BAUD_4	1
		#define MX_HARD_BAUD_4	(((MX_CLK_SPEED / MX_UART_BAUD_4) - 16) / 16)
		#define MX_HARD_SLOW_4	0

		#if (MX_HARD_BAUD_4 > 255)
			#undef MX_HARD_BAUD_4
			#undef MX_HARD_SLOW_4
			#define MX_HARD_BAUD_4	(((MX_CLK_SPEED / MX_UART_BAUD_4) - 16)	/ 64)
			#define MX_HARD_SLOW_4	1
		#endif
	#endif
 #endif


//Hardware Baud update definitions
#ifndef MX_HARD_BAUD_CHANGE_DEFS
	#define MX_HARD_BAUD_CHANGE_DEFS

	#define MX_HARD_BAUD_1200	(((MX_CLK_SPEED / 1200) - 16) / 16)
	#if (MX_HARD_BAUD_1200 > 255)
		#undef MX_HARD_BAUD_1200
		#define MX_HARD_BAUD_1200	(((MX_CLK_SPEED / 1200) - 16) / 64)
		#define MX_HARD_SLOW_1200	1
	#else
		#define MX_HARD_SLOW_1200	0
	#endif

	#define MX_HARD_BAUD_2400	(((MX_CLK_SPEED / 2400) - 16) / 16)
	#if (MX_HARD_BAUD_2400 > 255)
		#undef MX_HARD_BAUD_2400
		#define MX_HARD_BAUD_2400	(((MX_CLK_SPEED / 2400) - 16) / 64)
		#define MX_HARD_SLOW_2400	1
	#else
		#define MX_HARD_SLOW_2400	0
	#endif

	#define MX_HARD_BAUD_4800	(((MX_CLK_SPEED / 4800) - 16) / 16)
	#if (MX_HARD_BAUD_4800 > 255)
		#undef MX_HARD_BAUD_4800
		#define MX_HARD_BAUD_4800	(((MX_CLK_SPEED / 4800) - 16) / 64)
		#define MX_HARD_SLOW_4800	1
	#else
		#define MX_HARD_SLOW_4800	0
	#endif

	#define MX_HARD_BAUD_9600	(((MX_CLK_SPEED / 9600) - 16) / 16)
	#if (MX_HARD_BAUD_9600 > 255)
		#undef MX_HARD_BAUD_9600
		#define MX_HARD_BAUD_9600	(((MX_CLK_SPEED / 9600) - 16) / 64)
		#define MX_HARD_SLOW_9600	1
	#else
		#define MX_HARD_SLOW_9600	0
	#endif

	#define MX_HARD_BAUD_19200	(((MX_CLK_SPEED / 19200) - 16) / 16)
	#if (MX_HARD_BAUD_19200 > 255)
		#undef MX_HARD_BAUD_19200
		#define MX_HARD_BAUD_19200	(((MX_CLK_SPEED / 19200) - 16) / 64)
		#define MX_HARD_SLOW_19200	1
	#else
		#define MX_HARD_SLOW_19200	0
	#endif

	#define MX_HARD_BAUD_38400	(((MX_CLK_SPEED / 38400) - 16) / 16)
	#if (MX_HARD_BAUD_38400 > 255)
		#undef MX_HARD_BAUD_38400
		#define MX_HARD_BAUD_38400	(((MX_CLK_SPEED / 38400) - 16) / 64)
		#define MX_HARD_SLOW_38400	1
	#else
		#define MX_HARD_SLOW_38400	0
	#endif

	#define MX_HARD_BAUD_57600	(((MX_CLK_SPEED / 57600) - 16) / 16)
	#if (MX_HARD_BAUD_57600 > 255)
		#undef MX_HARD_BAUD_57600
		#define MX_HARD_BAUD_57600	(((MX_CLK_SPEED / 57600) - 16) / 64)
		#define MX_HARD_SLOW_57600	1
	#else
		#define MX_HARD_SLOW_57600	0
	#endif

	#define MX_HARD_BAUD_115200	(((MX_CLK_SPEED / 115200) - 16) / 16)
	#if (MX_HARD_BAUD_115200 > 255)
		#undef MX_HARD_BAUD_115200
		#define MX_HARD_BAUD_115200	(((MX_CLK_SPEED / 115200) - 16) / 64)
		#define MX_HARD_SLOW_115200	1
	#else
		#define MX_HARD_SLOW_115200	0
	#endif
#endif


//Dynamic function naming based on defines and index number
#define MX_UART_CHANNEL_X	CAL_APPEND(MX_UART_CHANNEL_, MX_UART_NUM)
#define MX_UART_TX_PIN_X	CAL_APPEND(MX_UART_TX_PIN_, MX_UART_NUM)
#define MX_UART_TX_PORT_X	CAL_APPEND(MX_UART_TX_PORT_, MX_UART_NUM)
#define MX_UART_TX_TRIS_X	CAL_APPEND(MX_UART_TX_TRIS_, MX_UART_NUM)
#define MX_UART_RX_PIN_X	CAL_APPEND(MX_UART_RX_PIN_, MX_UART_NUM)
#define MX_UART_RX_PORT_X	CAL_APPEND(MX_UART_RX_PORT_, MX_UART_NUM)
#define MX_UART_RX_TRIS_X	CAL_APPEND(MX_UART_RX_TRIS_, MX_UART_NUM)
#define MX_UART_FLOWEN_X	CAL_APPEND(MX_UART_FLOWEN_, MX_UART_NUM)
#define MX_UART_CTS_PIN_X	CAL_APPEND(MX_UART_CTS_PIN_, MX_UART_NUM)
#define MX_UART_CTS_PORT_X	CAL_APPEND(MX_UART_CTS_PORT_, MX_UART_NUM)
#define MX_UART_CTS_TRIS_X	CAL_APPEND(MX_UART_CTS_TRIS_, MX_UART_NUM)
#define MX_UART_RTS_PIN_X	CAL_APPEND(MX_UART_RTS_PIN_, MX_UART_NUM)
#define MX_UART_RTS_PORT_X	CAL_APPEND(MX_UART_RTS_PORT_, MX_UART_NUM)
#define MX_UART_RTS_TRIS_X	CAL_APPEND(MX_UART_RTS_TRIS_, MX_UART_NUM)
#define MX_UART_DBITS_X		CAL_APPEND(MX_UART_DBITS_, MX_UART_NUM)
#define MX_UART_RETURN_X	CAL_APPEND(MX_UART_RETURN_, MX_UART_NUM)
#define MX_UART_ECHO_X		CAL_APPEND(MX_UART_ECHO_, MX_UART_NUM)
#define MX_UART_INT_X		CAL_APPEND(MX_UART_INT_, MX_UART_NUM)
#define MX_UART_BAUD_X		CAL_APPEND(MX_HARD_BAUD_, MX_UART_NUM)
#define MX_SOFT_BAUD_X		CAL_APPEND(MX_SOFT_BAUD_, MX_UART_NUM)
#define MX_HARD_SLOW_X		CAL_APPEND(MX_HARD_SLOW_, MX_UART_NUM)

#define UART_Delay_CAL		CAL_APPEND(FC_CAL_UART_Delay_, MX_UART_NUM)
#define UART_Send			CAL_APPEND(FC_CAL_UART_Send_, MX_UART_NUM)
#define UART_Uninit			CAL_APPEND(FC_CAL_UART_Uninit_, MX_UART_NUM)


//Component Definitions
#define UART_STATUS_LOOP	0
#define UART_STATUS_TIMEOUT	1
#define UART_STATUS_RXBYTE	2


//Interrupt Definitions
#ifdef MX_UART_2_PIE4
  #define MX_UART2_PIE pie4
  #define MX_UART2_PIR pir4
  #define MX_UART2_TXSTA tx2sta
  #define MX_UART2_RCSTA rc2sta
  #define MX_UART2_TXREG tx2reg
  #define MX_UART2_RCREG rc2reg
#else
  #define MX_UART2_PIE pie3
  #define MX_UART2_PIR pir3
  #define MX_UART2_TXSTA txsta2
  #define MX_UART2_RCSTA rcsta2
  #define MX_UART2_TXREG txreg2
  #define MX_UART2_RCREG rcreg2
#endif

#if (MX_UART_INT_X == 1)

	#ifndef MX_UART_INT_DEFS
	#define MX_UART_INT_DEFS

		#define MX_UART_INT_CH1_FUNC
		#define MX_UART_INT_CH2_FUNC
		#define MX_UART_INT_FUNC_END

		#define MX_UART_INT_CH1_DET		ts_bit(pir1, RCIF) && ts_bit(pie1, RCIE)
		#define MX_UART_INT_CH2_DET		ts_bit(MX_UART2_PIR, RC2IF) && ts_bit(MX_UART2_PIE, RC2IE)

		#define MX_UART_INT_CH1_EN		st_bit (pie1, RCIE)
		#define MX_UART_INT_CH2_EN		st_bit (MX_UART2_PIE, RC2IE)

		#define MX_UART_INT_CH1_DIS		cr_bit (pie1, RCIE)
		#define MX_UART_INT_CH2_DIS		cr_bit (MX_UART2_PIE, RC2IE)

		#define MX_UART_INT_CH1_CLR		cr_bit (pir1, RCIF)
		#define MX_UART_INT_CH2_CLR		cr_bit (MX_UART2_PIR, RC2IF)

	#endif
#endif


//Function Prototypes
CALFUNCTION(void, FC_CAL_UART_Init_, (void));
CALFUNCTION(void, FC_CAL_UART_Uninit_, (void));
CALFUNCTION(void, FC_CAL_UART_Send_, (MX_UINT16 nChar));
CALFUNCTION(MX_SINT16, FC_CAL_UART_Receive_, (MX_UINT8 nTimeout));
CALFUNCTION(void, FC_CAL_UART_Delay_, (void));


//Peripheral Functions
CALFUNCTION(void, FC_CAL_UART_Init_, (void))

{

	#if (MX_UART_CHANNEL_X == 0)
		FC_CAL_Bit_In_DDR 	(MX_UART_RX_PORT_X, MX_UART_RX_TRIS_X, MX_UART_RX_PIN_X);		// Receive pin is a input
		FC_CAL_Bit_High_DDR (MX_UART_TX_PORT_X, MX_UART_TX_TRIS_X, MX_UART_TX_PIN_X);		// Transmit pin is default high
	#endif

	#if (MX_UART_CHANNEL_X == 1)
	  #ifndef MX_UART_1
	  	  #error "UART channel 1 not available on this device"
	  #else
		  #if (MX_HARD_SLOW_X == 1)
			cr_bit(txsta, BRGH);						//Low Speed
		  #else
			st_bit(txsta, BRGH);						//High Speed
019B  1683  	BSF STATUS, RP0
019C  1303  	BCF STATUS, RP1
019D  1518  	BSF gbl_txsta,2

		  #endif
			spbrg = MX_UART_BAUD_X;   					// set the baud rate
019E  3081  	MOVLW 0x81
019F  0099  	MOVWF gbl_spbrg

			rcsta = 0;                    				// 8-bit, disabled
01A0  1283  	BCF STATUS, RP0
01A1  0198  	CLRF gbl_rcsta


			#if(MX_UART_DBITS_X == 9)
				st_bit(txsta, TX9);   					// 9-bit TX
				st_bit(rcsta, RX9);                    	// 9-bit RX
			#endif

			st_bit(rcsta, SPEN);         				// turn on serial interface
01A2  1798  	BSF gbl_rcsta,7

			st_bit(txsta, TXEN);
01A3  1683  	BSF STATUS, RP0
01A4  1698  	BSF gbl_txsta,5

			st_bit(rcsta, CREN);
01A5  1283  	BCF STATUS, RP0
01A6  1618  	BSF gbl_rcsta,4


			#if (MX_UART_INT_X == 1)
				MX_UART_INT_CH1_EN;
				st_bit(intcon, PEIE);
				st_bit(intcon, GIE);
			#else
				cr_bit (pie1, RCIE);
01A7  1683  	BSF STATUS, RP0
01A8  128C  	BCF gbl_pie1,5

			#endif
	  #endif
	#endif


	#if (MX_UART_CHANNEL_X == 2)

	  #ifndef MX_UART_2
		  #error "UART channel 2 not available on this device"
	  #else
		  #ifdef MX_UART_2_REMAPPABLE
			RPOR9 = 5;									//TX2 - RP9 - RB6
			RPINR16	= 10;								//RX2 - RP10 - RB7
		  #endif
		  #if (MX_HARD_SLOW_X == 1)
			cr_bit(MX_UART2_TXSTA, BRGH);						//Low Speed
		  #else
			st_bit(MX_UART2_TXSTA, BRGH);						//High Speed
		  #endif
			spbrg2 = MX_UART_BAUD_X;   				// set the baud rate
			MX_UART2_RCSTA = 0;                    				// 8-bit, disabled

			#if(MX_UART_DBITS_X == 9)
				st_bit(MX_UART2_TXSTA, TX9);   					// 9-bit TX
				st_bit(MX_UART2_RCSTA, RX9);                    // 9-bit RX
			#endif

			st_bit(MX_UART2_RCSTA, SPEN);         				// turn on serial interface
			st_bit(MX_UART2_TXSTA, TXEN);
			st_bit(MX_UART2_RCSTA, CREN);

			#if (MX_UART_INT_X == 1)
				MX_UART_INT_CH2_EN;
				st_bit(intcon, PEIE);
				st_bit(intcon, GIE);
			#else
				cr_bit (MX_UART2_PIE, RC2IE);
			#endif
	  #endif
	#endif

	#if (MX_UART_FLOWEN_X == 1)						//Flowcontrol enabled?
		FC_CAL_Bit_In_DDR (MX_UART_CTS_PORT_X, MX_UART_CTS_TRIS_X, MX_UART_CTS_PIN_X);	// CTS pin is a input
		FC_CAL_Bit_High_DDR (MX_UART_RTS_PORT_X, MX_UART_RTS_TRIS_X, MX_UART_RTS_PIN_X);	// RTS not ready to accept data
	#endif

}
01A9  0008  	RETURN




CALFUNCTION(void, FC_CAL_UART_Uninit_, (void))
{

	#if (MX_UART_CHANNEL_X == 0)
		FC_CAL_Bit_In_DDR (MX_UART_RX_PORT_X, MX_UART_RX_TRIS_X, MX_UART_RX_PIN_X);		// Receive pin is a input
		FC_CAL_Bit_In_DDR (MX_UART_TX_PORT_X, MX_UART_TX_TRIS_X, MX_UART_TX_PIN_X);		// Transmit pin is default high
	#endif

	#if (MX_UART_CHANNEL_X == 1)
			rcsta = 0;                    								// 8-bit, disabled
			txsta = 0;
		  #ifdef MX_UART_RXINT
			MX_UART_INT_CH1_DIS;
		  #endif
	#endif

	#if (MX_UART_CHANNEL_X == 2)
			MX_UART2_RCSTA = 0;                    								// 8-bit, disabled
			MX_UART2_TXSTA = 0;
		  #ifdef MX_UART_RXINT
			MX_UART_INT_CH2_DIS;
		  #endif
	#endif

	#if (MX_UART_FLOWEN_X == 1)										//Flowcontrol enabled?
		FC_CAL_Bit_In_DDR (MX_UART_CTS_PORT_X, MX_UART_CTS_TRIS_X, MX_UART_CTS_PIN_X);		// CTS pin is a input
		FC_CAL_Bit_In_DDR (MX_UART_RTS_PORT_X, MX_UART_RTS_TRIS_X, MX_UART_RTS_PIN_X);		// RTS not ready to accept data
	#endif
}



CALFUNCTION(void, FC_CAL_UART_Send_, (MX_UINT16 nChar))
{
	#if (MX_UART_FLOWEN_X == 1)
		while (FC_CAL_Bit_In(MX_UART_CTS_PORT_X, MX_UART_CTS_PIN_X) != 0);	// Wait until CTS is low
	#endif

	#if (MX_UART_CHANNEL_X == 0)													// Software UART TX
		MX_UINT8 idx;
		FC_CAL_Bit_Low(MX_UART_TX_PORT_X, MX_UART_TX_PIN_X);					// Send Start bit
		UART_Delay_CAL();
		for (idx = 0; idx < MX_UART_DBITS_X; idx++)
		{
			if (nChar & 0x01)														// Mask off data bit
				FC_CAL_Bit_High(MX_UART_TX_PORT_X, MX_UART_TX_PIN_X);
			else
				FC_CAL_Bit_Low(MX_UART_TX_PORT_X, MX_UART_TX_PIN_X);
			UART_Delay_CAL();
			nChar = nChar >> 1;														// Move to next data bit
		}
		FC_CAL_Bit_High(MX_UART_TX_PORT_X, MX_UART_TX_PIN_X);					// Send Stop bit
		UART_Delay_CAL();
	#endif

	#if (MX_UART_CHANNEL_X == 1)
		while (ts_bit(pir1, TXIF) == 0);

		#if (MX_UART_DBITS_X == 9)
			if (test_bit(nChar, 8))
				st_bit(txsta, TX9D);
			else
				cr_bit(txsta, TX9D);
	  	#endif
		txreg = nChar;
	#endif

	#if (MX_UART_CHANNEL_X == 2)
		while (ts_bit(pir3, TX2IF) == 0);

		#if (MX_UART_DBITS_X == 9)
			if (test_bit(nChar, 8))
				st_bit(MX_UART2_TXSTA, TX9D);
			else
				cr_bit(MX_UART2_TXSTA, TX9D);
		#endif
		MX_UART2_TXREG = nChar;
	#endif
}


CALFUNCTION(MX_SINT16, FC_CAL_UART_Receive_, (MX_UINT8 nTimeout))

{
  #if (MX_UART_RETURN_X == 1)
	MX_UINT16 retVal = 512;
  #else
  	MX_UINT8 retVal = 255;
0015  30FF  	MOVLW 0xFF
0016  00E2  	MOVWF FC_CAL_UAR_0005B_1_retVal

  #endif

	MX_UINT8 delay1 = 0;
0017  01E3  	CLRF FC_CAL_UAR_0005B_1_delay1

	MX_UINT8 regcheck = 0;
0018  01E4  	CLRF FC_CAL_UAR_0005B_1_regcheck

	MX_UINT8 bWaitForever = 0;
0019  01E5  	CLRF FC_CAL_UAR_0005B_1_bWaitForever

	MX_UINT8 rxStatus = UART_STATUS_LOOP;
001A  01E6  	CLRF FC_CAL_UAR_0005B_1_rxStatus


  #if (MX_UART_CHANNEL_X == 0)
  	MX_UINT8 idx;
  #else
  	MX_UINT8 dummy = 0;
001B  01E7  	CLRF FC_CAL_UAR_0005B_1_dummy

  #endif

	if (nTimeout == 255)
001C  0A61  	INCF FC_CAL_UAR_0005B_arg_nTimeout, W
001D  1D03  	BTFSS STATUS,Z
001E  2821  	GOTO	label2
0021        label2

		bWaitForever = 1;
001F  3001  	MOVLW 0x01
0020  00E5  	MOVWF FC_CAL_UAR_0005B_1_bWaitForever


	#if (MX_UART_FLOWEN_X == 1)
		FC_CAL_Bit_Low (MX_UART_RTS_PORT_X, MX_UART_RTS_PIN_X);			// Ready to accept data
	#endif

	while (rxStatus == UART_STATUS_LOOP)
0021  08E6  	MOVF FC_CAL_UAR_0005B_1_rxStatus, F
0022  1D03  	BTFSS STATUS,Z
0023  2843  	GOTO	label5
0042  2821  	GOTO	label2
0043        label5

	{
		if (bWaitForever == 0)
0024  08E5  	MOVF FC_CAL_UAR_0005B_1_bWaitForever, F
0025  1D03  	BTFSS STATUS,Z
0026  283A  	GOTO	label4

		{
			if (nTimeout == 0)							//don't wait forever, so do timeout thing...
0027  08E1  	MOVF FC_CAL_UAR_0005B_arg_nTimeout, F
0028  1D03  	BTFSS STATUS,Z
0029  282D  	GOTO	label3
002D        label3

			{
				rxStatus = UART_STATUS_TIMEOUT;
002A  3001  	MOVLW 0x01
002B  00E6  	MOVWF FC_CAL_UAR_0005B_1_rxStatus

			}
			else
002C  283A  	GOTO	label4

			{
				delay_us(10);
002D  300A  	MOVLW 0x0A
002E  00E8  	MOVWF delay_us_00000_arg_del
002F  2010  	CALL delay_us_00000

				delay1 = delay1 + 1;
0030  0A63  	INCF FC_CAL_UAR_0005B_1_delay1, W
0031  00E3  	MOVWF FC_CAL_UAR_0005B_1_delay1

				if(delay1 == 100)
0032  0863  	MOVF FC_CAL_UAR_0005B_1_delay1, W
0033  3A64  	XORLW 0x64
0034  1D03  	BTFSS STATUS,Z
0035  283A  	GOTO	label4
003A        label4

				{
					nTimeout = nTimeout - 1;
0036  0361  	DECF FC_CAL_UAR_0005B_arg_nTimeout, W
0037  00E1  	MOVWF FC_CAL_UAR_0005B_arg_nTimeout

					MX_CLEAR_WATCHDOG;
0038  0064  	CLRWDT

					delay1 = 0;
0039  01E3  	CLRF FC_CAL_UAR_0005B_1_delay1

				}
			}
		}

		#if (MX_UART_CHANNEL_X == 0)
			regcheck = FC_CAL_Bit_In(MX_UART_RX_PORT_1, MX_UART_RX_PIN_1);	//Test for start bit
			if (regcheck == 0)
				rxStatus = UART_STATUS_RXBYTE;
		#endif

		#if (MX_UART_CHANNEL_X == 1)
			regcheck = ts_bit(pir1, RCIF);
003A  3020  	MOVLW 0x20
003B  050C  	ANDWF gbl_pir1, W
003C  00E4  	MOVWF FC_CAL_UAR_0005B_1_regcheck

			if (regcheck != 0)
003D  08E4  	MOVF FC_CAL_UAR_0005B_1_regcheck, F
003E  1903  	BTFSC STATUS,Z
003F  2821  	GOTO	label2

				rxStatus = UART_STATUS_RXBYTE;
0040  3002  	MOVLW 0x02
0041  00E6  	MOVWF FC_CAL_UAR_0005B_1_rxStatus

		#endif

		#if (MX_UART_CHANNEL_X == 2)
			regcheck = ts_bit(MX_UART2_PIR, RC2IF);
			if (regcheck != 0)
				rxStatus = UART_STATUS_RXBYTE;
		#endif

	}

	if (rxStatus == UART_STATUS_RXBYTE)
0043  0866  	MOVF FC_CAL_UAR_0005B_1_rxStatus, W
0044  3A02  	XORLW 0x02
0045  1D03  	BTFSS STATUS,Z
0046  285D  	GOTO	label8

	{
		#if (MX_UART_CHANNEL_X == 0)

			retVal = 0;
			UART_Delay_CAL();

			for (idx = 0; idx < MX_UART_DBITS_X; idx++)
			{
				if (FC_CAL_Bit_In(MX_UART_RX_PORT_X, MX_UART_RX_PIN_X))
					retVal = retVal | (0x01 << idx);

				UART_Delay_CAL();
			}
		#endif

		#if (MX_UART_CHANNEL_X == 1)
			regcheck = ts_bit(rcsta, FERR);
0047  3004  	MOVLW 0x04
0048  0518  	ANDWF gbl_rcsta, W
0049  00E4  	MOVWF FC_CAL_UAR_0005B_1_regcheck

			if (regcheck != 0)
004A  08E4  	MOVF FC_CAL_UAR_0005B_1_regcheck, F
004B  1903  	BTFSC STATUS,Z
004C  2850  	GOTO	label6
0050        label6

			{
				dummy = rcreg;						//need to read the rcreg to clear FERR
004D  081A  	MOVF gbl_rcreg, W
004E  00E7  	MOVWF FC_CAL_UAR_0005B_1_dummy

				#if (MX_UART_RETURN_X == 1)
					retVal = 0x400;					//Framing Error Flag
				#endif
			}
			else
004F  285D  	GOTO	label8

			{
				regcheck = ts_bit(rcsta, OERR);
0050  3002  	MOVLW 0x02
0051  0518  	ANDWF gbl_rcsta, W
0052  00E4  	MOVWF FC_CAL_UAR_0005B_1_regcheck

				if (regcheck != 0)
0053  08E4  	MOVF FC_CAL_UAR_0005B_1_regcheck, F
0054  1903  	BTFSC STATUS,Z
0055  2859  	GOTO	label7
0059        label7

				{
					cr_bit(rcsta, CREN);			//Reset receiver to clear error
0056  1218  	BCF gbl_rcsta,4

					st_bit(rcsta, CREN);
0057  1618  	BSF gbl_rcsta,4


					#if (MX_UART_RETURN_X == 1)
						retVal = 0x800;				//Overrun Error Flag
					#endif
				}
				else
0058  285D  	GOTO	label8
005D        label8

				{
					retVal = 0;
0059  01E2  	CLRF FC_CAL_UAR_0005B_1_retVal


					#if (MX_UART_DBITS_X == 9)
						if(ts_bit(rcsta, RX9D))
							retVal = 0x100;
					#endif

					retVal = retVal | rcreg; 			//no error, so rx byte is valid
005A  081A  	MOVF gbl_rcreg, W
005B  0462  	IORWF FC_CAL_UAR_0005B_1_retVal, W
005C  00E2  	MOVWF FC_CAL_UAR_0005B_1_retVal

				}
			}
		#endif

		#if (MX_UART_CHANNEL_X == 2)
			regcheck = ts_bit(MX_UART2_RCSTA, FERR);
			if (regcheck != 0)
			{
				dummy = MX_UART2_RCREG;			//need to read the rcreg to clear FERR
				#if (MX_UART_RETURN_X == 1)
					retVal = 0x400;					//Framing Error Flag
				#endif
			}
			else
			{
				regcheck = ts_bit(MX_UART2_RCSTA, OERR);
				if (regcheck != 0)
				{
					cr_bit(MX_UART2_RCSTA, CREN);	//Reset receiver to clear error
					st_bit(MX_UART2_RCSTA, CREN);
					#if (MX_UART_RETURN_X == 1)
						retVal = 0x800;				//Overrun Error Flag
					#endif
				}
				else
				{
					retVal = 0;

					#if (MX_UART_DBITS_X == 9)
						if(ts_bit(MX_UART2_RCSTA, RX9D))
							retVal = 0x100;
					#endif

					retVal = retVal | MX_UART2_RCREG; 			//no error, so rx byte is valid
				}
			}

		#endif

		#if (MX_UART_ECHO_X == 1)
			UART_Send(retVal);
		#endif
	}

	#if (MX_UART_FLOWEN_X == 1)
		FC_CAL_Bit_High(MX_UART_RTS_PORT_X, MX_UART_RTS_PIN_X);		//not ready to accept data
	#endif

	return (retVal);
005D  0862  	MOVF FC_CAL_UAR_0005B_1_retVal, W
005E  00E8  	MOVWF CompTempVarRet2210
005F  01E9  	CLRF CompTempVarRet2210+D'1'

}
0060  0008  	RETURN



CALFUNCTION(void, FC_CAL_UART_Delay_, (void))
{
  #if (MX_UART_CHANNEL_X == 0)

	MX_UINT16 delay = MX_SOFT_BAUD_X;

	while (delay > 255)
	{
		delay_us(255);
		delay = delay - 255;
		MX_CLEAR_WATCHDOG;
	}
	delay_us(delay);
	MX_CLEAR_WATCHDOG;

  #endif
}


CALFUNCTION(void, FC_CAL_UART_Update_Baud_, (MX_UINT8 new_baud))
{
	//Baud Rates - Function compatible with hardware mode only
	/*
	0 - 1200
	1 - 2400
	2 - 4800
	3 - 9600
	4 - 19200
	5 - 38400
	6 - 57600
	7 - 115200
	*/

	MX_UINT8 baudrate, baudmode;

	if (new_baud > 7)
		return;

	if (new_baud == 0)
	{
		baudrate = MX_HARD_BAUD_1200;
		baudmode = MX_HARD_SLOW_1200;
	}
	else if (new_baud == 1)
	{
		baudrate = MX_HARD_BAUD_2400;
		baudmode = MX_HARD_SLOW_2400;
	}
	else if (new_baud == 2)
	{
		baudrate = MX_HARD_BAUD_4800;
		baudmode = MX_HARD_SLOW_4800;
	}
	else if (new_baud == 3)
	{
		baudrate = MX_HARD_BAUD_9600;
		baudmode = MX_HARD_SLOW_9600;
	}
	else if (new_baud == 4)
	{
		baudrate = MX_HARD_BAUD_19200;
		baudmode = MX_HARD_SLOW_19200;
	}
	else if (new_baud == 5)
	{
		baudrate = MX_HARD_BAUD_38400;
		baudmode = MX_HARD_SLOW_38400;
	}
	else if (new_baud == 6)
	{
		baudrate = MX_HARD_BAUD_57600;
		baudmode = MX_HARD_SLOW_57600;
	}
	else if (new_baud == 7)
	{
		baudrate = MX_HARD_BAUD_115200;
		baudmode = MX_HARD_SLOW_115200;
	}

	UART_Uninit();

	#if (MX_UART_CHANNEL_X == 1)

	    if (baudmode == 1)
			cr_bit(txsta, BRGH);					//Low Speed
	    else
			st_bit(txsta, BRGH);					//High Speed

		spbrg = baudrate;   						// set the baud rate
		rcsta = 0;                    				// 8-bit, disabled

		#if(MX_UART_DBITS_X == 9)
			st_bit(txsta, TX9);   					// 9-bit TX
			st_bit(rcsta, RX9);                    	// 9-bit RX
		#endif

		st_bit(rcsta, SPEN);         				// turn on serial interface
		st_bit(txsta, TXEN);
		st_bit(rcsta, CREN);

		#if (MX_UART_INT_X == 1)
			MX_UART_INT_CH1_EN;
			st_bit(intcon, PEIE);
			st_bit(intcon, GIE);
		#else
			cr_bit (pie1, RCIE);
		#endif
	#endif

	#if (MX_UART_CHANNEL_X == 2)

	  	if (baudmode == 1)
			cr_bit(MX_UART2_TXSTA, BRGH);			//Low Speed
	  	else
			st_bit(MX_UART2_TXSTA, BRGH);			//High Speed

		spbrg2 = baudrate;   						// set the baud rate
		MX_UART2_RCSTA = 0;                    		// 8-bit, disabled

		#if(MX_UART_DBITS_X == 9)
			st_bit(MX_UART2_TXSTA, TX9);   			// 9-bit TX
			st_bit(MX_UART2_RCSTA, RX9);            // 9-bit RX
		#endif

		st_bit(MX_UART2_RCSTA, SPEN);         		// turn on serial interface
		st_bit(MX_UART2_TXSTA, TXEN);
		st_bit(MX_UART2_RCSTA, CREN);

		#if (MX_UART_INT_X == 1)
			MX_UART_INT_CH2_EN;
			st_bit(intcon, PEIE);
			st_bit(intcon, GIE);
		#else
			cr_bit (MX_UART2_PIE, RC2IE);
		#endif
	#endif

	#if (MX_UART_FLOWEN_X == 1)						//Flowcontrol enabled?
		FC_CAL_Bit_In_DDR (MX_UART_CTS_PORT_X, MX_UART_CTS_TRIS_X, MX_UART_CTS_PIN_X);	// CTS pin is a input
		FC_CAL_Bit_High_DDR (MX_UART_RTS_PORT_X, MX_UART_RTS_TRIS_X, MX_UART_RTS_PIN_X);	// RTS not ready to accept data
	#endif

}

////////////////////////////////////////
// Code with no source :-)
////////////////////////////////////////
0000  2BA3  	GOTO	_startup

0004  00FF  	MOVWF Int1Context
0005  0E03  	SWAPF STATUS, W
0006  1283  	BCF STATUS, RP0
0007  1303  	BCF STATUS, RP1
0008  00B4  	MOVWF Int1BContext
0009  0E0A  	SWAPF PCLATH, W
000A  00B5  	MOVWF Int1BContext+D'1'
000B  0E04  	SWAPF FSR, W
000C  00B6  	MOVWF Int1BContext+D'2'
000D  118A  	BCF PCLATH,3
000E  120A  	BCF PCLATH,4
000F  2BDB  	GOTO	interrupt
0010        delay_us_00000
0010        ; { delay_us ; function begin
0010        label1
0010  0000  	NOP
0011  0000  	NOP
0012  0BE8  	DECFSZ delay_us_00000_arg_del, F
0013  2810  	GOTO	label1
0014  0008  	RETURN
0015        ; } delay_us function end


0179        __rem_8_8_00000
0179        ; { __rem_8_8 ; function begin
0179  01DE  	CLRF CompTempVarRet220
017A  01DC  	CLRF __rem_8_8_00000_1_c
017B  01DD  	CLRF __rem_8_8_00000_1_i
017C        label28
017C  19DD  	BTFSC __rem_8_8_00000_1_i,3
017D  0008  	RETURN
017E  1003  	BCF STATUS,C
017F  0DDC  	RLF __rem_8_8_00000_1_c, F
0180  0DDA  	RLF __rem_8_8_00000_arg_a, F
0181  0DDE  	RLF CompTempVarRet220, F
0182  085B  	MOVF __rem_8_8_00000_arg_b, W
0183  025E  	SUBWF CompTempVarRet220, W
0184  1C03  	BTFSS STATUS,C
0185  2988  	GOTO	label29
0186  00DE  	MOVWF CompTempVarRet220
0187  145C  	BSF __rem_8_8_00000_1_c,0
0188        label29
0188  0ADD  	INCF __rem_8_8_00000_1_i, F
0189  297C  	GOTO	label28
018A        ; } __rem_8_8 function end

018A        __div_8_8_00000
018A        ; { __div_8_8 ; function begin
018A  01DC  	CLRF __div_8_8_00000_1_r
018B  01DE  	CLRF CompTempVarRet218
018C  01DD  	CLRF __div_8_8_00000_1_i
018D        label30
018D  19DD  	BTFSC __div_8_8_00000_1_i,3
018E  0008  	RETURN
018F  1003  	BCF STATUS,C
0190  0DDE  	RLF CompTempVarRet218, F
0191  0DDA  	RLF __div_8_8_00000_arg_a, F
0192  0DDC  	RLF __div_8_8_00000_1_r, F
0193  085B  	MOVF __div_8_8_00000_arg_b, W
0194  025C  	SUBWF __div_8_8_00000_1_r, W
0195  1C03  	BTFSS STATUS,C
0196  2999  	GOTO	label31
0197  00DC  	MOVWF __div_8_8_00000_1_r
0198  145E  	BSF CompTempVarRet218,0
0199        label31
0199  0ADD  	INCF __div_8_8_00000_1_i, F
019A  298D  	GOTO	label30
019B        ; } __div_8_8 function end


03A3        _startup
03A3  30D5  	MOVLW 0xD5
03A4  1283  	BCF STATUS, RP0
03A5  1303  	BCF STATUS, RP1
03A6  00A0  	MOVWF gbl_14_LSR
03A7  30C4  	MOVLW 0xC4
03A8  00A1  	MOVWF gbl_14_LSR+D'1'
03A9  30BB  	MOVLW 0xBB
03AA  00A2  	MOVWF gbl_14_LSR+D'2'
03AB  30DC  	MOVLW 0xDC
03AC  00A3  	MOVWF gbl_14_LSR+D'3'
03AD  01A4  	CLRF gbl_15_gbl_aSig
03AE  01A5  	CLRF gbl_15_gbl_aSig+D'1'
03AF  01A6  	CLRF gbl_15_gbl_aSig+D'2'
03B0  01A7  	CLRF gbl_15_gbl_aSig+D'3'
03B1  01A8  	CLRF gbl_15_gbl_bSig
03B2  01A9  	CLRF gbl_15_gbl_bSig+D'1'
03B3  01AA  	CLRF gbl_15_gbl_bSig+D'2'
03B4  01AB  	CLRF gbl_15_gbl_bSig+D'3'
03B5  01AC  	CLRF gbl_15_gbl_zSig
03B6  01AD  	CLRF gbl_15_gbl_zSig+D'1'
03B7  01AE  	CLRF gbl_15_gbl_zSig+D'2'
03B8  01AF  	CLRF gbl_15_gbl_zSig+D'3'
03B9  01BC  	CLRF gbl_15_gbl_aExp
03BA  01BD  	CLRF gbl_15_gbl_bExp
03BB  01B7  	CLRF gbl_15_gbl_zExp
03BC  01B8  	CLRF gbl_15_gbl_zExp+D'1'
03BD  01BE  	CLRF gbl_15_gbl_aSign
03BE  01BF  	CLRF gbl_15_gbl_bSign
03BF  01C0  	CLRF gbl_15_gbl_zSign
03C0  01C1  	CLRF gbl_15_gbl_zSigZero
03C1  01B0  	CLRF gbl_15_gbl_ret
03C2  01B1  	CLRF gbl_15_gbl_ret+D'1'
03C3  01B2  	CLRF gbl_15_gbl_ret+D'2'
03C4  01B3  	CLRF gbl_15_gbl_ret+D'3'
03C5  01BA  	CLRF gbl_float_rounding_mode
03C6  01BB  	CLRF gbl_float_exception_flags
03C7  01B9  	CLRF gbl_float_detect_tininess

03D8  118A  	BCF PCLATH,3
03D9  120A  	BCF PCLATH,4
03DA  2A63  	GOTO	main

2007  20C2  	DW 0x20C2
2008  3EFF  	DW 0x3EFF
