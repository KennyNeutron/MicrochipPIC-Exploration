;/////////////////////////////////////////////////////////////////////////////////
;// Code Generator: BoostC Compiler - http://www.sourceboost.com
;// Version       : 7.03
;// License Type  : Pro License
;// Limitations   : PIC12,PIC16 max code size:Unlimited, max RAM banks:Unlimited
;/////////////////////////////////////////////////////////////////////////////////

//************************************************************************************
//**  
//**  File name:     D:\KennyNeutronsInnovations\ScoreBoard\Flowcode\dm135Test.c
//**  Title:         
//**  Description:   
//**  
//**  Generated by:  Flowcode v5.2.0.0
//**  Date:          Monday, January 28, 2019 20:36:41
//**  Licence:       Professional
//**  Registered to: xyz
//**  Licence key:   WUK7B9
//**  
//**  
//**  http://www.matrixmultimedia.com
//**  
//************************************************************************************


#define MX_PIC

#define MX_USES_UINT8 3
#define MX_USES_SINT16 0
#define MX_USES_CHAR 0
#define MX_USES_FLOAT 0
#define MX_USES_SINT32 0
#define MX_USES_BOOL 1
#define MX_USES_UINT16 0
#define MX_USES_UINT32 0
//Defines for microcontroller
#define P16F690
#define FC_CAL_PIC
#define MX_ADC
#define MX_ADC_TYPE_3
#define MX_ADC_BITS_10
#define MX_EE
#define MX_EE_TYPE2
#define MX_EE_SIZE 256
#define MX_SPI_1
#define MX_SPI_1_MISO_PORT portb
#define MX_SPI_1_MISO_TRIS trisb
#define MX_SPI_1_MISO_PIN 4
#define MX_SPI_1_MOSI_PORT portc
#define MX_SPI_1_MOSI_TRIS trisc
#define MX_SPI_1_MOSI_PIN 7
#define MX_SPI_1_CLK_PORT portb
#define MX_SPI_1_CLK_TRIS trisb
#define MX_SPI_1_CLK_PIN 6
#define MX_SPI_1_SS_PORT portb
#define MX_SPI_1_SS_TRIS trisb
#define MX_UART_1
#define MX_UART_1_TX_PORT portb
#define MX_UART_1_TX_TRIS trisb
#define MX_UART_1_TX_PIN 7
#define MX_UART_1_RX_PORT portb
#define MX_UART_1_RX_TRIS trisb
#define MX_UART_1_RX_PIN 5
#define MX_I2C
#define MX_MI2C
#define MX_I2C_1
#define MX_I2C_1_SDA_PORT portb
#define MX_I2C_1_SDA_TRIS trisb
#define MX_I2C_1_SDA_PIN 4
#define MX_I2C_1_SCL_PORT portb
#define MX_I2C_1_SCL_TRIS trisb
#define MX_I2C_1_SCL_PIN 6
#define MX_PWM
#define MX_PWM_CNT 1
#define MX_PWM_PSCA1
#define MX_PWM_PSCA4
#define MX_PWM_PSCA16
#define MX_PWM_1_PORT portc
#define MX_PWM_1_TRIS trisc
#define MX_PWM_1_PIN 5

//Functions
#define MX_CLK_SPEED 4000000
#ifdef _BOOSTC
#include <system.h>
#endif
#ifdef HI_TECH_C
#include <pic.h>
#endif

//Configuration data
#ifdef _BOOSTC
#pragma DATA 0x2007, 0x30d4
#endif
#ifdef HI_TECH_C
__CONFIG(0x30d4);
#endif

//Internal functions
#include "C:\Program Files (x86)\Flowcode\v5\FCD\internals.c"

//Macro function declarations
void FCM_databank();
void FCM_display();
void FCM_Data_recv();


//Variable declarations
#define FCV_FALSE (0)
#define FCV_TRUE (1)
MX_UINT8 FCV_RECIEVE;
MX_UINT8 FCV_TEMO_TENS = (0x0);
01CE  01C8  	CLRF gbl_FCV_TEMO_TENS

MX_BOOL FCV_DAT = (0);
01CF  1049  	BCF gbl_FCV_DAT,0

MX_UINT8 FCV_RECV[5];
MX_UINT8 FCV_BIT1;
MX_UINT8 FCV_BITS;
MX_UINT8 FCV_TEMP_ONES = (0x0);
01D0  01CB  	CLRF gbl_FCV_TEMP_ONES

MX_UINT8 FCV_TENS = (0x0);
01D1  01CC  	CLRF gbl_FCV_TENS

MX_UINT8 FCV_BIT2;
MX_UINT8 FCV_DIGIT;
MX_UINT8 FCV_COUNT = (0x0);
01D2  01CE  	CLRF gbl_FCV_COUNT

MX_UINT8 FCV_ONES = (0x0);
01D3  01CF  	CLRF gbl_FCV_ONES

MX_UINT8 FCV_RX_COUNT = (0x0);
01D4  01D0  	CLRF gbl_FCV_RX_COUNT


MX_UINT8 FCLV_LOOP1;
MX_UINT8 FCLV_LOOP2;
MX_UINT8 FCLV_LOOP3;



//RS232(0): //Defines:

/**** Macro Substitutions ****
a = Unique Reference
b = Uart Channel		(0-software / 1-4 hardware)
c = tx pin
d = tx port
e = rx pin
f = rx port
g = flow control		(0-Off / 1-On)
h = cts pin
i = cts port
j = rts pin
k = rts port
l = baud rate
m = data bits			(7/8/9) (7 only supported in software modes)
n = return type		(0-byte / 1-MX_UINT16)
o = echo enable		(0-Off / 1-On)
******************************/

//Definitions for RS232 UART slot allocation
#ifndef	MX_UART_REF1
	#define MX_UART_REF1
	#define RS232_1_MX_UART_UREF			1
	#define MX_UART_CHANNEL_1		1
	#define MX_UART_TX_PIN_1		0
	#define MX_UART_TX_PORT_1		porta
	#define MX_UART_TX_TRIS_1		trisa
	#define MX_UART_RX_PIN_1		0
	#define MX_UART_RX_PORT_1		porta
	#define MX_UART_RX_TRIS_1		trisa
	#define MX_UART_FLOWEN_1		0
	#define MX_UART_CTS_PIN_1		4
	#define MX_UART_CTS_PORT_1		portc
	#define MX_UART_CTS_TRIS_1		trisc
	#define MX_UART_RTS_PIN_1		0
	#define MX_UART_RTS_PORT_1		portc
	#define MX_UART_RTS_TRIS_1		trisc
	#define MX_UART_BAUD_1			9600
	#define MX_UART_DBITS_1			8
	#define MX_UART_RETURN_1		0
	#define MX_UART_ECHO_1			0
	#define MX_UART_INT_1			0
#else
 #ifndef	MX_UART_REF2
	#define MX_UART_REF2
	#define RS232_1_MX_UART_UREF			2
	#define MX_UART_CHANNEL_2		1
	#define MX_UART_TX_PIN_2		0
	#define MX_UART_TX_PORT_2		porta
	#define MX_UART_TX_TRIS_2		trisa
	#define MX_UART_RX_PIN_2		0
	#define MX_UART_RX_PORT_2		porta
	#define MX_UART_RX_TRIS_2		trisa
	#define MX_UART_FLOWEN_2		0
	#define MX_UART_CTS_PIN_2		4
	#define MX_UART_CTS_PORT_2		portc
	#define MX_UART_CTS_TRIS_2		trisc
	#define MX_UART_RTS_PIN_2		0
	#define MX_UART_RTS_PORT_2		portc
	#define MX_UART_RTS_TRIS_2		trisc
	#define MX_UART_BAUD_2			9600
	#define MX_UART_DBITS_2			8
	#define MX_UART_RETURN_2		0
	#define MX_UART_ECHO_2			0
	#define MX_UART_INT_2			0
 #else
  #ifndef	MX_UART_REF3
	#define MX_UART_REF3
	#define RS232_1_MX_UART_UREF			3
	#define MX_UART_CHANNEL_3		1
	#define MX_UART_TX_PIN_3		0
	#define MX_UART_TX_PORT_3		porta
	#define MX_UART_TX_TRIS_3		trisa
	#define MX_UART_RX_PIN_3		0
	#define MX_UART_RX_PORT_3		porta
	#define MX_UART_RX_TRIS_3		trisa
	#define MX_UART_FLOWEN_3		0
	#define MX_UART_CTS_PIN_3		4
	#define MX_UART_CTS_PORT_3		portc
	#define MX_UART_CTS_TRIS_3		trisc
	#define MX_UART_RTS_PIN_3		0
	#define MX_UART_RTS_PORT_3		portc
	#define MX_UART_RTS_TRIS_3		trisc
	#define MX_UART_BAUD_3			9600
	#define MX_UART_DBITS_3			8
	#define MX_UART_RETURN_3		0
	#define MX_UART_ECHO_3			0
	#define MX_UART_INT_3			0
  #else
   #ifndef	MX_UART_REF4
	#define MX_UART_REF4
	#define RS232_1_MX_UART_UREF			4
	#define MX_UART_CHANNEL_4		1
	#define MX_UART_TX_PIN_4		0
	#define MX_UART_TX_PORT_4		porta
	#define MX_UART_TX_TRIS_4		trisa
	#define MX_UART_RX_PIN_4		0
	#define MX_UART_RX_PORT_4		porta
	#define MX_UART_RX_TRIS_4		trisa
	#define MX_UART_FLOWEN_4		0
	#define MX_UART_CTS_PIN_4		4
	#define MX_UART_CTS_PORT_4		portc
	#define MX_UART_CTS_TRIS_4		trisc
	#define MX_UART_RTS_PIN_4		0
	#define MX_UART_RTS_PORT_4		portc
	#define MX_UART_RTS_TRIS_4		trisc
	#define MX_UART_BAUD_4			9600
	#define MX_UART_DBITS_4			8
	#define MX_UART_RETURN_4		0
	#define MX_UART_ECHO_4			0
	#define MX_UART_INT_4			0
   #endif
  #endif
 #endif
#endif

#define RS232_1_UART_Init		CAL_APPEND(FC_CAL_UART_Init_, RS232_1_MX_UART_UREF)
#define RS232_1_UART_Send		CAL_APPEND(FC_CAL_UART_Send_, RS232_1_MX_UART_UREF)
#define RS232_1_UART_Receive		CAL_APPEND(FC_CAL_UART_Receive_, RS232_1_MX_UART_UREF)
#define RS232_1_UART_Update_Baud CAL_APPEND(FC_CAL_UART_Update_Baud_, RS232_1_MX_UART_UREF)

extern void RS232_1_UART_Init();
extern void RS232_1_UART_Send(MX_UINT16 nChar);
extern MX_SINT16 RS232_1_UART_Receive(MX_UINT8 nTimeout);
extern void RS232_1_UART_Update_Baud(MX_UINT8 newbaud);




//RS232(0): //Macro function declarations

void FCD_RS2320_SendRS232Char(MX_SINT16 nChar);
void FCD_RS2320_SendRS232String(MX_STRING String, MX_UINT8 MSZ_String);
MX_SINT16 FCD_RS2320_ReceiveRS232Char(MX_UINT8 nTimeout);
void FCD_RS2320_ReceiveRS232String(MX_CHAR* FCR_RETVAL, MX_UINT8 FCR_RETVAL_SIZE, MX_UINT8 nTimeout, MX_UINT8 NumBytes);
void FCD_RS2320_ChangeHWBaud(MX_UINT8 newbaud);



//RS232(0): //Macro implementations


void FCD_RS2320_SendRS232Char(MX_SINT16 nChar)
{
	
		RS232_1_UART_Send ( nChar);

}

void FCD_RS2320_SendRS232String(MX_STRING String, MX_UINT8 MSZ_String)
{
	
		MX_UINT8 idx;
		for(idx = 0; idx < MSZ_String; idx++)
		{
			if (String[idx] == 0)
				break;
			else RS232_1_UART_Send ( String[idx] );
		}

}

MX_SINT16 FCD_RS2320_ReceiveRS232Char(MX_UINT8 nTimeout)

{
	
		return ( RS232_1_UART_Receive ( nTimeout) );
00A6  0854  	MOVF FCD_RS2320_00054_arg_nTimeout, W
00A7  00D5  	MOVWF FC_CAL_UAR_00057_arg_nTimeout
00A8  201A  	CALL FC_CAL_UAR_00057
00A9  085C  	MOVF CompTempVarRet2204, W
00AA  00D6  	MOVWF CompTempVarRet2203
00AB  085D  	MOVF CompTempVarRet2204+D'1', W
00AC  00D7  	MOVWF CompTempVarRet2203+D'1'


}
00AD  0008  	RETURN


void FCD_RS2320_ReceiveRS232String(MX_CHAR* FCR_RETVAL, MX_UINT8 FCR_RETVAL_SIZE, MX_UINT8 nTimeout, MX_UINT8 NumBytes)
{
	
		MX_UINT8 idx;
		MX_SINT16 RS232_TO = 255;
		MX_SINT16 in;

		if ( 0 != 0 )
			RS232_TO = 256;

		if (NumBytes > FCR_RETVAL_SIZE)
			NumBytes = FCR_RETVAL_SIZE;

		for (idx = 0; idx < NumBytes; idx++)
		{
			in = RS232_1_UART_Receive ( nTimeout);
			if(in < RS232_TO)
				FCR_RETVAL[idx] = in & 0xFF;
			else
				break;
		}

		if (idx < FCR_RETVAL_SIZE)
			FCR_RETVAL[idx] = 0;

}

void FCD_RS2320_ChangeHWBaud(MX_UINT8 newbaud)
{
	
		RS232_1_UART_Update_Baud (newbaud);

}

#include "C:\Program Files (x86)\Flowcode\v5\CAL\includes.c"

//Macro implementations


void FCM_databank()

{

	//Switch
	//Switch: digit?
	switch (FCV_DIGIT)

	{
		case 1:
0066  1283  	BCF STATUS, RP0
0067  1303  	BCF STATUS, RP1
0068  084D  	MOVF gbl_FCV_DIGIT, W
0069  3A01  	XORLW 0x01
006A  1903  	BTFSC STATUS,Z
006B  2888  	GOTO	label9
0088        label9

		{
			//Calculation
			//Calculation:
			//  bits = 48
			FCV_BITS = 48;
0088  3030  	MOVLW 0x30
0089  00CA  	MOVWF gbl_FCV_BITS


			break;

		}
		case 2:
006C  3A03  	XORLW 0x03
006D  1903  	BTFSC STATUS,Z
006E  288B  	GOTO	label10
008B        label10

		{
			//Calculation
			//Calculation:
			//  bits = 91
			FCV_BITS = 91;
008B  305B  	MOVLW 0x5B
008C  00CA  	MOVWF gbl_FCV_BITS


			break;

		}
		case 3:
006F  3A01  	XORLW 0x01
0070  1903  	BTFSC STATUS,Z
0071  288E  	GOTO	label11
008E        label11

		{
			//Calculation
			//Calculation:
			//  bits = 121
			FCV_BITS = 121;
008E  3079  	MOVLW 0x79
008F  00CA  	MOVWF gbl_FCV_BITS


			break;

		}
		case 4:
0072  3A07  	XORLW 0x07
0073  1903  	BTFSC STATUS,Z
0074  2891  	GOTO	label12
0091        label12

		{
			//Calculation
			//Calculation:
			//  bits = 116
			FCV_BITS = 116;
0091  3074  	MOVLW 0x74
0092  00CA  	MOVWF gbl_FCV_BITS


			break;

		}
		case 5:
0075  3A01  	XORLW 0x01
0076  1903  	BTFSC STATUS,Z
0077  2894  	GOTO	label13
0094        label13

		{
			//Calculation
			//Calculation:
			//  bits = 109
			FCV_BITS = 109;
0094  306D  	MOVLW 0x6D
0095  00CA  	MOVWF gbl_FCV_BITS


			break;

		}
		case 6:
0078  3A03  	XORLW 0x03
0079  1903  	BTFSC STATUS,Z
007A  2897  	GOTO	label14
0097        label14

		{
			//Calculation
			//Calculation:
			//  bits = 111
			FCV_BITS = 111;
0097  306F  	MOVLW 0x6F
0098  00CA  	MOVWF gbl_FCV_BITS


			break;

		}
		case 7:
007B  3A01  	XORLW 0x01
007C  1903  	BTFSC STATUS,Z
007D  289A  	GOTO	label15
009A        label15

		{
			//Calculation
			//Calculation:
			//  bits = 56
			FCV_BITS = 56;
009A  3038  	MOVLW 0x38
009B  00CA  	MOVWF gbl_FCV_BITS


			break;

		}
		case 8:
007E  3A0F  	XORLW 0x0F
007F  1903  	BTFSC STATUS,Z
0080  289D  	GOTO	label16
009D        label16

		{
			//Calculation
			//Calculation:
			//  bits = 127
			FCV_BITS = 127;
009D  307F  	MOVLW 0x7F
009E  00CA  	MOVWF gbl_FCV_BITS


			break;

		}
		case 9:
0081  3A01  	XORLW 0x01
0082  1903  	BTFSC STATUS,Z
0083  28A0  	GOTO	label17
00A0        label17

		{
			//Calculation
			//Calculation:
			//  bits = 125
			FCV_BITS = 125;
00A0  307D  	MOVLW 0x7D
00A1  00CA  	MOVWF gbl_FCV_BITS


			break;

		}
		case 0:
0084  3A09  	XORLW 0x09
0085  1903  	BTFSC STATUS,Z
0086  28A3  	GOTO	label18
00A3        label18

		{
			//Calculation
			//Calculation:
			//  bits = 63
			FCV_BITS = 63;
00A3  303F  	MOVLW 0x3F
00A4  00CA  	MOVWF gbl_FCV_BITS


			break;

		}
		// default:

	}

}
0087  0008  	RETURN
008A  0008  	RETURN
008D  0008  	RETURN
0090  0008  	RETURN
0093  0008  	RETURN
0096  0008  	RETURN
0099  0008  	RETURN
009C  0008  	RETURN
009F  0008  	RETURN
00A2  0008  	RETURN
00A5  0008  	RETURN



void FCM_display()

{

	//Calculation
	//Calculation:
	//  digit = tens
	FCV_DIGIT = FCV_TENS;
00BD  1283  	BCF STATUS, RP0
00BE  1303  	BCF STATUS, RP1
00BF  084C  	MOVF gbl_FCV_TENS, W
00C0  00CD  	MOVWF gbl_FCV_DIGIT


	//Call Macro
	//Call Macro: databank()
	FCM_databank();
00C1  2066  	CALL FCM_databa_00051


	//Loop
	//Loop: Loop 8 times
	for (FCLV_LOOP1=0; FCLV_LOOP1<8; FCLV_LOOP1++)
00C2  01D1  	CLRF gbl_FCLV_LOOP1
00C3        label19
00C3  3008  	MOVLW 0x08
00C4  0251  	SUBWF gbl_FCLV_LOOP1, W
00C5  1803  	BTFSC STATUS,C
00C6  2904  	GOTO	label22
0102  0AD1  	INCF gbl_FCLV_LOOP1, F
0103  28C3  	GOTO	label19
0104        label22

	{

		//Calculation
		//Calculation:
		//  dat = bits AND 1
		FCV_DAT = FCV_BITS & 1;
00C7  3001  	MOVLW 0x01
00C8  054A  	ANDWF gbl_FCV_BITS, W
00C9  00D4  	MOVWF CompTempVar2188
00CA  01D5  	CLRF CompTempVar2189
00CB  08D4  	MOVF CompTempVar2188, F
00CC  1D03  	BTFSS STATUS,Z
00CD  1455  	BSF CompTempVar2189,0
00CE  1049  	BCF gbl_FCV_DAT,0
00CF  0855  	MOVF CompTempVar2189, W
00D0  1D03  	BTFSS STATUS,Z
00D1  1449  	BSF gbl_FCV_DAT,0


		//data
		//Output: dat -> C2
		trisc = trisc & 0xFB;
00D2  30FB  	MOVLW 0xFB
00D3  1683  	BSF STATUS, RP0
00D4  0507  	ANDWF gbl_trisc, W
00D5  0087  	MOVWF gbl_trisc

		if ((FCV_DAT))
00D6  1283  	BCF STATUS, RP0
00D7  1C49  	BTFSS gbl_FCV_DAT,0
00D8  28E0  	GOTO	label20
00E0        label20

			portc = (portc & 0xFB) | 0x04;
00D9  30FB  	MOVLW 0xFB
00DA  0507  	ANDWF gbl_portc, W
00DB  00D4  	MOVWF CompTempVar2190
00DC  3004  	MOVLW 0x04
00DD  0454  	IORWF CompTempVar2190, W
00DE  0087  	MOVWF gbl_portc

		else
00DF  28E3  	GOTO	label21
00E3        label21

			portc = portc & 0xFB;
00E0  30FB  	MOVLW 0xFB
00E1  0507  	ANDWF gbl_portc, W
00E2  0087  	MOVWF gbl_portc


		//Delay
		//Delay: 1 us
		delay_us(1);
00E3  3001  	MOVLW 0x01
00E4  00DC  	MOVWF delay_us_00000_arg_del
00E5  2010  	CALL delay_us_00000


		//clk
		//Output: 1 -> C0
		trisc = trisc & 0xFE;
00E6  30FE  	MOVLW 0xFE
00E7  1683  	BSF STATUS, RP0
00E8  0507  	ANDWF gbl_trisc, W
00E9  0087  	MOVWF gbl_trisc

		if ((1))
			portc = (portc & 0xFE) | 0x01;
00EA  30FE  	MOVLW 0xFE
00EB  1283  	BCF STATUS, RP0
00EC  0507  	ANDWF gbl_portc, W
00ED  00D4  	MOVWF CompTempVar2191
00EE  3001  	MOVLW 0x01
00EF  0454  	IORWF CompTempVar2191, W
00F0  0087  	MOVWF gbl_portc

		else
			portc = portc & 0xFE;

		//Delay
		//Delay: 1 us
		delay_us(1);
00F1  3001  	MOVLW 0x01
00F2  00DC  	MOVWF delay_us_00000_arg_del
00F3  2010  	CALL delay_us_00000


		//clk
		//Output: 0 -> C0
		trisc = trisc & 0xFE;
00F4  30FE  	MOVLW 0xFE
00F5  1683  	BSF STATUS, RP0
00F6  0507  	ANDWF gbl_trisc, W
00F7  0087  	MOVWF gbl_trisc

		if ((0))
			portc = (portc & 0xFE) | 0x01;
		else
			portc = portc & 0xFE;
00F8  30FE  	MOVLW 0xFE
00F9  1283  	BCF STATUS, RP0
00FA  0507  	ANDWF gbl_portc, W
00FB  0087  	MOVWF gbl_portc


		//Delay
		//Delay: 1 us
		delay_us(1);
00FC  3001  	MOVLW 0x01
00FD  00DC  	MOVWF delay_us_00000_arg_del
00FE  2010  	CALL delay_us_00000


		//Calculation
		//Calculation:
		//  bits = bits >> 1
		FCV_BITS = FCV_BITS >> 1;
00FF  08CA  	MOVF gbl_FCV_BITS, F
0100  1003  	BCF STATUS,C
0101  0CCA  	RRF gbl_FCV_BITS, F



	}

	//Calculation
	//Calculation:
	//  digit = ones
	FCV_DIGIT = FCV_ONES;
0104  084F  	MOVF gbl_FCV_ONES, W
0105  00CD  	MOVWF gbl_FCV_DIGIT


	//Call Macro
	//Call Macro: databank()
	FCM_databank();
0106  2066  	CALL FCM_databa_00051


	//Loop
	//Loop: Loop 8 times
	for (FCLV_LOOP2=0; FCLV_LOOP2<8; FCLV_LOOP2++)
0107  01D2  	CLRF gbl_FCLV_LOOP2
0108        label23
0108  3008  	MOVLW 0x08
0109  0252  	SUBWF gbl_FCLV_LOOP2, W
010A  1803  	BTFSC STATUS,C
010B  2949  	GOTO	label26
0147  0AD2  	INCF gbl_FCLV_LOOP2, F
0148  2908  	GOTO	label23
0149        label26

	{

		//Calculation
		//Calculation:
		//  dat = bits AND 1
		FCV_DAT = FCV_BITS & 1;
010C  3001  	MOVLW 0x01
010D  054A  	ANDWF gbl_FCV_BITS, W
010E  00D4  	MOVWF CompTempVar2193
010F  01D5  	CLRF CompTempVar2194
0110  08D4  	MOVF CompTempVar2193, F
0111  1D03  	BTFSS STATUS,Z
0112  1455  	BSF CompTempVar2194,0
0113  1049  	BCF gbl_FCV_DAT,0
0114  0855  	MOVF CompTempVar2194, W
0115  1D03  	BTFSS STATUS,Z
0116  1449  	BSF gbl_FCV_DAT,0


		//data
		//Output: dat -> C2
		trisc = trisc & 0xFB;
0117  30FB  	MOVLW 0xFB
0118  1683  	BSF STATUS, RP0
0119  0507  	ANDWF gbl_trisc, W
011A  0087  	MOVWF gbl_trisc

		if ((FCV_DAT))
011B  1283  	BCF STATUS, RP0
011C  1C49  	BTFSS gbl_FCV_DAT,0
011D  2925  	GOTO	label24
0125        label24

			portc = (portc & 0xFB) | 0x04;
011E  30FB  	MOVLW 0xFB
011F  0507  	ANDWF gbl_portc, W
0120  00D4  	MOVWF CompTempVar2195
0121  3004  	MOVLW 0x04
0122  0454  	IORWF CompTempVar2195, W
0123  0087  	MOVWF gbl_portc

		else
0124  2928  	GOTO	label25
0128        label25

			portc = portc & 0xFB;
0125  30FB  	MOVLW 0xFB
0126  0507  	ANDWF gbl_portc, W
0127  0087  	MOVWF gbl_portc


		//Delay
		//Delay: 1 us
		delay_us(1);
0128  3001  	MOVLW 0x01
0129  00DC  	MOVWF delay_us_00000_arg_del
012A  2010  	CALL delay_us_00000


		//clk
		//Output: 1 -> C0
		trisc = trisc & 0xFE;
012B  30FE  	MOVLW 0xFE
012C  1683  	BSF STATUS, RP0
012D  0507  	ANDWF gbl_trisc, W
012E  0087  	MOVWF gbl_trisc

		if ((1))
			portc = (portc & 0xFE) | 0x01;
012F  30FE  	MOVLW 0xFE
0130  1283  	BCF STATUS, RP0
0131  0507  	ANDWF gbl_portc, W
0132  00D4  	MOVWF CompTempVar2196
0133  3001  	MOVLW 0x01
0134  0454  	IORWF CompTempVar2196, W
0135  0087  	MOVWF gbl_portc

		else
			portc = portc & 0xFE;

		//Delay
		//Delay: 1 us
		delay_us(1);
0136  3001  	MOVLW 0x01
0137  00DC  	MOVWF delay_us_00000_arg_del
0138  2010  	CALL delay_us_00000


		//clk
		//Output: 0 -> C0
		trisc = trisc & 0xFE;
0139  30FE  	MOVLW 0xFE
013A  1683  	BSF STATUS, RP0
013B  0507  	ANDWF gbl_trisc, W
013C  0087  	MOVWF gbl_trisc

		if ((0))
			portc = (portc & 0xFE) | 0x01;
		else
			portc = portc & 0xFE;
013D  30FE  	MOVLW 0xFE
013E  1283  	BCF STATUS, RP0
013F  0507  	ANDWF gbl_portc, W
0140  0087  	MOVWF gbl_portc


		//Delay
		//Delay: 1 us
		delay_us(1);
0141  3001  	MOVLW 0x01
0142  00DC  	MOVWF delay_us_00000_arg_del
0143  2010  	CALL delay_us_00000


		//Calculation
		//Calculation:
		//  bits = bits >> 1
		FCV_BITS = FCV_BITS >> 1;
0144  08CA  	MOVF gbl_FCV_BITS, F
0145  1003  	BCF STATUS,C
0146  0CCA  	RRF gbl_FCV_BITS, F



	}

	//reg
	//Output: 1 -> C1
	trisc = trisc & 0xFD;
0149  30FD  	MOVLW 0xFD
014A  1683  	BSF STATUS, RP0
014B  0507  	ANDWF gbl_trisc, W
014C  0087  	MOVWF gbl_trisc

	if ((1))
		portc = (portc & 0xFD) | 0x02;
014D  30FD  	MOVLW 0xFD
014E  1283  	BCF STATUS, RP0
014F  0507  	ANDWF gbl_portc, W
0150  00D4  	MOVWF CompTempVar2198
0151  3002  	MOVLW 0x02
0152  0454  	IORWF CompTempVar2198, W
0153  0087  	MOVWF gbl_portc

	else
		portc = portc & 0xFD;

	//Delay
	//Delay: 1 us
	delay_us(1);
0154  3001  	MOVLW 0x01
0155  00DC  	MOVWF delay_us_00000_arg_del
0156  2010  	CALL delay_us_00000


	//reg
	//Output: 0 -> C1
	trisc = trisc & 0xFD;
0157  30FD  	MOVLW 0xFD
0158  1683  	BSF STATUS, RP0
0159  0507  	ANDWF gbl_trisc, W
015A  0087  	MOVWF gbl_trisc

	if ((0))
		portc = (portc & 0xFD) | 0x02;
	else
		portc = portc & 0xFD;
015B  30FD  	MOVLW 0xFD
015C  1283  	BCF STATUS, RP0
015D  0507  	ANDWF gbl_portc, W
015E  0087  	MOVWF gbl_portc


	//Delay
	//Delay: 1 us
	delay_us(1);
015F  3001  	MOVLW 0x01
0160  00DC  	MOVWF delay_us_00000_arg_del
0161  2010  	CALL delay_us_00000


}
0162  0008  	RETURN



void FCM_Data_recv()

{

	//Loop
	//Loop: Loop 3 times
	for (FCLV_LOOP3=0; FCLV_LOOP3<3; FCLV_LOOP3++)
0163  1283  	BCF STATUS, RP0
0164  1303  	BCF STATUS, RP1
0165  01D3  	CLRF gbl_FCLV_LOOP3
0166        label27
0166  3003  	MOVLW 0x03
0167  0253  	SUBWF gbl_FCLV_LOOP3, W
0168  1803  	BTFSC STATUS,C
0169  297A  	GOTO	label28
0178  0AD3  	INCF gbl_FCLV_LOOP3, F
0179  2966  	GOTO	label27
017A        label28

	{

		//Call Component Macro
		//Call Component Macro: recieve=ReceiveRS232Char(25)
		FCV_RECIEVE = FCD_RS2320_ReceiveRS232Char(25);
016A  3019  	MOVLW 0x19
016B  00D4  	MOVWF FCD_RS2320_00054_arg_nTimeout
016C  20A6  	CALL FCD_RS2320_00054
016D  0856  	MOVF CompTempVarRet2203, W
016E  00C7  	MOVWF gbl_FCV_RECIEVE


		//Calculation
		//Calculation:
		//  recv[rx_count] = recieve
		//  rx_count = rx_count + 1
		FCV_RECV[FCV_RX_COUNT] = FCV_RECIEVE;
016F  1383  	BCF	STATUS,IRP
0170  3020  	MOVLW LOW(gbl_FCV_RECV+D'0')
0171  0084  	MOVWF FSR
0172  0850  	MOVF gbl_FCV_RX_COUNT, W
0173  0784  	ADDWF FSR, F
0174  0847  	MOVF gbl_FCV_RECIEVE, W
0175  0080  	MOVWF INDF

		FCV_RX_COUNT = FCV_RX_COUNT + 1;
0176  0A50  	INCF gbl_FCV_RX_COUNT, W
0177  00D0  	MOVWF gbl_FCV_RX_COUNT



	}

	//Decision
	//Decision: recv[1] = 'o'?
	if (FCV_RECV[1] == 'o')
017A  0821  	MOVF gbl_FCV_RECV+D'1', W
017B  3A6F  	XORLW 0x6F
017C  1D03  	BTFSS STATUS,Z
017D  2982  	GOTO	label29
0182        label29

	{

		//
		//Calculation:
		//  ones = recv[0]
		//  tens = recv[2]
		FCV_ONES = FCV_RECV[0];
017E  0820  	MOVF gbl_FCV_RECV, W
017F  00CF  	MOVWF gbl_FCV_ONES

		FCV_TENS = FCV_RECV[2];
0180  0822  	MOVF gbl_FCV_RECV+D'2', W
0181  00CC  	MOVWF gbl_FCV_TENS


	// } else {

	}

	//Calculation
	//Calculation:
	//  rx_count = 0
	FCV_RX_COUNT = 0;
0182  01D0  	CLRF gbl_FCV_RX_COUNT


}
0183  0008  	RETURN




void main()

{
	//Initialization
	ansel = 0;
0184  1283  	BCF STATUS, RP0
0185  1703  	BSF STATUS, RP1
0186  019E  	CLRF gbl_ansel

anselh = 0;
0187  019F  	CLRF gbl_anselh


	
		RS232_1_UART_Init( );		//Call initialise function
0188  20AE  	CALL FC_CAL_UAR_00055



	//Interrupt initialization code
	option_reg = 0xC0;
0189  30C0  	MOVLW 0xC0
018A  0081  	MOVWF gbl_option_reg



	//clk
	//Output: 0 -> C0
	trisc = trisc & 0xFE;
018B  30FE  	MOVLW 0xFE
018C  0507  	ANDWF gbl_trisc, W
018D  0087  	MOVWF gbl_trisc

	if ((0))
		portc = (portc & 0xFE) | 0x01;
	else
		portc = portc & 0xFE;
018E  30FE  	MOVLW 0xFE
018F  1283  	BCF STATUS, RP0
0190  0507  	ANDWF gbl_portc, W
0191  0087  	MOVWF gbl_portc


	//reg
	//Output: 0 -> C1
	trisc = trisc & 0xFD;
0192  30FD  	MOVLW 0xFD
0193  1683  	BSF STATUS, RP0
0194  0507  	ANDWF gbl_trisc, W
0195  0087  	MOVWF gbl_trisc

	if ((0))
		portc = (portc & 0xFD) | 0x02;
	else
		portc = portc & 0xFD;
0196  30FD  	MOVLW 0xFD
0197  1283  	BCF STATUS, RP0
0198  0507  	ANDWF gbl_portc, W
0199  0087  	MOVWF gbl_portc


	//Calculation
	//Calculation:
	//  tens = 9
	//  ones = 9
	FCV_TENS = 9;
019A  3009  	MOVLW 0x09
019B  00CC  	MOVWF gbl_FCV_TENS

	FCV_ONES = 9;
019C  00CF  	MOVWF gbl_FCV_ONES


	//Call Macro
	//Call Macro: display()
	FCM_display();
019D  20BD  	CALL FCM_displa_00052


	//Loop
	//Loop: While 1
	while (1)
019E        label30
01A8  299E  	GOTO	label30

	{

		//Call Component Macro
		//Call Component Macro: recieve=ReceiveRS232Char(25)
		FCV_RECIEVE = FCD_RS2320_ReceiveRS232Char(25);
019E  3019  	MOVLW 0x19
019F  00D4  	MOVWF FCD_RS2320_00054_arg_nTimeout
01A0  20A6  	CALL FCD_RS2320_00054
01A1  0856  	MOVF CompTempVarRet2203, W
01A2  00C7  	MOVWF gbl_FCV_RECIEVE


		//Decision
		//Decision: recieve = 't'?
		if (FCV_RECIEVE == 't')
01A3  0847  	MOVF gbl_FCV_RECIEVE, W
01A4  3A74  	XORLW 0x74
01A5  1903  	BTFSC STATUS,Z

		{

			//Call Macro
			//Call Macro: Data_recv()
			FCM_Data_recv();
01A6  2163  	CALL FCM_Data_r_00053


		// } else {

		}

		//Call Macro
		//Call Macro: display()
		FCM_display();
01A7  20BD  	CALL FCM_displa_00052



	}

	mainendloop: goto mainendloop;
}


void MX_INTERRUPT_MACRO(void)

{
}
01D8  1283  	BCF STATUS, RP0
01D9  1303  	BCF STATUS, RP1
01DA  0E3B  	SWAPF Int1BContext+D'2', W
01DB  0084  	MOVWF FSR
01DC  0E3A  	SWAPF Int1BContext+D'1', W
01DD  008A  	MOVWF PCLATH
01DE  0E39  	SWAPF Int1BContext, W
01DF  0083  	MOVWF STATUS
01E0  0EFF  	SWAPF Int1Context, F
01E1  0E7F  	SWAPF Int1Context, W
01E2  0009  	RETFIE





/*********************************************************************
 *                  Flowcode CAL UART File
 *
 * File: PIC_CAL_UART.c
 *
 * (c) 2011 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * “Company”) for its Flowcode graphical programming language is
 * intended and supplied to you, the Company’s customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 010911 | BR | Created
 * 020911 | BR | Updated variables with typedef alternatives
 * 011211 | BR | Converted to new dynamic defines mechanism
 * 160112 | BR | Fixed issues with rx return type and low bauds on fast devices
 * 020212 | ST | Added <MX_UART_2_PIE4> routing to account for differences in 16F and 18F devices with 2 UARTs
 * 270212 | BR | Fixed a bug in the receive functionality
 * 280212 | BR | Sorted out auto echo functionality
 * 160412 | BR | Addition of HW change baud function
 */



#ifndef MX_UART_SW_DEFS
	#define MX_UART_SW_DEFS

	#ifdef _BOOSTC
		#define INST_COUNT	45	//65 for lower speeds or 40 for higher speeds.
	#endif
	#ifdef HI_TECH_C
		#define INST_COUNT	315
	#endif

	//Work out number of nops for software baud rate
	#define MX_INSTRUCTION_SPEED 	(MX_CLK_SPEED / 4)
	#define MX_OVERHEAD				(MX_INSTRUCTION_SPEED / INST_COUNT)
	#define SW_OFFSET				(1000000 / MX_OVERHEAD)

	//Work out software baud rates if required
	#define SW_1200_BAUD	(832 - SW_OFFSET)
	#define SW_2400_BAUD	(416 - SW_OFFSET)
	#define SW_4800_BAUD	(208 - SW_OFFSET)
	#define SW_9600_BAUD	(104 - SW_OFFSET)
	#define SW_19200_BAUD	(52 - SW_OFFSET)
	#define SW_31250_BAUD	(32 - SW_OFFSET)
	#define SW_115200_BAUD	(8 - SW_OFFSET)
#endif

 #if defined(MX_UART_CHANNEL_1) && (MX_UART_NUM==1)
	#if (MX_UART_CHANNEL_1 == 0)
		#if (MX_UART_BAUD_1 == 1200)
			#define MX_SOFT_BAUD_1	SW_1200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 1200 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_1 == 2400)
			#define MX_SOFT_BAUD_1	SW_2400_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 2400 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_1 == 4800)
			#define MX_SOFT_BAUD_1	SW_4800_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 4800 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_1 == 9600)
			#define MX_SOFT_BAUD_1	SW_9600_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 9600 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_1 == 19200)
			#define MX_SOFT_BAUD_1	SW_19200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 19200 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_1 == 31250)
			#define MX_SOFT_BAUD_1	SW_31250_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 31250 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_1 == 115200)
			#define MX_SOFT_BAUD_1	SW_115200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 115200 Not Available At This Clock Speed"
			#endif
		#endif
		#ifndef MX_SOFT_BAUD_1
			#error "UART Baud Rate not supported in Software Mode"
		#endif
	#else
		#define MX_SOFT_BAUD_1	1
		#define MX_HARD_BAUD_1	(((MX_CLK_SPEED / MX_UART_BAUD_1) - 16) / 16)
		#define MX_HARD_SLOW_1	0

		#if (MX_HARD_BAUD_1 > 255)
			#undef MX_HARD_BAUD_1
			#undef MX_HARD_SLOW_1
			#define MX_HARD_BAUD_1	(((MX_CLK_SPEED / MX_UART_BAUD_1) - 16)	/ 64)
			#define MX_HARD_SLOW_1	1
		#endif

	#endif
 #endif
 #if defined(MX_UART_CHANNEL_2) && (MX_UART_NUM==2)
	#if (MX_UART_CHANNEL_2 == 0)
		#if (MX_UART_BAUD_2 == 1200)
			#define MX_SOFT_BAUD_2	SW_1200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 1200 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_2 == 2400)
			#define MX_SOFT_BAUD_2	SW_2400_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 2400 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_2 == 4800)
			#define MX_SOFT_BAUD_2	SW_4800_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 4800 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_2 == 9600)
			#define MX_SOFT_BAUD_2	SW_9600_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 9600 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_2 == 19200)
			#define MX_SOFT_BAUD_2	SW_19200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 19200 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_2 == 31250)
			#define MX_SOFT_BAUD_2	SW_31250_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 31250 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_2 == 115200)
			#define MX_SOFT_BAUD_2	SW_115200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 115200 Not Available At This Clock Speed"
			#endif
		#endif
		#ifndef MX_SOFT_BAUD_2
			#error "UART Baud Rate not supported in Software Mode"
		#endif
	#else
		#define MX_SOFT_BAUD_2	1
		#define MX_HARD_BAUD_2	(((MX_CLK_SPEED / MX_UART_BAUD_2) - 16) / 16)
		#define MX_HARD_SLOW_2	0

		#if (MX_HARD_BAUD_2 > 255)
			#undef MX_HARD_BAUD_2
			#undef MX_HARD_SLOW_2
			#define MX_HARD_BAUD_2	(((MX_CLK_SPEED / MX_UART_BAUD_2) - 16)	/ 64)
			#define MX_HARD_SLOW_2	1
		#endif
 	#endif
 #endif
 #if defined(MX_UART_CHANNEL_3) && (MX_UART_NUM==3)
	#if (MX_UART_CHANNEL_3 == 0)
		#if (MX_UART_BAUD_3 == 1200)
			#define MX_SOFT_BAUD_3	SW_1200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 1200 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_3 == 2400)
			#define MX_SOFT_BAUD_3	SW_2400_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 2400 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_3 == 4800)
			#define MX_SOFT_BAUD_3	SW_4800_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 4800 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_3 == 9600)
			#define MX_SOFT_BAUD_3	SW_9600_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 9600 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_3 == 19200)
			#define MX_SOFT_BAUD_3	SW_19200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 19200 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_3 == 31250)
			#define MX_SOFT_BAUD_3	SW_31250_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 31250 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_3 == 115200)
			#define MX_SOFT_BAUD_3	SW_115200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 115200 Not Available At This Clock Speed"
			#endif
		#endif
		#ifndef MX_SOFT_BAUD_3
			#error "UART Baud Rate not supported in Software Mode"
		#endif
	#else
		#define MX_SOFT_BAUD_3	1
		#define MX_HARD_BAUD_3	(((MX_CLK_SPEED / MX_UART_BAUD_3) - 16) / 16)
		#define MX_HARD_SLOW_3	0

		#if (MX_HARD_BAUD_3 > 255)
			#undef MX_HARD_BAUD_3
			#undef MX_HARD_SLOW_3
			#define MX_HARD_BAUD_3	(((MX_CLK_SPEED / MX_UART_BAUD_3) - 16)	/ 64)
			#define MX_HARD_SLOW_3	1
		#endif
	#endif
 #endif
 #if defined(MX_UART_CHANNEL_4) && (MX_UART_NUM==4)
	#if (MX_UART_CHANNEL_4 == 0)
		#if (MX_UART_BAUD_4 == 1200)
			#define MX_SOFT_BAUD_4	SW_1200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 1200 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_4 == 2400)
			#define MX_SOFT_BAUD_4	SW_2400_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 2400 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_4 == 4800)
			#define MX_SOFT_BAUD_4	SW_4800_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 4800 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_4 == 9600)
			#define MX_SOFT_BAUD_4	SW_9600_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 9600 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_4 == 19200)
			#define MX_SOFT_BAUD_4	SW_19200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 19200 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_4 == 31250)
			#define MX_SOFT_BAUD_4	SW_31250_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 31250 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_4 == 115200)
			#define MX_SOFT_BAUD_4	SW_115200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 115200 Not Available At This Clock Speed"
			#endif
		#endif
		#ifndef MX_SOFT_BAUD_4
			#error "UART Baud Rate not supported in Software Mode"
		#endif
	#else
		#define MX_SOFT_BAUD_4	1
		#define MX_HARD_BAUD_4	(((MX_CLK_SPEED / MX_UART_BAUD_4) - 16) / 16)
		#define MX_HARD_SLOW_4	0

		#if (MX_HARD_BAUD_4 > 255)
			#undef MX_HARD_BAUD_4
			#undef MX_HARD_SLOW_4
			#define MX_HARD_BAUD_4	(((MX_CLK_SPEED / MX_UART_BAUD_4) - 16)	/ 64)
			#define MX_HARD_SLOW_4	1
		#endif
	#endif
 #endif


//Hardware Baud update definitions
#ifndef MX_HARD_BAUD_CHANGE_DEFS
	#define MX_HARD_BAUD_CHANGE_DEFS

	#define MX_HARD_BAUD_1200	(((MX_CLK_SPEED / 1200) - 16) / 16)
	#if (MX_HARD_BAUD_1200 > 255)
		#undef MX_HARD_BAUD_1200
		#define MX_HARD_BAUD_1200	(((MX_CLK_SPEED / 1200) - 16) / 64)
		#define MX_HARD_SLOW_1200	1
	#else
		#define MX_HARD_SLOW_1200	0
	#endif

	#define MX_HARD_BAUD_2400	(((MX_CLK_SPEED / 2400) - 16) / 16)
	#if (MX_HARD_BAUD_2400 > 255)
		#undef MX_HARD_BAUD_2400
		#define MX_HARD_BAUD_2400	(((MX_CLK_SPEED / 2400) - 16) / 64)
		#define MX_HARD_SLOW_2400	1
	#else
		#define MX_HARD_SLOW_2400	0
	#endif

	#define MX_HARD_BAUD_4800	(((MX_CLK_SPEED / 4800) - 16) / 16)
	#if (MX_HARD_BAUD_4800 > 255)
		#undef MX_HARD_BAUD_4800
		#define MX_HARD_BAUD_4800	(((MX_CLK_SPEED / 4800) - 16) / 64)
		#define MX_HARD_SLOW_4800	1
	#else
		#define MX_HARD_SLOW_4800	0
	#endif

	#define MX_HARD_BAUD_9600	(((MX_CLK_SPEED / 9600) - 16) / 16)
	#if (MX_HARD_BAUD_9600 > 255)
		#undef MX_HARD_BAUD_9600
		#define MX_HARD_BAUD_9600	(((MX_CLK_SPEED / 9600) - 16) / 64)
		#define MX_HARD_SLOW_9600	1
	#else
		#define MX_HARD_SLOW_9600	0
	#endif

	#define MX_HARD_BAUD_19200	(((MX_CLK_SPEED / 19200) - 16) / 16)
	#if (MX_HARD_BAUD_19200 > 255)
		#undef MX_HARD_BAUD_19200
		#define MX_HARD_BAUD_19200	(((MX_CLK_SPEED / 19200) - 16) / 64)
		#define MX_HARD_SLOW_19200	1
	#else
		#define MX_HARD_SLOW_19200	0
	#endif

	#define MX_HARD_BAUD_38400	(((MX_CLK_SPEED / 38400) - 16) / 16)
	#if (MX_HARD_BAUD_38400 > 255)
		#undef MX_HARD_BAUD_38400
		#define MX_HARD_BAUD_38400	(((MX_CLK_SPEED / 38400) - 16) / 64)
		#define MX_HARD_SLOW_38400	1
	#else
		#define MX_HARD_SLOW_38400	0
	#endif

	#define MX_HARD_BAUD_57600	(((MX_CLK_SPEED / 57600) - 16) / 16)
	#if (MX_HARD_BAUD_57600 > 255)
		#undef MX_HARD_BAUD_57600
		#define MX_HARD_BAUD_57600	(((MX_CLK_SPEED / 57600) - 16) / 64)
		#define MX_HARD_SLOW_57600	1
	#else
		#define MX_HARD_SLOW_57600	0
	#endif

	#define MX_HARD_BAUD_115200	(((MX_CLK_SPEED / 115200) - 16) / 16)
	#if (MX_HARD_BAUD_115200 > 255)
		#undef MX_HARD_BAUD_115200
		#define MX_HARD_BAUD_115200	(((MX_CLK_SPEED / 115200) - 16) / 64)
		#define MX_HARD_SLOW_115200	1
	#else
		#define MX_HARD_SLOW_115200	0
	#endif
#endif


//Dynamic function naming based on defines and index number
#define MX_UART_CHANNEL_X	CAL_APPEND(MX_UART_CHANNEL_, MX_UART_NUM)
#define MX_UART_TX_PIN_X	CAL_APPEND(MX_UART_TX_PIN_, MX_UART_NUM)
#define MX_UART_TX_PORT_X	CAL_APPEND(MX_UART_TX_PORT_, MX_UART_NUM)
#define MX_UART_TX_TRIS_X	CAL_APPEND(MX_UART_TX_TRIS_, MX_UART_NUM)
#define MX_UART_RX_PIN_X	CAL_APPEND(MX_UART_RX_PIN_, MX_UART_NUM)
#define MX_UART_RX_PORT_X	CAL_APPEND(MX_UART_RX_PORT_, MX_UART_NUM)
#define MX_UART_RX_TRIS_X	CAL_APPEND(MX_UART_RX_TRIS_, MX_UART_NUM)
#define MX_UART_FLOWEN_X	CAL_APPEND(MX_UART_FLOWEN_, MX_UART_NUM)
#define MX_UART_CTS_PIN_X	CAL_APPEND(MX_UART_CTS_PIN_, MX_UART_NUM)
#define MX_UART_CTS_PORT_X	CAL_APPEND(MX_UART_CTS_PORT_, MX_UART_NUM)
#define MX_UART_CTS_TRIS_X	CAL_APPEND(MX_UART_CTS_TRIS_, MX_UART_NUM)
#define MX_UART_RTS_PIN_X	CAL_APPEND(MX_UART_RTS_PIN_, MX_UART_NUM)
#define MX_UART_RTS_PORT_X	CAL_APPEND(MX_UART_RTS_PORT_, MX_UART_NUM)
#define MX_UART_RTS_TRIS_X	CAL_APPEND(MX_UART_RTS_TRIS_, MX_UART_NUM)
#define MX_UART_DBITS_X		CAL_APPEND(MX_UART_DBITS_, MX_UART_NUM)
#define MX_UART_RETURN_X	CAL_APPEND(MX_UART_RETURN_, MX_UART_NUM)
#define MX_UART_ECHO_X		CAL_APPEND(MX_UART_ECHO_, MX_UART_NUM)
#define MX_UART_INT_X		CAL_APPEND(MX_UART_INT_, MX_UART_NUM)
#define MX_UART_BAUD_X		CAL_APPEND(MX_HARD_BAUD_, MX_UART_NUM)
#define MX_SOFT_BAUD_X		CAL_APPEND(MX_SOFT_BAUD_, MX_UART_NUM)
#define MX_HARD_SLOW_X		CAL_APPEND(MX_HARD_SLOW_, MX_UART_NUM)

#define UART_Delay_CAL		CAL_APPEND(FC_CAL_UART_Delay_, MX_UART_NUM)
#define UART_Send			CAL_APPEND(FC_CAL_UART_Send_, MX_UART_NUM)
#define UART_Uninit			CAL_APPEND(FC_CAL_UART_Uninit_, MX_UART_NUM)


//Component Definitions
#define UART_STATUS_LOOP	0
#define UART_STATUS_TIMEOUT	1
#define UART_STATUS_RXBYTE	2


//Interrupt Definitions
#ifdef MX_UART_2_PIE4
  #define MX_UART2_PIE pie4
  #define MX_UART2_PIR pir4
  #define MX_UART2_TXSTA tx2sta
  #define MX_UART2_RCSTA rc2sta
  #define MX_UART2_TXREG tx2reg
  #define MX_UART2_RCREG rc2reg
#else
  #define MX_UART2_PIE pie3
  #define MX_UART2_PIR pir3
  #define MX_UART2_TXSTA txsta2
  #define MX_UART2_RCSTA rcsta2
  #define MX_UART2_TXREG txreg2
  #define MX_UART2_RCREG rcreg2
#endif

#if (MX_UART_INT_X == 1)

	#ifndef MX_UART_INT_DEFS
	#define MX_UART_INT_DEFS

		#define MX_UART_INT_CH1_FUNC
		#define MX_UART_INT_CH2_FUNC
		#define MX_UART_INT_FUNC_END

		#define MX_UART_INT_CH1_DET		ts_bit(pir1, RCIF) && ts_bit(pie1, RCIE)
		#define MX_UART_INT_CH2_DET		ts_bit(MX_UART2_PIR, RC2IF) && ts_bit(MX_UART2_PIE, RC2IE)

		#define MX_UART_INT_CH1_EN		st_bit (pie1, RCIE)
		#define MX_UART_INT_CH2_EN		st_bit (MX_UART2_PIE, RC2IE)

		#define MX_UART_INT_CH1_DIS		cr_bit (pie1, RCIE)
		#define MX_UART_INT_CH2_DIS		cr_bit (MX_UART2_PIE, RC2IE)

		#define MX_UART_INT_CH1_CLR		cr_bit (pir1, RCIF)
		#define MX_UART_INT_CH2_CLR		cr_bit (MX_UART2_PIR, RC2IF)

	#endif
#endif


//Function Prototypes
CALFUNCTION(void, FC_CAL_UART_Init_, (void));
CALFUNCTION(void, FC_CAL_UART_Uninit_, (void));
CALFUNCTION(void, FC_CAL_UART_Send_, (MX_UINT16 nChar));
CALFUNCTION(MX_SINT16, FC_CAL_UART_Receive_, (MX_UINT8 nTimeout));
CALFUNCTION(void, FC_CAL_UART_Delay_, (void));


//Peripheral Functions
CALFUNCTION(void, FC_CAL_UART_Init_, (void))

{

	#if (MX_UART_CHANNEL_X == 0)
		FC_CAL_Bit_In_DDR 	(MX_UART_RX_PORT_X, MX_UART_RX_TRIS_X, MX_UART_RX_PIN_X);		// Receive pin is a input
		FC_CAL_Bit_High_DDR (MX_UART_TX_PORT_X, MX_UART_TX_TRIS_X, MX_UART_TX_PIN_X);		// Transmit pin is default high
	#endif

	#if (MX_UART_CHANNEL_X == 1)
	  #ifndef MX_UART_1
	  	  #error "UART channel 1 not available on this device"
	  #else
		  #if (MX_HARD_SLOW_X == 1)
			cr_bit(txsta, BRGH);						//Low Speed
		  #else
			st_bit(txsta, BRGH);						//High Speed
00AE  1683  	BSF STATUS, RP0
00AF  1303  	BCF STATUS, RP1
00B0  1518  	BSF gbl_txsta,2

		  #endif
			spbrg = MX_UART_BAUD_X;   					// set the baud rate
00B1  3019  	MOVLW 0x19
00B2  0099  	MOVWF gbl_spbrg

			rcsta = 0;                    				// 8-bit, disabled
00B3  1283  	BCF STATUS, RP0
00B4  0198  	CLRF gbl_rcsta


			#if(MX_UART_DBITS_X == 9)
				st_bit(txsta, TX9);   					// 9-bit TX
				st_bit(rcsta, RX9);                    	// 9-bit RX
			#endif

			st_bit(rcsta, SPEN);         				// turn on serial interface
00B5  1798  	BSF gbl_rcsta,7

			st_bit(txsta, TXEN);
00B6  1683  	BSF STATUS, RP0
00B7  1698  	BSF gbl_txsta,5

			st_bit(rcsta, CREN);
00B8  1283  	BCF STATUS, RP0
00B9  1618  	BSF gbl_rcsta,4


			#if (MX_UART_INT_X == 1)
				MX_UART_INT_CH1_EN;
				st_bit(intcon, PEIE);
				st_bit(intcon, GIE);
			#else
				cr_bit (pie1, RCIE);
00BA  1683  	BSF STATUS, RP0
00BB  128C  	BCF gbl_pie1,5

			#endif
	  #endif
	#endif


	#if (MX_UART_CHANNEL_X == 2)

	  #ifndef MX_UART_2
		  #error "UART channel 2 not available on this device"
	  #else
		  #ifdef MX_UART_2_REMAPPABLE
			RPOR9 = 5;									//TX2 - RP9 - RB6
			RPINR16	= 10;								//RX2 - RP10 - RB7
		  #endif
		  #if (MX_HARD_SLOW_X == 1)
			cr_bit(MX_UART2_TXSTA, BRGH);						//Low Speed
		  #else
			st_bit(MX_UART2_TXSTA, BRGH);						//High Speed
		  #endif
			spbrg2 = MX_UART_BAUD_X;   				// set the baud rate
			MX_UART2_RCSTA = 0;                    				// 8-bit, disabled

			#if(MX_UART_DBITS_X == 9)
				st_bit(MX_UART2_TXSTA, TX9);   					// 9-bit TX
				st_bit(MX_UART2_RCSTA, RX9);                    // 9-bit RX
			#endif

			st_bit(MX_UART2_RCSTA, SPEN);         				// turn on serial interface
			st_bit(MX_UART2_TXSTA, TXEN);
			st_bit(MX_UART2_RCSTA, CREN);

			#if (MX_UART_INT_X == 1)
				MX_UART_INT_CH2_EN;
				st_bit(intcon, PEIE);
				st_bit(intcon, GIE);
			#else
				cr_bit (MX_UART2_PIE, RC2IE);
			#endif
	  #endif
	#endif

	#if (MX_UART_FLOWEN_X == 1)						//Flowcontrol enabled?
		FC_CAL_Bit_In_DDR (MX_UART_CTS_PORT_X, MX_UART_CTS_TRIS_X, MX_UART_CTS_PIN_X);	// CTS pin is a input
		FC_CAL_Bit_High_DDR (MX_UART_RTS_PORT_X, MX_UART_RTS_TRIS_X, MX_UART_RTS_PIN_X);	// RTS not ready to accept data
	#endif

}
00BC  0008  	RETURN




CALFUNCTION(void, FC_CAL_UART_Uninit_, (void))
{

	#if (MX_UART_CHANNEL_X == 0)
		FC_CAL_Bit_In_DDR (MX_UART_RX_PORT_X, MX_UART_RX_TRIS_X, MX_UART_RX_PIN_X);		// Receive pin is a input
		FC_CAL_Bit_In_DDR (MX_UART_TX_PORT_X, MX_UART_TX_TRIS_X, MX_UART_TX_PIN_X);		// Transmit pin is default high
	#endif

	#if (MX_UART_CHANNEL_X == 1)
			rcsta = 0;                    								// 8-bit, disabled
			txsta = 0;
		  #ifdef MX_UART_RXINT
			MX_UART_INT_CH1_DIS;
		  #endif
	#endif

	#if (MX_UART_CHANNEL_X == 2)
			MX_UART2_RCSTA = 0;                    								// 8-bit, disabled
			MX_UART2_TXSTA = 0;
		  #ifdef MX_UART_RXINT
			MX_UART_INT_CH2_DIS;
		  #endif
	#endif

	#if (MX_UART_FLOWEN_X == 1)										//Flowcontrol enabled?
		FC_CAL_Bit_In_DDR (MX_UART_CTS_PORT_X, MX_UART_CTS_TRIS_X, MX_UART_CTS_PIN_X);		// CTS pin is a input
		FC_CAL_Bit_In_DDR (MX_UART_RTS_PORT_X, MX_UART_RTS_TRIS_X, MX_UART_RTS_PIN_X);		// RTS not ready to accept data
	#endif
}



CALFUNCTION(void, FC_CAL_UART_Send_, (MX_UINT16 nChar))
{
	#if (MX_UART_FLOWEN_X == 1)
		while (FC_CAL_Bit_In(MX_UART_CTS_PORT_X, MX_UART_CTS_PIN_X) != 0);	// Wait until CTS is low
	#endif

	#if (MX_UART_CHANNEL_X == 0)													// Software UART TX
		MX_UINT8 idx;
		FC_CAL_Bit_Low(MX_UART_TX_PORT_X, MX_UART_TX_PIN_X);					// Send Start bit
		UART_Delay_CAL();
		for (idx = 0; idx < MX_UART_DBITS_X; idx++)
		{
			if (nChar & 0x01)														// Mask off data bit
				FC_CAL_Bit_High(MX_UART_TX_PORT_X, MX_UART_TX_PIN_X);
			else
				FC_CAL_Bit_Low(MX_UART_TX_PORT_X, MX_UART_TX_PIN_X);
			UART_Delay_CAL();
			nChar = nChar >> 1;														// Move to next data bit
		}
		FC_CAL_Bit_High(MX_UART_TX_PORT_X, MX_UART_TX_PIN_X);					// Send Stop bit
		UART_Delay_CAL();
	#endif

	#if (MX_UART_CHANNEL_X == 1)
		while (ts_bit(pir1, TXIF) == 0);

		#if (MX_UART_DBITS_X == 9)
			if (test_bit(nChar, 8))
				st_bit(txsta, TX9D);
			else
				cr_bit(txsta, TX9D);
	  	#endif
		txreg = nChar;
	#endif

	#if (MX_UART_CHANNEL_X == 2)
		while (ts_bit(pir3, TX2IF) == 0);

		#if (MX_UART_DBITS_X == 9)
			if (test_bit(nChar, 8))
				st_bit(MX_UART2_TXSTA, TX9D);
			else
				cr_bit(MX_UART2_TXSTA, TX9D);
		#endif
		MX_UART2_TXREG = nChar;
	#endif
}


CALFUNCTION(MX_SINT16, FC_CAL_UART_Receive_, (MX_UINT8 nTimeout))

{
  #if (MX_UART_RETURN_X == 1)
	MX_UINT16 retVal = 512;
  #else
  	MX_UINT8 retVal = 255;
001A  30FF  	MOVLW 0xFF
001B  00D6  	MOVWF FC_CAL_UAR_00057_1_retVal

  #endif

	MX_UINT8 delay1 = 0;
001C  01D7  	CLRF FC_CAL_UAR_00057_1_delay1

	MX_UINT8 regcheck = 0;
001D  01D8  	CLRF FC_CAL_UAR_00057_1_regcheck

	MX_UINT8 bWaitForever = 0;
001E  01D9  	CLRF FC_CAL_UAR_00057_1_bWaitForever

	MX_UINT8 rxStatus = UART_STATUS_LOOP;
001F  01DA  	CLRF FC_CAL_UAR_00057_1_rxStatus


  #if (MX_UART_CHANNEL_X == 0)
  	MX_UINT8 idx;
  #else
  	MX_UINT8 dummy = 0;
0020  01DB  	CLRF FC_CAL_UAR_00057_1_dummy

  #endif

	if (nTimeout == 255)
0021  0A55  	INCF FC_CAL_UAR_00057_arg_nTimeout, W
0022  1D03  	BTFSS STATUS,Z
0023  2826  	GOTO	label2
0026        label2

		bWaitForever = 1;
0024  3001  	MOVLW 0x01
0025  00D9  	MOVWF FC_CAL_UAR_00057_1_bWaitForever


	#if (MX_UART_FLOWEN_X == 1)
		FC_CAL_Bit_Low (MX_UART_RTS_PORT_X, MX_UART_RTS_PIN_X);			// Ready to accept data
	#endif

	while (rxStatus == UART_STATUS_LOOP)
0026  08DA  	MOVF FC_CAL_UAR_00057_1_rxStatus, F
0027  1D03  	BTFSS STATUS,Z
0028  2848  	GOTO	label5
0047  2826  	GOTO	label2
0048        label5

	{
		if (bWaitForever == 0)
0029  08D9  	MOVF FC_CAL_UAR_00057_1_bWaitForever, F
002A  1D03  	BTFSS STATUS,Z
002B  283F  	GOTO	label4

		{
			if (nTimeout == 0)							//don't wait forever, so do timeout thing...
002C  08D5  	MOVF FC_CAL_UAR_00057_arg_nTimeout, F
002D  1D03  	BTFSS STATUS,Z
002E  2832  	GOTO	label3
0032        label3

			{
				rxStatus = UART_STATUS_TIMEOUT;
002F  3001  	MOVLW 0x01
0030  00DA  	MOVWF FC_CAL_UAR_00057_1_rxStatus

			}
			else
0031  283F  	GOTO	label4

			{
				delay_us(10);
0032  300A  	MOVLW 0x0A
0033  00DC  	MOVWF delay_us_00000_arg_del
0034  2010  	CALL delay_us_00000

				delay1 = delay1 + 1;
0035  0A57  	INCF FC_CAL_UAR_00057_1_delay1, W
0036  00D7  	MOVWF FC_CAL_UAR_00057_1_delay1

				if(delay1 == 100)
0037  0857  	MOVF FC_CAL_UAR_00057_1_delay1, W
0038  3A64  	XORLW 0x64
0039  1D03  	BTFSS STATUS,Z
003A  283F  	GOTO	label4
003F        label4

				{
					nTimeout = nTimeout - 1;
003B  0355  	DECF FC_CAL_UAR_00057_arg_nTimeout, W
003C  00D5  	MOVWF FC_CAL_UAR_00057_arg_nTimeout

					MX_CLEAR_WATCHDOG;
003D  0064  	CLRWDT

					delay1 = 0;
003E  01D7  	CLRF FC_CAL_UAR_00057_1_delay1

				}
			}
		}

		#if (MX_UART_CHANNEL_X == 0)
			regcheck = FC_CAL_Bit_In(MX_UART_RX_PORT_1, MX_UART_RX_PIN_1);	//Test for start bit
			if (regcheck == 0)
				rxStatus = UART_STATUS_RXBYTE;
		#endif

		#if (MX_UART_CHANNEL_X == 1)
			regcheck = ts_bit(pir1, RCIF);
003F  3020  	MOVLW 0x20
0040  050C  	ANDWF gbl_pir1, W
0041  00D8  	MOVWF FC_CAL_UAR_00057_1_regcheck

			if (regcheck != 0)
0042  08D8  	MOVF FC_CAL_UAR_00057_1_regcheck, F
0043  1903  	BTFSC STATUS,Z
0044  2826  	GOTO	label2

				rxStatus = UART_STATUS_RXBYTE;
0045  3002  	MOVLW 0x02
0046  00DA  	MOVWF FC_CAL_UAR_00057_1_rxStatus

		#endif

		#if (MX_UART_CHANNEL_X == 2)
			regcheck = ts_bit(MX_UART2_PIR, RC2IF);
			if (regcheck != 0)
				rxStatus = UART_STATUS_RXBYTE;
		#endif

	}

	if (rxStatus == UART_STATUS_RXBYTE)
0048  085A  	MOVF FC_CAL_UAR_00057_1_rxStatus, W
0049  3A02  	XORLW 0x02
004A  1D03  	BTFSS STATUS,Z
004B  2862  	GOTO	label8

	{
		#if (MX_UART_CHANNEL_X == 0)

			retVal = 0;
			UART_Delay_CAL();

			for (idx = 0; idx < MX_UART_DBITS_X; idx++)
			{
				if (FC_CAL_Bit_In(MX_UART_RX_PORT_X, MX_UART_RX_PIN_X))
					retVal = retVal | (0x01 << idx);

				UART_Delay_CAL();
			}
		#endif

		#if (MX_UART_CHANNEL_X == 1)
			regcheck = ts_bit(rcsta, FERR);
004C  3004  	MOVLW 0x04
004D  0518  	ANDWF gbl_rcsta, W
004E  00D8  	MOVWF FC_CAL_UAR_00057_1_regcheck

			if (regcheck != 0)
004F  08D8  	MOVF FC_CAL_UAR_00057_1_regcheck, F
0050  1903  	BTFSC STATUS,Z
0051  2855  	GOTO	label6
0055        label6

			{
				dummy = rcreg;						//need to read the rcreg to clear FERR
0052  081A  	MOVF gbl_rcreg, W
0053  00DB  	MOVWF FC_CAL_UAR_00057_1_dummy

				#if (MX_UART_RETURN_X == 1)
					retVal = 0x400;					//Framing Error Flag
				#endif
			}
			else
0054  2862  	GOTO	label8

			{
				regcheck = ts_bit(rcsta, OERR);
0055  3002  	MOVLW 0x02
0056  0518  	ANDWF gbl_rcsta, W
0057  00D8  	MOVWF FC_CAL_UAR_00057_1_regcheck

				if (regcheck != 0)
0058  08D8  	MOVF FC_CAL_UAR_00057_1_regcheck, F
0059  1903  	BTFSC STATUS,Z
005A  285E  	GOTO	label7
005E        label7

				{
					cr_bit(rcsta, CREN);			//Reset receiver to clear error
005B  1218  	BCF gbl_rcsta,4

					st_bit(rcsta, CREN);
005C  1618  	BSF gbl_rcsta,4


					#if (MX_UART_RETURN_X == 1)
						retVal = 0x800;				//Overrun Error Flag
					#endif
				}
				else
005D  2862  	GOTO	label8
0062        label8

				{
					retVal = 0;
005E  01D6  	CLRF FC_CAL_UAR_00057_1_retVal


					#if (MX_UART_DBITS_X == 9)
						if(ts_bit(rcsta, RX9D))
							retVal = 0x100;
					#endif

					retVal = retVal | rcreg; 			//no error, so rx byte is valid
005F  081A  	MOVF gbl_rcreg, W
0060  0456  	IORWF FC_CAL_UAR_00057_1_retVal, W
0061  00D6  	MOVWF FC_CAL_UAR_00057_1_retVal

				}
			}
		#endif

		#if (MX_UART_CHANNEL_X == 2)
			regcheck = ts_bit(MX_UART2_RCSTA, FERR);
			if (regcheck != 0)
			{
				dummy = MX_UART2_RCREG;			//need to read the rcreg to clear FERR
				#if (MX_UART_RETURN_X == 1)
					retVal = 0x400;					//Framing Error Flag
				#endif
			}
			else
			{
				regcheck = ts_bit(MX_UART2_RCSTA, OERR);
				if (regcheck != 0)
				{
					cr_bit(MX_UART2_RCSTA, CREN);	//Reset receiver to clear error
					st_bit(MX_UART2_RCSTA, CREN);
					#if (MX_UART_RETURN_X == 1)
						retVal = 0x800;				//Overrun Error Flag
					#endif
				}
				else
				{
					retVal = 0;

					#if (MX_UART_DBITS_X == 9)
						if(ts_bit(MX_UART2_RCSTA, RX9D))
							retVal = 0x100;
					#endif

					retVal = retVal | MX_UART2_RCREG; 			//no error, so rx byte is valid
				}
			}

		#endif

		#if (MX_UART_ECHO_X == 1)
			UART_Send(retVal);
		#endif
	}

	#if (MX_UART_FLOWEN_X == 1)
		FC_CAL_Bit_High(MX_UART_RTS_PORT_X, MX_UART_RTS_PIN_X);		//not ready to accept data
	#endif

	return (retVal);
0062  0856  	MOVF FC_CAL_UAR_00057_1_retVal, W
0063  00DC  	MOVWF CompTempVarRet2204
0064  01DD  	CLRF CompTempVarRet2204+D'1'

}
0065  0008  	RETURN



CALFUNCTION(void, FC_CAL_UART_Delay_, (void))
{
  #if (MX_UART_CHANNEL_X == 0)

	MX_UINT16 delay = MX_SOFT_BAUD_X;

	while (delay > 255)
	{
		delay_us(255);
		delay = delay - 255;
		MX_CLEAR_WATCHDOG;
	}
	delay_us(delay);
	MX_CLEAR_WATCHDOG;

  #endif
}


CALFUNCTION(void, FC_CAL_UART_Update_Baud_, (MX_UINT8 new_baud))
{
	//Baud Rates - Function compatible with hardware mode only
	/*
	0 - 1200
	1 - 2400
	2 - 4800
	3 - 9600
	4 - 19200
	5 - 38400
	6 - 57600
	7 - 115200
	*/

	MX_UINT8 baudrate, baudmode;

	if (new_baud > 7)
		return;

	if (new_baud == 0)
	{
		baudrate = MX_HARD_BAUD_1200;
		baudmode = MX_HARD_SLOW_1200;
	}
	else if (new_baud == 1)
	{
		baudrate = MX_HARD_BAUD_2400;
		baudmode = MX_HARD_SLOW_2400;
	}
	else if (new_baud == 2)
	{
		baudrate = MX_HARD_BAUD_4800;
		baudmode = MX_HARD_SLOW_4800;
	}
	else if (new_baud == 3)
	{
		baudrate = MX_HARD_BAUD_9600;
		baudmode = MX_HARD_SLOW_9600;
	}
	else if (new_baud == 4)
	{
		baudrate = MX_HARD_BAUD_19200;
		baudmode = MX_HARD_SLOW_19200;
	}
	else if (new_baud == 5)
	{
		baudrate = MX_HARD_BAUD_38400;
		baudmode = MX_HARD_SLOW_38400;
	}
	else if (new_baud == 6)
	{
		baudrate = MX_HARD_BAUD_57600;
		baudmode = MX_HARD_SLOW_57600;
	}
	else if (new_baud == 7)
	{
		baudrate = MX_HARD_BAUD_115200;
		baudmode = MX_HARD_SLOW_115200;
	}

	UART_Uninit();

	#if (MX_UART_CHANNEL_X == 1)

	    if (baudmode == 1)
			cr_bit(txsta, BRGH);					//Low Speed
	    else
			st_bit(txsta, BRGH);					//High Speed

		spbrg = baudrate;   						// set the baud rate
		rcsta = 0;                    				// 8-bit, disabled

		#if(MX_UART_DBITS_X == 9)
			st_bit(txsta, TX9);   					// 9-bit TX
			st_bit(rcsta, RX9);                    	// 9-bit RX
		#endif

		st_bit(rcsta, SPEN);         				// turn on serial interface
		st_bit(txsta, TXEN);
		st_bit(rcsta, CREN);

		#if (MX_UART_INT_X == 1)
			MX_UART_INT_CH1_EN;
			st_bit(intcon, PEIE);
			st_bit(intcon, GIE);
		#else
			cr_bit (pie1, RCIE);
		#endif
	#endif

	#if (MX_UART_CHANNEL_X == 2)

	  	if (baudmode == 1)
			cr_bit(MX_UART2_TXSTA, BRGH);			//Low Speed
	  	else
			st_bit(MX_UART2_TXSTA, BRGH);			//High Speed

		spbrg2 = baudrate;   						// set the baud rate
		MX_UART2_RCSTA = 0;                    		// 8-bit, disabled

		#if(MX_UART_DBITS_X == 9)
			st_bit(MX_UART2_TXSTA, TX9);   			// 9-bit TX
			st_bit(MX_UART2_RCSTA, RX9);            // 9-bit RX
		#endif

		st_bit(MX_UART2_RCSTA, SPEN);         		// turn on serial interface
		st_bit(MX_UART2_TXSTA, TXEN);
		st_bit(MX_UART2_RCSTA, CREN);

		#if (MX_UART_INT_X == 1)
			MX_UART_INT_CH2_EN;
			st_bit(intcon, PEIE);
			st_bit(intcon, GIE);
		#else
			cr_bit (MX_UART2_PIE, RC2IE);
		#endif
	#endif

	#if (MX_UART_FLOWEN_X == 1)						//Flowcontrol enabled?
		FC_CAL_Bit_In_DDR (MX_UART_CTS_PORT_X, MX_UART_CTS_TRIS_X, MX_UART_CTS_PIN_X);	// CTS pin is a input
		FC_CAL_Bit_High_DDR (MX_UART_RTS_PORT_X, MX_UART_RTS_TRIS_X, MX_UART_RTS_PIN_X);	// RTS not ready to accept data
	#endif

}

////////////////////////////////////////
// Code with no source :-)
////////////////////////////////////////
0000  29A9  	GOTO	_startup

0004  00FF  	MOVWF Int1Context
0005  0E03  	SWAPF STATUS, W
0006  1283  	BCF STATUS, RP0
0007  1303  	BCF STATUS, RP1
0008  00B9  	MOVWF Int1BContext
0009  0E0A  	SWAPF PCLATH, W
000A  00BA  	MOVWF Int1BContext+D'1'
000B  0E04  	SWAPF FSR, W
000C  00BB  	MOVWF Int1BContext+D'2'
000D  118A  	BCF PCLATH,3
000E  120A  	BCF PCLATH,4
000F  29D8  	GOTO	interrupt
0010        delay_us_00000
0010        ; { delay_us ; function begin
0010  3003  	MOVLW 0x03
0011  07DC  	ADDWF delay_us_00000_arg_del, F
0012  0CDC  	RRF delay_us_00000_arg_del, F
0013  0CDC  	RRF delay_us_00000_arg_del, F
0014  307F  	MOVLW 0x7F
0015  05DC  	ANDWF delay_us_00000_arg_del, F
0016        label1
0016  0000  	NOP
0017  0BDC  	DECFSZ delay_us_00000_arg_del, F
0018  2816  	GOTO	label1
0019  0008  	RETURN
001A        ; } delay_us function end


01A9        _startup
01A9  30D5  	MOVLW 0xD5
01AA  1283  	BCF STATUS, RP0
01AB  1303  	BCF STATUS, RP1
01AC  00A5  	MOVWF gbl_14_LSR
01AD  30C4  	MOVLW 0xC4
01AE  00A6  	MOVWF gbl_14_LSR+D'1'
01AF  30BB  	MOVLW 0xBB
01B0  00A7  	MOVWF gbl_14_LSR+D'2'
01B1  30DC  	MOVLW 0xDC
01B2  00A8  	MOVWF gbl_14_LSR+D'3'
01B3  01A9  	CLRF gbl_15_gbl_aSig
01B4  01AA  	CLRF gbl_15_gbl_aSig+D'1'
01B5  01AB  	CLRF gbl_15_gbl_aSig+D'2'
01B6  01AC  	CLRF gbl_15_gbl_aSig+D'3'
01B7  01AD  	CLRF gbl_15_gbl_bSig
01B8  01AE  	CLRF gbl_15_gbl_bSig+D'1'
01B9  01AF  	CLRF gbl_15_gbl_bSig+D'2'
01BA  01B0  	CLRF gbl_15_gbl_bSig+D'3'
01BB  01B1  	CLRF gbl_15_gbl_zSig
01BC  01B2  	CLRF gbl_15_gbl_zSig+D'1'
01BD  01B3  	CLRF gbl_15_gbl_zSig+D'2'
01BE  01B4  	CLRF gbl_15_gbl_zSig+D'3'
01BF  01C1  	CLRF gbl_15_gbl_aExp
01C0  01C2  	CLRF gbl_15_gbl_bExp
01C1  01BC  	CLRF gbl_15_gbl_zExp
01C2  01BD  	CLRF gbl_15_gbl_zExp+D'1'
01C3  01C3  	CLRF gbl_15_gbl_aSign
01C4  01C4  	CLRF gbl_15_gbl_bSign
01C5  01C5  	CLRF gbl_15_gbl_zSign
01C6  01C6  	CLRF gbl_15_gbl_zSigZero
01C7  01B5  	CLRF gbl_15_gbl_ret
01C8  01B6  	CLRF gbl_15_gbl_ret+D'1'
01C9  01B7  	CLRF gbl_15_gbl_ret+D'2'
01CA  01B8  	CLRF gbl_15_gbl_ret+D'3'
01CB  01BF  	CLRF gbl_float_rounding_mode
01CC  01C0  	CLRF gbl_float_exception_flags
01CD  01BE  	CLRF gbl_float_detect_tininess

01D5  118A  	BCF PCLATH,3
01D6  120A  	BCF PCLATH,4
01D7  2984  	GOTO	main

2007  30D4  	DW 0x30D4
