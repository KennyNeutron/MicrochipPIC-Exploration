;/////////////////////////////////////////////////////////////////////////////////
;// Code Generator: BoostC Compiler - http://www.sourceboost.com
;// Version       : 7.03
;// License Type  : Pro License
;// Limitations   : PIC12,PIC16 max code size:Unlimited, max RAM banks:Unlimited
;/////////////////////////////////////////////////////////////////////////////////

/*********************************************************************
 *                  Flowcode CAL Delays File
 *
 * File: PIC_CAL_Delay.c
 *
 * (c) 2011 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * “Company”) for its Flowcode graphical programming language is
 * intended and supplied to you, the Company’s customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 010911 | BR | Created
 *
 *
 *
 */

//Original Byte Delays
void Wdt_Delay_S(char delay);
void Wdt_Delay_Ms(char delay);

//New Int Delays
void FCI_DELAYINT_US(MX_UINT16 Delay);

void FCI_DELAYINT_MS(MX_UINT16 Delay);
void FCI_DELAYINTWDT_MS(MX_UINT16 Delay);

void FCI_DELAYINT_S(MX_UINT16 Delay);
void FCI_DELAYINTWDT_S(MX_UINT16 Delay);


#ifdef HI_TECH_C

	#define nop()	asm("NOP")

	void delay_10us(char del);
	void delay_us(char del);
	void delay_ms(char del);
	void delay_s(char del);

	void delay_10us(char del)
	{
		char count;
		for(count=0; count<10; count++)
		{
			delay_us(del);
		}
	}

	void delay_us(char del)
	{
		while (del > 1)
		{
			__delay_us(1);
			del = del - 1;
		}
	}

	void delay_ms(char del)
	{
		while (del > 1)
		{
			__delay_ms(1);
			del = del - 1;
		}
	}

	void delay_s(char del)
	{
		char i;
		for(i=0; i<del; i++)
		{
			delay_ms(250);
			delay_ms(250);
			delay_ms(250);
			delay_ms(250);
		}
	}

#endif

void Wdt_Delay_S(char delay)
{
    char i;
    short j;
    for (i=0; i<delay; i++)
    {
        for (j=0; j<999; j++)
        {
            Wdt_Delay_Ms(1);
        }
    }
}

void Wdt_Delay_Ms(char delay)

{
    char i;
    for (i=0; i<delay; i++)
0076  01CF  	CLRF Wdt_Delay__0003E_1_i
0077        label10
0077  084E  	MOVF Wdt_Delay__0003E_arg_delay, W
0078  024F  	SUBWF Wdt_Delay__0003E_1_i, W
0079  1803  	BTFSC STATUS,C
007F  0ACF  	INCF Wdt_Delay__0003E_1_i, F
0080  2877  	GOTO	label10

    {
        MX_CLEAR_WATCHDOG;        //Clear Watchdog Timer
007B  0064  	CLRWDT

        delay_ms(1);
007C  3001  	MOVLW 0x01
007D  00D4  	MOVWF delay_ms_00000_arg_del
007E  2015  	CALL delay_ms_00000

    }
}
007A  0008  	RETURN



void FCI_DELAYINT_US(MX_UINT16 Delay)
{
  	while (Delay > 255)
  	{
	  	delay_us(255);
	  	Delay = Delay - 255;
  	}
  	if (Delay > 0)
  		delay_us(Delay & 0xFF);
}

void FCI_DELAYINT_MS(MX_UINT16 Delay)
{
  	while (Delay > 255)
  	{
	  	delay_ms(255);
	  	Delay = Delay - 255;
  	}
  	if (Delay > 0)
  		delay_ms(Delay & 0xFF);
}

void FCI_DELAYINTWDT_MS(MX_UINT16 Delay)
{
  	while (Delay > 255)
  	{
	  	Wdt_Delay_Ms(255);
	  	Delay = Delay - 255;
  	}
  	if (Delay > 0)
  		Wdt_Delay_Ms(Delay & 0xFF);
}

void FCI_DELAYINT_S(MX_UINT16 Delay)
{
  	while (Delay > 255)
  	{
	  	delay_s(255);
	  	Delay = Delay - 255;
  	}
  	if (Delay > 0)
  		delay_s(Delay & 0xFF);
}

void FCI_DELAYINTWDT_S(MX_UINT16 Delay)
{
  	while (Delay > 255)
  	{
	  	Wdt_Delay_S(255);
	  	Delay = Delay - 255;
  	}
  	if (Delay > 0)
  		Wdt_Delay_S(Delay & 0xFF);
}



//************************************************************************************
//**  
//**  File name:     D:\KennyNeutronsInnovations\AC\FlowCode\NDKC_Lab_Security.c
//**  Title:         
//**  Description:   
//**  
//**  Generated by:  Flowcode v5.2.0.0
//**  Date:          Wednesday, March 06, 2019 18:51:17
//**  Licence:       Professional
//**  Registered to: xyz
//**  Licence key:   WUK7B9
//**  
//**  
//**  http://www.matrixmultimedia.com
//**  
//************************************************************************************


#define MX_PIC

#define MX_USES_UINT8 1
#define MX_USES_SINT16 0
#define MX_USES_CHAR 0
#define MX_USES_FLOAT 0
#define MX_USES_SINT32 0
#define MX_USES_BOOL 1
#define MX_USES_UINT16 0
#define MX_USES_UINT32 0
//Defines for microcontroller
#define P16F887
#define FC_CAL_PIC
#define MX_ADC
#define MX_ADC_TYPE_7
#define MX_ADC_BITS_10
#define MX_EE
#define MX_EE_TYPE2
#define MX_EE_SIZE 256
#define MX_SPI_1
#define MX_SPI_1_MISO_PORT portc
#define MX_SPI_1_MISO_TRIS trisc
#define MX_SPI_1_MISO_PIN 4
#define MX_SPI_1_MOSI_PORT portc
#define MX_SPI_1_MOSI_TRIS trisc
#define MX_SPI_1_MOSI_PIN 5
#define MX_SPI_1_CLK_PORT portc
#define MX_SPI_1_CLK_TRIS trisc
#define MX_SPI_1_CLK_PIN 3
#define MX_SPI_1_SS_PORT portc
#define MX_SPI_1_SS_TRIS trisc
#define MX_UART_1
#define MX_UART_1_TX_PORT portc
#define MX_UART_1_TX_TRIS trisc
#define MX_UART_1_TX_PIN 6
#define MX_UART_1_RX_PORT portc
#define MX_UART_1_RX_TRIS trisc
#define MX_UART_1_RX_PIN 7
#define MX_I2C
#define MX_MI2C
#define MX_I2C_1
#define MX_I2C_1_SDA_PORT portc
#define MX_I2C_1_SDA_TRIS trisc
#define MX_I2C_1_SDA_PIN 4
#define MX_I2C_1_SCL_PORT portc
#define MX_I2C_1_SCL_TRIS trisc
#define MX_I2C_1_SCL_PIN 3
#define MX_PWM
#define MX_PWM_CNT 2
#define MX_PWM_PSCA1
#define MX_PWM_PSCA4
#define MX_PWM_PSCA16
#define MX_PWM_1_PORT portc
#define MX_PWM_1_TRIS trisc
#define MX_PWM_1_PIN 2
#define MX_PWM_2_PORT portc
#define MX_PWM_2_TRIS trisc
#define MX_PWM_2_PIN 1

//Functions
#define MX_CLK_SPEED 20000000
#ifdef _BOOSTC
#include <system.h>
#endif
#ifdef HI_TECH_C
#include <pic.h>
#endif

//Configuration data
#ifdef _BOOSTC
#pragma DATA 0x2007, 0x20c2
#endif
#ifdef HI_TECH_C
__CONFIG(0x20c2);
#endif
#ifdef _BOOSTC
#pragma DATA 0x2008, 0x3eff
#endif
#ifdef HI_TECH_C
__CONFIG(0x3eff);
#endif

//Internal functions
#include "C:\Program Files (x86)\Flowcode\v5\FCD\internals.c"

//Macro function declarations
void FCM_Equipment1();
void FCM_Equipment2();
void FCM_Equipment3();
void FCM_init();
void FCM_check();
void FCM_Equipment4();
void FCM_Equipment5();
void FCM_Equipment6();


//Variable declarations
#define FCV_FALSE (0)
#define FCV_TRUE (1)
MX_BOOL FCV_EQ1_SE1 = (0);
0989  1042  	BCF gbl_FCV_EQ1_SE1,0

MX_BOOL FCV_EQ2_SE1 = (0);
098A  10C2  	BCF gbl_FCV_EQ2_SE1,1

MX_BOOL FCV_EQ1_SE2 = (0);
098B  1142  	BCF gbl_FCV_EQ1_SE2,2

MX_BOOL FCV_EQ6_FLAG = (0);
098C  11C2  	BCF gbl_FCV_EQ6_FLAG,3

MX_BOOL FCV_EQ2_ERRORFLAG = (0);
098D  1242  	BCF gbl_FCV_EQ2_ERRORFLAG,4

MX_BOOL FCV_EQ3_SE1 = (0);
098E  12C2  	BCF gbl_FCV_EQ3_SE1,5

MX_BOOL FCV_EQ2_SE2 = (0);
098F  1342  	BCF gbl_FCV_EQ2_SE2,6

MX_BOOL FCV_EQ5_ERRORFLAG = (0);
0990  13C2  	BCF gbl_FCV_EQ5_ERRORFLAG,7

MX_BOOL FCV_EQ5_FLAG = (0);
0991  1043  	BCF gbl_FCV_EQ5_FLAG,0

MX_BOOL FCV_EQ3_SE2 = (0);
0992  10C3  	BCF gbl_FCV_EQ3_SE2,1

MX_BOOL FCV_EQ4_FLAG = (0);
0993  1143  	BCF gbl_FCV_EQ4_FLAG,2

MX_BOOL FCV_EQ4_SE1 = (0);
0994  11C3  	BCF gbl_FCV_EQ4_SE1,3

MX_BOOL FCV_EQ3_FLAG = (0);
0995  1243  	BCF gbl_FCV_EQ3_FLAG,4

MX_BOOL FCV_EQ4_SE2 = (0);
0996  12C3  	BCF gbl_FCV_EQ4_SE2,5

MX_BOOL FCV_EQ5_SE1 = (0);
0997  1343  	BCF gbl_FCV_EQ5_SE1,6

MX_BOOL FCV_EQ2_FLAG = (0);
0998  13C3  	BCF gbl_FCV_EQ2_FLAG,7

MX_UINT8 FCV_RX = (0x0);
0999  01C4  	CLRF gbl_FCV_RX

MX_BOOL FCV_DOORLOCK = (0);
099A  1045  	BCF gbl_FCV_DOORLOCK,0

MX_BOOL FCV_SIREN_FLAG = (0);
099B  10C5  	BCF gbl_FCV_SIREN_FLAG,1

MX_BOOL FCV_EQ5_SE2 = (0);
099C  1145  	BCF gbl_FCV_EQ5_SE2,2

MX_BOOL FCV_EQ6_SE1 = (0);
099D  11C5  	BCF gbl_FCV_EQ6_SE1,3

MX_UINT8 FCV_FBIT = (0x0);
099E  01C6  	CLRF gbl_FCV_FBIT

MX_BOOL FCV_EQ1_FLAG = (0);
099F  1245  	BCF gbl_FCV_EQ1_FLAG,4

MX_BOOL FCV_EQ6_SE2 = (0);
09A0  12C5  	BCF gbl_FCV_EQ6_SE2,5

MX_BOOL FCV_EQ1_ERRORFLAG = (0);
09A1  1345  	BCF gbl_FCV_EQ1_ERRORFLAG,6

MX_BOOL FCV_EQ4_ERRORFLAG = (0);
09A2  13C5  	BCF gbl_FCV_EQ4_ERRORFLAG,7

MX_BOOL FCV_FLAG = (0);
09A3  1047  	BCF gbl_FCV_FLAG,0

MX_BOOL FCV_EQ3_ERRORFLAG;
MX_BOOL FCV_EQ6_ERRORFLAG = (0);
09A4  1147  	BCF gbl_FCV_EQ6_ERRORFLAG,2

MX_BOOL FCV_SIREN = (0);
09A5  11C7  	BCF gbl_FCV_SIREN,3





//LCDDisplay(0): //Defines:

/**** Macro Substitutions ****
a = Unique Component Reference Number
b = D1 Port Letter
c = D2 Port Letter
d = D3 Port Letter
e = D4 Port Letter
f = RS Port Letter
g = E Port Letter
h = Data 1_Pin
i = Data 2 Pin
j = Data 3 Pin
k = Data 4 Pin
l = RS Pin
m = Enable Pin
n = Row Count
o = Column Count
******************************/

	//component connections
	#define LCD_1__PORT0    portb
	#define LCD_1__PORT1    portb
	#define LCD_1__PORT2    portb
	#define LCD_1__PORT3    portb
	#define LCD_1__PORT4    portb
	#define LCD_1__PORT5    portb
	#define LCD_1__TRIS0    trisb
	#define LCD_1__TRIS1    trisb
	#define LCD_1__TRIS2    trisb
	#define LCD_1__TRIS3    trisb
	#define LCD_1__TRIS4    trisb
	#define LCD_1__TRIS5    trisb
	#define LCD_1__BIT0    	5
	#define LCD_1__BIT1    	4
	#define LCD_1__BIT2    	3
	#define LCD_1__BIT3    	2
	#define LCD_1__RS      	7
	#define LCD_1__E       	6
	#define LCD_1__ROWCNT	2
	#define LCD_1__COLCNT	16

	#ifdef _BOOSTC
	  #define LCD_1__DELAY   delay_10us(10)
	#endif
	#ifdef _C2C_
	  #define LCD_1__DELAY   delay_us(100)
	#endif
	#ifdef HI_TECH_C
	  #define LCD_1__DELAY   __delay_us(120)
	#endif
	#ifndef LCD_1__DELAY
	  #define LCD_1__DELAY   delay_us(100)
	#endif




//LCDDisplay(0): //Macro function declarations

void FCD_LCDDisplay0_RawSend(MX_UINT8 in, MX_UINT8 mask);
void FCD_LCDDisplay0_Start();
void FCD_LCDDisplay0_Clear();
void FCD_LCDDisplay0_PrintASCII(MX_UINT8 Character);
void FCD_LCDDisplay0_Command(MX_UINT8 in);
void FCD_LCDDisplay0_Cursor(MX_UINT8 x, MX_UINT8 y);
void FCD_LCDDisplay0_PrintNumber(MX_SINT16 Number);
void FCD_LCDDisplay0_PrintString(MX_STRING String, MX_UINT8 MSZ_String);
void FCD_LCDDisplay0_ScrollDisplay(MX_UINT8 Direction, MX_UINT8 Num_Positions);
void FCD_LCDDisplay0_ClearLine(MX_UINT8 Line);
void FCD_LCDDisplay0_RAM_Write(MX_UINT8 nIdx, MX_UINT8 d0, MX_UINT8 d1, MX_UINT8 d2, MX_UINT8 d3, MX_UINT8 d4, MX_UINT8 d5, MX_UINT8 d6, MX_UINT8 d7);


//RS232(0): //Defines:

/**** Macro Substitutions ****
a = Unique Reference
b = Uart Channel		(0-software / 1-4 hardware)
c = tx pin
d = tx port
e = rx pin
f = rx port
g = flow control		(0-Off / 1-On)
h = cts pin
i = cts port
j = rts pin
k = rts port
l = baud rate
m = data bits			(7/8/9) (7 only supported in software modes)
n = return type		(0-byte / 1-MX_UINT16)
o = echo enable		(0-Off / 1-On)
******************************/

//Definitions for RS232 UART slot allocation
#ifndef	MX_UART_REF1
	#define MX_UART_REF1
	#define RS232_2_MX_UART_UREF			1
	#define MX_UART_CHANNEL_1		1
	#define MX_UART_TX_PIN_1		0
	#define MX_UART_TX_PORT_1		porta
	#define MX_UART_TX_TRIS_1		trisa
	#define MX_UART_RX_PIN_1		0
	#define MX_UART_RX_PORT_1		porta
	#define MX_UART_RX_TRIS_1		trisa
	#define MX_UART_FLOWEN_1		0
	#define MX_UART_CTS_PIN_1		4
	#define MX_UART_CTS_PORT_1		portc
	#define MX_UART_CTS_TRIS_1		trisc
	#define MX_UART_RTS_PIN_1		0
	#define MX_UART_RTS_PORT_1		portc
	#define MX_UART_RTS_TRIS_1		trisc
	#define MX_UART_BAUD_1			9600
	#define MX_UART_DBITS_1			8
	#define MX_UART_RETURN_1		0
	#define MX_UART_ECHO_1			0
	#define MX_UART_INT_1			0
#else
 #ifndef	MX_UART_REF2
	#define MX_UART_REF2
	#define RS232_2_MX_UART_UREF			2
	#define MX_UART_CHANNEL_2		1
	#define MX_UART_TX_PIN_2		0
	#define MX_UART_TX_PORT_2		porta
	#define MX_UART_TX_TRIS_2		trisa
	#define MX_UART_RX_PIN_2		0
	#define MX_UART_RX_PORT_2		porta
	#define MX_UART_RX_TRIS_2		trisa
	#define MX_UART_FLOWEN_2		0
	#define MX_UART_CTS_PIN_2		4
	#define MX_UART_CTS_PORT_2		portc
	#define MX_UART_CTS_TRIS_2		trisc
	#define MX_UART_RTS_PIN_2		0
	#define MX_UART_RTS_PORT_2		portc
	#define MX_UART_RTS_TRIS_2		trisc
	#define MX_UART_BAUD_2			9600
	#define MX_UART_DBITS_2			8
	#define MX_UART_RETURN_2		0
	#define MX_UART_ECHO_2			0
	#define MX_UART_INT_2			0
 #else
  #ifndef	MX_UART_REF3
	#define MX_UART_REF3
	#define RS232_2_MX_UART_UREF			3
	#define MX_UART_CHANNEL_3		1
	#define MX_UART_TX_PIN_3		0
	#define MX_UART_TX_PORT_3		porta
	#define MX_UART_TX_TRIS_3		trisa
	#define MX_UART_RX_PIN_3		0
	#define MX_UART_RX_PORT_3		porta
	#define MX_UART_RX_TRIS_3		trisa
	#define MX_UART_FLOWEN_3		0
	#define MX_UART_CTS_PIN_3		4
	#define MX_UART_CTS_PORT_3		portc
	#define MX_UART_CTS_TRIS_3		trisc
	#define MX_UART_RTS_PIN_3		0
	#define MX_UART_RTS_PORT_3		portc
	#define MX_UART_RTS_TRIS_3		trisc
	#define MX_UART_BAUD_3			9600
	#define MX_UART_DBITS_3			8
	#define MX_UART_RETURN_3		0
	#define MX_UART_ECHO_3			0
	#define MX_UART_INT_3			0
  #else
   #ifndef	MX_UART_REF4
	#define MX_UART_REF4
	#define RS232_2_MX_UART_UREF			4
	#define MX_UART_CHANNEL_4		1
	#define MX_UART_TX_PIN_4		0
	#define MX_UART_TX_PORT_4		porta
	#define MX_UART_TX_TRIS_4		trisa
	#define MX_UART_RX_PIN_4		0
	#define MX_UART_RX_PORT_4		porta
	#define MX_UART_RX_TRIS_4		trisa
	#define MX_UART_FLOWEN_4		0
	#define MX_UART_CTS_PIN_4		4
	#define MX_UART_CTS_PORT_4		portc
	#define MX_UART_CTS_TRIS_4		trisc
	#define MX_UART_RTS_PIN_4		0
	#define MX_UART_RTS_PORT_4		portc
	#define MX_UART_RTS_TRIS_4		trisc
	#define MX_UART_BAUD_4			9600
	#define MX_UART_DBITS_4			8
	#define MX_UART_RETURN_4		0
	#define MX_UART_ECHO_4			0
	#define MX_UART_INT_4			0
   #endif
  #endif
 #endif
#endif

#define RS232_2_UART_Init		CAL_APPEND(FC_CAL_UART_Init_, RS232_2_MX_UART_UREF)
#define RS232_2_UART_Send		CAL_APPEND(FC_CAL_UART_Send_, RS232_2_MX_UART_UREF)
#define RS232_2_UART_Receive		CAL_APPEND(FC_CAL_UART_Receive_, RS232_2_MX_UART_UREF)
#define RS232_2_UART_Update_Baud CAL_APPEND(FC_CAL_UART_Update_Baud_, RS232_2_MX_UART_UREF)

extern void RS232_2_UART_Init();
extern void RS232_2_UART_Send(MX_UINT16 nChar);
extern MX_SINT16 RS232_2_UART_Receive(MX_UINT8 nTimeout);
extern void RS232_2_UART_Update_Baud(MX_UINT8 newbaud);




//RS232(0): //Macro function declarations

void FCD_RS2320_SendRS232Char(MX_SINT16 nChar);
void FCD_RS2320_SendRS232String(MX_STRING String, MX_UINT8 MSZ_String);
MX_SINT16 FCD_RS2320_ReceiveRS232Char(MX_UINT8 nTimeout);
void FCD_RS2320_ReceiveRS232String(MX_CHAR* FCR_RETVAL, MX_UINT8 FCR_RETVAL_SIZE, MX_UINT8 nTimeout, MX_UINT8 NumBytes);
void FCD_RS2320_ChangeHWBaud(MX_UINT8 newbaud);


//PWM(0): //Defines:

/**** Macro Substitutions ****
a = Unique Reference
b = PWM Channel - 0=SW / 1-8=HW
c = PWM Alt Pin FCD_PWM0_Enable - 0=Standard / 1=Alt
d = PWM Period
e = PWM Prescaler 1
******************************/

//Period and Prescaler Defines
#ifndef MX_PWM_PERIOD
  #define MX_PWM_PERIOD				155
#else
  #if (MX_PWM_PERIOD != 155)
    #error "PWM period value must be the same in all PWM modules"
  #endif
#endif

#ifndef MX_PWM_PRESCALE1
  #define MX_PWM_PRESCALE1			16
#else
  #if (MX_PWM_PRESCALE1 != 16)
    #error "PWM prescale value must be the same in all PWM modules"
  #endif
#endif

//Definitions for PWM slot allocation
#ifndef	MX_PWM_REF1
			#define MX_PWM_REF1
			#define PWM_5_MX_PWM_UREF			1
			#define MX_PWM_CHANNEL_1		1
			#define MX_PWM_HWALT_1			0
#else
 #ifndef	MX_PWM_REF2
			#define MX_PWM_REF2
			#define PWM_5_MX_PWM_UREF			2
			#define MX_PWM_CHANNEL_2		1
			#define MX_PWM_HWALT_2			0
 #else
  #ifndef	MX_PWM_REF3
			#define MX_PWM_REF3
			#define PWM_5_MX_PWM_UREF			3
			#define MX_PWM_CHANNEL_3		1
			#define MX_PWM_HWALT_3			0
  #else
   #ifndef	MX_PWM_REF4
			#define MX_PWM_REF4
			#define PWM_5_MX_PWM_UREF			4
			#define MX_PWM_CHANNEL_4		1
			#define MX_PWM_HWALT_4			0
   #else
    #ifndef	MX_PWM_REF5
			#define MX_PWM_REF5
			#define PWM_5_MX_PWM_UREF			5
			#define MX_PWM_CHANNEL_5		1
			#define MX_PWM_HWALT_5			0
    #else
     #ifndef	MX_PWM_REF6
			#define MX_PWM_REF6
			#define PWM_5_MX_PWM_UREF			6
			#define MX_PWM_CHANNEL_6		1
			#define MX_PWM_HWALT_6			0
     #else
      #ifndef	MX_PWM_REF7
			#define MX_PWM_REF7
			#define PWM_5_MX_PWM_UREF			7
			#define MX_PWM_CHANNEL_7		1
			#define MX_PWM_HWALT_7			0
      #else
       #ifndef	MX_PWM_REF8
			#define MX_PWM_REF8
			#define PWM_5_MX_PWM_UREF			8
			#define MX_PWM_CHANNEL_8		1
			#define MX_PWM_HWALT_8			0
       #else
        #ifndef	MX_PWM_REF9
			#define MX_PWM_REF9
			#define PWM_5_MX_PWM_UREF			9
			#define MX_PWM_CHANNEL_9		1
			#define MX_PWM_HWALT_9			0
        #else
         #ifndef	MX_PWM_REF10
			#define MX_PWM_REF10
			#define PWM_5_MX_PWM_UREF			10
			#define MX_PWM_CHANNEL_10		1
			#define MX_PWM_HWALT_10			0
         #endif
        #endif
       #endif
      #endif
     #endif
    #endif
   #endif
  #endif
 #endif
#endif

#define PWM_5_PWM_Enable_Channel		CAL_APPEND(FC_CAL_PWM_Enable_Channel_, PWM_5_MX_PWM_UREF)
#define PWM_5_PWM_Disable_Channel		CAL_APPEND(FC_CAL_PWM_Disable_Channel_, PWM_5_MX_PWM_UREF)
#define PWM_5_PWM_Set_Duty_8Bit		CAL_APPEND(FC_CAL_PWM_Set_Duty_8Bit_, PWM_5_MX_PWM_UREF)
#define PWM_5_PWM_Change_Period		CAL_APPEND(FC_CAL_PWM_Change_Period_, PWM_5_MX_PWM_UREF)
#define PWM_5_PWM_Set_Duty_10Bit		CAL_APPEND(FC_CAL_PWM_Set_Duty_10Bit_, PWM_5_MX_PWM_UREF)

extern void PWM_5_PWM_Enable_Channel ();
extern void PWM_5_PWM_Disable_Channel ();
extern void PWM_5_PWM_Set_Duty_8Bit (MX_UINT8 duty);
extern void PWM_5_PWM_Change_Period (MX_UINT8 period, MX_UINT16 prescaler);
extern void PWM_5_PWM_Set_Duty_10Bit (MX_UINT16 duty);




//PWM(0): //Macro function declarations

void FCD_PWM0_Enable();
void FCD_PWM0_Disable();
void FCD_PWM0_SetDutyCycle(MX_UINT8 nDuty);
void FCD_PWM0_ChangePeriod(MX_UINT8 nPeriodVal, MX_UINT8 nPrescalerVal);
void FCD_PWM0_SetDutyCycle10bit(MX_SINT16 nDuty);



//LCDDisplay(0): //Macro implementations


void FCD_LCDDisplay0_RawSend(MX_UINT8 in, MX_UINT8 mask)

{
	
		MX_UINT8 pt;

		FC_CAL_Bit_Low(LCD_1__PORT0, LCD_1__BIT0);
0113  1286  	BCF gbl_portb,5

		FC_CAL_Bit_Low(LCD_1__PORT1, LCD_1__BIT1);
0114  1206  	BCF gbl_portb,4

		FC_CAL_Bit_Low(LCD_1__PORT2, LCD_1__BIT2);
0115  1186  	BCF gbl_portb,3

		FC_CAL_Bit_Low(LCD_1__PORT3, LCD_1__BIT3);
0116  1106  	BCF gbl_portb,2

		FC_CAL_Bit_Low(LCD_1__PORT4, LCD_1__RS);
0117  1386  	BCF gbl_portb,7

		FC_CAL_Bit_Low(LCD_1__PORT5, LCD_1__E);
0118  1306  	BCF gbl_portb,6

		pt = ((in >> 4) & 0x0f);
0119  0E5C  	SWAPF FCD_LCDDis_00059_arg_in, W
011A  390F  	ANDLW 0x0F
011B  00DE  	MOVWF FCD_LCDDis_00059_1_pt
011C  300F  	MOVLW 0x0F
011D  05DE  	ANDWF FCD_LCDDis_00059_1_pt, F

		if (pt & 0x01)
011E  185E  	BTFSC FCD_LCDDis_00059_1_pt,0

		    FC_CAL_Bit_High(LCD_1__PORT0, LCD_1__BIT0);
011F  1686  	BSF gbl_portb,5

		if (pt & 0x02)
0120  18DE  	BTFSC FCD_LCDDis_00059_1_pt,1

		    FC_CAL_Bit_High(LCD_1__PORT1, LCD_1__BIT1);
0121  1606  	BSF gbl_portb,4

		if (pt & 0x04)
0122  195E  	BTFSC FCD_LCDDis_00059_1_pt,2

		    FC_CAL_Bit_High(LCD_1__PORT2, LCD_1__BIT2);
0123  1586  	BSF gbl_portb,3

		if (pt & 0x08)
0124  19DE  	BTFSC FCD_LCDDis_00059_1_pt,3

		    FC_CAL_Bit_High(LCD_1__PORT3, LCD_1__BIT3);
0125  1506  	BSF gbl_portb,2

		if (mask)
0126  08DD  	MOVF FCD_LCDDis_00059_arg_mask, F
0127  1D03  	BTFSS STATUS,Z

		    FC_CAL_Bit_High(LCD_1__PORT4, LCD_1__RS);
0128  1786  	BSF gbl_portb,7

		LCD_1__DELAY;
0129  300A  	MOVLW 0x0A
012A  00DF  	MOVWF delay_10us_00000_arg_del
012B  2041  	CALL delay_10us_00000

		FC_CAL_Bit_High (LCD_1__PORT5, LCD_1__E);
012C  1706  	BSF gbl_portb,6

		LCD_1__DELAY;
012D  300A  	MOVLW 0x0A
012E  00DF  	MOVWF delay_10us_00000_arg_del
012F  2041  	CALL delay_10us_00000

		FC_CAL_Bit_Low (LCD_1__PORT5, LCD_1__E);
0130  1306  	BCF gbl_portb,6

		pt = (in & 0x0f);
0131  300F  	MOVLW 0x0F
0132  055C  	ANDWF FCD_LCDDis_00059_arg_in, W
0133  00DE  	MOVWF FCD_LCDDis_00059_1_pt

		LCD_1__DELAY;
0134  300A  	MOVLW 0x0A
0135  00DF  	MOVWF delay_10us_00000_arg_del
0136  2041  	CALL delay_10us_00000

		FC_CAL_Bit_Low(LCD_1__PORT0, LCD_1__BIT0);
0137  1286  	BCF gbl_portb,5

		FC_CAL_Bit_Low(LCD_1__PORT1, LCD_1__BIT1);
0138  1206  	BCF gbl_portb,4

		FC_CAL_Bit_Low(LCD_1__PORT2, LCD_1__BIT2);
0139  1186  	BCF gbl_portb,3

		FC_CAL_Bit_Low(LCD_1__PORT3, LCD_1__BIT3);
013A  1106  	BCF gbl_portb,2

		FC_CAL_Bit_Low(LCD_1__PORT4, LCD_1__RS);
013B  1386  	BCF gbl_portb,7

		FC_CAL_Bit_Low(LCD_1__PORT5, LCD_1__E);
013C  1306  	BCF gbl_portb,6

		if (pt & 0x01)
013D  185E  	BTFSC FCD_LCDDis_00059_1_pt,0

		    FC_CAL_Bit_High(LCD_1__PORT0, LCD_1__BIT0);
013E  1686  	BSF gbl_portb,5

		if (pt & 0x02)
013F  18DE  	BTFSC FCD_LCDDis_00059_1_pt,1

		    FC_CAL_Bit_High(LCD_1__PORT1, LCD_1__BIT1);
0140  1606  	BSF gbl_portb,4

		if (pt & 0x04)
0141  195E  	BTFSC FCD_LCDDis_00059_1_pt,2

		    FC_CAL_Bit_High(LCD_1__PORT2, LCD_1__BIT2);
0142  1586  	BSF gbl_portb,3

		if (pt & 0x08)
0143  19DE  	BTFSC FCD_LCDDis_00059_1_pt,3

		    FC_CAL_Bit_High(LCD_1__PORT3, LCD_1__BIT3);
0144  1506  	BSF gbl_portb,2

		if (mask)
0145  08DD  	MOVF FCD_LCDDis_00059_arg_mask, F
0146  1D03  	BTFSS STATUS,Z

		    FC_CAL_Bit_High(LCD_1__PORT4, LCD_1__RS);
0147  1786  	BSF gbl_portb,7

		LCD_1__DELAY;
0148  300A  	MOVLW 0x0A
0149  00DF  	MOVWF delay_10us_00000_arg_del
014A  2041  	CALL delay_10us_00000

		FC_CAL_Bit_High (LCD_1__PORT5, LCD_1__E);
014B  1706  	BSF gbl_portb,6

		LCD_1__DELAY;
014C  300A  	MOVLW 0x0A
014D  00DF  	MOVWF delay_10us_00000_arg_del
014E  2041  	CALL delay_10us_00000

		FC_CAL_Bit_Low (LCD_1__PORT5, LCD_1__E);
014F  1306  	BCF gbl_portb,6

		LCD_1__DELAY;
0150  300A  	MOVLW 0x0A
0151  00DF  	MOVWF delay_10us_00000_arg_del
0152  2041  	CALL delay_10us_00000


}
0153  0008  	RETURN


void FCD_LCDDisplay0_Start()

{
	
		FC_CAL_Bit_Low_DDR(LCD_1__PORT0, LCD_1__TRIS0, LCD_1__BIT0);
0779  1683  	BSF STATUS, RP0
077A  1303  	BCF STATUS, RP1
077B  1286  	BCF gbl_trisb,5
077C  1283  	BCF STATUS, RP0
077D  1286  	BCF gbl_portb,5

		FC_CAL_Bit_Low_DDR(LCD_1__PORT1, LCD_1__TRIS1, LCD_1__BIT1);
077E  1683  	BSF STATUS, RP0
077F  1206  	BCF gbl_trisb,4
0780  1283  	BCF STATUS, RP0
0781  1206  	BCF gbl_portb,4

		FC_CAL_Bit_Low_DDR(LCD_1__PORT2, LCD_1__TRIS2, LCD_1__BIT2);
0782  1683  	BSF STATUS, RP0
0783  1186  	BCF gbl_trisb,3
0784  1283  	BCF STATUS, RP0
0785  1186  	BCF gbl_portb,3

		FC_CAL_Bit_Low_DDR(LCD_1__PORT3, LCD_1__TRIS3, LCD_1__BIT3);
0786  1683  	BSF STATUS, RP0
0787  1106  	BCF gbl_trisb,2
0788  1283  	BCF STATUS, RP0
0789  1106  	BCF gbl_portb,2

		FC_CAL_Bit_Low_DDR(LCD_1__PORT4, LCD_1__TRIS4, LCD_1__RS);
078A  1683  	BSF STATUS, RP0
078B  1386  	BCF gbl_trisb,7
078C  1283  	BCF STATUS, RP0
078D  1386  	BCF gbl_portb,7

		FC_CAL_Bit_Low_DDR(LCD_1__PORT5, LCD_1__TRIS5, LCD_1__E);
078E  1683  	BSF STATUS, RP0
078F  1306  	BCF gbl_trisb,6
0790  1283  	BCF STATUS, RP0
0791  1306  	BCF gbl_portb,6


		Wdt_Delay_Ms(12);
0792  300C  	MOVLW 0x0C
0793  00CE  	MOVWF Wdt_Delay__0003E_arg_delay
0794  2076  	CALL Wdt_Delay__0003E


		FCD_LCDDisplay0_RawSend(0x33, 0);
0795  3033  	MOVLW 0x33
0796  00DC  	MOVWF FCD_LCDDis_00059_arg_in
0797  01DD  	CLRF FCD_LCDDis_00059_arg_mask
0798  2113  	CALL FCD_LCDDis_00059

		Wdt_Delay_Ms(2);
0799  3002  	MOVLW 0x02
079A  00CE  	MOVWF Wdt_Delay__0003E_arg_delay
079B  2076  	CALL Wdt_Delay__0003E

		FCD_LCDDisplay0_RawSend(0x33, 0);
079C  3033  	MOVLW 0x33
079D  00DC  	MOVWF FCD_LCDDis_00059_arg_in
079E  01DD  	CLRF FCD_LCDDis_00059_arg_mask
079F  2113  	CALL FCD_LCDDis_00059

		Wdt_Delay_Ms(2);
07A0  3002  	MOVLW 0x02
07A1  00CE  	MOVWF Wdt_Delay__0003E_arg_delay
07A2  2076  	CALL Wdt_Delay__0003E

		FCD_LCDDisplay0_RawSend(0x32, 0);
07A3  3032  	MOVLW 0x32
07A4  00DC  	MOVWF FCD_LCDDis_00059_arg_in
07A5  01DD  	CLRF FCD_LCDDis_00059_arg_mask
07A6  2113  	CALL FCD_LCDDis_00059

		Wdt_Delay_Ms(2);
07A7  3002  	MOVLW 0x02
07A8  00CE  	MOVWF Wdt_Delay__0003E_arg_delay
07A9  2076  	CALL Wdt_Delay__0003E

		FCD_LCDDisplay0_RawSend(0x2c, 0);
07AA  302C  	MOVLW 0x2C
07AB  00DC  	MOVWF FCD_LCDDis_00059_arg_in
07AC  01DD  	CLRF FCD_LCDDis_00059_arg_mask
07AD  2113  	CALL FCD_LCDDis_00059

		Wdt_Delay_Ms(2);
07AE  3002  	MOVLW 0x02
07AF  00CE  	MOVWF Wdt_Delay__0003E_arg_delay
07B0  2076  	CALL Wdt_Delay__0003E

		FCD_LCDDisplay0_RawSend(0x06, 0);
07B1  3006  	MOVLW 0x06
07B2  00DC  	MOVWF FCD_LCDDis_00059_arg_in
07B3  01DD  	CLRF FCD_LCDDis_00059_arg_mask
07B4  2113  	CALL FCD_LCDDis_00059

		Wdt_Delay_Ms(2);
07B5  3002  	MOVLW 0x02
07B6  00CE  	MOVWF Wdt_Delay__0003E_arg_delay
07B7  2076  	CALL Wdt_Delay__0003E

		FCD_LCDDisplay0_RawSend(0x0c, 0);
07B8  300C  	MOVLW 0x0C
07B9  00DC  	MOVWF FCD_LCDDis_00059_arg_in
07BA  01DD  	CLRF FCD_LCDDis_00059_arg_mask
07BB  2113  	CALL FCD_LCDDis_00059

		Wdt_Delay_Ms(2);
07BC  3002  	MOVLW 0x02
07BD  00CE  	MOVWF Wdt_Delay__0003E_arg_delay
07BE  2076  	CALL Wdt_Delay__0003E


		//clear the display
		FCD_LCDDisplay0_RawSend(0x01, 0);
07BF  3001  	MOVLW 0x01
07C0  00DC  	MOVWF FCD_LCDDis_00059_arg_in
07C1  01DD  	CLRF FCD_LCDDis_00059_arg_mask
07C2  2113  	CALL FCD_LCDDis_00059

		Wdt_Delay_Ms(2);
07C3  3002  	MOVLW 0x02
07C4  00CE  	MOVWF Wdt_Delay__0003E_arg_delay
07C5  2076  	CALL Wdt_Delay__0003E

		FCD_LCDDisplay0_RawSend(0x02, 0);
07C6  3002  	MOVLW 0x02
07C7  00DC  	MOVWF FCD_LCDDis_00059_arg_in
07C8  01DD  	CLRF FCD_LCDDis_00059_arg_mask
07C9  2113  	CALL FCD_LCDDis_00059

		Wdt_Delay_Ms(2);
07CA  3002  	MOVLW 0x02
07CB  00CE  	MOVWF Wdt_Delay__0003E_arg_delay
07CC  2076  	CALL Wdt_Delay__0003E


}
07CD  0008  	RETURN


void FCD_LCDDisplay0_Clear()

{
	
		FCD_LCDDisplay0_RawSend(0x01, 0);
0768  3001  	MOVLW 0x01
0769  1283  	BCF STATUS, RP0
076A  1303  	BCF STATUS, RP1
076B  00DC  	MOVWF FCD_LCDDis_00059_arg_in
076C  01DD  	CLRF FCD_LCDDis_00059_arg_mask
076D  2113  	CALL FCD_LCDDis_00059

		Wdt_Delay_Ms(2);
076E  3002  	MOVLW 0x02
076F  00CE  	MOVWF Wdt_Delay__0003E_arg_delay
0770  2076  	CALL Wdt_Delay__0003E

		FCD_LCDDisplay0_RawSend(0x02, 0);
0771  3002  	MOVLW 0x02
0772  00DC  	MOVWF FCD_LCDDis_00059_arg_in
0773  01DD  	CLRF FCD_LCDDis_00059_arg_mask
0774  2113  	CALL FCD_LCDDis_00059

		Wdt_Delay_Ms(2);
0775  3002  	MOVLW 0x02
0776  00CE  	MOVWF Wdt_Delay__0003E_arg_delay
0777  2076  	CALL Wdt_Delay__0003E


}
0778  0008  	RETURN


void FCD_LCDDisplay0_PrintASCII(MX_UINT8 Character)
{
	
		FCD_LCDDisplay0_RawSend(Character, 0x10);

}

void FCD_LCDDisplay0_Command(MX_UINT8 in)
{
	
		FCD_LCDDisplay0_RawSend(in, 0);
		Wdt_Delay_Ms(2);

}

void FCD_LCDDisplay0_Cursor(MX_UINT8 x, MX_UINT8 y)

{
	
	  #if (LCD_1__ROWCNT == 1)
	    y=0x80;
	  #endif

	  #if (LCD_1__ROWCNT == 2)
		if (y==0)
0757  08CD  	MOVF FCD_LCDDis_0005E_arg_y, F
0758  1D03  	BTFSS STATUS,Z
0759  2F5D  	GOTO	label81
075D        label81

			y=0x80;
075A  3080  	MOVLW 0x80
075B  00CD  	MOVWF FCD_LCDDis_0005E_arg_y

		else
075C  2F5F  	GOTO	label82
075F        label82

			y=0xc0;
075D  30C0  	MOVLW 0xC0
075E  00CD  	MOVWF FCD_LCDDis_0005E_arg_y

	  #endif

	  #if (LCD_1__ROWCNT == 4)
		if (y==0)
			y=0x80;
		else if (y==1)
			y=0xc0;

		#if (LCD_1__COLCNT == 16)
			else if (y==2)
				y=0x90;
			else
				y=0xd0;
		#endif

		#if (LCD_1__COLCNT == 20)
			else if (y==2)
				y=0x94;
			else
				y=0xd4;
		#endif
	  #endif

		FCD_LCDDisplay0_RawSend(y+x, 0);
075F  084C  	MOVF FCD_LCDDis_0005E_arg_x, W
0760  074D  	ADDWF FCD_LCDDis_0005E_arg_y, W
0761  00DC  	MOVWF FCD_LCDDis_00059_arg_in
0762  01DD  	CLRF FCD_LCDDis_00059_arg_mask
0763  2113  	CALL FCD_LCDDis_00059

		Wdt_Delay_Ms(2);
0764  3002  	MOVLW 0x02
0765  00CE  	MOVWF Wdt_Delay__0003E_arg_delay
0766  2076  	CALL Wdt_Delay__0003E


}
0767  0008  	RETURN


void FCD_LCDDisplay0_PrintNumber(MX_SINT16 Number)

{
	
		MX_SINT16 tmp_int;
		MX_UINT8 tmp_byte;

		if (Number < 0)
0669  1FCD  	BTFSS FCD_LCDDis_0005F_arg_Number+D'1',7
066A  2E78  	GOTO	label60
0678        label60

		{
			FCD_LCDDisplay0_RawSend('-', 0x10);
066B  302D  	MOVLW 0x2D
066C  00DC  	MOVWF FCD_LCDDis_00059_arg_in
066D  3010  	MOVLW 0x10
066E  00DD  	MOVWF FCD_LCDDis_00059_arg_mask
066F  2113  	CALL FCD_LCDDis_00059

			Number = 0 - Number;
0670  084C  	MOVF FCD_LCDDis_0005F_arg_Number, W
0671  3C00  	SUBLW 0x00
0672  00D1  	MOVWF CompTempVar2403
0673  09CD  	COMF FCD_LCDDis_0005F_arg_Number+D'1', F
0674  1803  	BTFSC STATUS,C
0675  0ACD  	INCF FCD_LCDDis_0005F_arg_Number+D'1', F
0676  0851  	MOVF CompTempVar2403, W
0677  00CC  	MOVWF FCD_LCDDis_0005F_arg_Number

		}

		tmp_int = Number;
0678  084C  	MOVF FCD_LCDDis_0005F_arg_Number, W
0679  00CE  	MOVWF FCD_LCDDis_0005F_1_tmp_int
067A  084D  	MOVF FCD_LCDDis_0005F_arg_Number+D'1', W
067B  00CF  	MOVWF FCD_LCDDis_0005F_1_tmp_int+D'1'

		if (Number >= 10000)
067C  3027  	MOVLW 0x27
067D  024D  	SUBWF FCD_LCDDis_0005F_arg_Number+D'1', W
067E  1D03  	BTFSS STATUS,Z
067F  2E82  	GOTO	label61
0680  3010  	MOVLW 0x10
0681  024C  	SUBWF FCD_LCDDis_0005F_arg_Number, W
0682        label61
0682  1C03  	BTFSS STATUS,C
0683  2EB0  	GOTO	label65
0684  1BCD  	BTFSC FCD_LCDDis_0005F_arg_Number+D'1',7
0685  2EB0  	GOTO	label65

		{
			tmp_byte = tmp_int / 10000;
0686  01D5  	CLRF CompTempVar2406
0687  084E  	MOVF FCD_LCDDis_0005F_1_tmp_int, W
0688  00D1  	MOVWF __div_16_1_00003_arg_a
0689  084F  	MOVF FCD_LCDDis_0005F_1_tmp_int+D'1', W
068A  00D2  	MOVWF __div_16_1_00003_arg_a+D'1'
068B  1FCF  	BTFSS FCD_LCDDis_0005F_1_tmp_int+D'1',7
068C  2E93  	GOTO	label62
068D  09D1  	COMF __div_16_1_00003_arg_a, F
068E  09D2  	COMF __div_16_1_00003_arg_a+D'1', F
068F  0AD1  	INCF __div_16_1_00003_arg_a, F
0690  1903  	BTFSC STATUS,Z
0691  0AD2  	INCF __div_16_1_00003_arg_a+D'1', F
0692  0AD5  	INCF CompTempVar2406, F
0693        label62
0693  3010  	MOVLW 0x10
0694  00D3  	MOVWF __div_16_1_00003_arg_b
0695  3027  	MOVLW 0x27
0696  00D4  	MOVWF __div_16_1_00003_arg_b+D'1'
0697  2057  	CALL __div_16_1_00003
0698  085A  	MOVF CompTempVarRet214, W
0699  00D0  	MOVWF FCD_LCDDis_0005F_1_tmp_byte
069A  1C55  	BTFSS CompTempVar2406,0
069B  2E9E  	GOTO	label63
069C  09D0  	COMF FCD_LCDDis_0005F_1_tmp_byte, F
069D  0AD0  	INCF FCD_LCDDis_0005F_1_tmp_byte, F
069E        label63

			FCD_LCDDisplay0_RawSend('0' + tmp_byte, 0x10);
069E  0850  	MOVF FCD_LCDDis_0005F_1_tmp_byte, W
069F  3E30  	ADDLW 0x30
06A0  00DC  	MOVWF FCD_LCDDis_00059_arg_in
06A1  3010  	MOVLW 0x10
06A2  00DD  	MOVWF FCD_LCDDis_00059_arg_mask
06A3  2113  	CALL FCD_LCDDis_00059


			while (tmp_byte > 0)
06A4        label64
06A4  0850  	MOVF FCD_LCDDis_0005F_1_tmp_byte, W
06A5  3C00  	SUBLW 0x00
06A6  1803  	BTFSC STATUS,C
06A7  2EB0  	GOTO	label65
06AF  2EA4  	GOTO	label64
06B0        label65

			{
				tmp_int = tmp_int - 10000;
06A8  3010  	MOVLW 0x10
06A9  02CE  	SUBWF FCD_LCDDis_0005F_1_tmp_int, F
06AA  3027  	MOVLW 0x27
06AB  1C03  	BTFSS STATUS,C
06AC  3028  	MOVLW 0x28
06AD  02CF  	SUBWF FCD_LCDDis_0005F_1_tmp_int+D'1', F

				tmp_byte--;
06AE  03D0  	DECF FCD_LCDDis_0005F_1_tmp_byte, F

			}
		}
		if (Number >= 1000)
06B0  3003  	MOVLW 0x03
06B1  024D  	SUBWF FCD_LCDDis_0005F_arg_Number+D'1', W
06B2  1D03  	BTFSS STATUS,Z
06B3  2EB6  	GOTO	label66
06B4  30E8  	MOVLW 0xE8
06B5  024C  	SUBWF FCD_LCDDis_0005F_arg_Number, W
06B6        label66
06B6  1C03  	BTFSS STATUS,C
06B7  2EE6  	GOTO	label70
06B8  1BCD  	BTFSC FCD_LCDDis_0005F_arg_Number+D'1',7
06B9  2EE6  	GOTO	label70

		{
			tmp_byte = tmp_int / 1000;
06BA  01D6  	CLRF CompTempVar2410
06BB  084E  	MOVF FCD_LCDDis_0005F_1_tmp_int, W
06BC  00D1  	MOVWF __div_16_1_00003_arg_a
06BD  084F  	MOVF FCD_LCDDis_0005F_1_tmp_int+D'1', W
06BE  00D2  	MOVWF __div_16_1_00003_arg_a+D'1'
06BF  1FCF  	BTFSS FCD_LCDDis_0005F_1_tmp_int+D'1',7
06C0  2EC7  	GOTO	label67
06C1  09D1  	COMF __div_16_1_00003_arg_a, F
06C2  09D2  	COMF __div_16_1_00003_arg_a+D'1', F
06C3  0AD1  	INCF __div_16_1_00003_arg_a, F
06C4  1903  	BTFSC STATUS,Z
06C5  0AD2  	INCF __div_16_1_00003_arg_a+D'1', F
06C6  0AD6  	INCF CompTempVar2410, F
06C7        label67
06C7  30E8  	MOVLW 0xE8
06C8  00D3  	MOVWF __div_16_1_00003_arg_b
06C9  3003  	MOVLW 0x03
06CA  00D4  	MOVWF __div_16_1_00003_arg_b+D'1'
06CB  2057  	CALL __div_16_1_00003
06CC  085A  	MOVF CompTempVarRet214, W
06CD  00D5  	MOVWF CompTempVar2409
06CE  1C56  	BTFSS CompTempVar2410,0
06CF  2ED2  	GOTO	label68
06D0  09D5  	COMF CompTempVar2409, F
06D1  0AD5  	INCF CompTempVar2409, F
06D2        label68
06D2  0855  	MOVF CompTempVar2409, W
06D3  00D0  	MOVWF FCD_LCDDis_0005F_1_tmp_byte

			FCD_LCDDisplay0_RawSend('0' + tmp_byte, 0x10);
06D4  0850  	MOVF FCD_LCDDis_0005F_1_tmp_byte, W
06D5  3E30  	ADDLW 0x30
06D6  00DC  	MOVWF FCD_LCDDis_00059_arg_in
06D7  3010  	MOVLW 0x10
06D8  00DD  	MOVWF FCD_LCDDis_00059_arg_mask
06D9  2113  	CALL FCD_LCDDis_00059


			while (tmp_byte > 0)
06DA        label69
06DA  0850  	MOVF FCD_LCDDis_0005F_1_tmp_byte, W
06DB  3C00  	SUBLW 0x00
06DC  1803  	BTFSC STATUS,C
06DD  2EE6  	GOTO	label70
06E5  2EDA  	GOTO	label69
06E6        label70

			{
				tmp_int = tmp_int - 1000;
06DE  30E8  	MOVLW 0xE8
06DF  02CE  	SUBWF FCD_LCDDis_0005F_1_tmp_int, F
06E0  3003  	MOVLW 0x03
06E1  1C03  	BTFSS STATUS,C
06E2  3004  	MOVLW 0x04
06E3  02CF  	SUBWF FCD_LCDDis_0005F_1_tmp_int+D'1', F

				tmp_byte--;
06E4  03D0  	DECF FCD_LCDDis_0005F_1_tmp_byte, F

			}
		}
		if (Number >= 100)
06E6  084D  	MOVF FCD_LCDDis_0005F_arg_Number+D'1', W
06E7  3A80  	XORLW 0x80
06E8  00D1  	MOVWF CompTempVar2413
06E9  3080  	MOVLW 0x80
06EA  0251  	SUBWF CompTempVar2413, W
06EB  1D03  	BTFSS STATUS,Z
06EC  2EEF  	GOTO	label71
06ED  3064  	MOVLW 0x64
06EE  024C  	SUBWF FCD_LCDDis_0005F_arg_Number, W
06EF        label71
06EF  1C03  	BTFSS STATUS,C
06F0  2F1B  	GOTO	label75

		{
			tmp_byte = tmp_int / 100;
06F1  01D6  	CLRF CompTempVar2415
06F2  084E  	MOVF FCD_LCDDis_0005F_1_tmp_int, W
06F3  00D1  	MOVWF __div_16_1_00003_arg_a
06F4  084F  	MOVF FCD_LCDDis_0005F_1_tmp_int+D'1', W
06F5  00D2  	MOVWF __div_16_1_00003_arg_a+D'1'
06F6  1FCF  	BTFSS FCD_LCDDis_0005F_1_tmp_int+D'1',7
06F7  2EFE  	GOTO	label72
06F8  09D1  	COMF __div_16_1_00003_arg_a, F
06F9  09D2  	COMF __div_16_1_00003_arg_a+D'1', F
06FA  0AD1  	INCF __div_16_1_00003_arg_a, F
06FB  1903  	BTFSC STATUS,Z
06FC  0AD2  	INCF __div_16_1_00003_arg_a+D'1', F
06FD  0AD6  	INCF CompTempVar2415, F
06FE        label72
06FE  3064  	MOVLW 0x64
06FF  00D3  	MOVWF __div_16_1_00003_arg_b
0700  01D4  	CLRF __div_16_1_00003_arg_b+D'1'
0701  2057  	CALL __div_16_1_00003
0702  085A  	MOVF CompTempVarRet214, W
0703  00D5  	MOVWF CompTempVar2414
0704  1C56  	BTFSS CompTempVar2415,0
0705  2F08  	GOTO	label73
0706  09D5  	COMF CompTempVar2414, F
0707  0AD5  	INCF CompTempVar2414, F
0708        label73
0708  0855  	MOVF CompTempVar2414, W
0709  00D0  	MOVWF FCD_LCDDis_0005F_1_tmp_byte

			FCD_LCDDisplay0_RawSend('0' + tmp_byte, 0x10);
070A  0850  	MOVF FCD_LCDDis_0005F_1_tmp_byte, W
070B  3E30  	ADDLW 0x30
070C  00DC  	MOVWF FCD_LCDDis_00059_arg_in
070D  3010  	MOVLW 0x10
070E  00DD  	MOVWF FCD_LCDDis_00059_arg_mask
070F  2113  	CALL FCD_LCDDis_00059


			while (tmp_byte > 0)
0710        label74
0710  0850  	MOVF FCD_LCDDis_0005F_1_tmp_byte, W
0711  3C00  	SUBLW 0x00
0712  1803  	BTFSC STATUS,C
0713  2F1B  	GOTO	label75
071A  2F10  	GOTO	label74
071B        label75

			{
				tmp_int = tmp_int - 100;
0714  3064  	MOVLW 0x64
0715  02CE  	SUBWF FCD_LCDDis_0005F_1_tmp_int, F
0716  08CF  	MOVF FCD_LCDDis_0005F_1_tmp_int+D'1', F
0717  1C03  	BTFSS STATUS,C
0718  03CF  	DECF FCD_LCDDis_0005F_1_tmp_int+D'1', F

				tmp_byte--;
0719  03D0  	DECF FCD_LCDDis_0005F_1_tmp_byte, F

			}
		}
		if (Number >= 10)
071B  084D  	MOVF FCD_LCDDis_0005F_arg_Number+D'1', W
071C  3A80  	XORLW 0x80
071D  00D1  	MOVWF CompTempVar2418
071E  3080  	MOVLW 0x80
071F  0251  	SUBWF CompTempVar2418, W
0720  1D03  	BTFSS STATUS,Z
0721  2F24  	GOTO	label76
0722  300A  	MOVLW 0x0A
0723  024C  	SUBWF FCD_LCDDis_0005F_arg_Number, W
0724        label76
0724  1C03  	BTFSS STATUS,C
0725  2F50  	GOTO	label80

		{
			tmp_byte = tmp_int / 10;
0726  01D6  	CLRF CompTempVar2420
0727  084E  	MOVF FCD_LCDDis_0005F_1_tmp_int, W
0728  00D1  	MOVWF __div_16_1_00003_arg_a
0729  084F  	MOVF FCD_LCDDis_0005F_1_tmp_int+D'1', W
072A  00D2  	MOVWF __div_16_1_00003_arg_a+D'1'
072B  1FCF  	BTFSS FCD_LCDDis_0005F_1_tmp_int+D'1',7
072C  2F33  	GOTO	label77
072D  09D1  	COMF __div_16_1_00003_arg_a, F
072E  09D2  	COMF __div_16_1_00003_arg_a+D'1', F
072F  0AD1  	INCF __div_16_1_00003_arg_a, F
0730  1903  	BTFSC STATUS,Z
0731  0AD2  	INCF __div_16_1_00003_arg_a+D'1', F
0732  0AD6  	INCF CompTempVar2420, F
0733        label77
0733  300A  	MOVLW 0x0A
0734  00D3  	MOVWF __div_16_1_00003_arg_b
0735  01D4  	CLRF __div_16_1_00003_arg_b+D'1'
0736  2057  	CALL __div_16_1_00003
0737  085A  	MOVF CompTempVarRet214, W
0738  00D5  	MOVWF CompTempVar2419
0739  1C56  	BTFSS CompTempVar2420,0
073A  2F3D  	GOTO	label78
073B  09D5  	COMF CompTempVar2419, F
073C  0AD5  	INCF CompTempVar2419, F
073D        label78
073D  0855  	MOVF CompTempVar2419, W
073E  00D0  	MOVWF FCD_LCDDis_0005F_1_tmp_byte

			FCD_LCDDisplay0_RawSend('0' + tmp_byte, 0x10);
073F  0850  	MOVF FCD_LCDDis_0005F_1_tmp_byte, W
0740  3E30  	ADDLW 0x30
0741  00DC  	MOVWF FCD_LCDDis_00059_arg_in
0742  3010  	MOVLW 0x10
0743  00DD  	MOVWF FCD_LCDDis_00059_arg_mask
0744  2113  	CALL FCD_LCDDis_00059


			while (tmp_byte > 0)
0745        label79
0745  0850  	MOVF FCD_LCDDis_0005F_1_tmp_byte, W
0746  3C00  	SUBLW 0x00
0747  1803  	BTFSC STATUS,C
0748  2F50  	GOTO	label80
074F  2F45  	GOTO	label79
0750        label80

			{
				tmp_int = tmp_int - 10;
0749  300A  	MOVLW 0x0A
074A  02CE  	SUBWF FCD_LCDDis_0005F_1_tmp_int, F
074B  08CF  	MOVF FCD_LCDDis_0005F_1_tmp_int+D'1', F
074C  1C03  	BTFSS STATUS,C
074D  03CF  	DECF FCD_LCDDis_0005F_1_tmp_int+D'1', F

				tmp_byte--;
074E  03D0  	DECF FCD_LCDDis_0005F_1_tmp_byte, F

			}
		}
		FCD_LCDDisplay0_RawSend('0' + tmp_int, 0x10);
0750  084E  	MOVF FCD_LCDDis_0005F_1_tmp_int, W
0751  3E30  	ADDLW 0x30
0752  00DC  	MOVWF FCD_LCDDis_00059_arg_in
0753  3010  	MOVLW 0x10
0754  00DD  	MOVWF FCD_LCDDis_00059_arg_mask
0755  2113  	CALL FCD_LCDDis_00059


}
0756  0008  	RETURN


void FCD_LCDDisplay0_PrintString(MX_STRING String, MX_UINT8 MSZ_String)

{
	
		MX_UINT8 idx = 0;
064D  01DB  	CLRF FCD_LCDDis_00060_1_idx


		for (idx=0; idx<MSZ_String; idx++)
064E  01DB  	CLRF FCD_LCDDis_00060_1_idx
064F        label59
064F  085A  	MOVF FCD_LCDDis_00060_arg_MSZ_String, W
0650  025B  	SUBWF FCD_LCDDis_00060_1_idx, W
0651  1803  	BTFSC STATUS,C
0667  0ADB  	INCF FCD_LCDDis_00060_1_idx, F
0668  2E4F  	GOTO	label59

		{
			if (String[idx] == 0)
0653  1383  	BCF STATUS,IRP
0654  1849  	BTFSC FCD_LCDDis_00060_arg_String+D'1',0
0655  1783  	BSF STATUS,IRP
0656  0848  	MOVF FCD_LCDDis_00060_arg_String, W
0657  075B  	ADDWF FCD_LCDDis_00060_1_idx, W
0658  0084  	MOVWF FSR
0659  0880  	MOVF INDF, F
065A  1903  	BTFSC STATUS,Z

			{
				break;

			}
			FCD_LCDDisplay0_RawSend(String[idx], 0x10);
065C  1383  	BCF STATUS,IRP
065D  1849  	BTFSC FCD_LCDDis_00060_arg_String+D'1',0
065E  1783  	BSF STATUS,IRP
065F  0848  	MOVF FCD_LCDDis_00060_arg_String, W
0660  075B  	ADDWF FCD_LCDDis_00060_1_idx, W
0661  0084  	MOVWF FSR
0662  0800  	MOVF INDF, W
0663  00DC  	MOVWF FCD_LCDDis_00059_arg_in
0664  3010  	MOVLW 0x10
0665  00DD  	MOVWF FCD_LCDDis_00059_arg_mask
0666  2113  	CALL FCD_LCDDis_00059

		}

}
0652  0008  	RETURN
065B  0008  	RETURN


void FCD_LCDDisplay0_ScrollDisplay(MX_UINT8 Direction, MX_UINT8 Num_Positions)
{
	
		MX_UINT8 cmd = 0;
		MX_UINT8 count;

		//Choose the direction
		switch (Direction)
		{
			case 0:
			case 'l':
			case 'L':

				cmd = 0x18;
				break;

			case 1:
			case 'r':
			case 'R':

				cmd = 0x1C;
				break;

			default:
				break;
		}

		//If direction accepted then scroll the specified amount
		if (cmd)
		{
			for (count = 0; count < Num_Positions; count++)
				FCD_LCDDisplay0_Command(cmd);
		}

}

void FCD_LCDDisplay0_ClearLine(MX_UINT8 Line)
{
	
		MX_UINT8 count;
		MX_UINT8 rowcount;

		//Define number of columns per line
		#if (LCD_1__ROWCNT == 1)
			rowcount=80;
		#endif

		#if (LCD_1__ROWCNT == 2)
			rowcount=40;
		#endif

		#if (LCD_1__ROWCNT == 4)
			#if (LCD_1__COLCNT == 16)
				rowcount=16;
			#endif
			#if (LCD_1__COLCNT == 20)
				rowcount=20;
			#endif
		#endif

		//Start at beginning of the line
		FCD_LCDDisplay0_Cursor (0, Line);

		//Send out spaces to clear line
		for (count = 0; count < rowcount; count++)
			FCD_LCDDisplay0_RawSend(' ', 0x10);

		//Move back to the beginning of the line.
		FCD_LCDDisplay0_Cursor (0, Line);

}

void FCD_LCDDisplay0_RAM_Write(MX_UINT8 nIdx, MX_UINT8 d0, MX_UINT8 d1, MX_UINT8 d2, MX_UINT8 d3, MX_UINT8 d4, MX_UINT8 d5, MX_UINT8 d6, MX_UINT8 d7)
{
	   //set CGRAM address

	   FCD_LCDDisplay0_RawSend(64 + (nIdx << 3), 0);
	   delay_ms(2);

	   //write CGRAM data
	   FCD_LCDDisplay0_RawSend(d0, 0x10);
	   FCD_LCDDisplay0_RawSend(d1, 0x10);
	   FCD_LCDDisplay0_RawSend(d2, 0x10);
	   FCD_LCDDisplay0_RawSend(d3, 0x10);
	   FCD_LCDDisplay0_RawSend(d4, 0x10);
	   FCD_LCDDisplay0_RawSend(d5, 0x10);
	   FCD_LCDDisplay0_RawSend(d6, 0x10);
	   FCD_LCDDisplay0_RawSend(d7, 0x10);

	   //Clear the display
	   FCD_LCDDisplay0_RawSend(0x01, 0);
	   delay_ms(2);
	   FCD_LCDDisplay0_RawSend(0x02, 0);
	   delay_ms(2);

}



//RS232(0): //Macro implementations


void FCD_RS2320_SendRS232Char(MX_SINT16 nChar)
{
	
		RS232_2_UART_Send ( nChar);

}

void FCD_RS2320_SendRS232String(MX_STRING String, MX_UINT8 MSZ_String)

{
	
		MX_UINT8 idx;
		for(idx = 0; idx < MSZ_String; idx++)
00F5  01E3  	CLRF FCD_RS2320_00052_1_idx
00F6        label21
00F6  0862  	MOVF FCD_RS2320_00052_arg_MSZ_String, W
00F7  0263  	SUBWF FCD_RS2320_00052_1_idx, W
00F8  1803  	BTFSC STATUS,C
010D  0AE3  	INCF FCD_RS2320_00052_1_idx, F
010E  28F6  	GOTO	label21

		{
			if (String[idx] == 0)
00FA  1383  	BCF STATUS,IRP
00FB  185D  	BTFSC FCD_RS2320_00052_arg_String+D'1',0
00FC  1783  	BSF STATUS,IRP
00FD  085C  	MOVF FCD_RS2320_00052_arg_String, W
00FE  0763  	ADDWF FCD_RS2320_00052_1_idx, W
00FF  0084  	MOVWF FSR
0100  0880  	MOVF INDF, F
0101  1903  	BTFSC STATUS,Z

				break;
			else RS232_2_UART_Send ( String[idx] );
0103  1383  	BCF STATUS,IRP
0104  185D  	BTFSC FCD_RS2320_00052_arg_String+D'1',0
0105  1783  	BSF STATUS,IRP
0106  085C  	MOVF FCD_RS2320_00052_arg_String, W
0107  0763  	ADDWF FCD_RS2320_00052_1_idx, W
0108  0084  	MOVWF FSR
0109  0800  	MOVF INDF, W
010A  00E4  	MOVWF FC_CAL_UAR_00066_arg_nChar
010B  01E5  	CLRF FC_CAL_UAR_00066_arg_nChar+D'1'
010C  204F  	CALL FC_CAL_UAR_00066

		}

}
00F9  0008  	RETURN
0102  0008  	RETURN


MX_SINT16 FCD_RS2320_ReceiveRS232Char(MX_UINT8 nTimeout)

{
	
		return ( RS232_2_UART_Receive ( nTimeout) );
063B  084C  	MOVF FCD_RS2320_0006B_arg_nTimeout, W
063C  00CD  	MOVWF FC_CAL_UAR_00067_arg_nTimeout
063D  2081  	CALL FC_CAL_UAR_00067
063E  0854  	MOVF CompTempVarRet2431, W
063F  00CD  	MOVWF CompTempVarRet2432
0640  0855  	MOVF CompTempVarRet2431+D'1', W
0641  00CE  	MOVWF CompTempVarRet2432+D'1'


}
0642  0008  	RETURN


void FCD_RS2320_ReceiveRS232String(MX_CHAR* FCR_RETVAL, MX_UINT8 FCR_RETVAL_SIZE, MX_UINT8 nTimeout, MX_UINT8 NumBytes)
{
	
		MX_UINT8 idx;
		MX_SINT16 RS232_TO = 255;
		MX_SINT16 in;

		if ( 0 != 0 )
			RS232_TO = 256;

		if (NumBytes > FCR_RETVAL_SIZE)
			NumBytes = FCR_RETVAL_SIZE;

		for (idx = 0; idx < NumBytes; idx++)
		{
			in = RS232_2_UART_Receive ( nTimeout);
			if(in < RS232_TO)
				FCR_RETVAL[idx] = in & 0xFF;
			else
				break;
		}

		if (idx < FCR_RETVAL_SIZE)
			FCR_RETVAL[idx] = 0;

}

void FCD_RS2320_ChangeHWBaud(MX_UINT8 newbaud)
{
	
		RS232_2_UART_Update_Baud (newbaud);

}



//PWM(0): //Macro implementations


void FCD_PWM0_Enable()

{
	
		PWM_5_PWM_Change_Period (MX_PWM_PERIOD, MX_PWM_PRESCALE1);
0643  309B  	MOVLW 0x9B
0644  1283  	BCF STATUS, RP0
0645  1303  	BCF STATUS, RP1
0646  00C8  	MOVWF FC_CAL_PWM_00072_arg_period
0647  3010  	MOVLW 0x10
0648  00C9  	MOVWF FC_CAL_PWM_00072_arg_prescaler
0649  01CA  	CLRF FC_CAL_PWM_00072_arg_prescaler+D'1'
064A  20CD  	CALL FC_CAL_PWM_00072

		PWM_5_PWM_Enable_Channel ();
064B  20ED  	CALL FC_CAL_PWM_0006F


}
064C  0008  	RETURN


void FCD_PWM0_Disable()
{
	
		PWM_5_PWM_Disable_Channel();

}

void FCD_PWM0_SetDutyCycle(MX_UINT8 nDuty)

{
	
		PWM_5_PWM_Set_Duty_8Bit(nDuty);
010F  0854  	MOVF FCD_PWM0_S_00053_arg_nDuty, W
0110  00D5  	MOVWF FC_CAL_PWM_00071_arg_duty
0111  2054  	CALL FC_CAL_PWM_00071


}
0112  0008  	RETURN


void FCD_PWM0_ChangePeriod(MX_UINT8 nPeriodVal, MX_UINT8 nPrescalerVal)
{
	
		PWM_5_PWM_Change_Period (nPeriodVal, nPrescalerVal);

}

void FCD_PWM0_SetDutyCycle10bit(MX_SINT16 nDuty)
{
	
		PWM_5_PWM_Set_Duty_10Bit(nDuty);

}

#include "C:\Program Files (x86)\Flowcode\v5\CAL\includes.c"

//Macro implementations


void FCM_Equipment1()

{

	//Decision
	//Decision: eq1_se1 = 0 AND eq1_se2 = 0 AND eq1_flag = 0?
	if (FCV_EQ1_SE1 == 0 & FCV_EQ1_SE2 == 0 & FCV_EQ1_FLAG == 0)
05AF  1283  	BCF STATUS, RP0
05B0  1303  	BCF STATUS, RP1
05B1  01CE  	CLRF CompTempVar2191
05B2  1C42  	BTFSS gbl_FCV_EQ1_SE1,0
05B3  0ACE  	INCF CompTempVar2191, F
05B4  01CC  	CLRF CompTempVar2188
05B5  1D42  	BTFSS gbl_FCV_EQ1_SE2,2
05B6  0ACC  	INCF CompTempVar2188, F
05B7  084C  	MOVF CompTempVar2188, W
05B8  05CE  	ANDWF CompTempVar2191, F
05B9  01CD  	CLRF CompTempVar2190
05BA  1E45  	BTFSS gbl_FCV_EQ1_FLAG,4
05BB  0ACD  	INCF CompTempVar2190, F
05BC  084D  	MOVF CompTempVar2190, W
05BD  054E  	ANDWF CompTempVar2191, W
05BE  1903  	BTFSC STATUS,Z
05BF  2DD3  	GOTO	label54
05D3        label54

	{

		//Call Component Macro
		//Call Component Macro: SendRS232String("E1B")
		FCD_RS2320_SendRS232String("E1B", 3);
05C0  3045  	MOVLW 0x45
05C1  00D1  	MOVWF CompTempVar2192
05C2  3031  	MOVLW 0x31
05C3  00D2  	MOVWF CompTempVar2192+D'1'
05C4  3042  	MOVLW 0x42
05C5  00D3  	MOVWF CompTempVar2192+D'2'
05C6  01D4  	CLRF CompTempVar2192+D'3'
05C7  3000  	MOVLW HIGH(CompTempVar2192+D'0')
05C8  00DD  	MOVWF FCD_RS2320_00052_arg_String+D'1'
05C9  3051  	MOVLW LOW(CompTempVar2192+D'0')
05CA  00DC  	MOVWF FCD_RS2320_00052_arg_String
05CB  3003  	MOVLW 0x03
05CC  00E2  	MOVWF FCD_RS2320_00052_arg_MSZ_String
05CD  20F5  	CALL FCD_RS2320_00052


		//Delay
		//Delay: 200 ms
		delay_ms(200);
05CE  30C8  	MOVLW 0xC8
05CF  00D4  	MOVWF delay_ms_00000_arg_del
05D0  2015  	CALL delay_ms_00000


		//Calculation
		//Calculation:
		//  eq1_flag = 1
		FCV_EQ1_FLAG = 1;
05D1  1645  	BSF gbl_FCV_EQ1_FLAG,4


	} else {

		//Decision
		//Decision: eq1_se1 = 1 AND eq1_se2 = 0 AND eq1_flag = 1?
		if (FCV_EQ1_SE1 == 1 & FCV_EQ1_SE2 == 0 & FCV_EQ1_FLAG == 1)
05D3  01D1  	CLRF CompTempVar2197
05D4  1842  	BTFSC gbl_FCV_EQ1_SE1,0
05D5  0AD1  	INCF CompTempVar2197, F
05D6  01CF  	CLRF CompTempVar2194
05D7  1D42  	BTFSS gbl_FCV_EQ1_SE2,2
05D8  0ACF  	INCF CompTempVar2194, F
05D9  084F  	MOVF CompTempVar2194, W
05DA  05D1  	ANDWF CompTempVar2197, F
05DB  01D0  	CLRF CompTempVar2196
05DC  1A45  	BTFSC gbl_FCV_EQ1_FLAG,4
05DD  0AD0  	INCF CompTempVar2196, F
05DE  0850  	MOVF CompTempVar2196, W
05DF  0551  	ANDWF CompTempVar2197, W
05E0  1903  	BTFSC STATUS,Z
05E1  2DF8  	GOTO	label55
05F8        label55

		{

			//Call Component Macro
			//Call Component Macro: SendRS232String("E1P")
			FCD_RS2320_SendRS232String("E1P", 3);
05E2  3045  	MOVLW 0x45
05E3  00D4  	MOVWF CompTempVar2198
05E4  3031  	MOVLW 0x31
05E5  00D5  	MOVWF CompTempVar2198+D'1'
05E6  3050  	MOVLW 0x50
05E7  00D6  	MOVWF CompTempVar2198+D'2'
05E8  01D7  	CLRF CompTempVar2198+D'3'
05E9  3000  	MOVLW HIGH(CompTempVar2198+D'0')
05EA  00DD  	MOVWF FCD_RS2320_00052_arg_String+D'1'
05EB  3054  	MOVLW LOW(CompTempVar2198+D'0')
05EC  00DC  	MOVWF FCD_RS2320_00052_arg_String
05ED  3003  	MOVLW 0x03
05EE  00E2  	MOVWF FCD_RS2320_00052_arg_MSZ_String
05EF  20F5  	CALL FCD_RS2320_00052


			//Delay
			//Delay: 500 ms
			delay_ms(255);
05F0  30FF  	MOVLW 0xFF
05F1  00D4  	MOVWF delay_ms_00000_arg_del
05F2  2015  	CALL delay_ms_00000

			delay_ms(245);
05F3  30F5  	MOVLW 0xF5
05F4  00D4  	MOVWF delay_ms_00000_arg_del
05F5  2015  	CALL delay_ms_00000


			//Calculation
			//Calculation:
			//  eq1_flag = 0
			FCV_EQ1_FLAG = 0;
05F6  1245  	BCF gbl_FCV_EQ1_FLAG,4


		} else {

			//Decision
			//Decision: eq1_se1 = 0 AND eq1_se2 = 1?
			if (FCV_EQ1_SE1 == 0 & FCV_EQ1_SE2 == 1)
05F8  01D3  	CLRF CompTempVar2201
05F9  1C42  	BTFSS gbl_FCV_EQ1_SE1,0
05FA  0AD3  	INCF CompTempVar2201, F
05FB  01D2  	CLRF CompTempVar2200
05FC  1942  	BTFSC gbl_FCV_EQ1_SE2,2
05FD  0AD2  	INCF CompTempVar2200, F
05FE  0852  	MOVF CompTempVar2200, W
05FF  0553  	ANDWF CompTempVar2201, W
0600  1903  	BTFSC STATUS,Z

			{

				//Calculation
				//Calculation:
				//  eq1_errorflag = 0
				FCV_EQ1_ERRORFLAG = 0;
0602  1345  	BCF gbl_FCV_EQ1_ERRORFLAG,6


				//Loop
				//Loop: While eq1_se2 = 1
				while (FCV_EQ1_SE2 == 1)
0603        label56
0603  1D42  	BTFSS gbl_FCV_EQ1_SE2,2
0604  2E39  	GOTO	label58
0638  2E03  	GOTO	label56
0639        label58

				{

					//Input
					//Input: A1 -> eq1_se2
					trisa = trisa | 0x02;
0605  3002  	MOVLW 0x02
0606  1683  	BSF STATUS, RP0
0607  0405  	IORWF gbl_trisa, W
0608  0085  	MOVWF gbl_trisa

					FCV_EQ1_SE2 = ((porta & 0x02) == 0x02);
0609  3002  	MOVLW 0x02
060A  1283  	BCF STATUS, RP0
060B  0505  	ANDWF gbl_porta, W
060C  00D4  	MOVWF CompTempVar2202
060D  01D5  	CLRF CompTempVar2203
060E  3002  	MOVLW 0x02
060F  0254  	SUBWF CompTempVar2202, W
0610  1903  	BTFSC STATUS,Z
0611  0AD5  	INCF CompTempVar2203, F
0612  1142  	BCF gbl_FCV_EQ1_SE2,2
0613  0855  	MOVF CompTempVar2203, W
0614  1D03  	BTFSS STATUS,Z
0615  1542  	BSF gbl_FCV_EQ1_SE2,2


					//Decision
					//Decision: eq1_errorflag = 0?
					if (FCV_EQ1_ERRORFLAG == 0)
0616  1B45  	BTFSC gbl_FCV_EQ1_ERRORFLAG,6
0617  2E2D  	GOTO	label57
062D        label57

					{

						//Call Component Macro
						//Call Component Macro: SendRS232String("E1R")
						FCD_RS2320_SendRS232String("E1R", 3);
0618  3045  	MOVLW 0x45
0619  00D6  	MOVWF CompTempVar2204
061A  3031  	MOVLW 0x31
061B  00D7  	MOVWF CompTempVar2204+D'1'
061C  3052  	MOVLW 0x52
061D  00D8  	MOVWF CompTempVar2204+D'2'
061E  01D9  	CLRF CompTempVar2204+D'3'
061F  3000  	MOVLW HIGH(CompTempVar2204+D'0')
0620  00DD  	MOVWF FCD_RS2320_00052_arg_String+D'1'
0621  3056  	MOVLW LOW(CompTempVar2204+D'0')
0622  00DC  	MOVWF FCD_RS2320_00052_arg_String
0623  3003  	MOVLW 0x03
0624  00E2  	MOVWF FCD_RS2320_00052_arg_MSZ_String
0625  20F5  	CALL FCD_RS2320_00052


						//Delay
						//Delay: 500 ms
						delay_ms(255);
0626  30FF  	MOVLW 0xFF
0627  00D4  	MOVWF delay_ms_00000_arg_del
0628  2015  	CALL delay_ms_00000

						delay_ms(245);
0629  30F5  	MOVLW 0xF5
062A  00D4  	MOVWF delay_ms_00000_arg_del
062B  2015  	CALL delay_ms_00000


						//Calculation
						//Calculation:
						//  eq1_errorflag = 1
						FCV_EQ1_ERRORFLAG = 1;
062C  1745  	BSF gbl_FCV_EQ1_ERRORFLAG,6


					// } else {

					}

					//Call Component Macro
					//Call Component Macro: SetDutyCycle(76)
					FCD_PWM0_SetDutyCycle(76);
062D  304C  	MOVLW 0x4C
062E  00D4  	MOVWF FCD_PWM0_S_00053_arg_nDuty
062F  210F  	CALL FCD_PWM0_S_00053


					//Delay
					//Delay: 100 ms
					delay_ms(100);
0630  3064  	MOVLW 0x64
0631  00D4  	MOVWF delay_ms_00000_arg_del
0632  2015  	CALL delay_ms_00000


					//Call Component Macro
					//Call Component Macro: SetDutyCycle(0)
					FCD_PWM0_SetDutyCycle(0);
0633  01D4  	CLRF FCD_PWM0_S_00053_arg_nDuty
0634  210F  	CALL FCD_PWM0_S_00053


					//Delay
					//Delay: 100 ms
					delay_ms(100);
0635  3064  	MOVLW 0x64
0636  00D4  	MOVWF delay_ms_00000_arg_del
0637  2015  	CALL delay_ms_00000



				}

				//Calculation
				//Calculation:
				//  eq1_flag = 0
				FCV_EQ1_FLAG = 0;
0639  1245  	BCF gbl_FCV_EQ1_FLAG,4


			// } else {

			}

		}

	}

}
05D2  0008  	RETURN
05F7  0008  	RETURN
0601  0008  	RETURN
063A  0008  	RETURN



void FCM_Equipment2()

{

	//Decision
	//Decision: eq2_se1 = 0 AND eq2_se2 = 0 AND eq2_flag = 0?
	if (FCV_EQ2_SE1 == 0 & FCV_EQ2_SE2 == 0 & FCV_EQ2_FLAG == 0)
0523  1283  	BCF STATUS, RP0
0524  1303  	BCF STATUS, RP1
0525  01CE  	CLRF CompTempVar2213
0526  1CC2  	BTFSS gbl_FCV_EQ2_SE1,1
0527  0ACE  	INCF CompTempVar2213, F
0528  01CC  	CLRF CompTempVar2210
0529  1F42  	BTFSS gbl_FCV_EQ2_SE2,6
052A  0ACC  	INCF CompTempVar2210, F
052B  084C  	MOVF CompTempVar2210, W
052C  05CE  	ANDWF CompTempVar2213, F
052D  01CD  	CLRF CompTempVar2212
052E  1FC3  	BTFSS gbl_FCV_EQ2_FLAG,7
052F  0ACD  	INCF CompTempVar2212, F
0530  084D  	MOVF CompTempVar2212, W
0531  054E  	ANDWF CompTempVar2213, W
0532  1903  	BTFSC STATUS,Z
0533  2D47  	GOTO	label49
0547        label49

	{

		//Call Component Macro
		//Call Component Macro: SendRS232String("E2B")
		FCD_RS2320_SendRS232String("E2B", 3);
0534  3045  	MOVLW 0x45
0535  00CF  	MOVWF CompTempVar2214
0536  3032  	MOVLW 0x32
0537  00D0  	MOVWF CompTempVar2214+D'1'
0538  3042  	MOVLW 0x42
0539  00D1  	MOVWF CompTempVar2214+D'2'
053A  01D2  	CLRF CompTempVar2214+D'3'
053B  3000  	MOVLW HIGH(CompTempVar2214+D'0')
053C  00DD  	MOVWF FCD_RS2320_00052_arg_String+D'1'
053D  304F  	MOVLW LOW(CompTempVar2214+D'0')
053E  00DC  	MOVWF FCD_RS2320_00052_arg_String
053F  3003  	MOVLW 0x03
0540  00E2  	MOVWF FCD_RS2320_00052_arg_MSZ_String
0541  20F5  	CALL FCD_RS2320_00052


		//Delay
		//Delay: 200 ms
		delay_ms(200);
0542  30C8  	MOVLW 0xC8
0543  00D4  	MOVWF delay_ms_00000_arg_del
0544  2015  	CALL delay_ms_00000


		//Calculation
		//Calculation:
		//  eq2_flag = 1
		FCV_EQ2_FLAG = 1;
0545  17C3  	BSF gbl_FCV_EQ2_FLAG,7


	} else {

		//Decision
		//Decision: eq2_se1 = 1 AND eq2_se2 = 0 AND eq2_flag = 1?
		if (FCV_EQ2_SE1 == 1 & FCV_EQ2_SE2 == 0 & FCV_EQ2_FLAG == 1)
0547  01D1  	CLRF CompTempVar2219
0548  18C2  	BTFSC gbl_FCV_EQ2_SE1,1
0549  0AD1  	INCF CompTempVar2219, F
054A  01CF  	CLRF CompTempVar2216
054B  1F42  	BTFSS gbl_FCV_EQ2_SE2,6
054C  0ACF  	INCF CompTempVar2216, F
054D  084F  	MOVF CompTempVar2216, W
054E  05D1  	ANDWF CompTempVar2219, F
054F  01D0  	CLRF CompTempVar2218
0550  1BC3  	BTFSC gbl_FCV_EQ2_FLAG,7
0551  0AD0  	INCF CompTempVar2218, F
0552  0850  	MOVF CompTempVar2218, W
0553  0551  	ANDWF CompTempVar2219, W
0554  1903  	BTFSC STATUS,Z
0555  2D6C  	GOTO	label50
056C        label50

		{

			//Call Component Macro
			//Call Component Macro: SendRS232String("E2P")
			FCD_RS2320_SendRS232String("E2P", 3);
0556  3045  	MOVLW 0x45
0557  00D6  	MOVWF CompTempVar2220
0558  3032  	MOVLW 0x32
0559  00D7  	MOVWF CompTempVar2220+D'1'
055A  3050  	MOVLW 0x50
055B  00D8  	MOVWF CompTempVar2220+D'2'
055C  01D9  	CLRF CompTempVar2220+D'3'
055D  3000  	MOVLW HIGH(CompTempVar2220+D'0')
055E  00DD  	MOVWF FCD_RS2320_00052_arg_String+D'1'
055F  3056  	MOVLW LOW(CompTempVar2220+D'0')
0560  00DC  	MOVWF FCD_RS2320_00052_arg_String
0561  3003  	MOVLW 0x03
0562  00E2  	MOVWF FCD_RS2320_00052_arg_MSZ_String
0563  20F5  	CALL FCD_RS2320_00052


			//Delay
			//Delay: 500 ms
			delay_ms(255);
0564  30FF  	MOVLW 0xFF
0565  00D4  	MOVWF delay_ms_00000_arg_del
0566  2015  	CALL delay_ms_00000

			delay_ms(245);
0567  30F5  	MOVLW 0xF5
0568  00D4  	MOVWF delay_ms_00000_arg_del
0569  2015  	CALL delay_ms_00000


			//Calculation
			//Calculation:
			//  eq2_flag = 0
			FCV_EQ2_FLAG = 0;
056A  13C3  	BCF gbl_FCV_EQ2_FLAG,7


		} else {

			//Decision
			//Decision: eq2_se1 = 0 AND eq2_se2 = 1?
			if (FCV_EQ2_SE1 == 0 & FCV_EQ2_SE2 == 1)
056C  01D3  	CLRF CompTempVar2223
056D  1CC2  	BTFSS gbl_FCV_EQ2_SE1,1
056E  0AD3  	INCF CompTempVar2223, F
056F  01D2  	CLRF CompTempVar2222
0570  1B42  	BTFSC gbl_FCV_EQ2_SE2,6
0571  0AD2  	INCF CompTempVar2222, F
0572  0852  	MOVF CompTempVar2222, W
0573  0553  	ANDWF CompTempVar2223, W
0574  1903  	BTFSC STATUS,Z

			{

				//Calculation
				//Calculation:
				//  eq2_errorflag = 0
				FCV_EQ2_ERRORFLAG = 0;
0576  1242  	BCF gbl_FCV_EQ2_ERRORFLAG,4


				//Loop
				//Loop: While eq2_se2 = 1
				while (FCV_EQ2_SE2 == 1)
0577        label51
0577  1F42  	BTFSS gbl_FCV_EQ2_SE2,6
0578  2DAD  	GOTO	label53
05AC  2D77  	GOTO	label51
05AD        label53

				{

					//Input
					//Input: A3 -> eq2_se2
					trisa = trisa | 0x08;
0579  3008  	MOVLW 0x08
057A  1683  	BSF STATUS, RP0
057B  0405  	IORWF gbl_trisa, W
057C  0085  	MOVWF gbl_trisa

					FCV_EQ2_SE2 = ((porta & 0x08) == 0x08);
057D  3008  	MOVLW 0x08
057E  1283  	BCF STATUS, RP0
057F  0505  	ANDWF gbl_porta, W
0580  00D4  	MOVWF CompTempVar2224
0581  01D5  	CLRF CompTempVar2225
0582  3008  	MOVLW 0x08
0583  0254  	SUBWF CompTempVar2224, W
0584  1903  	BTFSC STATUS,Z
0585  0AD5  	INCF CompTempVar2225, F
0586  1342  	BCF gbl_FCV_EQ2_SE2,6
0587  0855  	MOVF CompTempVar2225, W
0588  1D03  	BTFSS STATUS,Z
0589  1742  	BSF gbl_FCV_EQ2_SE2,6


					//Decision
					//Decision: eq2_errorflag = 0?
					if (FCV_EQ2_ERRORFLAG == 0)
058A  1A42  	BTFSC gbl_FCV_EQ2_ERRORFLAG,4
058B  2DA1  	GOTO	label52
05A1        label52

					{

						//Call Component Macro
						//Call Component Macro: SendRS232String("E2R")
						FCD_RS2320_SendRS232String("E2R", 3);
058C  3045  	MOVLW 0x45
058D  00D6  	MOVWF CompTempVar2226
058E  3032  	MOVLW 0x32
058F  00D7  	MOVWF CompTempVar2226+D'1'
0590  3052  	MOVLW 0x52
0591  00D8  	MOVWF CompTempVar2226+D'2'
0592  01D9  	CLRF CompTempVar2226+D'3'
0593  3000  	MOVLW HIGH(CompTempVar2226+D'0')
0594  00DD  	MOVWF FCD_RS2320_00052_arg_String+D'1'
0595  3056  	MOVLW LOW(CompTempVar2226+D'0')
0596  00DC  	MOVWF FCD_RS2320_00052_arg_String
0597  3003  	MOVLW 0x03
0598  00E2  	MOVWF FCD_RS2320_00052_arg_MSZ_String
0599  20F5  	CALL FCD_RS2320_00052


						//Delay
						//Delay: 500 ms
						delay_ms(255);
059A  30FF  	MOVLW 0xFF
059B  00D4  	MOVWF delay_ms_00000_arg_del
059C  2015  	CALL delay_ms_00000

						delay_ms(245);
059D  30F5  	MOVLW 0xF5
059E  00D4  	MOVWF delay_ms_00000_arg_del
059F  2015  	CALL delay_ms_00000


						//Calculation
						//Calculation:
						//  eq2_errorflag = 1
						FCV_EQ2_ERRORFLAG = 1;
05A0  1642  	BSF gbl_FCV_EQ2_ERRORFLAG,4


					// } else {

					}

					//Call Component Macro
					//Call Component Macro: SetDutyCycle(76)
					FCD_PWM0_SetDutyCycle(76);
05A1  304C  	MOVLW 0x4C
05A2  00D4  	MOVWF FCD_PWM0_S_00053_arg_nDuty
05A3  210F  	CALL FCD_PWM0_S_00053


					//Delay
					//Delay: 100 ms
					delay_ms(100);
05A4  3064  	MOVLW 0x64
05A5  00D4  	MOVWF delay_ms_00000_arg_del
05A6  2015  	CALL delay_ms_00000


					//Call Component Macro
					//Call Component Macro: SetDutyCycle(0)
					FCD_PWM0_SetDutyCycle(0);
05A7  01D4  	CLRF FCD_PWM0_S_00053_arg_nDuty
05A8  210F  	CALL FCD_PWM0_S_00053


					//Delay
					//Delay: 100 ms
					delay_ms(100);
05A9  3064  	MOVLW 0x64
05AA  00D4  	MOVWF delay_ms_00000_arg_del
05AB  2015  	CALL delay_ms_00000



				}

				//Calculation
				//Calculation:
				//  eq2_flag = 0
				FCV_EQ2_FLAG = 0;
05AD  13C3  	BCF gbl_FCV_EQ2_FLAG,7


			// } else {

			}

		}

	}

}
0546  0008  	RETURN
056B  0008  	RETURN
0575  0008  	RETURN
05AE  0008  	RETURN



void FCM_Equipment3()

{

	//Decision
	//Decision: eq3_se1 = 0 AND eq3_se2 = 0 AND eq3_flag = 0?
	if (FCV_EQ3_SE1 == 0 & FCV_EQ3_SE2 == 0 & FCV_EQ3_FLAG == 0)
0497  1283  	BCF STATUS, RP0
0498  1303  	BCF STATUS, RP1
0499  01CE  	CLRF CompTempVar2231
049A  1EC2  	BTFSS gbl_FCV_EQ3_SE1,5
049B  0ACE  	INCF CompTempVar2231, F
049C  01CC  	CLRF CompTempVar2228
049D  1CC3  	BTFSS gbl_FCV_EQ3_SE2,1
049E  0ACC  	INCF CompTempVar2228, F
049F  084C  	MOVF CompTempVar2228, W
04A0  05CE  	ANDWF CompTempVar2231, F
04A1  01CD  	CLRF CompTempVar2230
04A2  1E43  	BTFSS gbl_FCV_EQ3_FLAG,4
04A3  0ACD  	INCF CompTempVar2230, F
04A4  084D  	MOVF CompTempVar2230, W
04A5  054E  	ANDWF CompTempVar2231, W
04A6  1903  	BTFSC STATUS,Z
04A7  2CBB  	GOTO	label44
04BB        label44

	{

		//Call Component Macro
		//Call Component Macro: SendRS232String("E3B")
		FCD_RS2320_SendRS232String("E3B", 3);
04A8  3045  	MOVLW 0x45
04A9  00CF  	MOVWF CompTempVar2232
04AA  3033  	MOVLW 0x33
04AB  00D0  	MOVWF CompTempVar2232+D'1'
04AC  3042  	MOVLW 0x42
04AD  00D1  	MOVWF CompTempVar2232+D'2'
04AE  01D2  	CLRF CompTempVar2232+D'3'
04AF  3000  	MOVLW HIGH(CompTempVar2232+D'0')
04B0  00DD  	MOVWF FCD_RS2320_00052_arg_String+D'1'
04B1  304F  	MOVLW LOW(CompTempVar2232+D'0')
04B2  00DC  	MOVWF FCD_RS2320_00052_arg_String
04B3  3003  	MOVLW 0x03
04B4  00E2  	MOVWF FCD_RS2320_00052_arg_MSZ_String
04B5  20F5  	CALL FCD_RS2320_00052


		//Delay
		//Delay: 200 ms
		delay_ms(200);
04B6  30C8  	MOVLW 0xC8
04B7  00D4  	MOVWF delay_ms_00000_arg_del
04B8  2015  	CALL delay_ms_00000


		//Calculation
		//Calculation:
		//  eq3_flag = 1
		FCV_EQ3_FLAG = 1;
04B9  1643  	BSF gbl_FCV_EQ3_FLAG,4


	} else {

		//Decision
		//Decision: eq3_se1 = 1 AND eq3_se2 = 0 AND eq3_flag = 1?
		if (FCV_EQ3_SE1 == 1 & FCV_EQ3_SE2 == 0 & FCV_EQ3_FLAG == 1)
04BB  01D1  	CLRF CompTempVar2237
04BC  1AC2  	BTFSC gbl_FCV_EQ3_SE1,5
04BD  0AD1  	INCF CompTempVar2237, F
04BE  01CF  	CLRF CompTempVar2234
04BF  1CC3  	BTFSS gbl_FCV_EQ3_SE2,1
04C0  0ACF  	INCF CompTempVar2234, F
04C1  084F  	MOVF CompTempVar2234, W
04C2  05D1  	ANDWF CompTempVar2237, F
04C3  01D0  	CLRF CompTempVar2236
04C4  1A43  	BTFSC gbl_FCV_EQ3_FLAG,4
04C5  0AD0  	INCF CompTempVar2236, F
04C6  0850  	MOVF CompTempVar2236, W
04C7  0551  	ANDWF CompTempVar2237, W
04C8  1903  	BTFSC STATUS,Z
04C9  2CE0  	GOTO	label45
04E0        label45

		{

			//Call Component Macro
			//Call Component Macro: SendRS232String("E3P")
			FCD_RS2320_SendRS232String("E3P", 3);
04CA  3045  	MOVLW 0x45
04CB  00D6  	MOVWF CompTempVar2238
04CC  3033  	MOVLW 0x33
04CD  00D7  	MOVWF CompTempVar2238+D'1'
04CE  3050  	MOVLW 0x50
04CF  00D8  	MOVWF CompTempVar2238+D'2'
04D0  01D9  	CLRF CompTempVar2238+D'3'
04D1  3000  	MOVLW HIGH(CompTempVar2238+D'0')
04D2  00DD  	MOVWF FCD_RS2320_00052_arg_String+D'1'
04D3  3056  	MOVLW LOW(CompTempVar2238+D'0')
04D4  00DC  	MOVWF FCD_RS2320_00052_arg_String
04D5  3003  	MOVLW 0x03
04D6  00E2  	MOVWF FCD_RS2320_00052_arg_MSZ_String
04D7  20F5  	CALL FCD_RS2320_00052


			//Delay
			//Delay: 500 ms
			delay_ms(255);
04D8  30FF  	MOVLW 0xFF
04D9  00D4  	MOVWF delay_ms_00000_arg_del
04DA  2015  	CALL delay_ms_00000

			delay_ms(245);
04DB  30F5  	MOVLW 0xF5
04DC  00D4  	MOVWF delay_ms_00000_arg_del
04DD  2015  	CALL delay_ms_00000


			//Calculation
			//Calculation:
			//  eq3_flag = 0
			FCV_EQ3_FLAG = 0;
04DE  1243  	BCF gbl_FCV_EQ3_FLAG,4


		} else {

			//Decision
			//Decision: eq3_se1 = 0 AND eq3_se2 = 1?
			if (FCV_EQ3_SE1 == 0 & FCV_EQ3_SE2 == 1)
04E0  01D3  	CLRF CompTempVar2241
04E1  1EC2  	BTFSS gbl_FCV_EQ3_SE1,5
04E2  0AD3  	INCF CompTempVar2241, F
04E3  01D2  	CLRF CompTempVar2240
04E4  18C3  	BTFSC gbl_FCV_EQ3_SE2,1
04E5  0AD2  	INCF CompTempVar2240, F
04E6  0852  	MOVF CompTempVar2240, W
04E7  0553  	ANDWF CompTempVar2241, W
04E8  1903  	BTFSC STATUS,Z

			{

				//Calculation
				//Calculation:
				//  eq3_errorflag = 0
				FCV_EQ3_ERRORFLAG = 0;
04EA  10C7  	BCF gbl_FCV_EQ3_ERRORFLAG,1


				//Loop
				//Loop: While eq3_se2 = 1
				while (FCV_EQ3_SE2 == 1)
04EB        label46
04EB  1CC3  	BTFSS gbl_FCV_EQ3_SE2,1
04EC  2D21  	GOTO	label48
0520  2CEB  	GOTO	label46
0521        label48

				{

					//Input
					//Input: A5 -> eq3_se2
					trisa = trisa | 0x20;
04ED  3020  	MOVLW 0x20
04EE  1683  	BSF STATUS, RP0
04EF  0405  	IORWF gbl_trisa, W
04F0  0085  	MOVWF gbl_trisa

					FCV_EQ3_SE2 = ((porta & 0x20) == 0x20);
04F1  3020  	MOVLW 0x20
04F2  1283  	BCF STATUS, RP0
04F3  0505  	ANDWF gbl_porta, W
04F4  00D4  	MOVWF CompTempVar2242
04F5  01D5  	CLRF CompTempVar2243
04F6  3020  	MOVLW 0x20
04F7  0254  	SUBWF CompTempVar2242, W
04F8  1903  	BTFSC STATUS,Z
04F9  0AD5  	INCF CompTempVar2243, F
04FA  10C3  	BCF gbl_FCV_EQ3_SE2,1
04FB  0855  	MOVF CompTempVar2243, W
04FC  1D03  	BTFSS STATUS,Z
04FD  14C3  	BSF gbl_FCV_EQ3_SE2,1


					//Decision
					//Decision: eq3_errorflag = 0?
					if (FCV_EQ3_ERRORFLAG == 0)
04FE  18C7  	BTFSC gbl_FCV_EQ3_ERRORFLAG,1
04FF  2D15  	GOTO	label47
0515        label47

					{

						//Call Component Macro
						//Call Component Macro: SendRS232String("E3R")
						FCD_RS2320_SendRS232String("E3R", 3);
0500  3045  	MOVLW 0x45
0501  00D6  	MOVWF CompTempVar2244
0502  3033  	MOVLW 0x33
0503  00D7  	MOVWF CompTempVar2244+D'1'
0504  3052  	MOVLW 0x52
0505  00D8  	MOVWF CompTempVar2244+D'2'
0506  01D9  	CLRF CompTempVar2244+D'3'
0507  3000  	MOVLW HIGH(CompTempVar2244+D'0')
0508  00DD  	MOVWF FCD_RS2320_00052_arg_String+D'1'
0509  3056  	MOVLW LOW(CompTempVar2244+D'0')
050A  00DC  	MOVWF FCD_RS2320_00052_arg_String
050B  3003  	MOVLW 0x03
050C  00E2  	MOVWF FCD_RS2320_00052_arg_MSZ_String
050D  20F5  	CALL FCD_RS2320_00052


						//Delay
						//Delay: 500 ms
						delay_ms(255);
050E  30FF  	MOVLW 0xFF
050F  00D4  	MOVWF delay_ms_00000_arg_del
0510  2015  	CALL delay_ms_00000

						delay_ms(245);
0511  30F5  	MOVLW 0xF5
0512  00D4  	MOVWF delay_ms_00000_arg_del
0513  2015  	CALL delay_ms_00000


						//Calculation
						//Calculation:
						//  eq3_errorflag = 1
						FCV_EQ3_ERRORFLAG = 1;
0514  14C7  	BSF gbl_FCV_EQ3_ERRORFLAG,1


					// } else {

					}

					//Call Component Macro
					//Call Component Macro: SetDutyCycle(76)
					FCD_PWM0_SetDutyCycle(76);
0515  304C  	MOVLW 0x4C
0516  00D4  	MOVWF FCD_PWM0_S_00053_arg_nDuty
0517  210F  	CALL FCD_PWM0_S_00053


					//Delay
					//Delay: 100 ms
					delay_ms(100);
0518  3064  	MOVLW 0x64
0519  00D4  	MOVWF delay_ms_00000_arg_del
051A  2015  	CALL delay_ms_00000


					//Call Component Macro
					//Call Component Macro: SetDutyCycle(0)
					FCD_PWM0_SetDutyCycle(0);
051B  01D4  	CLRF FCD_PWM0_S_00053_arg_nDuty
051C  210F  	CALL FCD_PWM0_S_00053


					//Delay
					//Delay: 100 ms
					delay_ms(100);
051D  3064  	MOVLW 0x64
051E  00D4  	MOVWF delay_ms_00000_arg_del
051F  2015  	CALL delay_ms_00000



				}

				//Calculation
				//Calculation:
				//  eq3_flag = 0
				FCV_EQ3_FLAG = 0;
0521  1243  	BCF gbl_FCV_EQ3_FLAG,4


			// } else {

			}

		}

	}

}
04BA  0008  	RETURN
04DF  0008  	RETURN
04E9  0008  	RETURN
0522  0008  	RETURN



void FCM_init()

{

	//Input
	//Input: A0 -> eq1_se1
	trisa = trisa | 0x01;
0163  3001  	MOVLW 0x01
0164  1683  	BSF STATUS, RP0
0165  1303  	BCF STATUS, RP1
0166  0405  	IORWF gbl_trisa, W
0167  0085  	MOVWF gbl_trisa

	FCV_EQ1_SE1 = ((porta & 0x01) == 0x01);
0168  3001  	MOVLW 0x01
0169  1283  	BCF STATUS, RP0
016A  0505  	ANDWF gbl_porta, W
016B  00CE  	MOVWF CompTempVar2252
016C  01CF  	CLRF CompTempVar2253
016D  034E  	DECF CompTempVar2252, W
016E  1903  	BTFSC STATUS,Z
016F  0ACF  	INCF CompTempVar2253, F
0170  1042  	BCF gbl_FCV_EQ1_SE1,0
0171  084F  	MOVF CompTempVar2253, W
0172  1D03  	BTFSS STATUS,Z
0173  1442  	BSF gbl_FCV_EQ1_SE1,0


	//Input
	//Input: A1 -> eq1_se2
	trisa = trisa | 0x02;
0174  3002  	MOVLW 0x02
0175  1683  	BSF STATUS, RP0
0176  0405  	IORWF gbl_trisa, W
0177  0085  	MOVWF gbl_trisa

	FCV_EQ1_SE2 = ((porta & 0x02) == 0x02);
0178  3002  	MOVLW 0x02
0179  1283  	BCF STATUS, RP0
017A  0505  	ANDWF gbl_porta, W
017B  00CE  	MOVWF CompTempVar2254
017C  01CF  	CLRF CompTempVar2255
017D  3002  	MOVLW 0x02
017E  024E  	SUBWF CompTempVar2254, W
017F  1903  	BTFSC STATUS,Z
0180  0ACF  	INCF CompTempVar2255, F
0181  1142  	BCF gbl_FCV_EQ1_SE2,2
0182  084F  	MOVF CompTempVar2255, W
0183  1D03  	BTFSS STATUS,Z
0184  1542  	BSF gbl_FCV_EQ1_SE2,2


	//Input
	//Input: A2 -> eq2_se1
	trisa = trisa | 0x04;
0185  3004  	MOVLW 0x04
0186  1683  	BSF STATUS, RP0
0187  0405  	IORWF gbl_trisa, W
0188  0085  	MOVWF gbl_trisa

	FCV_EQ2_SE1 = ((porta & 0x04) == 0x04);
0189  3004  	MOVLW 0x04
018A  1283  	BCF STATUS, RP0
018B  0505  	ANDWF gbl_porta, W
018C  00CE  	MOVWF CompTempVar2256
018D  01CF  	CLRF CompTempVar2257
018E  3004  	MOVLW 0x04
018F  024E  	SUBWF CompTempVar2256, W
0190  1903  	BTFSC STATUS,Z
0191  0ACF  	INCF CompTempVar2257, F
0192  10C2  	BCF gbl_FCV_EQ2_SE1,1
0193  084F  	MOVF CompTempVar2257, W
0194  1D03  	BTFSS STATUS,Z
0195  14C2  	BSF gbl_FCV_EQ2_SE1,1


	//Input
	//Input: A3 -> eq2_se2
	trisa = trisa | 0x08;
0196  3008  	MOVLW 0x08
0197  1683  	BSF STATUS, RP0
0198  0405  	IORWF gbl_trisa, W
0199  0085  	MOVWF gbl_trisa

	FCV_EQ2_SE2 = ((porta & 0x08) == 0x08);
019A  3008  	MOVLW 0x08
019B  1283  	BCF STATUS, RP0
019C  0505  	ANDWF gbl_porta, W
019D  00CE  	MOVWF CompTempVar2258
019E  01CF  	CLRF CompTempVar2259
019F  3008  	MOVLW 0x08
01A0  024E  	SUBWF CompTempVar2258, W
01A1  1903  	BTFSC STATUS,Z
01A2  0ACF  	INCF CompTempVar2259, F
01A3  1342  	BCF gbl_FCV_EQ2_SE2,6
01A4  084F  	MOVF CompTempVar2259, W
01A5  1D03  	BTFSS STATUS,Z
01A6  1742  	BSF gbl_FCV_EQ2_SE2,6


	//Input
	//Input: A4 -> eq3_se1
	trisa = trisa | 0x10;
01A7  3010  	MOVLW 0x10
01A8  1683  	BSF STATUS, RP0
01A9  0405  	IORWF gbl_trisa, W
01AA  0085  	MOVWF gbl_trisa

	FCV_EQ3_SE1 = ((porta & 0x10) == 0x10);
01AB  3010  	MOVLW 0x10
01AC  1283  	BCF STATUS, RP0
01AD  0505  	ANDWF gbl_porta, W
01AE  00CE  	MOVWF CompTempVar2260
01AF  01CF  	CLRF CompTempVar2261
01B0  3010  	MOVLW 0x10
01B1  024E  	SUBWF CompTempVar2260, W
01B2  1903  	BTFSC STATUS,Z
01B3  0ACF  	INCF CompTempVar2261, F
01B4  12C2  	BCF gbl_FCV_EQ3_SE1,5
01B5  084F  	MOVF CompTempVar2261, W
01B6  1D03  	BTFSS STATUS,Z
01B7  16C2  	BSF gbl_FCV_EQ3_SE1,5


	//Input
	//Input: A5 -> eq3_se2
	trisa = trisa | 0x20;
01B8  3020  	MOVLW 0x20
01B9  1683  	BSF STATUS, RP0
01BA  0405  	IORWF gbl_trisa, W
01BB  0085  	MOVWF gbl_trisa

	FCV_EQ3_SE2 = ((porta & 0x20) == 0x20);
01BC  3020  	MOVLW 0x20
01BD  1283  	BCF STATUS, RP0
01BE  0505  	ANDWF gbl_porta, W
01BF  00CE  	MOVWF CompTempVar2262
01C0  01CF  	CLRF CompTempVar2263
01C1  3020  	MOVLW 0x20
01C2  024E  	SUBWF CompTempVar2262, W
01C3  1903  	BTFSC STATUS,Z
01C4  0ACF  	INCF CompTempVar2263, F
01C5  10C3  	BCF gbl_FCV_EQ3_SE2,1
01C6  084F  	MOVF CompTempVar2263, W
01C7  1D03  	BTFSS STATUS,Z
01C8  14C3  	BSF gbl_FCV_EQ3_SE2,1


	//Decision
	//Decision: eq1_se1 = 1 OR eq1_se2 = 1?
	if (FCV_EQ1_SE1 == 1 | FCV_EQ1_SE2 == 1)
01C9  01C9  	CLRF CompTempVar2247
01CA  1842  	BTFSC gbl_FCV_EQ1_SE1,0
01CB  0AC9  	INCF CompTempVar2247, F
01CC  01C8  	CLRF CompTempVar2246
01CD  1942  	BTFSC gbl_FCV_EQ1_SE2,2
01CE  0AC8  	INCF CompTempVar2246, F
01CF  0848  	MOVF CompTempVar2246, W
01D0  0449  	IORWF CompTempVar2247, W
01D1  1D03  	BTFSS STATUS,Z

	{

		//Calculation
		//Calculation:
		//  eq1_flag = 1
		FCV_EQ1_FLAG = 1;
01D2  1645  	BSF gbl_FCV_EQ1_FLAG,4


	// } else {

	}

	//Decision
	//Decision: eq2_se1 = 1 OR eq2_se2 = 1?
	if (FCV_EQ2_SE1 == 1 | FCV_EQ2_SE2 == 1)
01D3  01CB  	CLRF CompTempVar2249
01D4  18C2  	BTFSC gbl_FCV_EQ2_SE1,1
01D5  0ACB  	INCF CompTempVar2249, F
01D6  01CA  	CLRF CompTempVar2248
01D7  1B42  	BTFSC gbl_FCV_EQ2_SE2,6
01D8  0ACA  	INCF CompTempVar2248, F
01D9  084A  	MOVF CompTempVar2248, W
01DA  044B  	IORWF CompTempVar2249, W
01DB  1D03  	BTFSS STATUS,Z

	{

		//Calculation
		//Calculation:
		//  eq2_flag = 1
		FCV_EQ2_FLAG = 1;
01DC  17C3  	BSF gbl_FCV_EQ2_FLAG,7


	// } else {

	}

	//Decision
	//Decision: eq3_se1 = 1 OR eq3_se2 = 1?
	if (FCV_EQ3_SE1 == 1 | FCV_EQ3_SE2 == 1)
01DD  01CD  	CLRF CompTempVar2251
01DE  1AC2  	BTFSC gbl_FCV_EQ3_SE1,5
01DF  0ACD  	INCF CompTempVar2251, F
01E0  01CC  	CLRF CompTempVar2250
01E1  18C3  	BTFSC gbl_FCV_EQ3_SE2,1
01E2  0ACC  	INCF CompTempVar2250, F
01E3  084C  	MOVF CompTempVar2250, W
01E4  044D  	IORWF CompTempVar2251, W
01E5  1D03  	BTFSS STATUS,Z

	{

		//Calculation
		//Calculation:
		//  eq3_flag = 1
		FCV_EQ3_FLAG = 1;
01E6  1643  	BSF gbl_FCV_EQ3_FLAG,4


	// } else {

	}

}
01E7  0008  	RETURN



void FCM_check()

{

	//Input
	//Input: A0 -> eq1_se1
	trisa = trisa | 0x01;
01E8  3001  	MOVLW 0x01
01E9  1683  	BSF STATUS, RP0
01EA  1303  	BCF STATUS, RP1
01EB  0405  	IORWF gbl_trisa, W
01EC  0085  	MOVWF gbl_trisa

	FCV_EQ1_SE1 = ((porta & 0x01) == 0x01);
01ED  3001  	MOVLW 0x01
01EE  1283  	BCF STATUS, RP0
01EF  0505  	ANDWF gbl_porta, W
01F0  00D8  	MOVWF CompTempVar2276
01F1  01D9  	CLRF CompTempVar2277
01F2  0358  	DECF CompTempVar2276, W
01F3  1903  	BTFSC STATUS,Z
01F4  0AD9  	INCF CompTempVar2277, F
01F5  1042  	BCF gbl_FCV_EQ1_SE1,0
01F6  0859  	MOVF CompTempVar2277, W
01F7  1D03  	BTFSS STATUS,Z
01F8  1442  	BSF gbl_FCV_EQ1_SE1,0


	//Input
	//Input: A1 -> eq1_se2
	trisa = trisa | 0x02;
01F9  3002  	MOVLW 0x02
01FA  1683  	BSF STATUS, RP0
01FB  0405  	IORWF gbl_trisa, W
01FC  0085  	MOVWF gbl_trisa

	FCV_EQ1_SE2 = ((porta & 0x02) == 0x02);
01FD  3002  	MOVLW 0x02
01FE  1283  	BCF STATUS, RP0
01FF  0505  	ANDWF gbl_porta, W
0200  00D8  	MOVWF CompTempVar2278
0201  01D9  	CLRF CompTempVar2279
0202  3002  	MOVLW 0x02
0203  0258  	SUBWF CompTempVar2278, W
0204  1903  	BTFSC STATUS,Z
0205  0AD9  	INCF CompTempVar2279, F
0206  1142  	BCF gbl_FCV_EQ1_SE2,2
0207  0859  	MOVF CompTempVar2279, W
0208  1D03  	BTFSS STATUS,Z
0209  1542  	BSF gbl_FCV_EQ1_SE2,2


	//Input
	//Input: A2 -> eq2_se1
	trisa = trisa | 0x04;
020A  3004  	MOVLW 0x04
020B  1683  	BSF STATUS, RP0
020C  0405  	IORWF gbl_trisa, W
020D  0085  	MOVWF gbl_trisa

	FCV_EQ2_SE1 = ((porta & 0x04) == 0x04);
020E  3004  	MOVLW 0x04
020F  1283  	BCF STATUS, RP0
0210  0505  	ANDWF gbl_porta, W
0211  00D8  	MOVWF CompTempVar2280
0212  01D9  	CLRF CompTempVar2281
0213  3004  	MOVLW 0x04
0214  0258  	SUBWF CompTempVar2280, W
0215  1903  	BTFSC STATUS,Z
0216  0AD9  	INCF CompTempVar2281, F
0217  10C2  	BCF gbl_FCV_EQ2_SE1,1
0218  0859  	MOVF CompTempVar2281, W
0219  1D03  	BTFSS STATUS,Z
021A  14C2  	BSF gbl_FCV_EQ2_SE1,1


	//Input
	//Input: A3 -> eq2_se2
	trisa = trisa | 0x08;
021B  3008  	MOVLW 0x08
021C  1683  	BSF STATUS, RP0
021D  0405  	IORWF gbl_trisa, W
021E  0085  	MOVWF gbl_trisa

	FCV_EQ2_SE2 = ((porta & 0x08) == 0x08);
021F  3008  	MOVLW 0x08
0220  1283  	BCF STATUS, RP0
0221  0505  	ANDWF gbl_porta, W
0222  00D8  	MOVWF CompTempVar2282
0223  01D9  	CLRF CompTempVar2283
0224  3008  	MOVLW 0x08
0225  0258  	SUBWF CompTempVar2282, W
0226  1903  	BTFSC STATUS,Z
0227  0AD9  	INCF CompTempVar2283, F
0228  1342  	BCF gbl_FCV_EQ2_SE2,6
0229  0859  	MOVF CompTempVar2283, W
022A  1D03  	BTFSS STATUS,Z
022B  1742  	BSF gbl_FCV_EQ2_SE2,6


	//Input
	//Input: A4 -> eq3_se1
	trisa = trisa | 0x10;
022C  3010  	MOVLW 0x10
022D  1683  	BSF STATUS, RP0
022E  0405  	IORWF gbl_trisa, W
022F  0085  	MOVWF gbl_trisa

	FCV_EQ3_SE1 = ((porta & 0x10) == 0x10);
0230  3010  	MOVLW 0x10
0231  1283  	BCF STATUS, RP0
0232  0505  	ANDWF gbl_porta, W
0233  00D8  	MOVWF CompTempVar2284
0234  01D9  	CLRF CompTempVar2285
0235  3010  	MOVLW 0x10
0236  0258  	SUBWF CompTempVar2284, W
0237  1903  	BTFSC STATUS,Z
0238  0AD9  	INCF CompTempVar2285, F
0239  12C2  	BCF gbl_FCV_EQ3_SE1,5
023A  0859  	MOVF CompTempVar2285, W
023B  1D03  	BTFSS STATUS,Z
023C  16C2  	BSF gbl_FCV_EQ3_SE1,5


	//Input
	//Input: A5 -> eq3_se2
	trisa = trisa | 0x20;
023D  3020  	MOVLW 0x20
023E  1683  	BSF STATUS, RP0
023F  0405  	IORWF gbl_trisa, W
0240  0085  	MOVWF gbl_trisa

	FCV_EQ3_SE2 = ((porta & 0x20) == 0x20);
0241  3020  	MOVLW 0x20
0242  1283  	BCF STATUS, RP0
0243  0505  	ANDWF gbl_porta, W
0244  00D8  	MOVWF CompTempVar2286
0245  01D9  	CLRF CompTempVar2287
0246  3020  	MOVLW 0x20
0247  0258  	SUBWF CompTempVar2286, W
0248  1903  	BTFSC STATUS,Z
0249  0AD9  	INCF CompTempVar2287, F
024A  10C3  	BCF gbl_FCV_EQ3_SE2,1
024B  0859  	MOVF CompTempVar2287, W
024C  1D03  	BTFSS STATUS,Z
024D  14C3  	BSF gbl_FCV_EQ3_SE2,1


	//Decision
	//Decision: eq1_se1 = 0 AND eq1_se2 = 0?
	if (FCV_EQ1_SE1 == 0 & FCV_EQ1_SE2 == 0)
024E  01CD  	CLRF CompTempVar2265
024F  1C42  	BTFSS gbl_FCV_EQ1_SE1,0
0250  0ACD  	INCF CompTempVar2265, F
0251  01CC  	CLRF CompTempVar2264
0252  1D42  	BTFSS gbl_FCV_EQ1_SE2,2
0253  0ACC  	INCF CompTempVar2264, F
0254  084C  	MOVF CompTempVar2264, W
0255  054D  	ANDWF CompTempVar2265, W
0256  1903  	BTFSC STATUS,Z
0257  2A67  	GOTO	label22
0267        label22

	{

		//Call Component Macro
		//Call Component Macro: SendRS232String("E1B")
		FCD_RS2320_SendRS232String("E1B", 3);
0258  3045  	MOVLW 0x45
0259  00DE  	MOVWF CompTempVar2288
025A  3031  	MOVLW 0x31
025B  00DF  	MOVWF CompTempVar2288+D'1'
025C  3042  	MOVLW 0x42
025D  00E0  	MOVWF CompTempVar2288+D'2'
025E  01E1  	CLRF CompTempVar2288+D'3'
025F  3000  	MOVLW HIGH(CompTempVar2288+D'0')
0260  00DD  	MOVWF FCD_RS2320_00052_arg_String+D'1'
0261  305E  	MOVLW LOW(CompTempVar2288+D'0')
0262  00DC  	MOVWF FCD_RS2320_00052_arg_String
0263  3003  	MOVLW 0x03
0264  00E2  	MOVWF FCD_RS2320_00052_arg_MSZ_String
0265  20F5  	CALL FCD_RS2320_00052


	} else {
0266  2A98  	GOTO	label24


		//Decision
		//Decision: eq1_se1 = 1 AND eq1_se2 = 0?
		if (FCV_EQ1_SE1 == 1 & FCV_EQ1_SE2 == 0)
0267  01D9  	CLRF CompTempVar2291
0268  1842  	BTFSC gbl_FCV_EQ1_SE1,0
0269  0AD9  	INCF CompTempVar2291, F
026A  01D8  	CLRF CompTempVar2290
026B  1D42  	BTFSS gbl_FCV_EQ1_SE2,2
026C  0AD8  	INCF CompTempVar2290, F
026D  0858  	MOVF CompTempVar2290, W
026E  0559  	ANDWF CompTempVar2291, W
026F  1903  	BTFSC STATUS,Z
0270  2A80  	GOTO	label23
0280        label23

		{

			//Call Component Macro
			//Call Component Macro: SendRS232String("E1P")
			FCD_RS2320_SendRS232String("E1P", 3);
0271  3045  	MOVLW 0x45
0272  00DE  	MOVWF CompTempVar2292
0273  3031  	MOVLW 0x31
0274  00DF  	MOVWF CompTempVar2292+D'1'
0275  3050  	MOVLW 0x50
0276  00E0  	MOVWF CompTempVar2292+D'2'
0277  01E1  	CLRF CompTempVar2292+D'3'
0278  3000  	MOVLW HIGH(CompTempVar2292+D'0')
0279  00DD  	MOVWF FCD_RS2320_00052_arg_String+D'1'
027A  305E  	MOVLW LOW(CompTempVar2292+D'0')
027B  00DC  	MOVWF FCD_RS2320_00052_arg_String
027C  3003  	MOVLW 0x03
027D  00E2  	MOVWF FCD_RS2320_00052_arg_MSZ_String
027E  20F5  	CALL FCD_RS2320_00052


		} else {
027F  2A98  	GOTO	label24


			//Decision
			//Decision: eq1_se1 = 0 AND eq1_se2 = 1?
			if (FCV_EQ1_SE1 == 0 & FCV_EQ1_SE2 == 1)
0280  01DB  	CLRF CompTempVar2295
0281  1C42  	BTFSS gbl_FCV_EQ1_SE1,0
0282  0ADB  	INCF CompTempVar2295, F
0283  01DA  	CLRF CompTempVar2294
0284  1942  	BTFSC gbl_FCV_EQ1_SE2,2
0285  0ADA  	INCF CompTempVar2294, F
0286  085A  	MOVF CompTempVar2294, W
0287  055B  	ANDWF CompTempVar2295, W
0288  1903  	BTFSC STATUS,Z
0289  2A98  	GOTO	label24
0298        label24

			{

				//Call Component Macro
				//Call Component Macro: SendRS232String("E1R")
				FCD_RS2320_SendRS232String("E1R", 3);
028A  3045  	MOVLW 0x45
028B  00DE  	MOVWF CompTempVar2296
028C  3031  	MOVLW 0x31
028D  00DF  	MOVWF CompTempVar2296+D'1'
028E  3052  	MOVLW 0x52
028F  00E0  	MOVWF CompTempVar2296+D'2'
0290  01E1  	CLRF CompTempVar2296+D'3'
0291  3000  	MOVLW HIGH(CompTempVar2296+D'0')
0292  00DD  	MOVWF FCD_RS2320_00052_arg_String+D'1'
0293  305E  	MOVLW LOW(CompTempVar2296+D'0')
0294  00DC  	MOVWF FCD_RS2320_00052_arg_String
0295  3003  	MOVLW 0x03
0296  00E2  	MOVWF FCD_RS2320_00052_arg_MSZ_String
0297  20F5  	CALL FCD_RS2320_00052


			// } else {

			}

		}

	}

	//Decision
	//Decision: eq2_se1 = 0 AND eq2_se2 = 0?
	if (FCV_EQ2_SE1 == 0 & FCV_EQ2_SE2 == 0)
0298  01CF  	CLRF CompTempVar2267
0299  1CC2  	BTFSS gbl_FCV_EQ2_SE1,1
029A  0ACF  	INCF CompTempVar2267, F
029B  01CE  	CLRF CompTempVar2266
029C  1F42  	BTFSS gbl_FCV_EQ2_SE2,6
029D  0ACE  	INCF CompTempVar2266, F
029E  084E  	MOVF CompTempVar2266, W
029F  054F  	ANDWF CompTempVar2267, W
02A0  1903  	BTFSC STATUS,Z
02A1  2AB1  	GOTO	label25
02B1        label25

	{

		//Call Component Macro
		//Call Component Macro: SendRS232String("E2B")
		FCD_RS2320_SendRS232String("E2B", 3);
02A2  3045  	MOVLW 0x45
02A3  00D8  	MOVWF CompTempVar2298
02A4  3032  	MOVLW 0x32
02A5  00D9  	MOVWF CompTempVar2298+D'1'
02A6  3042  	MOVLW 0x42
02A7  00DA  	MOVWF CompTempVar2298+D'2'
02A8  01DB  	CLRF CompTempVar2298+D'3'
02A9  3000  	MOVLW HIGH(CompTempVar2298+D'0')
02AA  00DD  	MOVWF FCD_RS2320_00052_arg_String+D'1'
02AB  3058  	MOVLW LOW(CompTempVar2298+D'0')
02AC  00DC  	MOVWF FCD_RS2320_00052_arg_String
02AD  3003  	MOVLW 0x03
02AE  00E2  	MOVWF FCD_RS2320_00052_arg_MSZ_String
02AF  20F5  	CALL FCD_RS2320_00052


	} else {
02B0  2AE2  	GOTO	label27


		//Decision
		//Decision: eq2_se1 = 1 AND eq2_se2 = 0?
		if (FCV_EQ2_SE1 == 1 & FCV_EQ2_SE2 == 0)
02B1  01D9  	CLRF CompTempVar2301
02B2  18C2  	BTFSC gbl_FCV_EQ2_SE1,1
02B3  0AD9  	INCF CompTempVar2301, F
02B4  01D8  	CLRF CompTempVar2300
02B5  1F42  	BTFSS gbl_FCV_EQ2_SE2,6
02B6  0AD8  	INCF CompTempVar2300, F
02B7  0858  	MOVF CompTempVar2300, W
02B8  0559  	ANDWF CompTempVar2301, W
02B9  1903  	BTFSC STATUS,Z
02BA  2ACA  	GOTO	label26
02CA        label26

		{

			//Call Component Macro
			//Call Component Macro: SendRS232String("E2P")
			FCD_RS2320_SendRS232String("E2P", 3);
02BB  3045  	MOVLW 0x45
02BC  00DE  	MOVWF CompTempVar2302
02BD  3032  	MOVLW 0x32
02BE  00DF  	MOVWF CompTempVar2302+D'1'
02BF  3050  	MOVLW 0x50
02C0  00E0  	MOVWF CompTempVar2302+D'2'
02C1  01E1  	CLRF CompTempVar2302+D'3'
02C2  3000  	MOVLW HIGH(CompTempVar2302+D'0')
02C3  00DD  	MOVWF FCD_RS2320_00052_arg_String+D'1'
02C4  305E  	MOVLW LOW(CompTempVar2302+D'0')
02C5  00DC  	MOVWF FCD_RS2320_00052_arg_String
02C6  3003  	MOVLW 0x03
02C7  00E2  	MOVWF FCD_RS2320_00052_arg_MSZ_String
02C8  20F5  	CALL FCD_RS2320_00052


		} else {
02C9  2AE2  	GOTO	label27


			//Decision
			//Decision: eq2_se1 = 0 AND eq2_se2 = 1?
			if (FCV_EQ2_SE1 == 0 & FCV_EQ2_SE2 == 1)
02CA  01DB  	CLRF CompTempVar2305
02CB  1CC2  	BTFSS gbl_FCV_EQ2_SE1,1
02CC  0ADB  	INCF CompTempVar2305, F
02CD  01DA  	CLRF CompTempVar2304
02CE  1B42  	BTFSC gbl_FCV_EQ2_SE2,6
02CF  0ADA  	INCF CompTempVar2304, F
02D0  085A  	MOVF CompTempVar2304, W
02D1  055B  	ANDWF CompTempVar2305, W
02D2  1903  	BTFSC STATUS,Z
02D3  2AE2  	GOTO	label27
02E2        label27

			{

				//Call Component Macro
				//Call Component Macro: SendRS232String("E2R")
				FCD_RS2320_SendRS232String("E2R", 3);
02D4  3045  	MOVLW 0x45
02D5  00DE  	MOVWF CompTempVar2306
02D6  3032  	MOVLW 0x32
02D7  00DF  	MOVWF CompTempVar2306+D'1'
02D8  3052  	MOVLW 0x52
02D9  00E0  	MOVWF CompTempVar2306+D'2'
02DA  01E1  	CLRF CompTempVar2306+D'3'
02DB  3000  	MOVLW HIGH(CompTempVar2306+D'0')
02DC  00DD  	MOVWF FCD_RS2320_00052_arg_String+D'1'
02DD  305E  	MOVLW LOW(CompTempVar2306+D'0')
02DE  00DC  	MOVWF FCD_RS2320_00052_arg_String
02DF  3003  	MOVLW 0x03
02E0  00E2  	MOVWF FCD_RS2320_00052_arg_MSZ_String
02E1  20F5  	CALL FCD_RS2320_00052


			// } else {

			}

		}

	}

	//Decision
	//Decision: eq3_se1 = 0 AND eq3_se2 = 0?
	if (FCV_EQ3_SE1 == 0 & FCV_EQ3_SE2 == 0)
02E2  01D1  	CLRF CompTempVar2269
02E3  1EC2  	BTFSS gbl_FCV_EQ3_SE1,5
02E4  0AD1  	INCF CompTempVar2269, F
02E5  01D0  	CLRF CompTempVar2268
02E6  1CC3  	BTFSS gbl_FCV_EQ3_SE2,1
02E7  0AD0  	INCF CompTempVar2268, F
02E8  0850  	MOVF CompTempVar2268, W
02E9  0551  	ANDWF CompTempVar2269, W
02EA  1903  	BTFSC STATUS,Z
02EB  2AFB  	GOTO	label28
02FB        label28

	{

		//Call Component Macro
		//Call Component Macro: SendRS232String("E3B")
		FCD_RS2320_SendRS232String("E3B", 3);
02EC  3045  	MOVLW 0x45
02ED  00D8  	MOVWF CompTempVar2308
02EE  3033  	MOVLW 0x33
02EF  00D9  	MOVWF CompTempVar2308+D'1'
02F0  3042  	MOVLW 0x42
02F1  00DA  	MOVWF CompTempVar2308+D'2'
02F2  01DB  	CLRF CompTempVar2308+D'3'
02F3  3000  	MOVLW HIGH(CompTempVar2308+D'0')
02F4  00DD  	MOVWF FCD_RS2320_00052_arg_String+D'1'
02F5  3058  	MOVLW LOW(CompTempVar2308+D'0')
02F6  00DC  	MOVWF FCD_RS2320_00052_arg_String
02F7  3003  	MOVLW 0x03
02F8  00E2  	MOVWF FCD_RS2320_00052_arg_MSZ_String
02F9  20F5  	CALL FCD_RS2320_00052


	} else {
02FA  2B2C  	GOTO	label30


		//Decision
		//Decision: eq3_se1 = 1 AND eq3_se2 = 0?
		if (FCV_EQ3_SE1 == 1 & FCV_EQ3_SE2 == 0)
02FB  01D9  	CLRF CompTempVar2311
02FC  1AC2  	BTFSC gbl_FCV_EQ3_SE1,5
02FD  0AD9  	INCF CompTempVar2311, F
02FE  01D8  	CLRF CompTempVar2310
02FF  1CC3  	BTFSS gbl_FCV_EQ3_SE2,1
0300  0AD8  	INCF CompTempVar2310, F
0301  0858  	MOVF CompTempVar2310, W
0302  0559  	ANDWF CompTempVar2311, W
0303  1903  	BTFSC STATUS,Z
0304  2B14  	GOTO	label29
0314        label29

		{

			//Call Component Macro
			//Call Component Macro: SendRS232String("E3P")
			FCD_RS2320_SendRS232String("E3P", 3);
0305  3045  	MOVLW 0x45
0306  00DE  	MOVWF CompTempVar2312
0307  3033  	MOVLW 0x33
0308  00DF  	MOVWF CompTempVar2312+D'1'
0309  3050  	MOVLW 0x50
030A  00E0  	MOVWF CompTempVar2312+D'2'
030B  01E1  	CLRF CompTempVar2312+D'3'
030C  3000  	MOVLW HIGH(CompTempVar2312+D'0')
030D  00DD  	MOVWF FCD_RS2320_00052_arg_String+D'1'
030E  305E  	MOVLW LOW(CompTempVar2312+D'0')
030F  00DC  	MOVWF FCD_RS2320_00052_arg_String
0310  3003  	MOVLW 0x03
0311  00E2  	MOVWF FCD_RS2320_00052_arg_MSZ_String
0312  20F5  	CALL FCD_RS2320_00052


		} else {
0313  2B2C  	GOTO	label30


			//Decision
			//Decision: eq3_se1 = 0 AND eq3_se2 = 1?
			if (FCV_EQ3_SE1 == 0 & FCV_EQ3_SE2 == 1)
0314  01DB  	CLRF CompTempVar2315
0315  1EC2  	BTFSS gbl_FCV_EQ3_SE1,5
0316  0ADB  	INCF CompTempVar2315, F
0317  01DA  	CLRF CompTempVar2314
0318  18C3  	BTFSC gbl_FCV_EQ3_SE2,1
0319  0ADA  	INCF CompTempVar2314, F
031A  085A  	MOVF CompTempVar2314, W
031B  055B  	ANDWF CompTempVar2315, W
031C  1903  	BTFSC STATUS,Z
031D  2B2C  	GOTO	label30
032C        label30

			{

				//Call Component Macro
				//Call Component Macro: SendRS232String("E3R")
				FCD_RS2320_SendRS232String("E3R", 3);
031E  3045  	MOVLW 0x45
031F  00DE  	MOVWF CompTempVar2316
0320  3033  	MOVLW 0x33
0321  00DF  	MOVWF CompTempVar2316+D'1'
0322  3052  	MOVLW 0x52
0323  00E0  	MOVWF CompTempVar2316+D'2'
0324  01E1  	CLRF CompTempVar2316+D'3'
0325  3000  	MOVLW HIGH(CompTempVar2316+D'0')
0326  00DD  	MOVWF FCD_RS2320_00052_arg_String+D'1'
0327  305E  	MOVLW LOW(CompTempVar2316+D'0')
0328  00DC  	MOVWF FCD_RS2320_00052_arg_String
0329  3003  	MOVLW 0x03
032A  00E2  	MOVWF FCD_RS2320_00052_arg_MSZ_String
032B  20F5  	CALL FCD_RS2320_00052


			// } else {

			}

		}

	}

	//Decision
	//Decision: eq4_se1 = 0 AND eq4_se2 = 0?
	if (FCV_EQ4_SE1 == 0 & FCV_EQ4_SE2 == 0)
032C  01D3  	CLRF CompTempVar2271
032D  1DC3  	BTFSS gbl_FCV_EQ4_SE1,3
032E  0AD3  	INCF CompTempVar2271, F
032F  01D2  	CLRF CompTempVar2270
0330  1EC3  	BTFSS gbl_FCV_EQ4_SE2,5
0331  0AD2  	INCF CompTempVar2270, F
0332  0852  	MOVF CompTempVar2270, W
0333  0553  	ANDWF CompTempVar2271, W
0334  1903  	BTFSC STATUS,Z
0335  2B45  	GOTO	label31
0345        label31

	{

		//Call Component Macro
		//Call Component Macro: SendRS232String("E4B")
		FCD_RS2320_SendRS232String("E4B", 3);
0336  3045  	MOVLW 0x45
0337  00D8  	MOVWF CompTempVar2318
0338  3034  	MOVLW 0x34
0339  00D9  	MOVWF CompTempVar2318+D'1'
033A  3042  	MOVLW 0x42
033B  00DA  	MOVWF CompTempVar2318+D'2'
033C  01DB  	CLRF CompTempVar2318+D'3'
033D  3000  	MOVLW HIGH(CompTempVar2318+D'0')
033E  00DD  	MOVWF FCD_RS2320_00052_arg_String+D'1'
033F  3058  	MOVLW LOW(CompTempVar2318+D'0')
0340  00DC  	MOVWF FCD_RS2320_00052_arg_String
0341  3003  	MOVLW 0x03
0342  00E2  	MOVWF FCD_RS2320_00052_arg_MSZ_String
0343  20F5  	CALL FCD_RS2320_00052


	} else {
0344  2B76  	GOTO	label33


		//Decision
		//Decision: eq4_se1 = 1 AND eq4_se2 = 0?
		if (FCV_EQ4_SE1 == 1 & FCV_EQ4_SE2 == 0)
0345  01D9  	CLRF CompTempVar2321
0346  19C3  	BTFSC gbl_FCV_EQ4_SE1,3
0347  0AD9  	INCF CompTempVar2321, F
0348  01D8  	CLRF CompTempVar2320
0349  1EC3  	BTFSS gbl_FCV_EQ4_SE2,5
034A  0AD8  	INCF CompTempVar2320, F
034B  0858  	MOVF CompTempVar2320, W
034C  0559  	ANDWF CompTempVar2321, W
034D  1903  	BTFSC STATUS,Z
034E  2B5E  	GOTO	label32
035E        label32

		{

			//Call Component Macro
			//Call Component Macro: SendRS232String("E4P")
			FCD_RS2320_SendRS232String("E4P", 3);
034F  3045  	MOVLW 0x45
0350  00DE  	MOVWF CompTempVar2322
0351  3034  	MOVLW 0x34
0352  00DF  	MOVWF CompTempVar2322+D'1'
0353  3050  	MOVLW 0x50
0354  00E0  	MOVWF CompTempVar2322+D'2'
0355  01E1  	CLRF CompTempVar2322+D'3'
0356  3000  	MOVLW HIGH(CompTempVar2322+D'0')
0357  00DD  	MOVWF FCD_RS2320_00052_arg_String+D'1'
0358  305E  	MOVLW LOW(CompTempVar2322+D'0')
0359  00DC  	MOVWF FCD_RS2320_00052_arg_String
035A  3003  	MOVLW 0x03
035B  00E2  	MOVWF FCD_RS2320_00052_arg_MSZ_String
035C  20F5  	CALL FCD_RS2320_00052


		} else {
035D  2B76  	GOTO	label33


			//Decision
			//Decision: eq4_se1 = 0 AND eq4_se2 = 1?
			if (FCV_EQ4_SE1 == 0 & FCV_EQ4_SE2 == 1)
035E  01DB  	CLRF CompTempVar2325
035F  1DC3  	BTFSS gbl_FCV_EQ4_SE1,3
0360  0ADB  	INCF CompTempVar2325, F
0361  01DA  	CLRF CompTempVar2324
0362  1AC3  	BTFSC gbl_FCV_EQ4_SE2,5
0363  0ADA  	INCF CompTempVar2324, F
0364  085A  	MOVF CompTempVar2324, W
0365  055B  	ANDWF CompTempVar2325, W
0366  1903  	BTFSC STATUS,Z
0367  2B76  	GOTO	label33
0376        label33

			{

				//Call Component Macro
				//Call Component Macro: SendRS232String("E4R")
				FCD_RS2320_SendRS232String("E4R", 3);
0368  3045  	MOVLW 0x45
0369  00DE  	MOVWF CompTempVar2326
036A  3034  	MOVLW 0x34
036B  00DF  	MOVWF CompTempVar2326+D'1'
036C  3052  	MOVLW 0x52
036D  00E0  	MOVWF CompTempVar2326+D'2'
036E  01E1  	CLRF CompTempVar2326+D'3'
036F  3000  	MOVLW HIGH(CompTempVar2326+D'0')
0370  00DD  	MOVWF FCD_RS2320_00052_arg_String+D'1'
0371  305E  	MOVLW LOW(CompTempVar2326+D'0')
0372  00DC  	MOVWF FCD_RS2320_00052_arg_String
0373  3003  	MOVLW 0x03
0374  00E2  	MOVWF FCD_RS2320_00052_arg_MSZ_String
0375  20F5  	CALL FCD_RS2320_00052


			// } else {

			}

		}

	}

	//Decision
	//Decision: eq5_se1 = 0 AND eq5_se2 = 0?
	if (FCV_EQ5_SE1 == 0 & FCV_EQ5_SE2 == 0)
0376  01D5  	CLRF CompTempVar2273
0377  1F43  	BTFSS gbl_FCV_EQ5_SE1,6
0378  0AD5  	INCF CompTempVar2273, F
0379  01D4  	CLRF CompTempVar2272
037A  1D45  	BTFSS gbl_FCV_EQ5_SE2,2
037B  0AD4  	INCF CompTempVar2272, F
037C  0854  	MOVF CompTempVar2272, W
037D  0555  	ANDWF CompTempVar2273, W
037E  1903  	BTFSC STATUS,Z
037F  2B8F  	GOTO	label34
038F        label34

	{

		//Call Component Macro
		//Call Component Macro: SendRS232String("E5B")
		FCD_RS2320_SendRS232String("E5B", 3);
0380  3045  	MOVLW 0x45
0381  00D8  	MOVWF CompTempVar2328
0382  3035  	MOVLW 0x35
0383  00D9  	MOVWF CompTempVar2328+D'1'
0384  3042  	MOVLW 0x42
0385  00DA  	MOVWF CompTempVar2328+D'2'
0386  01DB  	CLRF CompTempVar2328+D'3'
0387  3000  	MOVLW HIGH(CompTempVar2328+D'0')
0388  00DD  	MOVWF FCD_RS2320_00052_arg_String+D'1'
0389  3058  	MOVLW LOW(CompTempVar2328+D'0')
038A  00DC  	MOVWF FCD_RS2320_00052_arg_String
038B  3003  	MOVLW 0x03
038C  00E2  	MOVWF FCD_RS2320_00052_arg_MSZ_String
038D  20F5  	CALL FCD_RS2320_00052


	} else {
038E  2BC0  	GOTO	label36


		//Decision
		//Decision: eq5_se1 = 1 AND eq5_se2 = 0?
		if (FCV_EQ5_SE1 == 1 & FCV_EQ5_SE2 == 0)
038F  01D9  	CLRF CompTempVar2331
0390  1B43  	BTFSC gbl_FCV_EQ5_SE1,6
0391  0AD9  	INCF CompTempVar2331, F
0392  01D8  	CLRF CompTempVar2330
0393  1D45  	BTFSS gbl_FCV_EQ5_SE2,2
0394  0AD8  	INCF CompTempVar2330, F
0395  0858  	MOVF CompTempVar2330, W
0396  0559  	ANDWF CompTempVar2331, W
0397  1903  	BTFSC STATUS,Z
0398  2BA8  	GOTO	label35
03A8        label35

		{

			//Call Component Macro
			//Call Component Macro: SendRS232String("E5P")
			FCD_RS2320_SendRS232String("E5P", 3);
0399  3045  	MOVLW 0x45
039A  00DE  	MOVWF CompTempVar2332
039B  3035  	MOVLW 0x35
039C  00DF  	MOVWF CompTempVar2332+D'1'
039D  3050  	MOVLW 0x50
039E  00E0  	MOVWF CompTempVar2332+D'2'
039F  01E1  	CLRF CompTempVar2332+D'3'
03A0  3000  	MOVLW HIGH(CompTempVar2332+D'0')
03A1  00DD  	MOVWF FCD_RS2320_00052_arg_String+D'1'
03A2  305E  	MOVLW LOW(CompTempVar2332+D'0')
03A3  00DC  	MOVWF FCD_RS2320_00052_arg_String
03A4  3003  	MOVLW 0x03
03A5  00E2  	MOVWF FCD_RS2320_00052_arg_MSZ_String
03A6  20F5  	CALL FCD_RS2320_00052


		} else {
03A7  2BC0  	GOTO	label36


			//Decision
			//Decision: eq5_se1 = 0 AND eq5_se2 = 1?
			if (FCV_EQ5_SE1 == 0 & FCV_EQ5_SE2 == 1)
03A8  01DB  	CLRF CompTempVar2335
03A9  1F43  	BTFSS gbl_FCV_EQ5_SE1,6
03AA  0ADB  	INCF CompTempVar2335, F
03AB  01DA  	CLRF CompTempVar2334
03AC  1945  	BTFSC gbl_FCV_EQ5_SE2,2
03AD  0ADA  	INCF CompTempVar2334, F
03AE  085A  	MOVF CompTempVar2334, W
03AF  055B  	ANDWF CompTempVar2335, W
03B0  1903  	BTFSC STATUS,Z
03B1  2BC0  	GOTO	label36
03C0        label36

			{

				//Call Component Macro
				//Call Component Macro: SendRS232String("E5R")
				FCD_RS2320_SendRS232String("E5R", 3);
03B2  3045  	MOVLW 0x45
03B3  00DE  	MOVWF CompTempVar2336
03B4  3035  	MOVLW 0x35
03B5  00DF  	MOVWF CompTempVar2336+D'1'
03B6  3052  	MOVLW 0x52
03B7  00E0  	MOVWF CompTempVar2336+D'2'
03B8  01E1  	CLRF CompTempVar2336+D'3'
03B9  3000  	MOVLW HIGH(CompTempVar2336+D'0')
03BA  00DD  	MOVWF FCD_RS2320_00052_arg_String+D'1'
03BB  305E  	MOVLW LOW(CompTempVar2336+D'0')
03BC  00DC  	MOVWF FCD_RS2320_00052_arg_String
03BD  3003  	MOVLW 0x03
03BE  00E2  	MOVWF FCD_RS2320_00052_arg_MSZ_String
03BF  20F5  	CALL FCD_RS2320_00052


			// } else {

			}

		}

	}

	//Decision
	//Decision: eq6_se1 = 0 AND eq6_se2 = 0?
	if (FCV_EQ6_SE1 == 0 & FCV_EQ6_SE2 == 0)
03C0  01D7  	CLRF CompTempVar2275
03C1  1DC5  	BTFSS gbl_FCV_EQ6_SE1,3
03C2  0AD7  	INCF CompTempVar2275, F
03C3  01D6  	CLRF CompTempVar2274
03C4  1EC5  	BTFSS gbl_FCV_EQ6_SE2,5
03C5  0AD6  	INCF CompTempVar2274, F
03C6  0856  	MOVF CompTempVar2274, W
03C7  0557  	ANDWF CompTempVar2275, W
03C8  1903  	BTFSC STATUS,Z
03C9  2BD9  	GOTO	label37
03D9        label37

	{

		//Call Component Macro
		//Call Component Macro: SendRS232String("E6B")
		FCD_RS2320_SendRS232String("E6B", 3);
03CA  3045  	MOVLW 0x45
03CB  00D8  	MOVWF CompTempVar2338
03CC  3036  	MOVLW 0x36
03CD  00D9  	MOVWF CompTempVar2338+D'1'
03CE  3042  	MOVLW 0x42
03CF  00DA  	MOVWF CompTempVar2338+D'2'
03D0  01DB  	CLRF CompTempVar2338+D'3'
03D1  3000  	MOVLW HIGH(CompTempVar2338+D'0')
03D2  00DD  	MOVWF FCD_RS2320_00052_arg_String+D'1'
03D3  3058  	MOVLW LOW(CompTempVar2338+D'0')
03D4  00DC  	MOVWF FCD_RS2320_00052_arg_String
03D5  3003  	MOVLW 0x03
03D6  00E2  	MOVWF FCD_RS2320_00052_arg_MSZ_String
03D7  20F5  	CALL FCD_RS2320_00052


	} else {

		//Decision
		//Decision: eq6_se1 = 1 AND eq6_se2 = 0?
		if (FCV_EQ6_SE1 == 1 & FCV_EQ6_SE2 == 0)
03D9  01D9  	CLRF CompTempVar2341
03DA  19C5  	BTFSC gbl_FCV_EQ6_SE1,3
03DB  0AD9  	INCF CompTempVar2341, F
03DC  01D8  	CLRF CompTempVar2340
03DD  1EC5  	BTFSS gbl_FCV_EQ6_SE2,5
03DE  0AD8  	INCF CompTempVar2340, F
03DF  0858  	MOVF CompTempVar2340, W
03E0  0559  	ANDWF CompTempVar2341, W
03E1  1903  	BTFSC STATUS,Z
03E2  2BF2  	GOTO	label38
03F2        label38

		{

			//Call Component Macro
			//Call Component Macro: SendRS232String("E6P")
			FCD_RS2320_SendRS232String("E6P", 3);
03E3  3045  	MOVLW 0x45
03E4  00DE  	MOVWF CompTempVar2342
03E5  3036  	MOVLW 0x36
03E6  00DF  	MOVWF CompTempVar2342+D'1'
03E7  3050  	MOVLW 0x50
03E8  00E0  	MOVWF CompTempVar2342+D'2'
03E9  01E1  	CLRF CompTempVar2342+D'3'
03EA  3000  	MOVLW HIGH(CompTempVar2342+D'0')
03EB  00DD  	MOVWF FCD_RS2320_00052_arg_String+D'1'
03EC  305E  	MOVLW LOW(CompTempVar2342+D'0')
03ED  00DC  	MOVWF FCD_RS2320_00052_arg_String
03EE  3003  	MOVLW 0x03
03EF  00E2  	MOVWF FCD_RS2320_00052_arg_MSZ_String
03F0  20F5  	CALL FCD_RS2320_00052


		} else {

			//Decision
			//Decision: eq6_se1 = 0 AND eq6_se2 = 1?
			if (FCV_EQ6_SE1 == 0 & FCV_EQ6_SE2 == 1)
03F2  01DB  	CLRF CompTempVar2345
03F3  1DC5  	BTFSS gbl_FCV_EQ6_SE1,3
03F4  0ADB  	INCF CompTempVar2345, F
03F5  01DA  	CLRF CompTempVar2344
03F6  1AC5  	BTFSC gbl_FCV_EQ6_SE2,5
03F7  0ADA  	INCF CompTempVar2344, F
03F8  085A  	MOVF CompTempVar2344, W
03F9  055B  	ANDWF CompTempVar2345, W
03FA  1903  	BTFSC STATUS,Z

			{

				//Call Component Macro
				//Call Component Macro: SendRS232String("E6R")
				FCD_RS2320_SendRS232String("E6R", 3);
03FC  3045  	MOVLW 0x45
03FD  00DE  	MOVWF CompTempVar2346
03FE  3036  	MOVLW 0x36
03FF  00DF  	MOVWF CompTempVar2346+D'1'
0400  3052  	MOVLW 0x52
0401  00E0  	MOVWF CompTempVar2346+D'2'
0402  01E1  	CLRF CompTempVar2346+D'3'
0403  3000  	MOVLW HIGH(CompTempVar2346+D'0')
0404  00DD  	MOVWF FCD_RS2320_00052_arg_String+D'1'
0405  305E  	MOVLW LOW(CompTempVar2346+D'0')
0406  00DC  	MOVWF FCD_RS2320_00052_arg_String
0407  3003  	MOVLW 0x03
0408  00E2  	MOVWF FCD_RS2320_00052_arg_MSZ_String
0409  20F5  	CALL FCD_RS2320_00052


			// } else {

			}

		}

	}

}
03D8  0008  	RETURN
03F1  0008  	RETURN
03FB  0008  	RETURN
040A  0008  	RETURN



void FCM_Equipment4()

{

	//Decision
	//Decision: eq4_se1 = 0 AND eq4_se2 = 0 AND eq4_flag = 0?
	if (FCV_EQ4_SE1 == 0 & FCV_EQ4_SE2 == 0 & FCV_EQ4_FLAG == 0)
040B  1283  	BCF STATUS, RP0
040C  1303  	BCF STATUS, RP1
040D  01CE  	CLRF CompTempVar2351
040E  1DC3  	BTFSS gbl_FCV_EQ4_SE1,3
040F  0ACE  	INCF CompTempVar2351, F
0410  01CC  	CLRF CompTempVar2348
0411  1EC3  	BTFSS gbl_FCV_EQ4_SE2,5
0412  0ACC  	INCF CompTempVar2348, F
0413  084C  	MOVF CompTempVar2348, W
0414  05CE  	ANDWF CompTempVar2351, F
0415  01CD  	CLRF CompTempVar2350
0416  1D43  	BTFSS gbl_FCV_EQ4_FLAG,2
0417  0ACD  	INCF CompTempVar2350, F
0418  084D  	MOVF CompTempVar2350, W
0419  054E  	ANDWF CompTempVar2351, W
041A  1903  	BTFSC STATUS,Z
041B  2C2F  	GOTO	label39
042F        label39

	{

		//Call Component Macro
		//Call Component Macro: SendRS232String("E4B")
		FCD_RS2320_SendRS232String("E4B", 3);
041C  3045  	MOVLW 0x45
041D  00CF  	MOVWF CompTempVar2352
041E  3034  	MOVLW 0x34
041F  00D0  	MOVWF CompTempVar2352+D'1'
0420  3042  	MOVLW 0x42
0421  00D1  	MOVWF CompTempVar2352+D'2'
0422  01D2  	CLRF CompTempVar2352+D'3'
0423  3000  	MOVLW HIGH(CompTempVar2352+D'0')
0424  00DD  	MOVWF FCD_RS2320_00052_arg_String+D'1'
0425  304F  	MOVLW LOW(CompTempVar2352+D'0')
0426  00DC  	MOVWF FCD_RS2320_00052_arg_String
0427  3003  	MOVLW 0x03
0428  00E2  	MOVWF FCD_RS2320_00052_arg_MSZ_String
0429  20F5  	CALL FCD_RS2320_00052


		//Delay
		//Delay: 200 ms
		delay_ms(200);
042A  30C8  	MOVLW 0xC8
042B  00D4  	MOVWF delay_ms_00000_arg_del
042C  2015  	CALL delay_ms_00000


		//Calculation
		//Calculation:
		//  eq4_flag = 1
		FCV_EQ4_FLAG = 1;
042D  1543  	BSF gbl_FCV_EQ4_FLAG,2


	} else {

		//Decision
		//Decision: eq4_se1 = 1 AND eq4_se2 = 0 AND eq4_flag = 1?
		if (FCV_EQ4_SE1 == 1 & FCV_EQ4_SE2 == 0 & FCV_EQ4_FLAG == 1)
042F  01D1  	CLRF CompTempVar2357
0430  19C3  	BTFSC gbl_FCV_EQ4_SE1,3
0431  0AD1  	INCF CompTempVar2357, F
0432  01CF  	CLRF CompTempVar2354
0433  1EC3  	BTFSS gbl_FCV_EQ4_SE2,5
0434  0ACF  	INCF CompTempVar2354, F
0435  084F  	MOVF CompTempVar2354, W
0436  05D1  	ANDWF CompTempVar2357, F
0437  01D0  	CLRF CompTempVar2356
0438  1943  	BTFSC gbl_FCV_EQ4_FLAG,2
0439  0AD0  	INCF CompTempVar2356, F
043A  0850  	MOVF CompTempVar2356, W
043B  0551  	ANDWF CompTempVar2357, W
043C  1903  	BTFSC STATUS,Z
043D  2C54  	GOTO	label40
0454        label40

		{

			//Call Component Macro
			//Call Component Macro: SendRS232String("E4P")
			FCD_RS2320_SendRS232String("E4P", 3);
043E  3045  	MOVLW 0x45
043F  00D6  	MOVWF CompTempVar2358
0440  3034  	MOVLW 0x34
0441  00D7  	MOVWF CompTempVar2358+D'1'
0442  3050  	MOVLW 0x50
0443  00D8  	MOVWF CompTempVar2358+D'2'
0444  01D9  	CLRF CompTempVar2358+D'3'
0445  3000  	MOVLW HIGH(CompTempVar2358+D'0')
0446  00DD  	MOVWF FCD_RS2320_00052_arg_String+D'1'
0447  3056  	MOVLW LOW(CompTempVar2358+D'0')
0448  00DC  	MOVWF FCD_RS2320_00052_arg_String
0449  3003  	MOVLW 0x03
044A  00E2  	MOVWF FCD_RS2320_00052_arg_MSZ_String
044B  20F5  	CALL FCD_RS2320_00052


			//Delay
			//Delay: 500 ms
			delay_ms(255);
044C  30FF  	MOVLW 0xFF
044D  00D4  	MOVWF delay_ms_00000_arg_del
044E  2015  	CALL delay_ms_00000

			delay_ms(245);
044F  30F5  	MOVLW 0xF5
0450  00D4  	MOVWF delay_ms_00000_arg_del
0451  2015  	CALL delay_ms_00000


			//Calculation
			//Calculation:
			//  eq4_flag = 0
			FCV_EQ4_FLAG = 0;
0452  1143  	BCF gbl_FCV_EQ4_FLAG,2


		} else {

			//Decision
			//Decision: eq4_se1 = 0 AND eq4_se2 = 1?
			if (FCV_EQ4_SE1 == 0 & FCV_EQ4_SE2 == 1)
0454  01D3  	CLRF CompTempVar2361
0455  1DC3  	BTFSS gbl_FCV_EQ4_SE1,3
0456  0AD3  	INCF CompTempVar2361, F
0457  01D2  	CLRF CompTempVar2360
0458  1AC3  	BTFSC gbl_FCV_EQ4_SE2,5
0459  0AD2  	INCF CompTempVar2360, F
045A  0852  	MOVF CompTempVar2360, W
045B  0553  	ANDWF CompTempVar2361, W
045C  1903  	BTFSC STATUS,Z

			{

				//Calculation
				//Calculation:
				//  eq4_errorflag = 0
				FCV_EQ4_ERRORFLAG = 0;
045E  13C5  	BCF gbl_FCV_EQ4_ERRORFLAG,7


				//Loop
				//Loop: While eq4_se2 = 1
				while (FCV_EQ4_SE2 == 1)
045F        label41
045F  1EC3  	BTFSS gbl_FCV_EQ4_SE2,5
0460  2C95  	GOTO	label43
0494  2C5F  	GOTO	label41
0495        label43

				{

					//Input
					//Input: E1 -> eq4_se2
					trise = trise | 0x02;
0461  3002  	MOVLW 0x02
0462  1683  	BSF STATUS, RP0
0463  0409  	IORWF gbl_trise, W
0464  0089  	MOVWF gbl_trise

					FCV_EQ4_SE2 = ((porte & 0x02) == 0x02);
0465  3002  	MOVLW 0x02
0466  1283  	BCF STATUS, RP0
0467  0509  	ANDWF gbl_porte, W
0468  00D4  	MOVWF CompTempVar2362
0469  01D5  	CLRF CompTempVar2363
046A  3002  	MOVLW 0x02
046B  0254  	SUBWF CompTempVar2362, W
046C  1903  	BTFSC STATUS,Z
046D  0AD5  	INCF CompTempVar2363, F
046E  12C3  	BCF gbl_FCV_EQ4_SE2,5
046F  0855  	MOVF CompTempVar2363, W
0470  1D03  	BTFSS STATUS,Z
0471  16C3  	BSF gbl_FCV_EQ4_SE2,5


					//Decision
					//Decision: eq4_errorflag = 0?
					if (FCV_EQ4_ERRORFLAG == 0)
0472  1BC5  	BTFSC gbl_FCV_EQ4_ERRORFLAG,7
0473  2C89  	GOTO	label42
0489        label42

					{

						//Call Component Macro
						//Call Component Macro: SendRS232String("E4R")
						FCD_RS2320_SendRS232String("E4R", 3);
0474  3045  	MOVLW 0x45
0475  00D6  	MOVWF CompTempVar2364
0476  3034  	MOVLW 0x34
0477  00D7  	MOVWF CompTempVar2364+D'1'
0478  3052  	MOVLW 0x52
0479  00D8  	MOVWF CompTempVar2364+D'2'
047A  01D9  	CLRF CompTempVar2364+D'3'
047B  3000  	MOVLW HIGH(CompTempVar2364+D'0')
047C  00DD  	MOVWF FCD_RS2320_00052_arg_String+D'1'
047D  3056  	MOVLW LOW(CompTempVar2364+D'0')
047E  00DC  	MOVWF FCD_RS2320_00052_arg_String
047F  3003  	MOVLW 0x03
0480  00E2  	MOVWF FCD_RS2320_00052_arg_MSZ_String
0481  20F5  	CALL FCD_RS2320_00052


						//Delay
						//Delay: 500 ms
						delay_ms(255);
0482  30FF  	MOVLW 0xFF
0483  00D4  	MOVWF delay_ms_00000_arg_del
0484  2015  	CALL delay_ms_00000

						delay_ms(245);
0485  30F5  	MOVLW 0xF5
0486  00D4  	MOVWF delay_ms_00000_arg_del
0487  2015  	CALL delay_ms_00000


						//Calculation
						//Calculation:
						//  eq4_errorflag = 1
						FCV_EQ4_ERRORFLAG = 1;
0488  17C5  	BSF gbl_FCV_EQ4_ERRORFLAG,7


					// } else {

					}

					//Call Component Macro
					//Call Component Macro: SetDutyCycle(76)
					FCD_PWM0_SetDutyCycle(76);
0489  304C  	MOVLW 0x4C
048A  00D4  	MOVWF FCD_PWM0_S_00053_arg_nDuty
048B  210F  	CALL FCD_PWM0_S_00053


					//Delay
					//Delay: 100 ms
					delay_ms(100);
048C  3064  	MOVLW 0x64
048D  00D4  	MOVWF delay_ms_00000_arg_del
048E  2015  	CALL delay_ms_00000


					//Call Component Macro
					//Call Component Macro: SetDutyCycle(0)
					FCD_PWM0_SetDutyCycle(0);
048F  01D4  	CLRF FCD_PWM0_S_00053_arg_nDuty
0490  210F  	CALL FCD_PWM0_S_00053


					//Delay
					//Delay: 100 ms
					delay_ms(100);
0491  3064  	MOVLW 0x64
0492  00D4  	MOVWF delay_ms_00000_arg_del
0493  2015  	CALL delay_ms_00000



				}

				//Calculation
				//Calculation:
				//  eq4_flag = 0
				FCV_EQ4_FLAG = 0;
0495  1143  	BCF gbl_FCV_EQ4_FLAG,2


			// } else {

			}

		}

	}

}
042E  0008  	RETURN
0453  0008  	RETURN
045D  0008  	RETURN
0496  0008  	RETURN



void FCM_Equipment5()
{

	//Decision
	//Decision: eq5_se1 = 0 AND eq5_se2 = 0 AND eq5_flag = 0?
	if (FCV_EQ5_SE1 == 0 & FCV_EQ5_SE2 == 0 & FCV_EQ5_FLAG == 0)
	{

		//Call Component Macro
		//Call Component Macro: SendRS232String("E5B")
		FCD_RS2320_SendRS232String("E5B", 3);

		//Delay
		//Delay: 200 ms
		delay_ms(200);

		//Calculation
		//Calculation:
		//  eq5_flag = 1
		FCV_EQ5_FLAG = 1;

	} else {

		//Decision
		//Decision: eq5_se1 = 1 AND eq5_se2 = 0 AND eq5_flag = 1?
		if (FCV_EQ5_SE1 == 1 & FCV_EQ5_SE2 == 0 & FCV_EQ5_FLAG == 1)
		{

			//Call Component Macro
			//Call Component Macro: SendRS232String("E5P")
			FCD_RS2320_SendRS232String("E5P", 3);

			//Delay
			//Delay: 500 ms
			delay_ms(255);
			delay_ms(245);

			//Calculation
			//Calculation:
			//  eq5_flag = 0
			FCV_EQ5_FLAG = 0;

		} else {

			//Decision
			//Decision: eq5_se1 = 0 AND eq5_se2 = 1?
			if (FCV_EQ5_SE1 == 0 & FCV_EQ5_SE2 == 1)
			{

				//Calculation
				//Calculation:
				//  eq5_errorflag = 0
				FCV_EQ5_ERRORFLAG = 0;

				//Loop
				//Loop: While eq5_se2 = 1
				while (FCV_EQ5_SE2 == 1)
				{

					//Input
					//Input: D3 -> eq5_se2
					trisd = trisd | 0x08;
					FCV_EQ5_SE2 = ((portd & 0x08) == 0x08);

					//Decision
					//Decision: eq5_errorflag = 0?
					if (FCV_EQ5_ERRORFLAG == 0)
					{

						//Call Component Macro
						//Call Component Macro: SendRS232String("E5R")
						FCD_RS2320_SendRS232String("E5R", 3);

						//Delay
						//Delay: 500 ms
						delay_ms(255);
						delay_ms(245);

						//Calculation
						//Calculation:
						//  eq5_errorflag = 1
						FCV_EQ5_ERRORFLAG = 1;

					// } else {

					}

					//Call Component Macro
					//Call Component Macro: SetDutyCycle(76)
					FCD_PWM0_SetDutyCycle(76);

					//Delay
					//Delay: 100 ms
					delay_ms(100);

					//Call Component Macro
					//Call Component Macro: SetDutyCycle(0)
					FCD_PWM0_SetDutyCycle(0);

					//Delay
					//Delay: 100 ms
					delay_ms(100);


				}

				//Calculation
				//Calculation:
				//  eq5_flag = 0
				FCV_EQ5_FLAG = 0;

			// } else {

			}

		}

	}

}


void FCM_Equipment6()
{

	//Decision
	//Decision: eq6_se1 = 0 AND eq6_se2 = 0 AND eq6_flag = 0?
	if (FCV_EQ6_SE1 == 0 & FCV_EQ6_SE2 == 0 & FCV_EQ6_FLAG == 0)
	{

		//Call Component Macro
		//Call Component Macro: SendRS232String("E6B")
		FCD_RS2320_SendRS232String("E6B", 3);

		//Delay
		//Delay: 200 ms
		delay_ms(200);

		//Calculation
		//Calculation:
		//  eq6_flag = 1
		FCV_EQ6_FLAG = 1;

	} else {

		//Decision
		//Decision: eq6_se1 = 1 AND eq6_se2 = 0 AND eq6_flag = 1?
		if (FCV_EQ6_SE1 == 1 & FCV_EQ6_SE2 == 0 & FCV_EQ6_FLAG == 1)
		{

			//Call Component Macro
			//Call Component Macro: SendRS232String("E6P")
			FCD_RS2320_SendRS232String("E6P", 3);

			//Delay
			//Delay: 500 ms
			delay_ms(255);
			delay_ms(245);

			//Calculation
			//Calculation:
			//  eq6_flag = 0
			FCV_EQ6_FLAG = 0;

		} else {

			//Decision
			//Decision: eq6_se1 = 0 AND eq6_se2 = 1?
			if (FCV_EQ6_SE1 == 0 & FCV_EQ6_SE2 == 1)
			{

				//Calculation
				//Calculation:
				//  eq6_errorflag = 0
				FCV_EQ6_ERRORFLAG = 0;

				//Loop
				//Loop: While eq6_se2 = 1
				while (FCV_EQ6_SE2 == 1)
				{

					//Input
					//Input: D1 -> eq6_se2
					trisd = trisd | 0x02;
					FCV_EQ6_SE2 = ((portd & 0x02) == 0x02);

					//Decision
					//Decision: eq6_errorflag = 0?
					if (FCV_EQ6_ERRORFLAG == 0)
					{

						//Call Component Macro
						//Call Component Macro: SendRS232String("E6R")
						FCD_RS2320_SendRS232String("E6R", 3);

						//Delay
						//Delay: 500 ms
						delay_ms(255);
						delay_ms(245);

						//Calculation
						//Calculation:
						//  eq6_errorflag = 1
						FCV_EQ6_ERRORFLAG = 1;

					// } else {

					}

					//Call Component Macro
					//Call Component Macro: SetDutyCycle(76)
					FCD_PWM0_SetDutyCycle(76);

					//Delay
					//Delay: 100 ms
					delay_ms(100);

					//Call Component Macro
					//Call Component Macro: SetDutyCycle(0)
					FCD_PWM0_SetDutyCycle(0);

					//Delay
					//Delay: 100 ms
					delay_ms(100);


				}

				//Calculation
				//Calculation:
				//  eq6_flag = 0
				FCV_EQ6_FLAG = 0;

			// } else {

			}

		}

	}

}



void main()

{
	//Initialization
	ansel = 0;
07CE  1683  	BSF STATUS, RP0
07CF  1703  	BSF STATUS, RP1
07D0  0188  	CLRF gbl_ansel

anselh = 0;
07D1  0189  	CLRF gbl_anselh


	
		RS232_2_UART_Init( );		//Call initialise function
07D2  2154  	CALL FC_CAL_UAR_00065



	//Interrupt initialization code
	option_reg = 0xC0;
07D3  30C0  	MOVLW 0xC0
07D4  0081  	MOVWF gbl_option_reg



	//Calculation
	//Calculation:
	//  siren_flag = 0
	//  fbit = 0
	FCV_SIREN_FLAG = 0;
07D5  1283  	BCF STATUS, RP0
07D6  10C5  	BCF gbl_FCV_SIREN_FLAG,1

	FCV_FBIT = 0;
07D7  01C6  	CLRF gbl_FCV_FBIT


	//Call Component Macro
	//Call Component Macro: Start()
	FCD_LCDDisplay0_Start();
07D8  2779  	CALL FCD_LCDDis_0005A


	//Call Component Macro
	//Call Component Macro: Clear()
	FCD_LCDDisplay0_Clear();
07D9  2768  	CALL FCD_LCDDis_0005B


	//Call Component Macro
	//Call Component Macro: Cursor(0, 0)
	FCD_LCDDisplay0_Cursor(0, 0);
07DA  01CC  	CLRF FCD_LCDDis_0005E_arg_x
07DB  01CD  	CLRF FCD_LCDDis_0005E_arg_y
07DC  2757  	CALL FCD_LCDDis_0005E


	//Call Component Macro
	//Call Component Macro: PrintString("Kenny Neutron's")
	FCD_LCDDisplay0_PrintString("Kenny Neutron's", 15);
07DD  3020  	MOVLW 0x20
07DE  00CF  	MOVWF CompTempVar2446+D'5'
07DF  3027  	MOVLW 0x27
07E0  00D7  	MOVWF CompTempVar2446+D'13'
07E1  304B  	MOVLW 0x4B
07E2  00CA  	MOVWF CompTempVar2446
07E3  304E  	MOVLW 0x4E
07E4  00D0  	MOVWF CompTempVar2446+D'6'
07E5  3065  	MOVLW 0x65
07E6  00CB  	MOVWF CompTempVar2446+D'1'
07E7  00D1  	MOVWF CompTempVar2446+D'7'
07E8  306E  	MOVLW 0x6E
07E9  00CC  	MOVWF CompTempVar2446+D'2'
07EA  00CD  	MOVWF CompTempVar2446+D'3'
07EB  00D6  	MOVWF CompTempVar2446+D'12'
07EC  306F  	MOVLW 0x6F
07ED  00D5  	MOVWF CompTempVar2446+D'11'
07EE  3072  	MOVLW 0x72
07EF  00D4  	MOVWF CompTempVar2446+D'10'
07F0  3073  	MOVLW 0x73
07F1  00D8  	MOVWF CompTempVar2446+D'14'
07F2  3074  	MOVLW 0x74
07F3  00D3  	MOVWF CompTempVar2446+D'9'
07F4  3075  	MOVLW 0x75
07F5  00D2  	MOVWF CompTempVar2446+D'8'
07F6  3079  	MOVLW 0x79
07F7  00CE  	MOVWF CompTempVar2446+D'4'
07F8  01D9  	CLRF CompTempVar2446+D'15'
07F9  3000  	MOVLW HIGH(CompTempVar2446+D'0')
07FA  00C9  	MOVWF FCD_LCDDis_00060_arg_String+D'1'
07FB  304A  	MOVLW LOW(CompTempVar2446+D'0')
07FC  00C8  	MOVWF FCD_LCDDis_00060_arg_String
07FD  300F  	MOVLW 0x0F
07FE  00DA  	MOVWF FCD_LCDDis_00060_arg_MSZ_String
07FF  264D  	CALL FCD_LCDDis_00060


	//Call Component Macro
	//Call Component Macro: Cursor(0, 1)
	FCD_LCDDisplay0_Cursor(0, 1);
0800  01CC  	CLRF FCD_LCDDis_0005E_arg_x
0801  3001  	MOVLW 0x01
0802  00CD  	MOVWF FCD_LCDDis_0005E_arg_y
0803  2757  	CALL FCD_LCDDis_0005E


	//Call Component Macro
	//Call Component Macro: PrintString("Innovations")
	FCD_LCDDisplay0_PrintString("Innovations", 11);
0804  3049  	MOVLW 0x49
0805  00CA  	MOVWF CompTempVar2448
0806  3061  	MOVLW 0x61
0807  00CF  	MOVWF CompTempVar2448+D'5'
0808  3069  	MOVLW 0x69
0809  00D1  	MOVWF CompTempVar2448+D'7'
080A  306E  	MOVLW 0x6E
080B  00CB  	MOVWF CompTempVar2448+D'1'
080C  00CC  	MOVWF CompTempVar2448+D'2'
080D  00D3  	MOVWF CompTempVar2448+D'9'
080E  306F  	MOVLW 0x6F
080F  00CD  	MOVWF CompTempVar2448+D'3'
0810  00D2  	MOVWF CompTempVar2448+D'8'
0811  3073  	MOVLW 0x73
0812  00D4  	MOVWF CompTempVar2448+D'10'
0813  3074  	MOVLW 0x74
0814  00D0  	MOVWF CompTempVar2448+D'6'
0815  3076  	MOVLW 0x76
0816  00CE  	MOVWF CompTempVar2448+D'4'
0817  01D5  	CLRF CompTempVar2448+D'11'
0818  3000  	MOVLW HIGH(CompTempVar2448+D'0')
0819  00C9  	MOVWF FCD_LCDDis_00060_arg_String+D'1'
081A  304A  	MOVLW LOW(CompTempVar2448+D'0')
081B  00C8  	MOVWF FCD_LCDDis_00060_arg_String
081C  300B  	MOVLW 0x0B
081D  00DA  	MOVWF FCD_LCDDis_00060_arg_MSZ_String
081E  264D  	CALL FCD_LCDDis_00060


	//Call Component Macro
	//Call Component Macro: Enable()
	FCD_PWM0_Enable();
081F  2643  	CALL FCD_PWM0_E_00074


	//Call Macro
	//Call Macro: init()
	FCM_init();
0820  2163  	CALL FCM_init_00000


	//Calculation
	//Calculation:
	//  siren = 0
	FCV_SIREN = 0;
0821  11C7  	BCF gbl_FCV_SIREN,3


	//Loop
	//Loop: While 1
	while (1)
0822        label83
0962  158A  	BSF PCLATH,3
0963  2822  	GOTO	label83

	{

		//Input
		//Input: A0 -> eq1_se1
		trisa = trisa | 0x01;
0822  3001  	MOVLW 0x01
0823  1683  	BSF STATUS, RP0
0824  0405  	IORWF gbl_trisa, W
0825  0085  	MOVWF gbl_trisa

		FCV_EQ1_SE1 = ((porta & 0x01) == 0x01);
0826  3001  	MOVLW 0x01
0827  1283  	BCF STATUS, RP0
0828  0505  	ANDWF gbl_porta, W
0829  00CC  	MOVWF CompTempVar2454
082A  01CD  	CLRF CompTempVar2455
082B  034C  	DECF CompTempVar2454, W
082C  1903  	BTFSC STATUS,Z
082D  0ACD  	INCF CompTempVar2455, F
082E  1042  	BCF gbl_FCV_EQ1_SE1,0
082F  084D  	MOVF CompTempVar2455, W
0830  1D03  	BTFSS STATUS,Z
0831  1442  	BSF gbl_FCV_EQ1_SE1,0


		//Input
		//Input: A1 -> eq1_se2
		trisa = trisa | 0x02;
0832  3002  	MOVLW 0x02
0833  1683  	BSF STATUS, RP0
0834  0405  	IORWF gbl_trisa, W
0835  0085  	MOVWF gbl_trisa

		FCV_EQ1_SE2 = ((porta & 0x02) == 0x02);
0836  3002  	MOVLW 0x02
0837  1283  	BCF STATUS, RP0
0838  0505  	ANDWF gbl_porta, W
0839  00CC  	MOVWF CompTempVar2456
083A  01CD  	CLRF CompTempVar2457
083B  3002  	MOVLW 0x02
083C  024C  	SUBWF CompTempVar2456, W
083D  1903  	BTFSC STATUS,Z
083E  0ACD  	INCF CompTempVar2457, F
083F  1142  	BCF gbl_FCV_EQ1_SE2,2
0840  084D  	MOVF CompTempVar2457, W
0841  1D03  	BTFSS STATUS,Z
0842  1542  	BSF gbl_FCV_EQ1_SE2,2


		//Input
		//Input: A2 -> eq2_se1
		trisa = trisa | 0x04;
0843  3004  	MOVLW 0x04
0844  1683  	BSF STATUS, RP0
0845  0405  	IORWF gbl_trisa, W
0846  0085  	MOVWF gbl_trisa

		FCV_EQ2_SE1 = ((porta & 0x04) == 0x04);
0847  3004  	MOVLW 0x04
0848  1283  	BCF STATUS, RP0
0849  0505  	ANDWF gbl_porta, W
084A  00CC  	MOVWF CompTempVar2458
084B  01CD  	CLRF CompTempVar2459
084C  3004  	MOVLW 0x04
084D  024C  	SUBWF CompTempVar2458, W
084E  1903  	BTFSC STATUS,Z
084F  0ACD  	INCF CompTempVar2459, F
0850  10C2  	BCF gbl_FCV_EQ2_SE1,1
0851  084D  	MOVF CompTempVar2459, W
0852  1D03  	BTFSS STATUS,Z
0853  14C2  	BSF gbl_FCV_EQ2_SE1,1


		//Input
		//Input: A3 -> eq2_se2
		trisa = trisa | 0x08;
0854  3008  	MOVLW 0x08
0855  1683  	BSF STATUS, RP0
0856  0405  	IORWF gbl_trisa, W
0857  0085  	MOVWF gbl_trisa

		FCV_EQ2_SE2 = ((porta & 0x08) == 0x08);
0858  3008  	MOVLW 0x08
0859  1283  	BCF STATUS, RP0
085A  0505  	ANDWF gbl_porta, W
085B  00CC  	MOVWF CompTempVar2460
085C  01CD  	CLRF CompTempVar2461
085D  3008  	MOVLW 0x08
085E  024C  	SUBWF CompTempVar2460, W
085F  1903  	BTFSC STATUS,Z
0860  0ACD  	INCF CompTempVar2461, F
0861  1342  	BCF gbl_FCV_EQ2_SE2,6
0862  084D  	MOVF CompTempVar2461, W
0863  1D03  	BTFSS STATUS,Z
0864  1742  	BSF gbl_FCV_EQ2_SE2,6


		//Input
		//Input: A4 -> eq3_se1
		trisa = trisa | 0x10;
0865  3010  	MOVLW 0x10
0866  1683  	BSF STATUS, RP0
0867  0405  	IORWF gbl_trisa, W
0868  0085  	MOVWF gbl_trisa

		FCV_EQ3_SE1 = ((porta & 0x10) == 0x10);
0869  3010  	MOVLW 0x10
086A  1283  	BCF STATUS, RP0
086B  0505  	ANDWF gbl_porta, W
086C  00CC  	MOVWF CompTempVar2462
086D  01CD  	CLRF CompTempVar2463
086E  3010  	MOVLW 0x10
086F  024C  	SUBWF CompTempVar2462, W
0870  1903  	BTFSC STATUS,Z
0871  0ACD  	INCF CompTempVar2463, F
0872  12C2  	BCF gbl_FCV_EQ3_SE1,5
0873  084D  	MOVF CompTempVar2463, W
0874  1D03  	BTFSS STATUS,Z
0875  16C2  	BSF gbl_FCV_EQ3_SE1,5


		//Input
		//Input: A5 -> eq3_se2
		trisa = trisa | 0x20;
0876  3020  	MOVLW 0x20
0877  1683  	BSF STATUS, RP0
0878  0405  	IORWF gbl_trisa, W
0879  0085  	MOVWF gbl_trisa

		FCV_EQ3_SE2 = ((porta & 0x20) == 0x20);
087A  3020  	MOVLW 0x20
087B  1283  	BCF STATUS, RP0
087C  0505  	ANDWF gbl_porta, W
087D  00CC  	MOVWF CompTempVar2464
087E  01CD  	CLRF CompTempVar2465
087F  3020  	MOVLW 0x20
0880  024C  	SUBWF CompTempVar2464, W
0881  1903  	BTFSC STATUS,Z
0882  0ACD  	INCF CompTempVar2465, F
0883  10C3  	BCF gbl_FCV_EQ3_SE2,1
0884  084D  	MOVF CompTempVar2465, W
0885  1D03  	BTFSS STATUS,Z
0886  14C3  	BSF gbl_FCV_EQ3_SE2,1


		//Input
		//Input: E0 -> eq4_se1
		trise = trise | 0x01;
0887  3001  	MOVLW 0x01
0888  1683  	BSF STATUS, RP0
0889  0409  	IORWF gbl_trise, W
088A  0089  	MOVWF gbl_trise

		FCV_EQ4_SE1 = ((porte & 0x01) == 0x01);
088B  3001  	MOVLW 0x01
088C  1283  	BCF STATUS, RP0
088D  0509  	ANDWF gbl_porte, W
088E  00CC  	MOVWF CompTempVar2466
088F  01CD  	CLRF CompTempVar2467
0890  034C  	DECF CompTempVar2466, W
0891  1903  	BTFSC STATUS,Z
0892  0ACD  	INCF CompTempVar2467, F
0893  11C3  	BCF gbl_FCV_EQ4_SE1,3
0894  084D  	MOVF CompTempVar2467, W
0895  1D03  	BTFSS STATUS,Z
0896  15C3  	BSF gbl_FCV_EQ4_SE1,3


		//Input
		//Input: E1 -> eq4_se2
		trise = trise | 0x02;
0897  3002  	MOVLW 0x02
0898  1683  	BSF STATUS, RP0
0899  0409  	IORWF gbl_trise, W
089A  0089  	MOVWF gbl_trise

		FCV_EQ4_SE2 = ((porte & 0x02) == 0x02);
089B  3002  	MOVLW 0x02
089C  1283  	BCF STATUS, RP0
089D  0509  	ANDWF gbl_porte, W
089E  00CC  	MOVWF CompTempVar2468
089F  01CD  	CLRF CompTempVar2469
08A0  3002  	MOVLW 0x02
08A1  024C  	SUBWF CompTempVar2468, W
08A2  1903  	BTFSC STATUS,Z
08A3  0ACD  	INCF CompTempVar2469, F
08A4  12C3  	BCF gbl_FCV_EQ4_SE2,5
08A5  084D  	MOVF CompTempVar2469, W
08A6  1D03  	BTFSS STATUS,Z
08A7  16C3  	BSF gbl_FCV_EQ4_SE2,5


		//Input
		//Input: D2 -> eq5_se1
		trisd = trisd | 0x04;
08A8  3004  	MOVLW 0x04
08A9  1683  	BSF STATUS, RP0
08AA  0408  	IORWF gbl_trisd, W
08AB  0088  	MOVWF gbl_trisd

		FCV_EQ5_SE1 = ((portd & 0x04) == 0x04);
08AC  3004  	MOVLW 0x04
08AD  1283  	BCF STATUS, RP0
08AE  0508  	ANDWF gbl_portd, W
08AF  00CC  	MOVWF CompTempVar2470
08B0  01CD  	CLRF CompTempVar2471
08B1  3004  	MOVLW 0x04
08B2  024C  	SUBWF CompTempVar2470, W
08B3  1903  	BTFSC STATUS,Z
08B4  0ACD  	INCF CompTempVar2471, F
08B5  1343  	BCF gbl_FCV_EQ5_SE1,6
08B6  084D  	MOVF CompTempVar2471, W
08B7  1D03  	BTFSS STATUS,Z
08B8  1743  	BSF gbl_FCV_EQ5_SE1,6


		//Input
		//Input: D3 -> eq5_se2
		trisd = trisd | 0x08;
08B9  3008  	MOVLW 0x08
08BA  1683  	BSF STATUS, RP0
08BB  0408  	IORWF gbl_trisd, W
08BC  0088  	MOVWF gbl_trisd

		FCV_EQ5_SE2 = ((portd & 0x08) == 0x08);
08BD  3008  	MOVLW 0x08
08BE  1283  	BCF STATUS, RP0
08BF  0508  	ANDWF gbl_portd, W
08C0  00CC  	MOVWF CompTempVar2472
08C1  01CD  	CLRF CompTempVar2473
08C2  3008  	MOVLW 0x08
08C3  024C  	SUBWF CompTempVar2472, W
08C4  1903  	BTFSC STATUS,Z
08C5  0ACD  	INCF CompTempVar2473, F
08C6  1145  	BCF gbl_FCV_EQ5_SE2,2
08C7  084D  	MOVF CompTempVar2473, W
08C8  1D03  	BTFSS STATUS,Z
08C9  1545  	BSF gbl_FCV_EQ5_SE2,2


		//Input
		//Input: D0 -> eq6_se1
		trisd = trisd | 0x01;
08CA  3001  	MOVLW 0x01
08CB  1683  	BSF STATUS, RP0
08CC  0408  	IORWF gbl_trisd, W
08CD  0088  	MOVWF gbl_trisd

		FCV_EQ6_SE1 = ((portd & 0x01) == 0x01);
08CE  3001  	MOVLW 0x01
08CF  1283  	BCF STATUS, RP0
08D0  0508  	ANDWF gbl_portd, W
08D1  00CC  	MOVWF CompTempVar2474
08D2  01CD  	CLRF CompTempVar2475
08D3  034C  	DECF CompTempVar2474, W
08D4  1903  	BTFSC STATUS,Z
08D5  0ACD  	INCF CompTempVar2475, F
08D6  11C5  	BCF gbl_FCV_EQ6_SE1,3
08D7  084D  	MOVF CompTempVar2475, W
08D8  1D03  	BTFSS STATUS,Z
08D9  15C5  	BSF gbl_FCV_EQ6_SE1,3


		//Input
		//Input: D1 -> eq6_se2
		trisd = trisd | 0x02;
08DA  3002  	MOVLW 0x02
08DB  1683  	BSF STATUS, RP0
08DC  0408  	IORWF gbl_trisd, W
08DD  0088  	MOVWF gbl_trisd

		FCV_EQ6_SE2 = ((portd & 0x02) == 0x02);
08DE  3002  	MOVLW 0x02
08DF  1283  	BCF STATUS, RP0
08E0  0508  	ANDWF gbl_portd, W
08E1  00CC  	MOVWF CompTempVar2476
08E2  01CD  	CLRF CompTempVar2477
08E3  3002  	MOVLW 0x02
08E4  024C  	SUBWF CompTempVar2476, W
08E5  1903  	BTFSC STATUS,Z
08E6  0ACD  	INCF CompTempVar2477, F
08E7  12C5  	BCF gbl_FCV_EQ6_SE2,5
08E8  084D  	MOVF CompTempVar2477, W
08E9  1D03  	BTFSS STATUS,Z
08EA  16C5  	BSF gbl_FCV_EQ6_SE2,5


		//Input
		//Input: D7 -> doorlock
		trisd = trisd | 0x80;
08EB  3080  	MOVLW 0x80
08EC  1683  	BSF STATUS, RP0
08ED  0408  	IORWF gbl_trisd, W
08EE  0088  	MOVWF gbl_trisd

		FCV_DOORLOCK = ((portd & 0x80) == 0x80);
08EF  3080  	MOVLW 0x80
08F0  1283  	BCF STATUS, RP0
08F1  0508  	ANDWF gbl_portd, W
08F2  00CC  	MOVWF CompTempVar2478
08F3  01CD  	CLRF CompTempVar2479
08F4  3080  	MOVLW 0x80
08F5  024C  	SUBWF CompTempVar2478, W
08F6  1903  	BTFSC STATUS,Z
08F7  0ACD  	INCF CompTempVar2479, F
08F8  1045  	BCF gbl_FCV_DOORLOCK,0
08F9  084D  	MOVF CompTempVar2479, W
08FA  1D03  	BTFSS STATUS,Z
08FB  1445  	BSF gbl_FCV_DOORLOCK,0


		//Call Macro
		//Call Macro: Equipment1()
		FCM_Equipment1();
08FC  118A  	BCF PCLATH,3
08FD  25AF  	CALL FCM_Equipm_00051


		//Call Macro
		//Call Macro: Equipment2()
		FCM_Equipment2();
08FE  2523  	CALL FCM_Equipm_00054


		//Call Macro
		//Call Macro: Equipment3()
		FCM_Equipment3();
08FF  2497  	CALL FCM_Equipm_00055


		//Call Macro
		//Call Macro: Equipment4()
		FCM_Equipment4();
0900  240B  	CALL FCM_Equipm_00056


		//Call Component Macro
		//Call Component Macro: rx=ReceiveRS232Char(100)
		FCV_RX = FCD_RS2320_ReceiveRS232Char(100);
0901  3064  	MOVLW 0x64
0902  00CC  	MOVWF FCD_RS2320_0006B_arg_nTimeout
0903  263B  	CALL FCD_RS2320_0006B
0904  084D  	MOVF CompTempVarRet2432, W
0905  00C4  	MOVWF gbl_FCV_RX


		//Decision
		//Decision: rx = 'C'?
		if (FCV_RX == 'C')
0906  0844  	MOVF gbl_FCV_RX, W
0907  3A43  	XORLW 0x43
0908  1903  	BTFSC STATUS,Z

		{

			//Call Macro
			//Call Macro: check()
			FCM_check();
0909  21E8  	CALL FCM_check_00000


		// } else {

		}

		//Decision
		//Decision: rx = 'D'?
		if (FCV_RX == 'D')
090A  0844  	MOVF gbl_FCV_RX, W
090B  3A44  	XORLW 0x44
090C  1903  	BTFSC STATUS,Z

		{

			//Calculation
			//Calculation:
			//  siren_flag = 0
			FCV_SIREN_FLAG = 0;
090D  10C5  	BCF gbl_FCV_SIREN_FLAG,1


		// } else {

		}

		//Decision
		//Decision: rx = 'E'?
		if (FCV_RX == 'E')
090E  0844  	MOVF gbl_FCV_RX, W
090F  3A45  	XORLW 0x45
0910  1903  	BTFSC STATUS,Z

		{

			//Calculation
			//Calculation:
			//  siren_flag = 1
			FCV_SIREN_FLAG = 1;
0911  14C5  	BSF gbl_FCV_SIREN_FLAG,1


		// } else {

		}

		//Decision
		//Decision: doorlock = 1?
		if (FCV_DOORLOCK == 1)
0912  158A  	BSF PCLATH,3
0913  1C45  	BTFSS gbl_FCV_DOORLOCK,0
0914  291D  	GOTO	label84
091D        label84

		{

			//Output
			//Output: 0 -> D6
			trisd = trisd & 0xBF;
0915  30BF  	MOVLW 0xBF
0916  1683  	BSF STATUS, RP0
0917  0508  	ANDWF gbl_trisd, W
0918  0088  	MOVWF gbl_trisd

			if ((0))
				portd = (portd & 0xBF) | 0x40;
			else
				portd = portd & 0xBF;
0919  30BF  	MOVLW 0xBF
091A  1283  	BCF STATUS, RP0
091B  0508  	ANDWF gbl_portd, W
091C  0088  	MOVWF gbl_portd


		// } else {

		}

		//Decision
		//Decision: doorlock = 0 AND siren_flag = 1?
		if (FCV_DOORLOCK == 0 & FCV_SIREN_FLAG == 1)
091D  01C9  	CLRF CompTempVar2451
091E  1C45  	BTFSS gbl_FCV_DOORLOCK,0
091F  0AC9  	INCF CompTempVar2451, F
0920  01C8  	CLRF CompTempVar2450
0921  18C5  	BTFSC gbl_FCV_SIREN_FLAG,1
0922  0AC8  	INCF CompTempVar2450, F
0923  0848  	MOVF CompTempVar2450, W
0924  0549  	ANDWF CompTempVar2451, W
0925  1903  	BTFSC STATUS,Z
0926  292F  	GOTO	label85
092F        label85

		{

			//Output
			//Output: 0 -> D6
			trisd = trisd & 0xBF;
0927  30BF  	MOVLW 0xBF
0928  1683  	BSF STATUS, RP0
0929  0508  	ANDWF gbl_trisd, W
092A  0088  	MOVWF gbl_trisd

			if ((0))
				portd = (portd & 0xBF) | 0x40;
			else
				portd = portd & 0xBF;
092B  30BF  	MOVLW 0xBF
092C  1283  	BCF STATUS, RP0
092D  0508  	ANDWF gbl_portd, W
092E  0088  	MOVWF gbl_portd


		// } else {

		}

		//Decision
		//Decision: doorlock = 0 AND siren_flag = 0?
		if (FCV_DOORLOCK == 0 & FCV_SIREN_FLAG == 0)
092F  01CB  	CLRF CompTempVar2453
0930  1C45  	BTFSS gbl_FCV_DOORLOCK,0
0931  0ACB  	INCF CompTempVar2453, F
0932  01CA  	CLRF CompTempVar2452
0933  1CC5  	BTFSS gbl_FCV_SIREN_FLAG,1
0934  0ACA  	INCF CompTempVar2452, F
0935  084A  	MOVF CompTempVar2452, W
0936  054B  	ANDWF CompTempVar2453, W
0937  1903  	BTFSC STATUS,Z
0938  2956  	GOTO	label87
0956        label87

		{

			//Decision
			//Decision: fbit = 0?
			if (FCV_FBIT == 0)
0939  08C6  	MOVF gbl_FCV_FBIT, F
093A  1D03  	BTFSS STATUS,Z
093B  2949  	GOTO	label86
0949        label86

			{

				//Call Component Macro
				//Call Component Macro: SendRS232String("S")
				FCD_RS2320_SendRS232String("S", 1);
093C  3053  	MOVLW 0x53
093D  00CC  	MOVWF CompTempVar2480
093E  01CD  	CLRF CompTempVar2480+D'1'
093F  3000  	MOVLW HIGH(CompTempVar2480+D'0')
0940  00DD  	MOVWF FCD_RS2320_00052_arg_String+D'1'
0941  304C  	MOVLW LOW(CompTempVar2480+D'0')
0942  00DC  	MOVWF FCD_RS2320_00052_arg_String
0943  3001  	MOVLW 0x01
0944  00E2  	MOVWF FCD_RS2320_00052_arg_MSZ_String
0945  118A  	BCF PCLATH,3
0946  20F5  	CALL FCD_RS2320_00052


				//Calculation
				//Calculation:
				//  fbit = 1
				FCV_FBIT = 1;
0947  3001  	MOVLW 0x01
0948  00C6  	MOVWF gbl_FCV_FBIT


			// } else {

			}

			//Output
			//Output: 1 -> D6
			trisd = trisd & 0xBF;
0949  30BF  	MOVLW 0xBF
094A  1683  	BSF STATUS, RP0
094B  0508  	ANDWF gbl_trisd, W
094C  0088  	MOVWF gbl_trisd

			if ((1))
				portd = (portd & 0xBF) | 0x40;
094D  30BF  	MOVLW 0xBF
094E  1283  	BCF STATUS, RP0
094F  0508  	ANDWF gbl_portd, W
0950  00CC  	MOVWF CompTempVar2482
0951  3040  	MOVLW 0x40
0952  044C  	IORWF CompTempVar2482, W
0953  0088  	MOVWF gbl_portd

			else
				portd = portd & 0xBF;

		} else {
0954  158A  	BSF PCLATH,3
0955  2957  	GOTO	label88
0957        label88


			//Calculation
			//Calculation:
			//  fbit = 0
			FCV_FBIT = 0;
0956  01C6  	CLRF gbl_FCV_FBIT


		}

		//Call Component Macro
		//Call Component Macro: Cursor(14, 1)
		FCD_LCDDisplay0_Cursor(14, 1);
0957  300E  	MOVLW 0x0E
0958  00CC  	MOVWF FCD_LCDDis_0005E_arg_x
0959  3001  	MOVLW 0x01
095A  00CD  	MOVWF FCD_LCDDis_0005E_arg_y
095B  118A  	BCF PCLATH,3
095C  2757  	CALL FCD_LCDDis_0005E


		//Call Component Macro
		//Call Component Macro: PrintNumber(siren)
		FCD_LCDDisplay0_PrintNumber(FCV_SIREN);
095D  01CD  	CLRF FCD_LCDDis_0005F_arg_Number+D'1'
095E  01CC  	CLRF FCD_LCDDis_0005F_arg_Number
095F  19C7  	BTFSC gbl_FCV_SIREN,3
0960  0ACC  	INCF FCD_LCDDis_0005F_arg_Number, F
0961  2669  	CALL FCD_LCDDis_0005F



	}

	mainendloop: goto mainendloop;
}


void MX_INTERRUPT_MACRO(void)

{
}
09A9  1283  	BCF STATUS, RP0
09AA  1303  	BCF STATUS, RP1
09AB  0E36  	SWAPF Int1BContext+D'2', W
09AC  0084  	MOVWF FSR
09AD  0E35  	SWAPF Int1BContext+D'1', W
09AE  008A  	MOVWF PCLATH
09AF  0E34  	SWAPF Int1BContext, W
09B0  0083  	MOVWF STATUS
09B1  0EFF  	SWAPF Int1Context, F
09B2  0E7F  	SWAPF Int1Context, W
09B3  0009  	RETFIE





/*********************************************************************
 *                  Flowcode CAL PWM File
 *
 * File: PIC_CAL_PWM.c
 *
 * (c) 2011 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * “Company”) for its Flowcode graphical programming language is
 * intended and supplied to you, the Company’s customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 270911 | BR | Created
 * 021211 | BR | Converted to new dynamic defines mechanism
 *
 */


#define MX_PWM_CHANNEL_X		CAL_APPEND(MX_PWM_CHANNEL_, MX_PWM_NUM)
#define MX_PWM_HWALT_X			CAL_APPEND(MX_PWM_HWALT_, MX_PWM_NUM)


//I2C Master Functions
CALFUNCTION(void, FC_CAL_PWM_Enable_Channel_, (void));
CALFUNCTION(void, FC_CAL_PWM_Disable_Channel_, (void));
CALFUNCTION(void, FC_CAL_PWM_Set_Duty_8Bit_, (MX_UINT8 duty));
CALFUNCTION(void, FC_CAL_PWM_Change_Period_, (MX_UINT8 period, MX_UINT16 prescaler));
CALFUNCTION(void, FC_CAL_PWM_Set_Duty_10Bit_, (MX_UINT16 duty));


CALFUNCTION(void, FC_CAL_PWM_Enable_Channel_, (void))

{

 #ifdef MX_PWM

	#if (MX_PWM_CHANNEL_X == 1)
	  #ifdef MX_PWM_REMAPPABLE
	  	RPOR3 = 14;														//PWM1 - 14 - RB0 - RP3
	  #endif

		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
		  #ifndef MX_PWM_1_PORT											//Error checking
			#error "This chip does not have PWM channel 1 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_1_PORT, MX_PWM_1_TRIS, MX_PWM_1_PIN);			//PWM pin is an output
00ED  1683  	BSF STATUS, RP0
00EE  1303  	BCF STATUS, RP1
00EF  1107  	BCF gbl_trisc,2
00F0  1283  	BCF STATUS, RP0
00F1  1107  	BCF gbl_portc,2

		#else															//Alternate PWM Pin
		  #ifndef MX_PWM_1_PORT_A										//Error checking
			#error "This chip does not have PWM alt channel 1 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_1_PORT_A, MX_PWM_1_TRIS_A, MX_PWM_1_PIN_A);		//PWM pin is an output
		#endif

		ccp1con = 0x0C;													//Enable Capture Compare Channel 1
00F2  300C  	MOVLW 0x0C
00F3  0097  	MOVWF gbl_ccp1con

	#endif

	#if (MX_PWM_CHANNEL_X == 2)
	  #ifdef MX_PWM_REMAPPABLE
	  	RPOR4 = 18;														//PWM2 - 18 - RB1 - RP4
	  #endif

		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
		  #ifndef MX_PWM_2_PORT											//Error checking
			#error "This chip does not have PWM channel 2 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_2_PORT, MX_PWM_2_TRIS, MX_PWM_2_PIN);			//PWM pin is an output
		#else															//Alternate PWM Pin
		  #ifndef MX_PWM_2_PORT_A										//Error checking
			#error "This chip does not have PWM alt channel 2 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_2_PORT_A, MX_PWM_2_TRIS_A, MX_PWM_2_PIN_A);		//PWM pin is an output
		#endif

		ccp2con = 0x0C;													//Enable Capture Compare Channel 2
	#endif

	#if (MX_PWM_CHANNEL_X == 3)
	  #ifdef MX_PWM_REMAPPABLE
	  	RPOR5 = 22;														//PWM3 - 22 - RB2 - RP5
	  #endif

		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
		  #ifndef MX_PWM_3_PORT											//Error checking
			#error "This chip does not have PWM channel 3 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_3_PORT, MX_PWM_3_TRIS, MX_PWM_3_PIN);			//PWM pin is an output
		#else															//Alternate PWM Pin
		  #ifndef MX_PWM_3_PORT_A										//Error checking
			#error "This chip does not have PWM alt channel 3 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_3_PORT_A, MX_PWM_3_TRIS_A, MX_PWM_3_PIN_A);		//PWM pin is an output
		#endif

		ccp3con = 0x0C;													//Enable Capture Compare Channel 3 *****************************************************************
	#endif

	#if (MX_PWM_CHANNEL_X == 4)
		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
		  #ifndef MX_PWM_4_PORT											//Error checking
			#error "This chip does not have PWM channel 4 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_4_PORT, MX_PWM_4_TRIS, MX_PWM_4_PIN);			//PWM pin is an output
		#else															//Alternate PWM Pin
		  #ifndef MX_PWM_4_PORT_A										//Error checking
			#error "This chip does not have PWM alt channel 4 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_4_PORT_A, MX_PWM_4_TRIS_A, MX_PWM_4_PIN_A);		//PWM pin is an output
		#endif

		ccp4con = 0x0C;													//Enable Capture Compare Channel 4 *****************************************************************
	#endif

	#if (MX_PWM_CHANNEL_X == 5)
		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
		  #ifndef MX_PWM_5_PORT											//Error checking
			#error "This chip does not have PWM channel 5 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_5_PORT, MX_PWM_5_TRIS, MX_PWM_5_PIN);			//PWM pin is an output
		#else															//Alternate PWM Pin
		  #ifndef MX_PWM_5_PORT_A										//Error checking
			#error "This chip does not have PWM alt channel 5 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_5_PORT_A, MX_PWM_5_TRIS_A, MX_PWM_5_PIN_A);		//PWM pin is an output
		#endif

		ccp5con = 0x0C;													//Enable Capture Compare Channel 5 *****************************************************************
	#endif

	#if (MX_PWM_CHANNEL_X == 6)
		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
		  #ifndef MX_PWM_6_PORT											//Error checking
			#error "This chip does not have PWM channel 6 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_6_PORT, MX_PWM_6_TRIS, MX_PWM_6_PIN);			//PWM pin is an output
		#else															//Alternate PWM Pin
		  #ifndef MX_PWM_6_PORT_A										//Error checking
			#error "This chip does not have PWM alt channel 6 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_6_PORT_A, MX_PWM_6_TRIS_A, MX_PWM_6_PIN_A);		//PWM pin is an output
		#endif

		ccp6con = 0x0C;													//Enable Capture Compare Channel 6 *****************************************************************
	#endif

	#if (MX_PWM_CHANNEL_X == 7)
		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
		  #ifndef MX_PWM_7_PORT											//Error checking
			#error "This chip does not have PWM channel 7 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_7_PORT, MX_PWM_7_TRIS, MX_PWM_7_PIN);			//PWM pin is an output
		#else															//Alternate PWM Pin
		  #ifndef MX_PWM_7_PORT_A										//Error checking
			#error "This chip does not have PWM alt channel 7 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_7_PORT_A, MX_PWM_7_TRIS_A, MX_PWM_7_PIN_A);		//PWM pin is an output
		#endif

		ccp7con = 0x0C;													//Enable Capture Compare Channel 5 *****************************************************************
	#endif

	#if (MX_PWM_CHANNEL_X == 8)
		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
		  #ifndef MX_PWM_8_PORT											//Error checking
			#error "This chip does not have PWM channel 8 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_8_PORT, MX_PWM_8_TRIS, MX_PWM_8_PIN);			//PWM pin is an output
		#else															//Alternate PWM Pin
		  #ifndef MX_PWM_8_PORT_A										//Error checking
			#error "This chip does not have PWM alt channel 8 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_8_PORT_A, MX_PWM_8_TRIS_A, MX_PWM_8_PIN_A);		//PWM pin is an output
		#endif

		ccp8con = 0x0C;													//Enable Capture Compare Channel 8 *****************************************************************
	#endif

	#if (MX_PWM_CHANNEL_X == 9)
		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
		  #ifndef MX_PWM_9_PORT											//Error checking
			#error "This chip does not have PWM channel 9 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_9_PORT, MX_PWM_9_TRIS, MX_PWM_9_PIN);			//PWM pin is an output
		#else															//Alternate PWM Pin
		  #ifndef MX_PWM_9_PORT_A										//Error checking
			#error "This chip does not have PWM alt channel 9 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_9_PORT_A, MX_PWM_9_TRIS_A, MX_PWM_9_PIN_A);		//PWM pin is an output
		#endif

		ccp9con = 0x0C;													//Enable Capture Compare Channel 9 *****************************************************************
	#endif

	#if (MX_PWM_CHANNEL_X == 10)
		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
		  #ifndef MX_PWM_10_PORT											//Error checking
			#error "This chip does not have PWM channel 10 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_10_PORT, MX_PWM_10_TRIS, MX_PWM_10_PIN);			//PWM pin is an output
		#else															//Alternate PWM Pin
		  #ifndef MX_PWM_10_PORT_A										//Error checking
			#error "This chip does not have PWM alt channel 10 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_10_PORT_A, MX_PWM_10_TRIS_A, MX_PWM_10_PIN_A);		//PWM pin is an output
		#endif

		ccp10con = 0x0C;												//Enable Capture Compare Channel 10 *****************************************************************
	#endif

 #else
 	#error "Hardware PWM not supported by Target microcontroller."
 #endif

}
00F4  0008  	RETURN



CALFUNCTION(void, FC_CAL_PWM_Disable_Channel_, (void))
{
	#if (MX_PWM_CHANNEL_X == 1)
		ccp1con = 0x00;													//Disable Capture Compare Channel 1
		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_1_PORT, MX_PWM_1_TRIS, MX_PWM_1_PIN);			//PWM pin is an input
		#else															//Alternate PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_1_PORT_A, MX_PWM_1_TRIS_A, MX_PWM_1_PIN_A);		//PWM pin is an input
		#endif
	#endif

	#if (MX_PWM_CHANNEL_X == 2)
		ccp2con = 0x00;													//Disable Capture Compare Channel 2
		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_2_PORT, MX_PWM_2_TRIS, MX_PWM_2_PIN);			//PWM pin is an input
		#else															//Alternate PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_2_PORT_A, MX_PWM_2_TRIS_A, MX_PWM_2_PIN_A);		//PWM pin is an input
		#endif
	#endif

	#if (MX_PWM_CHANNEL_X == 3)
		ccp3con = 0x00;													//Disable Capture Compare Channel 3
		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_3_PORT, MX_PWM_3_TRIS, MX_PWM_3_PIN);			//PWM pin is an input
		#else															//Alternate PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_3_PORT_A, MX_PWM_3_TRIS_A, MX_PWM_3_PIN_A);		//PWM pin is an input
		#endif
	#endif

	#if (MX_PWM_CHANNEL_X == 4)
		ccp4con = 0x00;													//Disable Capture Compare Channel 4
		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_4_PORT, MX_PWM_4_TRIS, MX_PWM_4_PIN);			//PWM pin is an input
		#else															//Alternate PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_4_PORT_A, MX_PWM_4_TRIS_A, MX_PWM_4_PIN_A);		//PWM pin is an input
		#endif
	#endif

	#if (MX_PWM_CHANNEL_X == 5)
		ccp5con = 0x00;													//Disable Capture Compare Channel 5
		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_5_PORT, MX_PWM_5_TRIS, MX_PWM_5_PIN);			//PWM pin is an input
		#else															//Alternate PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_5_PORT_A, MX_PWM_5_TRIS_A, MX_PWM_5_PIN_A);		//PWM pin is an input
		#endif
	#endif

	#if (MX_PWM_CHANNEL_X == 6)
		ccp6con = 0x00;													//Disable Capture Compare Channel 6
		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_6_PORT, MX_PWM_6_TRIS, MX_PWM_6_PIN);			//PWM pin is an input
		#else															//Alternate PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_6_PORT_A, MX_PWM_6_TRIS_A, MX_PWM_6_PIN_A);		//PWM pin is an input
		#endif
	#endif

	#if (MX_PWM_CHANNEL_X == 7)
		ccp7con = 0x00;													//Disable Capture Compare Channel 7
		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_7_PORT, MX_PWM_7_TRIS, MX_PWM_7_PIN);			//PWM pin is an input
		#else															//Alternate PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_7_PORT_A, MX_PWM_7_TRIS_A, MX_PWM_7_PIN_A);		//PWM pin is an input
		#endif
	#endif

	#if (MX_PWM_CHANNEL_X == 8)
		ccp8con = 0x00;													//Disable Capture Compare Channel 8
		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_8_PORT, MX_PWM_8_TRIS, MX_PWM_8_PIN);			//PWM pin is an input
		#else															//Alternate PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_8_PORT_A, MX_PWM_8_TRIS_A, MX_PWM_8_PIN_A);		//PWM pin is an input
		#endif
	#endif

	#if (MX_PWM_CHANNEL_X == 9)
		ccp9con = 0x00;													//Disable Capture Compare Channel 9
		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_9_PORT, MX_PWM_9_TRIS, MX_PWM_9_PIN);			//PWM pin is an input
		#else															//Alternate PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_9_PORT_A, MX_PWM_9_TRIS_A, MX_PWM_9_PIN_A);		//PWM pin is an input
		#endif
	#endif

	#if (MX_PWM_CHANNEL_X == 10)
		ccp10con = 0x00;												//Disable Capture Compare Channel 10
		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_10_PORT, MX_PWM_10_TRIS, MX_PWM_10_PIN);			//PWM pin is an input
		#else															//Alternate PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_10_PORT_A, MX_PWM_10_TRIS_A, MX_PWM_10_PIN_A);		//PWM pin is an input
		#endif
	#endif
}


CALFUNCTION(void, FC_CAL_PWM_Set_Duty_8Bit_, (MX_UINT8 duty))

{
	#if (MX_PWM_CHANNEL_X == 1)
		ccpr1l = duty;													//Update Capture Compare Count 1
0054  0855  	MOVF FC_CAL_PWM_00071_arg_duty, W
0055  0095  	MOVWF gbl_ccpr1l

	#endif

	#if (MX_PWM_CHANNEL_X == 2)
		ccpr2l = duty;													//Update Capture Compare Count 2
	#endif

	#if (MX_PWM_CHANNEL_X == 3)
		ccpr3l = duty;													//Update Capture Compare Count 3
	#endif

	#if (MX_PWM_CHANNEL_X == 4)
		ccpr4l = duty;													//Update Capture Compare Count 4
	#endif

	#if (MX_PWM_CHANNEL_X == 5)
		ccpr5l = duty;													//Update Capture Compare Count 5
	#endif

	#if (MX_PWM_CHANNEL_X == 6)
		ccpr6l = duty;													//Update Capture Compare Count 6
	#endif

	#if (MX_PWM_CHANNEL_X == 7)
		ccpr7l = duty;													//Update Capture Compare Count 7
	#endif

	#if (MX_PWM_CHANNEL_X == 8)
		ccpr8l = duty;													//Update Capture Compare Count 8
	#endif

	#if (MX_PWM_CHANNEL_X == 9)
		ccpr9l = duty;													//Update Capture Compare Count 9
	#endif

	#if (MX_PWM_CHANNEL_X == 10)
		ccpr10l = duty;													//Update Capture Compare Count 10
	#endif
}
0056  0008  	RETURN



CALFUNCTION(void, FC_CAL_PWM_Change_Period_, (MX_UINT8 period, MX_UINT16 prescaler))

{
  #ifdef MX_PWM								//Hardware Mode
	pr2 = period;
00CD  0848  	MOVF FC_CAL_PWM_00072_arg_period, W
00CE  1683  	BSF STATUS, RP0
00CF  0092  	MOVWF gbl_pr2

	switch (prescaler)
	{
	  #ifdef MX_PWM_PSCA1
		case 1:
00D0  3001  	MOVLW 0x01
00D1  1283  	BCF STATUS, RP0
00D2  0649  	XORWF FC_CAL_PWM_00072_arg_prescaler, W
00D3  1903  	BTFSC STATUS,Z
00D4  084A  	MOVF FC_CAL_PWM_00072_arg_prescaler+D'1', W
00D5  1903  	BTFSC STATUS,Z
00D6  28E4  	GOTO	label18
00E4        label18

			t2con = 0x04;
00E4  3004  	MOVLW 0x04
00E5  0092  	MOVWF gbl_t2con

			break;
	  #endif
	  #ifdef MX_PWM_PSCA4
		case 4:
00D7  3004  	MOVLW 0x04
00D8  0649  	XORWF FC_CAL_PWM_00072_arg_prescaler, W
00D9  1903  	BTFSC STATUS,Z
00DA  084A  	MOVF FC_CAL_PWM_00072_arg_prescaler+D'1', W
00DB  1903  	BTFSC STATUS,Z
00DC  28E7  	GOTO	label19
00E7        label19

			t2con = 0x05;
00E7  3005  	MOVLW 0x05
00E8  0092  	MOVWF gbl_t2con

			break;
	  #endif
	  #ifdef MX_PWM_PSCA16
		case 16:
00DD  3010  	MOVLW 0x10
00DE  0649  	XORWF FC_CAL_PWM_00072_arg_prescaler, W
00DF  1903  	BTFSC STATUS,Z
00E0  084A  	MOVF FC_CAL_PWM_00072_arg_prescaler+D'1', W
00E1  1903  	BTFSC STATUS,Z
00E2  28EA  	GOTO	label20
00EA        label20

			t2con = 0x06;
00EA  3006  	MOVLW 0x06
00EB  0092  	MOVWF gbl_t2con

			break;
	  #endif
	  #ifdef MX_PWM_PSCA64
		case 64:
			t2con = 0x07;					//Note some earlier devices do not have the /64 option
			break;
	  #endif
	}
  #endif
}
00E3  0008  	RETURN
00E6  0008  	RETURN
00E9  0008  	RETURN
00EC  0008  	RETURN



CALFUNCTION(void, FC_CAL_PWM_Set_Duty_10Bit_, (MX_UINT16 duty))
{
	char nCCPxCONtemp;

	#if (MX_PWM_CHANNEL_X == 1)
		ccpr1l = (duty & 0x3FC) >> 2;									//Update Capture Compare Count 1
		duty = (duty & 0x03) << 4;
		nCCPxCONtemp = (ccp1con & 0xCF) | duty;
		ccp1con = nCCPxCONtemp;
	#endif

	#if (MX_PWM_CHANNEL_X == 2)
		ccpr2l = (duty & 0x3FC) >> 2;									//Update Capture Compare Count 2
		duty = (duty & 0x03) << 4;
		nCCPxCONtemp = (ccp2con & 0xCF) | duty;
		ccp2con = nCCPxCONtemp;
	#endif

	#if (MX_PWM_CHANNEL_X == 3)
		ccpr3l = (duty & 0x3FC) >> 2;									//Update Capture Compare Count 3
		duty = (duty & 0x03) << 4;
		nCCPxCONtemp = (ccp3con & 0xCF) | duty;
		ccp3con = nCCPxCONtemp;
	#endif

	#if (MX_PWM_CHANNEL_X == 4)
		ccpr4l = (duty & 0x3FC) >> 2;									//Update Capture Compare Count 4
		duty = (duty & 0x03) << 4;
		nCCPxCONtemp = (ccp4con & 0xCF) | duty;
		ccp4con = nCCPxCONtemp;
	#endif

	#if (MX_PWM_CHANNEL_X == 5)
		ccpr5l = (duty & 0x3FC) >> 2;									//Update Capture Compare Count 5
		duty = (duty & 0x03) << 4;
		nCCPxCONtemp = (ccp5con & 0xCF) | duty;
		ccp5con = nCCPxCONtemp;
	#endif

	#if (MX_PWM_CHANNEL_X == 6)
		ccpr6l = (duty & 0x3FC) >> 2;									//Update Capture Compare Count 6
		duty = (duty & 0x03) << 4;
		nCCPxCONtemp = (ccp6con & 0xCF) | duty;
		ccp6con = nCCPxCONtemp;
	#endif

	#if (MX_PWM_CHANNEL_X == 7)
		ccpr7l = (duty & 0x3FC) >> 2;									//Update Capture Compare Count 7
		duty = (duty & 0x03) << 4;
		nCCPxCONtemp = (ccp7con & 0xCF) | duty;
		ccp7con = nCCPxCONtemp;
	#endif

	#if (MX_PWM_CHANNEL_X == 8)
		ccpr8l = (duty & 0x3FC) >> 2;									//Update Capture Compare Count 8
		duty = (duty & 0x03) << 4;
		nCCPxCONtemp = (ccp8con & 0xCF) | duty;
		ccp8con = nCCPxCONtemp;
	#endif

	#if (MX_PWM_CHANNEL_X == 9)
		ccpr9l = (duty & 0x3FC) >> 2;									//Update Capture Compare Count 9
		duty = (duty & 0x03) << 4;
		nCCPxCONtemp = (ccp9con & 0xCF) | duty;
		ccp9con = nCCPxCONtemp;
	#endif

	#if (MX_PWM_CHANNEL_X == 10)
		ccpr10l = (duty & 0x3FC) >> 2;									//Update Capture Compare Count 10
		duty = (duty & 0x03) << 4;
		nCCPxCONtemp = (ccp10con & 0xCF) | duty;
		ccp10con = nCCPxCONtemp;
	#endif
}


/*********************************************************************
 *                  Flowcode CAL UART File
 *
 * File: PIC_CAL_UART.c
 *
 * (c) 2011 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * “Company”) for its Flowcode graphical programming language is
 * intended and supplied to you, the Company’s customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 010911 | BR | Created
 * 020911 | BR | Updated variables with typedef alternatives
 * 011211 | BR | Converted to new dynamic defines mechanism
 * 160112 | BR | Fixed issues with rx return type and low bauds on fast devices
 * 020212 | ST | Added <MX_UART_2_PIE4> routing to account for differences in 16F and 18F devices with 2 UARTs
 * 270212 | BR | Fixed a bug in the receive functionality
 * 280212 | BR | Sorted out auto echo functionality
 * 160412 | BR | Addition of HW change baud function
 */



#ifndef MX_UART_SW_DEFS
	#define MX_UART_SW_DEFS

	#ifdef _BOOSTC
		#define INST_COUNT	45	//65 for lower speeds or 40 for higher speeds.
	#endif
	#ifdef HI_TECH_C
		#define INST_COUNT	315
	#endif

	//Work out number of nops for software baud rate
	#define MX_INSTRUCTION_SPEED 	(MX_CLK_SPEED / 4)
	#define MX_OVERHEAD				(MX_INSTRUCTION_SPEED / INST_COUNT)
	#define SW_OFFSET				(1000000 / MX_OVERHEAD)

	//Work out software baud rates if required
	#define SW_1200_BAUD	(832 - SW_OFFSET)
	#define SW_2400_BAUD	(416 - SW_OFFSET)
	#define SW_4800_BAUD	(208 - SW_OFFSET)
	#define SW_9600_BAUD	(104 - SW_OFFSET)
	#define SW_19200_BAUD	(52 - SW_OFFSET)
	#define SW_31250_BAUD	(32 - SW_OFFSET)
	#define SW_115200_BAUD	(8 - SW_OFFSET)
#endif

 #if defined(MX_UART_CHANNEL_1) && (MX_UART_NUM==1)
	#if (MX_UART_CHANNEL_1 == 0)
		#if (MX_UART_BAUD_1 == 1200)
			#define MX_SOFT_BAUD_1	SW_1200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 1200 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_1 == 2400)
			#define MX_SOFT_BAUD_1	SW_2400_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 2400 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_1 == 4800)
			#define MX_SOFT_BAUD_1	SW_4800_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 4800 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_1 == 9600)
			#define MX_SOFT_BAUD_1	SW_9600_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 9600 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_1 == 19200)
			#define MX_SOFT_BAUD_1	SW_19200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 19200 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_1 == 31250)
			#define MX_SOFT_BAUD_1	SW_31250_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 31250 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_1 == 115200)
			#define MX_SOFT_BAUD_1	SW_115200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 115200 Not Available At This Clock Speed"
			#endif
		#endif
		#ifndef MX_SOFT_BAUD_1
			#error "UART Baud Rate not supported in Software Mode"
		#endif
	#else
		#define MX_SOFT_BAUD_1	1
		#define MX_HARD_BAUD_1	(((MX_CLK_SPEED / MX_UART_BAUD_1) - 16) / 16)
		#define MX_HARD_SLOW_1	0

		#if (MX_HARD_BAUD_1 > 255)
			#undef MX_HARD_BAUD_1
			#undef MX_HARD_SLOW_1
			#define MX_HARD_BAUD_1	(((MX_CLK_SPEED / MX_UART_BAUD_1) - 16)	/ 64)
			#define MX_HARD_SLOW_1	1
		#endif

	#endif
 #endif
 #if defined(MX_UART_CHANNEL_2) && (MX_UART_NUM==2)
	#if (MX_UART_CHANNEL_2 == 0)
		#if (MX_UART_BAUD_2 == 1200)
			#define MX_SOFT_BAUD_2	SW_1200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 1200 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_2 == 2400)
			#define MX_SOFT_BAUD_2	SW_2400_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 2400 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_2 == 4800)
			#define MX_SOFT_BAUD_2	SW_4800_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 4800 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_2 == 9600)
			#define MX_SOFT_BAUD_2	SW_9600_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 9600 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_2 == 19200)
			#define MX_SOFT_BAUD_2	SW_19200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 19200 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_2 == 31250)
			#define MX_SOFT_BAUD_2	SW_31250_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 31250 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_2 == 115200)
			#define MX_SOFT_BAUD_2	SW_115200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 115200 Not Available At This Clock Speed"
			#endif
		#endif
		#ifndef MX_SOFT_BAUD_2
			#error "UART Baud Rate not supported in Software Mode"
		#endif
	#else
		#define MX_SOFT_BAUD_2	1
		#define MX_HARD_BAUD_2	(((MX_CLK_SPEED / MX_UART_BAUD_2) - 16) / 16)
		#define MX_HARD_SLOW_2	0

		#if (MX_HARD_BAUD_2 > 255)
			#undef MX_HARD_BAUD_2
			#undef MX_HARD_SLOW_2
			#define MX_HARD_BAUD_2	(((MX_CLK_SPEED / MX_UART_BAUD_2) - 16)	/ 64)
			#define MX_HARD_SLOW_2	1
		#endif
 	#endif
 #endif
 #if defined(MX_UART_CHANNEL_3) && (MX_UART_NUM==3)
	#if (MX_UART_CHANNEL_3 == 0)
		#if (MX_UART_BAUD_3 == 1200)
			#define MX_SOFT_BAUD_3	SW_1200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 1200 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_3 == 2400)
			#define MX_SOFT_BAUD_3	SW_2400_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 2400 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_3 == 4800)
			#define MX_SOFT_BAUD_3	SW_4800_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 4800 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_3 == 9600)
			#define MX_SOFT_BAUD_3	SW_9600_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 9600 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_3 == 19200)
			#define MX_SOFT_BAUD_3	SW_19200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 19200 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_3 == 31250)
			#define MX_SOFT_BAUD_3	SW_31250_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 31250 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_3 == 115200)
			#define MX_SOFT_BAUD_3	SW_115200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 115200 Not Available At This Clock Speed"
			#endif
		#endif
		#ifndef MX_SOFT_BAUD_3
			#error "UART Baud Rate not supported in Software Mode"
		#endif
	#else
		#define MX_SOFT_BAUD_3	1
		#define MX_HARD_BAUD_3	(((MX_CLK_SPEED / MX_UART_BAUD_3) - 16) / 16)
		#define MX_HARD_SLOW_3	0

		#if (MX_HARD_BAUD_3 > 255)
			#undef MX_HARD_BAUD_3
			#undef MX_HARD_SLOW_3
			#define MX_HARD_BAUD_3	(((MX_CLK_SPEED / MX_UART_BAUD_3) - 16)	/ 64)
			#define MX_HARD_SLOW_3	1
		#endif
	#endif
 #endif
 #if defined(MX_UART_CHANNEL_4) && (MX_UART_NUM==4)
	#if (MX_UART_CHANNEL_4 == 0)
		#if (MX_UART_BAUD_4 == 1200)
			#define MX_SOFT_BAUD_4	SW_1200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 1200 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_4 == 2400)
			#define MX_SOFT_BAUD_4	SW_2400_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 2400 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_4 == 4800)
			#define MX_SOFT_BAUD_4	SW_4800_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 4800 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_4 == 9600)
			#define MX_SOFT_BAUD_4	SW_9600_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 9600 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_4 == 19200)
			#define MX_SOFT_BAUD_4	SW_19200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 19200 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_4 == 31250)
			#define MX_SOFT_BAUD_4	SW_31250_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 31250 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_4 == 115200)
			#define MX_SOFT_BAUD_4	SW_115200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 115200 Not Available At This Clock Speed"
			#endif
		#endif
		#ifndef MX_SOFT_BAUD_4
			#error "UART Baud Rate not supported in Software Mode"
		#endif
	#else
		#define MX_SOFT_BAUD_4	1
		#define MX_HARD_BAUD_4	(((MX_CLK_SPEED / MX_UART_BAUD_4) - 16) / 16)
		#define MX_HARD_SLOW_4	0

		#if (MX_HARD_BAUD_4 > 255)
			#undef MX_HARD_BAUD_4
			#undef MX_HARD_SLOW_4
			#define MX_HARD_BAUD_4	(((MX_CLK_SPEED / MX_UART_BAUD_4) - 16)	/ 64)
			#define MX_HARD_SLOW_4	1
		#endif
	#endif
 #endif


//Hardware Baud update definitions
#ifndef MX_HARD_BAUD_CHANGE_DEFS
	#define MX_HARD_BAUD_CHANGE_DEFS

	#define MX_HARD_BAUD_1200	(((MX_CLK_SPEED / 1200) - 16) / 16)
	#if (MX_HARD_BAUD_1200 > 255)
		#undef MX_HARD_BAUD_1200
		#define MX_HARD_BAUD_1200	(((MX_CLK_SPEED / 1200) - 16) / 64)
		#define MX_HARD_SLOW_1200	1
	#else
		#define MX_HARD_SLOW_1200	0
	#endif

	#define MX_HARD_BAUD_2400	(((MX_CLK_SPEED / 2400) - 16) / 16)
	#if (MX_HARD_BAUD_2400 > 255)
		#undef MX_HARD_BAUD_2400
		#define MX_HARD_BAUD_2400	(((MX_CLK_SPEED / 2400) - 16) / 64)
		#define MX_HARD_SLOW_2400	1
	#else
		#define MX_HARD_SLOW_2400	0
	#endif

	#define MX_HARD_BAUD_4800	(((MX_CLK_SPEED / 4800) - 16) / 16)
	#if (MX_HARD_BAUD_4800 > 255)
		#undef MX_HARD_BAUD_4800
		#define MX_HARD_BAUD_4800	(((MX_CLK_SPEED / 4800) - 16) / 64)
		#define MX_HARD_SLOW_4800	1
	#else
		#define MX_HARD_SLOW_4800	0
	#endif

	#define MX_HARD_BAUD_9600	(((MX_CLK_SPEED / 9600) - 16) / 16)
	#if (MX_HARD_BAUD_9600 > 255)
		#undef MX_HARD_BAUD_9600
		#define MX_HARD_BAUD_9600	(((MX_CLK_SPEED / 9600) - 16) / 64)
		#define MX_HARD_SLOW_9600	1
	#else
		#define MX_HARD_SLOW_9600	0
	#endif

	#define MX_HARD_BAUD_19200	(((MX_CLK_SPEED / 19200) - 16) / 16)
	#if (MX_HARD_BAUD_19200 > 255)
		#undef MX_HARD_BAUD_19200
		#define MX_HARD_BAUD_19200	(((MX_CLK_SPEED / 19200) - 16) / 64)
		#define MX_HARD_SLOW_19200	1
	#else
		#define MX_HARD_SLOW_19200	0
	#endif

	#define MX_HARD_BAUD_38400	(((MX_CLK_SPEED / 38400) - 16) / 16)
	#if (MX_HARD_BAUD_38400 > 255)
		#undef MX_HARD_BAUD_38400
		#define MX_HARD_BAUD_38400	(((MX_CLK_SPEED / 38400) - 16) / 64)
		#define MX_HARD_SLOW_38400	1
	#else
		#define MX_HARD_SLOW_38400	0
	#endif

	#define MX_HARD_BAUD_57600	(((MX_CLK_SPEED / 57600) - 16) / 16)
	#if (MX_HARD_BAUD_57600 > 255)
		#undef MX_HARD_BAUD_57600
		#define MX_HARD_BAUD_57600	(((MX_CLK_SPEED / 57600) - 16) / 64)
		#define MX_HARD_SLOW_57600	1
	#else
		#define MX_HARD_SLOW_57600	0
	#endif

	#define MX_HARD_BAUD_115200	(((MX_CLK_SPEED / 115200) - 16) / 16)
	#if (MX_HARD_BAUD_115200 > 255)
		#undef MX_HARD_BAUD_115200
		#define MX_HARD_BAUD_115200	(((MX_CLK_SPEED / 115200) - 16) / 64)
		#define MX_HARD_SLOW_115200	1
	#else
		#define MX_HARD_SLOW_115200	0
	#endif
#endif


//Dynamic function naming based on defines and index number
#define MX_UART_CHANNEL_X	CAL_APPEND(MX_UART_CHANNEL_, MX_UART_NUM)
#define MX_UART_TX_PIN_X	CAL_APPEND(MX_UART_TX_PIN_, MX_UART_NUM)
#define MX_UART_TX_PORT_X	CAL_APPEND(MX_UART_TX_PORT_, MX_UART_NUM)
#define MX_UART_TX_TRIS_X	CAL_APPEND(MX_UART_TX_TRIS_, MX_UART_NUM)
#define MX_UART_RX_PIN_X	CAL_APPEND(MX_UART_RX_PIN_, MX_UART_NUM)
#define MX_UART_RX_PORT_X	CAL_APPEND(MX_UART_RX_PORT_, MX_UART_NUM)
#define MX_UART_RX_TRIS_X	CAL_APPEND(MX_UART_RX_TRIS_, MX_UART_NUM)
#define MX_UART_FLOWEN_X	CAL_APPEND(MX_UART_FLOWEN_, MX_UART_NUM)
#define MX_UART_CTS_PIN_X	CAL_APPEND(MX_UART_CTS_PIN_, MX_UART_NUM)
#define MX_UART_CTS_PORT_X	CAL_APPEND(MX_UART_CTS_PORT_, MX_UART_NUM)
#define MX_UART_CTS_TRIS_X	CAL_APPEND(MX_UART_CTS_TRIS_, MX_UART_NUM)
#define MX_UART_RTS_PIN_X	CAL_APPEND(MX_UART_RTS_PIN_, MX_UART_NUM)
#define MX_UART_RTS_PORT_X	CAL_APPEND(MX_UART_RTS_PORT_, MX_UART_NUM)
#define MX_UART_RTS_TRIS_X	CAL_APPEND(MX_UART_RTS_TRIS_, MX_UART_NUM)
#define MX_UART_DBITS_X		CAL_APPEND(MX_UART_DBITS_, MX_UART_NUM)
#define MX_UART_RETURN_X	CAL_APPEND(MX_UART_RETURN_, MX_UART_NUM)
#define MX_UART_ECHO_X		CAL_APPEND(MX_UART_ECHO_, MX_UART_NUM)
#define MX_UART_INT_X		CAL_APPEND(MX_UART_INT_, MX_UART_NUM)
#define MX_UART_BAUD_X		CAL_APPEND(MX_HARD_BAUD_, MX_UART_NUM)
#define MX_SOFT_BAUD_X		CAL_APPEND(MX_SOFT_BAUD_, MX_UART_NUM)
#define MX_HARD_SLOW_X		CAL_APPEND(MX_HARD_SLOW_, MX_UART_NUM)

#define UART_Delay_CAL		CAL_APPEND(FC_CAL_UART_Delay_, MX_UART_NUM)
#define UART_Send			CAL_APPEND(FC_CAL_UART_Send_, MX_UART_NUM)
#define UART_Uninit			CAL_APPEND(FC_CAL_UART_Uninit_, MX_UART_NUM)


//Component Definitions
#define UART_STATUS_LOOP	0
#define UART_STATUS_TIMEOUT	1
#define UART_STATUS_RXBYTE	2


//Interrupt Definitions
#ifdef MX_UART_2_PIE4
  #define MX_UART2_PIE pie4
  #define MX_UART2_PIR pir4
  #define MX_UART2_TXSTA tx2sta
  #define MX_UART2_RCSTA rc2sta
  #define MX_UART2_TXREG tx2reg
  #define MX_UART2_RCREG rc2reg
#else
  #define MX_UART2_PIE pie3
  #define MX_UART2_PIR pir3
  #define MX_UART2_TXSTA txsta2
  #define MX_UART2_RCSTA rcsta2
  #define MX_UART2_TXREG txreg2
  #define MX_UART2_RCREG rcreg2
#endif

#if (MX_UART_INT_X == 1)

	#ifndef MX_UART_INT_DEFS
	#define MX_UART_INT_DEFS

		#define MX_UART_INT_CH1_FUNC
		#define MX_UART_INT_CH2_FUNC
		#define MX_UART_INT_FUNC_END

		#define MX_UART_INT_CH1_DET		ts_bit(pir1, RCIF) && ts_bit(pie1, RCIE)
		#define MX_UART_INT_CH2_DET		ts_bit(MX_UART2_PIR, RC2IF) && ts_bit(MX_UART2_PIE, RC2IE)

		#define MX_UART_INT_CH1_EN		st_bit (pie1, RCIE)
		#define MX_UART_INT_CH2_EN		st_bit (MX_UART2_PIE, RC2IE)

		#define MX_UART_INT_CH1_DIS		cr_bit (pie1, RCIE)
		#define MX_UART_INT_CH2_DIS		cr_bit (MX_UART2_PIE, RC2IE)

		#define MX_UART_INT_CH1_CLR		cr_bit (pir1, RCIF)
		#define MX_UART_INT_CH2_CLR		cr_bit (MX_UART2_PIR, RC2IF)

	#endif
#endif


//Function Prototypes
CALFUNCTION(void, FC_CAL_UART_Init_, (void));
CALFUNCTION(void, FC_CAL_UART_Uninit_, (void));
CALFUNCTION(void, FC_CAL_UART_Send_, (MX_UINT16 nChar));
CALFUNCTION(MX_SINT16, FC_CAL_UART_Receive_, (MX_UINT8 nTimeout));
CALFUNCTION(void, FC_CAL_UART_Delay_, (void));


//Peripheral Functions
CALFUNCTION(void, FC_CAL_UART_Init_, (void))

{

	#if (MX_UART_CHANNEL_X == 0)
		FC_CAL_Bit_In_DDR 	(MX_UART_RX_PORT_X, MX_UART_RX_TRIS_X, MX_UART_RX_PIN_X);		// Receive pin is a input
		FC_CAL_Bit_High_DDR (MX_UART_TX_PORT_X, MX_UART_TX_TRIS_X, MX_UART_TX_PIN_X);		// Transmit pin is default high
	#endif

	#if (MX_UART_CHANNEL_X == 1)
	  #ifndef MX_UART_1
	  	  #error "UART channel 1 not available on this device"
	  #else
		  #if (MX_HARD_SLOW_X == 1)
			cr_bit(txsta, BRGH);						//Low Speed
		  #else
			st_bit(txsta, BRGH);						//High Speed
0154  1683  	BSF STATUS, RP0
0155  1303  	BCF STATUS, RP1
0156  1518  	BSF gbl_txsta,2

		  #endif
			spbrg = MX_UART_BAUD_X;   					// set the baud rate
0157  3081  	MOVLW 0x81
0158  0099  	MOVWF gbl_spbrg

			rcsta = 0;                    				// 8-bit, disabled
0159  1283  	BCF STATUS, RP0
015A  0198  	CLRF gbl_rcsta


			#if(MX_UART_DBITS_X == 9)
				st_bit(txsta, TX9);   					// 9-bit TX
				st_bit(rcsta, RX9);                    	// 9-bit RX
			#endif

			st_bit(rcsta, SPEN);         				// turn on serial interface
015B  1798  	BSF gbl_rcsta,7

			st_bit(txsta, TXEN);
015C  1683  	BSF STATUS, RP0
015D  1698  	BSF gbl_txsta,5

			st_bit(rcsta, CREN);
015E  1283  	BCF STATUS, RP0
015F  1618  	BSF gbl_rcsta,4


			#if (MX_UART_INT_X == 1)
				MX_UART_INT_CH1_EN;
				st_bit(intcon, PEIE);
				st_bit(intcon, GIE);
			#else
				cr_bit (pie1, RCIE);
0160  1683  	BSF STATUS, RP0
0161  128C  	BCF gbl_pie1,5

			#endif
	  #endif
	#endif


	#if (MX_UART_CHANNEL_X == 2)

	  #ifndef MX_UART_2
		  #error "UART channel 2 not available on this device"
	  #else
		  #ifdef MX_UART_2_REMAPPABLE
			RPOR9 = 5;									//TX2 - RP9 - RB6
			RPINR16	= 10;								//RX2 - RP10 - RB7
		  #endif
		  #if (MX_HARD_SLOW_X == 1)
			cr_bit(MX_UART2_TXSTA, BRGH);						//Low Speed
		  #else
			st_bit(MX_UART2_TXSTA, BRGH);						//High Speed
		  #endif
			spbrg2 = MX_UART_BAUD_X;   				// set the baud rate
			MX_UART2_RCSTA = 0;                    				// 8-bit, disabled

			#if(MX_UART_DBITS_X == 9)
				st_bit(MX_UART2_TXSTA, TX9);   					// 9-bit TX
				st_bit(MX_UART2_RCSTA, RX9);                    // 9-bit RX
			#endif

			st_bit(MX_UART2_RCSTA, SPEN);         				// turn on serial interface
			st_bit(MX_UART2_TXSTA, TXEN);
			st_bit(MX_UART2_RCSTA, CREN);

			#if (MX_UART_INT_X == 1)
				MX_UART_INT_CH2_EN;
				st_bit(intcon, PEIE);
				st_bit(intcon, GIE);
			#else
				cr_bit (MX_UART2_PIE, RC2IE);
			#endif
	  #endif
	#endif

	#if (MX_UART_FLOWEN_X == 1)						//Flowcontrol enabled?
		FC_CAL_Bit_In_DDR (MX_UART_CTS_PORT_X, MX_UART_CTS_TRIS_X, MX_UART_CTS_PIN_X);	// CTS pin is a input
		FC_CAL_Bit_High_DDR (MX_UART_RTS_PORT_X, MX_UART_RTS_TRIS_X, MX_UART_RTS_PIN_X);	// RTS not ready to accept data
	#endif

}
0162  0008  	RETURN




CALFUNCTION(void, FC_CAL_UART_Uninit_, (void))
{

	#if (MX_UART_CHANNEL_X == 0)
		FC_CAL_Bit_In_DDR (MX_UART_RX_PORT_X, MX_UART_RX_TRIS_X, MX_UART_RX_PIN_X);		// Receive pin is a input
		FC_CAL_Bit_In_DDR (MX_UART_TX_PORT_X, MX_UART_TX_TRIS_X, MX_UART_TX_PIN_X);		// Transmit pin is default high
	#endif

	#if (MX_UART_CHANNEL_X == 1)
			rcsta = 0;                    								// 8-bit, disabled
			txsta = 0;
		  #ifdef MX_UART_RXINT
			MX_UART_INT_CH1_DIS;
		  #endif
	#endif

	#if (MX_UART_CHANNEL_X == 2)
			MX_UART2_RCSTA = 0;                    								// 8-bit, disabled
			MX_UART2_TXSTA = 0;
		  #ifdef MX_UART_RXINT
			MX_UART_INT_CH2_DIS;
		  #endif
	#endif

	#if (MX_UART_FLOWEN_X == 1)										//Flowcontrol enabled?
		FC_CAL_Bit_In_DDR (MX_UART_CTS_PORT_X, MX_UART_CTS_TRIS_X, MX_UART_CTS_PIN_X);		// CTS pin is a input
		FC_CAL_Bit_In_DDR (MX_UART_RTS_PORT_X, MX_UART_RTS_TRIS_X, MX_UART_RTS_PIN_X);		// RTS not ready to accept data
	#endif
}



CALFUNCTION(void, FC_CAL_UART_Send_, (MX_UINT16 nChar))

{
	#if (MX_UART_FLOWEN_X == 1)
		while (FC_CAL_Bit_In(MX_UART_CTS_PORT_X, MX_UART_CTS_PIN_X) != 0);	// Wait until CTS is low
	#endif

	#if (MX_UART_CHANNEL_X == 0)													// Software UART TX
		MX_UINT8 idx;
		FC_CAL_Bit_Low(MX_UART_TX_PORT_X, MX_UART_TX_PIN_X);					// Send Start bit
		UART_Delay_CAL();
		for (idx = 0; idx < MX_UART_DBITS_X; idx++)
		{
			if (nChar & 0x01)														// Mask off data bit
				FC_CAL_Bit_High(MX_UART_TX_PORT_X, MX_UART_TX_PIN_X);
			else
				FC_CAL_Bit_Low(MX_UART_TX_PORT_X, MX_UART_TX_PIN_X);
			UART_Delay_CAL();
			nChar = nChar >> 1;														// Move to next data bit
		}
		FC_CAL_Bit_High(MX_UART_TX_PORT_X, MX_UART_TX_PIN_X);					// Send Stop bit
		UART_Delay_CAL();
	#endif

	#if (MX_UART_CHANNEL_X == 1)
		while (ts_bit(pir1, TXIF) == 0);
004F        label6
004F  1E0C  	BTFSS gbl_pir1,4
0050  284F  	GOTO	label6


		#if (MX_UART_DBITS_X == 9)
			if (test_bit(nChar, 8))
				st_bit(txsta, TX9D);
			else
				cr_bit(txsta, TX9D);
	  	#endif
		txreg = nChar;
0051  0864  	MOVF FC_CAL_UAR_00066_arg_nChar, W
0052  0099  	MOVWF gbl_txreg

	#endif

	#if (MX_UART_CHANNEL_X == 2)
		while (ts_bit(pir3, TX2IF) == 0);

		#if (MX_UART_DBITS_X == 9)
			if (test_bit(nChar, 8))
				st_bit(MX_UART2_TXSTA, TX9D);
			else
				cr_bit(MX_UART2_TXSTA, TX9D);
		#endif
		MX_UART2_TXREG = nChar;
	#endif
}
0053  0008  	RETURN



CALFUNCTION(MX_SINT16, FC_CAL_UART_Receive_, (MX_UINT8 nTimeout))

{
  #if (MX_UART_RETURN_X == 1)
	MX_UINT16 retVal = 512;
  #else
  	MX_UINT8 retVal = 255;
0081  30FF  	MOVLW 0xFF
0082  00CE  	MOVWF FC_CAL_UAR_00067_1_retVal

  #endif

	MX_UINT8 delay1 = 0;
0083  01CF  	CLRF FC_CAL_UAR_00067_1_delay1

	MX_UINT8 regcheck = 0;
0084  01D0  	CLRF FC_CAL_UAR_00067_1_regcheck

	MX_UINT8 bWaitForever = 0;
0085  01D1  	CLRF FC_CAL_UAR_00067_1_bWaitForever

	MX_UINT8 rxStatus = UART_STATUS_LOOP;
0086  01D2  	CLRF FC_CAL_UAR_00067_1_rxStatus


  #if (MX_UART_CHANNEL_X == 0)
  	MX_UINT8 idx;
  #else
  	MX_UINT8 dummy = 0;
0087  01D3  	CLRF FC_CAL_UAR_00067_1_dummy

  #endif

	if (nTimeout == 255)
0088  0A4D  	INCF FC_CAL_UAR_00067_arg_nTimeout, W
0089  1D03  	BTFSS STATUS,Z
008A  288D  	GOTO	label11
008D        label11

		bWaitForever = 1;
008B  3001  	MOVLW 0x01
008C  00D1  	MOVWF FC_CAL_UAR_00067_1_bWaitForever


	#if (MX_UART_FLOWEN_X == 1)
		FC_CAL_Bit_Low (MX_UART_RTS_PORT_X, MX_UART_RTS_PIN_X);			// Ready to accept data
	#endif

	while (rxStatus == UART_STATUS_LOOP)
008D  08D2  	MOVF FC_CAL_UAR_00067_1_rxStatus, F
008E  1D03  	BTFSS STATUS,Z
008F  28AF  	GOTO	label14
00AE  288D  	GOTO	label11
00AF        label14

	{
		if (bWaitForever == 0)
0090  08D1  	MOVF FC_CAL_UAR_00067_1_bWaitForever, F
0091  1D03  	BTFSS STATUS,Z
0092  28A6  	GOTO	label13

		{
			if (nTimeout == 0)							//don't wait forever, so do timeout thing...
0093  08CD  	MOVF FC_CAL_UAR_00067_arg_nTimeout, F
0094  1D03  	BTFSS STATUS,Z
0095  2899  	GOTO	label12
0099        label12

			{
				rxStatus = UART_STATUS_TIMEOUT;
0096  3001  	MOVLW 0x01
0097  00D2  	MOVWF FC_CAL_UAR_00067_1_rxStatus

			}
			else
0098  28A6  	GOTO	label13

			{
				delay_us(10);
0099  300A  	MOVLW 0x0A
009A  00D4  	MOVWF delay_us_00000_arg_del
009B  2010  	CALL delay_us_00000

				delay1 = delay1 + 1;
009C  0A4F  	INCF FC_CAL_UAR_00067_1_delay1, W
009D  00CF  	MOVWF FC_CAL_UAR_00067_1_delay1

				if(delay1 == 100)
009E  084F  	MOVF FC_CAL_UAR_00067_1_delay1, W
009F  3A64  	XORLW 0x64
00A0  1D03  	BTFSS STATUS,Z
00A1  28A6  	GOTO	label13
00A6        label13

				{
					nTimeout = nTimeout - 1;
00A2  034D  	DECF FC_CAL_UAR_00067_arg_nTimeout, W
00A3  00CD  	MOVWF FC_CAL_UAR_00067_arg_nTimeout

					MX_CLEAR_WATCHDOG;
00A4  0064  	CLRWDT

					delay1 = 0;
00A5  01CF  	CLRF FC_CAL_UAR_00067_1_delay1

				}
			}
		}

		#if (MX_UART_CHANNEL_X == 0)
			regcheck = FC_CAL_Bit_In(MX_UART_RX_PORT_1, MX_UART_RX_PIN_1);	//Test for start bit
			if (regcheck == 0)
				rxStatus = UART_STATUS_RXBYTE;
		#endif

		#if (MX_UART_CHANNEL_X == 1)
			regcheck = ts_bit(pir1, RCIF);
00A6  3020  	MOVLW 0x20
00A7  050C  	ANDWF gbl_pir1, W
00A8  00D0  	MOVWF FC_CAL_UAR_00067_1_regcheck

			if (regcheck != 0)
00A9  08D0  	MOVF FC_CAL_UAR_00067_1_regcheck, F
00AA  1903  	BTFSC STATUS,Z
00AB  288D  	GOTO	label11

				rxStatus = UART_STATUS_RXBYTE;
00AC  3002  	MOVLW 0x02
00AD  00D2  	MOVWF FC_CAL_UAR_00067_1_rxStatus

		#endif

		#if (MX_UART_CHANNEL_X == 2)
			regcheck = ts_bit(MX_UART2_PIR, RC2IF);
			if (regcheck != 0)
				rxStatus = UART_STATUS_RXBYTE;
		#endif

	}

	if (rxStatus == UART_STATUS_RXBYTE)
00AF  0852  	MOVF FC_CAL_UAR_00067_1_rxStatus, W
00B0  3A02  	XORLW 0x02
00B1  1D03  	BTFSS STATUS,Z
00B2  28C9  	GOTO	label17

	{
		#if (MX_UART_CHANNEL_X == 0)

			retVal = 0;
			UART_Delay_CAL();

			for (idx = 0; idx < MX_UART_DBITS_X; idx++)
			{
				if (FC_CAL_Bit_In(MX_UART_RX_PORT_X, MX_UART_RX_PIN_X))
					retVal = retVal | (0x01 << idx);

				UART_Delay_CAL();
			}
		#endif

		#if (MX_UART_CHANNEL_X == 1)
			regcheck = ts_bit(rcsta, FERR);
00B3  3004  	MOVLW 0x04
00B4  0518  	ANDWF gbl_rcsta, W
00B5  00D0  	MOVWF FC_CAL_UAR_00067_1_regcheck

			if (regcheck != 0)
00B6  08D0  	MOVF FC_CAL_UAR_00067_1_regcheck, F
00B7  1903  	BTFSC STATUS,Z
00B8  28BC  	GOTO	label15
00BC        label15

			{
				dummy = rcreg;						//need to read the rcreg to clear FERR
00B9  081A  	MOVF gbl_rcreg, W
00BA  00D3  	MOVWF FC_CAL_UAR_00067_1_dummy

				#if (MX_UART_RETURN_X == 1)
					retVal = 0x400;					//Framing Error Flag
				#endif
			}
			else
00BB  28C9  	GOTO	label17

			{
				regcheck = ts_bit(rcsta, OERR);
00BC  3002  	MOVLW 0x02
00BD  0518  	ANDWF gbl_rcsta, W
00BE  00D0  	MOVWF FC_CAL_UAR_00067_1_regcheck

				if (regcheck != 0)
00BF  08D0  	MOVF FC_CAL_UAR_00067_1_regcheck, F
00C0  1903  	BTFSC STATUS,Z
00C1  28C5  	GOTO	label16
00C5        label16

				{
					cr_bit(rcsta, CREN);			//Reset receiver to clear error
00C2  1218  	BCF gbl_rcsta,4

					st_bit(rcsta, CREN);
00C3  1618  	BSF gbl_rcsta,4


					#if (MX_UART_RETURN_X == 1)
						retVal = 0x800;				//Overrun Error Flag
					#endif
				}
				else
00C4  28C9  	GOTO	label17
00C9        label17

				{
					retVal = 0;
00C5  01CE  	CLRF FC_CAL_UAR_00067_1_retVal


					#if (MX_UART_DBITS_X == 9)
						if(ts_bit(rcsta, RX9D))
							retVal = 0x100;
					#endif

					retVal = retVal | rcreg; 			//no error, so rx byte is valid
00C6  081A  	MOVF gbl_rcreg, W
00C7  044E  	IORWF FC_CAL_UAR_00067_1_retVal, W
00C8  00CE  	MOVWF FC_CAL_UAR_00067_1_retVal

				}
			}
		#endif

		#if (MX_UART_CHANNEL_X == 2)
			regcheck = ts_bit(MX_UART2_RCSTA, FERR);
			if (regcheck != 0)
			{
				dummy = MX_UART2_RCREG;			//need to read the rcreg to clear FERR
				#if (MX_UART_RETURN_X == 1)
					retVal = 0x400;					//Framing Error Flag
				#endif
			}
			else
			{
				regcheck = ts_bit(MX_UART2_RCSTA, OERR);
				if (regcheck != 0)
				{
					cr_bit(MX_UART2_RCSTA, CREN);	//Reset receiver to clear error
					st_bit(MX_UART2_RCSTA, CREN);
					#if (MX_UART_RETURN_X == 1)
						retVal = 0x800;				//Overrun Error Flag
					#endif
				}
				else
				{
					retVal = 0;

					#if (MX_UART_DBITS_X == 9)
						if(ts_bit(MX_UART2_RCSTA, RX9D))
							retVal = 0x100;
					#endif

					retVal = retVal | MX_UART2_RCREG; 			//no error, so rx byte is valid
				}
			}

		#endif

		#if (MX_UART_ECHO_X == 1)
			UART_Send(retVal);
		#endif
	}

	#if (MX_UART_FLOWEN_X == 1)
		FC_CAL_Bit_High(MX_UART_RTS_PORT_X, MX_UART_RTS_PIN_X);		//not ready to accept data
	#endif

	return (retVal);
00C9  084E  	MOVF FC_CAL_UAR_00067_1_retVal, W
00CA  00D4  	MOVWF CompTempVarRet2431
00CB  01D5  	CLRF CompTempVarRet2431+D'1'

}
00CC  0008  	RETURN



CALFUNCTION(void, FC_CAL_UART_Delay_, (void))
{
  #if (MX_UART_CHANNEL_X == 0)

	MX_UINT16 delay = MX_SOFT_BAUD_X;

	while (delay > 255)
	{
		delay_us(255);
		delay = delay - 255;
		MX_CLEAR_WATCHDOG;
	}
	delay_us(delay);
	MX_CLEAR_WATCHDOG;

  #endif
}


CALFUNCTION(void, FC_CAL_UART_Update_Baud_, (MX_UINT8 new_baud))
{
	//Baud Rates - Function compatible with hardware mode only
	/*
	0 - 1200
	1 - 2400
	2 - 4800
	3 - 9600
	4 - 19200
	5 - 38400
	6 - 57600
	7 - 115200
	*/

	MX_UINT8 baudrate, baudmode;

	if (new_baud > 7)
		return;

	if (new_baud == 0)
	{
		baudrate = MX_HARD_BAUD_1200;
		baudmode = MX_HARD_SLOW_1200;
	}
	else if (new_baud == 1)
	{
		baudrate = MX_HARD_BAUD_2400;
		baudmode = MX_HARD_SLOW_2400;
	}
	else if (new_baud == 2)
	{
		baudrate = MX_HARD_BAUD_4800;
		baudmode = MX_HARD_SLOW_4800;
	}
	else if (new_baud == 3)
	{
		baudrate = MX_HARD_BAUD_9600;
		baudmode = MX_HARD_SLOW_9600;
	}
	else if (new_baud == 4)
	{
		baudrate = MX_HARD_BAUD_19200;
		baudmode = MX_HARD_SLOW_19200;
	}
	else if (new_baud == 5)
	{
		baudrate = MX_HARD_BAUD_38400;
		baudmode = MX_HARD_SLOW_38400;
	}
	else if (new_baud == 6)
	{
		baudrate = MX_HARD_BAUD_57600;
		baudmode = MX_HARD_SLOW_57600;
	}
	else if (new_baud == 7)
	{
		baudrate = MX_HARD_BAUD_115200;
		baudmode = MX_HARD_SLOW_115200;
	}

	UART_Uninit();

	#if (MX_UART_CHANNEL_X == 1)

	    if (baudmode == 1)
			cr_bit(txsta, BRGH);					//Low Speed
	    else
			st_bit(txsta, BRGH);					//High Speed

		spbrg = baudrate;   						// set the baud rate
		rcsta = 0;                    				// 8-bit, disabled

		#if(MX_UART_DBITS_X == 9)
			st_bit(txsta, TX9);   					// 9-bit TX
			st_bit(rcsta, RX9);                    	// 9-bit RX
		#endif

		st_bit(rcsta, SPEN);         				// turn on serial interface
		st_bit(txsta, TXEN);
		st_bit(rcsta, CREN);

		#if (MX_UART_INT_X == 1)
			MX_UART_INT_CH1_EN;
			st_bit(intcon, PEIE);
			st_bit(intcon, GIE);
		#else
			cr_bit (pie1, RCIE);
		#endif
	#endif

	#if (MX_UART_CHANNEL_X == 2)

	  	if (baudmode == 1)
			cr_bit(MX_UART2_TXSTA, BRGH);			//Low Speed
	  	else
			st_bit(MX_UART2_TXSTA, BRGH);			//High Speed

		spbrg2 = baudrate;   						// set the baud rate
		MX_UART2_RCSTA = 0;                    		// 8-bit, disabled

		#if(MX_UART_DBITS_X == 9)
			st_bit(MX_UART2_TXSTA, TX9);   			// 9-bit TX
			st_bit(MX_UART2_RCSTA, RX9);            // 9-bit RX
		#endif

		st_bit(MX_UART2_RCSTA, SPEN);         		// turn on serial interface
		st_bit(MX_UART2_TXSTA, TXEN);
		st_bit(MX_UART2_RCSTA, CREN);

		#if (MX_UART_INT_X == 1)
			MX_UART_INT_CH2_EN;
			st_bit(intcon, PEIE);
			st_bit(intcon, GIE);
		#else
			cr_bit (MX_UART2_PIE, RC2IE);
		#endif
	#endif

	#if (MX_UART_FLOWEN_X == 1)						//Flowcontrol enabled?
		FC_CAL_Bit_In_DDR (MX_UART_CTS_PORT_X, MX_UART_CTS_TRIS_X, MX_UART_CTS_PIN_X);	// CTS pin is a input
		FC_CAL_Bit_High_DDR (MX_UART_RTS_PORT_X, MX_UART_RTS_TRIS_X, MX_UART_RTS_PIN_X);	// RTS not ready to accept data
	#endif

}

////////////////////////////////////////
// Code with no source :-)
////////////////////////////////////////
0000  158A  	BSF PCLATH,3
0001  2964  	GOTO	_startup

0004  00FF  	MOVWF Int1Context
0005  0E03  	SWAPF STATUS, W
0006  1283  	BCF STATUS, RP0
0007  1303  	BCF STATUS, RP1
0008  00B4  	MOVWF Int1BContext
0009  0E0A  	SWAPF PCLATH, W
000A  00B5  	MOVWF Int1BContext+D'1'
000B  0E04  	SWAPF FSR, W
000C  00B6  	MOVWF Int1BContext+D'2'
000D  158A  	BSF PCLATH,3
000E  120A  	BCF PCLATH,4
000F  29A9  	GOTO	interrupt
0010        delay_us_00000
0010        ; { delay_us ; function begin
0010        label1
0010  0000  	NOP
0011  0000  	NOP
0012  0BD4  	DECFSZ delay_us_00000_arg_del, F
0013  2810  	GOTO	label1
0014  0008  	RETURN
0015        ; } delay_us function end

0015        delay_ms_00000
0015        ; { delay_ms ; function begin
0015  08D4  	MOVF delay_ms_00000_arg_del, F
0016  1D03  	BTFSS STATUS,Z
0017  2819  	GOTO	label2
0018  0008  	RETURN
0019        label2
0019  30F9  	MOVLW 0xF9
001A        label3
001A  0000  	NOP
001B  0000  	NOP
001C  0000  	NOP
001D  0000  	NOP
001E  0000  	NOP
001F  0000  	NOP
0020  0000  	NOP
0021  0000  	NOP
0022  0000  	NOP
0023  0000  	NOP
0024  0000  	NOP
0025  0000  	NOP
0026  0000  	NOP
0027  0000  	NOP
0028  0000  	NOP
0029  0000  	NOP
002A  3EFF  	ADDLW 0xFF
002B  1D03  	BTFSS STATUS,Z
002C  281A  	GOTO	label3
002D  0000  	NOP
002E  0000  	NOP
002F  0000  	NOP
0030  0000  	NOP
0031  0000  	NOP
0032  0000  	NOP
0033  0000  	NOP
0034  0000  	NOP
0035  0000  	NOP
0036  0000  	NOP
0037  0000  	NOP
0038  0000  	NOP
0039  0000  	NOP
003A  0000  	NOP
003B  0000  	NOP
003C  0000  	NOP
003D  0000  	NOP
003E  0BD4  	DECFSZ delay_ms_00000_arg_del, F
003F  2819  	GOTO	label2
0040  0008  	RETURN
0041        ; } delay_ms function end

0041        delay_10us_00000
0041        ; { delay_10us ; function begin
0041  08DF  	MOVF delay_10us_00000_arg_del, F
0042  1D03  	BTFSS STATUS,Z
0043  2845  	GOTO	label4
0044  0008  	RETURN
0045        label4
0045  3009  	MOVLW 0x09
0046        label5
0046  0000  	NOP
0047  3EFF  	ADDLW 0xFF
0048  1D03  	BTFSS STATUS,Z
0049  2846  	GOTO	label5
004A  0000  	NOP
004B  0000  	NOP
004C  0BDF  	DECFSZ delay_10us_00000_arg_del, F
004D  2845  	GOTO	label4
004E  0008  	RETURN
004F        ; } delay_10us function end


0057        __div_16_1_00003
0057        ; { __div_16_16 ; function begin
0057  01D7  	CLRF __div_16_1_00003_1_r
0058  01D8  	CLRF __div_16_1_00003_1_r+D'1'
0059  01DA  	CLRF CompTempVarRet214
005A  01DB  	CLRF CompTempVarRet214+D'1'
005B  01D9  	CLRF __div_16_1_00003_1_i
005C        label7
005C  1A59  	BTFSC __div_16_1_00003_1_i,4
005D  0008  	RETURN
005E  1003  	BCF STATUS,C
005F  0DDA  	RLF CompTempVarRet214, F
0060  0DDB  	RLF CompTempVarRet214+D'1', F
0061  0DD1  	RLF __div_16_1_00003_arg_a, F
0062  0DD2  	RLF __div_16_1_00003_arg_a+D'1', F
0063  0DD7  	RLF __div_16_1_00003_1_r, F
0064  0DD8  	RLF __div_16_1_00003_1_r+D'1', F
0065  0854  	MOVF __div_16_1_00003_arg_b+D'1', W
0066  0258  	SUBWF __div_16_1_00003_1_r+D'1', W
0067  1D03  	BTFSS STATUS,Z
0068  286B  	GOTO	label8
0069  0853  	MOVF __div_16_1_00003_arg_b, W
006A  0257  	SUBWF __div_16_1_00003_1_r, W
006B        label8
006B  1C03  	BTFSS STATUS,C
006C  2874  	GOTO	label9
006D  0853  	MOVF __div_16_1_00003_arg_b, W
006E  02D7  	SUBWF __div_16_1_00003_1_r, F
006F  0854  	MOVF __div_16_1_00003_arg_b+D'1', W
0070  1C03  	BTFSS STATUS,C
0071  03D8  	DECF __div_16_1_00003_1_r+D'1', F
0072  02D8  	SUBWF __div_16_1_00003_1_r+D'1', F
0073  145A  	BSF CompTempVarRet214,0
0074        label9
0074  0AD9  	INCF __div_16_1_00003_1_i, F
0075  285C  	GOTO	label7
0076        ; } __div_16_16 function end


0964        _startup
0964  30D5  	MOVLW 0xD5
0965  1283  	BCF STATUS, RP0
0966  1303  	BCF STATUS, RP1
0967  00A0  	MOVWF gbl_14_LSR
0968  30C4  	MOVLW 0xC4
0969  00A1  	MOVWF gbl_14_LSR+D'1'
096A  30BB  	MOVLW 0xBB
096B  00A2  	MOVWF gbl_14_LSR+D'2'
096C  30DC  	MOVLW 0xDC
096D  00A3  	MOVWF gbl_14_LSR+D'3'
096E  01A4  	CLRF gbl_15_gbl_aSig
096F  01A5  	CLRF gbl_15_gbl_aSig+D'1'
0970  01A6  	CLRF gbl_15_gbl_aSig+D'2'
0971  01A7  	CLRF gbl_15_gbl_aSig+D'3'
0972  01A8  	CLRF gbl_15_gbl_bSig
0973  01A9  	CLRF gbl_15_gbl_bSig+D'1'
0974  01AA  	CLRF gbl_15_gbl_bSig+D'2'
0975  01AB  	CLRF gbl_15_gbl_bSig+D'3'
0976  01AC  	CLRF gbl_15_gbl_zSig
0977  01AD  	CLRF gbl_15_gbl_zSig+D'1'
0978  01AE  	CLRF gbl_15_gbl_zSig+D'2'
0979  01AF  	CLRF gbl_15_gbl_zSig+D'3'
097A  01BC  	CLRF gbl_15_gbl_aExp
097B  01BD  	CLRF gbl_15_gbl_bExp
097C  01B7  	CLRF gbl_15_gbl_zExp
097D  01B8  	CLRF gbl_15_gbl_zExp+D'1'
097E  01BE  	CLRF gbl_15_gbl_aSign
097F  01BF  	CLRF gbl_15_gbl_bSign
0980  01C0  	CLRF gbl_15_gbl_zSign
0981  01C1  	CLRF gbl_15_gbl_zSigZero
0982  01B0  	CLRF gbl_15_gbl_ret
0983  01B1  	CLRF gbl_15_gbl_ret+D'1'
0984  01B2  	CLRF gbl_15_gbl_ret+D'2'
0985  01B3  	CLRF gbl_15_gbl_ret+D'3'
0986  01BA  	CLRF gbl_float_rounding_mode
0987  01BB  	CLRF gbl_float_exception_flags
0988  01B9  	CLRF gbl_float_detect_tininess

09A6  118A  	BCF PCLATH,3
09A7  120A  	BCF PCLATH,4
09A8  2FCE  	GOTO	main

2007  20C2  	DW 0x20C2
2008  3EFF  	DW 0x3EFF
