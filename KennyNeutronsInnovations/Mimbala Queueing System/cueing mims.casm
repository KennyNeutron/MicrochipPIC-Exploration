;/////////////////////////////////////////////////////////////////////////////////
;// Code Generator: BoostC Compiler - http://www.sourceboost.com
;// Version       : 7.03
;// License Type  : Pro License
;// Limitations   : PIC12,PIC16 max code size:Unlimited, max RAM banks:Unlimited
;/////////////////////////////////////////////////////////////////////////////////

//************************************************************************************
//**  
//**  File name:     C:\Users\Acer-PC\Desktop\mimbala cueing\cueing mims.c
//**  Title:         
//**  Description:   
//**  
//**  Generated by:  Flowcode v5.2.0.0
//**  Date:          Sunday, December 02, 2018 19:25:43
//**  Licence:       Professional
//**  Registered to: xyz
//**  Licence key:   WUK7B9
//**  
//**  
//**  http://www.matrixmultimedia.com
//**  
//************************************************************************************


#define MX_PIC

#define MX_USES_UINT8 1
#define MX_USES_SINT16 0
#define MX_USES_CHAR 0
#define MX_USES_FLOAT 0
#define MX_USES_SINT32 0
#define MX_USES_BOOL 1
#define MX_USES_UINT16 1
#define MX_USES_UINT32 0
//Defines for microcontroller
#define P16F690
#define FC_CAL_PIC
#define MX_ADC
#define MX_ADC_TYPE_3
#define MX_ADC_BITS_10
#define MX_EE
#define MX_EE_TYPE2
#define MX_EE_SIZE 256
#define MX_SPI_1
#define MX_SPI_1_MISO_PORT portb
#define MX_SPI_1_MISO_TRIS trisb
#define MX_SPI_1_MISO_PIN 4
#define MX_SPI_1_MOSI_PORT portc
#define MX_SPI_1_MOSI_TRIS trisc
#define MX_SPI_1_MOSI_PIN 7
#define MX_SPI_1_CLK_PORT portb
#define MX_SPI_1_CLK_TRIS trisb
#define MX_SPI_1_CLK_PIN 6
#define MX_SPI_1_SS_PORT portb
#define MX_SPI_1_SS_TRIS trisb
#define MX_UART_1
#define MX_UART_1_TX_PORT portb
#define MX_UART_1_TX_TRIS trisb
#define MX_UART_1_TX_PIN 7
#define MX_UART_1_RX_PORT portb
#define MX_UART_1_RX_TRIS trisb
#define MX_UART_1_RX_PIN 5
#define MX_I2C
#define MX_MI2C
#define MX_I2C_1
#define MX_I2C_1_SDA_PORT portb
#define MX_I2C_1_SDA_TRIS trisb
#define MX_I2C_1_SDA_PIN 4
#define MX_I2C_1_SCL_PORT portb
#define MX_I2C_1_SCL_TRIS trisb
#define MX_I2C_1_SCL_PIN 6
#define MX_PWM
#define MX_PWM_CNT 1
#define MX_PWM_PSCA1
#define MX_PWM_PSCA4
#define MX_PWM_PSCA16
#define MX_PWM_1_PORT portc
#define MX_PWM_1_TRIS trisc
#define MX_PWM_1_PIN 5

//Functions
#define MX_CLK_SPEED 20000000
#ifdef _BOOSTC
#include <system.h>
#endif
#ifdef HI_TECH_C
#include <pic.h>
#endif

//Configuration data
#ifdef _BOOSTC
#pragma DATA 0x2007, 0x30d2
#endif
#ifdef HI_TECH_C
__CONFIG(0x30d2);
#endif

//Internal functions
#include "C:\Program Files (x86)\Flowcode\v5\FCD\internals.c"

//Macro function declarations
void FCM_databank();
void FCM_show_display();
void FCM_register();
void FCM_display_window1();
void FCM_display_window2();
void FCM_display_window3();
void FCM_display_all();


//Variable declarations
#define FCV_TRUE (1)
#define FCV_FALSE (0)
MX_UINT8 FCV_RECIEVE;
MX_UINT8 FCV_DAT;
MX_UINT8 FCV_COUNTER;
MX_UINT16 FCV_WINDOW1;
MX_UINT16 FCV_WINDOW2;
MX_UINT8 FCV_TENS;
MX_UINT16 FCV_WINDOW3;
MX_UINT8 FCV_DISPLAY;
MX_UINT8 FCV_VALUE;
MX_UINT8 FCV_HUNDREDS;
MX_UINT8 FCV_ONES;

MX_UINT8 FCLV_LOOP1;



//RS232(0): //Defines:

/**** Macro Substitutions ****
a = Unique Reference
b = Uart Channel		(0-software / 1-4 hardware)
c = tx pin
d = tx port
e = rx pin
f = rx port
g = flow control		(0-Off / 1-On)
h = cts pin
i = cts port
j = rts pin
k = rts port
l = baud rate
m = data bits			(7/8/9) (7 only supported in software modes)
n = return type		(0-byte / 1-MX_UINT16)
o = echo enable		(0-Off / 1-On)
******************************/

//Definitions for RS232 UART slot allocation
#ifndef	MX_UART_REF1
	#define MX_UART_REF1
	#define RS232_1_MX_UART_UREF			1
	#define MX_UART_CHANNEL_1		1
	#define MX_UART_TX_PIN_1		0
	#define MX_UART_TX_PORT_1		porta
	#define MX_UART_TX_TRIS_1		trisa
	#define MX_UART_RX_PIN_1		0
	#define MX_UART_RX_PORT_1		porta
	#define MX_UART_RX_TRIS_1		trisa
	#define MX_UART_FLOWEN_1		0
	#define MX_UART_CTS_PIN_1		4
	#define MX_UART_CTS_PORT_1		portc
	#define MX_UART_CTS_TRIS_1		trisc
	#define MX_UART_RTS_PIN_1		0
	#define MX_UART_RTS_PORT_1		portc
	#define MX_UART_RTS_TRIS_1		trisc
	#define MX_UART_BAUD_1			9600
	#define MX_UART_DBITS_1			8
	#define MX_UART_RETURN_1		0
	#define MX_UART_ECHO_1			0
	#define MX_UART_INT_1			0
#else
 #ifndef	MX_UART_REF2
	#define MX_UART_REF2
	#define RS232_1_MX_UART_UREF			2
	#define MX_UART_CHANNEL_2		1
	#define MX_UART_TX_PIN_2		0
	#define MX_UART_TX_PORT_2		porta
	#define MX_UART_TX_TRIS_2		trisa
	#define MX_UART_RX_PIN_2		0
	#define MX_UART_RX_PORT_2		porta
	#define MX_UART_RX_TRIS_2		trisa
	#define MX_UART_FLOWEN_2		0
	#define MX_UART_CTS_PIN_2		4
	#define MX_UART_CTS_PORT_2		portc
	#define MX_UART_CTS_TRIS_2		trisc
	#define MX_UART_RTS_PIN_2		0
	#define MX_UART_RTS_PORT_2		portc
	#define MX_UART_RTS_TRIS_2		trisc
	#define MX_UART_BAUD_2			9600
	#define MX_UART_DBITS_2			8
	#define MX_UART_RETURN_2		0
	#define MX_UART_ECHO_2			0
	#define MX_UART_INT_2			0
 #else
  #ifndef	MX_UART_REF3
	#define MX_UART_REF3
	#define RS232_1_MX_UART_UREF			3
	#define MX_UART_CHANNEL_3		1
	#define MX_UART_TX_PIN_3		0
	#define MX_UART_TX_PORT_3		porta
	#define MX_UART_TX_TRIS_3		trisa
	#define MX_UART_RX_PIN_3		0
	#define MX_UART_RX_PORT_3		porta
	#define MX_UART_RX_TRIS_3		trisa
	#define MX_UART_FLOWEN_3		0
	#define MX_UART_CTS_PIN_3		4
	#define MX_UART_CTS_PORT_3		portc
	#define MX_UART_CTS_TRIS_3		trisc
	#define MX_UART_RTS_PIN_3		0
	#define MX_UART_RTS_PORT_3		portc
	#define MX_UART_RTS_TRIS_3		trisc
	#define MX_UART_BAUD_3			9600
	#define MX_UART_DBITS_3			8
	#define MX_UART_RETURN_3		0
	#define MX_UART_ECHO_3			0
	#define MX_UART_INT_3			0
  #else
   #ifndef	MX_UART_REF4
	#define MX_UART_REF4
	#define RS232_1_MX_UART_UREF			4
	#define MX_UART_CHANNEL_4		1
	#define MX_UART_TX_PIN_4		0
	#define MX_UART_TX_PORT_4		porta
	#define MX_UART_TX_TRIS_4		trisa
	#define MX_UART_RX_PIN_4		0
	#define MX_UART_RX_PORT_4		porta
	#define MX_UART_RX_TRIS_4		trisa
	#define MX_UART_FLOWEN_4		0
	#define MX_UART_CTS_PIN_4		4
	#define MX_UART_CTS_PORT_4		portc
	#define MX_UART_CTS_TRIS_4		trisc
	#define MX_UART_RTS_PIN_4		0
	#define MX_UART_RTS_PORT_4		portc
	#define MX_UART_RTS_TRIS_4		trisc
	#define MX_UART_BAUD_4			9600
	#define MX_UART_DBITS_4			8
	#define MX_UART_RETURN_4		0
	#define MX_UART_ECHO_4			0
	#define MX_UART_INT_4			0
   #endif
  #endif
 #endif
#endif

#define RS232_1_UART_Init		CAL_APPEND(FC_CAL_UART_Init_, RS232_1_MX_UART_UREF)
#define RS232_1_UART_Send		CAL_APPEND(FC_CAL_UART_Send_, RS232_1_MX_UART_UREF)
#define RS232_1_UART_Receive		CAL_APPEND(FC_CAL_UART_Receive_, RS232_1_MX_UART_UREF)
#define RS232_1_UART_Update_Baud CAL_APPEND(FC_CAL_UART_Update_Baud_, RS232_1_MX_UART_UREF)

extern void RS232_1_UART_Init();
extern void RS232_1_UART_Send(MX_UINT16 nChar);
extern MX_SINT16 RS232_1_UART_Receive(MX_UINT8 nTimeout);
extern void RS232_1_UART_Update_Baud(MX_UINT8 newbaud);




//RS232(0): //Macro function declarations

void FCD_RS2320_SendRS232Char(MX_SINT16 nChar);
void FCD_RS2320_SendRS232String(MX_STRING String, MX_UINT8 MSZ_String);
MX_SINT16 FCD_RS2320_ReceiveRS232Char(MX_UINT8 nTimeout);
void FCD_RS2320_ReceiveRS232String(MX_CHAR* FCR_RETVAL, MX_UINT8 FCR_RETVAL_SIZE, MX_UINT8 nTimeout, MX_UINT8 NumBytes);
void FCD_RS2320_ChangeHWBaud(MX_UINT8 newbaud);



//RS232(0): //Macro implementations


void FCD_RS2320_SendRS232Char(MX_SINT16 nChar)
{
	
		RS232_1_UART_Send ( nChar);

}

void FCD_RS2320_SendRS232String(MX_STRING String, MX_UINT8 MSZ_String)
{
	
		MX_UINT8 idx;
		for(idx = 0; idx < MSZ_String; idx++)
		{
			if (String[idx] == 0)
				break;
			else RS232_1_UART_Send ( String[idx] );
		}

}

MX_SINT16 FCD_RS2320_ReceiveRS232Char(MX_UINT8 nTimeout)

{
	
		return ( RS232_1_UART_Receive ( nTimeout) );
0157  0850  	MOVF FCD_RS2320_0005F_arg_nTimeout, W
0158  00D1  	MOVWF FC_CAL_UAR_0005A_arg_nTimeout
0159  2015  	CALL FC_CAL_UAR_0005A
015A  0858  	MOVF CompTempVarRet2192, W
015B  00D2  	MOVWF CompTempVarRet2197
015C  0859  	MOVF CompTempVarRet2192+D'1', W
015D  00D3  	MOVWF CompTempVarRet2197+D'1'


}
015E  0008  	RETURN


void FCD_RS2320_ReceiveRS232String(MX_CHAR* FCR_RETVAL, MX_UINT8 FCR_RETVAL_SIZE, MX_UINT8 nTimeout, MX_UINT8 NumBytes)
{
	
		MX_UINT8 idx;
		MX_SINT16 RS232_TO = 255;
		MX_SINT16 in;

		if ( 0 != 0 )
			RS232_TO = 256;

		if (NumBytes > FCR_RETVAL_SIZE)
			NumBytes = FCR_RETVAL_SIZE;

		for (idx = 0; idx < NumBytes; idx++)
		{
			in = RS232_1_UART_Receive ( nTimeout);
			if(in < RS232_TO)
				FCR_RETVAL[idx] = in & 0xFF;
			else
				break;
		}

		if (idx < FCR_RETVAL_SIZE)
			FCR_RETVAL[idx] = 0;

}

void FCD_RS2320_ChangeHWBaud(MX_UINT8 newbaud)
{
	
		RS232_1_UART_Update_Baud (newbaud);

}

#include "C:\Program Files (x86)\Flowcode\v5\CAL\includes.c"

//Macro implementations


void FCM_databank()

{

	//Switch
	//Switch: display?
	switch (FCV_DISPLAY)

	{
		case 1:
00B6  1283  	BCF STATUS, RP0
00B7  1303  	BCF STATUS, RP1
00B8  084B  	MOVF gbl_FCV_DISPLAY, W
00B9  3A01  	XORLW 0x01
00BA  1903  	BTFSC STATUS,Z
00BB  28D8  	GOTO	label12
00D8        label12

		{
			//Calculation
			//Calculation:
			//  value = 0b10011111
			FCV_VALUE = 159;
00D8  309F  	MOVLW 0x9F
00D9  00CC  	MOVWF gbl_FCV_VALUE


			break;

		}
		case 2:
00BC  3A03  	XORLW 0x03
00BD  1903  	BTFSC STATUS,Z
00BE  28DB  	GOTO	label13
00DB        label13

		{
			//Calculation
			//Calculation:
			//  value = 0b00100101
			FCV_VALUE = 37;
00DB  3025  	MOVLW 0x25
00DC  00CC  	MOVWF gbl_FCV_VALUE


			break;

		}
		case 3:
00BF  3A01  	XORLW 0x01
00C0  1903  	BTFSC STATUS,Z
00C1  28DE  	GOTO	label14
00DE        label14

		{
			//Calculation
			//Calculation:
			//  value = 0b00001101
			FCV_VALUE = 13;
00DE  300D  	MOVLW 0x0D
00DF  00CC  	MOVWF gbl_FCV_VALUE


			break;

		}
		case 4:
00C2  3A07  	XORLW 0x07
00C3  1903  	BTFSC STATUS,Z
00C4  28E1  	GOTO	label15
00E1        label15

		{
			//Calculation
			//Calculation:
			//  value = 0b10011001
			FCV_VALUE = 153;
00E1  3099  	MOVLW 0x99
00E2  00CC  	MOVWF gbl_FCV_VALUE


			break;

		}
		case 5:
00C5  3A01  	XORLW 0x01
00C6  1903  	BTFSC STATUS,Z
00C7  28E4  	GOTO	label16
00E4        label16

		{
			//Calculation
			//Calculation:
			//  value = 0b01001001
			FCV_VALUE = 73;
00E4  3049  	MOVLW 0x49
00E5  00CC  	MOVWF gbl_FCV_VALUE


			break;

		}
		case 6:
00C8  3A03  	XORLW 0x03
00C9  1903  	BTFSC STATUS,Z
00CA  28E7  	GOTO	label17
00E7        label17

		{
			//Calculation
			//Calculation:
			//  value = 0b01000001
			FCV_VALUE = 65;
00E7  3041  	MOVLW 0x41
00E8  00CC  	MOVWF gbl_FCV_VALUE


			break;

		}
		case 7:
00CB  3A01  	XORLW 0x01
00CC  1903  	BTFSC STATUS,Z
00CD  28EA  	GOTO	label18
00EA        label18

		{
			//Calculation
			//Calculation:
			//  value = 0b00011111
			FCV_VALUE = 31;
00EA  301F  	MOVLW 0x1F
00EB  00CC  	MOVWF gbl_FCV_VALUE


			break;

		}
		case 8:
00CE  3A0F  	XORLW 0x0F
00CF  1903  	BTFSC STATUS,Z
00D0  28ED  	GOTO	label19
00ED        label19

		{
			//Calculation
			//Calculation:
			//  value = 0b00000001
			FCV_VALUE = 1;
00ED  3001  	MOVLW 0x01
00EE  00CC  	MOVWF gbl_FCV_VALUE


			break;

		}
		case 9:
00D1  3A01  	XORLW 0x01
00D2  1903  	BTFSC STATUS,Z
00D3  28F0  	GOTO	label20
00F0        label20

		{
			//Calculation
			//Calculation:
			//  value = 0b00001001
			FCV_VALUE = 9;
00F0  3009  	MOVLW 0x09
00F1  00CC  	MOVWF gbl_FCV_VALUE


			break;

		}
		case 0:
00D4  3A09  	XORLW 0x09
00D5  1903  	BTFSC STATUS,Z
00D6  28F3  	GOTO	label21
00F3        label21

		{
			//Calculation
			//Calculation:
			//  value = 0b00000011
			FCV_VALUE = 3;
00F3  3003  	MOVLW 0x03
00F4  00CC  	MOVWF gbl_FCV_VALUE


			break;

		}
		// default:

	}

}
00D7  0008  	RETURN
00DA  0008  	RETURN
00DD  0008  	RETURN
00E0  0008  	RETURN
00E3  0008  	RETURN
00E6  0008  	RETURN
00E9  0008  	RETURN
00EC  0008  	RETURN
00EF  0008  	RETURN
00F2  0008  	RETURN
00F5  0008  	RETURN



void FCM_show_display()

{

	//Loop
	//Loop: Loop 8 times
	for (FCLV_LOOP1=0; FCLV_LOOP1<8; FCLV_LOOP1++)
0061  1283  	BCF STATUS, RP0
0062  1303  	BCF STATUS, RP1
0063  01CF  	CLRF gbl_FCLV_LOOP1
0064        label9
0064  3008  	MOVLW 0x08
0065  024F  	SUBWF gbl_FCLV_LOOP1, W
0066  1803  	BTFSC STATUS,C
0099  0ACF  	INCF gbl_FCLV_LOOP1, F
009A  2864  	GOTO	label9

	{

		//Calculation
		//Calculation:
		//  dat = value AND 1
		//  value = value >> 1
		FCV_DAT = FCV_VALUE & 1;
0068  3001  	MOVLW 0x01
0069  054C  	ANDWF gbl_FCV_VALUE, W
006A  00C9  	MOVWF gbl_FCV_DAT

		FCV_VALUE = FCV_VALUE >> 1;
006B  08CC  	MOVF gbl_FCV_VALUE, F
006C  1003  	BCF STATUS,C
006D  0CCC  	RRF gbl_FCV_VALUE, F


		//Output
		//Output: dat -> C0
		trisc = trisc & 0xFE;
006E  30FE  	MOVLW 0xFE
006F  1683  	BSF STATUS, RP0
0070  0507  	ANDWF gbl_trisc, W
0071  0087  	MOVWF gbl_trisc

		if ((FCV_DAT))
0072  1283  	BCF STATUS, RP0
0073  08C9  	MOVF gbl_FCV_DAT, F
0074  1903  	BTFSC STATUS,Z
0075  287D  	GOTO	label10
007D        label10

			portc = (portc & 0xFE) | 0x01;
0076  30FE  	MOVLW 0xFE
0077  0507  	ANDWF gbl_portc, W
0078  00D0  	MOVWF CompTempVar2189
0079  3001  	MOVLW 0x01
007A  0450  	IORWF CompTempVar2189, W
007B  0087  	MOVWF gbl_portc

		else
007C  2880  	GOTO	label11
0080        label11

			portc = portc & 0xFE;
007D  30FE  	MOVLW 0xFE
007E  0507  	ANDWF gbl_portc, W
007F  0087  	MOVWF gbl_portc


		//clk
		//Output: 1 -> C1
		trisc = trisc & 0xFD;
0080  30FD  	MOVLW 0xFD
0081  1683  	BSF STATUS, RP0
0082  0507  	ANDWF gbl_trisc, W
0083  0087  	MOVWF gbl_trisc

		if ((1))
			portc = (portc & 0xFD) | 0x02;
0084  30FD  	MOVLW 0xFD
0085  1283  	BCF STATUS, RP0
0086  0507  	ANDWF gbl_portc, W
0087  00D0  	MOVWF CompTempVar2190
0088  3002  	MOVLW 0x02
0089  0450  	IORWF CompTempVar2190, W
008A  0087  	MOVWF gbl_portc

		else
			portc = portc & 0xFD;

		//Delay
		//Delay: 1 us
		delay_us(1);
008B  3001  	MOVLW 0x01
008C  00D8  	MOVWF delay_us_00000_arg_del
008D  2010  	CALL delay_us_00000


		//clk
		//Output: 0 -> C1
		trisc = trisc & 0xFD;
008E  30FD  	MOVLW 0xFD
008F  1683  	BSF STATUS, RP0
0090  0507  	ANDWF gbl_trisc, W
0091  0087  	MOVWF gbl_trisc

		if ((0))
			portc = (portc & 0xFD) | 0x02;
		else
			portc = portc & 0xFD;
0092  30FD  	MOVLW 0xFD
0093  1283  	BCF STATUS, RP0
0094  0507  	ANDWF gbl_portc, W
0095  0087  	MOVWF gbl_portc


		//Delay
		//Delay: 1 us
		delay_us(1);
0096  3001  	MOVLW 0x01
0097  00D8  	MOVWF delay_us_00000_arg_del
0098  2010  	CALL delay_us_00000



	}

}
0067  0008  	RETURN



void FCM_register()

{

	//reg
	//Output: 1 -> C2
	trisc = trisc & 0xFB;
009B  30FB  	MOVLW 0xFB
009C  1683  	BSF STATUS, RP0
009D  1303  	BCF STATUS, RP1
009E  0507  	ANDWF gbl_trisc, W
009F  0087  	MOVWF gbl_trisc

	if ((1))
		portc = (portc & 0xFB) | 0x04;
00A0  30FB  	MOVLW 0xFB
00A1  1283  	BCF STATUS, RP0
00A2  0507  	ANDWF gbl_portc, W
00A3  00D0  	MOVWF CompTempVar2191
00A4  3004  	MOVLW 0x04
00A5  0450  	IORWF CompTempVar2191, W
00A6  0087  	MOVWF gbl_portc

	else
		portc = portc & 0xFB;

	//Delay
	//Delay: 1 us
	delay_us(1);
00A7  3001  	MOVLW 0x01
00A8  00D8  	MOVWF delay_us_00000_arg_del
00A9  2010  	CALL delay_us_00000


	//reg
	//Output: 0 -> C2
	trisc = trisc & 0xFB;
00AA  30FB  	MOVLW 0xFB
00AB  1683  	BSF STATUS, RP0
00AC  0507  	ANDWF gbl_trisc, W
00AD  0087  	MOVWF gbl_trisc

	if ((0))
		portc = (portc & 0xFB) | 0x04;
	else
		portc = portc & 0xFB;
00AE  30FB  	MOVLW 0xFB
00AF  1283  	BCF STATUS, RP0
00B0  0507  	ANDWF gbl_portc, W
00B1  0087  	MOVWF gbl_portc


	//Delay
	//Delay: 1 us
	delay_us(1);
00B2  3001  	MOVLW 0x01
00B3  00D8  	MOVWF delay_us_00000_arg_del
00B4  2010  	CALL delay_us_00000


}
00B5  0008  	RETURN



void FCM_display_window1()

{

	//Calculation
	//Calculation:
	//  display = 1
	FCV_DISPLAY = 1;
0143  3001  	MOVLW 0x01
0144  1283  	BCF STATUS, RP0
0145  1303  	BCF STATUS, RP1
0146  00CB  	MOVWF gbl_FCV_DISPLAY


	//Call Macro
	//Call Macro: databank()
	FCM_databank();
0147  20B6  	CALL FCM_databa_00051


	//Call Macro
	//Call Macro: show_display()
	FCM_show_display();
0148  2061  	CALL FCM_show_d_00052


	//Calculation
	//Calculation:
	//  display = ones
	FCV_DISPLAY = FCV_ONES;
0149  084E  	MOVF gbl_FCV_ONES, W
014A  00CB  	MOVWF gbl_FCV_DISPLAY


	//Call Macro
	//Call Macro: databank()
	FCM_databank();
014B  20B6  	CALL FCM_databa_00051


	//Call Macro
	//Call Macro: show_display()
	FCM_show_display();
014C  2061  	CALL FCM_show_d_00052


	//Calculation
	//Calculation:
	//  display = tens
	FCV_DISPLAY = FCV_TENS;
014D  084A  	MOVF gbl_FCV_TENS, W
014E  00CB  	MOVWF gbl_FCV_DISPLAY


	//Call Macro
	//Call Macro: databank()
	FCM_databank();
014F  20B6  	CALL FCM_databa_00051


	//Call Macro
	//Call Macro: show_display()
	FCM_show_display();
0150  2061  	CALL FCM_show_d_00052


	//Calculation
	//Calculation:
	//  display = hundreds
	FCV_DISPLAY = FCV_HUNDREDS;
0151  084D  	MOVF gbl_FCV_HUNDREDS, W
0152  00CB  	MOVWF gbl_FCV_DISPLAY


	//Call Macro
	//Call Macro: databank()
	FCM_databank();
0153  20B6  	CALL FCM_databa_00051


	//Call Macro
	//Call Macro: show_display()
	FCM_show_display();
0154  2061  	CALL FCM_show_d_00052


	//Call Macro
	//Call Macro: register()
	FCM_register();
0155  209B  	CALL FCM_regist_00053


}
0156  0008  	RETURN



void FCM_display_window2()
{

	//Calculation
	//Calculation:
	//  display = 2
	FCV_DISPLAY = 2;

	//Call Macro
	//Call Macro: databank()
	FCM_databank();

	//Call Macro
	//Call Macro: show_display()
	FCM_show_display();

	//Calculation
	//Calculation:
	//  display = ones
	FCV_DISPLAY = FCV_ONES;

	//Call Macro
	//Call Macro: databank()
	FCM_databank();

	//Call Macro
	//Call Macro: show_display()
	FCM_show_display();

	//Calculation
	//Calculation:
	//  display = tens
	FCV_DISPLAY = FCV_TENS;

	//Call Macro
	//Call Macro: databank()
	FCM_databank();

	//Call Macro
	//Call Macro: show_display()
	FCM_show_display();

	//Calculation
	//Calculation:
	//  display = hundreds
	FCV_DISPLAY = FCV_HUNDREDS;

	//Call Macro
	//Call Macro: databank()
	FCM_databank();

	//Call Macro
	//Call Macro: show_display()
	FCM_show_display();

	//Call Macro
	//Call Macro: register()
	FCM_register();

}


void FCM_display_window3()
{

	//Calculation
	//Calculation:
	//  display = 3
	FCV_DISPLAY = 3;

	//Call Macro
	//Call Macro: databank()
	FCM_databank();

	//Call Macro
	//Call Macro: show_display()
	FCM_show_display();

	//Calculation
	//Calculation:
	//  display = ones
	FCV_DISPLAY = FCV_ONES;

	//Call Macro
	//Call Macro: databank()
	FCM_databank();

	//Call Macro
	//Call Macro: show_display()
	FCM_show_display();

	//Calculation
	//Calculation:
	//  display = tens
	FCV_DISPLAY = FCV_TENS;

	//Call Macro
	//Call Macro: databank()
	FCM_databank();

	//Call Macro
	//Call Macro: show_display()
	FCM_show_display();

	//Calculation
	//Calculation:
	//  display = hundreds
	FCV_DISPLAY = FCV_HUNDREDS;

	//Call Macro
	//Call Macro: databank()
	FCM_databank();

	//Call Macro
	//Call Macro: show_display()
	FCM_show_display();

	//Call Macro
	//Call Macro: register()
	FCM_register();

}


void FCM_display_all()
{

	//Calculation
	//Calculation:
	//  hundreds = window1 / 100
	//  tens = (window1 % 100) / 10
	//  ones = window1 % 10
	FCV_HUNDREDS = FCV_WINDOW1 / 100;
	FCV_TENS = (FCV_WINDOW1 % 100) / 10;
	FCV_ONES = FCV_WINDOW1 % 10;

	//Call Macro
	//Call Macro: display_window1()
	FCM_display_window1();

	//Delay
	//Delay: 800 ms
	delay_ms(255);
	delay_ms(255);
	delay_ms(255);
	delay_ms(35);

	//Calculation
	//Calculation:
	//  hundreds = window2 / 100
	//  tens = (window2 % 100) / 10
	//  ones = window2 % 10
	FCV_HUNDREDS = FCV_WINDOW2 / 100;
	FCV_TENS = (FCV_WINDOW2 % 100) / 10;
	FCV_ONES = FCV_WINDOW2 % 10;

	//Call Macro
	//Call Macro: display_window2()
	FCM_display_window2();

	//Delay
	//Delay: 800 ms
	delay_ms(255);
	delay_ms(255);
	delay_ms(255);
	delay_ms(35);

	//Calculation
	//Calculation:
	//  hundreds = window3 / 100
	//  tens = (window3 % 100) / 10
	//  ones = window3 % 10
	FCV_HUNDREDS = FCV_WINDOW3 / 100;
	FCV_TENS = (FCV_WINDOW3 % 100) / 10;
	FCV_ONES = FCV_WINDOW3 % 10;

	//Call Macro
	//Call Macro: display_window3()
	FCM_display_window3();

	//Delay
	//Delay: 800 ms
	delay_ms(255);
	delay_ms(255);
	delay_ms(255);
	delay_ms(35);

}



void main()

{
	//Initialization
	ansel = 0;
015F  1283  	BCF STATUS, RP0
0160  1703  	BSF STATUS, RP1
0161  019E  	CLRF gbl_ansel

anselh = 0;
0162  019F  	CLRF gbl_anselh


	
		RS232_1_UART_Init( );		//Call initialise function
0163  2134  	CALL FC_CAL_UAR_00058



	//Interrupt initialization code
	option_reg = 0xC0;
0164  30C0  	MOVLW 0xC0
0165  0081  	MOVWF gbl_option_reg



	//Comment:
	//C0-dat
	//C1-clk
	//C2-reg

	//clk
	//Output: 0 -> C1
	trisc = trisc & 0xFD;
0166  30FD  	MOVLW 0xFD
0167  0507  	ANDWF gbl_trisc, W
0168  0087  	MOVWF gbl_trisc

	if ((0))
		portc = (portc & 0xFD) | 0x02;
	else
		portc = portc & 0xFD;
0169  30FD  	MOVLW 0xFD
016A  1283  	BCF STATUS, RP0
016B  0507  	ANDWF gbl_portc, W
016C  0087  	MOVWF gbl_portc


	//reg
	//Output: 0 -> C2
	trisc = trisc & 0xFB;
016D  30FB  	MOVLW 0xFB
016E  1683  	BSF STATUS, RP0
016F  0507  	ANDWF gbl_trisc, W
0170  0087  	MOVWF gbl_trisc

	if ((0))
		portc = (portc & 0xFB) | 0x04;
	else
		portc = portc & 0xFB;
0171  30FB  	MOVLW 0xFB
0172  1283  	BCF STATUS, RP0
0173  0507  	ANDWF gbl_portc, W
0174  0087  	MOVWF gbl_portc


	//Calculation
	//Calculation:
	//  window1 = 123
	//  window2 = 345
	//  window3 = 567
	FCV_WINDOW1 = 123;
0175  307B  	MOVLW 0x7B
0176  00B9  	MOVWF gbl_FCV_WINDOW1
0177  01BA  	CLRF gbl_FCV_WINDOW1+D'1'

	FCV_WINDOW2 = 345;
0178  3059  	MOVLW 0x59
0179  00BB  	MOVWF gbl_FCV_WINDOW2
017A  3001  	MOVLW 0x01
017B  00BC  	MOVWF gbl_FCV_WINDOW2+D'1'

	FCV_WINDOW3 = 567;
017C  3037  	MOVLW 0x37
017D  00BD  	MOVWF gbl_FCV_WINDOW3
017E  3002  	MOVLW 0x02
017F  00BE  	MOVWF gbl_FCV_WINDOW3+D'1'


	//Loop
	//Loop: While 1
	while (1)
0180        label28
01B5  2980  	GOTO	label28

	{

		//Call Component Macro
		//Call Component Macro: recieve=ReceiveRS232Char(1)
		FCV_RECIEVE = FCD_RS2320_ReceiveRS232Char(1);
0180  3001  	MOVLW 0x01
0181  00D0  	MOVWF FCD_RS2320_0005F_arg_nTimeout
0182  2157  	CALL FCD_RS2320_0005F
0183  0852  	MOVF CompTempVarRet2197, W
0184  00C8  	MOVWF gbl_FCV_RECIEVE


		//Decision
		//Decision: recieve = 'A'?
		if (FCV_RECIEVE == 'A')
0185  0848  	MOVF gbl_FCV_RECIEVE, W
0186  3A41  	XORLW 0x41
0187  1D03  	BTFSS STATUS,Z
0188  298E  	GOTO	label29

		{

			//Calculation
			//Calculation:
			//  window1 = window1 + 1
			FCV_WINDOW1 = FCV_WINDOW1 + 1;
0189  08B9  	MOVF gbl_FCV_WINDOW1, F
018A  08BA  	MOVF gbl_FCV_WINDOW1+D'1', F
018B  0AB9  	INCF gbl_FCV_WINDOW1, F
018C  1903  	BTFSC STATUS,Z
018D  0ABA  	INCF gbl_FCV_WINDOW1+D'1', F
018E        label29


		// } else {

		}

		//Calculation
		//Calculation:
		//  hundreds = window1 / 100
		//  tens = (window1 % 100) / 10
		//  ones = window1 % 10
		FCV_HUNDREDS = FCV_WINDOW1 / 100;
018E  0839  	MOVF gbl_FCV_WINDOW1, W
018F  00D4  	MOVWF __div_16_1_00003_arg_a
0190  083A  	MOVF gbl_FCV_WINDOW1+D'1', W
0191  00D5  	MOVWF __div_16_1_00003_arg_a+D'1'
0192  3064  	MOVLW 0x64
0193  00D6  	MOVWF __div_16_1_00003_arg_b
0194  01D7  	CLRF __div_16_1_00003_arg_b+D'1'
0195  2115  	CALL __div_16_1_00003
0196  085B  	MOVF CompTempVarRet214, W
0197  00CD  	MOVWF gbl_FCV_HUNDREDS

		FCV_TENS = (FCV_WINDOW1 % 100) / 10;
0198  0839  	MOVF gbl_FCV_WINDOW1, W
0199  00D0  	MOVWF __rem_16_1_00004_arg_a
019A  083A  	MOVF gbl_FCV_WINDOW1+D'1', W
019B  00D1  	MOVWF __rem_16_1_00004_arg_a+D'1'
019C  3064  	MOVLW 0x64
019D  00D2  	MOVWF __rem_16_1_00004_arg_b
019E  01D3  	CLRF __rem_16_1_00004_arg_b+D'1'
019F  20F6  	CALL __rem_16_1_00004
01A0  085B  	MOVF CompTempVarRet216, W
01A1  00D4  	MOVWF __div_16_1_00003_arg_a
01A2  085C  	MOVF CompTempVarRet216+D'1', W
01A3  00D5  	MOVWF __div_16_1_00003_arg_a+D'1'
01A4  300A  	MOVLW 0x0A
01A5  00D6  	MOVWF __div_16_1_00003_arg_b
01A6  01D7  	CLRF __div_16_1_00003_arg_b+D'1'
01A7  2115  	CALL __div_16_1_00003
01A8  085B  	MOVF CompTempVarRet214, W
01A9  00CA  	MOVWF gbl_FCV_TENS

		FCV_ONES = FCV_WINDOW1 % 10;
01AA  0839  	MOVF gbl_FCV_WINDOW1, W
01AB  00D0  	MOVWF __rem_16_1_00004_arg_a
01AC  083A  	MOVF gbl_FCV_WINDOW1+D'1', W
01AD  00D1  	MOVWF __rem_16_1_00004_arg_a+D'1'
01AE  300A  	MOVLW 0x0A
01AF  00D2  	MOVWF __rem_16_1_00004_arg_b
01B0  01D3  	CLRF __rem_16_1_00004_arg_b+D'1'
01B1  20F6  	CALL __rem_16_1_00004
01B2  085B  	MOVF CompTempVarRet216, W
01B3  00CE  	MOVWF gbl_FCV_ONES


		//Call Macro
		//Call Macro: display_window1()
		FCM_display_window1();
01B4  2143  	CALL FCM_displa_00054



	}

	mainendloop: goto mainendloop;
}


void MX_INTERRUPT_MACRO(void)

{
}
01DE  1283  	BCF STATUS, RP0
01DF  1303  	BCF STATUS, RP1
01E0  0E36  	SWAPF Int1BContext+D'2', W
01E1  0084  	MOVWF FSR
01E2  0E35  	SWAPF Int1BContext+D'1', W
01E3  008A  	MOVWF PCLATH
01E4  0E34  	SWAPF Int1BContext, W
01E5  0083  	MOVWF STATUS
01E6  0EFF  	SWAPF Int1Context, F
01E7  0E7F  	SWAPF Int1Context, W
01E8  0009  	RETFIE





/*********************************************************************
 *                  Flowcode CAL UART File
 *
 * File: PIC_CAL_UART.c
 *
 * (c) 2011 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * “Company”) for its Flowcode graphical programming language is
 * intended and supplied to you, the Company’s customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 010911 | BR | Created
 * 020911 | BR | Updated variables with typedef alternatives
 * 011211 | BR | Converted to new dynamic defines mechanism
 * 160112 | BR | Fixed issues with rx return type and low bauds on fast devices
 * 020212 | ST | Added <MX_UART_2_PIE4> routing to account for differences in 16F and 18F devices with 2 UARTs
 * 270212 | BR | Fixed a bug in the receive functionality
 * 280212 | BR | Sorted out auto echo functionality
 * 160412 | BR | Addition of HW change baud function
 */



#ifndef MX_UART_SW_DEFS
	#define MX_UART_SW_DEFS

	#ifdef _BOOSTC
		#define INST_COUNT	45	//65 for lower speeds or 40 for higher speeds.
	#endif
	#ifdef HI_TECH_C
		#define INST_COUNT	315
	#endif

	//Work out number of nops for software baud rate
	#define MX_INSTRUCTION_SPEED 	(MX_CLK_SPEED / 4)
	#define MX_OVERHEAD				(MX_INSTRUCTION_SPEED / INST_COUNT)
	#define SW_OFFSET				(1000000 / MX_OVERHEAD)

	//Work out software baud rates if required
	#define SW_1200_BAUD	(832 - SW_OFFSET)
	#define SW_2400_BAUD	(416 - SW_OFFSET)
	#define SW_4800_BAUD	(208 - SW_OFFSET)
	#define SW_9600_BAUD	(104 - SW_OFFSET)
	#define SW_19200_BAUD	(52 - SW_OFFSET)
	#define SW_31250_BAUD	(32 - SW_OFFSET)
	#define SW_115200_BAUD	(8 - SW_OFFSET)
#endif

 #if defined(MX_UART_CHANNEL_1) && (MX_UART_NUM==1)
	#if (MX_UART_CHANNEL_1 == 0)
		#if (MX_UART_BAUD_1 == 1200)
			#define MX_SOFT_BAUD_1	SW_1200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 1200 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_1 == 2400)
			#define MX_SOFT_BAUD_1	SW_2400_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 2400 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_1 == 4800)
			#define MX_SOFT_BAUD_1	SW_4800_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 4800 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_1 == 9600)
			#define MX_SOFT_BAUD_1	SW_9600_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 9600 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_1 == 19200)
			#define MX_SOFT_BAUD_1	SW_19200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 19200 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_1 == 31250)
			#define MX_SOFT_BAUD_1	SW_31250_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 31250 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_1 == 115200)
			#define MX_SOFT_BAUD_1	SW_115200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 115200 Not Available At This Clock Speed"
			#endif
		#endif
		#ifndef MX_SOFT_BAUD_1
			#error "UART Baud Rate not supported in Software Mode"
		#endif
	#else
		#define MX_SOFT_BAUD_1	1
		#define MX_HARD_BAUD_1	(((MX_CLK_SPEED / MX_UART_BAUD_1) - 16) / 16)
		#define MX_HARD_SLOW_1	0

		#if (MX_HARD_BAUD_1 > 255)
			#undef MX_HARD_BAUD_1
			#undef MX_HARD_SLOW_1
			#define MX_HARD_BAUD_1	(((MX_CLK_SPEED / MX_UART_BAUD_1) - 16)	/ 64)
			#define MX_HARD_SLOW_1	1
		#endif

	#endif
 #endif
 #if defined(MX_UART_CHANNEL_2) && (MX_UART_NUM==2)
	#if (MX_UART_CHANNEL_2 == 0)
		#if (MX_UART_BAUD_2 == 1200)
			#define MX_SOFT_BAUD_2	SW_1200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 1200 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_2 == 2400)
			#define MX_SOFT_BAUD_2	SW_2400_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 2400 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_2 == 4800)
			#define MX_SOFT_BAUD_2	SW_4800_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 4800 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_2 == 9600)
			#define MX_SOFT_BAUD_2	SW_9600_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 9600 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_2 == 19200)
			#define MX_SOFT_BAUD_2	SW_19200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 19200 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_2 == 31250)
			#define MX_SOFT_BAUD_2	SW_31250_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 31250 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_2 == 115200)
			#define MX_SOFT_BAUD_2	SW_115200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 115200 Not Available At This Clock Speed"
			#endif
		#endif
		#ifndef MX_SOFT_BAUD_2
			#error "UART Baud Rate not supported in Software Mode"
		#endif
	#else
		#define MX_SOFT_BAUD_2	1
		#define MX_HARD_BAUD_2	(((MX_CLK_SPEED / MX_UART_BAUD_2) - 16) / 16)
		#define MX_HARD_SLOW_2	0

		#if (MX_HARD_BAUD_2 > 255)
			#undef MX_HARD_BAUD_2
			#undef MX_HARD_SLOW_2
			#define MX_HARD_BAUD_2	(((MX_CLK_SPEED / MX_UART_BAUD_2) - 16)	/ 64)
			#define MX_HARD_SLOW_2	1
		#endif
 	#endif
 #endif
 #if defined(MX_UART_CHANNEL_3) && (MX_UART_NUM==3)
	#if (MX_UART_CHANNEL_3 == 0)
		#if (MX_UART_BAUD_3 == 1200)
			#define MX_SOFT_BAUD_3	SW_1200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 1200 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_3 == 2400)
			#define MX_SOFT_BAUD_3	SW_2400_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 2400 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_3 == 4800)
			#define MX_SOFT_BAUD_3	SW_4800_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 4800 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_3 == 9600)
			#define MX_SOFT_BAUD_3	SW_9600_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 9600 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_3 == 19200)
			#define MX_SOFT_BAUD_3	SW_19200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 19200 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_3 == 31250)
			#define MX_SOFT_BAUD_3	SW_31250_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 31250 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_3 == 115200)
			#define MX_SOFT_BAUD_3	SW_115200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 115200 Not Available At This Clock Speed"
			#endif
		#endif
		#ifndef MX_SOFT_BAUD_3
			#error "UART Baud Rate not supported in Software Mode"
		#endif
	#else
		#define MX_SOFT_BAUD_3	1
		#define MX_HARD_BAUD_3	(((MX_CLK_SPEED / MX_UART_BAUD_3) - 16) / 16)
		#define MX_HARD_SLOW_3	0

		#if (MX_HARD_BAUD_3 > 255)
			#undef MX_HARD_BAUD_3
			#undef MX_HARD_SLOW_3
			#define MX_HARD_BAUD_3	(((MX_CLK_SPEED / MX_UART_BAUD_3) - 16)	/ 64)
			#define MX_HARD_SLOW_3	1
		#endif
	#endif
 #endif
 #if defined(MX_UART_CHANNEL_4) && (MX_UART_NUM==4)
	#if (MX_UART_CHANNEL_4 == 0)
		#if (MX_UART_BAUD_4 == 1200)
			#define MX_SOFT_BAUD_4	SW_1200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 1200 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_4 == 2400)
			#define MX_SOFT_BAUD_4	SW_2400_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 2400 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_4 == 4800)
			#define MX_SOFT_BAUD_4	SW_4800_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 4800 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_4 == 9600)
			#define MX_SOFT_BAUD_4	SW_9600_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 9600 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_4 == 19200)
			#define MX_SOFT_BAUD_4	SW_19200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 19200 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_4 == 31250)
			#define MX_SOFT_BAUD_4	SW_31250_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 31250 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_4 == 115200)
			#define MX_SOFT_BAUD_4	SW_115200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 115200 Not Available At This Clock Speed"
			#endif
		#endif
		#ifndef MX_SOFT_BAUD_4
			#error "UART Baud Rate not supported in Software Mode"
		#endif
	#else
		#define MX_SOFT_BAUD_4	1
		#define MX_HARD_BAUD_4	(((MX_CLK_SPEED / MX_UART_BAUD_4) - 16) / 16)
		#define MX_HARD_SLOW_4	0

		#if (MX_HARD_BAUD_4 > 255)
			#undef MX_HARD_BAUD_4
			#undef MX_HARD_SLOW_4
			#define MX_HARD_BAUD_4	(((MX_CLK_SPEED / MX_UART_BAUD_4) - 16)	/ 64)
			#define MX_HARD_SLOW_4	1
		#endif
	#endif
 #endif


//Hardware Baud update definitions
#ifndef MX_HARD_BAUD_CHANGE_DEFS
	#define MX_HARD_BAUD_CHANGE_DEFS

	#define MX_HARD_BAUD_1200	(((MX_CLK_SPEED / 1200) - 16) / 16)
	#if (MX_HARD_BAUD_1200 > 255)
		#undef MX_HARD_BAUD_1200
		#define MX_HARD_BAUD_1200	(((MX_CLK_SPEED / 1200) - 16) / 64)
		#define MX_HARD_SLOW_1200	1
	#else
		#define MX_HARD_SLOW_1200	0
	#endif

	#define MX_HARD_BAUD_2400	(((MX_CLK_SPEED / 2400) - 16) / 16)
	#if (MX_HARD_BAUD_2400 > 255)
		#undef MX_HARD_BAUD_2400
		#define MX_HARD_BAUD_2400	(((MX_CLK_SPEED / 2400) - 16) / 64)
		#define MX_HARD_SLOW_2400	1
	#else
		#define MX_HARD_SLOW_2400	0
	#endif

	#define MX_HARD_BAUD_4800	(((MX_CLK_SPEED / 4800) - 16) / 16)
	#if (MX_HARD_BAUD_4800 > 255)
		#undef MX_HARD_BAUD_4800
		#define MX_HARD_BAUD_4800	(((MX_CLK_SPEED / 4800) - 16) / 64)
		#define MX_HARD_SLOW_4800	1
	#else
		#define MX_HARD_SLOW_4800	0
	#endif

	#define MX_HARD_BAUD_9600	(((MX_CLK_SPEED / 9600) - 16) / 16)
	#if (MX_HARD_BAUD_9600 > 255)
		#undef MX_HARD_BAUD_9600
		#define MX_HARD_BAUD_9600	(((MX_CLK_SPEED / 9600) - 16) / 64)
		#define MX_HARD_SLOW_9600	1
	#else
		#define MX_HARD_SLOW_9600	0
	#endif

	#define MX_HARD_BAUD_19200	(((MX_CLK_SPEED / 19200) - 16) / 16)
	#if (MX_HARD_BAUD_19200 > 255)
		#undef MX_HARD_BAUD_19200
		#define MX_HARD_BAUD_19200	(((MX_CLK_SPEED / 19200) - 16) / 64)
		#define MX_HARD_SLOW_19200	1
	#else
		#define MX_HARD_SLOW_19200	0
	#endif

	#define MX_HARD_BAUD_38400	(((MX_CLK_SPEED / 38400) - 16) / 16)
	#if (MX_HARD_BAUD_38400 > 255)
		#undef MX_HARD_BAUD_38400
		#define MX_HARD_BAUD_38400	(((MX_CLK_SPEED / 38400) - 16) / 64)
		#define MX_HARD_SLOW_38400	1
	#else
		#define MX_HARD_SLOW_38400	0
	#endif

	#define MX_HARD_BAUD_57600	(((MX_CLK_SPEED / 57600) - 16) / 16)
	#if (MX_HARD_BAUD_57600 > 255)
		#undef MX_HARD_BAUD_57600
		#define MX_HARD_BAUD_57600	(((MX_CLK_SPEED / 57600) - 16) / 64)
		#define MX_HARD_SLOW_57600	1
	#else
		#define MX_HARD_SLOW_57600	0
	#endif

	#define MX_HARD_BAUD_115200	(((MX_CLK_SPEED / 115200) - 16) / 16)
	#if (MX_HARD_BAUD_115200 > 255)
		#undef MX_HARD_BAUD_115200
		#define MX_HARD_BAUD_115200	(((MX_CLK_SPEED / 115200) - 16) / 64)
		#define MX_HARD_SLOW_115200	1
	#else
		#define MX_HARD_SLOW_115200	0
	#endif
#endif


//Dynamic function naming based on defines and index number
#define MX_UART_CHANNEL_X	CAL_APPEND(MX_UART_CHANNEL_, MX_UART_NUM)
#define MX_UART_TX_PIN_X	CAL_APPEND(MX_UART_TX_PIN_, MX_UART_NUM)
#define MX_UART_TX_PORT_X	CAL_APPEND(MX_UART_TX_PORT_, MX_UART_NUM)
#define MX_UART_TX_TRIS_X	CAL_APPEND(MX_UART_TX_TRIS_, MX_UART_NUM)
#define MX_UART_RX_PIN_X	CAL_APPEND(MX_UART_RX_PIN_, MX_UART_NUM)
#define MX_UART_RX_PORT_X	CAL_APPEND(MX_UART_RX_PORT_, MX_UART_NUM)
#define MX_UART_RX_TRIS_X	CAL_APPEND(MX_UART_RX_TRIS_, MX_UART_NUM)
#define MX_UART_FLOWEN_X	CAL_APPEND(MX_UART_FLOWEN_, MX_UART_NUM)
#define MX_UART_CTS_PIN_X	CAL_APPEND(MX_UART_CTS_PIN_, MX_UART_NUM)
#define MX_UART_CTS_PORT_X	CAL_APPEND(MX_UART_CTS_PORT_, MX_UART_NUM)
#define MX_UART_CTS_TRIS_X	CAL_APPEND(MX_UART_CTS_TRIS_, MX_UART_NUM)
#define MX_UART_RTS_PIN_X	CAL_APPEND(MX_UART_RTS_PIN_, MX_UART_NUM)
#define MX_UART_RTS_PORT_X	CAL_APPEND(MX_UART_RTS_PORT_, MX_UART_NUM)
#define MX_UART_RTS_TRIS_X	CAL_APPEND(MX_UART_RTS_TRIS_, MX_UART_NUM)
#define MX_UART_DBITS_X		CAL_APPEND(MX_UART_DBITS_, MX_UART_NUM)
#define MX_UART_RETURN_X	CAL_APPEND(MX_UART_RETURN_, MX_UART_NUM)
#define MX_UART_ECHO_X		CAL_APPEND(MX_UART_ECHO_, MX_UART_NUM)
#define MX_UART_INT_X		CAL_APPEND(MX_UART_INT_, MX_UART_NUM)
#define MX_UART_BAUD_X		CAL_APPEND(MX_HARD_BAUD_, MX_UART_NUM)
#define MX_SOFT_BAUD_X		CAL_APPEND(MX_SOFT_BAUD_, MX_UART_NUM)
#define MX_HARD_SLOW_X		CAL_APPEND(MX_HARD_SLOW_, MX_UART_NUM)

#define UART_Delay_CAL		CAL_APPEND(FC_CAL_UART_Delay_, MX_UART_NUM)
#define UART_Send			CAL_APPEND(FC_CAL_UART_Send_, MX_UART_NUM)
#define UART_Uninit			CAL_APPEND(FC_CAL_UART_Uninit_, MX_UART_NUM)


//Component Definitions
#define UART_STATUS_LOOP	0
#define UART_STATUS_TIMEOUT	1
#define UART_STATUS_RXBYTE	2


//Interrupt Definitions
#ifdef MX_UART_2_PIE4
  #define MX_UART2_PIE pie4
  #define MX_UART2_PIR pir4
  #define MX_UART2_TXSTA tx2sta
  #define MX_UART2_RCSTA rc2sta
  #define MX_UART2_TXREG tx2reg
  #define MX_UART2_RCREG rc2reg
#else
  #define MX_UART2_PIE pie3
  #define MX_UART2_PIR pir3
  #define MX_UART2_TXSTA txsta2
  #define MX_UART2_RCSTA rcsta2
  #define MX_UART2_TXREG txreg2
  #define MX_UART2_RCREG rcreg2
#endif

#if (MX_UART_INT_X == 1)

	#ifndef MX_UART_INT_DEFS
	#define MX_UART_INT_DEFS

		#define MX_UART_INT_CH1_FUNC
		#define MX_UART_INT_CH2_FUNC
		#define MX_UART_INT_FUNC_END

		#define MX_UART_INT_CH1_DET		ts_bit(pir1, RCIF) && ts_bit(pie1, RCIE)
		#define MX_UART_INT_CH2_DET		ts_bit(MX_UART2_PIR, RC2IF) && ts_bit(MX_UART2_PIE, RC2IE)

		#define MX_UART_INT_CH1_EN		st_bit (pie1, RCIE)
		#define MX_UART_INT_CH2_EN		st_bit (MX_UART2_PIE, RC2IE)

		#define MX_UART_INT_CH1_DIS		cr_bit (pie1, RCIE)
		#define MX_UART_INT_CH2_DIS		cr_bit (MX_UART2_PIE, RC2IE)

		#define MX_UART_INT_CH1_CLR		cr_bit (pir1, RCIF)
		#define MX_UART_INT_CH2_CLR		cr_bit (MX_UART2_PIR, RC2IF)

	#endif
#endif


//Function Prototypes
CALFUNCTION(void, FC_CAL_UART_Init_, (void));
CALFUNCTION(void, FC_CAL_UART_Uninit_, (void));
CALFUNCTION(void, FC_CAL_UART_Send_, (MX_UINT16 nChar));
CALFUNCTION(MX_SINT16, FC_CAL_UART_Receive_, (MX_UINT8 nTimeout));
CALFUNCTION(void, FC_CAL_UART_Delay_, (void));


//Peripheral Functions
CALFUNCTION(void, FC_CAL_UART_Init_, (void))

{

	#if (MX_UART_CHANNEL_X == 0)
		FC_CAL_Bit_In_DDR 	(MX_UART_RX_PORT_X, MX_UART_RX_TRIS_X, MX_UART_RX_PIN_X);		// Receive pin is a input
		FC_CAL_Bit_High_DDR (MX_UART_TX_PORT_X, MX_UART_TX_TRIS_X, MX_UART_TX_PIN_X);		// Transmit pin is default high
	#endif

	#if (MX_UART_CHANNEL_X == 1)
	  #ifndef MX_UART_1
	  	  #error "UART channel 1 not available on this device"
	  #else
		  #if (MX_HARD_SLOW_X == 1)
			cr_bit(txsta, BRGH);						//Low Speed
		  #else
			st_bit(txsta, BRGH);						//High Speed
0134  1683  	BSF STATUS, RP0
0135  1303  	BCF STATUS, RP1
0136  1518  	BSF gbl_txsta,2

		  #endif
			spbrg = MX_UART_BAUD_X;   					// set the baud rate
0137  3081  	MOVLW 0x81
0138  0099  	MOVWF gbl_spbrg

			rcsta = 0;                    				// 8-bit, disabled
0139  1283  	BCF STATUS, RP0
013A  0198  	CLRF gbl_rcsta


			#if(MX_UART_DBITS_X == 9)
				st_bit(txsta, TX9);   					// 9-bit TX
				st_bit(rcsta, RX9);                    	// 9-bit RX
			#endif

			st_bit(rcsta, SPEN);         				// turn on serial interface
013B  1798  	BSF gbl_rcsta,7

			st_bit(txsta, TXEN);
013C  1683  	BSF STATUS, RP0
013D  1698  	BSF gbl_txsta,5

			st_bit(rcsta, CREN);
013E  1283  	BCF STATUS, RP0
013F  1618  	BSF gbl_rcsta,4


			#if (MX_UART_INT_X == 1)
				MX_UART_INT_CH1_EN;
				st_bit(intcon, PEIE);
				st_bit(intcon, GIE);
			#else
				cr_bit (pie1, RCIE);
0140  1683  	BSF STATUS, RP0
0141  128C  	BCF gbl_pie1,5

			#endif
	  #endif
	#endif


	#if (MX_UART_CHANNEL_X == 2)

	  #ifndef MX_UART_2
		  #error "UART channel 2 not available on this device"
	  #else
		  #ifdef MX_UART_2_REMAPPABLE
			RPOR9 = 5;									//TX2 - RP9 - RB6
			RPINR16	= 10;								//RX2 - RP10 - RB7
		  #endif
		  #if (MX_HARD_SLOW_X == 1)
			cr_bit(MX_UART2_TXSTA, BRGH);						//Low Speed
		  #else
			st_bit(MX_UART2_TXSTA, BRGH);						//High Speed
		  #endif
			spbrg2 = MX_UART_BAUD_X;   				// set the baud rate
			MX_UART2_RCSTA = 0;                    				// 8-bit, disabled

			#if(MX_UART_DBITS_X == 9)
				st_bit(MX_UART2_TXSTA, TX9);   					// 9-bit TX
				st_bit(MX_UART2_RCSTA, RX9);                    // 9-bit RX
			#endif

			st_bit(MX_UART2_RCSTA, SPEN);         				// turn on serial interface
			st_bit(MX_UART2_TXSTA, TXEN);
			st_bit(MX_UART2_RCSTA, CREN);

			#if (MX_UART_INT_X == 1)
				MX_UART_INT_CH2_EN;
				st_bit(intcon, PEIE);
				st_bit(intcon, GIE);
			#else
				cr_bit (MX_UART2_PIE, RC2IE);
			#endif
	  #endif
	#endif

	#if (MX_UART_FLOWEN_X == 1)						//Flowcontrol enabled?
		FC_CAL_Bit_In_DDR (MX_UART_CTS_PORT_X, MX_UART_CTS_TRIS_X, MX_UART_CTS_PIN_X);	// CTS pin is a input
		FC_CAL_Bit_High_DDR (MX_UART_RTS_PORT_X, MX_UART_RTS_TRIS_X, MX_UART_RTS_PIN_X);	// RTS not ready to accept data
	#endif

}
0142  0008  	RETURN




CALFUNCTION(void, FC_CAL_UART_Uninit_, (void))
{

	#if (MX_UART_CHANNEL_X == 0)
		FC_CAL_Bit_In_DDR (MX_UART_RX_PORT_X, MX_UART_RX_TRIS_X, MX_UART_RX_PIN_X);		// Receive pin is a input
		FC_CAL_Bit_In_DDR (MX_UART_TX_PORT_X, MX_UART_TX_TRIS_X, MX_UART_TX_PIN_X);		// Transmit pin is default high
	#endif

	#if (MX_UART_CHANNEL_X == 1)
			rcsta = 0;                    								// 8-bit, disabled
			txsta = 0;
		  #ifdef MX_UART_RXINT
			MX_UART_INT_CH1_DIS;
		  #endif
	#endif

	#if (MX_UART_CHANNEL_X == 2)
			MX_UART2_RCSTA = 0;                    								// 8-bit, disabled
			MX_UART2_TXSTA = 0;
		  #ifdef MX_UART_RXINT
			MX_UART_INT_CH2_DIS;
		  #endif
	#endif

	#if (MX_UART_FLOWEN_X == 1)										//Flowcontrol enabled?
		FC_CAL_Bit_In_DDR (MX_UART_CTS_PORT_X, MX_UART_CTS_TRIS_X, MX_UART_CTS_PIN_X);		// CTS pin is a input
		FC_CAL_Bit_In_DDR (MX_UART_RTS_PORT_X, MX_UART_RTS_TRIS_X, MX_UART_RTS_PIN_X);		// RTS not ready to accept data
	#endif
}



CALFUNCTION(void, FC_CAL_UART_Send_, (MX_UINT16 nChar))
{
	#if (MX_UART_FLOWEN_X == 1)
		while (FC_CAL_Bit_In(MX_UART_CTS_PORT_X, MX_UART_CTS_PIN_X) != 0);	// Wait until CTS is low
	#endif

	#if (MX_UART_CHANNEL_X == 0)													// Software UART TX
		MX_UINT8 idx;
		FC_CAL_Bit_Low(MX_UART_TX_PORT_X, MX_UART_TX_PIN_X);					// Send Start bit
		UART_Delay_CAL();
		for (idx = 0; idx < MX_UART_DBITS_X; idx++)
		{
			if (nChar & 0x01)														// Mask off data bit
				FC_CAL_Bit_High(MX_UART_TX_PORT_X, MX_UART_TX_PIN_X);
			else
				FC_CAL_Bit_Low(MX_UART_TX_PORT_X, MX_UART_TX_PIN_X);
			UART_Delay_CAL();
			nChar = nChar >> 1;														// Move to next data bit
		}
		FC_CAL_Bit_High(MX_UART_TX_PORT_X, MX_UART_TX_PIN_X);					// Send Stop bit
		UART_Delay_CAL();
	#endif

	#if (MX_UART_CHANNEL_X == 1)
		while (ts_bit(pir1, TXIF) == 0);

		#if (MX_UART_DBITS_X == 9)
			if (test_bit(nChar, 8))
				st_bit(txsta, TX9D);
			else
				cr_bit(txsta, TX9D);
	  	#endif
		txreg = nChar;
	#endif

	#if (MX_UART_CHANNEL_X == 2)
		while (ts_bit(pir3, TX2IF) == 0);

		#if (MX_UART_DBITS_X == 9)
			if (test_bit(nChar, 8))
				st_bit(MX_UART2_TXSTA, TX9D);
			else
				cr_bit(MX_UART2_TXSTA, TX9D);
		#endif
		MX_UART2_TXREG = nChar;
	#endif
}


CALFUNCTION(MX_SINT16, FC_CAL_UART_Receive_, (MX_UINT8 nTimeout))

{
  #if (MX_UART_RETURN_X == 1)
	MX_UINT16 retVal = 512;
  #else
  	MX_UINT8 retVal = 255;
0015  30FF  	MOVLW 0xFF
0016  00D2  	MOVWF FC_CAL_UAR_0005A_1_retVal

  #endif

	MX_UINT8 delay1 = 0;
0017  01D3  	CLRF FC_CAL_UAR_0005A_1_delay1

	MX_UINT8 regcheck = 0;
0018  01D4  	CLRF FC_CAL_UAR_0005A_1_regcheck

	MX_UINT8 bWaitForever = 0;
0019  01D5  	CLRF FC_CAL_UAR_0005A_1_bWaitForever

	MX_UINT8 rxStatus = UART_STATUS_LOOP;
001A  01D6  	CLRF FC_CAL_UAR_0005A_1_rxStatus


  #if (MX_UART_CHANNEL_X == 0)
  	MX_UINT8 idx;
  #else
  	MX_UINT8 dummy = 0;
001B  01D7  	CLRF FC_CAL_UAR_0005A_1_dummy

  #endif

	if (nTimeout == 255)
001C  0A51  	INCF FC_CAL_UAR_0005A_arg_nTimeout, W
001D  1D03  	BTFSS STATUS,Z
001E  2821  	GOTO	label2
0021        label2

		bWaitForever = 1;
001F  3001  	MOVLW 0x01
0020  00D5  	MOVWF FC_CAL_UAR_0005A_1_bWaitForever


	#if (MX_UART_FLOWEN_X == 1)
		FC_CAL_Bit_Low (MX_UART_RTS_PORT_X, MX_UART_RTS_PIN_X);			// Ready to accept data
	#endif

	while (rxStatus == UART_STATUS_LOOP)
0021  08D6  	MOVF FC_CAL_UAR_0005A_1_rxStatus, F
0022  1D03  	BTFSS STATUS,Z
0023  2843  	GOTO	label5
0042  2821  	GOTO	label2
0043        label5

	{
		if (bWaitForever == 0)
0024  08D5  	MOVF FC_CAL_UAR_0005A_1_bWaitForever, F
0025  1D03  	BTFSS STATUS,Z
0026  283A  	GOTO	label4

		{
			if (nTimeout == 0)							//don't wait forever, so do timeout thing...
0027  08D1  	MOVF FC_CAL_UAR_0005A_arg_nTimeout, F
0028  1D03  	BTFSS STATUS,Z
0029  282D  	GOTO	label3
002D        label3

			{
				rxStatus = UART_STATUS_TIMEOUT;
002A  3001  	MOVLW 0x01
002B  00D6  	MOVWF FC_CAL_UAR_0005A_1_rxStatus

			}
			else
002C  283A  	GOTO	label4

			{
				delay_us(10);
002D  300A  	MOVLW 0x0A
002E  00D8  	MOVWF delay_us_00000_arg_del
002F  2010  	CALL delay_us_00000

				delay1 = delay1 + 1;
0030  0A53  	INCF FC_CAL_UAR_0005A_1_delay1, W
0031  00D3  	MOVWF FC_CAL_UAR_0005A_1_delay1

				if(delay1 == 100)
0032  0853  	MOVF FC_CAL_UAR_0005A_1_delay1, W
0033  3A64  	XORLW 0x64
0034  1D03  	BTFSS STATUS,Z
0035  283A  	GOTO	label4
003A        label4

				{
					nTimeout = nTimeout - 1;
0036  0351  	DECF FC_CAL_UAR_0005A_arg_nTimeout, W
0037  00D1  	MOVWF FC_CAL_UAR_0005A_arg_nTimeout

					MX_CLEAR_WATCHDOG;
0038  0064  	CLRWDT

					delay1 = 0;
0039  01D3  	CLRF FC_CAL_UAR_0005A_1_delay1

				}
			}
		}

		#if (MX_UART_CHANNEL_X == 0)
			regcheck = FC_CAL_Bit_In(MX_UART_RX_PORT_1, MX_UART_RX_PIN_1);	//Test for start bit
			if (regcheck == 0)
				rxStatus = UART_STATUS_RXBYTE;
		#endif

		#if (MX_UART_CHANNEL_X == 1)
			regcheck = ts_bit(pir1, RCIF);
003A  3020  	MOVLW 0x20
003B  050C  	ANDWF gbl_pir1, W
003C  00D4  	MOVWF FC_CAL_UAR_0005A_1_regcheck

			if (regcheck != 0)
003D  08D4  	MOVF FC_CAL_UAR_0005A_1_regcheck, F
003E  1903  	BTFSC STATUS,Z
003F  2821  	GOTO	label2

				rxStatus = UART_STATUS_RXBYTE;
0040  3002  	MOVLW 0x02
0041  00D6  	MOVWF FC_CAL_UAR_0005A_1_rxStatus

		#endif

		#if (MX_UART_CHANNEL_X == 2)
			regcheck = ts_bit(MX_UART2_PIR, RC2IF);
			if (regcheck != 0)
				rxStatus = UART_STATUS_RXBYTE;
		#endif

	}

	if (rxStatus == UART_STATUS_RXBYTE)
0043  0856  	MOVF FC_CAL_UAR_0005A_1_rxStatus, W
0044  3A02  	XORLW 0x02
0045  1D03  	BTFSS STATUS,Z
0046  285D  	GOTO	label8

	{
		#if (MX_UART_CHANNEL_X == 0)

			retVal = 0;
			UART_Delay_CAL();

			for (idx = 0; idx < MX_UART_DBITS_X; idx++)
			{
				if (FC_CAL_Bit_In(MX_UART_RX_PORT_X, MX_UART_RX_PIN_X))
					retVal = retVal | (0x01 << idx);

				UART_Delay_CAL();
			}
		#endif

		#if (MX_UART_CHANNEL_X == 1)
			regcheck = ts_bit(rcsta, FERR);
0047  3004  	MOVLW 0x04
0048  0518  	ANDWF gbl_rcsta, W
0049  00D4  	MOVWF FC_CAL_UAR_0005A_1_regcheck

			if (regcheck != 0)
004A  08D4  	MOVF FC_CAL_UAR_0005A_1_regcheck, F
004B  1903  	BTFSC STATUS,Z
004C  2850  	GOTO	label6
0050        label6

			{
				dummy = rcreg;						//need to read the rcreg to clear FERR
004D  081A  	MOVF gbl_rcreg, W
004E  00D7  	MOVWF FC_CAL_UAR_0005A_1_dummy

				#if (MX_UART_RETURN_X == 1)
					retVal = 0x400;					//Framing Error Flag
				#endif
			}
			else
004F  285D  	GOTO	label8

			{
				regcheck = ts_bit(rcsta, OERR);
0050  3002  	MOVLW 0x02
0051  0518  	ANDWF gbl_rcsta, W
0052  00D4  	MOVWF FC_CAL_UAR_0005A_1_regcheck

				if (regcheck != 0)
0053  08D4  	MOVF FC_CAL_UAR_0005A_1_regcheck, F
0054  1903  	BTFSC STATUS,Z
0055  2859  	GOTO	label7
0059        label7

				{
					cr_bit(rcsta, CREN);			//Reset receiver to clear error
0056  1218  	BCF gbl_rcsta,4

					st_bit(rcsta, CREN);
0057  1618  	BSF gbl_rcsta,4


					#if (MX_UART_RETURN_X == 1)
						retVal = 0x800;				//Overrun Error Flag
					#endif
				}
				else
0058  285D  	GOTO	label8
005D        label8

				{
					retVal = 0;
0059  01D2  	CLRF FC_CAL_UAR_0005A_1_retVal


					#if (MX_UART_DBITS_X == 9)
						if(ts_bit(rcsta, RX9D))
							retVal = 0x100;
					#endif

					retVal = retVal | rcreg; 			//no error, so rx byte is valid
005A  081A  	MOVF gbl_rcreg, W
005B  0452  	IORWF FC_CAL_UAR_0005A_1_retVal, W
005C  00D2  	MOVWF FC_CAL_UAR_0005A_1_retVal

				}
			}
		#endif

		#if (MX_UART_CHANNEL_X == 2)
			regcheck = ts_bit(MX_UART2_RCSTA, FERR);
			if (regcheck != 0)
			{
				dummy = MX_UART2_RCREG;			//need to read the rcreg to clear FERR
				#if (MX_UART_RETURN_X == 1)
					retVal = 0x400;					//Framing Error Flag
				#endif
			}
			else
			{
				regcheck = ts_bit(MX_UART2_RCSTA, OERR);
				if (regcheck != 0)
				{
					cr_bit(MX_UART2_RCSTA, CREN);	//Reset receiver to clear error
					st_bit(MX_UART2_RCSTA, CREN);
					#if (MX_UART_RETURN_X == 1)
						retVal = 0x800;				//Overrun Error Flag
					#endif
				}
				else
				{
					retVal = 0;

					#if (MX_UART_DBITS_X == 9)
						if(ts_bit(MX_UART2_RCSTA, RX9D))
							retVal = 0x100;
					#endif

					retVal = retVal | MX_UART2_RCREG; 			//no error, so rx byte is valid
				}
			}

		#endif

		#if (MX_UART_ECHO_X == 1)
			UART_Send(retVal);
		#endif
	}

	#if (MX_UART_FLOWEN_X == 1)
		FC_CAL_Bit_High(MX_UART_RTS_PORT_X, MX_UART_RTS_PIN_X);		//not ready to accept data
	#endif

	return (retVal);
005D  0852  	MOVF FC_CAL_UAR_0005A_1_retVal, W
005E  00D8  	MOVWF CompTempVarRet2192
005F  01D9  	CLRF CompTempVarRet2192+D'1'

}
0060  0008  	RETURN



CALFUNCTION(void, FC_CAL_UART_Delay_, (void))
{
  #if (MX_UART_CHANNEL_X == 0)

	MX_UINT16 delay = MX_SOFT_BAUD_X;

	while (delay > 255)
	{
		delay_us(255);
		delay = delay - 255;
		MX_CLEAR_WATCHDOG;
	}
	delay_us(delay);
	MX_CLEAR_WATCHDOG;

  #endif
}


CALFUNCTION(void, FC_CAL_UART_Update_Baud_, (MX_UINT8 new_baud))
{
	//Baud Rates - Function compatible with hardware mode only
	/*
	0 - 1200
	1 - 2400
	2 - 4800
	3 - 9600
	4 - 19200
	5 - 38400
	6 - 57600
	7 - 115200
	*/

	MX_UINT8 baudrate, baudmode;

	if (new_baud > 7)
		return;

	if (new_baud == 0)
	{
		baudrate = MX_HARD_BAUD_1200;
		baudmode = MX_HARD_SLOW_1200;
	}
	else if (new_baud == 1)
	{
		baudrate = MX_HARD_BAUD_2400;
		baudmode = MX_HARD_SLOW_2400;
	}
	else if (new_baud == 2)
	{
		baudrate = MX_HARD_BAUD_4800;
		baudmode = MX_HARD_SLOW_4800;
	}
	else if (new_baud == 3)
	{
		baudrate = MX_HARD_BAUD_9600;
		baudmode = MX_HARD_SLOW_9600;
	}
	else if (new_baud == 4)
	{
		baudrate = MX_HARD_BAUD_19200;
		baudmode = MX_HARD_SLOW_19200;
	}
	else if (new_baud == 5)
	{
		baudrate = MX_HARD_BAUD_38400;
		baudmode = MX_HARD_SLOW_38400;
	}
	else if (new_baud == 6)
	{
		baudrate = MX_HARD_BAUD_57600;
		baudmode = MX_HARD_SLOW_57600;
	}
	else if (new_baud == 7)
	{
		baudrate = MX_HARD_BAUD_115200;
		baudmode = MX_HARD_SLOW_115200;
	}

	UART_Uninit();

	#if (MX_UART_CHANNEL_X == 1)

	    if (baudmode == 1)
			cr_bit(txsta, BRGH);					//Low Speed
	    else
			st_bit(txsta, BRGH);					//High Speed

		spbrg = baudrate;   						// set the baud rate
		rcsta = 0;                    				// 8-bit, disabled

		#if(MX_UART_DBITS_X == 9)
			st_bit(txsta, TX9);   					// 9-bit TX
			st_bit(rcsta, RX9);                    	// 9-bit RX
		#endif

		st_bit(rcsta, SPEN);         				// turn on serial interface
		st_bit(txsta, TXEN);
		st_bit(rcsta, CREN);

		#if (MX_UART_INT_X == 1)
			MX_UART_INT_CH1_EN;
			st_bit(intcon, PEIE);
			st_bit(intcon, GIE);
		#else
			cr_bit (pie1, RCIE);
		#endif
	#endif

	#if (MX_UART_CHANNEL_X == 2)

	  	if (baudmode == 1)
			cr_bit(MX_UART2_TXSTA, BRGH);			//Low Speed
	  	else
			st_bit(MX_UART2_TXSTA, BRGH);			//High Speed

		spbrg2 = baudrate;   						// set the baud rate
		MX_UART2_RCSTA = 0;                    		// 8-bit, disabled

		#if(MX_UART_DBITS_X == 9)
			st_bit(MX_UART2_TXSTA, TX9);   			// 9-bit TX
			st_bit(MX_UART2_RCSTA, RX9);            // 9-bit RX
		#endif

		st_bit(MX_UART2_RCSTA, SPEN);         		// turn on serial interface
		st_bit(MX_UART2_TXSTA, TXEN);
		st_bit(MX_UART2_RCSTA, CREN);

		#if (MX_UART_INT_X == 1)
			MX_UART_INT_CH2_EN;
			st_bit(intcon, PEIE);
			st_bit(intcon, GIE);
		#else
			cr_bit (MX_UART2_PIE, RC2IE);
		#endif
	#endif

	#if (MX_UART_FLOWEN_X == 1)						//Flowcontrol enabled?
		FC_CAL_Bit_In_DDR (MX_UART_CTS_PORT_X, MX_UART_CTS_TRIS_X, MX_UART_CTS_PIN_X);	// CTS pin is a input
		FC_CAL_Bit_High_DDR (MX_UART_RTS_PORT_X, MX_UART_RTS_TRIS_X, MX_UART_RTS_PIN_X);	// RTS not ready to accept data
	#endif

}

////////////////////////////////////////
// Code with no source :-)
////////////////////////////////////////
0000  29B6  	GOTO	_startup

0004  00FF  	MOVWF Int1Context
0005  0E03  	SWAPF STATUS, W
0006  1283  	BCF STATUS, RP0
0007  1303  	BCF STATUS, RP1
0008  00B4  	MOVWF Int1BContext
0009  0E0A  	SWAPF PCLATH, W
000A  00B5  	MOVWF Int1BContext+D'1'
000B  0E04  	SWAPF FSR, W
000C  00B6  	MOVWF Int1BContext+D'2'
000D  118A  	BCF PCLATH,3
000E  120A  	BCF PCLATH,4
000F  29DE  	GOTO	interrupt
0010        delay_us_00000
0010        ; { delay_us ; function begin
0010        label1
0010  0000  	NOP
0011  0000  	NOP
0012  0BD8  	DECFSZ delay_us_00000_arg_del, F
0013  2810  	GOTO	label1
0014  0008  	RETURN
0015        ; } delay_us function end


00F6        __rem_16_1_00004
00F6        ; { __rem_16_16 ; function begin
00F6  01DB  	CLRF CompTempVarRet216
00F7  01DC  	CLRF CompTempVarRet216+D'1'
00F8  01D8  	CLRF __rem_16_1_00004_1_c
00F9  01D9  	CLRF __rem_16_1_00004_1_c+D'1'
00FA  01DA  	CLRF __rem_16_1_00004_1_i
00FB        label22
00FB  1A5A  	BTFSC __rem_16_1_00004_1_i,4
00FC  0008  	RETURN
00FD  1003  	BCF STATUS,C
00FE  0DD8  	RLF __rem_16_1_00004_1_c, F
00FF  0DD9  	RLF __rem_16_1_00004_1_c+D'1', F
0100  0DD0  	RLF __rem_16_1_00004_arg_a, F
0101  0DD1  	RLF __rem_16_1_00004_arg_a+D'1', F
0102  0DDB  	RLF CompTempVarRet216, F
0103  0DDC  	RLF CompTempVarRet216+D'1', F
0104  0853  	MOVF __rem_16_1_00004_arg_b+D'1', W
0105  025C  	SUBWF CompTempVarRet216+D'1', W
0106  1D03  	BTFSS STATUS,Z
0107  290A  	GOTO	label23
0108  0852  	MOVF __rem_16_1_00004_arg_b, W
0109  025B  	SUBWF CompTempVarRet216, W
010A        label23
010A  1C03  	BTFSS STATUS,C
010B  2913  	GOTO	label24
010C  0852  	MOVF __rem_16_1_00004_arg_b, W
010D  02DB  	SUBWF CompTempVarRet216, F
010E  0853  	MOVF __rem_16_1_00004_arg_b+D'1', W
010F  1C03  	BTFSS STATUS,C
0110  03DC  	DECF CompTempVarRet216+D'1', F
0111  02DC  	SUBWF CompTempVarRet216+D'1', F
0112  1458  	BSF __rem_16_1_00004_1_c,0
0113        label24
0113  0ADA  	INCF __rem_16_1_00004_1_i, F
0114  28FB  	GOTO	label22
0115        ; } __rem_16_16 function end

0115        __div_16_1_00003
0115        ; { __div_16_16 ; function begin
0115  01D8  	CLRF __div_16_1_00003_1_r
0116  01D9  	CLRF __div_16_1_00003_1_r+D'1'
0117  01DB  	CLRF CompTempVarRet214
0118  01DC  	CLRF CompTempVarRet214+D'1'
0119  01DA  	CLRF __div_16_1_00003_1_i
011A        label25
011A  1A5A  	BTFSC __div_16_1_00003_1_i,4
011B  0008  	RETURN
011C  1003  	BCF STATUS,C
011D  0DDB  	RLF CompTempVarRet214, F
011E  0DDC  	RLF CompTempVarRet214+D'1', F
011F  0DD4  	RLF __div_16_1_00003_arg_a, F
0120  0DD5  	RLF __div_16_1_00003_arg_a+D'1', F
0121  0DD8  	RLF __div_16_1_00003_1_r, F
0122  0DD9  	RLF __div_16_1_00003_1_r+D'1', F
0123  0857  	MOVF __div_16_1_00003_arg_b+D'1', W
0124  0259  	SUBWF __div_16_1_00003_1_r+D'1', W
0125  1D03  	BTFSS STATUS,Z
0126  2929  	GOTO	label26
0127  0856  	MOVF __div_16_1_00003_arg_b, W
0128  0258  	SUBWF __div_16_1_00003_1_r, W
0129        label26
0129  1C03  	BTFSS STATUS,C
012A  2932  	GOTO	label27
012B  0856  	MOVF __div_16_1_00003_arg_b, W
012C  02D8  	SUBWF __div_16_1_00003_1_r, F
012D  0857  	MOVF __div_16_1_00003_arg_b+D'1', W
012E  1C03  	BTFSS STATUS,C
012F  03D9  	DECF __div_16_1_00003_1_r+D'1', F
0130  02D9  	SUBWF __div_16_1_00003_1_r+D'1', F
0131  145B  	BSF CompTempVarRet214,0
0132        label27
0132  0ADA  	INCF __div_16_1_00003_1_i, F
0133  291A  	GOTO	label25
0134        ; } __div_16_16 function end


01B6        _startup
01B6  30D5  	MOVLW 0xD5
01B7  1283  	BCF STATUS, RP0
01B8  1303  	BCF STATUS, RP1
01B9  00A0  	MOVWF gbl_14_LSR
01BA  30C4  	MOVLW 0xC4
01BB  00A1  	MOVWF gbl_14_LSR+D'1'
01BC  30BB  	MOVLW 0xBB
01BD  00A2  	MOVWF gbl_14_LSR+D'2'
01BE  30DC  	MOVLW 0xDC
01BF  00A3  	MOVWF gbl_14_LSR+D'3'
01C0  01A4  	CLRF gbl_15_gbl_aSig
01C1  01A5  	CLRF gbl_15_gbl_aSig+D'1'
01C2  01A6  	CLRF gbl_15_gbl_aSig+D'2'
01C3  01A7  	CLRF gbl_15_gbl_aSig+D'3'
01C4  01A8  	CLRF gbl_15_gbl_bSig
01C5  01A9  	CLRF gbl_15_gbl_bSig+D'1'
01C6  01AA  	CLRF gbl_15_gbl_bSig+D'2'
01C7  01AB  	CLRF gbl_15_gbl_bSig+D'3'
01C8  01AC  	CLRF gbl_15_gbl_zSig
01C9  01AD  	CLRF gbl_15_gbl_zSig+D'1'
01CA  01AE  	CLRF gbl_15_gbl_zSig+D'2'
01CB  01AF  	CLRF gbl_15_gbl_zSig+D'3'
01CC  01C2  	CLRF gbl_15_gbl_aExp
01CD  01C3  	CLRF gbl_15_gbl_bExp
01CE  01B7  	CLRF gbl_15_gbl_zExp
01CF  01B8  	CLRF gbl_15_gbl_zExp+D'1'
01D0  01C4  	CLRF gbl_15_gbl_aSign
01D1  01C5  	CLRF gbl_15_gbl_bSign
01D2  01C6  	CLRF gbl_15_gbl_zSign
01D3  01C7  	CLRF gbl_15_gbl_zSigZero
01D4  01B0  	CLRF gbl_15_gbl_ret
01D5  01B1  	CLRF gbl_15_gbl_ret+D'1'
01D6  01B2  	CLRF gbl_15_gbl_ret+D'2'
01D7  01B3  	CLRF gbl_15_gbl_ret+D'3'
01D8  01C0  	CLRF gbl_float_rounding_mode
01D9  01C1  	CLRF gbl_float_exception_flags
01DA  01BF  	CLRF gbl_float_detect_tininess
01DB  118A  	BCF PCLATH,3
01DC  120A  	BCF PCLATH,4
01DD  295F  	GOTO	main

2007  30D2  	DW 0x30D2
