;/////////////////////////////////////////////////////////////////////////////////
;// Code Generator: BoostC Compiler - http://www.sourceboost.com
;// Version       : 7.03
;// License Type  : Pro License
;// Limitations   : PIC12,PIC16 max code size:Unlimited, max RAM banks:Unlimited
;/////////////////////////////////////////////////////////////////////////////////

//************************************************************************************
//**  
//**  File name:     C:\Users\Acer-PC\Desktop\mimbala cueing\testprog.c
//**  Title:         
//**  Description:   
//**  
//**  Generated by:  Flowcode v5.2.0.0
//**  Date:          Monday, January 21, 2019 14:48:00
//**  Licence:       Professional
//**  Registered to: xyz
//**  Licence key:   WUK7B9
//**  
//**  
//**  http://www.matrixmultimedia.com
//**  
//************************************************************************************


#define MX_PIC

#define MX_USES_UINT8 1
#define MX_USES_SINT16 1
#define MX_USES_CHAR 0
#define MX_USES_FLOAT 0
#define MX_USES_SINT32 0
#define MX_USES_BOOL 1
#define MX_USES_UINT16 1
#define MX_USES_UINT32 0
//Defines for microcontroller
#define P16F883
#define FC_CAL_PIC
#define MX_ADC
#define MX_ADC_TYPE_7
#define MX_ADC_BITS_10
#define MX_EE
#define MX_EE_TYPE2
#define MX_EE_SIZE 256
#define MX_SPI_1
#define MX_SPI_1_MISO_PORT portc
#define MX_SPI_1_MISO_TRIS trisc
#define MX_SPI_1_MISO_PIN 4
#define MX_SPI_1_MOSI_PORT portc
#define MX_SPI_1_MOSI_TRIS trisc
#define MX_SPI_1_MOSI_PIN 5
#define MX_SPI_1_CLK_PORT portc
#define MX_SPI_1_CLK_TRIS trisc
#define MX_SPI_1_CLK_PIN 3
#define MX_SPI_1_SS_PORT portc
#define MX_SPI_1_SS_TRIS trisc
#define MX_UART_1
#define MX_UART_1_TX_PORT portc
#define MX_UART_1_TX_TRIS trisc
#define MX_UART_1_TX_PIN 6
#define MX_UART_1_RX_PORT portc
#define MX_UART_1_RX_TRIS trisc
#define MX_UART_1_RX_PIN 7
#define MX_I2C
#define MX_MI2C
#define MX_I2C_1
#define MX_I2C_1_SDA_PORT portc
#define MX_I2C_1_SDA_TRIS trisc
#define MX_I2C_1_SDA_PIN 4
#define MX_I2C_1_SCL_PORT portc
#define MX_I2C_1_SCL_TRIS trisc
#define MX_I2C_1_SCL_PIN 3
#define MX_PWM
#define MX_PWM_CNT 2
#define MX_PWM_PSCA1
#define MX_PWM_PSCA4
#define MX_PWM_PSCA16
#define MX_PWM_1_PORT portc
#define MX_PWM_1_TRIS trisc
#define MX_PWM_1_PIN 2
#define MX_PWM_2_PORT portc
#define MX_PWM_2_TRIS trisc
#define MX_PWM_2_PIN 1

//Functions
#define MX_CLK_SPEED 20000000
#ifdef _BOOSTC
#include <system.h>
#endif
#ifdef HI_TECH_C
#include <pic.h>
#endif

//Configuration data
#ifdef _BOOSTC
#pragma DATA 0x2007, 0x20d2
#endif
#ifdef HI_TECH_C
__CONFIG(0x20d2);
#endif
#ifdef _BOOSTC
#pragma DATA 0x2008, 0x3eff
#endif
#ifdef HI_TECH_C
__CONFIG(0x3eff);
#endif

//Internal functions
#include "C:\Program Files (x86)\Flowcode\v5\FCD\internals.c"

//Macro function declarations
void FCM_databank();
void FCM_display();
void FCM_display_win1();
void FCM_display_win2();
void FCM_display_win3();
void FCM_recieve();
void FCM_reset();


//Variable declarations
#define FCV_FALSE (0)
#define FCV_TRUE (1)
MX_UINT8 FCV_RECIEVE;
MX_SINT16 FCV_QUE1 = (0);
0083  01B9  	CLRF gbl_FCV_QUE1
0084  01BA  	CLRF gbl_FCV_QUE1+D'1'

MX_UINT8 FCV_WINDOW;
MX_SINT16 FCV_QUE2 = (0);
0085  01BB  	CLRF gbl_FCV_QUE2
0086  01BC  	CLRF gbl_FCV_QUE2+D'1'

MX_BOOL FCV_DAT;
MX_SINT16 FCV_QUE3 = (0);
0087  01BD  	CLRF gbl_FCV_QUE3
0088  01BE  	CLRF gbl_FCV_QUE3+D'1'

MX_UINT8 FCV_BITS;
MX_UINT8 FCV_WIN;
MX_UINT8 FCV_TENS;
MX_UINT8 FCV_DIGIT;
MX_UINT8 FCV_HUNDREDS;
MX_UINT8 FCV_ONES;
MX_UINT16 FCV_IHAP = (0x0);
0089  01BF  	CLRF gbl_FCV_IHAP
008A  01C0  	CLRF gbl_FCV_IHAP+D'1'


MX_UINT8 FCLV_LOOP1;
MX_UINT8 FCLV_LOOP2;
MX_UINT8 FCLV_LOOP3;
MX_UINT8 FCLV_LOOP4;
MX_UINT8 FCLV_LOOP5;
MX_UINT8 FCLV_LOOP6;
MX_UINT8 FCLV_LOOP7;
MX_UINT8 FCLV_LOOP8;



//PWM(0): //Defines:

/**** Macro Substitutions ****
a = Unique Reference
b = PWM Channel - 0=SW / 1-8=HW
c = PWM Alt Pin FCD_PWM0_Enable - 0=Standard / 1=Alt
d = PWM Period
e = PWM Prescaler 1
******************************/

//Period and Prescaler Defines
#ifndef MX_PWM_PERIOD
  #define MX_PWM_PERIOD				80
#else
  #if (MX_PWM_PERIOD != 80)
    #error "PWM period value must be the same in all PWM modules"
  #endif
#endif

#ifndef MX_PWM_PRESCALE1
  #define MX_PWM_PRESCALE1			16
#else
  #if (MX_PWM_PRESCALE1 != 16)
    #error "PWM prescale value must be the same in all PWM modules"
  #endif
#endif

//Definitions for PWM slot allocation
#ifndef	MX_PWM_REF1
			#define MX_PWM_REF1
			#define PWM_4_MX_PWM_UREF			1
			#define MX_PWM_CHANNEL_1		1
			#define MX_PWM_HWALT_1			0
#else
 #ifndef	MX_PWM_REF2
			#define MX_PWM_REF2
			#define PWM_4_MX_PWM_UREF			2
			#define MX_PWM_CHANNEL_2		1
			#define MX_PWM_HWALT_2			0
 #else
  #ifndef	MX_PWM_REF3
			#define MX_PWM_REF3
			#define PWM_4_MX_PWM_UREF			3
			#define MX_PWM_CHANNEL_3		1
			#define MX_PWM_HWALT_3			0
  #else
   #ifndef	MX_PWM_REF4
			#define MX_PWM_REF4
			#define PWM_4_MX_PWM_UREF			4
			#define MX_PWM_CHANNEL_4		1
			#define MX_PWM_HWALT_4			0
   #else
    #ifndef	MX_PWM_REF5
			#define MX_PWM_REF5
			#define PWM_4_MX_PWM_UREF			5
			#define MX_PWM_CHANNEL_5		1
			#define MX_PWM_HWALT_5			0
    #else
     #ifndef	MX_PWM_REF6
			#define MX_PWM_REF6
			#define PWM_4_MX_PWM_UREF			6
			#define MX_PWM_CHANNEL_6		1
			#define MX_PWM_HWALT_6			0
     #else
      #ifndef	MX_PWM_REF7
			#define MX_PWM_REF7
			#define PWM_4_MX_PWM_UREF			7
			#define MX_PWM_CHANNEL_7		1
			#define MX_PWM_HWALT_7			0
      #else
       #ifndef	MX_PWM_REF8
			#define MX_PWM_REF8
			#define PWM_4_MX_PWM_UREF			8
			#define MX_PWM_CHANNEL_8		1
			#define MX_PWM_HWALT_8			0
       #else
        #ifndef	MX_PWM_REF9
			#define MX_PWM_REF9
			#define PWM_4_MX_PWM_UREF			9
			#define MX_PWM_CHANNEL_9		1
			#define MX_PWM_HWALT_9			0
        #else
         #ifndef	MX_PWM_REF10
			#define MX_PWM_REF10
			#define PWM_4_MX_PWM_UREF			10
			#define MX_PWM_CHANNEL_10		1
			#define MX_PWM_HWALT_10			0
         #endif
        #endif
       #endif
      #endif
     #endif
    #endif
   #endif
  #endif
 #endif
#endif

#define PWM_4_PWM_Enable_Channel		CAL_APPEND(FC_CAL_PWM_Enable_Channel_, PWM_4_MX_PWM_UREF)
#define PWM_4_PWM_Disable_Channel		CAL_APPEND(FC_CAL_PWM_Disable_Channel_, PWM_4_MX_PWM_UREF)
#define PWM_4_PWM_Set_Duty_8Bit		CAL_APPEND(FC_CAL_PWM_Set_Duty_8Bit_, PWM_4_MX_PWM_UREF)
#define PWM_4_PWM_Change_Period		CAL_APPEND(FC_CAL_PWM_Change_Period_, PWM_4_MX_PWM_UREF)
#define PWM_4_PWM_Set_Duty_10Bit		CAL_APPEND(FC_CAL_PWM_Set_Duty_10Bit_, PWM_4_MX_PWM_UREF)

extern void PWM_4_PWM_Enable_Channel ();
extern void PWM_4_PWM_Disable_Channel ();
extern void PWM_4_PWM_Set_Duty_8Bit (MX_UINT8 duty);
extern void PWM_4_PWM_Change_Period (MX_UINT8 period, MX_UINT16 prescaler);
extern void PWM_4_PWM_Set_Duty_10Bit (MX_UINT16 duty);




//PWM(0): //Macro function declarations

void FCD_PWM0_Enable();
void FCD_PWM0_Disable();
void FCD_PWM0_SetDutyCycle(MX_UINT8 nDuty);
void FCD_PWM0_ChangePeriod(MX_UINT8 nPeriodVal, MX_UINT8 nPrescalerVal);
void FCD_PWM0_SetDutyCycle10bit(MX_SINT16 nDuty);


//RS232(0): //Defines:

/**** Macro Substitutions ****
a = Unique Reference
b = Uart Channel		(0-software / 1-4 hardware)
c = tx pin
d = tx port
e = rx pin
f = rx port
g = flow control		(0-Off / 1-On)
h = cts pin
i = cts port
j = rts pin
k = rts port
l = baud rate
m = data bits			(7/8/9) (7 only supported in software modes)
n = return type		(0-byte / 1-MX_UINT16)
o = echo enable		(0-Off / 1-On)
******************************/

//Definitions for RS232 UART slot allocation
#ifndef	MX_UART_REF1
	#define MX_UART_REF1
	#define RS232_5_MX_UART_UREF			1
	#define MX_UART_CHANNEL_1		1
	#define MX_UART_TX_PIN_1		0
	#define MX_UART_TX_PORT_1		porta
	#define MX_UART_TX_TRIS_1		trisa
	#define MX_UART_RX_PIN_1		0
	#define MX_UART_RX_PORT_1		porta
	#define MX_UART_RX_TRIS_1		trisa
	#define MX_UART_FLOWEN_1		0
	#define MX_UART_CTS_PIN_1		4
	#define MX_UART_CTS_PORT_1		portc
	#define MX_UART_CTS_TRIS_1		trisc
	#define MX_UART_RTS_PIN_1		0
	#define MX_UART_RTS_PORT_1		portc
	#define MX_UART_RTS_TRIS_1		trisc
	#define MX_UART_BAUD_1			9600
	#define MX_UART_DBITS_1			8
	#define MX_UART_RETURN_1		0
	#define MX_UART_ECHO_1			0
	#define MX_UART_INT_1			0
#else
 #ifndef	MX_UART_REF2
	#define MX_UART_REF2
	#define RS232_5_MX_UART_UREF			2
	#define MX_UART_CHANNEL_2		1
	#define MX_UART_TX_PIN_2		0
	#define MX_UART_TX_PORT_2		porta
	#define MX_UART_TX_TRIS_2		trisa
	#define MX_UART_RX_PIN_2		0
	#define MX_UART_RX_PORT_2		porta
	#define MX_UART_RX_TRIS_2		trisa
	#define MX_UART_FLOWEN_2		0
	#define MX_UART_CTS_PIN_2		4
	#define MX_UART_CTS_PORT_2		portc
	#define MX_UART_CTS_TRIS_2		trisc
	#define MX_UART_RTS_PIN_2		0
	#define MX_UART_RTS_PORT_2		portc
	#define MX_UART_RTS_TRIS_2		trisc
	#define MX_UART_BAUD_2			9600
	#define MX_UART_DBITS_2			8
	#define MX_UART_RETURN_2		0
	#define MX_UART_ECHO_2			0
	#define MX_UART_INT_2			0
 #else
  #ifndef	MX_UART_REF3
	#define MX_UART_REF3
	#define RS232_5_MX_UART_UREF			3
	#define MX_UART_CHANNEL_3		1
	#define MX_UART_TX_PIN_3		0
	#define MX_UART_TX_PORT_3		porta
	#define MX_UART_TX_TRIS_3		trisa
	#define MX_UART_RX_PIN_3		0
	#define MX_UART_RX_PORT_3		porta
	#define MX_UART_RX_TRIS_3		trisa
	#define MX_UART_FLOWEN_3		0
	#define MX_UART_CTS_PIN_3		4
	#define MX_UART_CTS_PORT_3		portc
	#define MX_UART_CTS_TRIS_3		trisc
	#define MX_UART_RTS_PIN_3		0
	#define MX_UART_RTS_PORT_3		portc
	#define MX_UART_RTS_TRIS_3		trisc
	#define MX_UART_BAUD_3			9600
	#define MX_UART_DBITS_3			8
	#define MX_UART_RETURN_3		0
	#define MX_UART_ECHO_3			0
	#define MX_UART_INT_3			0
  #else
   #ifndef	MX_UART_REF4
	#define MX_UART_REF4
	#define RS232_5_MX_UART_UREF			4
	#define MX_UART_CHANNEL_4		1
	#define MX_UART_TX_PIN_4		0
	#define MX_UART_TX_PORT_4		porta
	#define MX_UART_TX_TRIS_4		trisa
	#define MX_UART_RX_PIN_4		0
	#define MX_UART_RX_PORT_4		porta
	#define MX_UART_RX_TRIS_4		trisa
	#define MX_UART_FLOWEN_4		0
	#define MX_UART_CTS_PIN_4		4
	#define MX_UART_CTS_PORT_4		portc
	#define MX_UART_CTS_TRIS_4		trisc
	#define MX_UART_RTS_PIN_4		0
	#define MX_UART_RTS_PORT_4		portc
	#define MX_UART_RTS_TRIS_4		trisc
	#define MX_UART_BAUD_4			9600
	#define MX_UART_DBITS_4			8
	#define MX_UART_RETURN_4		0
	#define MX_UART_ECHO_4			0
	#define MX_UART_INT_4			0
   #endif
  #endif
 #endif
#endif

#define RS232_5_UART_Init		CAL_APPEND(FC_CAL_UART_Init_, RS232_5_MX_UART_UREF)
#define RS232_5_UART_Send		CAL_APPEND(FC_CAL_UART_Send_, RS232_5_MX_UART_UREF)
#define RS232_5_UART_Receive		CAL_APPEND(FC_CAL_UART_Receive_, RS232_5_MX_UART_UREF)
#define RS232_5_UART_Update_Baud CAL_APPEND(FC_CAL_UART_Update_Baud_, RS232_5_MX_UART_UREF)

extern void RS232_5_UART_Init();
extern void RS232_5_UART_Send(MX_UINT16 nChar);
extern MX_SINT16 RS232_5_UART_Receive(MX_UINT8 nTimeout);
extern void RS232_5_UART_Update_Baud(MX_UINT8 newbaud);




//RS232(0): //Macro function declarations

void FCD_RS2320_SendRS232Char(MX_SINT16 nChar);
void FCD_RS2320_SendRS232String(MX_STRING String, MX_UINT8 MSZ_String);
MX_SINT16 FCD_RS2320_ReceiveRS232Char(MX_UINT8 nTimeout);
void FCD_RS2320_ReceiveRS232String(MX_CHAR* FCR_RETVAL, MX_UINT8 FCR_RETVAL_SIZE, MX_UINT8 nTimeout, MX_UINT8 NumBytes);
void FCD_RS2320_ChangeHWBaud(MX_UINT8 newbaud);



//PWM(0): //Macro implementations


void FCD_PWM0_Enable()
{
	
		PWM_4_PWM_Change_Period (MX_PWM_PERIOD, MX_PWM_PRESCALE1);
		PWM_4_PWM_Enable_Channel ();

}

void FCD_PWM0_Disable()
{
	
		PWM_4_PWM_Disable_Channel();

}

void FCD_PWM0_SetDutyCycle(MX_UINT8 nDuty)
{
	
		PWM_4_PWM_Set_Duty_8Bit(nDuty);

}

void FCD_PWM0_ChangePeriod(MX_UINT8 nPeriodVal, MX_UINT8 nPrescalerVal)
{
	
		PWM_4_PWM_Change_Period (nPeriodVal, nPrescalerVal);

}

void FCD_PWM0_SetDutyCycle10bit(MX_SINT16 nDuty)
{
	
		PWM_4_PWM_Set_Duty_10Bit(nDuty);

}



//RS232(0): //Macro implementations


void FCD_RS2320_SendRS232Char(MX_SINT16 nChar)

{
	
		RS232_5_UART_Send ( nChar);
0024  084C  	MOVF FCD_RS2320_00068_arg_nChar, W
0025  00CE  	MOVWF FC_CAL_UAR_00064_arg_nChar
0026  084D  	MOVF FCD_RS2320_00068_arg_nChar+D'1', W
0027  00CF  	MOVWF FC_CAL_UAR_00064_arg_nChar+D'1'
0028  2010  	CALL FC_CAL_UAR_00064


}
0029  0008  	RETURN


void FCD_RS2320_SendRS232String(MX_STRING String, MX_UINT8 MSZ_String)
{
	
		MX_UINT8 idx;
		for(idx = 0; idx < MSZ_String; idx++)
		{
			if (String[idx] == 0)
				break;
			else RS232_5_UART_Send ( String[idx] );
		}

}

MX_SINT16 FCD_RS2320_ReceiveRS232Char(MX_UINT8 nTimeout)
{
	
		return ( RS232_5_UART_Receive ( nTimeout) );

}

void FCD_RS2320_ReceiveRS232String(MX_CHAR* FCR_RETVAL, MX_UINT8 FCR_RETVAL_SIZE, MX_UINT8 nTimeout, MX_UINT8 NumBytes)
{
	
		MX_UINT8 idx;
		MX_SINT16 RS232_TO = 255;
		MX_SINT16 in;

		if ( 0 != 0 )
			RS232_TO = 256;

		if (NumBytes > FCR_RETVAL_SIZE)
			NumBytes = FCR_RETVAL_SIZE;

		for (idx = 0; idx < NumBytes; idx++)
		{
			in = RS232_5_UART_Receive ( nTimeout);
			if(in < RS232_TO)
				FCR_RETVAL[idx] = in & 0xFF;
			else
				break;
		}

		if (idx < FCR_RETVAL_SIZE)
			FCR_RETVAL[idx] = 0;

}

void FCD_RS2320_ChangeHWBaud(MX_UINT8 newbaud)
{
	
		RS232_5_UART_Update_Baud (newbaud);

}

#include "C:\Program Files (x86)\Flowcode\v5\CAL\includes.c"

//Macro implementations


void FCM_databank()
{

	//Switch
	//Switch: digit?
	switch (FCV_DIGIT)
	{
		case 1:
		{
			//Calculation
			//Calculation:
			//  bits = 0b10011111
			FCV_BITS = 159;

			break;
		}
		case 2:
		{
			//Calculation
			//Calculation:
			//  bits = 0b00100100
			FCV_BITS = 36;

			break;
		}
		case 3:
		{
			//Calculation
			//Calculation:
			//  bits = 0b00001101
			FCV_BITS = 13;

			break;
		}
		case 4:
		{
			//Calculation
			//Calculation:
			//  bits = 0b10011001
			FCV_BITS = 153;

			break;
		}
		case 5:
		{
			//Calculation
			//Calculation:
			//  bits = 0b01001001
			FCV_BITS = 73;

			break;
		}
		case 6:
		{
			//Calculation
			//Calculation:
			//  bits = 0b01000001
			FCV_BITS = 65;

			break;
		}
		case 7:
		{
			//Calculation
			//Calculation:
			//  bits = 0b00011111
			FCV_BITS = 31;

			break;
		}
		case 8:
		{
			//Calculation
			//Calculation:
			//  bits = 0b00000001
			FCV_BITS = 1;

			break;
		}
		case 9:
		{
			//Calculation
			//Calculation:
			//  bits = 0b00001001
			FCV_BITS = 9;

			break;
		}
		case 0:
		{
			//Calculation
			//Calculation:
			//  bits = 0b00000011
			FCV_BITS = 3;

			break;
		}
		// default:

	}

}


void FCM_display()
{

	//Loop
	//Loop: Loop 8 times
	for (FCLV_LOOP2=0; FCLV_LOOP2<8; FCLV_LOOP2++)
	{

		//Calculation
		//Calculation:
		//  dat = bits AND 1
		FCV_DAT = FCV_BITS & 1;

		//data
		//Output: dat -> A0
		trisa = trisa & 0xFE;
		if ((FCV_DAT))
			porta = (porta & 0xFE) | 0x01;
		else
			porta = porta & 0xFE;

		//clk
		//Output: 1 -> B5
		trisb = trisb & 0xDF;
		if ((1))
			portb = (portb & 0xDF) | 0x20;
		else
			portb = portb & 0xDF;

		//Delay
		//Delay: 10 us
		delay_us(10);

		//clk
		//Output: 0 -> B5
		trisb = trisb & 0xDF;
		if ((0))
			portb = (portb & 0xDF) | 0x20;
		else
			portb = portb & 0xDF;

		//Delay
		//Delay: 10 us
		delay_us(10);

		//Calculation
		//Calculation:
		//  bits = bits >> 1
		FCV_BITS = FCV_BITS >> 1;


	}

	//reg
	//Output: 1 -> B4
	trisb = trisb & 0xEF;
	if ((1))
		portb = (portb & 0xEF) | 0x10;
	else
		portb = portb & 0xEF;

	//Delay
	//Delay: 10 us
	delay_us(10);

	//reg
	//Output: 0 -> B4
	trisb = trisb & 0xEF;
	if ((0))
		portb = (portb & 0xEF) | 0x10;
	else
		portb = portb & 0xEF;

	//Delay
	//Delay: 10 us
	delay_us(10);

}


void FCM_display_win1()
{

	//Calculation
	//Calculation:
	//  hundreds = que1 / 100
	//  tens = (que1 % 100) / 10
	//  ones = que1 % 10
	//  window = 1
	FCV_HUNDREDS = FCV_QUE1 / 100;
	FCV_TENS = (FCV_QUE1 % 100) / 10;
	FCV_ONES = FCV_QUE1 % 10;
	FCV_WINDOW = 1;

	//Calculation
	//Calculation:
	//  digit = window
	FCV_DIGIT = FCV_WINDOW;

	//Call Macro
	//Call Macro: databank()
	FCM_databank();

	//Call Macro
	//Call Macro: display()
	FCM_display();

	//Calculation
	//Calculation:
	//  digit = ones
	FCV_DIGIT = FCV_ONES;

	//Call Macro
	//Call Macro: databank()
	FCM_databank();

	//Call Macro
	//Call Macro: display()
	FCM_display();

	//Calculation
	//Calculation:
	//  digit = tens
	FCV_DIGIT = FCV_TENS;

	//Call Macro
	//Call Macro: databank()
	FCM_databank();

	//Call Macro
	//Call Macro: display()
	FCM_display();

	//Calculation
	//Calculation:
	//  digit = hundreds
	FCV_DIGIT = FCV_HUNDREDS;

	//Call Macro
	//Call Macro: databank()
	FCM_databank();

	//Call Macro
	//Call Macro: display()
	FCM_display();

}


void FCM_display_win2()
{

	//Calculation
	//Calculation:
	//  hundreds = que2 / 100
	//  tens = (que2 % 100) / 10
	//  ones = que2 % 10
	//  window = 2
	FCV_HUNDREDS = FCV_QUE2 / 100;
	FCV_TENS = (FCV_QUE2 % 100) / 10;
	FCV_ONES = FCV_QUE2 % 10;
	FCV_WINDOW = 2;

	//Calculation
	//Calculation:
	//  digit = window
	FCV_DIGIT = FCV_WINDOW;

	//Call Macro
	//Call Macro: databank()
	FCM_databank();

	//Call Macro
	//Call Macro: display()
	FCM_display();

	//Calculation
	//Calculation:
	//  digit = ones
	FCV_DIGIT = FCV_ONES;

	//Call Macro
	//Call Macro: databank()
	FCM_databank();

	//Call Macro
	//Call Macro: display()
	FCM_display();

	//Calculation
	//Calculation:
	//  digit = tens
	FCV_DIGIT = FCV_TENS;

	//Call Macro
	//Call Macro: databank()
	FCM_databank();

	//Call Macro
	//Call Macro: display()
	FCM_display();

	//Calculation
	//Calculation:
	//  digit = hundreds
	FCV_DIGIT = FCV_HUNDREDS;

	//Call Macro
	//Call Macro: databank()
	FCM_databank();

	//Call Macro
	//Call Macro: display()
	FCM_display();

}


void FCM_display_win3()
{

	//Calculation
	//Calculation:
	//  hundreds = que3 / 100
	//  tens = (que3 % 100) / 10
	//  ones = que3 % 10
	//  window = 3
	FCV_HUNDREDS = FCV_QUE3 / 100;
	FCV_TENS = (FCV_QUE3 % 100) / 10;
	FCV_ONES = FCV_QUE3 % 10;
	FCV_WINDOW = 3;

	//Calculation
	//Calculation:
	//  digit = window
	FCV_DIGIT = FCV_WINDOW;

	//Call Macro
	//Call Macro: databank()
	FCM_databank();

	//Call Macro
	//Call Macro: display()
	FCM_display();

	//Calculation
	//Calculation:
	//  digit = ones
	FCV_DIGIT = FCV_ONES;

	//Call Macro
	//Call Macro: databank()
	FCM_databank();

	//Call Macro
	//Call Macro: display()
	FCM_display();

	//Calculation
	//Calculation:
	//  digit = tens
	FCV_DIGIT = FCV_TENS;

	//Call Macro
	//Call Macro: databank()
	FCM_databank();

	//Call Macro
	//Call Macro: display()
	FCM_display();

	//Calculation
	//Calculation:
	//  digit = hundreds
	FCV_DIGIT = FCV_HUNDREDS;

	//Call Macro
	//Call Macro: databank()
	FCM_databank();

	//Call Macro
	//Call Macro: display()
	FCM_display();

}


void FCM_recieve()
{

	//Switch
	//Switch: recieve?
	switch (FCV_RECIEVE)
	{
		case 'A':
		{
			//Call Component Macro
			//Call Component Macro: recieve=ReceiveRS232Char(100)
			FCV_RECIEVE = FCD_RS2320_ReceiveRS232Char(100);

			//Switch
			//Switch: recieve?
			switch (FCV_RECIEVE)
			{
				case '1':
				{
					//Calculation
					//Calculation:
					//  que1 = que1 + 1
					FCV_QUE1 = FCV_QUE1 + 1;

					break;
				}
				case '2':
				{
					//Calculation
					//Calculation:
					//  que1 = que1 - 1
					FCV_QUE1 = FCV_QUE1 - 1;

					break;
				}
				// default:

			}

			//Call Macro
			//Call Macro: reset()
			FCM_reset();

			//Call Macro
			//Call Macro: display_win1()
			FCM_display_win1();

			//Loop
			//Loop: Loop 3 times
			for (FCLV_LOOP3=0; FCLV_LOOP3<3; FCLV_LOOP3++)
			{

				//Call Component Macro
				//Call Component Macro: Enable()
				FCD_PWM0_Enable();

				//Call Component Macro
				//Call Component Macro: SetDutyCycle(75)
				FCD_PWM0_SetDutyCycle(75);

				//Delay
				//Delay: 500 ms
				delay_ms(255);
				delay_ms(245);

				//Call Component Macro
				//Call Component Macro: Disable()
				FCD_PWM0_Disable();

				//Delay
				//Delay: 500 ms
				delay_ms(255);
				delay_ms(245);


			}

			break;
		}
		case 'B':
		{
			//Call Component Macro
			//Call Component Macro: recieve=ReceiveRS232Char(100)
			FCV_RECIEVE = FCD_RS2320_ReceiveRS232Char(100);

			//Switch
			//Switch: recieve?
			switch (FCV_RECIEVE)
			{
				case '1':
				{
					//Calculation
					//Calculation:
					//  que2 = que2 + 1
					FCV_QUE2 = FCV_QUE2 + 1;

					break;
				}
				case '2':
				{
					//Calculation
					//Calculation:
					//  que2 = que2 - 1
					FCV_QUE2 = FCV_QUE2 - 1;

					break;
				}
				// default:

			}

			//Call Macro
			//Call Macro: reset()
			FCM_reset();

			//Call Macro
			//Call Macro: display_win2()
			FCM_display_win2();

			//Loop
			//Loop: Loop 3 times
			for (FCLV_LOOP4=0; FCLV_LOOP4<3; FCLV_LOOP4++)
			{

				//Call Component Macro
				//Call Component Macro: Enable()
				FCD_PWM0_Enable();

				//Call Component Macro
				//Call Component Macro: SetDutyCycle(75)
				FCD_PWM0_SetDutyCycle(75);

				//Delay
				//Delay: 500 ms
				delay_ms(255);
				delay_ms(245);

				//Call Component Macro
				//Call Component Macro: Disable()
				FCD_PWM0_Disable();

				//Delay
				//Delay: 500 ms
				delay_ms(255);
				delay_ms(245);


			}

			break;
		}
		case 'C':
		{
			//Call Component Macro
			//Call Component Macro: recieve=ReceiveRS232Char(100)
			FCV_RECIEVE = FCD_RS2320_ReceiveRS232Char(100);

			//Switch
			//Switch: recieve?
			switch (FCV_RECIEVE)
			{
				case '1':
				{
					//Calculation
					//Calculation:
					//  que3 = que3 + 1
					FCV_QUE3 = FCV_QUE3 + 1;

					break;
				}
				case '2':
				{
					//Calculation
					//Calculation:
					//  que3 = que3 - 1
					FCV_QUE3 = FCV_QUE3 - 1;

					break;
				}
				// default:

			}

			//Call Macro
			//Call Macro: reset()
			FCM_reset();

			//Call Macro
			//Call Macro: display_win3()
			FCM_display_win3();

			//Loop
			//Loop: Loop 3 times
			for (FCLV_LOOP5=0; FCLV_LOOP5<3; FCLV_LOOP5++)
			{

				//Call Component Macro
				//Call Component Macro: Enable()
				FCD_PWM0_Enable();

				//Call Component Macro
				//Call Component Macro: SetDutyCycle(75)
				FCD_PWM0_SetDutyCycle(75);

				//Delay
				//Delay: 500 ms
				delay_ms(255);
				delay_ms(245);

				//Call Component Macro
				//Call Component Macro: Disable()
				FCD_PWM0_Disable();

				//Delay
				//Delay: 500 ms
				delay_ms(255);
				delay_ms(245);


			}

			break;
		}
		// default:

	}

}


void FCM_reset()
{

	//Switch
	//Switch: que1?
	switch (FCV_QUE1)
	{
		case -1:
		{
			//Calculation
			//Calculation:
			//  que1 = 999
			FCV_QUE1 = 999;

			break;
		}
		case 1000:
		{
			//Calculation
			//Calculation:
			//  que1 = 0
			FCV_QUE1 = 0;

			//Loop
			//Loop: Loop 10 times
			for (FCLV_LOOP6=0; FCLV_LOOP6<10; FCLV_LOOP6++)
			{

				//Call Component Macro
				//Call Component Macro: Enable()
				FCD_PWM0_Enable();

				//Call Component Macro
				//Call Component Macro: SetDutyCycle(75)
				FCD_PWM0_SetDutyCycle(75);

				//Delay
				//Delay: 150 ms
				delay_ms(150);

				//Call Component Macro
				//Call Component Macro: Disable()
				FCD_PWM0_Disable();

				//Delay
				//Delay: 150 ms
				delay_ms(150);


			}

			break;
		}
		// default:

	}

	//Switch
	//Switch: que2?
	switch (FCV_QUE2)
	{
		case -1:
		{
			//Calculation
			//Calculation:
			//  que2 = 999
			FCV_QUE2 = 999;

			break;
		}
		case 1000:
		{
			//Calculation
			//Calculation:
			//  que2 = 0
			FCV_QUE2 = 0;

			//Loop
			//Loop: Loop 10 times
			for (FCLV_LOOP7=0; FCLV_LOOP7<10; FCLV_LOOP7++)
			{

				//Call Component Macro
				//Call Component Macro: Enable()
				FCD_PWM0_Enable();

				//Call Component Macro
				//Call Component Macro: SetDutyCycle(75)
				FCD_PWM0_SetDutyCycle(75);

				//Delay
				//Delay: 150 ms
				delay_ms(150);

				//Call Component Macro
				//Call Component Macro: Disable()
				FCD_PWM0_Disable();

				//Delay
				//Delay: 150 ms
				delay_ms(150);


			}

			break;
		}
		// default:

	}

	//Switch
	//Switch: que3?
	switch (FCV_QUE3)
	{
		case -1:
		{
			//Calculation
			//Calculation:
			//  que3 = 999
			FCV_QUE3 = 999;

			break;
		}
		case 1000:
		{
			//Calculation
			//Calculation:
			//  que3 = 0
			FCV_QUE3 = 0;

			//Loop
			//Loop: Loop 10 times
			for (FCLV_LOOP8=0; FCLV_LOOP8<10; FCLV_LOOP8++)
			{

				//Call Component Macro
				//Call Component Macro: Enable()
				FCD_PWM0_Enable();

				//Call Component Macro
				//Call Component Macro: SetDutyCycle(75)
				FCD_PWM0_SetDutyCycle(75);

				//Delay
				//Delay: 150 ms
				delay_ms(150);

				//Call Component Macro
				//Call Component Macro: Disable()
				FCD_PWM0_Disable();

				//Delay
				//Delay: 150 ms
				delay_ms(150);


			}

			break;
		}
		// default:

	}

}



void main()

{
	//Initialization
	ansel = 0;
002A  1683  	BSF STATUS, RP0
002B  1703  	BSF STATUS, RP1
002C  0188  	CLRF gbl_ansel

anselh = 0;
002D  0189  	CLRF gbl_anselh


	
		RS232_5_UART_Init( );		//Call initialise function
002E  2015  	CALL FC_CAL_UAR_00063



	//Interrupt initialization code
	option_reg = 0xC0;
002F  30C0  	MOVLW 0xC0
0030  0081  	MOVWF gbl_option_reg



	//Calculation
	//Calculation:
	//  digit = 1
	FCV_DIGIT = 1;
0031  3001  	MOVLW 0x01
0032  1283  	BCF STATUS, RP0
0033  00CB  	MOVWF gbl_FCV_DIGIT


	//data
	//Output: 0 -> A0
	trisa = trisa & 0xFE;
0034  30FE  	MOVLW 0xFE
0035  1683  	BSF STATUS, RP0
0036  0505  	ANDWF gbl_trisa, W
0037  0085  	MOVWF gbl_trisa

	if ((0))
		porta = (porta & 0xFE) | 0x01;
	else
		porta = porta & 0xFE;
0038  30FE  	MOVLW 0xFE
0039  1283  	BCF STATUS, RP0
003A  0505  	ANDWF gbl_porta, W
003B  0085  	MOVWF gbl_porta


	//clk
	//Output: 0 -> B5
	trisb = trisb & 0xDF;
003C  30DF  	MOVLW 0xDF
003D  1683  	BSF STATUS, RP0
003E  0506  	ANDWF gbl_trisb, W
003F  0086  	MOVWF gbl_trisb

	if ((0))
		portb = (portb & 0xDF) | 0x20;
	else
		portb = portb & 0xDF;
0040  30DF  	MOVLW 0xDF
0041  1283  	BCF STATUS, RP0
0042  0506  	ANDWF gbl_portb, W
0043  0086  	MOVWF gbl_portb


	//reg
	//Output: 0 -> B4
	trisb = trisb & 0xEF;
0044  30EF  	MOVLW 0xEF
0045  1683  	BSF STATUS, RP0
0046  0506  	ANDWF gbl_trisb, W
0047  0086  	MOVWF gbl_trisb

	if ((0))
		portb = (portb & 0xEF) | 0x10;
	else
		portb = portb & 0xEF;
0048  30EF  	MOVLW 0xEF
0049  1283  	BCF STATUS, RP0
004A  0506  	ANDWF gbl_portb, W
004B  0086  	MOVWF gbl_portb


	//Calculation
	//Calculation:
	//  que1 = 123
	//  que2 = 456
	//  que3 = 789
	//  win = 1
	FCV_QUE1 = 123;
004C  307B  	MOVLW 0x7B
004D  00B9  	MOVWF gbl_FCV_QUE1
004E  01BA  	CLRF gbl_FCV_QUE1+D'1'

	FCV_QUE2 = 456;
004F  30C8  	MOVLW 0xC8
0050  00BB  	MOVWF gbl_FCV_QUE2
0051  3001  	MOVLW 0x01
0052  00BC  	MOVWF gbl_FCV_QUE2+D'1'

	FCV_QUE3 = 789;
0053  3015  	MOVLW 0x15
0054  00BD  	MOVWF gbl_FCV_QUE3
0055  3003  	MOVLW 0x03
0056  00BE  	MOVWF gbl_FCV_QUE3+D'1'

	FCV_WIN = 1;
0057  3001  	MOVLW 0x01
0058  00CA  	MOVWF gbl_FCV_WIN


	//Loop
	//Loop: While 1
	while (1)
0059        label2
005D  2859  	GOTO	label2

	{

		//Call Component Macro
		//Call Component Macro: SendRS232Char("a")
		FCD_RS2320_SendRS232Char('a');
0059  3061  	MOVLW 0x61
005A  00CC  	MOVWF FCD_RS2320_00068_arg_nChar
005B  01CD  	CLRF FCD_RS2320_00068_arg_nChar+D'1'
005C  2024  	CALL FCD_RS2320_00068



	}

	//Loop
	//Loop: While 1
	while (1)
	{

		//Loop
		//Loop: While ihap = 30
		while (1)

		{

			//Call Component Macro
			//Call Component Macro: recieve=ReceiveRS232Char(100)
			FCV_RECIEVE = FCD_RS2320_ReceiveRS232Char(100);


			//Decision
			//Decision: recieve = 'D'?
			if (FCV_RECIEVE == 'D')
			{

				//Calculation
				//Calculation:
				//  que1 = 0
				//  que2 = 0
				//  que3 = 0
				FCV_QUE1 = 0;

				FCV_QUE2 = 0;

				FCV_QUE3 = 0;


				//Call Macro
				//Call Macro: display_win1()
				FCM_display_win1();


				//Call Macro
				//Call Macro: display_win2()
				FCM_display_win2();


				//Call Macro
				//Call Macro: display_win3()
				FCM_display_win3();


				//Loop
				//Loop: Loop 10 times
				for (FCLV_LOOP1=0; FCLV_LOOP1<10; FCLV_LOOP1++)
				{

					//Call Component Macro
					//Call Component Macro: Enable()
					FCD_PWM0_Enable();


					//Call Component Macro
					//Call Component Macro: SetDutyCycle(75)
					FCD_PWM0_SetDutyCycle(75);


					//Delay
					//Delay: 150 ms
					delay_ms(150);


					//Call Component Macro
					//Call Component Macro: Disable()
					FCD_PWM0_Disable();


					//Delay
					//Delay: 150 ms
					delay_ms(150);



				}

			} else {

				//Call Macro
				//Call Macro: recieve()
				FCM_recieve();


			}

			//Delay
			//Delay: 1 ms
			delay_ms(1);


			//Calculation
			//Calculation:
			//  ihap = ihap + 1
			FCV_IHAP = FCV_IHAP + 1;



			if ((FCV_IHAP == 30) != 0) break;

		}

		//Connection Point
		//Connection Point: [A]: A
FCC_Main_A:
;

		//Switch
		//Switch: win?
		switch (FCV_WIN)
		{
			case 1:
			{
				//Call Macro
				//Call Macro: display_win1()
				FCM_display_win1();


				break;

			}
			case 2:
			{
				//Call Macro
				//Call Macro: display_win2()
				FCM_display_win2();


				break;

			}
			case 3:
			{
				//Call Macro
				//Call Macro: display_win3()
				FCM_display_win3();


				break;

			}
			case 4:
			{
				//Calculation
				//Calculation:
				//  win = 1
				FCV_WIN = 1;


				//Goto Connection Point
				//Goto Connection Point: [A]: A
				goto FCC_Main_A;

				break;

			}
			// default:

		}

		//Calculation
		//Calculation:
		//  win = win + 1
		FCV_WIN = FCV_WIN + 1;


		//Calculation
		//Calculation:
		//  ihap = 0
		FCV_IHAP = 0;



	}

	mainendloop: goto mainendloop;
}


void MX_INTERRUPT_MACRO(void)

{
}
008E  1283  	BCF STATUS, RP0
008F  1303  	BCF STATUS, RP1
0090  0E36  	SWAPF Int1BContext+D'2', W
0091  0084  	MOVWF FSR
0092  0E35  	SWAPF Int1BContext+D'1', W
0093  008A  	MOVWF PCLATH
0094  0E34  	SWAPF Int1BContext, W
0095  0083  	MOVWF STATUS
0096  0EFF  	SWAPF Int1Context, F
0097  0E7F  	SWAPF Int1Context, W
0098  0009  	RETFIE





/*********************************************************************
 *                  Flowcode CAL UART File
 *
 * File: PIC_CAL_UART.c
 *
 * (c) 2011 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * “Company”) for its Flowcode graphical programming language is
 * intended and supplied to you, the Company’s customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 010911 | BR | Created
 * 020911 | BR | Updated variables with typedef alternatives
 * 011211 | BR | Converted to new dynamic defines mechanism
 * 160112 | BR | Fixed issues with rx return type and low bauds on fast devices
 * 020212 | ST | Added <MX_UART_2_PIE4> routing to account for differences in 16F and 18F devices with 2 UARTs
 * 270212 | BR | Fixed a bug in the receive functionality
 * 280212 | BR | Sorted out auto echo functionality
 * 160412 | BR | Addition of HW change baud function
 */



#ifndef MX_UART_SW_DEFS
	#define MX_UART_SW_DEFS

	#ifdef _BOOSTC
		#define INST_COUNT	45	//65 for lower speeds or 40 for higher speeds.
	#endif
	#ifdef HI_TECH_C
		#define INST_COUNT	315
	#endif

	//Work out number of nops for software baud rate
	#define MX_INSTRUCTION_SPEED 	(MX_CLK_SPEED / 4)
	#define MX_OVERHEAD				(MX_INSTRUCTION_SPEED / INST_COUNT)
	#define SW_OFFSET				(1000000 / MX_OVERHEAD)

	//Work out software baud rates if required
	#define SW_1200_BAUD	(832 - SW_OFFSET)
	#define SW_2400_BAUD	(416 - SW_OFFSET)
	#define SW_4800_BAUD	(208 - SW_OFFSET)
	#define SW_9600_BAUD	(104 - SW_OFFSET)
	#define SW_19200_BAUD	(52 - SW_OFFSET)
	#define SW_31250_BAUD	(32 - SW_OFFSET)
	#define SW_115200_BAUD	(8 - SW_OFFSET)
#endif

 #if defined(MX_UART_CHANNEL_1) && (MX_UART_NUM==1)
	#if (MX_UART_CHANNEL_1 == 0)
		#if (MX_UART_BAUD_1 == 1200)
			#define MX_SOFT_BAUD_1	SW_1200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 1200 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_1 == 2400)
			#define MX_SOFT_BAUD_1	SW_2400_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 2400 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_1 == 4800)
			#define MX_SOFT_BAUD_1	SW_4800_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 4800 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_1 == 9600)
			#define MX_SOFT_BAUD_1	SW_9600_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 9600 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_1 == 19200)
			#define MX_SOFT_BAUD_1	SW_19200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 19200 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_1 == 31250)
			#define MX_SOFT_BAUD_1	SW_31250_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 31250 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_1 == 115200)
			#define MX_SOFT_BAUD_1	SW_115200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 115200 Not Available At This Clock Speed"
			#endif
		#endif
		#ifndef MX_SOFT_BAUD_1
			#error "UART Baud Rate not supported in Software Mode"
		#endif
	#else
		#define MX_SOFT_BAUD_1	1
		#define MX_HARD_BAUD_1	(((MX_CLK_SPEED / MX_UART_BAUD_1) - 16) / 16)
		#define MX_HARD_SLOW_1	0

		#if (MX_HARD_BAUD_1 > 255)
			#undef MX_HARD_BAUD_1
			#undef MX_HARD_SLOW_1
			#define MX_HARD_BAUD_1	(((MX_CLK_SPEED / MX_UART_BAUD_1) - 16)	/ 64)
			#define MX_HARD_SLOW_1	1
		#endif

	#endif
 #endif
 #if defined(MX_UART_CHANNEL_2) && (MX_UART_NUM==2)
	#if (MX_UART_CHANNEL_2 == 0)
		#if (MX_UART_BAUD_2 == 1200)
			#define MX_SOFT_BAUD_2	SW_1200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 1200 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_2 == 2400)
			#define MX_SOFT_BAUD_2	SW_2400_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 2400 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_2 == 4800)
			#define MX_SOFT_BAUD_2	SW_4800_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 4800 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_2 == 9600)
			#define MX_SOFT_BAUD_2	SW_9600_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 9600 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_2 == 19200)
			#define MX_SOFT_BAUD_2	SW_19200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 19200 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_2 == 31250)
			#define MX_SOFT_BAUD_2	SW_31250_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 31250 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_2 == 115200)
			#define MX_SOFT_BAUD_2	SW_115200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 115200 Not Available At This Clock Speed"
			#endif
		#endif
		#ifndef MX_SOFT_BAUD_2
			#error "UART Baud Rate not supported in Software Mode"
		#endif
	#else
		#define MX_SOFT_BAUD_2	1
		#define MX_HARD_BAUD_2	(((MX_CLK_SPEED / MX_UART_BAUD_2) - 16) / 16)
		#define MX_HARD_SLOW_2	0

		#if (MX_HARD_BAUD_2 > 255)
			#undef MX_HARD_BAUD_2
			#undef MX_HARD_SLOW_2
			#define MX_HARD_BAUD_2	(((MX_CLK_SPEED / MX_UART_BAUD_2) - 16)	/ 64)
			#define MX_HARD_SLOW_2	1
		#endif
 	#endif
 #endif
 #if defined(MX_UART_CHANNEL_3) && (MX_UART_NUM==3)
	#if (MX_UART_CHANNEL_3 == 0)
		#if (MX_UART_BAUD_3 == 1200)
			#define MX_SOFT_BAUD_3	SW_1200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 1200 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_3 == 2400)
			#define MX_SOFT_BAUD_3	SW_2400_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 2400 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_3 == 4800)
			#define MX_SOFT_BAUD_3	SW_4800_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 4800 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_3 == 9600)
			#define MX_SOFT_BAUD_3	SW_9600_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 9600 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_3 == 19200)
			#define MX_SOFT_BAUD_3	SW_19200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 19200 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_3 == 31250)
			#define MX_SOFT_BAUD_3	SW_31250_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 31250 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_3 == 115200)
			#define MX_SOFT_BAUD_3	SW_115200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 115200 Not Available At This Clock Speed"
			#endif
		#endif
		#ifndef MX_SOFT_BAUD_3
			#error "UART Baud Rate not supported in Software Mode"
		#endif
	#else
		#define MX_SOFT_BAUD_3	1
		#define MX_HARD_BAUD_3	(((MX_CLK_SPEED / MX_UART_BAUD_3) - 16) / 16)
		#define MX_HARD_SLOW_3	0

		#if (MX_HARD_BAUD_3 > 255)
			#undef MX_HARD_BAUD_3
			#undef MX_HARD_SLOW_3
			#define MX_HARD_BAUD_3	(((MX_CLK_SPEED / MX_UART_BAUD_3) - 16)	/ 64)
			#define MX_HARD_SLOW_3	1
		#endif
	#endif
 #endif
 #if defined(MX_UART_CHANNEL_4) && (MX_UART_NUM==4)
	#if (MX_UART_CHANNEL_4 == 0)
		#if (MX_UART_BAUD_4 == 1200)
			#define MX_SOFT_BAUD_4	SW_1200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 1200 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_4 == 2400)
			#define MX_SOFT_BAUD_4	SW_2400_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 2400 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_4 == 4800)
			#define MX_SOFT_BAUD_4	SW_4800_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 4800 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_4 == 9600)
			#define MX_SOFT_BAUD_4	SW_9600_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 9600 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_4 == 19200)
			#define MX_SOFT_BAUD_4	SW_19200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 19200 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_4 == 31250)
			#define MX_SOFT_BAUD_4	SW_31250_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 31250 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_4 == 115200)
			#define MX_SOFT_BAUD_4	SW_115200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 115200 Not Available At This Clock Speed"
			#endif
		#endif
		#ifndef MX_SOFT_BAUD_4
			#error "UART Baud Rate not supported in Software Mode"
		#endif
	#else
		#define MX_SOFT_BAUD_4	1
		#define MX_HARD_BAUD_4	(((MX_CLK_SPEED / MX_UART_BAUD_4) - 16) / 16)
		#define MX_HARD_SLOW_4	0

		#if (MX_HARD_BAUD_4 > 255)
			#undef MX_HARD_BAUD_4
			#undef MX_HARD_SLOW_4
			#define MX_HARD_BAUD_4	(((MX_CLK_SPEED / MX_UART_BAUD_4) - 16)	/ 64)
			#define MX_HARD_SLOW_4	1
		#endif
	#endif
 #endif


//Hardware Baud update definitions
#ifndef MX_HARD_BAUD_CHANGE_DEFS
	#define MX_HARD_BAUD_CHANGE_DEFS

	#define MX_HARD_BAUD_1200	(((MX_CLK_SPEED / 1200) - 16) / 16)
	#if (MX_HARD_BAUD_1200 > 255)
		#undef MX_HARD_BAUD_1200
		#define MX_HARD_BAUD_1200	(((MX_CLK_SPEED / 1200) - 16) / 64)
		#define MX_HARD_SLOW_1200	1
	#else
		#define MX_HARD_SLOW_1200	0
	#endif

	#define MX_HARD_BAUD_2400	(((MX_CLK_SPEED / 2400) - 16) / 16)
	#if (MX_HARD_BAUD_2400 > 255)
		#undef MX_HARD_BAUD_2400
		#define MX_HARD_BAUD_2400	(((MX_CLK_SPEED / 2400) - 16) / 64)
		#define MX_HARD_SLOW_2400	1
	#else
		#define MX_HARD_SLOW_2400	0
	#endif

	#define MX_HARD_BAUD_4800	(((MX_CLK_SPEED / 4800) - 16) / 16)
	#if (MX_HARD_BAUD_4800 > 255)
		#undef MX_HARD_BAUD_4800
		#define MX_HARD_BAUD_4800	(((MX_CLK_SPEED / 4800) - 16) / 64)
		#define MX_HARD_SLOW_4800	1
	#else
		#define MX_HARD_SLOW_4800	0
	#endif

	#define MX_HARD_BAUD_9600	(((MX_CLK_SPEED / 9600) - 16) / 16)
	#if (MX_HARD_BAUD_9600 > 255)
		#undef MX_HARD_BAUD_9600
		#define MX_HARD_BAUD_9600	(((MX_CLK_SPEED / 9600) - 16) / 64)
		#define MX_HARD_SLOW_9600	1
	#else
		#define MX_HARD_SLOW_9600	0
	#endif

	#define MX_HARD_BAUD_19200	(((MX_CLK_SPEED / 19200) - 16) / 16)
	#if (MX_HARD_BAUD_19200 > 255)
		#undef MX_HARD_BAUD_19200
		#define MX_HARD_BAUD_19200	(((MX_CLK_SPEED / 19200) - 16) / 64)
		#define MX_HARD_SLOW_19200	1
	#else
		#define MX_HARD_SLOW_19200	0
	#endif

	#define MX_HARD_BAUD_38400	(((MX_CLK_SPEED / 38400) - 16) / 16)
	#if (MX_HARD_BAUD_38400 > 255)
		#undef MX_HARD_BAUD_38400
		#define MX_HARD_BAUD_38400	(((MX_CLK_SPEED / 38400) - 16) / 64)
		#define MX_HARD_SLOW_38400	1
	#else
		#define MX_HARD_SLOW_38400	0
	#endif

	#define MX_HARD_BAUD_57600	(((MX_CLK_SPEED / 57600) - 16) / 16)
	#if (MX_HARD_BAUD_57600 > 255)
		#undef MX_HARD_BAUD_57600
		#define MX_HARD_BAUD_57600	(((MX_CLK_SPEED / 57600) - 16) / 64)
		#define MX_HARD_SLOW_57600	1
	#else
		#define MX_HARD_SLOW_57600	0
	#endif

	#define MX_HARD_BAUD_115200	(((MX_CLK_SPEED / 115200) - 16) / 16)
	#if (MX_HARD_BAUD_115200 > 255)
		#undef MX_HARD_BAUD_115200
		#define MX_HARD_BAUD_115200	(((MX_CLK_SPEED / 115200) - 16) / 64)
		#define MX_HARD_SLOW_115200	1
	#else
		#define MX_HARD_SLOW_115200	0
	#endif
#endif


//Dynamic function naming based on defines and index number
#define MX_UART_CHANNEL_X	CAL_APPEND(MX_UART_CHANNEL_, MX_UART_NUM)
#define MX_UART_TX_PIN_X	CAL_APPEND(MX_UART_TX_PIN_, MX_UART_NUM)
#define MX_UART_TX_PORT_X	CAL_APPEND(MX_UART_TX_PORT_, MX_UART_NUM)
#define MX_UART_TX_TRIS_X	CAL_APPEND(MX_UART_TX_TRIS_, MX_UART_NUM)
#define MX_UART_RX_PIN_X	CAL_APPEND(MX_UART_RX_PIN_, MX_UART_NUM)
#define MX_UART_RX_PORT_X	CAL_APPEND(MX_UART_RX_PORT_, MX_UART_NUM)
#define MX_UART_RX_TRIS_X	CAL_APPEND(MX_UART_RX_TRIS_, MX_UART_NUM)
#define MX_UART_FLOWEN_X	CAL_APPEND(MX_UART_FLOWEN_, MX_UART_NUM)
#define MX_UART_CTS_PIN_X	CAL_APPEND(MX_UART_CTS_PIN_, MX_UART_NUM)
#define MX_UART_CTS_PORT_X	CAL_APPEND(MX_UART_CTS_PORT_, MX_UART_NUM)
#define MX_UART_CTS_TRIS_X	CAL_APPEND(MX_UART_CTS_TRIS_, MX_UART_NUM)
#define MX_UART_RTS_PIN_X	CAL_APPEND(MX_UART_RTS_PIN_, MX_UART_NUM)
#define MX_UART_RTS_PORT_X	CAL_APPEND(MX_UART_RTS_PORT_, MX_UART_NUM)
#define MX_UART_RTS_TRIS_X	CAL_APPEND(MX_UART_RTS_TRIS_, MX_UART_NUM)
#define MX_UART_DBITS_X		CAL_APPEND(MX_UART_DBITS_, MX_UART_NUM)
#define MX_UART_RETURN_X	CAL_APPEND(MX_UART_RETURN_, MX_UART_NUM)
#define MX_UART_ECHO_X		CAL_APPEND(MX_UART_ECHO_, MX_UART_NUM)
#define MX_UART_INT_X		CAL_APPEND(MX_UART_INT_, MX_UART_NUM)
#define MX_UART_BAUD_X		CAL_APPEND(MX_HARD_BAUD_, MX_UART_NUM)
#define MX_SOFT_BAUD_X		CAL_APPEND(MX_SOFT_BAUD_, MX_UART_NUM)
#define MX_HARD_SLOW_X		CAL_APPEND(MX_HARD_SLOW_, MX_UART_NUM)

#define UART_Delay_CAL		CAL_APPEND(FC_CAL_UART_Delay_, MX_UART_NUM)
#define UART_Send			CAL_APPEND(FC_CAL_UART_Send_, MX_UART_NUM)
#define UART_Uninit			CAL_APPEND(FC_CAL_UART_Uninit_, MX_UART_NUM)


//Component Definitions
#define UART_STATUS_LOOP	0
#define UART_STATUS_TIMEOUT	1
#define UART_STATUS_RXBYTE	2


//Interrupt Definitions
#ifdef MX_UART_2_PIE4
  #define MX_UART2_PIE pie4
  #define MX_UART2_PIR pir4
  #define MX_UART2_TXSTA tx2sta
  #define MX_UART2_RCSTA rc2sta
  #define MX_UART2_TXREG tx2reg
  #define MX_UART2_RCREG rc2reg
#else
  #define MX_UART2_PIE pie3
  #define MX_UART2_PIR pir3
  #define MX_UART2_TXSTA txsta2
  #define MX_UART2_RCSTA rcsta2
  #define MX_UART2_TXREG txreg2
  #define MX_UART2_RCREG rcreg2
#endif

#if (MX_UART_INT_X == 1)

	#ifndef MX_UART_INT_DEFS
	#define MX_UART_INT_DEFS

		#define MX_UART_INT_CH1_FUNC
		#define MX_UART_INT_CH2_FUNC
		#define MX_UART_INT_FUNC_END

		#define MX_UART_INT_CH1_DET		ts_bit(pir1, RCIF) && ts_bit(pie1, RCIE)
		#define MX_UART_INT_CH2_DET		ts_bit(MX_UART2_PIR, RC2IF) && ts_bit(MX_UART2_PIE, RC2IE)

		#define MX_UART_INT_CH1_EN		st_bit (pie1, RCIE)
		#define MX_UART_INT_CH2_EN		st_bit (MX_UART2_PIE, RC2IE)

		#define MX_UART_INT_CH1_DIS		cr_bit (pie1, RCIE)
		#define MX_UART_INT_CH2_DIS		cr_bit (MX_UART2_PIE, RC2IE)

		#define MX_UART_INT_CH1_CLR		cr_bit (pir1, RCIF)
		#define MX_UART_INT_CH2_CLR		cr_bit (MX_UART2_PIR, RC2IF)

	#endif
#endif


//Function Prototypes
CALFUNCTION(void, FC_CAL_UART_Init_, (void));
CALFUNCTION(void, FC_CAL_UART_Uninit_, (void));
CALFUNCTION(void, FC_CAL_UART_Send_, (MX_UINT16 nChar));
CALFUNCTION(MX_SINT16, FC_CAL_UART_Receive_, (MX_UINT8 nTimeout));
CALFUNCTION(void, FC_CAL_UART_Delay_, (void));


//Peripheral Functions
CALFUNCTION(void, FC_CAL_UART_Init_, (void))

{

	#if (MX_UART_CHANNEL_X == 0)
		FC_CAL_Bit_In_DDR 	(MX_UART_RX_PORT_X, MX_UART_RX_TRIS_X, MX_UART_RX_PIN_X);		// Receive pin is a input
		FC_CAL_Bit_High_DDR (MX_UART_TX_PORT_X, MX_UART_TX_TRIS_X, MX_UART_TX_PIN_X);		// Transmit pin is default high
	#endif

	#if (MX_UART_CHANNEL_X == 1)
	  #ifndef MX_UART_1
	  	  #error "UART channel 1 not available on this device"
	  #else
		  #if (MX_HARD_SLOW_X == 1)
			cr_bit(txsta, BRGH);						//Low Speed
		  #else
			st_bit(txsta, BRGH);						//High Speed
0015  1683  	BSF STATUS, RP0
0016  1303  	BCF STATUS, RP1
0017  1518  	BSF gbl_txsta,2

		  #endif
			spbrg = MX_UART_BAUD_X;   					// set the baud rate
0018  3081  	MOVLW 0x81
0019  0099  	MOVWF gbl_spbrg

			rcsta = 0;                    				// 8-bit, disabled
001A  1283  	BCF STATUS, RP0
001B  0198  	CLRF gbl_rcsta


			#if(MX_UART_DBITS_X == 9)
				st_bit(txsta, TX9);   					// 9-bit TX
				st_bit(rcsta, RX9);                    	// 9-bit RX
			#endif

			st_bit(rcsta, SPEN);         				// turn on serial interface
001C  1798  	BSF gbl_rcsta,7

			st_bit(txsta, TXEN);
001D  1683  	BSF STATUS, RP0
001E  1698  	BSF gbl_txsta,5

			st_bit(rcsta, CREN);
001F  1283  	BCF STATUS, RP0
0020  1618  	BSF gbl_rcsta,4


			#if (MX_UART_INT_X == 1)
				MX_UART_INT_CH1_EN;
				st_bit(intcon, PEIE);
				st_bit(intcon, GIE);
			#else
				cr_bit (pie1, RCIE);
0021  1683  	BSF STATUS, RP0
0022  128C  	BCF gbl_pie1,5

			#endif
	  #endif
	#endif


	#if (MX_UART_CHANNEL_X == 2)

	  #ifndef MX_UART_2
		  #error "UART channel 2 not available on this device"
	  #else
		  #ifdef MX_UART_2_REMAPPABLE
			RPOR9 = 5;									//TX2 - RP9 - RB6
			RPINR16	= 10;								//RX2 - RP10 - RB7
		  #endif
		  #if (MX_HARD_SLOW_X == 1)
			cr_bit(MX_UART2_TXSTA, BRGH);						//Low Speed
		  #else
			st_bit(MX_UART2_TXSTA, BRGH);						//High Speed
		  #endif
			spbrg2 = MX_UART_BAUD_X;   				// set the baud rate
			MX_UART2_RCSTA = 0;                    				// 8-bit, disabled

			#if(MX_UART_DBITS_X == 9)
				st_bit(MX_UART2_TXSTA, TX9);   					// 9-bit TX
				st_bit(MX_UART2_RCSTA, RX9);                    // 9-bit RX
			#endif

			st_bit(MX_UART2_RCSTA, SPEN);         				// turn on serial interface
			st_bit(MX_UART2_TXSTA, TXEN);
			st_bit(MX_UART2_RCSTA, CREN);

			#if (MX_UART_INT_X == 1)
				MX_UART_INT_CH2_EN;
				st_bit(intcon, PEIE);
				st_bit(intcon, GIE);
			#else
				cr_bit (MX_UART2_PIE, RC2IE);
			#endif
	  #endif
	#endif

	#if (MX_UART_FLOWEN_X == 1)						//Flowcontrol enabled?
		FC_CAL_Bit_In_DDR (MX_UART_CTS_PORT_X, MX_UART_CTS_TRIS_X, MX_UART_CTS_PIN_X);	// CTS pin is a input
		FC_CAL_Bit_High_DDR (MX_UART_RTS_PORT_X, MX_UART_RTS_TRIS_X, MX_UART_RTS_PIN_X);	// RTS not ready to accept data
	#endif

}
0023  0008  	RETURN




CALFUNCTION(void, FC_CAL_UART_Uninit_, (void))
{

	#if (MX_UART_CHANNEL_X == 0)
		FC_CAL_Bit_In_DDR (MX_UART_RX_PORT_X, MX_UART_RX_TRIS_X, MX_UART_RX_PIN_X);		// Receive pin is a input
		FC_CAL_Bit_In_DDR (MX_UART_TX_PORT_X, MX_UART_TX_TRIS_X, MX_UART_TX_PIN_X);		// Transmit pin is default high
	#endif

	#if (MX_UART_CHANNEL_X == 1)
			rcsta = 0;                    								// 8-bit, disabled
			txsta = 0;
		  #ifdef MX_UART_RXINT
			MX_UART_INT_CH1_DIS;
		  #endif
	#endif

	#if (MX_UART_CHANNEL_X == 2)
			MX_UART2_RCSTA = 0;                    								// 8-bit, disabled
			MX_UART2_TXSTA = 0;
		  #ifdef MX_UART_RXINT
			MX_UART_INT_CH2_DIS;
		  #endif
	#endif

	#if (MX_UART_FLOWEN_X == 1)										//Flowcontrol enabled?
		FC_CAL_Bit_In_DDR (MX_UART_CTS_PORT_X, MX_UART_CTS_TRIS_X, MX_UART_CTS_PIN_X);		// CTS pin is a input
		FC_CAL_Bit_In_DDR (MX_UART_RTS_PORT_X, MX_UART_RTS_TRIS_X, MX_UART_RTS_PIN_X);		// RTS not ready to accept data
	#endif
}



CALFUNCTION(void, FC_CAL_UART_Send_, (MX_UINT16 nChar))

{
	#if (MX_UART_FLOWEN_X == 1)
		while (FC_CAL_Bit_In(MX_UART_CTS_PORT_X, MX_UART_CTS_PIN_X) != 0);	// Wait until CTS is low
	#endif

	#if (MX_UART_CHANNEL_X == 0)													// Software UART TX
		MX_UINT8 idx;
		FC_CAL_Bit_Low(MX_UART_TX_PORT_X, MX_UART_TX_PIN_X);					// Send Start bit
		UART_Delay_CAL();
		for (idx = 0; idx < MX_UART_DBITS_X; idx++)
		{
			if (nChar & 0x01)														// Mask off data bit
				FC_CAL_Bit_High(MX_UART_TX_PORT_X, MX_UART_TX_PIN_X);
			else
				FC_CAL_Bit_Low(MX_UART_TX_PORT_X, MX_UART_TX_PIN_X);
			UART_Delay_CAL();
			nChar = nChar >> 1;														// Move to next data bit
		}
		FC_CAL_Bit_High(MX_UART_TX_PORT_X, MX_UART_TX_PIN_X);					// Send Stop bit
		UART_Delay_CAL();
	#endif

	#if (MX_UART_CHANNEL_X == 1)
		while (ts_bit(pir1, TXIF) == 0);
0010        label1
0010  1E0C  	BTFSS gbl_pir1,4
0011  2810  	GOTO	label1


		#if (MX_UART_DBITS_X == 9)
			if (test_bit(nChar, 8))
				st_bit(txsta, TX9D);
			else
				cr_bit(txsta, TX9D);
	  	#endif
		txreg = nChar;
0012  084E  	MOVF FC_CAL_UAR_00064_arg_nChar, W
0013  0099  	MOVWF gbl_txreg

	#endif

	#if (MX_UART_CHANNEL_X == 2)
		while (ts_bit(pir3, TX2IF) == 0);

		#if (MX_UART_DBITS_X == 9)
			if (test_bit(nChar, 8))
				st_bit(MX_UART2_TXSTA, TX9D);
			else
				cr_bit(MX_UART2_TXSTA, TX9D);
		#endif
		MX_UART2_TXREG = nChar;
	#endif
}
0014  0008  	RETURN



CALFUNCTION(MX_SINT16, FC_CAL_UART_Receive_, (MX_UINT8 nTimeout))
{
  #if (MX_UART_RETURN_X == 1)
	MX_UINT16 retVal = 512;
  #else
  	MX_UINT8 retVal = 255;
  #endif

	MX_UINT8 delay1 = 0;
	MX_UINT8 regcheck = 0;
	MX_UINT8 bWaitForever = 0;
	MX_UINT8 rxStatus = UART_STATUS_LOOP;

  #if (MX_UART_CHANNEL_X == 0)
  	MX_UINT8 idx;
  #else
  	MX_UINT8 dummy = 0;
  #endif

	if (nTimeout == 255)
		bWaitForever = 1;

	#if (MX_UART_FLOWEN_X == 1)
		FC_CAL_Bit_Low (MX_UART_RTS_PORT_X, MX_UART_RTS_PIN_X);			// Ready to accept data
	#endif

	while (rxStatus == UART_STATUS_LOOP)
	{
		if (bWaitForever == 0)
		{
			if (nTimeout == 0)							//don't wait forever, so do timeout thing...
			{
				rxStatus = UART_STATUS_TIMEOUT;
			}
			else
			{
				delay_us(10);
				delay1 = delay1 + 1;
				if(delay1 == 100)
				{
					nTimeout = nTimeout - 1;
					MX_CLEAR_WATCHDOG;
					delay1 = 0;
				}
			}
		}

		#if (MX_UART_CHANNEL_X == 0)
			regcheck = FC_CAL_Bit_In(MX_UART_RX_PORT_1, MX_UART_RX_PIN_1);	//Test for start bit
			if (regcheck == 0)
				rxStatus = UART_STATUS_RXBYTE;
		#endif

		#if (MX_UART_CHANNEL_X == 1)
			regcheck = ts_bit(pir1, RCIF);
			if (regcheck != 0)
				rxStatus = UART_STATUS_RXBYTE;
		#endif

		#if (MX_UART_CHANNEL_X == 2)
			regcheck = ts_bit(MX_UART2_PIR, RC2IF);
			if (regcheck != 0)
				rxStatus = UART_STATUS_RXBYTE;
		#endif

	}

	if (rxStatus == UART_STATUS_RXBYTE)
	{
		#if (MX_UART_CHANNEL_X == 0)

			retVal = 0;
			UART_Delay_CAL();

			for (idx = 0; idx < MX_UART_DBITS_X; idx++)
			{
				if (FC_CAL_Bit_In(MX_UART_RX_PORT_X, MX_UART_RX_PIN_X))
					retVal = retVal | (0x01 << idx);

				UART_Delay_CAL();
			}
		#endif

		#if (MX_UART_CHANNEL_X == 1)
			regcheck = ts_bit(rcsta, FERR);
			if (regcheck != 0)
			{
				dummy = rcreg;						//need to read the rcreg to clear FERR
				#if (MX_UART_RETURN_X == 1)
					retVal = 0x400;					//Framing Error Flag
				#endif
			}
			else
			{
				regcheck = ts_bit(rcsta, OERR);
				if (regcheck != 0)
				{
					cr_bit(rcsta, CREN);			//Reset receiver to clear error
					st_bit(rcsta, CREN);

					#if (MX_UART_RETURN_X == 1)
						retVal = 0x800;				//Overrun Error Flag
					#endif
				}
				else
				{
					retVal = 0;

					#if (MX_UART_DBITS_X == 9)
						if(ts_bit(rcsta, RX9D))
							retVal = 0x100;
					#endif

					retVal = retVal | rcreg; 			//no error, so rx byte is valid
				}
			}
		#endif

		#if (MX_UART_CHANNEL_X == 2)
			regcheck = ts_bit(MX_UART2_RCSTA, FERR);
			if (regcheck != 0)
			{
				dummy = MX_UART2_RCREG;			//need to read the rcreg to clear FERR
				#if (MX_UART_RETURN_X == 1)
					retVal = 0x400;					//Framing Error Flag
				#endif
			}
			else
			{
				regcheck = ts_bit(MX_UART2_RCSTA, OERR);
				if (regcheck != 0)
				{
					cr_bit(MX_UART2_RCSTA, CREN);	//Reset receiver to clear error
					st_bit(MX_UART2_RCSTA, CREN);
					#if (MX_UART_RETURN_X == 1)
						retVal = 0x800;				//Overrun Error Flag
					#endif
				}
				else
				{
					retVal = 0;

					#if (MX_UART_DBITS_X == 9)
						if(ts_bit(MX_UART2_RCSTA, RX9D))
							retVal = 0x100;
					#endif

					retVal = retVal | MX_UART2_RCREG; 			//no error, so rx byte is valid
				}
			}

		#endif

		#if (MX_UART_ECHO_X == 1)
			UART_Send(retVal);
		#endif
	}

	#if (MX_UART_FLOWEN_X == 1)
		FC_CAL_Bit_High(MX_UART_RTS_PORT_X, MX_UART_RTS_PIN_X);		//not ready to accept data
	#endif

	return (retVal);
}


CALFUNCTION(void, FC_CAL_UART_Delay_, (void))
{
  #if (MX_UART_CHANNEL_X == 0)

	MX_UINT16 delay = MX_SOFT_BAUD_X;

	while (delay > 255)
	{
		delay_us(255);
		delay = delay - 255;
		MX_CLEAR_WATCHDOG;
	}
	delay_us(delay);
	MX_CLEAR_WATCHDOG;

  #endif
}


CALFUNCTION(void, FC_CAL_UART_Update_Baud_, (MX_UINT8 new_baud))
{
	//Baud Rates - Function compatible with hardware mode only
	/*
	0 - 1200
	1 - 2400
	2 - 4800
	3 - 9600
	4 - 19200
	5 - 38400
	6 - 57600
	7 - 115200
	*/

	MX_UINT8 baudrate, baudmode;

	if (new_baud > 7)
		return;

	if (new_baud == 0)
	{
		baudrate = MX_HARD_BAUD_1200;
		baudmode = MX_HARD_SLOW_1200;
	}
	else if (new_baud == 1)
	{
		baudrate = MX_HARD_BAUD_2400;
		baudmode = MX_HARD_SLOW_2400;
	}
	else if (new_baud == 2)
	{
		baudrate = MX_HARD_BAUD_4800;
		baudmode = MX_HARD_SLOW_4800;
	}
	else if (new_baud == 3)
	{
		baudrate = MX_HARD_BAUD_9600;
		baudmode = MX_HARD_SLOW_9600;
	}
	else if (new_baud == 4)
	{
		baudrate = MX_HARD_BAUD_19200;
		baudmode = MX_HARD_SLOW_19200;
	}
	else if (new_baud == 5)
	{
		baudrate = MX_HARD_BAUD_38400;
		baudmode = MX_HARD_SLOW_38400;
	}
	else if (new_baud == 6)
	{
		baudrate = MX_HARD_BAUD_57600;
		baudmode = MX_HARD_SLOW_57600;
	}
	else if (new_baud == 7)
	{
		baudrate = MX_HARD_BAUD_115200;
		baudmode = MX_HARD_SLOW_115200;
	}

	UART_Uninit();

	#if (MX_UART_CHANNEL_X == 1)

	    if (baudmode == 1)
			cr_bit(txsta, BRGH);					//Low Speed
	    else
			st_bit(txsta, BRGH);					//High Speed

		spbrg = baudrate;   						// set the baud rate
		rcsta = 0;                    				// 8-bit, disabled

		#if(MX_UART_DBITS_X == 9)
			st_bit(txsta, TX9);   					// 9-bit TX
			st_bit(rcsta, RX9);                    	// 9-bit RX
		#endif

		st_bit(rcsta, SPEN);         				// turn on serial interface
		st_bit(txsta, TXEN);
		st_bit(rcsta, CREN);

		#if (MX_UART_INT_X == 1)
			MX_UART_INT_CH1_EN;
			st_bit(intcon, PEIE);
			st_bit(intcon, GIE);
		#else
			cr_bit (pie1, RCIE);
		#endif
	#endif

	#if (MX_UART_CHANNEL_X == 2)

	  	if (baudmode == 1)
			cr_bit(MX_UART2_TXSTA, BRGH);			//Low Speed
	  	else
			st_bit(MX_UART2_TXSTA, BRGH);			//High Speed

		spbrg2 = baudrate;   						// set the baud rate
		MX_UART2_RCSTA = 0;                    		// 8-bit, disabled

		#if(MX_UART_DBITS_X == 9)
			st_bit(MX_UART2_TXSTA, TX9);   			// 9-bit TX
			st_bit(MX_UART2_RCSTA, RX9);            // 9-bit RX
		#endif

		st_bit(MX_UART2_RCSTA, SPEN);         		// turn on serial interface
		st_bit(MX_UART2_TXSTA, TXEN);
		st_bit(MX_UART2_RCSTA, CREN);

		#if (MX_UART_INT_X == 1)
			MX_UART_INT_CH2_EN;
			st_bit(intcon, PEIE);
			st_bit(intcon, GIE);
		#else
			cr_bit (MX_UART2_PIE, RC2IE);
		#endif
	#endif

	#if (MX_UART_FLOWEN_X == 1)						//Flowcontrol enabled?
		FC_CAL_Bit_In_DDR (MX_UART_CTS_PORT_X, MX_UART_CTS_TRIS_X, MX_UART_CTS_PIN_X);	// CTS pin is a input
		FC_CAL_Bit_High_DDR (MX_UART_RTS_PORT_X, MX_UART_RTS_TRIS_X, MX_UART_RTS_PIN_X);	// RTS not ready to accept data
	#endif

}

////////////////////////////////////////
// Code with no source :-)
////////////////////////////////////////
0000  285E  	GOTO	_startup

0004  00FF  	MOVWF Int1Context
0005  0E03  	SWAPF STATUS, W
0006  1283  	BCF STATUS, RP0
0007  1303  	BCF STATUS, RP1
0008  00B4  	MOVWF Int1BContext
0009  0E0A  	SWAPF PCLATH, W
000A  00B5  	MOVWF Int1BContext+D'1'
000B  0E04  	SWAPF FSR, W
000C  00B6  	MOVWF Int1BContext+D'2'
000D  118A  	BCF PCLATH,3
000E  120A  	BCF PCLATH,4
000F  288E  	GOTO	interrupt

005E        _startup
005E  30D5  	MOVLW 0xD5
005F  1283  	BCF STATUS, RP0
0060  1303  	BCF STATUS, RP1
0061  00A0  	MOVWF gbl_14_LSR
0062  30C4  	MOVLW 0xC4
0063  00A1  	MOVWF gbl_14_LSR+D'1'
0064  30BB  	MOVLW 0xBB
0065  00A2  	MOVWF gbl_14_LSR+D'2'
0066  30DC  	MOVLW 0xDC
0067  00A3  	MOVWF gbl_14_LSR+D'3'
0068  01A4  	CLRF gbl_15_gbl_aSig
0069  01A5  	CLRF gbl_15_gbl_aSig+D'1'
006A  01A6  	CLRF gbl_15_gbl_aSig+D'2'
006B  01A7  	CLRF gbl_15_gbl_aSig+D'3'
006C  01A8  	CLRF gbl_15_gbl_bSig
006D  01A9  	CLRF gbl_15_gbl_bSig+D'1'
006E  01AA  	CLRF gbl_15_gbl_bSig+D'2'
006F  01AB  	CLRF gbl_15_gbl_bSig+D'3'
0070  01AC  	CLRF gbl_15_gbl_zSig
0071  01AD  	CLRF gbl_15_gbl_zSig+D'1'
0072  01AE  	CLRF gbl_15_gbl_zSig+D'2'
0073  01AF  	CLRF gbl_15_gbl_zSig+D'3'
0074  01C4  	CLRF gbl_15_gbl_aExp
0075  01C5  	CLRF gbl_15_gbl_bExp
0076  01B7  	CLRF gbl_15_gbl_zExp
0077  01B8  	CLRF gbl_15_gbl_zExp+D'1'
0078  01C6  	CLRF gbl_15_gbl_aSign
0079  01C7  	CLRF gbl_15_gbl_bSign
007A  01C8  	CLRF gbl_15_gbl_zSign
007B  01C9  	CLRF gbl_15_gbl_zSigZero
007C  01B0  	CLRF gbl_15_gbl_ret
007D  01B1  	CLRF gbl_15_gbl_ret+D'1'
007E  01B2  	CLRF gbl_15_gbl_ret+D'2'
007F  01B3  	CLRF gbl_15_gbl_ret+D'3'
0080  01C2  	CLRF gbl_float_rounding_mode
0081  01C3  	CLRF gbl_float_exception_flags
0082  01C1  	CLRF gbl_float_detect_tininess

008B  118A  	BCF PCLATH,3
008C  120A  	BCF PCLATH,4
008D  282A  	GOTO	main

2007  20D2  	DW 0x20D2
2008  3EFF  	DW 0x3EFF
