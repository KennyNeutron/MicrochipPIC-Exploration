;/////////////////////////////////////////////////////////////////////////////////
;// Code Generator: BoostC Compiler - http://www.sourceboost.com
;// Version       : 7.03
;// License Type  : Pro License
;// Limitations   : PIC12,PIC16 max code size:Unlimited, max RAM banks:Unlimited
;/////////////////////////////////////////////////////////////////////////////////

//************************************************************************************
//**  
//**  File name:     D:\KennyNeutronsInnovations\VendoMachine\Flowcode\VendoMachine.c
//**  Title:         
//**  Description:   
//**  
//**  Generated by:  Flowcode v5.2.0.0
//**  Date:          Saturday, February 02, 2019 20:18:33
//**  Licence:       Professional
//**  Registered to: xyz
//**  Licence key:   WUK7B9
//**  
//**  
//**  http://www.matrixmultimedia.com
//**  
//************************************************************************************


#define MX_PIC

#define MX_USES_UINT8 1
#define MX_USES_SINT16 1
#define MX_USES_CHAR 0
#define MX_USES_FLOAT 0
#define MX_USES_SINT32 0
#define MX_USES_BOOL 1
#define MX_USES_UINT16 0
#define MX_USES_UINT32 0
//Defines for microcontroller
#define P16F690
#define FC_CAL_PIC
#define MX_ADC
#define MX_ADC_TYPE_3
#define MX_ADC_BITS_10
#define MX_EE
#define MX_EE_TYPE2
#define MX_EE_SIZE 256
#define MX_SPI_1
#define MX_SPI_1_MISO_PORT portb
#define MX_SPI_1_MISO_TRIS trisb
#define MX_SPI_1_MISO_PIN 4
#define MX_SPI_1_MOSI_PORT portc
#define MX_SPI_1_MOSI_TRIS trisc
#define MX_SPI_1_MOSI_PIN 7
#define MX_SPI_1_CLK_PORT portb
#define MX_SPI_1_CLK_TRIS trisb
#define MX_SPI_1_CLK_PIN 6
#define MX_SPI_1_SS_PORT portb
#define MX_SPI_1_SS_TRIS trisb
#define MX_UART_1
#define MX_UART_1_TX_PORT portb
#define MX_UART_1_TX_TRIS trisb
#define MX_UART_1_TX_PIN 7
#define MX_UART_1_RX_PORT portb
#define MX_UART_1_RX_TRIS trisb
#define MX_UART_1_RX_PIN 5
#define MX_I2C
#define MX_MI2C
#define MX_I2C_1
#define MX_I2C_1_SDA_PORT portb
#define MX_I2C_1_SDA_TRIS trisb
#define MX_I2C_1_SDA_PIN 4
#define MX_I2C_1_SCL_PORT portb
#define MX_I2C_1_SCL_TRIS trisb
#define MX_I2C_1_SCL_PIN 6
#define MX_PWM
#define MX_PWM_CNT 1
#define MX_PWM_PSCA1
#define MX_PWM_PSCA4
#define MX_PWM_PSCA16
#define MX_PWM_1_PORT portc
#define MX_PWM_1_TRIS trisc
#define MX_PWM_1_PIN 5

//Functions
#define MX_CLK_SPEED 4000000
#ifdef _BOOSTC
#include <system.h>
#endif
#ifdef HI_TECH_C
#include <pic.h>
#endif

//Configuration data
#ifdef _BOOSTC
#pragma DATA 0x2007, 0x30d4
#endif
#ifdef HI_TECH_C
__CONFIG(0x30d4);
#endif

//Internal functions
#include "C:\Program Files (x86)\Flowcode\v5\FCD\internals.c"

//Macro function declarations
void FCM_row1_forward();
void FCM_row1_reverse();
void FCM_row3_forward();
void FCM_row4_forward();
void FCM_row3_reverse();
void FCM_row4_reverse();
void FCM_row2_forward();
void FCM_row2_reverse();
void FCM_row1_stop();
void FCM_row2_stop();
void FCM_row3_stop();
void FCM_row4_stop();


//Variable declarations
#define FCV_TRUE (1)
#define FCV_FALSE (0)
MX_UINT8 FCV_LOOP = (0x0);
0288  01C4  	CLRF gbl_FCV_LOOP

MX_UINT8 FCV_ROW;
MX_UINT8 FCV_RX;
MX_SINT16 FCV_DELAY = (0);
0289  01B9  	CLRF gbl_FCV_DELAY
028A  01BA  	CLRF gbl_FCV_DELAY+D'1'

MX_UINT8 FCV_QUANT;




//RS232(0): //Defines:

/**** Macro Substitutions ****
a = Unique Reference
b = Uart Channel		(0-software / 1-4 hardware)
c = tx pin
d = tx port
e = rx pin
f = rx port
g = flow control		(0-Off / 1-On)
h = cts pin
i = cts port
j = rts pin
k = rts port
l = baud rate
m = data bits			(7/8/9) (7 only supported in software modes)
n = return type		(0-byte / 1-MX_UINT16)
o = echo enable		(0-Off / 1-On)
******************************/

//Definitions for RS232 UART slot allocation
#ifndef	MX_UART_REF1
	#define MX_UART_REF1
	#define RS232_1_MX_UART_UREF			1
	#define MX_UART_CHANNEL_1		1
	#define MX_UART_TX_PIN_1		0
	#define MX_UART_TX_PORT_1		porta
	#define MX_UART_TX_TRIS_1		trisa
	#define MX_UART_RX_PIN_1		0
	#define MX_UART_RX_PORT_1		porta
	#define MX_UART_RX_TRIS_1		trisa
	#define MX_UART_FLOWEN_1		0
	#define MX_UART_CTS_PIN_1		4
	#define MX_UART_CTS_PORT_1		portc
	#define MX_UART_CTS_TRIS_1		trisc
	#define MX_UART_RTS_PIN_1		0
	#define MX_UART_RTS_PORT_1		portc
	#define MX_UART_RTS_TRIS_1		trisc
	#define MX_UART_BAUD_1			9600
	#define MX_UART_DBITS_1			8
	#define MX_UART_RETURN_1		0
	#define MX_UART_ECHO_1			0
	#define MX_UART_INT_1			0
#else
 #ifndef	MX_UART_REF2
	#define MX_UART_REF2
	#define RS232_1_MX_UART_UREF			2
	#define MX_UART_CHANNEL_2		1
	#define MX_UART_TX_PIN_2		0
	#define MX_UART_TX_PORT_2		porta
	#define MX_UART_TX_TRIS_2		trisa
	#define MX_UART_RX_PIN_2		0
	#define MX_UART_RX_PORT_2		porta
	#define MX_UART_RX_TRIS_2		trisa
	#define MX_UART_FLOWEN_2		0
	#define MX_UART_CTS_PIN_2		4
	#define MX_UART_CTS_PORT_2		portc
	#define MX_UART_CTS_TRIS_2		trisc
	#define MX_UART_RTS_PIN_2		0
	#define MX_UART_RTS_PORT_2		portc
	#define MX_UART_RTS_TRIS_2		trisc
	#define MX_UART_BAUD_2			9600
	#define MX_UART_DBITS_2			8
	#define MX_UART_RETURN_2		0
	#define MX_UART_ECHO_2			0
	#define MX_UART_INT_2			0
 #else
  #ifndef	MX_UART_REF3
	#define MX_UART_REF3
	#define RS232_1_MX_UART_UREF			3
	#define MX_UART_CHANNEL_3		1
	#define MX_UART_TX_PIN_3		0
	#define MX_UART_TX_PORT_3		porta
	#define MX_UART_TX_TRIS_3		trisa
	#define MX_UART_RX_PIN_3		0
	#define MX_UART_RX_PORT_3		porta
	#define MX_UART_RX_TRIS_3		trisa
	#define MX_UART_FLOWEN_3		0
	#define MX_UART_CTS_PIN_3		4
	#define MX_UART_CTS_PORT_3		portc
	#define MX_UART_CTS_TRIS_3		trisc
	#define MX_UART_RTS_PIN_3		0
	#define MX_UART_RTS_PORT_3		portc
	#define MX_UART_RTS_TRIS_3		trisc
	#define MX_UART_BAUD_3			9600
	#define MX_UART_DBITS_3			8
	#define MX_UART_RETURN_3		0
	#define MX_UART_ECHO_3			0
	#define MX_UART_INT_3			0
  #else
   #ifndef	MX_UART_REF4
	#define MX_UART_REF4
	#define RS232_1_MX_UART_UREF			4
	#define MX_UART_CHANNEL_4		1
	#define MX_UART_TX_PIN_4		0
	#define MX_UART_TX_PORT_4		porta
	#define MX_UART_TX_TRIS_4		trisa
	#define MX_UART_RX_PIN_4		0
	#define MX_UART_RX_PORT_4		porta
	#define MX_UART_RX_TRIS_4		trisa
	#define MX_UART_FLOWEN_4		0
	#define MX_UART_CTS_PIN_4		4
	#define MX_UART_CTS_PORT_4		portc
	#define MX_UART_CTS_TRIS_4		trisc
	#define MX_UART_RTS_PIN_4		0
	#define MX_UART_RTS_PORT_4		portc
	#define MX_UART_RTS_TRIS_4		trisc
	#define MX_UART_BAUD_4			9600
	#define MX_UART_DBITS_4			8
	#define MX_UART_RETURN_4		0
	#define MX_UART_ECHO_4			0
	#define MX_UART_INT_4			0
   #endif
  #endif
 #endif
#endif

#define RS232_1_UART_Init		CAL_APPEND(FC_CAL_UART_Init_, RS232_1_MX_UART_UREF)
#define RS232_1_UART_Send		CAL_APPEND(FC_CAL_UART_Send_, RS232_1_MX_UART_UREF)
#define RS232_1_UART_Receive		CAL_APPEND(FC_CAL_UART_Receive_, RS232_1_MX_UART_UREF)
#define RS232_1_UART_Update_Baud CAL_APPEND(FC_CAL_UART_Update_Baud_, RS232_1_MX_UART_UREF)

extern void RS232_1_UART_Init();
extern void RS232_1_UART_Send(MX_UINT16 nChar);
extern MX_SINT16 RS232_1_UART_Receive(MX_UINT8 nTimeout);
extern void RS232_1_UART_Update_Baud(MX_UINT8 newbaud);




//RS232(0): //Macro function declarations

void FCD_RS2320_SendRS232Char(MX_SINT16 nChar);
void FCD_RS2320_SendRS232String(MX_STRING String, MX_UINT8 MSZ_String);
MX_SINT16 FCD_RS2320_ReceiveRS232Char(MX_UINT8 nTimeout);
void FCD_RS2320_ReceiveRS232String(MX_CHAR* FCR_RETVAL, MX_UINT8 FCR_RETVAL_SIZE, MX_UINT8 nTimeout, MX_UINT8 NumBytes);
void FCD_RS2320_ChangeHWBaud(MX_UINT8 newbaud);



//RS232(0): //Macro implementations


void FCD_RS2320_SendRS232Char(MX_SINT16 nChar)
{
	
		RS232_1_UART_Send ( nChar);

}

void FCD_RS2320_SendRS232String(MX_STRING String, MX_UINT8 MSZ_String)
{
	
		MX_UINT8 idx;
		for(idx = 0; idx < MSZ_String; idx++)
		{
			if (String[idx] == 0)
				break;
			else RS232_1_UART_Send ( String[idx] );
		}

}

MX_SINT16 FCD_RS2320_ReceiveRS232Char(MX_UINT8 nTimeout)

{
	
		return ( RS232_1_UART_Receive ( nTimeout) );
012C  084C  	MOVF FCD_RS2320_00064_arg_nTimeout, W
012D  00CD  	MOVWF FC_CAL_UAR_0005F_arg_nTimeout
012E  2035  	CALL FC_CAL_UAR_0005F
012F  0854  	MOVF CompTempVarRet2196, W
0130  00CD  	MOVWF CompTempVarRet2201
0131  0855  	MOVF CompTempVarRet2196+D'1', W
0132  00CE  	MOVWF CompTempVarRet2201+D'1'


}
0133  0008  	RETURN


void FCD_RS2320_ReceiveRS232String(MX_CHAR* FCR_RETVAL, MX_UINT8 FCR_RETVAL_SIZE, MX_UINT8 nTimeout, MX_UINT8 NumBytes)
{
	
		MX_UINT8 idx;
		MX_SINT16 RS232_TO = 255;
		MX_SINT16 in;

		if ( 0 != 0 )
			RS232_TO = 256;

		if (NumBytes > FCR_RETVAL_SIZE)
			NumBytes = FCR_RETVAL_SIZE;

		for (idx = 0; idx < NumBytes; idx++)
		{
			in = RS232_1_UART_Receive ( nTimeout);
			if(in < RS232_TO)
				FCR_RETVAL[idx] = in & 0xFF;
			else
				break;
		}

		if (idx < FCR_RETVAL_SIZE)
			FCR_RETVAL[idx] = 0;

}

void FCD_RS2320_ChangeHWBaud(MX_UINT8 newbaud)
{
	
		RS232_1_UART_Update_Baud (newbaud);

}

#include "C:\Program Files (x86)\Flowcode\v5\CAL\includes.c"

//Macro implementations


void FCM_row1_forward()

{

	//Output
	//Output: 0 -> C0
	trisc = trisc & 0xFE;
0117  30FE  	MOVLW 0xFE
0118  1683  	BSF STATUS, RP0
0119  1303  	BCF STATUS, RP1
011A  0507  	ANDWF gbl_trisc, W
011B  0087  	MOVWF gbl_trisc

	if ((0))
		portc = (portc & 0xFE) | 0x01;
	else
		portc = portc & 0xFE;
011C  30FE  	MOVLW 0xFE
011D  1283  	BCF STATUS, RP0
011E  0507  	ANDWF gbl_portc, W
011F  0087  	MOVWF gbl_portc


	//Output
	//Output: 1 -> C1
	trisc = trisc & 0xFD;
0120  30FD  	MOVLW 0xFD
0121  1683  	BSF STATUS, RP0
0122  0507  	ANDWF gbl_trisc, W
0123  0087  	MOVWF gbl_trisc

	if ((1))
		portc = (portc & 0xFD) | 0x02;
0124  30FD  	MOVLW 0xFD
0125  1283  	BCF STATUS, RP0
0126  0507  	ANDWF gbl_portc, W
0127  00CD  	MOVWF CompTempVar2188
0128  3002  	MOVLW 0x02
0129  044D  	IORWF CompTempVar2188, W
012A  0087  	MOVWF gbl_portc

	else
		portc = portc & 0xFD;

}
012B  0008  	RETURN



void FCM_row1_reverse()
{

	//Output
	//Output: 1 -> C0
	trisc = trisc & 0xFE;
	if ((1))
		portc = (portc & 0xFE) | 0x01;
	else
		portc = portc & 0xFE;

	//Output
	//Output: 0 -> C1
	trisc = trisc & 0xFD;
	if ((0))
		portc = (portc & 0xFD) | 0x02;
	else
		portc = portc & 0xFD;

}


void FCM_row3_forward()

{

	//Output
	//Output: 1 -> A0
	trisa = trisa & 0xFE;
00C9  30FE  	MOVLW 0xFE
00CA  1683  	BSF STATUS, RP0
00CB  1303  	BCF STATUS, RP1
00CC  0505  	ANDWF gbl_trisa, W
00CD  0085  	MOVWF gbl_trisa

	if ((1))
		porta = (porta & 0xFE) | 0x01;
00CE  30FE  	MOVLW 0xFE
00CF  1283  	BCF STATUS, RP0
00D0  0505  	ANDWF gbl_porta, W
00D1  00CD  	MOVWF CompTempVar2190
00D2  3001  	MOVLW 0x01
00D3  044D  	IORWF CompTempVar2190, W
00D4  0085  	MOVWF gbl_porta

	else
		porta = porta & 0xFE;

	//Output
	//Output: 0 -> A1
	trisa = trisa & 0xFD;
00D5  30FD  	MOVLW 0xFD
00D6  1683  	BSF STATUS, RP0
00D7  0505  	ANDWF gbl_trisa, W
00D8  0085  	MOVWF gbl_trisa

	if ((0))
		porta = (porta & 0xFD) | 0x02;
	else
		porta = porta & 0xFD;
00D9  30FD  	MOVLW 0xFD
00DA  1283  	BCF STATUS, RP0
00DB  0505  	ANDWF gbl_porta, W
00DC  0085  	MOVWF gbl_porta


}
00DD  0008  	RETURN



void FCM_row4_forward()

{

	//Output
	//Output: 0 -> A2
	trisa = trisa & 0xFB;
00A2  30FB  	MOVLW 0xFB
00A3  1683  	BSF STATUS, RP0
00A4  1303  	BCF STATUS, RP1
00A5  0505  	ANDWF gbl_trisa, W
00A6  0085  	MOVWF gbl_trisa

	if ((0))
		porta = (porta & 0xFB) | 0x04;
	else
		porta = porta & 0xFB;
00A7  30FB  	MOVLW 0xFB
00A8  1283  	BCF STATUS, RP0
00A9  0505  	ANDWF gbl_porta, W
00AA  0085  	MOVWF gbl_porta


	//Output
	//Output: 1 -> B4
	trisb = trisb & 0xEF;
00AB  30EF  	MOVLW 0xEF
00AC  1683  	BSF STATUS, RP0
00AD  0506  	ANDWF gbl_trisb, W
00AE  0086  	MOVWF gbl_trisb

	if ((1))
		portb = (portb & 0xEF) | 0x10;
00AF  30EF  	MOVLW 0xEF
00B0  1283  	BCF STATUS, RP0
00B1  0506  	ANDWF gbl_portb, W
00B2  00CD  	MOVWF CompTempVar2191
00B3  3010  	MOVLW 0x10
00B4  044D  	IORWF CompTempVar2191, W
00B5  0086  	MOVWF gbl_portb

	else
		portb = portb & 0xEF;

}
00B6  0008  	RETURN



void FCM_row3_reverse()
{

	//Output
	//Output: 0 -> A0
	trisa = trisa & 0xFE;
	if ((0))
		porta = (porta & 0xFE) | 0x01;
	else
		porta = porta & 0xFE;

	//Output
	//Output: 1 -> A1
	trisa = trisa & 0xFD;
	if ((1))
		porta = (porta & 0xFD) | 0x02;
	else
		porta = porta & 0xFD;

}


void FCM_row4_reverse()
{

	//Output
	//Output: 1 -> A2
	trisa = trisa & 0xFB;
	if ((1))
		porta = (porta & 0xFB) | 0x04;
	else
		porta = porta & 0xFB;

	//Output
	//Output: 0 -> B4
	trisb = trisb & 0xEF;
	if ((0))
		portb = (portb & 0xEF) | 0x10;
	else
		portb = portb & 0xEF;

}


void FCM_row2_forward()

{

	//Output
	//Output: 0 -> C2
	trisc = trisc & 0xFB;
00F0  30FB  	MOVLW 0xFB
00F1  1683  	BSF STATUS, RP0
00F2  1303  	BCF STATUS, RP1
00F3  0507  	ANDWF gbl_trisc, W
00F4  0087  	MOVWF gbl_trisc

	if ((0))
		portc = (portc & 0xFB) | 0x04;
	else
		portc = portc & 0xFB;
00F5  30FB  	MOVLW 0xFB
00F6  1283  	BCF STATUS, RP0
00F7  0507  	ANDWF gbl_portc, W
00F8  0087  	MOVWF gbl_portc


	//Output
	//Output: 1 -> C3
	trisc = trisc & 0xF7;
00F9  30F7  	MOVLW 0xF7
00FA  1683  	BSF STATUS, RP0
00FB  0507  	ANDWF gbl_trisc, W
00FC  0087  	MOVWF gbl_trisc

	if ((1))
		portc = (portc & 0xF7) | 0x08;
00FD  30F7  	MOVLW 0xF7
00FE  1283  	BCF STATUS, RP0
00FF  0507  	ANDWF gbl_portc, W
0100  00CD  	MOVWF CompTempVar2194
0101  3008  	MOVLW 0x08
0102  044D  	IORWF CompTempVar2194, W
0103  0087  	MOVWF gbl_portc

	else
		portc = portc & 0xF7;

}
0104  0008  	RETURN



void FCM_row2_reverse()
{

	//Output
	//Output: 1 -> C2
	trisc = trisc & 0xFB;
	if ((1))
		portc = (portc & 0xFB) | 0x04;
	else
		portc = portc & 0xFB;

	//Output
	//Output: 0 -> C3
	trisc = trisc & 0xF7;
	if ((0))
		portc = (portc & 0xF7) | 0x08;
	else
		portc = portc & 0xF7;

}


void FCM_row1_stop()

{

	//Output
	//Output: 0 -> C0
	trisc = trisc & 0xFE;
0105  30FE  	MOVLW 0xFE
0106  1683  	BSF STATUS, RP0
0107  1303  	BCF STATUS, RP1
0108  0507  	ANDWF gbl_trisc, W
0109  0087  	MOVWF gbl_trisc

	if ((0))
		portc = (portc & 0xFE) | 0x01;
	else
		portc = portc & 0xFE;
010A  30FE  	MOVLW 0xFE
010B  1283  	BCF STATUS, RP0
010C  0507  	ANDWF gbl_portc, W
010D  0087  	MOVWF gbl_portc


	//Output
	//Output: 0 -> C1
	trisc = trisc & 0xFD;
010E  30FD  	MOVLW 0xFD
010F  1683  	BSF STATUS, RP0
0110  0507  	ANDWF gbl_trisc, W
0111  0087  	MOVWF gbl_trisc

	if ((0))
		portc = (portc & 0xFD) | 0x02;
	else
		portc = portc & 0xFD;
0112  30FD  	MOVLW 0xFD
0113  1283  	BCF STATUS, RP0
0114  0507  	ANDWF gbl_portc, W
0115  0087  	MOVWF gbl_portc


}
0116  0008  	RETURN



void FCM_row2_stop()

{

	//Output
	//Output: 0 -> C2
	trisc = trisc & 0xFB;
00DE  30FB  	MOVLW 0xFB
00DF  1683  	BSF STATUS, RP0
00E0  1303  	BCF STATUS, RP1
00E1  0507  	ANDWF gbl_trisc, W
00E2  0087  	MOVWF gbl_trisc

	if ((0))
		portc = (portc & 0xFB) | 0x04;
	else
		portc = portc & 0xFB;
00E3  30FB  	MOVLW 0xFB
00E4  1283  	BCF STATUS, RP0
00E5  0507  	ANDWF gbl_portc, W
00E6  0087  	MOVWF gbl_portc


	//Output
	//Output: 0 -> C3
	trisc = trisc & 0xF7;
00E7  30F7  	MOVLW 0xF7
00E8  1683  	BSF STATUS, RP0
00E9  0507  	ANDWF gbl_trisc, W
00EA  0087  	MOVWF gbl_trisc

	if ((0))
		portc = (portc & 0xF7) | 0x08;
	else
		portc = portc & 0xF7;
00EB  30F7  	MOVLW 0xF7
00EC  1283  	BCF STATUS, RP0
00ED  0507  	ANDWF gbl_portc, W
00EE  0087  	MOVWF gbl_portc


}
00EF  0008  	RETURN



void FCM_row3_stop()

{

	//Output
	//Output: 0 -> A0
	trisa = trisa & 0xFE;
00B7  30FE  	MOVLW 0xFE
00B8  1683  	BSF STATUS, RP0
00B9  1303  	BCF STATUS, RP1
00BA  0505  	ANDWF gbl_trisa, W
00BB  0085  	MOVWF gbl_trisa

	if ((0))
		porta = (porta & 0xFE) | 0x01;
	else
		porta = porta & 0xFE;
00BC  30FE  	MOVLW 0xFE
00BD  1283  	BCF STATUS, RP0
00BE  0505  	ANDWF gbl_porta, W
00BF  0085  	MOVWF gbl_porta


	//Output
	//Output: 0 -> A1
	trisa = trisa & 0xFD;
00C0  30FD  	MOVLW 0xFD
00C1  1683  	BSF STATUS, RP0
00C2  0505  	ANDWF gbl_trisa, W
00C3  0085  	MOVWF gbl_trisa

	if ((0))
		porta = (porta & 0xFD) | 0x02;
	else
		porta = porta & 0xFD;
00C4  30FD  	MOVLW 0xFD
00C5  1283  	BCF STATUS, RP0
00C6  0505  	ANDWF gbl_porta, W
00C7  0085  	MOVWF gbl_porta


}
00C8  0008  	RETURN



void FCM_row4_stop()

{

	//Output
	//Output: 0 -> A2
	trisa = trisa & 0xFB;
0090  30FB  	MOVLW 0xFB
0091  1683  	BSF STATUS, RP0
0092  1303  	BCF STATUS, RP1
0093  0505  	ANDWF gbl_trisa, W
0094  0085  	MOVWF gbl_trisa

	if ((0))
		porta = (porta & 0xFB) | 0x04;
	else
		porta = porta & 0xFB;
0095  30FB  	MOVLW 0xFB
0096  1283  	BCF STATUS, RP0
0097  0505  	ANDWF gbl_porta, W
0098  0085  	MOVWF gbl_porta


	//Output
	//Output: 0 -> B4
	trisb = trisb & 0xEF;
0099  30EF  	MOVLW 0xEF
009A  1683  	BSF STATUS, RP0
009B  0506  	ANDWF gbl_trisb, W
009C  0086  	MOVWF gbl_trisb

	if ((0))
		portb = (portb & 0xEF) | 0x10;
	else
		portb = portb & 0xEF;
009D  30EF  	MOVLW 0xEF
009E  1283  	BCF STATUS, RP0
009F  0506  	ANDWF gbl_portb, W
00A0  0086  	MOVWF gbl_portb


}
00A1  0008  	RETURN




void main()

{
	//Initialization
	ansel = 0;
0134  1283  	BCF STATUS, RP0
0135  1703  	BSF STATUS, RP1
0136  019E  	CLRF gbl_ansel

anselh = 0;
0137  019F  	CLRF gbl_anselh


	
		RS232_1_UART_Init( );		//Call initialise function
0138  2081  	CALL FC_CAL_UAR_0005D



	//Interrupt initialization code
	option_reg = 0xC0;
0139  30C0  	MOVLW 0xC0
013A  0081  	MOVWF gbl_option_reg



	//Calculation
	//Calculation:
	//  quant = 3
	FCV_QUANT = 3;
013B  3003  	MOVLW 0x03
013C  1283  	BCF STATUS, RP0
013D  00C7  	MOVWF gbl_FCV_QUANT


	//Loop
	//Loop: While 1
	while (1)
013E        label12

	{

		//finish
		//Output: 0 -> C6
		trisc = trisc & 0xBF;
013E  30BF  	MOVLW 0xBF
013F  1683  	BSF STATUS, RP0
0140  0507  	ANDWF gbl_trisc, W
0141  0087  	MOVWF gbl_trisc

		if ((0))
			portc = (portc & 0xBF) | 0x40;
		else
			portc = portc & 0xBF;
0142  30BF  	MOVLW 0xBF
0143  1283  	BCF STATUS, RP0
0144  0507  	ANDWF gbl_portc, W
0145  0087  	MOVWF gbl_portc


		//Connection Point
		//Connection Point: [A]: A
FCC_Main_A:
0146        label13

;

		//Calculation
		//Calculation:
		//  delay = 0
		//  quant = 0
		//  row = 0
		FCV_DELAY = 0;
0146  01B9  	CLRF gbl_FCV_DELAY
0147  01BA  	CLRF gbl_FCV_DELAY+D'1'

		FCV_QUANT = 0;
0148  01C7  	CLRF gbl_FCV_QUANT

		FCV_ROW = 0;
0149  01C5  	CLRF gbl_FCV_ROW


		//Call Component Macro
		//Call Component Macro: rx=ReceiveRS232Char(100)
		FCV_RX = FCD_RS2320_ReceiveRS232Char(100);
014A  3064  	MOVLW 0x64
014B  00CC  	MOVWF FCD_RS2320_00064_arg_nTimeout
014C  212C  	CALL FCD_RS2320_00064
014D  084D  	MOVF CompTempVarRet2201, W
014E  00C6  	MOVWF gbl_FCV_RX


		//Decision
		//Decision: rx = 'R'?
		if (FCV_RX == 'R')
014F  0846  	MOVF gbl_FCV_RX, W
0150  3A52  	XORLW 0x52
0151  1D03  	BTFSS STATUS,Z
0152  293E  	GOTO	label12

		{

			//Call Component Macro
			//Call Component Macro: rx=ReceiveRS232Char(100)
			FCV_RX = FCD_RS2320_ReceiveRS232Char(100);
0153  3064  	MOVLW 0x64
0154  00CC  	MOVWF FCD_RS2320_00064_arg_nTimeout
0155  212C  	CALL FCD_RS2320_00064
0156  084D  	MOVF CompTempVarRet2201, W
0157  00C6  	MOVWF gbl_FCV_RX


			//Decision
			//Decision: rx > '0'AND rx < '5'?
			if (FCV_RX > '0' & FCV_RX < '5')
0158  01C9  	CLRF CompTempVar2207
0159  0846  	MOVF gbl_FCV_RX, W
015A  3C30  	SUBLW 0x30
015B  1C03  	BTFSS STATUS,C
015C  0AC9  	INCF CompTempVar2207, F
015D  01C8  	CLRF CompTempVar2206
015E  3035  	MOVLW 0x35
015F  0246  	SUBWF gbl_FCV_RX, W
0160  1C03  	BTFSS STATUS,C
0161  0AC8  	INCF CompTempVar2206, F
0162  0848  	MOVF CompTempVar2206, W
0163  0549  	ANDWF CompTempVar2207, W
0164  1903  	BTFSC STATUS,Z
0165  2946  	GOTO	label13

			{

				//Calculation
				//Calculation:
				//  row = rx - 48
				FCV_ROW = FCV_RX - 48;
0166  3030  	MOVLW 0x30
0167  0246  	SUBWF gbl_FCV_RX, W
0168  00C5  	MOVWF gbl_FCV_ROW


				//Call Component Macro
				//Call Component Macro: rx=ReceiveRS232Char(100)
				FCV_RX = FCD_RS2320_ReceiveRS232Char(100);
0169  3064  	MOVLW 0x64
016A  00CC  	MOVWF FCD_RS2320_00064_arg_nTimeout
016B  212C  	CALL FCD_RS2320_00064
016C  084D  	MOVF CompTempVarRet2201, W
016D  00C6  	MOVWF gbl_FCV_RX


				//Decision
				//Decision: rx = 'Q'?
				if (FCV_RX == 'Q')
016E  0846  	MOVF gbl_FCV_RX, W
016F  3A51  	XORLW 0x51
0170  1D03  	BTFSS STATUS,Z
0171  2946  	GOTO	label13

				{

					//Call Component Macro
					//Call Component Macro: rx=ReceiveRS232Char(100)
					FCV_RX = FCD_RS2320_ReceiveRS232Char(100);
0172  3064  	MOVLW 0x64
0173  00CC  	MOVWF FCD_RS2320_00064_arg_nTimeout
0174  212C  	CALL FCD_RS2320_00064
0175  084D  	MOVF CompTempVarRet2201, W
0176  00C6  	MOVWF gbl_FCV_RX


					//Decision
					//Decision: rx > '0'AND rx <= '9'?
					if (FCV_RX > '0' & FCV_RX <= '9')
0177  01CB  	CLRF CompTempVar2209
0178  0846  	MOVF gbl_FCV_RX, W
0179  3C30  	SUBLW 0x30
017A  1C03  	BTFSS STATUS,C
017B  0ACB  	INCF CompTempVar2209, F
017C  01CA  	CLRF CompTempVar2208
017D  0846  	MOVF gbl_FCV_RX, W
017E  3C39  	SUBLW 0x39
017F  1803  	BTFSC STATUS,C
0180  0ACA  	INCF CompTempVar2208, F
0181  084A  	MOVF CompTempVar2208, W
0182  054B  	ANDWF CompTempVar2209, W
0183  1903  	BTFSC STATUS,Z
0184  2946  	GOTO	label13

					{

						//Calculation
						//Calculation:
						//  quant = rx - 48
						//  loop = 0
						FCV_QUANT = FCV_RX - 48;
0185  3030  	MOVLW 0x30
0186  0246  	SUBWF gbl_FCV_RX, W
0187  00C7  	MOVWF gbl_FCV_QUANT

						FCV_LOOP = 0;
0188  01C4  	CLRF gbl_FCV_LOOP


						//Switch
						//Switch: row?
						switch (FCV_ROW)
						{
							case 1:
0189  0845  	MOVF gbl_FCV_ROW, W
018A  3A01  	XORLW 0x01
018B  1903  	BTFSC STATUS,Z
018C  2997  	GOTO	label14
0197        label14

							{
								//finish
								//Output: 1 -> C6
								trisc = trisc & 0xBF;
0197  30BF  	MOVLW 0xBF
0198  1683  	BSF STATUS, RP0
0199  0507  	ANDWF gbl_trisc, W
019A  0087  	MOVWF gbl_trisc

								if ((1))
									portc = (portc & 0xBF) | 0x40;
019B  30BF  	MOVLW 0xBF
019C  1283  	BCF STATUS, RP0
019D  0507  	ANDWF gbl_portc, W
019E  00CD  	MOVWF CompTempVar2212
019F  3040  	MOVLW 0x40
01A0  044D  	IORWF CompTempVar2212, W
01A1  0087  	MOVWF gbl_portc

								else
									portc = portc & 0xBF;

								//Delay
								//Delay: 2 s
								delay_s(2);
01A2  3002  	MOVLW 0x02
01A3  00CD  	MOVWF delay_s_00000_arg_del
01A4  2026  	CALL delay_s_00000


								//Loop
								//Loop: While loop = quant
								while (!(FCV_LOOP == FCV_QUANT))
01A5        label15
01A5  01CC  	CLRF CompTempVar2211
01A6  0847  	MOVF gbl_FCV_QUANT, W
01A7  0244  	SUBWF gbl_FCV_LOOP, W
01A8  1903  	BTFSC STATUS,Z
01A9  0ACC  	INCF CompTempVar2211, F
01AA  08CC  	MOVF CompTempVar2211, F
01AB  1D03  	BTFSS STATUS,Z
01AC  29BE  	GOTO	label16
01BD  29A5  	GOTO	label15
01BE        label16

								{

									//Call Macro
									//Call Macro: row1_forward()
									FCM_row1_forward();
01AD  2117  	CALL FCM_row1_f_00051


									//Delay
									//Delay: 600 ms
									delay_ms(255);
01AE  30FF  	MOVLW 0xFF
01AF  00CE  	MOVWF delay_ms_00000_arg_del
01B0  201A  	CALL delay_ms_00000

									delay_ms(255);
01B1  30FF  	MOVLW 0xFF
01B2  00CE  	MOVWF delay_ms_00000_arg_del
01B3  201A  	CALL delay_ms_00000

									delay_ms(90);
01B4  305A  	MOVLW 0x5A
01B5  00CE  	MOVWF delay_ms_00000_arg_del
01B6  201A  	CALL delay_ms_00000


									//Call Macro
									//Call Macro: row1_stop()
									FCM_row1_stop();
01B7  2105  	CALL FCM_row1_s_00059


									//Delay
									//Delay: 2 s
									delay_s(2);
01B8  3002  	MOVLW 0x02
01B9  00CD  	MOVWF delay_s_00000_arg_del
01BA  2026  	CALL delay_s_00000


									//Calculation
									//Calculation:
									//  loop = loop + 1
									FCV_LOOP = FCV_LOOP + 1;
01BB  0A44  	INCF gbl_FCV_LOOP, W
01BC  00C4  	MOVWF gbl_FCV_LOOP



								}

								//Delay
								//Delay: 1 s
								delay_s(1);
01BE  3001  	MOVLW 0x01
01BF  00CD  	MOVWF delay_s_00000_arg_del
01C0  2026  	CALL delay_s_00000


								//finish
								//Output: 0 -> C6
								trisc = trisc & 0xBF;
01C1  30BF  	MOVLW 0xBF
01C2  1683  	BSF STATUS, RP0
01C3  0507  	ANDWF gbl_trisc, W
01C4  0087  	MOVWF gbl_trisc

								if ((0))
									portc = (portc & 0xBF) | 0x40;
								else
									portc = portc & 0xBF;
01C5  30BF  	MOVLW 0xBF
01C6  1283  	BCF STATUS, RP0
01C7  0507  	ANDWF gbl_portc, W
01C8  0087  	MOVWF gbl_portc


								break;
01C9  293E  	GOTO	label12

							}
							case 2:
018D  3A03  	XORLW 0x03
018E  1903  	BTFSC STATUS,Z
018F  29CA  	GOTO	label17
01CA        label17

							{
								//finish
								//Output: 1 -> C6
								trisc = trisc & 0xBF;
01CA  30BF  	MOVLW 0xBF
01CB  1683  	BSF STATUS, RP0
01CC  0507  	ANDWF gbl_trisc, W
01CD  0087  	MOVWF gbl_trisc

								if ((1))
									portc = (portc & 0xBF) | 0x40;
01CE  30BF  	MOVLW 0xBF
01CF  1283  	BCF STATUS, RP0
01D0  0507  	ANDWF gbl_portc, W
01D1  00CD  	MOVWF CompTempVar2215
01D2  3040  	MOVLW 0x40
01D3  044D  	IORWF CompTempVar2215, W
01D4  0087  	MOVWF gbl_portc

								else
									portc = portc & 0xBF;

								//Delay
								//Delay: 2 s
								delay_s(2);
01D5  3002  	MOVLW 0x02
01D6  00CD  	MOVWF delay_s_00000_arg_del
01D7  2026  	CALL delay_s_00000


								//Loop
								//Loop: While loop = quant
								while (!(FCV_LOOP == FCV_QUANT))
01D8        label18
01D8  01CC  	CLRF CompTempVar2214
01D9  0847  	MOVF gbl_FCV_QUANT, W
01DA  0244  	SUBWF gbl_FCV_LOOP, W
01DB  1903  	BTFSC STATUS,Z
01DC  0ACC  	INCF CompTempVar2214, F
01DD  08CC  	MOVF CompTempVar2214, F
01DE  1D03  	BTFSS STATUS,Z
01DF  29F1  	GOTO	label19
01F0  29D8  	GOTO	label18
01F1        label19

								{

									//Call Macro
									//Call Macro: row2_forward()
									FCM_row2_forward();
01E0  20F0  	CALL FCM_row2_f_00057


									//Delay
									//Delay: 600 ms
									delay_ms(255);
01E1  30FF  	MOVLW 0xFF
01E2  00CE  	MOVWF delay_ms_00000_arg_del
01E3  201A  	CALL delay_ms_00000

									delay_ms(255);
01E4  30FF  	MOVLW 0xFF
01E5  00CE  	MOVWF delay_ms_00000_arg_del
01E6  201A  	CALL delay_ms_00000

									delay_ms(90);
01E7  305A  	MOVLW 0x5A
01E8  00CE  	MOVWF delay_ms_00000_arg_del
01E9  201A  	CALL delay_ms_00000


									//Call Macro
									//Call Macro: row2_stop()
									FCM_row2_stop();
01EA  20DE  	CALL FCM_row2_s_0005A


									//Delay
									//Delay: 2 s
									delay_s(2);
01EB  3002  	MOVLW 0x02
01EC  00CD  	MOVWF delay_s_00000_arg_del
01ED  2026  	CALL delay_s_00000


									//Calculation
									//Calculation:
									//  loop = loop + 1
									FCV_LOOP = FCV_LOOP + 1;
01EE  0A44  	INCF gbl_FCV_LOOP, W
01EF  00C4  	MOVWF gbl_FCV_LOOP



								}

								//Delay
								//Delay: 1 s
								delay_s(1);
01F1  3001  	MOVLW 0x01
01F2  00CD  	MOVWF delay_s_00000_arg_del
01F3  2026  	CALL delay_s_00000


								//finish
								//Output: 0 -> C6
								trisc = trisc & 0xBF;
01F4  30BF  	MOVLW 0xBF
01F5  1683  	BSF STATUS, RP0
01F6  0507  	ANDWF gbl_trisc, W
01F7  0087  	MOVWF gbl_trisc

								if ((0))
									portc = (portc & 0xBF) | 0x40;
								else
									portc = portc & 0xBF;
01F8  30BF  	MOVLW 0xBF
01F9  1283  	BCF STATUS, RP0
01FA  0507  	ANDWF gbl_portc, W
01FB  0087  	MOVWF gbl_portc


								break;
01FC  293E  	GOTO	label12

							}
							case 3:
0190  3A01  	XORLW 0x01
0191  1903  	BTFSC STATUS,Z
0192  29FD  	GOTO	label20
01FD        label20

							{
								//finish
								//Output: 1 -> C6
								trisc = trisc & 0xBF;
01FD  30BF  	MOVLW 0xBF
01FE  1683  	BSF STATUS, RP0
01FF  0507  	ANDWF gbl_trisc, W
0200  0087  	MOVWF gbl_trisc

								if ((1))
									portc = (portc & 0xBF) | 0x40;
0201  30BF  	MOVLW 0xBF
0202  1283  	BCF STATUS, RP0
0203  0507  	ANDWF gbl_portc, W
0204  00CD  	MOVWF CompTempVar2218
0205  3040  	MOVLW 0x40
0206  044D  	IORWF CompTempVar2218, W
0207  0087  	MOVWF gbl_portc

								else
									portc = portc & 0xBF;

								//Delay
								//Delay: 2 s
								delay_s(2);
0208  3002  	MOVLW 0x02
0209  00CD  	MOVWF delay_s_00000_arg_del
020A  2026  	CALL delay_s_00000


								//Loop
								//Loop: While loop = quant
								while (!(FCV_LOOP == FCV_QUANT))
020B        label21
020B  01CC  	CLRF CompTempVar2217
020C  0847  	MOVF gbl_FCV_QUANT, W
020D  0244  	SUBWF gbl_FCV_LOOP, W
020E  1903  	BTFSC STATUS,Z
020F  0ACC  	INCF CompTempVar2217, F
0210  08CC  	MOVF CompTempVar2217, F
0211  1D03  	BTFSS STATUS,Z
0212  2A24  	GOTO	label22
0223  2A0B  	GOTO	label21
0224        label22

								{

									//Call Macro
									//Call Macro: row3_forward()
									FCM_row3_forward();
0213  20C9  	CALL FCM_row3_f_00053


									//Delay
									//Delay: 600 ms
									delay_ms(255);
0214  30FF  	MOVLW 0xFF
0215  00CE  	MOVWF delay_ms_00000_arg_del
0216  201A  	CALL delay_ms_00000

									delay_ms(255);
0217  30FF  	MOVLW 0xFF
0218  00CE  	MOVWF delay_ms_00000_arg_del
0219  201A  	CALL delay_ms_00000

									delay_ms(90);
021A  305A  	MOVLW 0x5A
021B  00CE  	MOVWF delay_ms_00000_arg_del
021C  201A  	CALL delay_ms_00000


									//Call Macro
									//Call Macro: row3_stop()
									FCM_row3_stop();
021D  20B7  	CALL FCM_row3_s_0005B


									//Delay
									//Delay: 2 s
									delay_s(2);
021E  3002  	MOVLW 0x02
021F  00CD  	MOVWF delay_s_00000_arg_del
0220  2026  	CALL delay_s_00000


									//Calculation
									//Calculation:
									//  loop = loop + 1
									FCV_LOOP = FCV_LOOP + 1;
0221  0A44  	INCF gbl_FCV_LOOP, W
0222  00C4  	MOVWF gbl_FCV_LOOP



								}

								//Delay
								//Delay: 1 s
								delay_s(1);
0224  3001  	MOVLW 0x01
0225  00CD  	MOVWF delay_s_00000_arg_del
0226  2026  	CALL delay_s_00000


								//finish
								//Output: 0 -> C6
								trisc = trisc & 0xBF;
0227  30BF  	MOVLW 0xBF
0228  1683  	BSF STATUS, RP0
0229  0507  	ANDWF gbl_trisc, W
022A  0087  	MOVWF gbl_trisc

								if ((0))
									portc = (portc & 0xBF) | 0x40;
								else
									portc = portc & 0xBF;
022B  30BF  	MOVLW 0xBF
022C  1283  	BCF STATUS, RP0
022D  0507  	ANDWF gbl_portc, W
022E  0087  	MOVWF gbl_portc


								break;
022F  293E  	GOTO	label12

							}
							case 4:
0193  3A07  	XORLW 0x07
0194  1903  	BTFSC STATUS,Z
0195  2A30  	GOTO	label23
0230        label23

							{
								//finish
								//Output: 1 -> C6
								trisc = trisc & 0xBF;
0230  30BF  	MOVLW 0xBF
0231  1683  	BSF STATUS, RP0
0232  0507  	ANDWF gbl_trisc, W
0233  0087  	MOVWF gbl_trisc

								if ((1))
									portc = (portc & 0xBF) | 0x40;
0234  30BF  	MOVLW 0xBF
0235  1283  	BCF STATUS, RP0
0236  0507  	ANDWF gbl_portc, W
0237  00CD  	MOVWF CompTempVar2221
0238  3040  	MOVLW 0x40
0239  044D  	IORWF CompTempVar2221, W
023A  0087  	MOVWF gbl_portc

								else
									portc = portc & 0xBF;

								//Delay
								//Delay: 2 s
								delay_s(2);
023B  3002  	MOVLW 0x02
023C  00CD  	MOVWF delay_s_00000_arg_del
023D  2026  	CALL delay_s_00000


								//Loop
								//Loop: While loop = quant
								while (!(FCV_LOOP == FCV_QUANT))
023E        label24
023E  01CC  	CLRF CompTempVar2220
023F  0847  	MOVF gbl_FCV_QUANT, W
0240  0244  	SUBWF gbl_FCV_LOOP, W
0241  1903  	BTFSC STATUS,Z
0242  0ACC  	INCF CompTempVar2220, F
0243  08CC  	MOVF CompTempVar2220, F
0244  1D03  	BTFSS STATUS,Z
0245  2A57  	GOTO	label25
0256  2A3E  	GOTO	label24
0257        label25

								{

									//Call Macro
									//Call Macro: row4_forward()
									FCM_row4_forward();
0246  20A2  	CALL FCM_row4_f_00054


									//Delay
									//Delay: 600 ms
									delay_ms(255);
0247  30FF  	MOVLW 0xFF
0248  00CE  	MOVWF delay_ms_00000_arg_del
0249  201A  	CALL delay_ms_00000

									delay_ms(255);
024A  30FF  	MOVLW 0xFF
024B  00CE  	MOVWF delay_ms_00000_arg_del
024C  201A  	CALL delay_ms_00000

									delay_ms(90);
024D  305A  	MOVLW 0x5A
024E  00CE  	MOVWF delay_ms_00000_arg_del
024F  201A  	CALL delay_ms_00000


									//Call Macro
									//Call Macro: row4_stop()
									FCM_row4_stop();
0250  2090  	CALL FCM_row4_s_0005C


									//Delay
									//Delay: 2 s
									delay_s(2);
0251  3002  	MOVLW 0x02
0252  00CD  	MOVWF delay_s_00000_arg_del
0253  2026  	CALL delay_s_00000


									//Calculation
									//Calculation:
									//  loop = loop + 1
									FCV_LOOP = FCV_LOOP + 1;
0254  0A44  	INCF gbl_FCV_LOOP, W
0255  00C4  	MOVWF gbl_FCV_LOOP



								}

								//Delay
								//Delay: 1 s
								delay_s(1);
0257  3001  	MOVLW 0x01
0258  00CD  	MOVWF delay_s_00000_arg_del
0259  2026  	CALL delay_s_00000


								//finish
								//Output: 0 -> C6
								trisc = trisc & 0xBF;
025A  30BF  	MOVLW 0xBF
025B  1683  	BSF STATUS, RP0
025C  0507  	ANDWF gbl_trisc, W
025D  0087  	MOVWF gbl_trisc

								if ((0))
									portc = (portc & 0xBF) | 0x40;
								else
									portc = portc & 0xBF;
025E  30BF  	MOVLW 0xBF
025F  1283  	BCF STATUS, RP0
0260  0507  	ANDWF gbl_portc, W
0261  0087  	MOVWF gbl_portc


								break;

							}
							default:
0196  2946  	GOTO	label13
0262  293E  	GOTO	label12

							{
								//Goto Connection Point
								//Goto Connection Point: [A]: A
								goto FCC_Main_A;


							}
						}

					} else {

						//Goto Connection Point
						//Goto Connection Point: [A]: A
						goto FCC_Main_A;


					}

				} else {

					//Goto Connection Point
					//Goto Connection Point: [A]: A
					goto FCC_Main_A;


				}

			} else {

				//Goto Connection Point
				//Goto Connection Point: [A]: A
				goto FCC_Main_A;


			}

		// } else {

		}


	}

	mainendloop: goto mainendloop;
}


void MX_INTERRUPT_MACRO(void)

{
}
028E  1283  	BCF STATUS, RP0
028F  1303  	BCF STATUS, RP1
0290  0E36  	SWAPF Int1BContext+D'2', W
0291  0084  	MOVWF FSR
0292  0E35  	SWAPF Int1BContext+D'1', W
0293  008A  	MOVWF PCLATH
0294  0E34  	SWAPF Int1BContext, W
0295  0083  	MOVWF STATUS
0296  0EFF  	SWAPF Int1Context, F
0297  0E7F  	SWAPF Int1Context, W
0298  0009  	RETFIE





/*********************************************************************
 *                  Flowcode CAL UART File
 *
 * File: PIC_CAL_UART.c
 *
 * (c) 2011 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * “Company”) for its Flowcode graphical programming language is
 * intended and supplied to you, the Company’s customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 010911 | BR | Created
 * 020911 | BR | Updated variables with typedef alternatives
 * 011211 | BR | Converted to new dynamic defines mechanism
 * 160112 | BR | Fixed issues with rx return type and low bauds on fast devices
 * 020212 | ST | Added <MX_UART_2_PIE4> routing to account for differences in 16F and 18F devices with 2 UARTs
 * 270212 | BR | Fixed a bug in the receive functionality
 * 280212 | BR | Sorted out auto echo functionality
 * 160412 | BR | Addition of HW change baud function
 */



#ifndef MX_UART_SW_DEFS
	#define MX_UART_SW_DEFS

	#ifdef _BOOSTC
		#define INST_COUNT	45	//65 for lower speeds or 40 for higher speeds.
	#endif
	#ifdef HI_TECH_C
		#define INST_COUNT	315
	#endif

	//Work out number of nops for software baud rate
	#define MX_INSTRUCTION_SPEED 	(MX_CLK_SPEED / 4)
	#define MX_OVERHEAD				(MX_INSTRUCTION_SPEED / INST_COUNT)
	#define SW_OFFSET				(1000000 / MX_OVERHEAD)

	//Work out software baud rates if required
	#define SW_1200_BAUD	(832 - SW_OFFSET)
	#define SW_2400_BAUD	(416 - SW_OFFSET)
	#define SW_4800_BAUD	(208 - SW_OFFSET)
	#define SW_9600_BAUD	(104 - SW_OFFSET)
	#define SW_19200_BAUD	(52 - SW_OFFSET)
	#define SW_31250_BAUD	(32 - SW_OFFSET)
	#define SW_115200_BAUD	(8 - SW_OFFSET)
#endif

 #if defined(MX_UART_CHANNEL_1) && (MX_UART_NUM==1)
	#if (MX_UART_CHANNEL_1 == 0)
		#if (MX_UART_BAUD_1 == 1200)
			#define MX_SOFT_BAUD_1	SW_1200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 1200 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_1 == 2400)
			#define MX_SOFT_BAUD_1	SW_2400_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 2400 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_1 == 4800)
			#define MX_SOFT_BAUD_1	SW_4800_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 4800 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_1 == 9600)
			#define MX_SOFT_BAUD_1	SW_9600_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 9600 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_1 == 19200)
			#define MX_SOFT_BAUD_1	SW_19200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 19200 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_1 == 31250)
			#define MX_SOFT_BAUD_1	SW_31250_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 31250 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_1 == 115200)
			#define MX_SOFT_BAUD_1	SW_115200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 115200 Not Available At This Clock Speed"
			#endif
		#endif
		#ifndef MX_SOFT_BAUD_1
			#error "UART Baud Rate not supported in Software Mode"
		#endif
	#else
		#define MX_SOFT_BAUD_1	1
		#define MX_HARD_BAUD_1	(((MX_CLK_SPEED / MX_UART_BAUD_1) - 16) / 16)
		#define MX_HARD_SLOW_1	0

		#if (MX_HARD_BAUD_1 > 255)
			#undef MX_HARD_BAUD_1
			#undef MX_HARD_SLOW_1
			#define MX_HARD_BAUD_1	(((MX_CLK_SPEED / MX_UART_BAUD_1) - 16)	/ 64)
			#define MX_HARD_SLOW_1	1
		#endif

	#endif
 #endif
 #if defined(MX_UART_CHANNEL_2) && (MX_UART_NUM==2)
	#if (MX_UART_CHANNEL_2 == 0)
		#if (MX_UART_BAUD_2 == 1200)
			#define MX_SOFT_BAUD_2	SW_1200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 1200 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_2 == 2400)
			#define MX_SOFT_BAUD_2	SW_2400_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 2400 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_2 == 4800)
			#define MX_SOFT_BAUD_2	SW_4800_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 4800 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_2 == 9600)
			#define MX_SOFT_BAUD_2	SW_9600_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 9600 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_2 == 19200)
			#define MX_SOFT_BAUD_2	SW_19200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 19200 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_2 == 31250)
			#define MX_SOFT_BAUD_2	SW_31250_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 31250 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_2 == 115200)
			#define MX_SOFT_BAUD_2	SW_115200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 115200 Not Available At This Clock Speed"
			#endif
		#endif
		#ifndef MX_SOFT_BAUD_2
			#error "UART Baud Rate not supported in Software Mode"
		#endif
	#else
		#define MX_SOFT_BAUD_2	1
		#define MX_HARD_BAUD_2	(((MX_CLK_SPEED / MX_UART_BAUD_2) - 16) / 16)
		#define MX_HARD_SLOW_2	0

		#if (MX_HARD_BAUD_2 > 255)
			#undef MX_HARD_BAUD_2
			#undef MX_HARD_SLOW_2
			#define MX_HARD_BAUD_2	(((MX_CLK_SPEED / MX_UART_BAUD_2) - 16)	/ 64)
			#define MX_HARD_SLOW_2	1
		#endif
 	#endif
 #endif
 #if defined(MX_UART_CHANNEL_3) && (MX_UART_NUM==3)
	#if (MX_UART_CHANNEL_3 == 0)
		#if (MX_UART_BAUD_3 == 1200)
			#define MX_SOFT_BAUD_3	SW_1200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 1200 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_3 == 2400)
			#define MX_SOFT_BAUD_3	SW_2400_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 2400 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_3 == 4800)
			#define MX_SOFT_BAUD_3	SW_4800_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 4800 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_3 == 9600)
			#define MX_SOFT_BAUD_3	SW_9600_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 9600 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_3 == 19200)
			#define MX_SOFT_BAUD_3	SW_19200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 19200 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_3 == 31250)
			#define MX_SOFT_BAUD_3	SW_31250_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 31250 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_3 == 115200)
			#define MX_SOFT_BAUD_3	SW_115200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 115200 Not Available At This Clock Speed"
			#endif
		#endif
		#ifndef MX_SOFT_BAUD_3
			#error "UART Baud Rate not supported in Software Mode"
		#endif
	#else
		#define MX_SOFT_BAUD_3	1
		#define MX_HARD_BAUD_3	(((MX_CLK_SPEED / MX_UART_BAUD_3) - 16) / 16)
		#define MX_HARD_SLOW_3	0

		#if (MX_HARD_BAUD_3 > 255)
			#undef MX_HARD_BAUD_3
			#undef MX_HARD_SLOW_3
			#define MX_HARD_BAUD_3	(((MX_CLK_SPEED / MX_UART_BAUD_3) - 16)	/ 64)
			#define MX_HARD_SLOW_3	1
		#endif
	#endif
 #endif
 #if defined(MX_UART_CHANNEL_4) && (MX_UART_NUM==4)
	#if (MX_UART_CHANNEL_4 == 0)
		#if (MX_UART_BAUD_4 == 1200)
			#define MX_SOFT_BAUD_4	SW_1200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 1200 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_4 == 2400)
			#define MX_SOFT_BAUD_4	SW_2400_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 2400 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_4 == 4800)
			#define MX_SOFT_BAUD_4	SW_4800_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 4800 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_4 == 9600)
			#define MX_SOFT_BAUD_4	SW_9600_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 9600 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_4 == 19200)
			#define MX_SOFT_BAUD_4	SW_19200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 19200 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_4 == 31250)
			#define MX_SOFT_BAUD_4	SW_31250_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 31250 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_4 == 115200)
			#define MX_SOFT_BAUD_4	SW_115200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 115200 Not Available At This Clock Speed"
			#endif
		#endif
		#ifndef MX_SOFT_BAUD_4
			#error "UART Baud Rate not supported in Software Mode"
		#endif
	#else
		#define MX_SOFT_BAUD_4	1
		#define MX_HARD_BAUD_4	(((MX_CLK_SPEED / MX_UART_BAUD_4) - 16) / 16)
		#define MX_HARD_SLOW_4	0

		#if (MX_HARD_BAUD_4 > 255)
			#undef MX_HARD_BAUD_4
			#undef MX_HARD_SLOW_4
			#define MX_HARD_BAUD_4	(((MX_CLK_SPEED / MX_UART_BAUD_4) - 16)	/ 64)
			#define MX_HARD_SLOW_4	1
		#endif
	#endif
 #endif


//Hardware Baud update definitions
#ifndef MX_HARD_BAUD_CHANGE_DEFS
	#define MX_HARD_BAUD_CHANGE_DEFS

	#define MX_HARD_BAUD_1200	(((MX_CLK_SPEED / 1200) - 16) / 16)
	#if (MX_HARD_BAUD_1200 > 255)
		#undef MX_HARD_BAUD_1200
		#define MX_HARD_BAUD_1200	(((MX_CLK_SPEED / 1200) - 16) / 64)
		#define MX_HARD_SLOW_1200	1
	#else
		#define MX_HARD_SLOW_1200	0
	#endif

	#define MX_HARD_BAUD_2400	(((MX_CLK_SPEED / 2400) - 16) / 16)
	#if (MX_HARD_BAUD_2400 > 255)
		#undef MX_HARD_BAUD_2400
		#define MX_HARD_BAUD_2400	(((MX_CLK_SPEED / 2400) - 16) / 64)
		#define MX_HARD_SLOW_2400	1
	#else
		#define MX_HARD_SLOW_2400	0
	#endif

	#define MX_HARD_BAUD_4800	(((MX_CLK_SPEED / 4800) - 16) / 16)
	#if (MX_HARD_BAUD_4800 > 255)
		#undef MX_HARD_BAUD_4800
		#define MX_HARD_BAUD_4800	(((MX_CLK_SPEED / 4800) - 16) / 64)
		#define MX_HARD_SLOW_4800	1
	#else
		#define MX_HARD_SLOW_4800	0
	#endif

	#define MX_HARD_BAUD_9600	(((MX_CLK_SPEED / 9600) - 16) / 16)
	#if (MX_HARD_BAUD_9600 > 255)
		#undef MX_HARD_BAUD_9600
		#define MX_HARD_BAUD_9600	(((MX_CLK_SPEED / 9600) - 16) / 64)
		#define MX_HARD_SLOW_9600	1
	#else
		#define MX_HARD_SLOW_9600	0
	#endif

	#define MX_HARD_BAUD_19200	(((MX_CLK_SPEED / 19200) - 16) / 16)
	#if (MX_HARD_BAUD_19200 > 255)
		#undef MX_HARD_BAUD_19200
		#define MX_HARD_BAUD_19200	(((MX_CLK_SPEED / 19200) - 16) / 64)
		#define MX_HARD_SLOW_19200	1
	#else
		#define MX_HARD_SLOW_19200	0
	#endif

	#define MX_HARD_BAUD_38400	(((MX_CLK_SPEED / 38400) - 16) / 16)
	#if (MX_HARD_BAUD_38400 > 255)
		#undef MX_HARD_BAUD_38400
		#define MX_HARD_BAUD_38400	(((MX_CLK_SPEED / 38400) - 16) / 64)
		#define MX_HARD_SLOW_38400	1
	#else
		#define MX_HARD_SLOW_38400	0
	#endif

	#define MX_HARD_BAUD_57600	(((MX_CLK_SPEED / 57600) - 16) / 16)
	#if (MX_HARD_BAUD_57600 > 255)
		#undef MX_HARD_BAUD_57600
		#define MX_HARD_BAUD_57600	(((MX_CLK_SPEED / 57600) - 16) / 64)
		#define MX_HARD_SLOW_57600	1
	#else
		#define MX_HARD_SLOW_57600	0
	#endif

	#define MX_HARD_BAUD_115200	(((MX_CLK_SPEED / 115200) - 16) / 16)
	#if (MX_HARD_BAUD_115200 > 255)
		#undef MX_HARD_BAUD_115200
		#define MX_HARD_BAUD_115200	(((MX_CLK_SPEED / 115200) - 16) / 64)
		#define MX_HARD_SLOW_115200	1
	#else
		#define MX_HARD_SLOW_115200	0
	#endif
#endif


//Dynamic function naming based on defines and index number
#define MX_UART_CHANNEL_X	CAL_APPEND(MX_UART_CHANNEL_, MX_UART_NUM)
#define MX_UART_TX_PIN_X	CAL_APPEND(MX_UART_TX_PIN_, MX_UART_NUM)
#define MX_UART_TX_PORT_X	CAL_APPEND(MX_UART_TX_PORT_, MX_UART_NUM)
#define MX_UART_TX_TRIS_X	CAL_APPEND(MX_UART_TX_TRIS_, MX_UART_NUM)
#define MX_UART_RX_PIN_X	CAL_APPEND(MX_UART_RX_PIN_, MX_UART_NUM)
#define MX_UART_RX_PORT_X	CAL_APPEND(MX_UART_RX_PORT_, MX_UART_NUM)
#define MX_UART_RX_TRIS_X	CAL_APPEND(MX_UART_RX_TRIS_, MX_UART_NUM)
#define MX_UART_FLOWEN_X	CAL_APPEND(MX_UART_FLOWEN_, MX_UART_NUM)
#define MX_UART_CTS_PIN_X	CAL_APPEND(MX_UART_CTS_PIN_, MX_UART_NUM)
#define MX_UART_CTS_PORT_X	CAL_APPEND(MX_UART_CTS_PORT_, MX_UART_NUM)
#define MX_UART_CTS_TRIS_X	CAL_APPEND(MX_UART_CTS_TRIS_, MX_UART_NUM)
#define MX_UART_RTS_PIN_X	CAL_APPEND(MX_UART_RTS_PIN_, MX_UART_NUM)
#define MX_UART_RTS_PORT_X	CAL_APPEND(MX_UART_RTS_PORT_, MX_UART_NUM)
#define MX_UART_RTS_TRIS_X	CAL_APPEND(MX_UART_RTS_TRIS_, MX_UART_NUM)
#define MX_UART_DBITS_X		CAL_APPEND(MX_UART_DBITS_, MX_UART_NUM)
#define MX_UART_RETURN_X	CAL_APPEND(MX_UART_RETURN_, MX_UART_NUM)
#define MX_UART_ECHO_X		CAL_APPEND(MX_UART_ECHO_, MX_UART_NUM)
#define MX_UART_INT_X		CAL_APPEND(MX_UART_INT_, MX_UART_NUM)
#define MX_UART_BAUD_X		CAL_APPEND(MX_HARD_BAUD_, MX_UART_NUM)
#define MX_SOFT_BAUD_X		CAL_APPEND(MX_SOFT_BAUD_, MX_UART_NUM)
#define MX_HARD_SLOW_X		CAL_APPEND(MX_HARD_SLOW_, MX_UART_NUM)

#define UART_Delay_CAL		CAL_APPEND(FC_CAL_UART_Delay_, MX_UART_NUM)
#define UART_Send			CAL_APPEND(FC_CAL_UART_Send_, MX_UART_NUM)
#define UART_Uninit			CAL_APPEND(FC_CAL_UART_Uninit_, MX_UART_NUM)


//Component Definitions
#define UART_STATUS_LOOP	0
#define UART_STATUS_TIMEOUT	1
#define UART_STATUS_RXBYTE	2


//Interrupt Definitions
#ifdef MX_UART_2_PIE4
  #define MX_UART2_PIE pie4
  #define MX_UART2_PIR pir4
  #define MX_UART2_TXSTA tx2sta
  #define MX_UART2_RCSTA rc2sta
  #define MX_UART2_TXREG tx2reg
  #define MX_UART2_RCREG rc2reg
#else
  #define MX_UART2_PIE pie3
  #define MX_UART2_PIR pir3
  #define MX_UART2_TXSTA txsta2
  #define MX_UART2_RCSTA rcsta2
  #define MX_UART2_TXREG txreg2
  #define MX_UART2_RCREG rcreg2
#endif

#if (MX_UART_INT_X == 1)

	#ifndef MX_UART_INT_DEFS
	#define MX_UART_INT_DEFS

		#define MX_UART_INT_CH1_FUNC
		#define MX_UART_INT_CH2_FUNC
		#define MX_UART_INT_FUNC_END

		#define MX_UART_INT_CH1_DET		ts_bit(pir1, RCIF) && ts_bit(pie1, RCIE)
		#define MX_UART_INT_CH2_DET		ts_bit(MX_UART2_PIR, RC2IF) && ts_bit(MX_UART2_PIE, RC2IE)

		#define MX_UART_INT_CH1_EN		st_bit (pie1, RCIE)
		#define MX_UART_INT_CH2_EN		st_bit (MX_UART2_PIE, RC2IE)

		#define MX_UART_INT_CH1_DIS		cr_bit (pie1, RCIE)
		#define MX_UART_INT_CH2_DIS		cr_bit (MX_UART2_PIE, RC2IE)

		#define MX_UART_INT_CH1_CLR		cr_bit (pir1, RCIF)
		#define MX_UART_INT_CH2_CLR		cr_bit (MX_UART2_PIR, RC2IF)

	#endif
#endif


//Function Prototypes
CALFUNCTION(void, FC_CAL_UART_Init_, (void));
CALFUNCTION(void, FC_CAL_UART_Uninit_, (void));
CALFUNCTION(void, FC_CAL_UART_Send_, (MX_UINT16 nChar));
CALFUNCTION(MX_SINT16, FC_CAL_UART_Receive_, (MX_UINT8 nTimeout));
CALFUNCTION(void, FC_CAL_UART_Delay_, (void));


//Peripheral Functions
CALFUNCTION(void, FC_CAL_UART_Init_, (void))

{

	#if (MX_UART_CHANNEL_X == 0)
		FC_CAL_Bit_In_DDR 	(MX_UART_RX_PORT_X, MX_UART_RX_TRIS_X, MX_UART_RX_PIN_X);		// Receive pin is a input
		FC_CAL_Bit_High_DDR (MX_UART_TX_PORT_X, MX_UART_TX_TRIS_X, MX_UART_TX_PIN_X);		// Transmit pin is default high
	#endif

	#if (MX_UART_CHANNEL_X == 1)
	  #ifndef MX_UART_1
	  	  #error "UART channel 1 not available on this device"
	  #else
		  #if (MX_HARD_SLOW_X == 1)
			cr_bit(txsta, BRGH);						//Low Speed
		  #else
			st_bit(txsta, BRGH);						//High Speed
0081  1683  	BSF STATUS, RP0
0082  1303  	BCF STATUS, RP1
0083  1518  	BSF gbl_txsta,2

		  #endif
			spbrg = MX_UART_BAUD_X;   					// set the baud rate
0084  3019  	MOVLW 0x19
0085  0099  	MOVWF gbl_spbrg

			rcsta = 0;                    				// 8-bit, disabled
0086  1283  	BCF STATUS, RP0
0087  0198  	CLRF gbl_rcsta


			#if(MX_UART_DBITS_X == 9)
				st_bit(txsta, TX9);   					// 9-bit TX
				st_bit(rcsta, RX9);                    	// 9-bit RX
			#endif

			st_bit(rcsta, SPEN);         				// turn on serial interface
0088  1798  	BSF gbl_rcsta,7

			st_bit(txsta, TXEN);
0089  1683  	BSF STATUS, RP0
008A  1698  	BSF gbl_txsta,5

			st_bit(rcsta, CREN);
008B  1283  	BCF STATUS, RP0
008C  1618  	BSF gbl_rcsta,4


			#if (MX_UART_INT_X == 1)
				MX_UART_INT_CH1_EN;
				st_bit(intcon, PEIE);
				st_bit(intcon, GIE);
			#else
				cr_bit (pie1, RCIE);
008D  1683  	BSF STATUS, RP0
008E  128C  	BCF gbl_pie1,5

			#endif
	  #endif
	#endif


	#if (MX_UART_CHANNEL_X == 2)

	  #ifndef MX_UART_2
		  #error "UART channel 2 not available on this device"
	  #else
		  #ifdef MX_UART_2_REMAPPABLE
			RPOR9 = 5;									//TX2 - RP9 - RB6
			RPINR16	= 10;								//RX2 - RP10 - RB7
		  #endif
		  #if (MX_HARD_SLOW_X == 1)
			cr_bit(MX_UART2_TXSTA, BRGH);						//Low Speed
		  #else
			st_bit(MX_UART2_TXSTA, BRGH);						//High Speed
		  #endif
			spbrg2 = MX_UART_BAUD_X;   				// set the baud rate
			MX_UART2_RCSTA = 0;                    				// 8-bit, disabled

			#if(MX_UART_DBITS_X == 9)
				st_bit(MX_UART2_TXSTA, TX9);   					// 9-bit TX
				st_bit(MX_UART2_RCSTA, RX9);                    // 9-bit RX
			#endif

			st_bit(MX_UART2_RCSTA, SPEN);         				// turn on serial interface
			st_bit(MX_UART2_TXSTA, TXEN);
			st_bit(MX_UART2_RCSTA, CREN);

			#if (MX_UART_INT_X == 1)
				MX_UART_INT_CH2_EN;
				st_bit(intcon, PEIE);
				st_bit(intcon, GIE);
			#else
				cr_bit (MX_UART2_PIE, RC2IE);
			#endif
	  #endif
	#endif

	#if (MX_UART_FLOWEN_X == 1)						//Flowcontrol enabled?
		FC_CAL_Bit_In_DDR (MX_UART_CTS_PORT_X, MX_UART_CTS_TRIS_X, MX_UART_CTS_PIN_X);	// CTS pin is a input
		FC_CAL_Bit_High_DDR (MX_UART_RTS_PORT_X, MX_UART_RTS_TRIS_X, MX_UART_RTS_PIN_X);	// RTS not ready to accept data
	#endif

}
008F  0008  	RETURN




CALFUNCTION(void, FC_CAL_UART_Uninit_, (void))
{

	#if (MX_UART_CHANNEL_X == 0)
		FC_CAL_Bit_In_DDR (MX_UART_RX_PORT_X, MX_UART_RX_TRIS_X, MX_UART_RX_PIN_X);		// Receive pin is a input
		FC_CAL_Bit_In_DDR (MX_UART_TX_PORT_X, MX_UART_TX_TRIS_X, MX_UART_TX_PIN_X);		// Transmit pin is default high
	#endif

	#if (MX_UART_CHANNEL_X == 1)
			rcsta = 0;                    								// 8-bit, disabled
			txsta = 0;
		  #ifdef MX_UART_RXINT
			MX_UART_INT_CH1_DIS;
		  #endif
	#endif

	#if (MX_UART_CHANNEL_X == 2)
			MX_UART2_RCSTA = 0;                    								// 8-bit, disabled
			MX_UART2_TXSTA = 0;
		  #ifdef MX_UART_RXINT
			MX_UART_INT_CH2_DIS;
		  #endif
	#endif

	#if (MX_UART_FLOWEN_X == 1)										//Flowcontrol enabled?
		FC_CAL_Bit_In_DDR (MX_UART_CTS_PORT_X, MX_UART_CTS_TRIS_X, MX_UART_CTS_PIN_X);		// CTS pin is a input
		FC_CAL_Bit_In_DDR (MX_UART_RTS_PORT_X, MX_UART_RTS_TRIS_X, MX_UART_RTS_PIN_X);		// RTS not ready to accept data
	#endif
}



CALFUNCTION(void, FC_CAL_UART_Send_, (MX_UINT16 nChar))
{
	#if (MX_UART_FLOWEN_X == 1)
		while (FC_CAL_Bit_In(MX_UART_CTS_PORT_X, MX_UART_CTS_PIN_X) != 0);	// Wait until CTS is low
	#endif

	#if (MX_UART_CHANNEL_X == 0)													// Software UART TX
		MX_UINT8 idx;
		FC_CAL_Bit_Low(MX_UART_TX_PORT_X, MX_UART_TX_PIN_X);					// Send Start bit
		UART_Delay_CAL();
		for (idx = 0; idx < MX_UART_DBITS_X; idx++)
		{
			if (nChar & 0x01)														// Mask off data bit
				FC_CAL_Bit_High(MX_UART_TX_PORT_X, MX_UART_TX_PIN_X);
			else
				FC_CAL_Bit_Low(MX_UART_TX_PORT_X, MX_UART_TX_PIN_X);
			UART_Delay_CAL();
			nChar = nChar >> 1;														// Move to next data bit
		}
		FC_CAL_Bit_High(MX_UART_TX_PORT_X, MX_UART_TX_PIN_X);					// Send Stop bit
		UART_Delay_CAL();
	#endif

	#if (MX_UART_CHANNEL_X == 1)
		while (ts_bit(pir1, TXIF) == 0);

		#if (MX_UART_DBITS_X == 9)
			if (test_bit(nChar, 8))
				st_bit(txsta, TX9D);
			else
				cr_bit(txsta, TX9D);
	  	#endif
		txreg = nChar;
	#endif

	#if (MX_UART_CHANNEL_X == 2)
		while (ts_bit(pir3, TX2IF) == 0);

		#if (MX_UART_DBITS_X == 9)
			if (test_bit(nChar, 8))
				st_bit(MX_UART2_TXSTA, TX9D);
			else
				cr_bit(MX_UART2_TXSTA, TX9D);
		#endif
		MX_UART2_TXREG = nChar;
	#endif
}


CALFUNCTION(MX_SINT16, FC_CAL_UART_Receive_, (MX_UINT8 nTimeout))

{
  #if (MX_UART_RETURN_X == 1)
	MX_UINT16 retVal = 512;
  #else
  	MX_UINT8 retVal = 255;
0035  30FF  	MOVLW 0xFF
0036  00CE  	MOVWF FC_CAL_UAR_0005F_1_retVal

  #endif

	MX_UINT8 delay1 = 0;
0037  01CF  	CLRF FC_CAL_UAR_0005F_1_delay1

	MX_UINT8 regcheck = 0;
0038  01D0  	CLRF FC_CAL_UAR_0005F_1_regcheck

	MX_UINT8 bWaitForever = 0;
0039  01D1  	CLRF FC_CAL_UAR_0005F_1_bWaitForever

	MX_UINT8 rxStatus = UART_STATUS_LOOP;
003A  01D2  	CLRF FC_CAL_UAR_0005F_1_rxStatus


  #if (MX_UART_CHANNEL_X == 0)
  	MX_UINT8 idx;
  #else
  	MX_UINT8 dummy = 0;
003B  01D3  	CLRF FC_CAL_UAR_0005F_1_dummy

  #endif

	if (nTimeout == 255)
003C  0A4D  	INCF FC_CAL_UAR_0005F_arg_nTimeout, W
003D  1D03  	BTFSS STATUS,Z
003E  2841  	GOTO	label5
0041        label5

		bWaitForever = 1;
003F  3001  	MOVLW 0x01
0040  00D1  	MOVWF FC_CAL_UAR_0005F_1_bWaitForever


	#if (MX_UART_FLOWEN_X == 1)
		FC_CAL_Bit_Low (MX_UART_RTS_PORT_X, MX_UART_RTS_PIN_X);			// Ready to accept data
	#endif

	while (rxStatus == UART_STATUS_LOOP)
0041  08D2  	MOVF FC_CAL_UAR_0005F_1_rxStatus, F
0042  1D03  	BTFSS STATUS,Z
0043  2863  	GOTO	label8
0062  2841  	GOTO	label5
0063        label8

	{
		if (bWaitForever == 0)
0044  08D1  	MOVF FC_CAL_UAR_0005F_1_bWaitForever, F
0045  1D03  	BTFSS STATUS,Z
0046  285A  	GOTO	label7

		{
			if (nTimeout == 0)							//don't wait forever, so do timeout thing...
0047  08CD  	MOVF FC_CAL_UAR_0005F_arg_nTimeout, F
0048  1D03  	BTFSS STATUS,Z
0049  284D  	GOTO	label6
004D        label6

			{
				rxStatus = UART_STATUS_TIMEOUT;
004A  3001  	MOVLW 0x01
004B  00D2  	MOVWF FC_CAL_UAR_0005F_1_rxStatus

			}
			else
004C  285A  	GOTO	label7

			{
				delay_us(10);
004D  300A  	MOVLW 0x0A
004E  00D4  	MOVWF delay_us_00000_arg_del
004F  2010  	CALL delay_us_00000

				delay1 = delay1 + 1;
0050  0A4F  	INCF FC_CAL_UAR_0005F_1_delay1, W
0051  00CF  	MOVWF FC_CAL_UAR_0005F_1_delay1

				if(delay1 == 100)
0052  084F  	MOVF FC_CAL_UAR_0005F_1_delay1, W
0053  3A64  	XORLW 0x64
0054  1D03  	BTFSS STATUS,Z
0055  285A  	GOTO	label7
005A        label7

				{
					nTimeout = nTimeout - 1;
0056  034D  	DECF FC_CAL_UAR_0005F_arg_nTimeout, W
0057  00CD  	MOVWF FC_CAL_UAR_0005F_arg_nTimeout

					MX_CLEAR_WATCHDOG;
0058  0064  	CLRWDT

					delay1 = 0;
0059  01CF  	CLRF FC_CAL_UAR_0005F_1_delay1

				}
			}
		}

		#if (MX_UART_CHANNEL_X == 0)
			regcheck = FC_CAL_Bit_In(MX_UART_RX_PORT_1, MX_UART_RX_PIN_1);	//Test for start bit
			if (regcheck == 0)
				rxStatus = UART_STATUS_RXBYTE;
		#endif

		#if (MX_UART_CHANNEL_X == 1)
			regcheck = ts_bit(pir1, RCIF);
005A  3020  	MOVLW 0x20
005B  050C  	ANDWF gbl_pir1, W
005C  00D0  	MOVWF FC_CAL_UAR_0005F_1_regcheck

			if (regcheck != 0)
005D  08D0  	MOVF FC_CAL_UAR_0005F_1_regcheck, F
005E  1903  	BTFSC STATUS,Z
005F  2841  	GOTO	label5

				rxStatus = UART_STATUS_RXBYTE;
0060  3002  	MOVLW 0x02
0061  00D2  	MOVWF FC_CAL_UAR_0005F_1_rxStatus

		#endif

		#if (MX_UART_CHANNEL_X == 2)
			regcheck = ts_bit(MX_UART2_PIR, RC2IF);
			if (regcheck != 0)
				rxStatus = UART_STATUS_RXBYTE;
		#endif

	}

	if (rxStatus == UART_STATUS_RXBYTE)
0063  0852  	MOVF FC_CAL_UAR_0005F_1_rxStatus, W
0064  3A02  	XORLW 0x02
0065  1D03  	BTFSS STATUS,Z
0066  287D  	GOTO	label11

	{
		#if (MX_UART_CHANNEL_X == 0)

			retVal = 0;
			UART_Delay_CAL();

			for (idx = 0; idx < MX_UART_DBITS_X; idx++)
			{
				if (FC_CAL_Bit_In(MX_UART_RX_PORT_X, MX_UART_RX_PIN_X))
					retVal = retVal | (0x01 << idx);

				UART_Delay_CAL();
			}
		#endif

		#if (MX_UART_CHANNEL_X == 1)
			regcheck = ts_bit(rcsta, FERR);
0067  3004  	MOVLW 0x04
0068  0518  	ANDWF gbl_rcsta, W
0069  00D0  	MOVWF FC_CAL_UAR_0005F_1_regcheck

			if (regcheck != 0)
006A  08D0  	MOVF FC_CAL_UAR_0005F_1_regcheck, F
006B  1903  	BTFSC STATUS,Z
006C  2870  	GOTO	label9
0070        label9

			{
				dummy = rcreg;						//need to read the rcreg to clear FERR
006D  081A  	MOVF gbl_rcreg, W
006E  00D3  	MOVWF FC_CAL_UAR_0005F_1_dummy

				#if (MX_UART_RETURN_X == 1)
					retVal = 0x400;					//Framing Error Flag
				#endif
			}
			else
006F  287D  	GOTO	label11

			{
				regcheck = ts_bit(rcsta, OERR);
0070  3002  	MOVLW 0x02
0071  0518  	ANDWF gbl_rcsta, W
0072  00D0  	MOVWF FC_CAL_UAR_0005F_1_regcheck

				if (regcheck != 0)
0073  08D0  	MOVF FC_CAL_UAR_0005F_1_regcheck, F
0074  1903  	BTFSC STATUS,Z
0075  2879  	GOTO	label10
0079        label10

				{
					cr_bit(rcsta, CREN);			//Reset receiver to clear error
0076  1218  	BCF gbl_rcsta,4

					st_bit(rcsta, CREN);
0077  1618  	BSF gbl_rcsta,4


					#if (MX_UART_RETURN_X == 1)
						retVal = 0x800;				//Overrun Error Flag
					#endif
				}
				else
0078  287D  	GOTO	label11
007D        label11

				{
					retVal = 0;
0079  01CE  	CLRF FC_CAL_UAR_0005F_1_retVal


					#if (MX_UART_DBITS_X == 9)
						if(ts_bit(rcsta, RX9D))
							retVal = 0x100;
					#endif

					retVal = retVal | rcreg; 			//no error, so rx byte is valid
007A  081A  	MOVF gbl_rcreg, W
007B  044E  	IORWF FC_CAL_UAR_0005F_1_retVal, W
007C  00CE  	MOVWF FC_CAL_UAR_0005F_1_retVal

				}
			}
		#endif

		#if (MX_UART_CHANNEL_X == 2)
			regcheck = ts_bit(MX_UART2_RCSTA, FERR);
			if (regcheck != 0)
			{
				dummy = MX_UART2_RCREG;			//need to read the rcreg to clear FERR
				#if (MX_UART_RETURN_X == 1)
					retVal = 0x400;					//Framing Error Flag
				#endif
			}
			else
			{
				regcheck = ts_bit(MX_UART2_RCSTA, OERR);
				if (regcheck != 0)
				{
					cr_bit(MX_UART2_RCSTA, CREN);	//Reset receiver to clear error
					st_bit(MX_UART2_RCSTA, CREN);
					#if (MX_UART_RETURN_X == 1)
						retVal = 0x800;				//Overrun Error Flag
					#endif
				}
				else
				{
					retVal = 0;

					#if (MX_UART_DBITS_X == 9)
						if(ts_bit(MX_UART2_RCSTA, RX9D))
							retVal = 0x100;
					#endif

					retVal = retVal | MX_UART2_RCREG; 			//no error, so rx byte is valid
				}
			}

		#endif

		#if (MX_UART_ECHO_X == 1)
			UART_Send(retVal);
		#endif
	}

	#if (MX_UART_FLOWEN_X == 1)
		FC_CAL_Bit_High(MX_UART_RTS_PORT_X, MX_UART_RTS_PIN_X);		//not ready to accept data
	#endif

	return (retVal);
007D  084E  	MOVF FC_CAL_UAR_0005F_1_retVal, W
007E  00D4  	MOVWF CompTempVarRet2196
007F  01D5  	CLRF CompTempVarRet2196+D'1'

}
0080  0008  	RETURN



CALFUNCTION(void, FC_CAL_UART_Delay_, (void))
{
  #if (MX_UART_CHANNEL_X == 0)

	MX_UINT16 delay = MX_SOFT_BAUD_X;

	while (delay > 255)
	{
		delay_us(255);
		delay = delay - 255;
		MX_CLEAR_WATCHDOG;
	}
	delay_us(delay);
	MX_CLEAR_WATCHDOG;

  #endif
}


CALFUNCTION(void, FC_CAL_UART_Update_Baud_, (MX_UINT8 new_baud))
{
	//Baud Rates - Function compatible with hardware mode only
	/*
	0 - 1200
	1 - 2400
	2 - 4800
	3 - 9600
	4 - 19200
	5 - 38400
	6 - 57600
	7 - 115200
	*/

	MX_UINT8 baudrate, baudmode;

	if (new_baud > 7)
		return;

	if (new_baud == 0)
	{
		baudrate = MX_HARD_BAUD_1200;
		baudmode = MX_HARD_SLOW_1200;
	}
	else if (new_baud == 1)
	{
		baudrate = MX_HARD_BAUD_2400;
		baudmode = MX_HARD_SLOW_2400;
	}
	else if (new_baud == 2)
	{
		baudrate = MX_HARD_BAUD_4800;
		baudmode = MX_HARD_SLOW_4800;
	}
	else if (new_baud == 3)
	{
		baudrate = MX_HARD_BAUD_9600;
		baudmode = MX_HARD_SLOW_9600;
	}
	else if (new_baud == 4)
	{
		baudrate = MX_HARD_BAUD_19200;
		baudmode = MX_HARD_SLOW_19200;
	}
	else if (new_baud == 5)
	{
		baudrate = MX_HARD_BAUD_38400;
		baudmode = MX_HARD_SLOW_38400;
	}
	else if (new_baud == 6)
	{
		baudrate = MX_HARD_BAUD_57600;
		baudmode = MX_HARD_SLOW_57600;
	}
	else if (new_baud == 7)
	{
		baudrate = MX_HARD_BAUD_115200;
		baudmode = MX_HARD_SLOW_115200;
	}

	UART_Uninit();

	#if (MX_UART_CHANNEL_X == 1)

	    if (baudmode == 1)
			cr_bit(txsta, BRGH);					//Low Speed
	    else
			st_bit(txsta, BRGH);					//High Speed

		spbrg = baudrate;   						// set the baud rate
		rcsta = 0;                    				// 8-bit, disabled

		#if(MX_UART_DBITS_X == 9)
			st_bit(txsta, TX9);   					// 9-bit TX
			st_bit(rcsta, RX9);                    	// 9-bit RX
		#endif

		st_bit(rcsta, SPEN);         				// turn on serial interface
		st_bit(txsta, TXEN);
		st_bit(rcsta, CREN);

		#if (MX_UART_INT_X == 1)
			MX_UART_INT_CH1_EN;
			st_bit(intcon, PEIE);
			st_bit(intcon, GIE);
		#else
			cr_bit (pie1, RCIE);
		#endif
	#endif

	#if (MX_UART_CHANNEL_X == 2)

	  	if (baudmode == 1)
			cr_bit(MX_UART2_TXSTA, BRGH);			//Low Speed
	  	else
			st_bit(MX_UART2_TXSTA, BRGH);			//High Speed

		spbrg2 = baudrate;   						// set the baud rate
		MX_UART2_RCSTA = 0;                    		// 8-bit, disabled

		#if(MX_UART_DBITS_X == 9)
			st_bit(MX_UART2_TXSTA, TX9);   			// 9-bit TX
			st_bit(MX_UART2_RCSTA, RX9);            // 9-bit RX
		#endif

		st_bit(MX_UART2_RCSTA, SPEN);         		// turn on serial interface
		st_bit(MX_UART2_TXSTA, TXEN);
		st_bit(MX_UART2_RCSTA, CREN);

		#if (MX_UART_INT_X == 1)
			MX_UART_INT_CH2_EN;
			st_bit(intcon, PEIE);
			st_bit(intcon, GIE);
		#else
			cr_bit (MX_UART2_PIE, RC2IE);
		#endif
	#endif

	#if (MX_UART_FLOWEN_X == 1)						//Flowcontrol enabled?
		FC_CAL_Bit_In_DDR (MX_UART_CTS_PORT_X, MX_UART_CTS_TRIS_X, MX_UART_CTS_PIN_X);	// CTS pin is a input
		FC_CAL_Bit_High_DDR (MX_UART_RTS_PORT_X, MX_UART_RTS_TRIS_X, MX_UART_RTS_PIN_X);	// RTS not ready to accept data
	#endif

}

////////////////////////////////////////
// Code with no source :-)
////////////////////////////////////////
0000  2A63  	GOTO	_startup

0004  00FF  	MOVWF Int1Context
0005  0E03  	SWAPF STATUS, W
0006  1283  	BCF STATUS, RP0
0007  1303  	BCF STATUS, RP1
0008  00B4  	MOVWF Int1BContext
0009  0E0A  	SWAPF PCLATH, W
000A  00B5  	MOVWF Int1BContext+D'1'
000B  0E04  	SWAPF FSR, W
000C  00B6  	MOVWF Int1BContext+D'2'
000D  118A  	BCF PCLATH,3
000E  120A  	BCF PCLATH,4
000F  2A8E  	GOTO	interrupt
0010        delay_us_00000
0010        ; { delay_us ; function begin
0010  3003  	MOVLW 0x03
0011  07D4  	ADDWF delay_us_00000_arg_del, F
0012  0CD4  	RRF delay_us_00000_arg_del, F
0013  0CD4  	RRF delay_us_00000_arg_del, F
0014  307F  	MOVLW 0x7F
0015  05D4  	ANDWF delay_us_00000_arg_del, F
0016        label1
0016  0000  	NOP
0017  0BD4  	DECFSZ delay_us_00000_arg_del, F
0018  2816  	GOTO	label1
0019  0008  	RETURN
001A        ; } delay_us function end

001A        delay_ms_00000
001A        ; { delay_ms ; function begin
001A  08CE  	MOVF delay_ms_00000_arg_del, F
001B  1D03  	BTFSS STATUS,Z
001C  281E  	GOTO	label2
001D  0008  	RETURN
001E        label2
001E  30F9  	MOVLW 0xF9
001F        label3
001F  3EFF  	ADDLW 0xFF
0020  1D03  	BTFSS STATUS,Z
0021  281F  	GOTO	label3
0022  0000  	NOP
0023  0BCE  	DECFSZ delay_ms_00000_arg_del, F
0024  281E  	GOTO	label2
0025  0008  	RETURN
0026        ; } delay_ms function end

0026        delay_s_00000
0026        ; { delay_s ; function begin
0026        label4
0026  30FA  	MOVLW 0xFA
0027  00CE  	MOVWF delay_ms_00000_arg_del
0028  201A  	CALL delay_ms_00000
0029  30FA  	MOVLW 0xFA
002A  00CE  	MOVWF delay_ms_00000_arg_del
002B  201A  	CALL delay_ms_00000
002C  30FA  	MOVLW 0xFA
002D  00CE  	MOVWF delay_ms_00000_arg_del
002E  201A  	CALL delay_ms_00000
002F  30FA  	MOVLW 0xFA
0030  00CE  	MOVWF delay_ms_00000_arg_del
0031  201A  	CALL delay_ms_00000
0032  0BCD  	DECFSZ delay_s_00000_arg_del, F
0033  2826  	GOTO	label4
0034  0008  	RETURN
0035        ; } delay_s function end


0263        _startup
0263  30D5  	MOVLW 0xD5
0264  1283  	BCF STATUS, RP0
0265  1303  	BCF STATUS, RP1
0266  00A0  	MOVWF gbl_14_LSR
0267  30C4  	MOVLW 0xC4
0268  00A1  	MOVWF gbl_14_LSR+D'1'
0269  30BB  	MOVLW 0xBB
026A  00A2  	MOVWF gbl_14_LSR+D'2'
026B  30DC  	MOVLW 0xDC
026C  00A3  	MOVWF gbl_14_LSR+D'3'
026D  01A4  	CLRF gbl_15_gbl_aSig
026E  01A5  	CLRF gbl_15_gbl_aSig+D'1'
026F  01A6  	CLRF gbl_15_gbl_aSig+D'2'
0270  01A7  	CLRF gbl_15_gbl_aSig+D'3'
0271  01A8  	CLRF gbl_15_gbl_bSig
0272  01A9  	CLRF gbl_15_gbl_bSig+D'1'
0273  01AA  	CLRF gbl_15_gbl_bSig+D'2'
0274  01AB  	CLRF gbl_15_gbl_bSig+D'3'
0275  01AC  	CLRF gbl_15_gbl_zSig
0276  01AD  	CLRF gbl_15_gbl_zSig+D'1'
0277  01AE  	CLRF gbl_15_gbl_zSig+D'2'
0278  01AF  	CLRF gbl_15_gbl_zSig+D'3'
0279  01BE  	CLRF gbl_15_gbl_aExp
027A  01BF  	CLRF gbl_15_gbl_bExp
027B  01B7  	CLRF gbl_15_gbl_zExp
027C  01B8  	CLRF gbl_15_gbl_zExp+D'1'
027D  01C0  	CLRF gbl_15_gbl_aSign
027E  01C1  	CLRF gbl_15_gbl_bSign
027F  01C2  	CLRF gbl_15_gbl_zSign
0280  01C3  	CLRF gbl_15_gbl_zSigZero
0281  01B0  	CLRF gbl_15_gbl_ret
0282  01B1  	CLRF gbl_15_gbl_ret+D'1'
0283  01B2  	CLRF gbl_15_gbl_ret+D'2'
0284  01B3  	CLRF gbl_15_gbl_ret+D'3'
0285  01BC  	CLRF gbl_float_rounding_mode
0286  01BD  	CLRF gbl_float_exception_flags
0287  01BB  	CLRF gbl_float_detect_tininess

028B  118A  	BCF PCLATH,3
028C  120A  	BCF PCLATH,4
028D  2934  	GOTO	main

2007  30D4  	DW 0x30D4
