;/////////////////////////////////////////////////////////////////////////////////
;// Code Generator: BoostC Compiler - http://www.sourceboost.com
;// Version       : 7.03
;// License Type  : Pro License
;// Limitations   : PIC12,PIC16 max code size:Unlimited, max RAM banks:Unlimited
;/////////////////////////////////////////////////////////////////////////////////

//************************************************************************************
//**  
//**  File name:     C:\Users\gerpe\OneDrive\GER-PER 2016\Documents\KennyNeutron\2020\SPWM\pic16f690_spwm\SPWM.c
//**  Title:         
//**  Description:   
//**  
//**  Generated by:  Flowcode v5.2.0.0
//**  Date:          Tuesday, November 24, 2020 16:30:30
//**  Licence:       Professional
//**  Registered to: xyz
//**  Licence key:   WUK7B9
//**  
//**  
//**  http://www.matrixmultimedia.com
//**  
//************************************************************************************


#define MX_PIC

#define MX_USES_UINT8 1
#define MX_USES_SINT16 0
#define MX_USES_CHAR 0
#define MX_USES_FLOAT 0
#define MX_USES_SINT32 0
#define MX_USES_BOOL 1
#define MX_USES_UINT16 0
#define MX_USES_UINT32 0
//Defines for microcontroller
#define P16F690
#define FC_CAL_PIC
#define MX_ADC
#define MX_ADC_TYPE_3
#define MX_ADC_BITS_10
#define MX_EE
#define MX_EE_TYPE2
#define MX_EE_SIZE 256
#define MX_SPI_1
#define MX_SPI_1_MISO_PORT portb
#define MX_SPI_1_MISO_TRIS trisb
#define MX_SPI_1_MISO_PIN 4
#define MX_SPI_1_MOSI_PORT portc
#define MX_SPI_1_MOSI_TRIS trisc
#define MX_SPI_1_MOSI_PIN 7
#define MX_SPI_1_CLK_PORT portb
#define MX_SPI_1_CLK_TRIS trisb
#define MX_SPI_1_CLK_PIN 6
#define MX_SPI_1_SS_PORT portb
#define MX_SPI_1_SS_TRIS trisb
#define MX_UART_1
#define MX_UART_1_TX_PORT portb
#define MX_UART_1_TX_TRIS trisb
#define MX_UART_1_TX_PIN 7
#define MX_UART_1_RX_PORT portb
#define MX_UART_1_RX_TRIS trisb
#define MX_UART_1_RX_PIN 5
#define MX_I2C
#define MX_MI2C
#define MX_I2C_1
#define MX_I2C_1_SDA_PORT portb
#define MX_I2C_1_SDA_TRIS trisb
#define MX_I2C_1_SDA_PIN 4
#define MX_I2C_1_SCL_PORT portb
#define MX_I2C_1_SCL_TRIS trisb
#define MX_I2C_1_SCL_PIN 6
#define MX_PWM
#define MX_PWM_CNT 1
#define MX_PWM_PSCA1
#define MX_PWM_PSCA4
#define MX_PWM_PSCA16
#define MX_PWM_1_PORT portc
#define MX_PWM_1_TRIS trisc
#define MX_PWM_1_PIN 5

//Functions
#define MX_CLK_SPEED 20000000
#ifdef _BOOSTC
#include <system.h>
#endif
#ifdef HI_TECH_C
#include <pic.h>
#endif

//Configuration data
#ifdef _BOOSTC
#pragma DATA 0x2007, 0x30c2
#endif
#ifdef HI_TECH_C
__CONFIG(0x30c2);
#endif

//Internal functions
#include "C:\Program Files (x86)\Flowcode\v5\FCD\internals.c"

//Macro function declarations
void FCM_pwm0();
void FCM_spwm();
void FCM_pwm1();


//Variable declarations
#define FCV_FALSE (0)
#define FCV_TRUE (1)
MX_UINT8 FCV_DIV_COUNTER = (0x0);
0143  01C2  	CLRF gbl_FCV_DIV_COUNTER

MX_BOOL FCV_FLAG0 = (0);
0144  1043  	BCF gbl_FCV_FLAG0,0

MX_UINT8 FCV_DUTY_COUNTER = (0x0);
0145  01C4  	CLRF gbl_FCV_DUTY_COUNTER

MX_UINT8 FCV_DELAY_0 = (0x0);
0146  01C5  	CLRF gbl_FCV_DELAY_0

MX_UINT8 FCV_DELAY_1 = (0x0);
0147  01C6  	CLRF gbl_FCV_DELAY_1




#include "C:\Program Files (x86)\Flowcode\v5\CAL\includes.c"

//Macro implementations


void FCM_pwm0()

{

	//Decision
	//Decision: div_counter > 16?
	if (FCV_DIV_COUNTER > 16)
008F  1283  	BCF STATUS, RP0
0090  1303  	BCF STATUS, RP1
0091  0842  	MOVF gbl_FCV_DIV_COUNTER, W
0092  3C10  	SUBLW 0x10
0093  1803  	BTFSC STATUS,C
0094  28DA  	GOTO	label9
00DA        label9

	{

		//Decision
		//Decision: div_counter > 24?
		if (FCV_DIV_COUNTER > 24)
0095  0842  	MOVF gbl_FCV_DIV_COUNTER, W
0096  3C18  	SUBLW 0x18
0097  1803  	BTFSC STATUS,C
0098  28CC  	GOTO	label8
00CC        label8

		{

			//Decision
			//Decision: div_counter > 40?
			if (FCV_DIV_COUNTER > 40)
0099  0842  	MOVF gbl_FCV_DIV_COUNTER, W
009A  3C28  	SUBLW 0x28
009B  1803  	BTFSC STATUS,C
009C  28AA  	GOTO	label7
00AA        label7

			{

				//Output
				//Output: 0 -> C0
				trisc = trisc & 0xFE;
009D  30FE  	MOVLW 0xFE
009E  1683  	BSF STATUS, RP0
009F  0507  	ANDWF gbl_trisc, W
00A0  0087  	MOVWF gbl_trisc

				if ((0))
					portc = (portc & 0xFE) | 0x01;
				else
					portc = portc & 0xFE;
00A1  30FE  	MOVLW 0xFE
00A2  1283  	BCF STATUS, RP0
00A3  0507  	ANDWF gbl_portc, W
00A4  0087  	MOVWF gbl_portc


				//Calculation
				//Calculation:
				//  duty_counter = 1
				//  div_counter = 0
				FCV_DUTY_COUNTER = 1;
00A5  3001  	MOVLW 0x01
00A6  00C4  	MOVWF gbl_FCV_DUTY_COUNTER

				FCV_DIV_COUNTER = 0;
00A7  01C2  	CLRF gbl_FCV_DIV_COUNTER


				//Calculation
				//Calculation:
				//  flag0 = 1
				FCV_FLAG0 = 1;
00A8  1443  	BSF gbl_FCV_FLAG0,0


			} else {

				//Calculation
				//Calculation:
				//  duty_counter = duty_counter - 1
				//  div_counter = div_counter + 1
				FCV_DUTY_COUNTER = FCV_DUTY_COUNTER - 1;
00AA  0344  	DECF gbl_FCV_DUTY_COUNTER, W
00AB  00C4  	MOVWF gbl_FCV_DUTY_COUNTER

				FCV_DIV_COUNTER = FCV_DIV_COUNTER + 1;
00AC  0A42  	INCF gbl_FCV_DIV_COUNTER, W
00AD  00C2  	MOVWF gbl_FCV_DIV_COUNTER


				//Output
				//Output: 1 -> C0
				trisc = trisc & 0xFE;
00AE  30FE  	MOVLW 0xFE
00AF  1683  	BSF STATUS, RP0
00B0  0507  	ANDWF gbl_trisc, W
00B1  0087  	MOVWF gbl_trisc

				if ((1))
					portc = (portc & 0xFE) | 0x01;
00B2  30FE  	MOVLW 0xFE
00B3  1283  	BCF STATUS, RP0
00B4  0507  	ANDWF gbl_portc, W
00B5  00C8  	MOVWF CompTempVar2188
00B6  3001  	MOVLW 0x01
00B7  0448  	IORWF CompTempVar2188, W
00B8  0087  	MOVWF gbl_portc

				else
					portc = portc & 0xFE;

				//Calculation
				//Calculation:
				//  delay_1 = 10 * duty_counter
				FCV_DELAY_1 = 10 * FCV_DUTY_COUNTER;
00B9  300A  	MOVLW 0x0A
00BA  00C8  	MOVWF __mul_8_8__00005_arg_a
00BB  0844  	MOVF gbl_FCV_DUTY_COUNTER, W
00BC  00C9  	MOVWF __mul_8_8__00005_arg_b
00BD  2015  	CALL __mul_8_8__00005
00BE  084B  	MOVF CompTempVarRet451, W
00BF  00C6  	MOVWF gbl_FCV_DELAY_1


				//Delay
				//Delay: delay_1 us
				delay_us(FCV_DELAY_1);
00C0  0846  	MOVF gbl_FCV_DELAY_1, W
00C1  00C8  	MOVWF delay_us_00000_arg_del
00C2  2010  	CALL delay_us_00000


				//Output
				//Output: 0 -> C0
				trisc = trisc & 0xFE;
00C3  30FE  	MOVLW 0xFE
00C4  1683  	BSF STATUS, RP0
00C5  0507  	ANDWF gbl_trisc, W
00C6  0087  	MOVWF gbl_trisc

				if ((0))
					portc = (portc & 0xFE) | 0x01;
				else
					portc = portc & 0xFE;
00C7  30FE  	MOVLW 0xFE
00C8  1283  	BCF STATUS, RP0
00C9  0507  	ANDWF gbl_portc, W
00CA  0087  	MOVWF gbl_portc


			}

		} else {

			//Output
			//Output: 1 -> C0
			trisc = trisc & 0xFE;
00CC  30FE  	MOVLW 0xFE
00CD  1683  	BSF STATUS, RP0
00CE  0507  	ANDWF gbl_trisc, W
00CF  0087  	MOVWF gbl_trisc

			if ((1))
				portc = (portc & 0xFE) | 0x01;
00D0  30FE  	MOVLW 0xFE
00D1  1283  	BCF STATUS, RP0
00D2  0507  	ANDWF gbl_portc, W
00D3  00C8  	MOVWF CompTempVar2189
00D4  3001  	MOVLW 0x01
00D5  0448  	IORWF CompTempVar2189, W
00D6  0087  	MOVWF gbl_portc

			else
				portc = portc & 0xFE;

			//Calculation
			//Calculation:
			//  div_counter = div_counter + 1
			FCV_DIV_COUNTER = FCV_DIV_COUNTER + 1;
00D7  0A42  	INCF gbl_FCV_DIV_COUNTER, W
00D8  00C2  	MOVWF gbl_FCV_DIV_COUNTER


		}

	} else {

		//Output
		//Output: 1 -> C0
		trisc = trisc & 0xFE;
00DA  30FE  	MOVLW 0xFE
00DB  1683  	BSF STATUS, RP0
00DC  0507  	ANDWF gbl_trisc, W
00DD  0087  	MOVWF gbl_trisc

		if ((1))
			portc = (portc & 0xFE) | 0x01;
00DE  30FE  	MOVLW 0xFE
00DF  1283  	BCF STATUS, RP0
00E0  0507  	ANDWF gbl_portc, W
00E1  00C8  	MOVWF CompTempVar2190
00E2  3001  	MOVLW 0x01
00E3  0448  	IORWF CompTempVar2190, W
00E4  0087  	MOVWF gbl_portc

		else
			portc = portc & 0xFE;

		//Calculation
		//Calculation:
		//  delay_1 = 10 * duty_counter
		FCV_DELAY_1 = 10 * FCV_DUTY_COUNTER;
00E5  300A  	MOVLW 0x0A
00E6  00C8  	MOVWF __mul_8_8__00005_arg_a
00E7  0844  	MOVF gbl_FCV_DUTY_COUNTER, W
00E8  00C9  	MOVWF __mul_8_8__00005_arg_b
00E9  2015  	CALL __mul_8_8__00005
00EA  084B  	MOVF CompTempVarRet451, W
00EB  00C6  	MOVWF gbl_FCV_DELAY_1


		//Delay
		//Delay: delay_1 us
		delay_us(FCV_DELAY_1);
00EC  0846  	MOVF gbl_FCV_DELAY_1, W
00ED  00C8  	MOVWF delay_us_00000_arg_del
00EE  2010  	CALL delay_us_00000


		//Output
		//Output: 0 -> C0
		trisc = trisc & 0xFE;
00EF  30FE  	MOVLW 0xFE
00F0  1683  	BSF STATUS, RP0
00F1  0507  	ANDWF gbl_trisc, W
00F2  0087  	MOVWF gbl_trisc

		if ((0))
			portc = (portc & 0xFE) | 0x01;
		else
			portc = portc & 0xFE;
00F3  30FE  	MOVLW 0xFE
00F4  1283  	BCF STATUS, RP0
00F5  0507  	ANDWF gbl_portc, W
00F6  0087  	MOVWF gbl_portc


		//Calculation
		//Calculation:
		//  duty_counter = duty_counter + 1
		//  div_counter = div_counter + 1
		FCV_DUTY_COUNTER = FCV_DUTY_COUNTER + 1;
00F7  0A44  	INCF gbl_FCV_DUTY_COUNTER, W
00F8  00C4  	MOVWF gbl_FCV_DUTY_COUNTER

		FCV_DIV_COUNTER = FCV_DIV_COUNTER + 1;
00F9  0A42  	INCF gbl_FCV_DIV_COUNTER, W
00FA  00C2  	MOVWF gbl_FCV_DIV_COUNTER


	}

}
00A9  0008  	RETURN
00CB  0008  	RETURN
00D9  0008  	RETURN
00FB  0008  	RETURN



void FCM_spwm()

{

	//Decision
	//Decision: flag0 = 0?
	if (FCV_FLAG0 == 0)
00FC  1283  	BCF STATUS, RP0
00FD  1303  	BCF STATUS, RP1
00FE  1843  	BTFSC gbl_FCV_FLAG0,0
00FF  2902  	GOTO	label10
0102        label10

	{

		//Call Macro
		//Call Macro: pwm0()
		FCM_pwm0();
0100  208F  	CALL FCM_pwm0_00000


	} else {

		//Call Macro
		//Call Macro: pwm1()
		FCM_pwm1();
0102  2022  	CALL FCM_pwm1_00000


	}

}
0101  0008  	RETURN
0103  0008  	RETURN



void FCM_pwm1()

{

	//Decision
	//Decision: div_counter > 16?
	if (FCV_DIV_COUNTER > 16)
0022  1283  	BCF STATUS, RP0
0023  1303  	BCF STATUS, RP1
0024  0842  	MOVF gbl_FCV_DIV_COUNTER, W
0025  3C10  	SUBLW 0x10
0026  1803  	BTFSC STATUS,C
0027  286D  	GOTO	label6
006D        label6

	{

		//Decision
		//Decision: div_counter > 24?
		if (FCV_DIV_COUNTER > 24)
0028  0842  	MOVF gbl_FCV_DIV_COUNTER, W
0029  3C18  	SUBLW 0x18
002A  1803  	BTFSC STATUS,C
002B  285F  	GOTO	label5
005F        label5

		{

			//Decision
			//Decision: div_counter > 40?
			if (FCV_DIV_COUNTER > 40)
002C  0842  	MOVF gbl_FCV_DIV_COUNTER, W
002D  3C28  	SUBLW 0x28
002E  1803  	BTFSC STATUS,C
002F  283D  	GOTO	label4
003D        label4

			{

				//Output
				//Output: 0 -> C1
				trisc = trisc & 0xFD;
0030  30FD  	MOVLW 0xFD
0031  1683  	BSF STATUS, RP0
0032  0507  	ANDWF gbl_trisc, W
0033  0087  	MOVWF gbl_trisc

				if ((0))
					portc = (portc & 0xFD) | 0x02;
				else
					portc = portc & 0xFD;
0034  30FD  	MOVLW 0xFD
0035  1283  	BCF STATUS, RP0
0036  0507  	ANDWF gbl_portc, W
0037  0087  	MOVWF gbl_portc


				//Calculation
				//Calculation:
				//  duty_counter = 1
				//  div_counter = 0
				FCV_DUTY_COUNTER = 1;
0038  3001  	MOVLW 0x01
0039  00C4  	MOVWF gbl_FCV_DUTY_COUNTER

				FCV_DIV_COUNTER = 0;
003A  01C2  	CLRF gbl_FCV_DIV_COUNTER


				//Calculation
				//Calculation:
				//  flag0 = 0
				FCV_FLAG0 = 0;
003B  1043  	BCF gbl_FCV_FLAG0,0


			} else {

				//Calculation
				//Calculation:
				//  duty_counter = duty_counter - 1
				//  div_counter = div_counter + 1
				FCV_DUTY_COUNTER = FCV_DUTY_COUNTER - 1;
003D  0344  	DECF gbl_FCV_DUTY_COUNTER, W
003E  00C4  	MOVWF gbl_FCV_DUTY_COUNTER

				FCV_DIV_COUNTER = FCV_DIV_COUNTER + 1;
003F  0A42  	INCF gbl_FCV_DIV_COUNTER, W
0040  00C2  	MOVWF gbl_FCV_DIV_COUNTER


				//Output
				//Output: 1 -> C1
				trisc = trisc & 0xFD;
0041  30FD  	MOVLW 0xFD
0042  1683  	BSF STATUS, RP0
0043  0507  	ANDWF gbl_trisc, W
0044  0087  	MOVWF gbl_trisc

				if ((1))
					portc = (portc & 0xFD) | 0x02;
0045  30FD  	MOVLW 0xFD
0046  1283  	BCF STATUS, RP0
0047  0507  	ANDWF gbl_portc, W
0048  00C8  	MOVWF CompTempVar2191
0049  3002  	MOVLW 0x02
004A  0448  	IORWF CompTempVar2191, W
004B  0087  	MOVWF gbl_portc

				else
					portc = portc & 0xFD;

				//Calculation
				//Calculation:
				//  delay_1 = 10 * duty_counter
				FCV_DELAY_1 = 10 * FCV_DUTY_COUNTER;
004C  300A  	MOVLW 0x0A
004D  00C8  	MOVWF __mul_8_8__00005_arg_a
004E  0844  	MOVF gbl_FCV_DUTY_COUNTER, W
004F  00C9  	MOVWF __mul_8_8__00005_arg_b
0050  2015  	CALL __mul_8_8__00005
0051  084B  	MOVF CompTempVarRet451, W
0052  00C6  	MOVWF gbl_FCV_DELAY_1


				//Delay
				//Delay: delay_1 us
				delay_us(FCV_DELAY_1);
0053  0846  	MOVF gbl_FCV_DELAY_1, W
0054  00C8  	MOVWF delay_us_00000_arg_del
0055  2010  	CALL delay_us_00000


				//Output
				//Output: 0 -> C1
				trisc = trisc & 0xFD;
0056  30FD  	MOVLW 0xFD
0057  1683  	BSF STATUS, RP0
0058  0507  	ANDWF gbl_trisc, W
0059  0087  	MOVWF gbl_trisc

				if ((0))
					portc = (portc & 0xFD) | 0x02;
				else
					portc = portc & 0xFD;
005A  30FD  	MOVLW 0xFD
005B  1283  	BCF STATUS, RP0
005C  0507  	ANDWF gbl_portc, W
005D  0087  	MOVWF gbl_portc


			}

		} else {

			//Output
			//Output: 1 -> C1
			trisc = trisc & 0xFD;
005F  30FD  	MOVLW 0xFD
0060  1683  	BSF STATUS, RP0
0061  0507  	ANDWF gbl_trisc, W
0062  0087  	MOVWF gbl_trisc

			if ((1))
				portc = (portc & 0xFD) | 0x02;
0063  30FD  	MOVLW 0xFD
0064  1283  	BCF STATUS, RP0
0065  0507  	ANDWF gbl_portc, W
0066  00C8  	MOVWF CompTempVar2192
0067  3002  	MOVLW 0x02
0068  0448  	IORWF CompTempVar2192, W
0069  0087  	MOVWF gbl_portc

			else
				portc = portc & 0xFD;

			//Calculation
			//Calculation:
			//  div_counter = div_counter + 1
			FCV_DIV_COUNTER = FCV_DIV_COUNTER + 1;
006A  0A42  	INCF gbl_FCV_DIV_COUNTER, W
006B  00C2  	MOVWF gbl_FCV_DIV_COUNTER


		}

	} else {

		//Output
		//Output: 1 -> C1
		trisc = trisc & 0xFD;
006D  30FD  	MOVLW 0xFD
006E  1683  	BSF STATUS, RP0
006F  0507  	ANDWF gbl_trisc, W
0070  0087  	MOVWF gbl_trisc

		if ((1))
			portc = (portc & 0xFD) | 0x02;
0071  30FD  	MOVLW 0xFD
0072  1283  	BCF STATUS, RP0
0073  0507  	ANDWF gbl_portc, W
0074  00C8  	MOVWF CompTempVar2193
0075  3002  	MOVLW 0x02
0076  0448  	IORWF CompTempVar2193, W
0077  0087  	MOVWF gbl_portc

		else
			portc = portc & 0xFD;

		//Calculation
		//Calculation:
		//  delay_1 = 10 * duty_counter
		FCV_DELAY_1 = 10 * FCV_DUTY_COUNTER;
0078  300A  	MOVLW 0x0A
0079  00C8  	MOVWF __mul_8_8__00005_arg_a
007A  0844  	MOVF gbl_FCV_DUTY_COUNTER, W
007B  00C9  	MOVWF __mul_8_8__00005_arg_b
007C  2015  	CALL __mul_8_8__00005
007D  084B  	MOVF CompTempVarRet451, W
007E  00C6  	MOVWF gbl_FCV_DELAY_1


		//Delay
		//Delay: delay_1 us
		delay_us(FCV_DELAY_1);
007F  0846  	MOVF gbl_FCV_DELAY_1, W
0080  00C8  	MOVWF delay_us_00000_arg_del
0081  2010  	CALL delay_us_00000


		//Output
		//Output: 0 -> C1
		trisc = trisc & 0xFD;
0082  30FD  	MOVLW 0xFD
0083  1683  	BSF STATUS, RP0
0084  0507  	ANDWF gbl_trisc, W
0085  0087  	MOVWF gbl_trisc

		if ((0))
			portc = (portc & 0xFD) | 0x02;
		else
			portc = portc & 0xFD;
0086  30FD  	MOVLW 0xFD
0087  1283  	BCF STATUS, RP0
0088  0507  	ANDWF gbl_portc, W
0089  0087  	MOVWF gbl_portc


		//Calculation
		//Calculation:
		//  duty_counter = duty_counter + 1
		//  div_counter = div_counter + 1
		FCV_DUTY_COUNTER = FCV_DUTY_COUNTER + 1;
008A  0A44  	INCF gbl_FCV_DUTY_COUNTER, W
008B  00C4  	MOVWF gbl_FCV_DUTY_COUNTER

		FCV_DIV_COUNTER = FCV_DIV_COUNTER + 1;
008C  0A42  	INCF gbl_FCV_DIV_COUNTER, W
008D  00C2  	MOVWF gbl_FCV_DIV_COUNTER


	}

}
003C  0008  	RETURN
005E  0008  	RETURN
006C  0008  	RETURN
008E  0008  	RETURN




void main()

{
	//Initialization
	ansel = 0;
0104  1283  	BCF STATUS, RP0
0105  1703  	BSF STATUS, RP1
0106  019E  	CLRF gbl_ansel

anselh = 0;
0107  019F  	CLRF gbl_anselh



	//Interrupt initialization code
	option_reg = 0xC0;
0108  30C0  	MOVLW 0xC0
0109  1683  	BSF STATUS, RP0
010A  1303  	BCF STATUS, RP1
010B  0081  	MOVWF gbl_option_reg



	//Calculation
	//Calculation:
	//  duty_counter = 0
	//  div_counter = 0
	//  flag0 = 0
	FCV_DUTY_COUNTER = 0;
010C  1283  	BCF STATUS, RP0
010D  01C4  	CLRF gbl_FCV_DUTY_COUNTER

	FCV_DIV_COUNTER = 0;
010E  01C2  	CLRF gbl_FCV_DIV_COUNTER

	FCV_FLAG0 = 0;
010F  1043  	BCF gbl_FCV_FLAG0,0


	//Interrupt
	//Interrupt: Enable TMR0
	cr_bit(option_reg,T0CS);
0110  1683  	BSF STATUS, RP0
0111  1281  	BCF gbl_option_reg,5

	st_bit(option_reg,T0SE);
0112  1601  	BSF gbl_option_reg,4

	option_reg = (option_reg & 0xF0) | 0x01;
0113  30F0  	MOVLW 0xF0
0114  0501  	ANDWF gbl_option_reg, W
0115  1283  	BCF STATUS, RP0
0116  00C7  	MOVWF CompTempVar2194
0117  3001  	MOVLW 0x01
0118  0447  	IORWF CompTempVar2194, W
0119  1683  	BSF STATUS, RP0
011A  0081  	MOVWF gbl_option_reg

	st_bit(intcon,GIE);
011B  178B  	BSF gbl_intcon,7

	st_bit(intcon, T0IE);
011C  168B  	BSF gbl_intcon,5


	//Loop
	//Loop: While 1
	while (1)
011D        label11
011D  291D  	GOTO	label11

	{


	}

	mainendloop: goto mainendloop;
}


void MX_INTERRUPT_MACRO(void)

{
	//Handler code for [TMR0]
	#ifndef MX_INTHANDLER_intcon_T0IF
	#define MX_INTHANDLER_intcon_T0IF
	if (ts_bit(intcon, T0IF) && ts_bit(intcon, T0IE))
014B  1D0B  	BTFSS gbl_intcon,2
014C  2951  	GOTO	label13
014D  1E8B  	BTFSS gbl_intcon,5
014E  2951  	GOTO	label13
0151        label13

	{
		#ifdef USE_FLOWCODE_ICD
			extern char ICD_Interrupt_Enable = 1;
		#endif	
		FCM_spwm();
014F  20FC  	CALL FCM_spwm_00000

		cr_bit(intcon, T0IF);
0150  110B  	BCF gbl_intcon,2

		#ifdef USE_FLOWCODE_ICD
			extern char ICD_Interrupt_Enable = 0;
		#endif	
	}
	#else
	#warning "This interrupt has previously been enabled, so the macro <spwm> may never get called."
	#endif


}
0151  1283  	BCF STATUS, RP0
0152  1303  	BCF STATUS, RP1
0153  0E36  	SWAPF Int1BContext+D'2', W
0154  0084  	MOVWF FSR
0155  0E35  	SWAPF Int1BContext+D'1', W
0156  008A  	MOVWF PCLATH
0157  0E34  	SWAPF Int1BContext, W
0158  0083  	MOVWF STATUS
0159  0EFF  	SWAPF Int1Context, F
015A  0E7F  	SWAPF Int1Context, W
015B  0009  	RETFIE





////////////////////////////////////////
// Code with no source :-)
////////////////////////////////////////
0000  291E  	GOTO	_startup

0004  00FF  	MOVWF Int1Context
0005  0E03  	SWAPF STATUS, W
0006  1283  	BCF STATUS, RP0
0007  1303  	BCF STATUS, RP1
0008  00B4  	MOVWF Int1BContext
0009  0E0A  	SWAPF PCLATH, W
000A  00B5  	MOVWF Int1BContext+D'1'
000B  0E04  	SWAPF FSR, W
000C  00B6  	MOVWF Int1BContext+D'2'
000D  118A  	BCF PCLATH,3
000E  120A  	BCF PCLATH,4
000F  294B  	GOTO	interrupt
0010        delay_us_00000
0010        ; { delay_us ; function begin
0010        label1
0010  0000  	NOP
0011  0000  	NOP
0012  0BC8  	DECFSZ delay_us_00000_arg_del, F
0013  2810  	GOTO	label1
0014  0008  	RETURN
0015        ; } delay_us function end

0015        __mul_8_8__00005
0015        ; { __mul_8_8__8 ; function begin
0015  01CA  	CLRF __mul_8_8__00005_1_i
0016  01CB  	CLRF CompTempVarRet451
0017        label2
0017  19CA  	BTFSC __mul_8_8__00005_1_i,3
0018  0008  	RETURN
0019  1C49  	BTFSS __mul_8_8__00005_arg_b,0
001A  281D  	GOTO	label3
001B  0848  	MOVF __mul_8_8__00005_arg_a, W
001C  07CB  	ADDWF CompTempVarRet451, F
001D        label3
001D  0CC9  	RRF __mul_8_8__00005_arg_b, F
001E  1003  	BCF gbl_status,0
001F  0DC8  	RLF __mul_8_8__00005_arg_a, F
0020  0ACA  	INCF __mul_8_8__00005_1_i, F
0021  2817  	GOTO	label2
0022        ; } __mul_8_8__8 function end


011E        _startup
011E  30D5  	MOVLW 0xD5
011F  1283  	BCF STATUS, RP0
0120  1303  	BCF STATUS, RP1
0121  00A0  	MOVWF gbl_14_LSR
0122  30C4  	MOVLW 0xC4
0123  00A1  	MOVWF gbl_14_LSR+D'1'
0124  30BB  	MOVLW 0xBB
0125  00A2  	MOVWF gbl_14_LSR+D'2'
0126  30DC  	MOVLW 0xDC
0127  00A3  	MOVWF gbl_14_LSR+D'3'
0128  01A4  	CLRF gbl_15_gbl_aSig
0129  01A5  	CLRF gbl_15_gbl_aSig+D'1'
012A  01A6  	CLRF gbl_15_gbl_aSig+D'2'
012B  01A7  	CLRF gbl_15_gbl_aSig+D'3'
012C  01A8  	CLRF gbl_15_gbl_bSig
012D  01A9  	CLRF gbl_15_gbl_bSig+D'1'
012E  01AA  	CLRF gbl_15_gbl_bSig+D'2'
012F  01AB  	CLRF gbl_15_gbl_bSig+D'3'
0130  01AC  	CLRF gbl_15_gbl_zSig
0131  01AD  	CLRF gbl_15_gbl_zSig+D'1'
0132  01AE  	CLRF gbl_15_gbl_zSig+D'2'
0133  01AF  	CLRF gbl_15_gbl_zSig+D'3'
0134  01BC  	CLRF gbl_15_gbl_aExp
0135  01BD  	CLRF gbl_15_gbl_bExp
0136  01B7  	CLRF gbl_15_gbl_zExp
0137  01B8  	CLRF gbl_15_gbl_zExp+D'1'
0138  01BE  	CLRF gbl_15_gbl_aSign
0139  01BF  	CLRF gbl_15_gbl_bSign
013A  01C0  	CLRF gbl_15_gbl_zSign
013B  01C1  	CLRF gbl_15_gbl_zSigZero
013C  01B0  	CLRF gbl_15_gbl_ret
013D  01B1  	CLRF gbl_15_gbl_ret+D'1'
013E  01B2  	CLRF gbl_15_gbl_ret+D'2'
013F  01B3  	CLRF gbl_15_gbl_ret+D'3'
0140  01BA  	CLRF gbl_float_rounding_mode
0141  01BB  	CLRF gbl_float_exception_flags
0142  01B9  	CLRF gbl_float_detect_tininess

0148  118A  	BCF PCLATH,3
0149  120A  	BCF PCLATH,4
014A  2904  	GOTO	main

2007  30C2  	DW 0x30C2
