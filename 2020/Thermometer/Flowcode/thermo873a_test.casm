;/////////////////////////////////////////////////////////////////////////////////
;// Code Generator: BoostC Compiler - http://www.sourceboost.com
;// Version       : 7.03
;// License Type  : Pro License
;// Limitations   : PIC12,PIC16 max code size:Unlimited, max RAM banks:Unlimited
;/////////////////////////////////////////////////////////////////////////////////

//************************************************************************************
//**  
//**  File name:     C:\Users\gerpe\OneDrive\GER-PER 2016\Documents\KennyNeutron\2020\Thermometer\Flowcode\thermo873a_test.c
//**  Title:         
//**  Description:   
//**  
//**  Generated by:  Flowcode v5.2.0.0
//**  Date:          Friday, July 17, 2020 14:25:22
//**  Licence:       Professional
//**  Registered to: xyz
//**  Licence key:   WUK7B9
//**  
//**  
//**  http://www.matrixmultimedia.com
//**  
//************************************************************************************


#define MX_PIC

#define MX_USES_UINT8 1
#define MX_USES_SINT16 1
#define MX_USES_CHAR 0
#define MX_USES_FLOAT 1
#define MX_USES_SINT32 1
#define MX_USES_BOOL 1
#define MX_USES_UINT16 1
#define MX_USES_UINT32 0
//Defines for microcontroller
#define P16F873A
#define FC_CAL_PIC
#define MX_ADC
#define MX_ADC_TYPE_1
#define MX_ADC_BITS_10
#define MX_EE
#define MX_EE_TYPE2
#define MX_EE_SIZE 128
#define MX_SPI_1
#define MX_SPI_1_MISO_PORT portc
#define MX_SPI_1_MISO_TRIS trisc
#define MX_SPI_1_MISO_PIN 4
#define MX_SPI_1_MOSI_PORT portc
#define MX_SPI_1_MOSI_TRIS trisc
#define MX_SPI_1_MOSI_PIN 5
#define MX_SPI_1_CLK_PORT portc
#define MX_SPI_1_CLK_TRIS trisc
#define MX_SPI_1_CLK_PIN 3
#define MX_SPI_1_SS_PORT portc
#define MX_SPI_1_SS_TRIS trisc
#define MX_UART_1
#define MX_UART_1_TX_PORT portc
#define MX_UART_1_TX_TRIS trisc
#define MX_UART_1_TX_PIN 6
#define MX_UART_1_RX_PORT portc
#define MX_UART_1_RX_TRIS trisc
#define MX_UART_1_RX_PIN 7
#define MX_I2C
#define MX_MI2C
#define MX_I2C_1
#define MX_I2C_1_SDA_PORT portc
#define MX_I2C_1_SDA_TRIS trisc
#define MX_I2C_1_SDA_PIN 4
#define MX_I2C_1_SCL_PORT portc
#define MX_I2C_1_SCL_TRIS trisc
#define MX_I2C_1_SCL_PIN 3
#define MX_PWM
#define MX_PWM_CNT 2
#define MX_PWM_PSCA1
#define MX_PWM_PSCA4
#define MX_PWM_PSCA16
#define MX_PWM_1_PORT portc
#define MX_PWM_1_TRIS trisc
#define MX_PWM_1_PIN 2
#define MX_PWM_2_PORT portc
#define MX_PWM_2_TRIS trisc
#define MX_PWM_2_PIN 1

//Functions
#define MX_CLK_SPEED 3276800
#ifdef _BOOSTC
#include <system.h>
#endif
#ifdef HI_TECH_C
#include <pic.h>
#endif

//Configuration data
#ifdef _BOOSTC
#pragma DATA 0x2007, 0x1e72
#endif
#ifdef HI_TECH_C
__CONFIG(0x1e72);
#endif

//Internal functions
#include "C:\Program Files (x86)\Flowcode\v5\FCD\internals.c"

//Macro function declarations
void FCM_i2c_comm();
void FCM_intro();
void FCM_scan1();
void FCM_scan2();
void FCM_scan3();
void FCM_scan4();
void FCM_ikotled();
void FCM_seg_pattern();
void FCM_display_temp();
void FCM_scan_off();
void FCM_calc();
void FCM_calibrate();
void FCM_display_calib();
void FCM_display_error();
void FCM_error();
void FCM_display_repeat();
void FCM_ready();
void FCM_def_calib();


//Variable declarations
#define FCV_FALSE (0)
#define FCV_TRUE (1)
MX_UINT8 FCV_CALIB_ADD0_DAT = (0x0);
08F1  01D4  	CLRF gbl_FCV_CALIB_ADD0_DAT

MX_UINT8 FCV_TEMP_TENS = (0x0);
08F2  01D5  	CLRF gbl_FCV_TEMP_TENS

MX_UINT8 FCV_D_BYTE = (0x0);
08F3  01D6  	CLRF gbl_FCV_D_BYTE

MX_UINT8 FCV_CALIB_ADD1_DAT = (0x0);
08F4  01D7  	CLRF gbl_FCV_CALIB_ADD1_DAT

MX_UINT8 FCV_TRIM = (0xff);
08F5  30FF  	MOVLW 0xFF
08F6  00D8  	MOVWF gbl_FCV_TRIM

MX_UINT8 FCV_TEMP_CDP = (0x0);
08F7  01D9  	CLRF gbl_FCV_TEMP_CDP

MX_SINT32 FCV_RAW = (0);
08F8  01B4  	CLRF gbl_FCV_RAW
08F9  01B5  	CLRF gbl_FCV_RAW+D'1'
08FA  01B6  	CLRF gbl_FCV_RAW+D'2'
08FB  01B7  	CLRF gbl_FCV_RAW+D'3'

MX_UINT8 FCV_DATA0 = (0xff);
08FC  30FF  	MOVLW 0xFF
08FD  00DA  	MOVWF gbl_FCV_DATA0

MX_UINT8 FCV_SAVE_IDXH = (0x0);
08FE  01DB  	CLRF gbl_FCV_SAVE_IDXH

MX_UINT8 FCV_DATA1 = (0xff);
08FF  30FF  	MOVLW 0xFF
0900  00DC  	MOVWF gbl_FCV_DATA1

MX_UINT8 FCV_DP2 = (0x0);
0901  01DD  	CLRF gbl_FCV_DP2

MX_UINT8 FCV_DATA2 = (0xff);
0902  30FF  	MOVLW 0xFF
0903  00DE  	MOVWF gbl_FCV_DATA2

MX_UINT8 FCV_CALIB_ADD0 = (0x2);
0904  3002  	MOVLW 0x02
0905  00DF  	MOVWF gbl_FCV_CALIB_ADD0

MX_FLOAT FCV_FL;
MX_UINT8 FCV_TEMP_DEC = (0x0);
0906  01E0  	CLRF gbl_FCV_TEMP_DEC

MX_UINT8 FCV_CALIB_ADD1 = (0x3);
0907  3003  	MOVLW 0x03
0908  00E1  	MOVWF gbl_FCV_CALIB_ADD1

MX_UINT8 FCV_SAVE_IDXL = (0x0);
0909  01E2  	CLRF gbl_FCV_SAVE_IDXL

MX_UINT8 FCV_TRIM_PREV = (0xff);
090A  30FF  	MOVLW 0xFF
090B  00E3  	MOVWF gbl_FCV_TRIM_PREV

MX_UINT8 FCV_TEMP_ONES = (0x0);
090C  01E4  	CLRF gbl_FCV_TEMP_ONES

MX_UINT8 FCV_LSB = (0x0);
090D  01E5  	CLRF gbl_FCV_LSB

MX_UINT8 FCV_RT_BYTE = (0x1);
090E  3001  	MOVLW 0x01
090F  00E6  	MOVWF gbl_FCV_RT_BYTE

MX_UINT16 FCV_CALIB_SUBTRACTOR = (0x0);
0910  01C5  	CLRF gbl_FCV_CALIB_SUBTRACTOR
0911  01C6  	CLRF gbl_FCV_CALIB_SUBTRACTOR+D'1'

MX_UINT8 FCV_MSB = (0x0);
0912  01E7  	CLRF gbl_FCV_MSB

MX_UINT8 FCV_DIGIT = (0x0);
0913  01E8  	CLRF gbl_FCV_DIGIT

MX_UINT8 FCV_CALIB_TEMP = (0x0);
0914  01E9  	CLRF gbl_FCV_CALIB_TEMP

MX_BOOL FCV_FLAGBIT = (0);
0915  106A  	BCF gbl_FCV_FLAGBIT,0

MX_SINT32 FCV_TRIM_DIFF = (0);
0916  01B8  	CLRF gbl_FCV_TRIM_DIFF
0917  01B9  	CLRF gbl_FCV_TRIM_DIFF+D'1'
0918  01BA  	CLRF gbl_FCV_TRIM_DIFF+D'2'
0919  01BB  	CLRF gbl_FCV_TRIM_DIFF+D'3'

MX_SINT32 FCV_TEMP_C = (0);
091A  01BC  	CLRF gbl_FCV_TEMP_C
091B  01BD  	CLRF gbl_FCV_TEMP_C+D'1'
091C  01BE  	CLRF gbl_FCV_TEMP_C+D'2'
091D  01BF  	CLRF gbl_FCV_TEMP_C+D'3'

MX_UINT8 FCV_I2C_RX = (0x0);
091E  01EB  	CLRF gbl_FCV_I2C_RX

MX_UINT8 FCV_CALIB_FACTOR;
MX_UINT8 FCV_CALIB_VAR = (0x0);
091F  01ED  	CLRF gbl_FCV_CALIB_VAR

MX_UINT8 FCV_DATA_PREV = (0xff);
0920  30FF  	MOVLW 0xFF
0921  00EE  	MOVWF gbl_FCV_DATA_PREV

MX_UINT8 FCV_SW_COUNTER = (0x0);
0922  01EF  	CLRF gbl_FCV_SW_COUNTER

MX_UINT8 FCV_IHAP = (0x0);
0923  01F0  	CLRF gbl_FCV_IHAP

MX_SINT16 FCV_CALIB_OFFSET = (0);
0924  01C7  	CLRF gbl_FCV_CALIB_OFFSET
0925  01C8  	CLRF gbl_FCV_CALIB_OFFSET+D'1'

MX_BOOL FCV_SW_IR = (1);
0926  14EA  	BSF gbl_FCV_SW_IR,1

MX_UINT8 FCV_DATA_DIFF = (0x0);
0927  01F1  	CLRF gbl_FCV_DATA_DIFF

MX_UINT8 FCV_ERRORCOUNT = (0x0);
0928  01F2  	CLRF gbl_FCV_ERRORCOUNT


MX_UINT8 FCLV_LOOP1;
MX_UINT8 FCLV_LOOP2;
MX_UINT8 FCLV_LOOP3;
MX_UINT8 FCLV_LOOP4;
MX_UINT8 FCLV_LOOP5;
MX_UINT8 FCLV_LOOP6;
MX_UINT8 FCLV_LOOP7;



//I2C_Master(0): //Defines:

/**** Macro Substitutions ****
a = Unique component ID
b = I2C Channel - 0=SW, 1-4=HW
c = Baud Rate
d = SM BUS Enable 0/2
e = Slew Rate Enable 0/1
f = Bitbanged Data Port Letter
g = Bitbanged Data Pin
h = Bitbanged Clock Port Letter
i = Bitbanged Clock Pin
******************************/

//BMODE
//Bit 0 - Slew Control
//Bit 1 - SMBus Control

//Definitions for I2C slot allocation
#ifndef	MX_I2C_REF1
	#define MX_I2C_REF1
	#define I2CMASTER_9_MX_I2C_UREF			1
	#define MX_I2C_CHANNEL_1		1
	#define MX_I2C_SDA_PIN_1		4
	#define MX_I2C_SDA_PORT_1		portd
	#define MX_I2C_SDA_TRIS_1		trisd
	#define MX_I2C_SCL_PIN_1		3
	#define MX_I2C_SCL_PORT_1		portd
	#define MX_I2C_SCL_TRIS_1		trisd
	#define MX_I2C_BMODE_1			0 | 0
	#define MX_I2C_BAUD_1			100000
	#define MX_I2C_INT_1			0
#else
 #ifndef MX_I2C_REF2
	#define MX_I2C_REF2
	#define I2CMASTER_9_MX_I2C_UREF			2
	#define MX_I2C_CHANNEL_2		1
	#define MX_I2C_SDA_PIN_2		4
	#define MX_I2C_SDA_PORT_2		portd
	#define MX_I2C_SDA_TRIS_2		trisd
	#define MX_I2C_SCL_PIN_2		3
	#define MX_I2C_SCL_PORT_2		portd
	#define MX_I2C_SCL_TRIS_2		trisd
	#define MX_I2C_BMODE_2			0 | 0
	#define MX_I2C_BAUD_2			100000
	#define MX_I2C_INT_2			0
 #else
  #ifndef MX_I2C_REF3
	#define MX_I2C_REF3
	#define I2CMASTER_9_MX_I2C_UREF			3
	#define MX_I2C_CHANNEL_3		1
	#define MX_I2C_SDA_PIN_3		4
	#define MX_I2C_SDA_PORT_3		portd
	#define MX_I2C_SDA_TRIS_3		trisd
	#define MX_I2C_SCL_PIN_3		3
	#define MX_I2C_SCL_PORT_3		portd
	#define MX_I2C_SCL_TRIS_3		trisd
	#define MX_I2C_BMODE_3			0 | 0
	#define MX_I2C_BAUD_3			100000
	#define MX_I2C_INT_3			0
  #else
   #ifndef MX_I2C_REF4
	#define MX_I2C_REF4
	#define I2CMASTER_9_MX_I2C_UREF			4
	#define MX_I2C_CHANNEL_4		1
	#define MX_I2C_SDA_PIN_4		4
	#define MX_I2C_SDA_PORT_4		portd
	#define MX_I2C_SDA_TRIS_4		trisd
	#define MX_I2C_SCL_PIN_4		3
	#define MX_I2C_SCL_PORT_4		portd
	#define MX_I2C_SCL_TRIS_4		trisd
	#define MX_I2C_BMODE_4			0 | 0
	#define MX_I2C_BAUD_4			100000
	#define MX_I2C_INT_4			0
   #endif
  #endif
 #endif
#endif

#define I2CMASTER_9_I2C_Master_Init		CAL_APPEND(FC_CAL_I2C_Master_Init_, I2CMASTER_9_MX_I2C_UREF)
#define I2CMASTER_9_I2C_Master_Uninit	CAL_APPEND(FC_CAL_I2C_Master_Uninit_, I2CMASTER_9_MX_I2C_UREF)
#define I2CMASTER_9_I2C_Master_Start		CAL_APPEND(FC_CAL_I2C_Master_Start_, I2CMASTER_9_MX_I2C_UREF)
#define I2CMASTER_9_I2C_Master_Restart	CAL_APPEND(FC_CAL_I2C_Master_Restart_, I2CMASTER_9_MX_I2C_UREF)
#define I2CMASTER_9_I2C_Master_Stop		CAL_APPEND(FC_CAL_I2C_Master_Stop_, I2CMASTER_9_MX_I2C_UREF)
#define I2CMASTER_9_I2C_Master_TX_Byte	CAL_APPEND(FC_CAL_I2C_Master_TX_Byte_, I2CMASTER_9_MX_I2C_UREF)
#define I2CMASTER_9_I2C_Master_RX_Byte	CAL_APPEND(FC_CAL_I2C_Master_RX_Byte_, I2CMASTER_9_MX_I2C_UREF)

extern void I2CMASTER_9_I2C_Master_Init ();
extern void I2CMASTER_9_I2C_Master_Uninit ();
extern void I2CMASTER_9_I2C_Master_Start ();
extern void I2CMASTER_9_I2C_Master_Restart ();
extern void I2CMASTER_9_I2C_Master_Stop ();
extern MX_UINT8 I2CMASTER_9_I2C_Master_TX_Byte (MX_UINT8 Data);
extern MX_UINT8 I2CMASTER_9_I2C_Master_RX_Byte (MX_UINT8 Last);




//I2C_Master(0): //Macro function declarations

void FCD_I2C_Master0_MI2C_Init();
void FCD_I2C_Master0_MI2C_Start();
void FCD_I2C_Master0_MI2C_Restart();
void FCD_I2C_Master0_MI2C_Stop();
MX_UINT8 FCD_I2C_Master0_MI2C_Transmit_Byte(MX_UINT8 Data);
MX_UINT8 FCD_I2C_Master0_MI2C_Receive_Byte(MX_UINT8 Last);
void FCD_I2C_Master0_MI2C_Send_Byte_Transaction(MX_UINT8 Device_ID, MX_UINT8 AddrH, MX_UINT8 AddrL, MX_UINT8 Data);
MX_UINT8 FCD_I2C_Master0_MI2C_Receive_Byte_Transaction(MX_UINT8 Device_ID, MX_UINT8 AddrH, MX_UINT8 AddrL);


//ADC(0): //Defines:

/**** Macro Substitutions ****
a = Unique Reference
b = Which ADC Channel
c = Acquisition time
d = Conversion Speed
e = VRef+ Option
f = VRef Voltage x 0.01V
******************************/

//Common Defines

#define ADC_11_MX_ADC_CHANNEL	4
#define ADC_11_MX_ADC_ACTIME	40
#define ADC_11_MX_ADC_CONVSP	3
#define ADC_11_MX_ADC_VREFOP	0
#define ADC_11_MX_ADC_VREFVOL	500

#ifndef MX_ADC_CHANNEL_4
 #define MX_ADC_CHANNEL_4			//Inform CAL ADC channel 4 is now in use.
#endif

#ifndef MX_ADC_REF					//Inform CAL ADC peripheral is now in use
 #define MX_ADC_REF
#endif

extern void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge);
extern MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode);
extern void FC_CAL_Disable_ADC (void);




//ADC(0): //Macro function declarations

void FCD_ADC0_SampleADC();
MX_UINT8 FCD_ADC0_ReadAsByte();
MX_UINT16 FCD_ADC0_ReadAsInt();
MX_FLOAT FCD_ADC0_ReadAsVoltage();
void FCD_ADC0_ReadAsString(MX_CHAR* FCR_RETVAL, MX_UINT8 FCR_RETVAL_SIZE);
void FCD_ADC0_ADC_RAW_Configure_Channel();
MX_UINT8 FCD_ADC0_ADC_RAW_Sample_Channel_Byte();
MX_UINT16 FCD_ADC0_ADC_RAW_Sample_Channel_Int();
MX_UINT8 FCD_ADC0_ADC_RAW_Average_Channel_Byte(MX_UINT8 NumSamples, MX_UINT8 DelayUs);
MX_UINT16 FCD_ADC0_ADC_RAW_Average_Channel_Int(MX_UINT8 NumSamples, MX_UINT8 DelayUs);
void FCD_ADC0_ADC_RAW_Disable_Channel();


//PWM(0): //Defines:

/**** Macro Substitutions ****
a = Unique Reference
b = PWM Channel - 0=SW / 1-8=HW
c = PWM Alt Pin FCD_PWM0_Enable - 0=Standard / 1=Alt
d = PWM Period
e = PWM Prescaler 1
******************************/

//Period and Prescaler Defines
#ifndef MX_PWM_PERIOD
  #define MX_PWM_PERIOD				150
#else
  #if (MX_PWM_PERIOD != 150)
    #error "PWM period value must be the same in all PWM modules"
  #endif
#endif

#ifndef MX_PWM_PRESCALE1
  #define MX_PWM_PRESCALE1			1
#else
  #if (MX_PWM_PRESCALE1 != 1)
    #error "PWM prescale value must be the same in all PWM modules"
  #endif
#endif

//Definitions for PWM slot allocation
#ifndef	MX_PWM_REF1
			#define MX_PWM_REF1
			#define PWM_13_MX_PWM_UREF			1
			#define MX_PWM_CHANNEL_1		1
			#define MX_PWM_HWALT_1			0
#else
 #ifndef	MX_PWM_REF2
			#define MX_PWM_REF2
			#define PWM_13_MX_PWM_UREF			2
			#define MX_PWM_CHANNEL_2		1
			#define MX_PWM_HWALT_2			0
 #else
  #ifndef	MX_PWM_REF3
			#define MX_PWM_REF3
			#define PWM_13_MX_PWM_UREF			3
			#define MX_PWM_CHANNEL_3		1
			#define MX_PWM_HWALT_3			0
  #else
   #ifndef	MX_PWM_REF4
			#define MX_PWM_REF4
			#define PWM_13_MX_PWM_UREF			4
			#define MX_PWM_CHANNEL_4		1
			#define MX_PWM_HWALT_4			0
   #else
    #ifndef	MX_PWM_REF5
			#define MX_PWM_REF5
			#define PWM_13_MX_PWM_UREF			5
			#define MX_PWM_CHANNEL_5		1
			#define MX_PWM_HWALT_5			0
    #else
     #ifndef	MX_PWM_REF6
			#define MX_PWM_REF6
			#define PWM_13_MX_PWM_UREF			6
			#define MX_PWM_CHANNEL_6		1
			#define MX_PWM_HWALT_6			0
     #else
      #ifndef	MX_PWM_REF7
			#define MX_PWM_REF7
			#define PWM_13_MX_PWM_UREF			7
			#define MX_PWM_CHANNEL_7		1
			#define MX_PWM_HWALT_7			0
      #else
       #ifndef	MX_PWM_REF8
			#define MX_PWM_REF8
			#define PWM_13_MX_PWM_UREF			8
			#define MX_PWM_CHANNEL_8		1
			#define MX_PWM_HWALT_8			0
       #else
        #ifndef	MX_PWM_REF9
			#define MX_PWM_REF9
			#define PWM_13_MX_PWM_UREF			9
			#define MX_PWM_CHANNEL_9		1
			#define MX_PWM_HWALT_9			0
        #else
         #ifndef	MX_PWM_REF10
			#define MX_PWM_REF10
			#define PWM_13_MX_PWM_UREF			10
			#define MX_PWM_CHANNEL_10		1
			#define MX_PWM_HWALT_10			0
         #endif
        #endif
       #endif
      #endif
     #endif
    #endif
   #endif
  #endif
 #endif
#endif

#define PWM_13_PWM_Enable_Channel		CAL_APPEND(FC_CAL_PWM_Enable_Channel_, PWM_13_MX_PWM_UREF)
#define PWM_13_PWM_Disable_Channel		CAL_APPEND(FC_CAL_PWM_Disable_Channel_, PWM_13_MX_PWM_UREF)
#define PWM_13_PWM_Set_Duty_8Bit		CAL_APPEND(FC_CAL_PWM_Set_Duty_8Bit_, PWM_13_MX_PWM_UREF)
#define PWM_13_PWM_Change_Period		CAL_APPEND(FC_CAL_PWM_Change_Period_, PWM_13_MX_PWM_UREF)
#define PWM_13_PWM_Set_Duty_10Bit		CAL_APPEND(FC_CAL_PWM_Set_Duty_10Bit_, PWM_13_MX_PWM_UREF)

extern void PWM_13_PWM_Enable_Channel ();
extern void PWM_13_PWM_Disable_Channel ();
extern void PWM_13_PWM_Set_Duty_8Bit (MX_UINT8 duty);
extern void PWM_13_PWM_Change_Period (MX_UINT8 period, MX_UINT16 prescaler);
extern void PWM_13_PWM_Set_Duty_10Bit (MX_UINT16 duty);




//PWM(0): //Macro function declarations

void FCD_PWM0_Enable();
void FCD_PWM0_Disable();
void FCD_PWM0_SetDutyCycle(MX_UINT8 nDuty);
void FCD_PWM0_ChangePeriod(MX_UINT8 nPeriodVal, MX_UINT8 nPrescalerVal);
void FCD_PWM0_SetDutyCycle10bit(MX_SINT16 nDuty);



//I2C_Master(0): //Macro implementations


void FCD_I2C_Master0_MI2C_Init()

{
	
		I2CMASTER_9_I2C_Master_Init();
06F9  2341  	CALL FC_CAL_I2C_00061


}
06FA  0008  	RETURN


void FCD_I2C_Master0_MI2C_Start()

{
	
		I2CMASTER_9_I2C_Master_Start();
052D  228F  	CALL FC_CAL_I2C_00063


}
052E  0008  	RETURN


void FCD_I2C_Master0_MI2C_Restart()

{
	
		I2CMASTER_9_I2C_Master_Restart();
0525  2287  	CALL FC_CAL_I2C_00064


}
0526  0008  	RETURN


void FCD_I2C_Master0_MI2C_Stop()

{
	
		I2CMASTER_9_I2C_Master_Stop();
051D  227B  	CALL FC_CAL_I2C_00065


}
051E  0008  	RETURN


MX_UINT8 FCD_I2C_Master0_MI2C_Transmit_Byte(MX_UINT8 Data)

{
	
		return I2CMASTER_9_I2C_Master_TX_Byte(Data);
0527  087B  	MOVF FCD_I2C_Ma_00053_arg_Data, W
0528  00FC  	MOVWF FC_CAL_I2C_00066_arg_Data
0529  226C  	CALL FC_CAL_I2C_00066
052A  087D  	MOVF CompTempVarRet2254, W
052B  00FC  	MOVWF CompTempVarRet2195


}
052C  0008  	RETURN


MX_UINT8 FCD_I2C_Master0_MI2C_Receive_Byte(MX_UINT8 Last)

{
	
		return I2CMASTER_9_I2C_Master_RX_Byte(Last);
051F  087B  	MOVF FCD_I2C_Ma_00055_arg_Last, W
0520  00FC  	MOVWF FC_CAL_I2C_00067_arg_Last
0521  2257  	CALL FC_CAL_I2C_00067
0522  087D  	MOVF CompTempVarRet2255, W
0523  00FC  	MOVWF CompTempVarRet2196


}
0524  0008  	RETURN


void FCD_I2C_Master0_MI2C_Send_Byte_Transaction(MX_UINT8 Device_ID, MX_UINT8 AddrH, MX_UINT8 AddrL, MX_UINT8 Data)
{
	
		Device_ID = Device_ID << 1;					//Shift Device ID to enable write mode

		I2CMASTER_9_I2C_Master_Start();						//Start transaction
		I2CMASTER_9_I2C_Master_TX_Byte(Device_ID);			//Transmit Device Address
		I2CMASTER_9_I2C_Master_TX_Byte(AddrH);				//Transmit Internal Address
		I2CMASTER_9_I2C_Master_TX_Byte(AddrL);
		I2CMASTER_9_I2C_Master_TX_Byte(Data);				//Send Data byte
		I2CMASTER_9_I2C_Master_Stop();						//Stop Transaction

}

MX_UINT8 FCD_I2C_Master0_MI2C_Receive_Byte_Transaction(MX_UINT8 Device_ID, MX_UINT8 AddrH, MX_UINT8 AddrL)
{
	
		MX_UINT8 RetVal = 0;
		Device_ID = Device_ID << 1;					//Shift Device ID to enable write mode

		I2CMASTER_9_I2C_Master_Start();						//Start transaction
		I2CMASTER_9_I2C_Master_TX_Byte(Device_ID);			//Transmit Device Address
		I2CMASTER_9_I2C_Master_TX_Byte(AddrH);				//Transmit Internal Address
		I2CMASTER_9_I2C_Master_TX_Byte(AddrL);
		I2CMASTER_9_I2C_Master_Restart();					//Restart transaction

		Device_ID = Device_ID | 0x01;				//Change Device ID to read mode
		I2CMASTER_9_I2C_Master_TX_Byte(Device_ID);			//Transmit Device Address
		RetVal = I2CMASTER_9_I2C_Master_RX_Byte(1);			//Read data at address
		I2CMASTER_9_I2C_Master_Stop();						//Stop Transaction

		return RetVal;								//Return data

}



//ADC(0): //Macro implementations


void FCD_ADC0_SampleADC()
{
	
	    //unused

}

MX_UINT8 FCD_ADC0_ReadAsByte()

{
	
		MX_UINT8 retVal;

		//Configure & Enable ADC Channel
		FC_CAL_Enable_ADC ( ADC_11_MX_ADC_CHANNEL , ADC_11_MX_ADC_CONVSP , ADC_11_MX_ADC_VREFOP , ADC_11_MX_ADC_ACTIME );
02CB  3004  	MOVLW 0x04
02CC  1683  	BSF STATUS, RP0
02CD  1303  	BCF STATUS, RP1
02CE  00A0  	MOVWF FC_CAL_Ena_0006B_arg_Channel
02CF  3003  	MOVLW 0x03
02D0  00A1  	MOVWF FC_CAL_Ena_0006B_arg_Conv_Speed
02D1  01A2  	CLRF FC_CAL_Ena_0006B_arg_Vref
02D2  3028  	MOVLW 0x28
02D3  00A3  	MOVWF FC_CAL_Ena_0006B_arg_T_Charge
02D4  204E  	CALL FC_CAL_Ena_0006B


		retVal = FC_CAL_Sample_ADC( 0 );				//Perform Sample - Return as byte
02D5  01A0  	CLRF FC_CAL_Sam_0006C_arg_Sample_Mode
02D6  2026  	CALL FC_CAL_Sam_0006C
02D7  0823  	MOVF CompTempVarRet2266, W
02D8  1283  	BCF STATUS, RP0
02D9  00FE  	MOVWF FCD_ADC0_R_0005C_1_retVal


		FC_CAL_Disable_ADC ();
02DA  2095  	CALL FC_CAL_Dis_0006D


		return (retVal);
02DB  087E  	MOVF FCD_ADC0_R_0005C_1_retVal, W
02DC  1683  	BSF STATUS, RP0
02DD  00A0  	MOVWF CompTempVarRet2244


}
02DE  0008  	RETURN


MX_UINT16 FCD_ADC0_ReadAsInt()
{
	
		MX_UINT16 retVal;

		//Configure & Enable ADC Channel
		FC_CAL_Enable_ADC ( ADC_11_MX_ADC_CHANNEL , ADC_11_MX_ADC_CONVSP , ADC_11_MX_ADC_VREFOP , ADC_11_MX_ADC_ACTIME );

		retVal = FC_CAL_Sample_ADC( 1 );				//Perform Sample - Return as MX_UINT16

		FC_CAL_Disable_ADC ();

		return (retVal);

}

MX_FLOAT FCD_ADC0_ReadAsVoltage()
{
	
		MX_UINT16 iSample;
		MX_FLOAT fSample, fVoltage, fVperDiv;

		//Configure & Enable ADC Channel
		FC_CAL_Enable_ADC ( ADC_11_MX_ADC_CHANNEL , ADC_11_MX_ADC_CONVSP , ADC_11_MX_ADC_VREFOP , ADC_11_MX_ADC_ACTIME );

	  #ifdef MX_ADC_BITS_8
		iSample = FC_CAL_Sample_ADC( 0 );								//Perform Sample - Return as byte
	  #else
		iSample = FC_CAL_Sample_ADC( 1 );								//Perform Sample - Return as MX_UINT16
	  #endif

	  	FC_CAL_Disable_ADC ();											//Switch off ADC peripheral
		fVoltage = flt_fromi( ADC_11_MX_ADC_VREFVOL );						//Convert reference voltage count to floating point (0 - 500 x 10mV)
		fVoltage = flt_mul(fVoltage, 0.01);								//Convert reference voltage count to actual voltage (0 - 5)

	  #ifdef MX_ADC_BITS_8
		fVperDiv = flt_mul(fVoltage, 0.00390625);						//Convert actual voltage to voltage per division (VRef / 256)
	  #endif
	  #ifdef MX_ADC_BITS_10
		fVperDiv = flt_mul(fVoltage, 0.000976);							//Convert actual voltage to voltage per division (VRef / 1024)
	  #endif
	  #ifdef MX_ADC_BITS_12
		fVperDiv = flt_mul(fVoltage, 0.00024414);						//Convert actual voltage to voltage per division (VRef / 4096)
	  #endif

		fSample = flt_fromi(iSample);									//Convert to floating point variable
		fVoltage = flt_mul(fSample, fVperDiv);							//Calculate floating point voltage

		return (fVoltage);

}

void FCD_ADC0_ReadAsString(MX_CHAR* FCR_RETVAL, MX_UINT8 FCR_RETVAL_SIZE)
{
	
		MX_FLOAT fVoltage;

		fVoltage = FCD_ADC0_ReadAsVoltage();
		FCI_FLOAT_TO_STRING(fVoltage, 2, FCR_RETVAL, FCR_RETVAL_SIZE);	//Convert to String

}

void FCD_ADC0_ADC_RAW_Configure_Channel()
{
	
		//Configure & Enable ADC Channel
		FC_CAL_Enable_ADC ( ADC_11_MX_ADC_CHANNEL , ADC_11_MX_ADC_CONVSP , ADC_11_MX_ADC_VREFOP , ADC_11_MX_ADC_ACTIME );

}

MX_UINT8 FCD_ADC0_ADC_RAW_Sample_Channel_Byte()
{
	
		return FC_CAL_Sample_ADC( 0 );									//Perform Sample - Return as byte

}

MX_UINT16 FCD_ADC0_ADC_RAW_Sample_Channel_Int()
{
	
		return FC_CAL_Sample_ADC( 1 );									//Perform Sample - Return as MX_UINT16

}

MX_UINT8 FCD_ADC0_ADC_RAW_Average_Channel_Byte(MX_UINT8 NumSamples, MX_UINT8 DelayUs)
{
	
		MX_UINT32 average = 0;
		MX_UINT8 count;

		for (count=0; count<NumSamples; count++)
		{
			average = average + FC_CAL_Sample_ADC( 0 );					//Perform Sample - Return as byte - add to average

			if (DelayUs)
				delay_us(DelayUs);										//If delay is not 0 then pause between samples
		}
		average = average / count;

		return (average & 0xFF);										//Return average as byte

}

MX_UINT16 FCD_ADC0_ADC_RAW_Average_Channel_Int(MX_UINT8 NumSamples, MX_UINT8 DelayUs)
{
	
		MX_UINT32 average = 0;
		MX_UINT8 count;

		for (count=0; count<NumSamples; count++)
		{
			average = average + FC_CAL_Sample_ADC( 1 );					//Perform Sample - Return as MX_UINT16 - add to average

			if (DelayUs)
				delay_us(DelayUs);										//If delay is not 0 then pause between samples
		}
		average = average / count;

		return (average & 0x1FFF);										//Return average as MX_SINT16

}

void FCD_ADC0_ADC_RAW_Disable_Channel()
{
	
		FC_CAL_Disable_ADC ();											//Disable ADC Channel

}



//PWM(0): //Macro implementations


void FCD_PWM0_Enable()

{
	
		PWM_13_PWM_Change_Period (MX_PWM_PERIOD, MX_PWM_PRESCALE1);
06EC  3096  	MOVLW 0x96
06ED  1283  	BCF STATUS, RP0
06EE  1303  	BCF STATUS, RP1
06EF  00FE  	MOVWF FC_CAL_PWM_0007C_arg_period
06F0  3001  	MOVLW 0x01
06F1  1683  	BSF STATUS, RP0
06F2  00A0  	MOVWF FC_CAL_PWM_0007C_arg_prescaler
06F3  01A1  	CLRF FC_CAL_PWM_0007C_arg_prescaler+D'1'
06F4  230C  	CALL FC_CAL_PWM_0007C

		PWM_13_PWM_Enable_Channel ();
06F5  2339  	CALL FC_CAL_PWM_00079


}
06F6  0008  	RETURN


void FCD_PWM0_Disable()

{
	
		PWM_13_PWM_Disable_Channel();
06F7  2333  	CALL FC_CAL_PWM_0007A


}
06F8  0008  	RETURN


void FCD_PWM0_SetDutyCycle(MX_UINT8 nDuty)

{
	
		PWM_13_PWM_Set_Duty_8Bit(nDuty);
06E7  087E  	MOVF FCD_PWM0_S_00080_arg_nDuty, W
06E8  1683  	BSF STATUS, RP0
06E9  00A0  	MOVWF FC_CAL_PWM_0007B_arg_duty
06EA  232F  	CALL FC_CAL_PWM_0007B


}
06EB  0008  	RETURN


void FCD_PWM0_ChangePeriod(MX_UINT8 nPeriodVal, MX_UINT8 nPrescalerVal)
{
	
		PWM_13_PWM_Change_Period (nPeriodVal, nPrescalerVal);

}

void FCD_PWM0_SetDutyCycle10bit(MX_SINT16 nDuty)
{
	
		PWM_13_PWM_Set_Duty_10Bit(nDuty);

}

#include "C:\Program Files (x86)\Flowcode\v5\CAL\includes.c"

//Macro implementations


void FCM_i2c_comm()

{

	//Call Component Macro
	//Call Component Macro: MI2C_Start()
	FCD_I2C_Master0_MI2C_Start();
052F  252D  	CALL FCD_I2C_Ma_00052


	//Calculation
	//Calculation:
	//  rt_byte = 0
	FCV_RT_BYTE = 0;
0530  1283  	BCF STATUS, RP0
0531  01E6  	CLRF gbl_FCV_RT_BYTE


	//Call Component Macro
	//Call Component Macro: rt_byte=MI2C_Transmit_Byte(0xB4)
	FCV_RT_BYTE = FCD_I2C_Master0_MI2C_Transmit_Byte(0xB4);
0532  30B4  	MOVLW 0xB4
0533  00FB  	MOVWF FCD_I2C_Ma_00053_arg_Data
0534  2527  	CALL FCD_I2C_Ma_00053
0535  087C  	MOVF CompTempVarRet2195, W
0536  00E6  	MOVWF gbl_FCV_RT_BYTE


	//Calculation
	//Calculation:
	//  rt_byte = 0
	FCV_RT_BYTE = 0;
0537  01E6  	CLRF gbl_FCV_RT_BYTE


	//Call Component Macro
	//Call Component Macro: rt_byte=MI2C_Transmit_Byte(0x07)
	FCV_RT_BYTE = FCD_I2C_Master0_MI2C_Transmit_Byte(0x07);
0538  3007  	MOVLW 0x07
0539  00FB  	MOVWF FCD_I2C_Ma_00053_arg_Data
053A  2527  	CALL FCD_I2C_Ma_00053
053B  087C  	MOVF CompTempVarRet2195, W
053C  00E6  	MOVWF gbl_FCV_RT_BYTE


	//Comment:
	//end of RD/WR cmd

	//Call Component Macro
	//Call Component Macro: MI2C_Restart()
	FCD_I2C_Master0_MI2C_Restart();
053D  2525  	CALL FCD_I2C_Ma_00054


	//Calculation
	//Calculation:
	//  rt_byte = 0
	FCV_RT_BYTE = 0;
053E  1283  	BCF STATUS, RP0
053F  01E6  	CLRF gbl_FCV_RT_BYTE


	//Call Component Macro
	//Call Component Macro: rt_byte=MI2C_Transmit_Byte(0xB4)
	FCV_RT_BYTE = FCD_I2C_Master0_MI2C_Transmit_Byte(0xB4);
0540  30B4  	MOVLW 0xB4
0541  00FB  	MOVWF FCD_I2C_Ma_00053_arg_Data
0542  2527  	CALL FCD_I2C_Ma_00053
0543  087C  	MOVF CompTempVarRet2195, W
0544  00E6  	MOVWF gbl_FCV_RT_BYTE


	//Call Component Macro
	//Call Component Macro: i2c_rx=MI2C_Receive_Byte(rt_byte)
	FCV_I2C_RX = FCD_I2C_Master0_MI2C_Receive_Byte(FCV_RT_BYTE);
0545  0866  	MOVF gbl_FCV_RT_BYTE, W
0546  00FB  	MOVWF FCD_I2C_Ma_00055_arg_Last
0547  251F  	CALL FCD_I2C_Ma_00055
0548  087C  	MOVF CompTempVarRet2196, W
0549  00EB  	MOVWF gbl_FCV_I2C_RX


	//Calculation
	//Calculation:
	//  data0 = i2c_rx
	FCV_DATA0 = FCV_I2C_RX;
054A  086B  	MOVF gbl_FCV_I2C_RX, W
054B  00DA  	MOVWF gbl_FCV_DATA0


	//Call Component Macro
	//Call Component Macro: i2c_rx=MI2C_Receive_Byte(rt_byte)
	FCV_I2C_RX = FCD_I2C_Master0_MI2C_Receive_Byte(FCV_RT_BYTE);
054C  0866  	MOVF gbl_FCV_RT_BYTE, W
054D  00FB  	MOVWF FCD_I2C_Ma_00055_arg_Last
054E  251F  	CALL FCD_I2C_Ma_00055
054F  087C  	MOVF CompTempVarRet2196, W
0550  00EB  	MOVWF gbl_FCV_I2C_RX


	//Calculation
	//Calculation:
	//  data1 = i2c_rx
	FCV_DATA1 = FCV_I2C_RX;
0551  086B  	MOVF gbl_FCV_I2C_RX, W
0552  00DC  	MOVWF gbl_FCV_DATA1


	//Call Component Macro
	//Call Component Macro: i2c_rx=MI2C_Receive_Byte(rt_byte)
	FCV_I2C_RX = FCD_I2C_Master0_MI2C_Receive_Byte(FCV_RT_BYTE);
0553  0866  	MOVF gbl_FCV_RT_BYTE, W
0554  00FB  	MOVWF FCD_I2C_Ma_00055_arg_Last
0555  251F  	CALL FCD_I2C_Ma_00055
0556  087C  	MOVF CompTempVarRet2196, W
0557  00EB  	MOVWF gbl_FCV_I2C_RX


	//Calculation
	//Calculation:
	//  data2 = i2c_rx
	FCV_DATA2 = FCV_I2C_RX;
0558  086B  	MOVF gbl_FCV_I2C_RX, W
0559  00DE  	MOVWF gbl_FCV_DATA2


	//Call Component Macro
	//Call Component Macro: MI2C_Stop()
	FCD_I2C_Master0_MI2C_Stop();
055A  251D  	CALL FCD_I2C_Ma_00056


}
055B  0008  	RETURN



void FCM_intro()
{

	//Call Macro
	//Call Macro: scan1()
	FCM_scan1();

	//Call Macro
	//Call Macro: ikotled()
	FCM_ikotled();

	//Call Macro
	//Call Macro: scan2()
	FCM_scan2();

	//Call Macro
	//Call Macro: ikotled()
	FCM_ikotled();

	//Call Macro
	//Call Macro: scan3()
	FCM_scan3();

	//Call Macro
	//Call Macro: ikotled()
	FCM_ikotled();

	//Call Macro
	//Call Macro: scan4()
	FCM_scan4();

	//Call Macro
	//Call Macro: ikotled()
	FCM_ikotled();

	//Delay
	//Delay: 500 ms
	delay_ms(255);
	delay_ms(245);

}


void FCM_scan1()

{

	//Output
	//Output: 1 -> A0
	trisa = trisa & 0xFE;
0193  30FE  	MOVLW 0xFE
0194  1683  	BSF STATUS, RP0
0195  1303  	BCF STATUS, RP1
0196  0505  	ANDWF gbl_trisa, W
0197  0085  	MOVWF gbl_trisa

	if ((1))
		porta = (porta & 0xFE) | 0x01;
0198  30FE  	MOVLW 0xFE
0199  1283  	BCF STATUS, RP0
019A  0505  	ANDWF gbl_porta, W
019B  00FE  	MOVWF CompTempVar2197
019C  3001  	MOVLW 0x01
019D  047E  	IORWF CompTempVar2197, W
019E  0085  	MOVWF gbl_porta

	else
		porta = porta & 0xFE;

	//Output
	//Output: 0 -> A1
	trisa = trisa & 0xFD;
019F  30FD  	MOVLW 0xFD
01A0  1683  	BSF STATUS, RP0
01A1  0505  	ANDWF gbl_trisa, W
01A2  0085  	MOVWF gbl_trisa

	if ((0))
		porta = (porta & 0xFD) | 0x02;
	else
		porta = porta & 0xFD;
01A3  30FD  	MOVLW 0xFD
01A4  1283  	BCF STATUS, RP0
01A5  0505  	ANDWF gbl_porta, W
01A6  0085  	MOVWF gbl_porta


	//Output
	//Output: 0 -> A2
	trisa = trisa & 0xFB;
01A7  30FB  	MOVLW 0xFB
01A8  1683  	BSF STATUS, RP0
01A9  0505  	ANDWF gbl_trisa, W
01AA  0085  	MOVWF gbl_trisa

	if ((0))
		porta = (porta & 0xFB) | 0x04;
	else
		porta = porta & 0xFB;
01AB  30FB  	MOVLW 0xFB
01AC  1283  	BCF STATUS, RP0
01AD  0505  	ANDWF gbl_porta, W
01AE  0085  	MOVWF gbl_porta


	//Output
	//Output: 0 -> A3
	trisa = trisa & 0xF7;
01AF  30F7  	MOVLW 0xF7
01B0  1683  	BSF STATUS, RP0
01B1  0505  	ANDWF gbl_trisa, W
01B2  0085  	MOVWF gbl_trisa

	if ((0))
		porta = (porta & 0xF7) | 0x08;
	else
		porta = porta & 0xF7;
01B3  30F7  	MOVLW 0xF7
01B4  1283  	BCF STATUS, RP0
01B5  0505  	ANDWF gbl_porta, W
01B6  0085  	MOVWF gbl_porta


}
01B7  0008  	RETURN



void FCM_scan2()

{

	//Output
	//Output: 0 -> A0
	trisa = trisa & 0xFE;
016E  30FE  	MOVLW 0xFE
016F  1683  	BSF STATUS, RP0
0170  1303  	BCF STATUS, RP1
0171  0505  	ANDWF gbl_trisa, W
0172  0085  	MOVWF gbl_trisa

	if ((0))
		porta = (porta & 0xFE) | 0x01;
	else
		porta = porta & 0xFE;
0173  30FE  	MOVLW 0xFE
0174  1283  	BCF STATUS, RP0
0175  0505  	ANDWF gbl_porta, W
0176  0085  	MOVWF gbl_porta


	//Output
	//Output: 1 -> A1
	trisa = trisa & 0xFD;
0177  30FD  	MOVLW 0xFD
0178  1683  	BSF STATUS, RP0
0179  0505  	ANDWF gbl_trisa, W
017A  0085  	MOVWF gbl_trisa

	if ((1))
		porta = (porta & 0xFD) | 0x02;
017B  30FD  	MOVLW 0xFD
017C  1283  	BCF STATUS, RP0
017D  0505  	ANDWF gbl_porta, W
017E  00FE  	MOVWF CompTempVar2199
017F  3002  	MOVLW 0x02
0180  047E  	IORWF CompTempVar2199, W
0181  0085  	MOVWF gbl_porta

	else
		porta = porta & 0xFD;

	//Output
	//Output: 0 -> A2
	trisa = trisa & 0xFB;
0182  30FB  	MOVLW 0xFB
0183  1683  	BSF STATUS, RP0
0184  0505  	ANDWF gbl_trisa, W
0185  0085  	MOVWF gbl_trisa

	if ((0))
		porta = (porta & 0xFB) | 0x04;
	else
		porta = porta & 0xFB;
0186  30FB  	MOVLW 0xFB
0187  1283  	BCF STATUS, RP0
0188  0505  	ANDWF gbl_porta, W
0189  0085  	MOVWF gbl_porta


	//Output
	//Output: 0 -> A3
	trisa = trisa & 0xF7;
018A  30F7  	MOVLW 0xF7
018B  1683  	BSF STATUS, RP0
018C  0505  	ANDWF gbl_trisa, W
018D  0085  	MOVWF gbl_trisa

	if ((0))
		porta = (porta & 0xF7) | 0x08;
	else
		porta = porta & 0xF7;
018E  30F7  	MOVLW 0xF7
018F  1283  	BCF STATUS, RP0
0190  0505  	ANDWF gbl_porta, W
0191  0085  	MOVWF gbl_porta


}
0192  0008  	RETURN



void FCM_scan3()

{

	//Output
	//Output: 0 -> A0
	trisa = trisa & 0xFE;
0149  30FE  	MOVLW 0xFE
014A  1683  	BSF STATUS, RP0
014B  1303  	BCF STATUS, RP1
014C  0505  	ANDWF gbl_trisa, W
014D  0085  	MOVWF gbl_trisa

	if ((0))
		porta = (porta & 0xFE) | 0x01;
	else
		porta = porta & 0xFE;
014E  30FE  	MOVLW 0xFE
014F  1283  	BCF STATUS, RP0
0150  0505  	ANDWF gbl_porta, W
0151  0085  	MOVWF gbl_porta


	//Output
	//Output: 0 -> A1
	trisa = trisa & 0xFD;
0152  30FD  	MOVLW 0xFD
0153  1683  	BSF STATUS, RP0
0154  0505  	ANDWF gbl_trisa, W
0155  0085  	MOVWF gbl_trisa

	if ((0))
		porta = (porta & 0xFD) | 0x02;
	else
		porta = porta & 0xFD;
0156  30FD  	MOVLW 0xFD
0157  1283  	BCF STATUS, RP0
0158  0505  	ANDWF gbl_porta, W
0159  0085  	MOVWF gbl_porta


	//Output
	//Output: 1 -> A2
	trisa = trisa & 0xFB;
015A  30FB  	MOVLW 0xFB
015B  1683  	BSF STATUS, RP0
015C  0505  	ANDWF gbl_trisa, W
015D  0085  	MOVWF gbl_trisa

	if ((1))
		porta = (porta & 0xFB) | 0x04;
015E  30FB  	MOVLW 0xFB
015F  1283  	BCF STATUS, RP0
0160  0505  	ANDWF gbl_porta, W
0161  00FE  	MOVWF CompTempVar2200
0162  3004  	MOVLW 0x04
0163  047E  	IORWF CompTempVar2200, W
0164  0085  	MOVWF gbl_porta

	else
		porta = porta & 0xFB;

	//Output
	//Output: 0 -> A3
	trisa = trisa & 0xF7;
0165  30F7  	MOVLW 0xF7
0166  1683  	BSF STATUS, RP0
0167  0505  	ANDWF gbl_trisa, W
0168  0085  	MOVWF gbl_trisa

	if ((0))
		porta = (porta & 0xF7) | 0x08;
	else
		porta = porta & 0xF7;
0169  30F7  	MOVLW 0xF7
016A  1283  	BCF STATUS, RP0
016B  0505  	ANDWF gbl_porta, W
016C  0085  	MOVWF gbl_porta


}
016D  0008  	RETURN



void FCM_scan4()

{

	//Output
	//Output: 0 -> A0
	trisa = trisa & 0xFE;
0124  30FE  	MOVLW 0xFE
0125  1683  	BSF STATUS, RP0
0126  1303  	BCF STATUS, RP1
0127  0505  	ANDWF gbl_trisa, W
0128  0085  	MOVWF gbl_trisa

	if ((0))
		porta = (porta & 0xFE) | 0x01;
	else
		porta = porta & 0xFE;
0129  30FE  	MOVLW 0xFE
012A  1283  	BCF STATUS, RP0
012B  0505  	ANDWF gbl_porta, W
012C  0085  	MOVWF gbl_porta


	//Output
	//Output: 0 -> A1
	trisa = trisa & 0xFD;
012D  30FD  	MOVLW 0xFD
012E  1683  	BSF STATUS, RP0
012F  0505  	ANDWF gbl_trisa, W
0130  0085  	MOVWF gbl_trisa

	if ((0))
		porta = (porta & 0xFD) | 0x02;
	else
		porta = porta & 0xFD;
0131  30FD  	MOVLW 0xFD
0132  1283  	BCF STATUS, RP0
0133  0505  	ANDWF gbl_porta, W
0134  0085  	MOVWF gbl_porta


	//Output
	//Output: 0 -> A2
	trisa = trisa & 0xFB;
0135  30FB  	MOVLW 0xFB
0136  1683  	BSF STATUS, RP0
0137  0505  	ANDWF gbl_trisa, W
0138  0085  	MOVWF gbl_trisa

	if ((0))
		porta = (porta & 0xFB) | 0x04;
	else
		porta = porta & 0xFB;
0139  30FB  	MOVLW 0xFB
013A  1283  	BCF STATUS, RP0
013B  0505  	ANDWF gbl_porta, W
013C  0085  	MOVWF gbl_porta


	//Output
	//Output: 1 -> A3
	trisa = trisa & 0xF7;
013D  30F7  	MOVLW 0xF7
013E  1683  	BSF STATUS, RP0
013F  0505  	ANDWF gbl_trisa, W
0140  0085  	MOVWF gbl_trisa

	if ((1))
		porta = (porta & 0xF7) | 0x08;
0141  30F7  	MOVLW 0xF7
0142  1283  	BCF STATUS, RP0
0143  0505  	ANDWF gbl_porta, W
0144  00FE  	MOVWF CompTempVar2201
0145  3008  	MOVLW 0x08
0146  047E  	IORWF CompTempVar2201, W
0147  0085  	MOVWF gbl_porta

	else
		porta = porta & 0xF7;

}
0148  0008  	RETURN



void FCM_ikotled()
{

	//Output
	//Output: 0 -> PORTB
	trisb = 0x00;
	portb = (0);

	//Calculation
	//Calculation:
	//  d_byte = 1
	FCV_D_BYTE = 1;

	//Delay
	//Delay: 200 ms
	delay_ms(200);

	//Loop
	//Loop: Loop 8 times
	for (FCLV_LOOP6=0; FCLV_LOOP6<8; FCLV_LOOP6++)
	{

		//Output
		//Output: d_byte -> PORTB
		trisb = 0x00;
		portb = (FCV_D_BYTE);

		//Calculation
		//Calculation:
		//  d_byte = d_byte * 2
		FCV_D_BYTE = FCV_D_BYTE * 2;

		//Delay
		//Delay: 100 ms
		delay_ms(100);


	}

}


void FCM_seg_pattern()

{

	//Switch
	//Switch: digit?
	switch (FCV_DIGIT)

	{
		case 1:
00A4  1283  	BCF STATUS, RP0
00A5  1303  	BCF STATUS, RP1
00A6  0868  	MOVF gbl_FCV_DIGIT, W
00A7  3A01  	XORLW 0x01
00A8  1903  	BTFSC STATUS,Z
00A9  28C6  	GOTO	label9
00C6        label9

		{
			//Output
			//Output: 0b10010000 -> PORTB
			trisb = 0x00;
00C6  1683  	BSF STATUS, RP0
00C7  0186  	CLRF gbl_trisb

			portb = (144);
00C8  3090  	MOVLW 0x90
00C9  1283  	BCF STATUS, RP0
00CA  0086  	MOVWF gbl_portb


			break;

		}
		case 2:
00AA  3A03  	XORLW 0x03
00AB  1903  	BTFSC STATUS,Z
00AC  28CC  	GOTO	label10
00CC        label10

		{
			//Output
			//Output: 0b01111010 -> PORTB
			trisb = 0x00;
00CC  1683  	BSF STATUS, RP0
00CD  0186  	CLRF gbl_trisb

			portb = (122);
00CE  307A  	MOVLW 0x7A
00CF  1283  	BCF STATUS, RP0
00D0  0086  	MOVWF gbl_portb


			break;

		}
		case 3:
00AD  3A01  	XORLW 0x01
00AE  1903  	BTFSC STATUS,Z
00AF  28D2  	GOTO	label11
00D2        label11

		{
			//Output
			//Output: 0b11011010 -> PORTB
			trisb = 0x00;
00D2  1683  	BSF STATUS, RP0
00D3  0186  	CLRF gbl_trisb

			portb = (218);
00D4  30DA  	MOVLW 0xDA
00D5  1283  	BCF STATUS, RP0
00D6  0086  	MOVWF gbl_portb


			break;

		}
		case 4:
00B0  3A07  	XORLW 0x07
00B1  1903  	BTFSC STATUS,Z
00B2  28D8  	GOTO	label12
00D8        label12

		{
			//Output
			//Output: 0b010010110 -> PORTB
			trisb = 0x00;
00D8  1683  	BSF STATUS, RP0
00D9  0186  	CLRF gbl_trisb

			portb = (150);
00DA  3096  	MOVLW 0x96
00DB  1283  	BCF STATUS, RP0
00DC  0086  	MOVWF gbl_portb


			break;

		}
		case 5:
00B3  3A01  	XORLW 0x01
00B4  1903  	BTFSC STATUS,Z
00B5  28DE  	GOTO	label13
00DE        label13

		{
			//Output
			//Output: 0b11001110 -> PORTB
			trisb = 0x00;
00DE  1683  	BSF STATUS, RP0
00DF  0186  	CLRF gbl_trisb

			portb = (206);
00E0  30CE  	MOVLW 0xCE
00E1  1283  	BCF STATUS, RP0
00E2  0086  	MOVWF gbl_portb


			break;

		}
		case 6:
00B6  3A03  	XORLW 0x03
00B7  1903  	BTFSC STATUS,Z
00B8  28E4  	GOTO	label14
00E4        label14

		{
			//Output
			//Output: 0b11101110 -> PORTB
			trisb = 0x00;
00E4  1683  	BSF STATUS, RP0
00E5  0186  	CLRF gbl_trisb

			portb = (238);
00E6  30EE  	MOVLW 0xEE
00E7  1283  	BCF STATUS, RP0
00E8  0086  	MOVWF gbl_portb


			break;

		}
		case 7:
00B9  3A01  	XORLW 0x01
00BA  1903  	BTFSC STATUS,Z
00BB  28EA  	GOTO	label15
00EA        label15

		{
			//Output
			//Output: 0b10011000 -> PORTB
			trisb = 0x00;
00EA  1683  	BSF STATUS, RP0
00EB  0186  	CLRF gbl_trisb

			portb = (152);
00EC  3098  	MOVLW 0x98
00ED  1283  	BCF STATUS, RP0
00EE  0086  	MOVWF gbl_portb


			break;

		}
		case 8:
00BC  3A0F  	XORLW 0x0F
00BD  1903  	BTFSC STATUS,Z
00BE  28F0  	GOTO	label16
00F0        label16

		{
			//Output
			//Output: 0b11111110 -> PORTB
			trisb = 0x00;
00F0  1683  	BSF STATUS, RP0
00F1  0186  	CLRF gbl_trisb

			portb = (254);
00F2  30FE  	MOVLW 0xFE
00F3  1283  	BCF STATUS, RP0
00F4  0086  	MOVWF gbl_portb


			break;

		}
		case 9:
00BF  3A01  	XORLW 0x01
00C0  1903  	BTFSC STATUS,Z
00C1  28F6  	GOTO	label17
00F6        label17

		{
			//Output
			//Output: 0b11011110 -> PORTB
			trisb = 0x00;
00F6  1683  	BSF STATUS, RP0
00F7  0186  	CLRF gbl_trisb

			portb = (222);
00F8  30DE  	MOVLW 0xDE
00F9  1283  	BCF STATUS, RP0
00FA  0086  	MOVWF gbl_portb


			break;

		}
		case 0:
00C2  3A09  	XORLW 0x09
00C3  1903  	BTFSC STATUS,Z
00C4  28FC  	GOTO	label18
00FC        label18

		{
			//Connection Point
			//Connection Point: [A]: A
FCC_seg_pattern_A:

;

			//Output
			//Output: 0b11111100 -> PORTB
			trisb = 0x00;
00FC  1683  	BSF STATUS, RP0
00FD  0186  	CLRF gbl_trisb

			portb = (252);
00FE  30FC  	MOVLW 0xFC
00FF  1283  	BCF STATUS, RP0
0100  0086  	MOVWF gbl_portb


			break;

		}
		default:
00C5  28FC  	GOTO	label18

		{
			//Goto Connection Point
			//Goto Connection Point: [A]: A
			goto FCC_seg_pattern_A;


		}
	}

}
00CB  0008  	RETURN
00D1  0008  	RETURN
00D7  0008  	RETURN
00DD  0008  	RETURN
00E3  0008  	RETURN
00E9  0008  	RETURN
00EF  0008  	RETURN
00F5  0008  	RETURN
00FB  0008  	RETURN
0101  0008  	RETURN



void FCM_display_temp()

{

	//Output
	//Output: 0 -> PORTB
	trisb = 0x00;
0596  1683  	BSF STATUS, RP0
0597  1303  	BCF STATUS, RP1
0598  0186  	CLRF gbl_trisb

	portb = (0);
0599  1283  	BCF STATUS, RP0
059A  0186  	CLRF gbl_portb


	//Call Macro
	//Call Macro: scan_off()
	FCM_scan_off();
059B  2102  	CALL FCM_scan_o_0005A


	//Call Macro
	//Call Macro: scan1()
	FCM_scan1();
059C  2193  	CALL FCM_scan1_00000


	//Calculation
	//Calculation:
	//  digit = temp_tens
	FCV_DIGIT = FCV_TEMP_TENS;
059D  0855  	MOVF gbl_FCV_TEMP_TENS, W
059E  00E8  	MOVWF gbl_FCV_DIGIT


	//Call Macro
	//Call Macro: seg_pattern()
	FCM_seg_pattern();
059F  20A4  	CALL FCM_seg_pa_00058


	//Delay
	//Delay: 4 ms
	delay_ms(4);
05A0  3004  	MOVLW 0x04
05A1  00FE  	MOVWF delay_ms_00000_arg_del
05A2  201A  	CALL delay_ms_00000


	//Output
	//Output: 0 -> PORTB
	trisb = 0x00;
05A3  1683  	BSF STATUS, RP0
05A4  0186  	CLRF gbl_trisb

	portb = (0);
05A5  1283  	BCF STATUS, RP0
05A6  0186  	CLRF gbl_portb


	//Call Macro
	//Call Macro: scan_off()
	FCM_scan_off();
05A7  2102  	CALL FCM_scan_o_0005A


	//Call Macro
	//Call Macro: scan2()
	FCM_scan2();
05A8  216E  	CALL FCM_scan2_00000


	//Calculation
	//Calculation:
	//  digit = temp_ones
	FCV_DIGIT = FCV_TEMP_ONES;
05A9  0864  	MOVF gbl_FCV_TEMP_ONES, W
05AA  00E8  	MOVWF gbl_FCV_DIGIT


	//Call Macro
	//Call Macro: seg_pattern()
	FCM_seg_pattern();
05AB  20A4  	CALL FCM_seg_pa_00058


	//Delay
	//Delay: 4 ms
	delay_ms(4);
05AC  3004  	MOVLW 0x04
05AD  00FE  	MOVWF delay_ms_00000_arg_del
05AE  201A  	CALL delay_ms_00000


	//Output
	//Output: 0 -> PORTB
	trisb = 0x00;
05AF  1683  	BSF STATUS, RP0
05B0  0186  	CLRF gbl_trisb

	portb = (0);
05B1  1283  	BCF STATUS, RP0
05B2  0186  	CLRF gbl_portb


	//Call Macro
	//Call Macro: scan_off()
	FCM_scan_off();
05B3  2102  	CALL FCM_scan_o_0005A


	//Call Macro
	//Call Macro: scan3()
	FCM_scan3();
05B4  2149  	CALL FCM_scan3_00000


	//Calculation
	//Calculation:
	//  digit = temp_dec
	FCV_DIGIT = FCV_TEMP_DEC;
05B5  0860  	MOVF gbl_FCV_TEMP_DEC, W
05B6  00E8  	MOVWF gbl_FCV_DIGIT


	//Call Macro
	//Call Macro: seg_pattern()
	FCM_seg_pattern();
05B7  20A4  	CALL FCM_seg_pa_00058


	//Delay
	//Delay: 4 ms
	delay_ms(4);
05B8  3004  	MOVLW 0x04
05B9  00FE  	MOVWF delay_ms_00000_arg_del
05BA  201A  	CALL delay_ms_00000


	//Output
	//Output: 0 -> PORTB
	trisb = 0x00;
05BB  1683  	BSF STATUS, RP0
05BC  0186  	CLRF gbl_trisb

	portb = (0);
05BD  1283  	BCF STATUS, RP0
05BE  0186  	CLRF gbl_portb


	//Call Macro
	//Call Macro: scan_off()
	FCM_scan_off();
05BF  2102  	CALL FCM_scan_o_0005A


	//Call Macro
	//Call Macro: scan4()
	FCM_scan4();
05C0  2124  	CALL FCM_scan4_00000


	//Output
	//Output: 0b00001111 -> PORTB
	trisb = 0x00;
05C1  1683  	BSF STATUS, RP0
05C2  0186  	CLRF gbl_trisb

	portb = (15);
05C3  300F  	MOVLW 0x0F
05C4  1283  	BCF STATUS, RP0
05C5  0086  	MOVWF gbl_portb


	//Delay
	//Delay: 4 ms
	delay_ms(4);
05C6  3004  	MOVLW 0x04
05C7  00FE  	MOVWF delay_ms_00000_arg_del
05C8  201A  	CALL delay_ms_00000


}
05C9  0008  	RETURN



void FCM_scan_off()

{

	//Output
	//Output: 0 -> A0
	trisa = trisa & 0xFE;
0102  30FE  	MOVLW 0xFE
0103  1683  	BSF STATUS, RP0
0104  1303  	BCF STATUS, RP1
0105  0505  	ANDWF gbl_trisa, W
0106  0085  	MOVWF gbl_trisa

	if ((0))
		porta = (porta & 0xFE) | 0x01;
	else
		porta = porta & 0xFE;
0107  30FE  	MOVLW 0xFE
0108  1283  	BCF STATUS, RP0
0109  0505  	ANDWF gbl_porta, W
010A  0085  	MOVWF gbl_porta


	//Output
	//Output: 0 -> A1
	trisa = trisa & 0xFD;
010B  30FD  	MOVLW 0xFD
010C  1683  	BSF STATUS, RP0
010D  0505  	ANDWF gbl_trisa, W
010E  0085  	MOVWF gbl_trisa

	if ((0))
		porta = (porta & 0xFD) | 0x02;
	else
		porta = porta & 0xFD;
010F  30FD  	MOVLW 0xFD
0110  1283  	BCF STATUS, RP0
0111  0505  	ANDWF gbl_porta, W
0112  0085  	MOVWF gbl_porta


	//Output
	//Output: 0 -> A2
	trisa = trisa & 0xFB;
0113  30FB  	MOVLW 0xFB
0114  1683  	BSF STATUS, RP0
0115  0505  	ANDWF gbl_trisa, W
0116  0085  	MOVWF gbl_trisa

	if ((0))
		porta = (porta & 0xFB) | 0x04;
	else
		porta = porta & 0xFB;
0117  30FB  	MOVLW 0xFB
0118  1283  	BCF STATUS, RP0
0119  0505  	ANDWF gbl_porta, W
011A  0085  	MOVWF gbl_porta


	//Output
	//Output: 0 -> A3
	trisa = trisa & 0xF7;
011B  30F7  	MOVLW 0xF7
011C  1683  	BSF STATUS, RP0
011D  0505  	ANDWF gbl_trisa, W
011E  0085  	MOVWF gbl_trisa

	if ((0))
		porta = (porta & 0xF7) | 0x08;
	else
		porta = porta & 0xF7;
011F  30F7  	MOVLW 0xF7
0120  1283  	BCF STATUS, RP0
0121  0505  	ANDWF gbl_porta, W
0122  0085  	MOVWF gbl_porta


}
0123  0008  	RETURN



void FCM_calc()

{

	//Calculation
	//Calculation:
	//  lsb = data0
	//  msb = data1
	FCV_LSB = FCV_DATA0;
040D  1283  	BCF STATUS, RP0
040E  1303  	BCF STATUS, RP1
040F  085A  	MOVF gbl_FCV_DATA0, W
0410  00E5  	MOVWF gbl_FCV_LSB

	FCV_MSB = FCV_DATA1;
0411  085C  	MOVF gbl_FCV_DATA1, W
0412  00E7  	MOVWF gbl_FCV_MSB


	//Calculation
	//Calculation:
	//  raw = msb
	FCV_RAW = FCV_MSB;
0413  0867  	MOVF gbl_FCV_MSB, W
0414  00B4  	MOVWF gbl_FCV_RAW
0415  01B5  	CLRF gbl_FCV_RAW+D'1'
0416  01B6  	CLRF gbl_FCV_RAW+D'2'
0417  01B7  	CLRF gbl_FCV_RAW+D'3'


	//Loop
	//Loop: Loop 8 times
	for (FCLV_LOOP7=0; FCLV_LOOP7<8; FCLV_LOOP7++)
0418  01F8  	CLRF gbl_FCLV_LOOP7
0419        label57
0419  3008  	MOVLW 0x08
041A  0278  	SUBWF gbl_FCLV_LOOP7, W
041B  1803  	BTFSC STATUS,C
041C  2C28  	GOTO	label58
0426  0AF8  	INCF gbl_FCLV_LOOP7, F
0427  2C19  	GOTO	label57
0428        label58

	{

		//Calculation
		//Calculation:
		//  raw = raw << 1
		FCV_RAW = FCV_RAW << 1;
041D  08B4  	MOVF gbl_FCV_RAW, F
041E  08B5  	MOVF gbl_FCV_RAW+D'1', F
041F  08B6  	MOVF gbl_FCV_RAW+D'2', F
0420  08B7  	MOVF gbl_FCV_RAW+D'3', F
0421  1003  	BCF STATUS,C
0422  0DB4  	RLF gbl_FCV_RAW, F
0423  0DB5  	RLF gbl_FCV_RAW+D'1', F
0424  0DB6  	RLF gbl_FCV_RAW+D'2', F
0425  0DB7  	RLF gbl_FCV_RAW+D'3', F



	}

	//Calculation
	//Calculation:
	//  raw = raw + lsb
	FCV_RAW = FCV_RAW + FCV_LSB;
0428  0865  	MOVF gbl_FCV_LSB, W
0429  00FD  	MOVWF CompTempVar2208
042A  01FE  	CLRF CompTempVar2209
042B  1683  	BSF STATUS, RP0
042C  01A0  	CLRF CompTempVar2210
042D  01A1  	CLRF CompTempVar2211
042E  1283  	BCF STATUS, RP0
042F  0834  	MOVF gbl_FCV_RAW, W
0430  07FD  	ADDWF CompTempVar2208, F
0431  0835  	MOVF gbl_FCV_RAW+D'1', W
0432  1803  	BTFSC STATUS,C
0433  0F35  	INCFSZ gbl_FCV_RAW+D'1', W
0434  07FE  	ADDWF CompTempVar2209, F
0435  0836  	MOVF gbl_FCV_RAW+D'2', W
0436  1C03  	BTFSS STATUS,C
0437  2C3B  	GOTO	label59
0438  0F36  	INCFSZ gbl_FCV_RAW+D'2', W
0439  2C3B  	GOTO	label59
043A  2C3D  	GOTO	label60
043B        label59
043B  1683  	BSF STATUS, RP0
043C  07A0  	ADDWF CompTempVar2210, F
043D        label60
043D  1283  	BCF STATUS, RP0
043E  0837  	MOVF gbl_FCV_RAW+D'3', W
043F  1C03  	BTFSS STATUS,C
0440  2C44  	GOTO	label61
0441  0F37  	INCFSZ gbl_FCV_RAW+D'3', W
0442  2C44  	GOTO	label61
0443  2C46  	GOTO	label62
0444        label61
0444  1683  	BSF STATUS, RP0
0445  07A1  	ADDWF CompTempVar2211, F
0446        label62
0446  1283  	BCF STATUS, RP0
0447  087D  	MOVF CompTempVar2208, W
0448  00B4  	MOVWF gbl_FCV_RAW
0449  087E  	MOVF CompTempVar2209, W
044A  00B5  	MOVWF gbl_FCV_RAW+D'1'
044B  1683  	BSF STATUS, RP0
044C  0820  	MOVF CompTempVar2210, W
044D  1283  	BCF STATUS, RP0
044E  00B6  	MOVWF gbl_FCV_RAW+D'2'
044F  1683  	BSF STATUS, RP0
0450  0821  	MOVF CompTempVar2211, W
0451  1283  	BCF STATUS, RP0
0452  00B7  	MOVWF gbl_FCV_RAW+D'3'


	//Calculation
	//Calculation:
	//  temp_c = (raw / 50) - calib_subtractor
	FCV_TEMP_C = (FCV_RAW / 50) - FCV_CALIB_SUBTRACTOR;
0453  01FD  	CLRF CompTempVar2221
0454  0834  	MOVF gbl_FCV_RAW, W
0455  1683  	BSF STATUS, RP0
0456  00A0  	MOVWF __div_32_3_00001_arg_a
0457  1283  	BCF STATUS, RP0
0458  0835  	MOVF gbl_FCV_RAW+D'1', W
0459  1683  	BSF STATUS, RP0
045A  00A1  	MOVWF __div_32_3_00001_arg_a+D'1'
045B  1283  	BCF STATUS, RP0
045C  0836  	MOVF gbl_FCV_RAW+D'2', W
045D  1683  	BSF STATUS, RP0
045E  00A2  	MOVWF __div_32_3_00001_arg_a+D'2'
045F  1283  	BCF STATUS, RP0
0460  0837  	MOVF gbl_FCV_RAW+D'3', W
0461  1683  	BSF STATUS, RP0
0462  00A3  	MOVWF __div_32_3_00001_arg_a+D'3'
0463  1283  	BCF STATUS, RP0
0464  1FB7  	BTFSS gbl_FCV_RAW+D'3',7
0465  2C74  	GOTO	label63
0466  1683  	BSF STATUS, RP0
0467  09A0  	COMF __div_32_3_00001_arg_a, F
0468  09A1  	COMF __div_32_3_00001_arg_a+D'1', F
0469  09A2  	COMF __div_32_3_00001_arg_a+D'2', F
046A  09A3  	COMF __div_32_3_00001_arg_a+D'3', F
046B  0AA0  	INCF __div_32_3_00001_arg_a, F
046C  1903  	BTFSC STATUS,Z
046D  0AA1  	INCF __div_32_3_00001_arg_a+D'1', F
046E  1903  	BTFSC STATUS,Z
046F  0AA2  	INCF __div_32_3_00001_arg_a+D'2', F
0470  1903  	BTFSC STATUS,Z
0471  0AA3  	INCF __div_32_3_00001_arg_a+D'3', F
0472  1283  	BCF STATUS, RP0
0473  0AFD  	INCF CompTempVar2221, F
0474        label63
0474  3032  	MOVLW 0x32
0475  1683  	BSF STATUS, RP0
0476  00A4  	MOVWF __div_32_3_00001_arg_b
0477  01A5  	CLRF __div_32_3_00001_arg_b+D'1'
0478  01A6  	CLRF __div_32_3_00001_arg_b+D'2'
0479  01A7  	CLRF __div_32_3_00001_arg_b+D'3'
047A  221B  	CALL __div_32_3_00001
047B  1683  	BSF STATUS, RP0
047C  0830  	MOVF CompTempVarRet210, W
047D  1283  	BCF STATUS, RP0
047E  00BC  	MOVWF gbl_FCV_TEMP_C
047F  1683  	BSF STATUS, RP0
0480  0831  	MOVF CompTempVarRet210+D'1', W
0481  1283  	BCF STATUS, RP0
0482  00BD  	MOVWF gbl_FCV_TEMP_C+D'1'
0483  1683  	BSF STATUS, RP0
0484  0832  	MOVF CompTempVarRet210+D'2', W
0485  1283  	BCF STATUS, RP0
0486  00BE  	MOVWF gbl_FCV_TEMP_C+D'2'
0487  1683  	BSF STATUS, RP0
0488  0833  	MOVF CompTempVarRet210+D'3', W
0489  1283  	BCF STATUS, RP0
048A  00BF  	MOVWF gbl_FCV_TEMP_C+D'3'
048B  1C7D  	BTFSS CompTempVar2221,0
048C  2C98  	GOTO	label64
048D  09BC  	COMF gbl_FCV_TEMP_C, F
048E  09BD  	COMF gbl_FCV_TEMP_C+D'1', F
048F  09BE  	COMF gbl_FCV_TEMP_C+D'2', F
0490  09BF  	COMF gbl_FCV_TEMP_C+D'3', F
0491  0ABC  	INCF gbl_FCV_TEMP_C, F
0492  1903  	BTFSC STATUS,Z
0493  0ABD  	INCF gbl_FCV_TEMP_C+D'1', F
0494  1903  	BTFSC STATUS,Z
0495  0ABE  	INCF gbl_FCV_TEMP_C+D'2', F
0496  1903  	BTFSC STATUS,Z
0497  0ABF  	INCF gbl_FCV_TEMP_C+D'3', F
0498        label64
0498  0845  	MOVF gbl_FCV_CALIB_SUBTRACTOR, W
0499  1683  	BSF STATUS, RP0
049A  00A8  	MOVWF CompTempVar2212
049B  1283  	BCF STATUS, RP0
049C  0846  	MOVF gbl_FCV_CALIB_SUBTRACTOR+D'1', W
049D  1683  	BSF STATUS, RP0
049E  00A9  	MOVWF CompTempVar2212+D'1'
049F  01AA  	CLRF CompTempVar2212+D'2'
04A0  01AB  	CLRF CompTempVar2212+D'3'
04A1  0828  	MOVF CompTempVar2212, W
04A2  1283  	BCF STATUS, RP0
04A3  02BC  	SUBWF gbl_FCV_TEMP_C, F
04A4  1683  	BSF STATUS, RP0
04A5  0829  	MOVF CompTempVar2212+D'1', W
04A6  1803  	BTFSC STATUS,C
04A7  2CAB  	GOTO	label65
04A8  0F29  	INCFSZ CompTempVar2212+D'1', W
04A9  2CAB  	GOTO	label65
04AA  2CAD  	GOTO	label66
04AB        label65
04AB  1283  	BCF STATUS, RP0
04AC  02BD  	SUBWF gbl_FCV_TEMP_C+D'1', F
04AD        label66
04AD  1683  	BSF STATUS, RP0
04AE  082A  	MOVF CompTempVar2212+D'2', W
04AF  1803  	BTFSC STATUS,C
04B0  2CB4  	GOTO	label67
04B1  0F2A  	INCFSZ CompTempVar2212+D'2', W
04B2  2CB4  	GOTO	label67
04B3  2CB6  	GOTO	label68
04B4        label67
04B4  1283  	BCF STATUS, RP0
04B5  02BE  	SUBWF gbl_FCV_TEMP_C+D'2', F
04B6        label68
04B6  1683  	BSF STATUS, RP0
04B7  082B  	MOVF CompTempVar2212+D'3', W
04B8  1803  	BTFSC STATUS,C
04B9  2CBD  	GOTO	label69
04BA  0F2B  	INCFSZ CompTempVar2212+D'3', W
04BB  2CBD  	GOTO	label69
04BC  2CBF  	GOTO	label70
04BD        label69
04BD  1283  	BCF STATUS, RP0
04BE  02BF  	SUBWF gbl_FCV_TEMP_C+D'3', F
04BF        label70


	//Calculation
	//Calculation:
	//  dp2 = raw % 50
	FCV_DP2 = FCV_RAW % 50;
04BF  1283  	BCF STATUS, RP0
04C0  0834  	MOVF gbl_FCV_RAW, W
04C1  1683  	BSF STATUS, RP0
04C2  00A0  	MOVWF __rem_32_3_00002_arg_a
04C3  1283  	BCF STATUS, RP0
04C4  0835  	MOVF gbl_FCV_RAW+D'1', W
04C5  1683  	BSF STATUS, RP0
04C6  00A1  	MOVWF __rem_32_3_00002_arg_a+D'1'
04C7  1283  	BCF STATUS, RP0
04C8  0836  	MOVF gbl_FCV_RAW+D'2', W
04C9  1683  	BSF STATUS, RP0
04CA  00A2  	MOVWF __rem_32_3_00002_arg_a+D'2'
04CB  1283  	BCF STATUS, RP0
04CC  0837  	MOVF gbl_FCV_RAW+D'3', W
04CD  1683  	BSF STATUS, RP0
04CE  00A3  	MOVWF __rem_32_3_00002_arg_a+D'3'
04CF  1283  	BCF STATUS, RP0
04D0  1FB7  	BTFSS gbl_FCV_RAW+D'3',7
04D1  2CDE  	GOTO	label71
04D2  1683  	BSF STATUS, RP0
04D3  09A0  	COMF __rem_32_3_00002_arg_a, F
04D4  09A1  	COMF __rem_32_3_00002_arg_a+D'1', F
04D5  09A2  	COMF __rem_32_3_00002_arg_a+D'2', F
04D6  09A3  	COMF __rem_32_3_00002_arg_a+D'3', F
04D7  0AA0  	INCF __rem_32_3_00002_arg_a, F
04D8  1903  	BTFSC STATUS,Z
04D9  0AA1  	INCF __rem_32_3_00002_arg_a+D'1', F
04DA  1903  	BTFSC STATUS,Z
04DB  0AA2  	INCF __rem_32_3_00002_arg_a+D'2', F
04DC  1903  	BTFSC STATUS,Z
04DD  0AA3  	INCF __rem_32_3_00002_arg_a+D'3', F
04DE        label71
04DE  3032  	MOVLW 0x32
04DF  1683  	BSF STATUS, RP0
04E0  00A4  	MOVWF __rem_32_3_00002_arg_b
04E1  01A5  	CLRF __rem_32_3_00002_arg_b+D'1'
04E2  01A6  	CLRF __rem_32_3_00002_arg_b+D'2'
04E3  01A7  	CLRF __rem_32_3_00002_arg_b+D'3'
04E4  21CE  	CALL __rem_32_3_00002
04E5  1683  	BSF STATUS, RP0
04E6  082C  	MOVF CompTempVarRet212, W
04E7  1283  	BCF STATUS, RP0
04E8  00DD  	MOVWF gbl_FCV_DP2
04E9  1FB7  	BTFSS gbl_FCV_RAW+D'3',7
04EA  2CED  	GOTO	label72
04EB  09DD  	COMF gbl_FCV_DP2, F
04EC  0ADD  	INCF gbl_FCV_DP2, F
04ED        label72


	//Decision
	//Decision: dp2 >= 100?
	if (FCV_DP2 >= 100)
04ED  3064  	MOVLW 0x64
04EE  025D  	SUBWF gbl_FCV_DP2, W
04EF  1C03  	BTFSS STATUS,C
04F0  2CFB  	GOTO	label73
04FB        label73

	{

		//Calculation
		//Calculation:
		//  temp_cdp = dp2 / 100
		FCV_TEMP_CDP = FCV_DP2 / 100;
04F1  085D  	MOVF gbl_FCV_DP2, W
04F2  1683  	BSF STATUS, RP0
04F3  00A0  	MOVWF __div_8_8_00000_arg_a
04F4  3064  	MOVLW 0x64
04F5  00A1  	MOVWF __div_8_8_00000_arg_b
04F6  220A  	CALL __div_8_8_00000
04F7  0824  	MOVF CompTempVarRet218, W
04F8  1283  	BCF STATUS, RP0
04F9  00D9  	MOVWF gbl_FCV_TEMP_CDP


	} else {
04FA  2D19  	GOTO	label75


		//Decision
		//Decision: dp2 >= 10 AND dp2 <= 100?
		if (FCV_DP2 >= 10 & FCV_DP2 <= 100)
04FB  01FE  	CLRF CompTempVar2224
04FC  300A  	MOVLW 0x0A
04FD  025D  	SUBWF gbl_FCV_DP2, W
04FE  1803  	BTFSC STATUS,C
04FF  0AFE  	INCF CompTempVar2224, F
0500  01FD  	CLRF CompTempVar2223
0501  085D  	MOVF gbl_FCV_DP2, W
0502  3C64  	SUBLW 0x64
0503  1803  	BTFSC STATUS,C
0504  0AFD  	INCF CompTempVar2223, F
0505  087D  	MOVF CompTempVar2223, W
0506  057E  	ANDWF CompTempVar2224, W
0507  1903  	BTFSC STATUS,Z
0508  2D13  	GOTO	label74
0513        label74

		{

			//Calculation
			//Calculation:
			//  temp_cdp = dp2 / 10
			FCV_TEMP_CDP = FCV_DP2 / 10;
0509  085D  	MOVF gbl_FCV_DP2, W
050A  1683  	BSF STATUS, RP0
050B  00A0  	MOVWF __div_8_8_00000_arg_a
050C  300A  	MOVLW 0x0A
050D  00A1  	MOVWF __div_8_8_00000_arg_b
050E  220A  	CALL __div_8_8_00000
050F  0824  	MOVF CompTempVarRet218, W
0510  1283  	BCF STATUS, RP0
0511  00D9  	MOVWF gbl_FCV_TEMP_CDP


		} else {
0512  2D19  	GOTO	label75


			//Decision
			//Decision: dp2 < 10?
			if (FCV_DP2 < 10)
0513  300A  	MOVLW 0x0A
0514  025D  	SUBWF gbl_FCV_DP2, W
0515  1803  	BTFSC STATUS,C
0516  2D19  	GOTO	label75
0519        label75

			{

				//Calculation
				//Calculation:
				//  temp_cdp = dp2
				FCV_TEMP_CDP = FCV_DP2;
0517  085D  	MOVF gbl_FCV_DP2, W
0518  00D9  	MOVWF gbl_FCV_TEMP_CDP


			// } else {

			}

		}

	}

	//Calculation
	//Calculation:
	//  temp_cdp = temp_cdp + calib_offset
	FCV_TEMP_CDP = FCV_TEMP_CDP + FCV_CALIB_OFFSET;
0519  0847  	MOVF gbl_FCV_CALIB_OFFSET, W
051A  0759  	ADDWF gbl_FCV_TEMP_CDP, W
051B  00D9  	MOVWF gbl_FCV_TEMP_CDP


}
051C  0008  	RETURN



void FCM_calibrate()

{

	//Call Component Macro
	//Call Component Macro: trim=ReadAsByte()
	FCV_TRIM = FCD_ADC0_ReadAsByte();
05D4  22CB  	CALL FCD_ADC0_R_0005C
05D5  0820  	MOVF CompTempVarRet2244, W
05D6  1283  	BCF STATUS, RP0
05D7  00D8  	MOVWF gbl_FCV_TRIM


	//Decision
	//Decision: trim = 255 OR trim = 0?
	if (FCV_TRIM == 255 | FCV_TRIM == 0)
05D8  01FC  	CLRF CompTempVar2226
05D9  0A58  	INCF gbl_FCV_TRIM, W
05DA  1903  	BTFSC STATUS,Z
05DB  0AFC  	INCF CompTempVar2226, F
05DC  01FB  	CLRF CompTempVar2225
05DD  0AFB  	INCF CompTempVar2225, F
05DE  08D8  	MOVF gbl_FCV_TRIM, F
05DF  1D03  	BTFSS STATUS,Z
05E0  107B  	BCF CompTempVar2225,0
05E1  087B  	MOVF CompTempVar2225, W
05E2  047C  	IORWF CompTempVar2226, W
05E3  1D03  	BTFSS STATUS,Z

	{

		//Call Macro
		//Call Macro: error()
		FCM_error();
05E4  2350  	CALL FCM_error_00000


	// } else {

	}

	//Calculation
	//Calculation:
	//  trim_diff = trim - trim_prev
	FCV_TRIM_DIFF = FCV_TRIM - FCV_TRIM_PREV;
05E5  0858  	MOVF gbl_FCV_TRIM, W
05E6  00B8  	MOVWF gbl_FCV_TRIM_DIFF
05E7  01B9  	CLRF gbl_FCV_TRIM_DIFF+D'1'
05E8  01BA  	CLRF gbl_FCV_TRIM_DIFF+D'2'
05E9  01BB  	CLRF gbl_FCV_TRIM_DIFF+D'3'
05EA  0863  	MOVF gbl_FCV_TRIM_PREV, W
05EB  1683  	BSF STATUS, RP0
05EC  00A0  	MOVWF CompTempVar2227
05ED  01A1  	CLRF CompTempVar2227+D'1'
05EE  01A2  	CLRF CompTempVar2227+D'2'
05EF  01A3  	CLRF CompTempVar2227+D'3'
05F0  0820  	MOVF CompTempVar2227, W
05F1  1283  	BCF STATUS, RP0
05F2  02B8  	SUBWF gbl_FCV_TRIM_DIFF, F
05F3  1683  	BSF STATUS, RP0
05F4  0821  	MOVF CompTempVar2227+D'1', W
05F5  1803  	BTFSC STATUS,C
05F6  2DFA  	GOTO	label76
05F7  0F21  	INCFSZ CompTempVar2227+D'1', W
05F8  2DFA  	GOTO	label76
05F9  2DFC  	GOTO	label77
05FA        label76
05FA  1283  	BCF STATUS, RP0
05FB  02B9  	SUBWF gbl_FCV_TRIM_DIFF+D'1', F
05FC        label77
05FC  1683  	BSF STATUS, RP0
05FD  0822  	MOVF CompTempVar2227+D'2', W
05FE  1803  	BTFSC STATUS,C
05FF  2E03  	GOTO	label78
0600  0F22  	INCFSZ CompTempVar2227+D'2', W
0601  2E03  	GOTO	label78
0602  2E05  	GOTO	label79
0603        label78
0603  1283  	BCF STATUS, RP0
0604  02BA  	SUBWF gbl_FCV_TRIM_DIFF+D'2', F
0605        label79
0605  1683  	BSF STATUS, RP0
0606  0823  	MOVF CompTempVar2227+D'3', W
0607  1803  	BTFSC STATUS,C
0608  2E0C  	GOTO	label80
0609  0F23  	INCFSZ CompTempVar2227+D'3', W
060A  2E0C  	GOTO	label80
060B  2E0E  	GOTO	label81
060C        label80
060C  1283  	BCF STATUS, RP0
060D  02BB  	SUBWF gbl_FCV_TRIM_DIFF+D'3', F
060E        label81


	//Decision
	//Decision: trim_diff = 0?
	if (FCV_TRIM_DIFF == 0)
060E  1283  	BCF STATUS, RP0
060F  0838  	MOVF gbl_FCV_TRIM_DIFF, W
0610  0439  	IORWF gbl_FCV_TRIM_DIFF+D'1', W
0611  043A  	IORWF gbl_FCV_TRIM_DIFF+D'2', W
0612  043B  	IORWF gbl_FCV_TRIM_DIFF+D'3', W
0613  39FF  	ANDLW 0xFF
0614  1D03  	BTFSS STATUS,Z
0615  2E1E  	GOTO	label82
061E        label82

	{

		//Calculation
		//Calculation:
		//  ihap = ihap + 1
		FCV_IHAP = FCV_IHAP + 1;
0616  0A70  	INCF gbl_FCV_IHAP, W
0617  00F0  	MOVWF gbl_FCV_IHAP


		//Decision
		//Decision: ihap = 255?
		if (FCV_IHAP == 255)
0618  0A70  	INCF gbl_FCV_IHAP, W
0619  1D03  	BTFSS STATUS,Z
061A  2E1F  	GOTO	label83

		{

			//Calculation
			//Calculation:
			//  ihap = 0
			//  calib_var = 0
			FCV_IHAP = 0;
061B  01F0  	CLRF gbl_FCV_IHAP

			FCV_CALIB_VAR = 0;
061C  01ED  	CLRF gbl_FCV_CALIB_VAR


		// } else {

		}

	} else {
061D  2E1F  	GOTO	label83
061F        label83


		//Calculation
		//Calculation:
		//  ihap = 0
		FCV_IHAP = 0;
061E  01F0  	CLRF gbl_FCV_IHAP


	}

	//Calculation
	//Calculation:
	//  calib_factor = trim / 10
	FCV_CALIB_FACTOR = FCV_TRIM / 10;
061F  0858  	MOVF gbl_FCV_TRIM, W
0620  1683  	BSF STATUS, RP0
0621  00A0  	MOVWF __div_8_8_00000_arg_a
0622  300A  	MOVLW 0x0A
0623  00A1  	MOVWF __div_8_8_00000_arg_b
0624  220A  	CALL __div_8_8_00000
0625  0824  	MOVF CompTempVarRet218, W
0626  1283  	BCF STATUS, RP0
0627  00EC  	MOVWF gbl_FCV_CALIB_FACTOR


	//Decision
	//Decision: calib_factor > 12?
	if (FCV_CALIB_FACTOR > 12)
0628  086C  	MOVF gbl_FCV_CALIB_FACTOR, W
0629  3C0C  	SUBLW 0x0C
062A  1803  	BTFSC STATUS,C
062B  2E52  	GOTO	label85
0652        label85

	{

		//Calculation
		//Calculation:
		//  calib_temp = calib_factor - 12
		FCV_CALIB_TEMP = FCV_CALIB_FACTOR - 12;
062C  300C  	MOVLW 0x0C
062D  026C  	SUBWF gbl_FCV_CALIB_FACTOR, W
062E  00E9  	MOVWF gbl_FCV_CALIB_TEMP


		//Decision
		//Decision: calib_temp > 10?
		if (FCV_CALIB_TEMP > 10)
062F  0869  	MOVF gbl_FCV_CALIB_TEMP, W
0630  3C0A  	SUBLW 0x0A
0631  1803  	BTFSC STATUS,C
0632  2E3A  	GOTO	label84
063A        label84

		{

			//Calculation
			//Calculation:
			//  calib_subtractor = 270 + 1
			//  calib_temp = calib_temp - 10
			FCV_CALIB_SUBTRACTOR = 270 + 1;
0633  300F  	MOVLW 0x0F
0634  00C5  	MOVWF gbl_FCV_CALIB_SUBTRACTOR
0635  3001  	MOVLW 0x01
0636  00C6  	MOVWF gbl_FCV_CALIB_SUBTRACTOR+D'1'

			FCV_CALIB_TEMP = FCV_CALIB_TEMP - 10;
0637  300A  	MOVLW 0x0A
0638  0269  	SUBWF gbl_FCV_CALIB_TEMP, W
0639  00E9  	MOVWF gbl_FCV_CALIB_TEMP


		// } else {

		}

		//Calculation
		//Calculation:
		//  calib_offset = 3 + calib_temp
		FCV_CALIB_OFFSET = 3 + FCV_CALIB_TEMP;
063A  01C8  	CLRF gbl_FCV_CALIB_OFFSET+D'1'
063B  0869  	MOVF gbl_FCV_CALIB_TEMP, W
063C  3E03  	ADDLW 0x03
063D  00C7  	MOVWF gbl_FCV_CALIB_OFFSET
063E  1803  	BTFSC STATUS,C
063F  0AC8  	INCF gbl_FCV_CALIB_OFFSET+D'1', F


		//Decision
		//Decision: calib_offset > 10?
		if (FCV_CALIB_OFFSET > 10)
0640  0847  	MOVF gbl_FCV_CALIB_OFFSET, W
0641  3C0A  	SUBLW 0x0A
0642  0848  	MOVF gbl_FCV_CALIB_OFFSET+D'1', W
0643  1803  	BTFSC STATUS,C
0644  1D03  	BTFSS STATUS,Z
0645  1BC8  	BTFSC gbl_FCV_CALIB_OFFSET+D'1',7
0646  2E83  	GOTO	label87

		{

			//Calculation
			//Calculation:
			//  calib_subtractor = calib_subtractor + 1
			//  calib_offset = calib_offset - 10
			FCV_CALIB_SUBTRACTOR = FCV_CALIB_SUBTRACTOR + 1;
0647  08C5  	MOVF gbl_FCV_CALIB_SUBTRACTOR, F
0648  08C6  	MOVF gbl_FCV_CALIB_SUBTRACTOR+D'1', F
0649  0AC5  	INCF gbl_FCV_CALIB_SUBTRACTOR, F
064A  1903  	BTFSC STATUS,Z
064B  0AC6  	INCF gbl_FCV_CALIB_SUBTRACTOR+D'1', F

			FCV_CALIB_OFFSET = FCV_CALIB_OFFSET - 10;
064C  300A  	MOVLW 0x0A
064D  02C7  	SUBWF gbl_FCV_CALIB_OFFSET, F
064E  08C8  	MOVF gbl_FCV_CALIB_OFFSET+D'1', F
064F  1C03  	BTFSS STATUS,C
0650  03C8  	DECF gbl_FCV_CALIB_OFFSET+D'1', F


		// } else {

		}

	} else {
0651  2E83  	GOTO	label87


		//Decision
		//Decision: calib_factor < 12?
		if (FCV_CALIB_FACTOR < 12)
0652  300C  	MOVLW 0x0C
0653  026C  	SUBWF gbl_FCV_CALIB_FACTOR, W
0654  1803  	BTFSC STATUS,C
0655  2E78  	GOTO	label86
0678        label86

		{

			//Calculation
			//Calculation:
			//  calib_offset = 3 - calib_factor
			FCV_CALIB_OFFSET = 3 - FCV_CALIB_FACTOR;
0656  01FE  	CLRF CompTempVar2240
0657  086C  	MOVF gbl_FCV_CALIB_FACTOR, W
0658  3C03  	SUBLW 0x03
0659  00FD  	MOVWF CompTempVar2239
065A  1C03  	BTFSS STATUS,C
065B  03FE  	DECF CompTempVar2240, F
065C  087D  	MOVF CompTempVar2239, W
065D  00C7  	MOVWF gbl_FCV_CALIB_OFFSET
065E  087E  	MOVF CompTempVar2240, W
065F  00C8  	MOVWF gbl_FCV_CALIB_OFFSET+D'1'


			//Decision
			//Decision: calib_offset < 0?
			if (FCV_CALIB_OFFSET < 0)
0660  1FC8  	BTFSS gbl_FCV_CALIB_OFFSET+D'1',7
0661  2E83  	GOTO	label87

			{

				//Calculation
				//Calculation:
				//  calib_offset = calib_offset * -1
				//  calib_subtractor = 270 - 1
				FCV_CALIB_OFFSET = FCV_CALIB_OFFSET * -1;
0662  0847  	MOVF gbl_FCV_CALIB_OFFSET, W
0663  00FD  	MOVWF __mul_16s__0000E_arg_a
0664  0848  	MOVF gbl_FCV_CALIB_OFFSET+D'1', W
0665  00FE  	MOVWF __mul_16s__0000E_arg_a+D'1'
0666  30FF  	MOVLW 0xFF
0667  1683  	BSF STATUS, RP0
0668  00A0  	MOVWF __mul_16s__0000E_arg_b
0669  01A1  	CLRF __mul_16s__0000E_arg_b+D'1'
066A  03A1  	DECF __mul_16s__0000E_arg_b+D'1', F
066B  22DF  	CALL __mul_16s__0000E
066C  0825  	MOVF CompTempVarRet461, W
066D  1283  	BCF STATUS, RP0
066E  00C7  	MOVWF gbl_FCV_CALIB_OFFSET
066F  1683  	BSF STATUS, RP0
0670  0826  	MOVF CompTempVarRet461+D'1', W
0671  1283  	BCF STATUS, RP0
0672  00C8  	MOVWF gbl_FCV_CALIB_OFFSET+D'1'

				FCV_CALIB_SUBTRACTOR = 270 - 1;
0673  300D  	MOVLW 0x0D
0674  00C5  	MOVWF gbl_FCV_CALIB_SUBTRACTOR
0675  3001  	MOVLW 0x01
0676  00C6  	MOVWF gbl_FCV_CALIB_SUBTRACTOR+D'1'


			// } else {

			}

		} else {
0677  2E83  	GOTO	label87


			//Decision
			//Decision: calib_factor = 12?
			if (FCV_CALIB_FACTOR == 12)
0678  086C  	MOVF gbl_FCV_CALIB_FACTOR, W
0679  3A0C  	XORLW 0x0C
067A  1D03  	BTFSS STATUS,Z
067B  2E83  	GOTO	label87
0683        label87

			{

				//Calculation
				//Calculation:
				//  calib_offset = 3
				//  calib_subtractor = 270
				FCV_CALIB_OFFSET = 3;
067C  3003  	MOVLW 0x03
067D  00C7  	MOVWF gbl_FCV_CALIB_OFFSET
067E  01C8  	CLRF gbl_FCV_CALIB_OFFSET+D'1'

				FCV_CALIB_SUBTRACTOR = 270;
067F  300E  	MOVLW 0x0E
0680  00C5  	MOVWF gbl_FCV_CALIB_SUBTRACTOR
0681  3001  	MOVLW 0x01
0682  00C6  	MOVWF gbl_FCV_CALIB_SUBTRACTOR+D'1'


			// } else {

			}

		}

	}

	//Calculation
	//Calculation:
	//  temp_tens = temp_c / 10
	//  temp_ones = temp_c % 10
	//  temp_dec = temp_cdp
	FCV_TEMP_TENS = FCV_TEMP_C / 10;
0683  01FD  	CLRF CompTempVar2242
0684  083C  	MOVF gbl_FCV_TEMP_C, W
0685  1683  	BSF STATUS, RP0
0686  00A0  	MOVWF __div_32_3_00001_arg_a
0687  1283  	BCF STATUS, RP0
0688  083D  	MOVF gbl_FCV_TEMP_C+D'1', W
0689  1683  	BSF STATUS, RP0
068A  00A1  	MOVWF __div_32_3_00001_arg_a+D'1'
068B  1283  	BCF STATUS, RP0
068C  083E  	MOVF gbl_FCV_TEMP_C+D'2', W
068D  1683  	BSF STATUS, RP0
068E  00A2  	MOVWF __div_32_3_00001_arg_a+D'2'
068F  1283  	BCF STATUS, RP0
0690  083F  	MOVF gbl_FCV_TEMP_C+D'3', W
0691  1683  	BSF STATUS, RP0
0692  00A3  	MOVWF __div_32_3_00001_arg_a+D'3'
0693  1283  	BCF STATUS, RP0
0694  1FBF  	BTFSS gbl_FCV_TEMP_C+D'3',7
0695  2EA4  	GOTO	label88
0696  1683  	BSF STATUS, RP0
0697  09A0  	COMF __div_32_3_00001_arg_a, F
0698  09A1  	COMF __div_32_3_00001_arg_a+D'1', F
0699  09A2  	COMF __div_32_3_00001_arg_a+D'2', F
069A  09A3  	COMF __div_32_3_00001_arg_a+D'3', F
069B  0AA0  	INCF __div_32_3_00001_arg_a, F
069C  1903  	BTFSC STATUS,Z
069D  0AA1  	INCF __div_32_3_00001_arg_a+D'1', F
069E  1903  	BTFSC STATUS,Z
069F  0AA2  	INCF __div_32_3_00001_arg_a+D'2', F
06A0  1903  	BTFSC STATUS,Z
06A1  0AA3  	INCF __div_32_3_00001_arg_a+D'3', F
06A2  1283  	BCF STATUS, RP0
06A3  0AFD  	INCF CompTempVar2242, F
06A4        label88
06A4  300A  	MOVLW 0x0A
06A5  1683  	BSF STATUS, RP0
06A6  00A4  	MOVWF __div_32_3_00001_arg_b
06A7  01A5  	CLRF __div_32_3_00001_arg_b+D'1'
06A8  01A6  	CLRF __div_32_3_00001_arg_b+D'2'
06A9  01A7  	CLRF __div_32_3_00001_arg_b+D'3'
06AA  221B  	CALL __div_32_3_00001
06AB  1683  	BSF STATUS, RP0
06AC  0830  	MOVF CompTempVarRet210, W
06AD  1283  	BCF STATUS, RP0
06AE  00D5  	MOVWF gbl_FCV_TEMP_TENS
06AF  1C7D  	BTFSS CompTempVar2242,0
06B0  2EB3  	GOTO	label89
06B1  09D5  	COMF gbl_FCV_TEMP_TENS, F
06B2  0AD5  	INCF gbl_FCV_TEMP_TENS, F
06B3        label89

	FCV_TEMP_ONES = FCV_TEMP_C % 10;
06B3  083C  	MOVF gbl_FCV_TEMP_C, W
06B4  1683  	BSF STATUS, RP0
06B5  00A0  	MOVWF __rem_32_3_00002_arg_a
06B6  1283  	BCF STATUS, RP0
06B7  083D  	MOVF gbl_FCV_TEMP_C+D'1', W
06B8  1683  	BSF STATUS, RP0
06B9  00A1  	MOVWF __rem_32_3_00002_arg_a+D'1'
06BA  1283  	BCF STATUS, RP0
06BB  083E  	MOVF gbl_FCV_TEMP_C+D'2', W
06BC  1683  	BSF STATUS, RP0
06BD  00A2  	MOVWF __rem_32_3_00002_arg_a+D'2'
06BE  1283  	BCF STATUS, RP0
06BF  083F  	MOVF gbl_FCV_TEMP_C+D'3', W
06C0  1683  	BSF STATUS, RP0
06C1  00A3  	MOVWF __rem_32_3_00002_arg_a+D'3'
06C2  1283  	BCF STATUS, RP0
06C3  1FBF  	BTFSS gbl_FCV_TEMP_C+D'3',7
06C4  2ED1  	GOTO	label90
06C5  1683  	BSF STATUS, RP0
06C6  09A0  	COMF __rem_32_3_00002_arg_a, F
06C7  09A1  	COMF __rem_32_3_00002_arg_a+D'1', F
06C8  09A2  	COMF __rem_32_3_00002_arg_a+D'2', F
06C9  09A3  	COMF __rem_32_3_00002_arg_a+D'3', F
06CA  0AA0  	INCF __rem_32_3_00002_arg_a, F
06CB  1903  	BTFSC STATUS,Z
06CC  0AA1  	INCF __rem_32_3_00002_arg_a+D'1', F
06CD  1903  	BTFSC STATUS,Z
06CE  0AA2  	INCF __rem_32_3_00002_arg_a+D'2', F
06CF  1903  	BTFSC STATUS,Z
06D0  0AA3  	INCF __rem_32_3_00002_arg_a+D'3', F
06D1        label90
06D1  300A  	MOVLW 0x0A
06D2  1683  	BSF STATUS, RP0
06D3  00A4  	MOVWF __rem_32_3_00002_arg_b
06D4  01A5  	CLRF __rem_32_3_00002_arg_b+D'1'
06D5  01A6  	CLRF __rem_32_3_00002_arg_b+D'2'
06D6  01A7  	CLRF __rem_32_3_00002_arg_b+D'3'
06D7  21CE  	CALL __rem_32_3_00002
06D8  1683  	BSF STATUS, RP0
06D9  082C  	MOVF CompTempVarRet212, W
06DA  1283  	BCF STATUS, RP0
06DB  00E4  	MOVWF gbl_FCV_TEMP_ONES
06DC  1FBF  	BTFSS gbl_FCV_TEMP_C+D'3',7
06DD  2EE0  	GOTO	label91
06DE  09E4  	COMF gbl_FCV_TEMP_ONES, F
06DF  0AE4  	INCF gbl_FCV_TEMP_ONES, F
06E0        label91

	FCV_TEMP_DEC = FCV_TEMP_CDP;
06E0  0859  	MOVF gbl_FCV_TEMP_CDP, W
06E1  00E0  	MOVWF gbl_FCV_TEMP_DEC


	//Call Macro
	//Call Macro: calc()
	FCM_calc();
06E2  240D  	CALL FCM_calc_00000


	//Call Macro
	//Call Macro: display_calib()
	FCM_display_calib();
06E3  23DA  	CALL FCM_displa_0005D


	//Calculation
	//Calculation:
	//  trim_prev = trim
	FCV_TRIM_PREV = FCV_TRIM;
06E4  0858  	MOVF gbl_FCV_TRIM, W
06E5  00E3  	MOVWF gbl_FCV_TRIM_PREV


}
06E6  0008  	RETURN



void FCM_display_calib()

{

	//Output
	//Output: 0 -> PORTB
	trisb = 0x00;
03DA  1683  	BSF STATUS, RP0
03DB  1303  	BCF STATUS, RP1
03DC  0186  	CLRF gbl_trisb

	portb = (0);
03DD  1283  	BCF STATUS, RP0
03DE  0186  	CLRF gbl_portb


	//Call Macro
	//Call Macro: scan_off()
	FCM_scan_off();
03DF  2102  	CALL FCM_scan_o_0005A


	//Call Macro
	//Call Macro: scan1()
	FCM_scan1();
03E0  2193  	CALL FCM_scan1_00000


	//Calculation
	//Calculation:
	//  digit = temp_tens
	FCV_DIGIT = FCV_TEMP_TENS;
03E1  0855  	MOVF gbl_FCV_TEMP_TENS, W
03E2  00E8  	MOVWF gbl_FCV_DIGIT


	//Call Macro
	//Call Macro: seg_pattern()
	FCM_seg_pattern();
03E3  20A4  	CALL FCM_seg_pa_00058


	//Delay
	//Delay: 4 ms
	delay_ms(4);
03E4  3004  	MOVLW 0x04
03E5  00FE  	MOVWF delay_ms_00000_arg_del
03E6  201A  	CALL delay_ms_00000


	//Output
	//Output: 0 -> PORTB
	trisb = 0x00;
03E7  1683  	BSF STATUS, RP0
03E8  0186  	CLRF gbl_trisb

	portb = (0);
03E9  1283  	BCF STATUS, RP0
03EA  0186  	CLRF gbl_portb


	//Call Macro
	//Call Macro: scan_off()
	FCM_scan_off();
03EB  2102  	CALL FCM_scan_o_0005A


	//Call Macro
	//Call Macro: scan2()
	FCM_scan2();
03EC  216E  	CALL FCM_scan2_00000


	//Calculation
	//Calculation:
	//  digit = temp_ones
	FCV_DIGIT = FCV_TEMP_ONES;
03ED  0864  	MOVF gbl_FCV_TEMP_ONES, W
03EE  00E8  	MOVWF gbl_FCV_DIGIT


	//Call Macro
	//Call Macro: seg_pattern()
	FCM_seg_pattern();
03EF  20A4  	CALL FCM_seg_pa_00058


	//Delay
	//Delay: 4 ms
	delay_ms(4);
03F0  3004  	MOVLW 0x04
03F1  00FE  	MOVWF delay_ms_00000_arg_del
03F2  201A  	CALL delay_ms_00000


	//Output
	//Output: 0 -> PORTB
	trisb = 0x00;
03F3  1683  	BSF STATUS, RP0
03F4  0186  	CLRF gbl_trisb

	portb = (0);
03F5  1283  	BCF STATUS, RP0
03F6  0186  	CLRF gbl_portb


	//Call Macro
	//Call Macro: scan_off()
	FCM_scan_off();
03F7  2102  	CALL FCM_scan_o_0005A


	//Call Macro
	//Call Macro: scan3()
	FCM_scan3();
03F8  2149  	CALL FCM_scan3_00000


	//Calculation
	//Calculation:
	//  digit = temp_dec
	FCV_DIGIT = FCV_TEMP_DEC;
03F9  0860  	MOVF gbl_FCV_TEMP_DEC, W
03FA  00E8  	MOVWF gbl_FCV_DIGIT


	//Call Macro
	//Call Macro: seg_pattern()
	FCM_seg_pattern();
03FB  20A4  	CALL FCM_seg_pa_00058


	//Delay
	//Delay: 4 ms
	delay_ms(4);
03FC  3004  	MOVLW 0x04
03FD  00FE  	MOVWF delay_ms_00000_arg_del
03FE  201A  	CALL delay_ms_00000


	//Output
	//Output: 0 -> PORTB
	trisb = 0x00;
03FF  1683  	BSF STATUS, RP0
0400  0186  	CLRF gbl_trisb

	portb = (0);
0401  1283  	BCF STATUS, RP0
0402  0186  	CLRF gbl_portb


	//Call Macro
	//Call Macro: scan_off()
	FCM_scan_off();
0403  2102  	CALL FCM_scan_o_0005A


	//Call Macro
	//Call Macro: scan4()
	FCM_scan4();
0404  2124  	CALL FCM_scan4_00000


	//Output
	//Output: 0 -> PORTB
	trisb = 0x00;
0405  1683  	BSF STATUS, RP0
0406  0186  	CLRF gbl_trisb

	portb = (0);
0407  1283  	BCF STATUS, RP0
0408  0186  	CLRF gbl_portb


	//Delay
	//Delay: 4 ms
	delay_ms(4);
0409  3004  	MOVLW 0x04
040A  00FE  	MOVWF delay_ms_00000_arg_del
040B  201A  	CALL delay_ms_00000


}
040C  0008  	RETURN



void FCM_display_error()

{

	//Output
	//Output: 0 -> PORTB
	trisb = 0x00;
0297  1683  	BSF STATUS, RP0
0298  1303  	BCF STATUS, RP1
0299  0186  	CLRF gbl_trisb

	portb = (0);
029A  1283  	BCF STATUS, RP0
029B  0186  	CLRF gbl_portb


	//Call Macro
	//Call Macro: scan_off()
	FCM_scan_off();
029C  2102  	CALL FCM_scan_o_0005A


	//Call Macro
	//Call Macro: scan1()
	FCM_scan1();
029D  2193  	CALL FCM_scan1_00000


	//Calculation
	//Calculation:
	//  digit = temp_tens
	FCV_DIGIT = FCV_TEMP_TENS;
029E  0855  	MOVF gbl_FCV_TEMP_TENS, W
029F  00E8  	MOVWF gbl_FCV_DIGIT


	//Call Macro
	//Call Macro: seg_pattern()
	FCM_seg_pattern();
02A0  20A4  	CALL FCM_seg_pa_00058


	//Delay
	//Delay: 4 ms
	delay_ms(4);
02A1  3004  	MOVLW 0x04
02A2  00FE  	MOVWF delay_ms_00000_arg_del
02A3  201A  	CALL delay_ms_00000


	//Output
	//Output: 0 -> PORTB
	trisb = 0x00;
02A4  1683  	BSF STATUS, RP0
02A5  0186  	CLRF gbl_trisb

	portb = (0);
02A6  1283  	BCF STATUS, RP0
02A7  0186  	CLRF gbl_portb


	//Call Macro
	//Call Macro: scan_off()
	FCM_scan_off();
02A8  2102  	CALL FCM_scan_o_0005A


	//Call Macro
	//Call Macro: scan2()
	FCM_scan2();
02A9  216E  	CALL FCM_scan2_00000


	//Calculation
	//Calculation:
	//  digit = temp_ones
	FCV_DIGIT = FCV_TEMP_ONES;
02AA  0864  	MOVF gbl_FCV_TEMP_ONES, W
02AB  00E8  	MOVWF gbl_FCV_DIGIT


	//Call Macro
	//Call Macro: seg_pattern()
	FCM_seg_pattern();
02AC  20A4  	CALL FCM_seg_pa_00058


	//Delay
	//Delay: 4 ms
	delay_ms(4);
02AD  3004  	MOVLW 0x04
02AE  00FE  	MOVWF delay_ms_00000_arg_del
02AF  201A  	CALL delay_ms_00000


	//Output
	//Output: 0 -> PORTB
	trisb = 0x00;
02B0  1683  	BSF STATUS, RP0
02B1  0186  	CLRF gbl_trisb

	portb = (0);
02B2  1283  	BCF STATUS, RP0
02B3  0186  	CLRF gbl_portb


	//Call Macro
	//Call Macro: scan_off()
	FCM_scan_off();
02B4  2102  	CALL FCM_scan_o_0005A


	//Call Macro
	//Call Macro: scan3()
	FCM_scan3();
02B5  2149  	CALL FCM_scan3_00000


	//Calculation
	//Calculation:
	//  digit = temp_dec
	FCV_DIGIT = FCV_TEMP_DEC;
02B6  0860  	MOVF gbl_FCV_TEMP_DEC, W
02B7  00E8  	MOVWF gbl_FCV_DIGIT


	//Call Macro
	//Call Macro: seg_pattern()
	FCM_seg_pattern();
02B8  20A4  	CALL FCM_seg_pa_00058


	//Delay
	//Delay: 4 ms
	delay_ms(4);
02B9  3004  	MOVLW 0x04
02BA  00FE  	MOVWF delay_ms_00000_arg_del
02BB  201A  	CALL delay_ms_00000


	//Output
	//Output: 0 -> PORTB
	trisb = 0x00;
02BC  1683  	BSF STATUS, RP0
02BD  0186  	CLRF gbl_trisb

	portb = (0);
02BE  1283  	BCF STATUS, RP0
02BF  0186  	CLRF gbl_portb


	//Call Macro
	//Call Macro: scan_off()
	FCM_scan_off();
02C0  2102  	CALL FCM_scan_o_0005A


	//Call Macro
	//Call Macro: scan4()
	FCM_scan4();
02C1  2124  	CALL FCM_scan4_00000


	//Output
	//Output: 0b01101111 -> PORTB
	trisb = 0x00;
02C2  1683  	BSF STATUS, RP0
02C3  0186  	CLRF gbl_trisb

	portb = (111);
02C4  306F  	MOVLW 0x6F
02C5  1283  	BCF STATUS, RP0
02C6  0086  	MOVWF gbl_portb


	//Delay
	//Delay: 4 ms
	delay_ms(4);
02C7  3004  	MOVLW 0x04
02C8  00FE  	MOVWF delay_ms_00000_arg_del
02C9  201A  	CALL delay_ms_00000


}
02CA  0008  	RETURN



void FCM_error()

{

	//Loop
	//Loop: While 1
	while (1)
0350        label44
03D9  2B50  	GOTO	label44

	{

		//Call Component Macro
		//Call Component Macro: trim=ReadAsByte()
		FCV_TRIM = FCD_ADC0_ReadAsByte();
0350  22CB  	CALL FCD_ADC0_R_0005C
0351  0820  	MOVF CompTempVarRet2244, W
0352  1283  	BCF STATUS, RP0
0353  00D8  	MOVWF gbl_FCV_TRIM


		//Calculation
		//Calculation:
		//  temp_tens = trim / 100
		//  temp_ones = (trim % 100) / 10
		//  temp_dec = trim % 10
		FCV_TEMP_TENS = FCV_TRIM / 100;
0354  0858  	MOVF gbl_FCV_TRIM, W
0355  1683  	BSF STATUS, RP0
0356  00A0  	MOVWF __div_8_8_00000_arg_a
0357  3064  	MOVLW 0x64
0358  00A1  	MOVWF __div_8_8_00000_arg_b
0359  220A  	CALL __div_8_8_00000
035A  0824  	MOVF CompTempVarRet218, W
035B  1283  	BCF STATUS, RP0
035C  00D5  	MOVWF gbl_FCV_TEMP_TENS

		FCV_TEMP_ONES = (FCV_TRIM % 100) / 10;
035D  0858  	MOVF gbl_FCV_TRIM, W
035E  00FD  	MOVWF __rem_8_8_00000_arg_a
035F  3064  	MOVLW 0x64
0360  00FE  	MOVWF __rem_8_8_00000_arg_b
0361  21B8  	CALL __rem_8_8_00000
0362  0824  	MOVF CompTempVarRet220, W
0363  00A0  	MOVWF __div_8_8_00000_arg_a
0364  300A  	MOVLW 0x0A
0365  00A1  	MOVWF __div_8_8_00000_arg_b
0366  220A  	CALL __div_8_8_00000
0367  0824  	MOVF CompTempVarRet218, W
0368  1283  	BCF STATUS, RP0
0369  00E4  	MOVWF gbl_FCV_TEMP_ONES

		FCV_TEMP_DEC = FCV_TRIM % 10;
036A  0858  	MOVF gbl_FCV_TRIM, W
036B  00FD  	MOVWF __rem_8_8_00000_arg_a
036C  300A  	MOVLW 0x0A
036D  00FE  	MOVWF __rem_8_8_00000_arg_b
036E  21B8  	CALL __rem_8_8_00000
036F  0824  	MOVF CompTempVarRet220, W
0370  1283  	BCF STATUS, RP0
0371  00E0  	MOVWF gbl_FCV_TEMP_DEC


		//Call Macro
		//Call Macro: display_error()
		FCM_display_error();
0372  2297  	CALL FCM_displa_0005E


		//Decision
		//Decision: trim = 120?
		if (FCV_TRIM == 120)
0373  0858  	MOVF gbl_FCV_TRIM, W
0374  3A78  	XORLW 0x78
0375  1D03  	BTFSS STATUS,Z
0376  2BD8  	GOTO	label56
03D8        label56

		{

			//Calculation
			//Calculation:
			//  trim_diff = trim - trim_prev
			//  calib_offset = calib_offset + trim_diff
			FCV_TRIM_DIFF = FCV_TRIM - FCV_TRIM_PREV;
0377  0858  	MOVF gbl_FCV_TRIM, W
0378  00B8  	MOVWF gbl_FCV_TRIM_DIFF
0379  01B9  	CLRF gbl_FCV_TRIM_DIFF+D'1'
037A  01BA  	CLRF gbl_FCV_TRIM_DIFF+D'2'
037B  01BB  	CLRF gbl_FCV_TRIM_DIFF+D'3'
037C  0863  	MOVF gbl_FCV_TRIM_PREV, W
037D  1683  	BSF STATUS, RP0
037E  00A0  	MOVWF CompTempVar2245
037F  01A1  	CLRF CompTempVar2245+D'1'
0380  01A2  	CLRF CompTempVar2245+D'2'
0381  01A3  	CLRF CompTempVar2245+D'3'
0382  0820  	MOVF CompTempVar2245, W
0383  1283  	BCF STATUS, RP0
0384  02B8  	SUBWF gbl_FCV_TRIM_DIFF, F
0385  1683  	BSF STATUS, RP0
0386  0821  	MOVF CompTempVar2245+D'1', W
0387  1803  	BTFSC STATUS,C
0388  2B8C  	GOTO	label45
0389  0F21  	INCFSZ CompTempVar2245+D'1', W
038A  2B8C  	GOTO	label45
038B  2B8E  	GOTO	label46
038C        label45
038C  1283  	BCF STATUS, RP0
038D  02B9  	SUBWF gbl_FCV_TRIM_DIFF+D'1', F
038E        label46
038E  1683  	BSF STATUS, RP0
038F  0822  	MOVF CompTempVar2245+D'2', W
0390  1803  	BTFSC STATUS,C
0391  2B95  	GOTO	label47
0392  0F22  	INCFSZ CompTempVar2245+D'2', W
0393  2B95  	GOTO	label47
0394  2B97  	GOTO	label48
0395        label47
0395  1283  	BCF STATUS, RP0
0396  02BA  	SUBWF gbl_FCV_TRIM_DIFF+D'2', F
0397        label48
0397  1683  	BSF STATUS, RP0
0398  0823  	MOVF CompTempVar2245+D'3', W
0399  1803  	BTFSC STATUS,C
039A  2B9E  	GOTO	label49
039B  0F23  	INCFSZ CompTempVar2245+D'3', W
039C  2B9E  	GOTO	label49
039D  2BA0  	GOTO	label50
039E        label49
039E  1283  	BCF STATUS, RP0
039F  02BB  	SUBWF gbl_FCV_TRIM_DIFF+D'3', F
03A0        label50

			FCV_CALIB_OFFSET = FCV_CALIB_OFFSET + FCV_TRIM_DIFF;
03A0  1283  	BCF STATUS, RP0
03A1  0847  	MOVF gbl_FCV_CALIB_OFFSET, W
03A2  1683  	BSF STATUS, RP0
03A3  00A0  	MOVWF CompTempVar2251
03A4  1283  	BCF STATUS, RP0
03A5  0848  	MOVF gbl_FCV_CALIB_OFFSET+D'1', W
03A6  1683  	BSF STATUS, RP0
03A7  00A1  	MOVWF CompTempVar2251+D'1'
03A8  01A2  	CLRF CompTempVar2251+D'2'
03A9  01A3  	CLRF CompTempVar2251+D'3'
03AA  1283  	BCF STATUS, RP0
03AB  1FC8  	BTFSS gbl_FCV_CALIB_OFFSET+D'1',7
03AC  2BB0  	GOTO	label51
03AD  1683  	BSF STATUS, RP0
03AE  03A2  	DECF CompTempVar2251+D'2', F
03AF  03A3  	DECF CompTempVar2251+D'3', F
03B0        label51
03B0  1283  	BCF STATUS, RP0
03B1  0838  	MOVF gbl_FCV_TRIM_DIFF, W
03B2  1683  	BSF STATUS, RP0
03B3  0720  	ADDWF CompTempVar2251, W
03B4  1283  	BCF STATUS, RP0
03B5  00FD  	MOVWF CompTempVar2252
03B6  0839  	MOVF gbl_FCV_TRIM_DIFF+D'1', W
03B7  00FE  	MOVWF CompTempVar2253
03B8  1683  	BSF STATUS, RP0
03B9  0821  	MOVF CompTempVar2251+D'1', W
03BA  1C03  	BTFSS STATUS,C
03BB  2BBF  	GOTO	label52
03BC  0F21  	INCFSZ CompTempVar2251+D'1', W
03BD  2BBF  	GOTO	label52
03BE  2BC1  	GOTO	label53
03BF        label52
03BF  1283  	BCF STATUS, RP0
03C0  07FE  	ADDWF CompTempVar2253, F
03C1        label53
03C1  1283  	BCF STATUS, RP0
03C2  087D  	MOVF CompTempVar2252, W
03C3  00C7  	MOVWF gbl_FCV_CALIB_OFFSET
03C4  087E  	MOVF CompTempVar2253, W
03C5  00C8  	MOVWF gbl_FCV_CALIB_OFFSET+D'1'


			//Decision
			//Decision: trim_diff = 0?
			if (FCV_TRIM_DIFF == 0)
03C6  0838  	MOVF gbl_FCV_TRIM_DIFF, W
03C7  0439  	IORWF gbl_FCV_TRIM_DIFF+D'1', W
03C8  043A  	IORWF gbl_FCV_TRIM_DIFF+D'2', W
03C9  043B  	IORWF gbl_FCV_TRIM_DIFF+D'3', W
03CA  39FF  	ANDLW 0xFF
03CB  1D03  	BTFSS STATUS,Z
03CC  2BD4  	GOTO	label54
03D4        label54

			{

				//Calculation
				//Calculation:
				//  errorcount = errorcount + 1
				FCV_ERRORCOUNT = FCV_ERRORCOUNT + 1;
03CD  0A72  	INCF gbl_FCV_ERRORCOUNT, W
03CE  00F2  	MOVWF gbl_FCV_ERRORCOUNT


				//Decision
				//Decision: errorcount = 255?
				if (FCV_ERRORCOUNT == 255)
03CF  0A72  	INCF gbl_FCV_ERRORCOUNT, W
03D0  1D03  	BTFSS STATUS,Z
03D1  2BD5  	GOTO	label55

				{

					//Calculation
					//Calculation:
					//  errorcount = 0
					FCV_ERRORCOUNT = 0;
03D2  01F2  	CLRF gbl_FCV_ERRORCOUNT


					//Goto Connection Point
					//Goto Connection Point: [A]: A
					goto FCC_error_A;


				// } else {

				}

			} else {
03D5        label55


				//Calculation
				//Calculation:
				//  errorcount = 0
				FCV_ERRORCOUNT = 0;
03D4  01F2  	CLRF gbl_FCV_ERRORCOUNT


			}

			//Calculation
			//Calculation:
			//  trim_prev = trim
			FCV_TRIM_PREV = FCV_TRIM;
03D5  0858  	MOVF gbl_FCV_TRIM, W
03D6  00E3  	MOVWF gbl_FCV_TRIM_PREV


		} else {
03D7  2B50  	GOTO	label44


			//Calculation
			//Calculation:
			//  errorcount = 0
			FCV_ERRORCOUNT = 0;
03D8  01F2  	CLRF gbl_FCV_ERRORCOUNT


		}


	}

	//Connection Point
	//Connection Point: [A]: A
FCC_error_A:
;

}
03D3  0008  	RETURN



void FCM_display_repeat()

{

	//Output
	//Output: 0 -> PORTB
	trisb = 0x00;
055C  1683  	BSF STATUS, RP0
055D  1303  	BCF STATUS, RP1
055E  0186  	CLRF gbl_trisb

	portb = (0);
055F  1283  	BCF STATUS, RP0
0560  0186  	CLRF gbl_portb


	//Call Macro
	//Call Macro: scan_off()
	FCM_scan_off();
0561  2102  	CALL FCM_scan_o_0005A


	//Call Macro
	//Call Macro: scan1()
	FCM_scan1();
0562  2193  	CALL FCM_scan1_00000


	//Output
	//Output: 0b00000010 -> PORTB
	trisb = 0x00;
0563  1683  	BSF STATUS, RP0
0564  0186  	CLRF gbl_trisb

	portb = (2);
0565  3002  	MOVLW 0x02
0566  1283  	BCF STATUS, RP0
0567  0086  	MOVWF gbl_portb


	//Delay
	//Delay: 4 ms
	delay_ms(4);
0568  3004  	MOVLW 0x04
0569  00FE  	MOVWF delay_ms_00000_arg_del
056A  201A  	CALL delay_ms_00000


	//Output
	//Output: 0 -> PORTB
	trisb = 0x00;
056B  1683  	BSF STATUS, RP0
056C  0186  	CLRF gbl_trisb

	portb = (0);
056D  1283  	BCF STATUS, RP0
056E  0186  	CLRF gbl_portb


	//Call Macro
	//Call Macro: scan_off()
	FCM_scan_off();
056F  2102  	CALL FCM_scan_o_0005A


	//Call Macro
	//Call Macro: scan2()
	FCM_scan2();
0570  216E  	CALL FCM_scan2_00000


	//Output
	//Output: 0b00000010 -> PORTB
	trisb = 0x00;
0571  1683  	BSF STATUS, RP0
0572  0186  	CLRF gbl_trisb

	portb = (2);
0573  3002  	MOVLW 0x02
0574  1283  	BCF STATUS, RP0
0575  0086  	MOVWF gbl_portb


	//Delay
	//Delay: 4 ms
	delay_ms(4);
0576  3004  	MOVLW 0x04
0577  00FE  	MOVWF delay_ms_00000_arg_del
0578  201A  	CALL delay_ms_00000


	//Output
	//Output: 0 -> PORTB
	trisb = 0x00;
0579  1683  	BSF STATUS, RP0
057A  0186  	CLRF gbl_trisb

	portb = (0);
057B  1283  	BCF STATUS, RP0
057C  0186  	CLRF gbl_portb


	//Call Macro
	//Call Macro: scan_off()
	FCM_scan_off();
057D  2102  	CALL FCM_scan_o_0005A


	//Call Macro
	//Call Macro: scan3()
	FCM_scan3();
057E  2149  	CALL FCM_scan3_00000


	//Output
	//Output: 0b00000010 -> PORTB
	trisb = 0x00;
057F  1683  	BSF STATUS, RP0
0580  0186  	CLRF gbl_trisb

	portb = (2);
0581  3002  	MOVLW 0x02
0582  1283  	BCF STATUS, RP0
0583  0086  	MOVWF gbl_portb


	//Delay
	//Delay: 4 ms
	delay_ms(4);
0584  3004  	MOVLW 0x04
0585  00FE  	MOVWF delay_ms_00000_arg_del
0586  201A  	CALL delay_ms_00000


	//Output
	//Output: 0 -> PORTB
	trisb = 0x00;
0587  1683  	BSF STATUS, RP0
0588  0186  	CLRF gbl_trisb

	portb = (0);
0589  1283  	BCF STATUS, RP0
058A  0186  	CLRF gbl_portb


	//Call Macro
	//Call Macro: scan_off()
	FCM_scan_off();
058B  2102  	CALL FCM_scan_o_0005A


	//Call Macro
	//Call Macro: scan4()
	FCM_scan4();
058C  2124  	CALL FCM_scan4_00000


	//Output
	//Output: 0b00001111 -> PORTB
	trisb = 0x00;
058D  1683  	BSF STATUS, RP0
058E  0186  	CLRF gbl_trisb

	portb = (15);
058F  300F  	MOVLW 0x0F
0590  1283  	BCF STATUS, RP0
0591  0086  	MOVWF gbl_portb


	//Delay
	//Delay: 4 ms
	delay_ms(4);
0592  3004  	MOVLW 0x04
0593  00FE  	MOVWF delay_ms_00000_arg_del
0594  201A  	CALL delay_ms_00000


}
0595  0008  	RETURN



void FCM_ready()
{

	//Output
	//Output: 0 -> PORTB
	trisb = 0x00;
	portb = (0);

	//Call Macro
	//Call Macro: scan_off()
	FCM_scan_off();

	//Call Macro
	//Call Macro: scan1()
	FCM_scan1();

	//Calculation
	//Calculation:
	//  digit = temp_tens
	FCV_DIGIT = FCV_TEMP_TENS;

	//Output
	//Output: 0 -> PORTB
	trisb = 0x00;
	portb = (0);

	//Delay
	//Delay: 4 ms
	delay_ms(4);

	//Output
	//Output: 0 -> PORTB
	trisb = 0x00;
	portb = (0);

	//Call Macro
	//Call Macro: scan_off()
	FCM_scan_off();

	//Call Macro
	//Call Macro: scan2()
	FCM_scan2();

	//Calculation
	//Calculation:
	//  digit = temp_ones
	FCV_DIGIT = FCV_TEMP_ONES;

	//Output
	//Output: 0 -> PORTB
	trisb = 0x00;
	portb = (0);

	//Delay
	//Delay: 4 ms
	delay_ms(4);

	//Output
	//Output: 0 -> PORTB
	trisb = 0x00;
	portb = (0);

	//Call Macro
	//Call Macro: scan_off()
	FCM_scan_off();

	//Call Macro
	//Call Macro: scan3()
	FCM_scan3();

	//Calculation
	//Calculation:
	//  digit = temp_dec
	FCV_DIGIT = FCV_TEMP_DEC;

	//Output
	//Output: 0 -> PORTB
	trisb = 0x00;
	portb = (0);

	//Delay
	//Delay: 4 ms
	delay_ms(4);

	//Output
	//Output: 0 -> PORTB
	trisb = 0x00;
	portb = (0);

	//Call Macro
	//Call Macro: scan_off()
	FCM_scan_off();

	//Call Macro
	//Call Macro: scan4()
	FCM_scan4();

	//Output
	//Output: 0b00001111 -> PORTB
	trisb = 0x00;
	portb = (15);

	//Delay
	//Delay: 4 ms
	delay_ms(4);

}


void FCM_def_calib()

{

	//Calculation
	//Calculation:
	//  calib_offset = 3
	//  calib_subtractor = 270
	FCV_CALIB_OFFSET = 3;
05CA  3003  	MOVLW 0x03
05CB  1283  	BCF STATUS, RP0
05CC  1303  	BCF STATUS, RP1
05CD  00C7  	MOVWF gbl_FCV_CALIB_OFFSET
05CE  01C8  	CLRF gbl_FCV_CALIB_OFFSET+D'1'

	FCV_CALIB_SUBTRACTOR = 270;
05CF  300E  	MOVLW 0x0E
05D0  00C5  	MOVWF gbl_FCV_CALIB_SUBTRACTOR
05D1  3001  	MOVLW 0x01
05D2  00C6  	MOVWF gbl_FCV_CALIB_SUBTRACTOR+D'1'


}
05D3  0008  	RETURN




void main()

{
	//Initialization
	adcon1 = 0x07;
06FB  3007  	MOVLW 0x07
06FC  1683  	BSF STATUS, RP0
06FD  1303  	BCF STATUS, RP1
06FE  009F  	MOVWF gbl_adcon1



	//Interrupt initialization code
	option_reg = 0xC0;
06FF  30C0  	MOVLW 0xC0
0700  0081  	MOVWF gbl_option_reg



	//Calculation
	//Calculation:
	//  data0 = 123
	//  data1 = 0xff
	//  data2 = 0xff
	//  lsb = 0x00
	//  msb = 0x00
	FCV_DATA0 = 123;
0701  307B  	MOVLW 0x7B
0702  1283  	BCF STATUS, RP0
0703  00DA  	MOVWF gbl_FCV_DATA0

	FCV_DATA1 = 0xff;
0704  30FF  	MOVLW 0xFF
0705  00DC  	MOVWF gbl_FCV_DATA1

	FCV_DATA2 = 0xff;
0706  00DE  	MOVWF gbl_FCV_DATA2

	FCV_LSB = 0x00;
0707  01E5  	CLRF gbl_FCV_LSB

	FCV_MSB = 0x00;
0708  01E7  	CLRF gbl_FCV_MSB


	//Calculation
	//Calculation:
	//  temp_tens = 0
	//  temp_ones = 0
	//  temp_dec = 0
	FCV_TEMP_TENS = 0;
0709  01D5  	CLRF gbl_FCV_TEMP_TENS

	FCV_TEMP_ONES = 0;
070A  01E4  	CLRF gbl_FCV_TEMP_ONES

	FCV_TEMP_DEC = 0;
070B  01E0  	CLRF gbl_FCV_TEMP_DEC


	//Call Component Macro
	//Call Component Macro: MI2C_Init()
	FCD_I2C_Master0_MI2C_Init();
070C  26F9  	CALL FCD_I2C_Ma_00068


	//Calculation
	//Calculation:
	//  temp_c = 35
	//  calib_offset = 3
	//  calib_subtractor = 270
	FCV_TEMP_C = 35;
070D  3023  	MOVLW 0x23
070E  1283  	BCF STATUS, RP0
070F  00BC  	MOVWF gbl_FCV_TEMP_C
0710  01BD  	CLRF gbl_FCV_TEMP_C+D'1'
0711  01BE  	CLRF gbl_FCV_TEMP_C+D'2'
0712  01BF  	CLRF gbl_FCV_TEMP_C+D'3'

	FCV_CALIB_OFFSET = 3;
0713  3003  	MOVLW 0x03
0714  00C7  	MOVWF gbl_FCV_CALIB_OFFSET
0715  01C8  	CLRF gbl_FCV_CALIB_OFFSET+D'1'

	FCV_CALIB_SUBTRACTOR = 270;
0716  300E  	MOVLW 0x0E
0717  00C5  	MOVWF gbl_FCV_CALIB_SUBTRACTOR
0718  3001  	MOVLW 0x01
0719  00C6  	MOVWF gbl_FCV_CALIB_SUBTRACTOR+D'1'


	//Call Macro
	//Call Macro: calibrate()
	FCM_calibrate();
071A  25D4  	CALL FCM_calibr_0005B


	//Decision
	//Decision: trim = 120?
	if (FCV_TRIM == 120)
071B  0858  	MOVF gbl_FCV_TRIM, W
071C  3A78  	XORLW 0x78
071D  1D03  	BTFSS STATUS,Z
071E  2F26  	GOTO	label92
0726        label92

	{

		//Calculation
		//Calculation:
		//  calib_offset = 3
		//  calib_subtractor = 270
		FCV_CALIB_OFFSET = 3;
071F  3003  	MOVLW 0x03
0720  00C7  	MOVWF gbl_FCV_CALIB_OFFSET
0721  01C8  	CLRF gbl_FCV_CALIB_OFFSET+D'1'

		FCV_CALIB_SUBTRACTOR = 270;
0722  300E  	MOVLW 0x0E
0723  00C5  	MOVWF gbl_FCV_CALIB_SUBTRACTOR
0724  3001  	MOVLW 0x01
0725  00C6  	MOVWF gbl_FCV_CALIB_SUBTRACTOR+D'1'


	// } else {

	}

	//Loop
	//Loop: While 1
	while (1)
08CB  2F26  	GOTO	label92

	{

		//Call Component Macro
		//Call Component Macro: trim=ReadAsByte()
		FCV_TRIM = FCD_ADC0_ReadAsByte();
0726  22CB  	CALL FCD_ADC0_R_0005C
0727  0820  	MOVF CompTempVarRet2244, W
0728  1283  	BCF STATUS, RP0
0729  00D8  	MOVWF gbl_FCV_TRIM


		//Call Component Macro
		//Call Component Macro: Disable()
		FCD_PWM0_Disable();
072A  26F7  	CALL FCD_PWM0_D_0007F


		//Connection Point
		//Connection Point: [C]: C
FCC_Main_C:
072B        label93

;

		//Call Macro
		//Call Macro: scan_off()
		FCM_scan_off();
072B  2102  	CALL FCM_scan_o_0005A


		//Calculation
		//Calculation:
		//  sw_counter = 0
		FCV_SW_COUNTER = 0;
072C  01EF  	CLRF gbl_FCV_SW_COUNTER


		//Connection Point
		//Connection Point: [A]: A
FCC_Main_A:
072D        label94

;

		//Input
		//Input: C0 -> sw_ir
		trisc = trisc | 0x01;
072D  3001  	MOVLW 0x01
072E  1683  	BSF STATUS, RP0
072F  0407  	IORWF gbl_trisc, W
0730  0087  	MOVWF gbl_trisc

		FCV_SW_IR = ((portc & 0x01) == 0x01);
0731  3001  	MOVLW 0x01
0732  1283  	BCF STATUS, RP0
0733  0507  	ANDWF gbl_portc, W
0734  00FB  	MOVWF CompTempVar2309
0735  01FC  	CLRF CompTempVar2310
0736  037B  	DECF CompTempVar2309, W
0737  1903  	BTFSC STATUS,Z
0738  0AFC  	INCF CompTempVar2310, F
0739  10EA  	BCF gbl_FCV_SW_IR,1
073A  087C  	MOVF CompTempVar2310, W
073B  1D03  	BTFSS STATUS,Z
073C  14EA  	BSF gbl_FCV_SW_IR,1


		//Decision
		//Decision: sw_ir = 0?
		if (FCV_SW_IR == 0)
073D  18EA  	BTFSC gbl_FCV_SW_IR,1
073E  2F2D  	GOTO	label94
073F        label95

		{

			//Connection Point
			//Connection Point: [B]: B
FCC_Main_B:

;

			//Calculation
			//Calculation:
			//  sw_counter = sw_counter + 1
			FCV_SW_COUNTER = FCV_SW_COUNTER + 1;
073F  0A6F  	INCF gbl_FCV_SW_COUNTER, W
0740  00EF  	MOVWF gbl_FCV_SW_COUNTER


			//Delay
			//Delay: 100 ms
			delay_ms(100);
0741  3064  	MOVLW 0x64
0742  00FE  	MOVWF delay_ms_00000_arg_del
0743  201A  	CALL delay_ms_00000


			//Input
			//Input: C0 -> sw_ir
			trisc = trisc | 0x01;
0744  3001  	MOVLW 0x01
0745  1683  	BSF STATUS, RP0
0746  0407  	IORWF gbl_trisc, W
0747  0087  	MOVWF gbl_trisc

			FCV_SW_IR = ((portc & 0x01) == 0x01);
0748  3001  	MOVLW 0x01
0749  1283  	BCF STATUS, RP0
074A  0507  	ANDWF gbl_portc, W
074B  00FB  	MOVWF CompTempVar2311
074C  01FC  	CLRF CompTempVar2312
074D  037B  	DECF CompTempVar2311, W
074E  1903  	BTFSC STATUS,Z
074F  0AFC  	INCF CompTempVar2312, F
0750  10EA  	BCF gbl_FCV_SW_IR,1
0751  087C  	MOVF CompTempVar2312, W
0752  1D03  	BTFSS STATUS,Z
0753  14EA  	BSF gbl_FCV_SW_IR,1


			//Decision
			//Decision: sw_ir = 0?
			if (FCV_SW_IR == 0)
0754  18EA  	BTFSC gbl_FCV_SW_IR,1
0755  2F2B  	GOTO	label93

			{

				//Decision
				//Decision: sw_counter = 10?
				if (FCV_SW_COUNTER == 10)
0756  086F  	MOVF gbl_FCV_SW_COUNTER, W
0757  3A0A  	XORLW 0x0A
0758  1D03  	BTFSS STATUS,Z

				{

				} else {

					//Goto Connection Point
					//Goto Connection Point: [B]: B
					goto FCC_Main_B;
0759  2F3F  	GOTO	label95


				}

			} else {
0838  2815  	GOTO	label109


				//Goto Connection Point
				//Goto Connection Point: [C]: C
				goto FCC_Main_C;


			}

		} else {

			//Goto Connection Point
			//Goto Connection Point: [A]: A
			goto FCC_Main_A;


		}

		//Call Component Macro
		//Call Component Macro: Enable()
		FCD_PWM0_Enable();
075A  26EC  	CALL FCD_PWM0_E_0007E


		//Call Component Macro
		//Call Component Macro: SetDutyCycle(120)
		FCD_PWM0_SetDutyCycle(120);
075B  3078  	MOVLW 0x78
075C  00FE  	MOVWF FCD_PWM0_S_00080_arg_nDuty
075D  26E7  	CALL FCD_PWM0_S_00080


		//Call Component Macro
		//Call Component Macro: SetDutyCycle(0)
		FCD_PWM0_SetDutyCycle(0);
075E  01FE  	CLRF FCD_PWM0_S_00080_arg_nDuty
075F  26E7  	CALL FCD_PWM0_S_00080


		//Connection Point
		//Connection Point: [D]: D
FCC_Main_D:
0760        label96

;

		//Call Macro
		//Call Macro: i2c_comm()
		FCM_i2c_comm();
0760  252F  	CALL FCM_i2c_co_00051


		//Calculation
		//Calculation:
		//  data_prev = data1
		FCV_DATA_PREV = FCV_DATA1;
0761  085C  	MOVF gbl_FCV_DATA1, W
0762  00EE  	MOVWF gbl_FCV_DATA_PREV


		//Call Macro
		//Call Macro: i2c_comm()
		FCM_i2c_comm();
0763  252F  	CALL FCM_i2c_co_00051


		//Calculation
		//Calculation:
		//  data_diff = data_prev - data1
		FCV_DATA_DIFF = FCV_DATA_PREV - FCV_DATA1;
0764  085C  	MOVF gbl_FCV_DATA1, W
0765  026E  	SUBWF gbl_FCV_DATA_PREV, W
0766  00F1  	MOVWF gbl_FCV_DATA_DIFF


		//Decision
		//Decision: data_diff > 10?
		if (FCV_DATA_DIFF > 10)
0767  0871  	MOVF gbl_FCV_DATA_DIFF, W
0768  3C0A  	SUBLW 0x0A
0769  1C03  	BTFSS STATUS,C

		{

			//Goto Connection Point
			//Goto Connection Point: [D]: D
			goto FCC_Main_D;
076A  2F60  	GOTO	label96


		// } else {

		}

		//Call Macro
		//Call Macro: calc()
		FCM_calc();
076B  240D  	CALL FCM_calc_00000


		//Calculation
		//Calculation:
		//  temp_tens = temp_c / 10
		//  temp_ones = temp_c % 10
		//  temp_dec = temp_cdp
		FCV_TEMP_TENS = FCV_TEMP_C / 10;
076C  01FB  	CLRF CompTempVar2314
076D  083C  	MOVF gbl_FCV_TEMP_C, W
076E  1683  	BSF STATUS, RP0
076F  00A0  	MOVWF __div_32_3_00001_arg_a
0770  1283  	BCF STATUS, RP0
0771  083D  	MOVF gbl_FCV_TEMP_C+D'1', W
0772  1683  	BSF STATUS, RP0
0773  00A1  	MOVWF __div_32_3_00001_arg_a+D'1'
0774  1283  	BCF STATUS, RP0
0775  083E  	MOVF gbl_FCV_TEMP_C+D'2', W
0776  1683  	BSF STATUS, RP0
0777  00A2  	MOVWF __div_32_3_00001_arg_a+D'2'
0778  1283  	BCF STATUS, RP0
0779  083F  	MOVF gbl_FCV_TEMP_C+D'3', W
077A  1683  	BSF STATUS, RP0
077B  00A3  	MOVWF __div_32_3_00001_arg_a+D'3'
077C  1283  	BCF STATUS, RP0
077D  1FBF  	BTFSS gbl_FCV_TEMP_C+D'3',7
077E  2F8D  	GOTO	label97
077F  1683  	BSF STATUS, RP0
0780  09A0  	COMF __div_32_3_00001_arg_a, F
0781  09A1  	COMF __div_32_3_00001_arg_a+D'1', F
0782  09A2  	COMF __div_32_3_00001_arg_a+D'2', F
0783  09A3  	COMF __div_32_3_00001_arg_a+D'3', F
0784  0AA0  	INCF __div_32_3_00001_arg_a, F
0785  1903  	BTFSC STATUS,Z
0786  0AA1  	INCF __div_32_3_00001_arg_a+D'1', F
0787  1903  	BTFSC STATUS,Z
0788  0AA2  	INCF __div_32_3_00001_arg_a+D'2', F
0789  1903  	BTFSC STATUS,Z
078A  0AA3  	INCF __div_32_3_00001_arg_a+D'3', F
078B  1283  	BCF STATUS, RP0
078C  0AFB  	INCF CompTempVar2314, F
078D        label97
078D  300A  	MOVLW 0x0A
078E  1683  	BSF STATUS, RP0
078F  00A4  	MOVWF __div_32_3_00001_arg_b
0790  01A5  	CLRF __div_32_3_00001_arg_b+D'1'
0791  01A6  	CLRF __div_32_3_00001_arg_b+D'2'
0792  01A7  	CLRF __div_32_3_00001_arg_b+D'3'
0793  221B  	CALL __div_32_3_00001
0794  1683  	BSF STATUS, RP0
0795  0830  	MOVF CompTempVarRet210, W
0796  1283  	BCF STATUS, RP0
0797  00D5  	MOVWF gbl_FCV_TEMP_TENS
0798  1C7B  	BTFSS CompTempVar2314,0
0799  2F9C  	GOTO	label98
079A  09D5  	COMF gbl_FCV_TEMP_TENS, F
079B  0AD5  	INCF gbl_FCV_TEMP_TENS, F
079C        label98

		FCV_TEMP_ONES = FCV_TEMP_C % 10;
079C  083C  	MOVF gbl_FCV_TEMP_C, W
079D  1683  	BSF STATUS, RP0
079E  00A0  	MOVWF __rem_32_3_00002_arg_a
079F  1283  	BCF STATUS, RP0
07A0  083D  	MOVF gbl_FCV_TEMP_C+D'1', W
07A1  1683  	BSF STATUS, RP0
07A2  00A1  	MOVWF __rem_32_3_00002_arg_a+D'1'
07A3  1283  	BCF STATUS, RP0
07A4  083E  	MOVF gbl_FCV_TEMP_C+D'2', W
07A5  1683  	BSF STATUS, RP0
07A6  00A2  	MOVWF __rem_32_3_00002_arg_a+D'2'
07A7  1283  	BCF STATUS, RP0
07A8  083F  	MOVF gbl_FCV_TEMP_C+D'3', W
07A9  1683  	BSF STATUS, RP0
07AA  00A3  	MOVWF __rem_32_3_00002_arg_a+D'3'
07AB  1283  	BCF STATUS, RP0
07AC  1FBF  	BTFSS gbl_FCV_TEMP_C+D'3',7
07AD  2FBA  	GOTO	label99
07AE  1683  	BSF STATUS, RP0
07AF  09A0  	COMF __rem_32_3_00002_arg_a, F
07B0  09A1  	COMF __rem_32_3_00002_arg_a+D'1', F
07B1  09A2  	COMF __rem_32_3_00002_arg_a+D'2', F
07B2  09A3  	COMF __rem_32_3_00002_arg_a+D'3', F
07B3  0AA0  	INCF __rem_32_3_00002_arg_a, F
07B4  1903  	BTFSC STATUS,Z
07B5  0AA1  	INCF __rem_32_3_00002_arg_a+D'1', F
07B6  1903  	BTFSC STATUS,Z
07B7  0AA2  	INCF __rem_32_3_00002_arg_a+D'2', F
07B8  1903  	BTFSC STATUS,Z
07B9  0AA3  	INCF __rem_32_3_00002_arg_a+D'3', F
07BA        label99
07BA  300A  	MOVLW 0x0A
07BB  1683  	BSF STATUS, RP0
07BC  00A4  	MOVWF __rem_32_3_00002_arg_b
07BD  01A5  	CLRF __rem_32_3_00002_arg_b+D'1'
07BE  01A6  	CLRF __rem_32_3_00002_arg_b+D'2'
07BF  01A7  	CLRF __rem_32_3_00002_arg_b+D'3'
07C0  21CE  	CALL __rem_32_3_00002
07C1  1683  	BSF STATUS, RP0
07C2  082C  	MOVF CompTempVarRet212, W
07C3  1283  	BCF STATUS, RP0
07C4  00E4  	MOVWF gbl_FCV_TEMP_ONES
07C5  1FBF  	BTFSS gbl_FCV_TEMP_C+D'3',7
07C6  2FC9  	GOTO	label100
07C7  09E4  	COMF gbl_FCV_TEMP_ONES, F
07C8  0AE4  	INCF gbl_FCV_TEMP_ONES, F
07C9        label100

		FCV_TEMP_DEC = FCV_TEMP_CDP;
07C9  0859  	MOVF gbl_FCV_TEMP_CDP, W
07CA  00E0  	MOVWF gbl_FCV_TEMP_DEC


		//Call Component Macro
		//Call Component Macro: trim=ReadAsByte()
		FCV_TRIM = FCD_ADC0_ReadAsByte();
07CB  22CB  	CALL FCD_ADC0_R_0005C
07CC  0820  	MOVF CompTempVarRet2244, W
07CD  1283  	BCF STATUS, RP0
07CE  00D8  	MOVWF gbl_FCV_TRIM


		//Calculation
		//Calculation:
		//  trim_prev = trim
		FCV_TRIM_PREV = FCV_TRIM;
07CF  0858  	MOVF gbl_FCV_TRIM, W
07D0  00E3  	MOVWF gbl_FCV_TRIM_PREV


		//Call Component Macro
		//Call Component Macro: Enable()
		FCD_PWM0_Enable();
07D1  26EC  	CALL FCD_PWM0_E_0007E


		//Call Component Macro
		//Call Component Macro: SetDutyCycle(120)
		FCD_PWM0_SetDutyCycle(120);
07D2  3078  	MOVLW 0x78
07D3  00FE  	MOVWF FCD_PWM0_S_00080_arg_nDuty
07D4  26E7  	CALL FCD_PWM0_S_00080


		//Loop
		//Loop: Loop 10 times
		for (FCLV_LOOP1=0; FCLV_LOOP1<10; FCLV_LOOP1++)
07D5  01F3  	CLRF gbl_FCLV_LOOP1
07D6        label101
07D6  300A  	MOVLW 0x0A
07D7  0273  	SUBWF gbl_FCLV_LOOP1, W
07D8  1803  	BTFSC STATUS,C
07D9  2FDD  	GOTO	label102
07DB  0AF3  	INCF gbl_FCLV_LOOP1, F
07DC  2FD6  	GOTO	label101
07DD        label102

		{

			//Call Macro
			//Call Macro: display_temp()
			FCM_display_temp();
07DA  2596  	CALL FCM_displa_00059



		}

		//Call Component Macro
		//Call Component Macro: SetDutyCycle(0)
		FCD_PWM0_SetDutyCycle(0);
07DD  01FE  	CLRF FCD_PWM0_S_00080_arg_nDuty
07DE  26E7  	CALL FCD_PWM0_S_00080


		//Loop
		//Loop: While sw_ir = 0
		while (1)
07DF        label103
08C0  118A  	BCF PCLATH,3
08C2  2FDF  	GOTO	label103

		{

			//Loop
			//Loop: Loop 250 times
			for (FCLV_LOOP2=0; FCLV_LOOP2<250; FCLV_LOOP2++)
07DF  01F4  	CLRF gbl_FCLV_LOOP2
07E0        label104
07E0  30FA  	MOVLW 0xFA
07E1  0274  	SUBWF gbl_FCLV_LOOP2, W
07E2  158A  	BSF PCLATH,3
07E3  1803  	BTFSC STATUS,C
07E4  28AC  	GOTO	label126
08A9  0AF4  	INCF gbl_FCLV_LOOP2, F
08AA  118A  	BCF PCLATH,3
08AB  2FE0  	GOTO	label104
08AC        label126

			{

				//Call Macro
				//Call Macro: display_temp()
				FCM_display_temp();
07E5  118A  	BCF PCLATH,3
07E6  2596  	CALL FCM_displa_00059


				//Decision
				//Decision: temp_c > 37?
				if (FCV_TEMP_C > 37)
07E7  083F  	MOVF gbl_FCV_TEMP_C+D'3', W
07E8  3C00  	SUBLW 0x00
07E9  1D03  	BTFSS STATUS,Z
07EA  2FF5  	GOTO	label105
07EB  083E  	MOVF gbl_FCV_TEMP_C+D'2', W
07EC  3C00  	SUBLW 0x00
07ED  1D03  	BTFSS STATUS,Z
07EE  2FF5  	GOTO	label105
07EF  083D  	MOVF gbl_FCV_TEMP_C+D'1', W
07F0  3C00  	SUBLW 0x00
07F1  1D03  	BTFSS STATUS,Z
07F2  2FF5  	GOTO	label105
07F3  083C  	MOVF gbl_FCV_TEMP_C, W
07F4  3C25  	SUBLW 0x25
07F5        label105
07F5  1BBF  	BTFSC gbl_FCV_TEMP_C+D'3',7
07F6  1403  	BSF STATUS,C
07F7  1803  	BTFSC STATUS,C
07F8  2FFF  	GOTO	label106
07FF        label106

				{

					//Call Component Macro
					//Call Component Macro: Enable()
					FCD_PWM0_Enable();
07F9  26EC  	CALL FCD_PWM0_E_0007E


					//Call Component Macro
					//Call Component Macro: SetDutyCycle(120)
					FCD_PWM0_SetDutyCycle(120);
07FA  3078  	MOVLW 0x78
07FB  00FE  	MOVWF FCD_PWM0_S_00080_arg_nDuty
07FC  26E7  	CALL FCD_PWM0_S_00080


				} else {
07FD  158A  	BSF PCLATH,3
07FE  2844  	GOTO	label115
0844        label115


					//Decision
					//Decision: temp_c < 34?
					if (FCV_TEMP_C < 34)
07FF  3000  	MOVLW 0x00
0800  023F  	SUBWF gbl_FCV_TEMP_C+D'3', W
0801  158A  	BSF PCLATH,3
0802  1D03  	BTFSS STATUS,Z
0803  280E  	GOTO	label107
0804  3000  	MOVLW 0x00
0805  023E  	SUBWF gbl_FCV_TEMP_C+D'2', W
0806  1D03  	BTFSS STATUS,Z
0807  280E  	GOTO	label107
0808  3000  	MOVLW 0x00
0809  023D  	SUBWF gbl_FCV_TEMP_C+D'1', W
080A  1D03  	BTFSS STATUS,Z
080B  280E  	GOTO	label107
080C  3022  	MOVLW 0x22
080D  023C  	SUBWF gbl_FCV_TEMP_C, W
080E        label107
080E  1C03  	BTFSS STATUS,C
080F  2812  	GOTO	label108
0810  1FBF  	BTFSS gbl_FCV_TEMP_C+D'3',7
0811  2839  	GOTO	label114
0812        label108
0839        label114

					{

						//Call Component Macro
						//Call Component Macro: Enable()
						FCD_PWM0_Enable();
0812  118A  	BCF PCLATH,3
0813  26EC  	CALL FCD_PWM0_E_0007E


						//Loop
						//Loop: Loop 6 times
						for (FCLV_LOOP3=0; FCLV_LOOP3<6; FCLV_LOOP3++)
0814  01F5  	CLRF gbl_FCLV_LOOP3
0815        label109
0815  3006  	MOVLW 0x06
0816  0275  	SUBWF gbl_FCLV_LOOP3, W
0817  158A  	BSF PCLATH,3
0818  1803  	BTFSC STATUS,C
0819  28AC  	GOTO	label126
0837  0AF5  	INCF gbl_FCLV_LOOP3, F

						{

							//Call Component Macro
							//Call Component Macro: SetDutyCycle(120)
							FCD_PWM0_SetDutyCycle(120);
081A  3078  	MOVLW 0x78
081B  00FE  	MOVWF FCD_PWM0_S_00080_arg_nDuty
081C  118A  	BCF PCLATH,3
081D  26E7  	CALL FCD_PWM0_S_00080


							//Loop
							//Loop: Loop 10 times
							for (FCLV_LOOP4=0; FCLV_LOOP4<10; FCLV_LOOP4++)
081E  01F6  	CLRF gbl_FCLV_LOOP4
081F        label110
081F  300A  	MOVLW 0x0A
0820  0276  	SUBWF gbl_FCLV_LOOP4, W
0821  158A  	BSF PCLATH,3
0822  1803  	BTFSC STATUS,C
0823  2829  	GOTO	label111
0826  0AF6  	INCF gbl_FCLV_LOOP4, F
0827  158A  	BSF PCLATH,3
0828  281F  	GOTO	label110
0829        label111

							{

								//Call Macro
								//Call Macro: display_repeat()
								FCM_display_repeat();
0824  118A  	BCF PCLATH,3
0825  255C  	CALL FCM_displa_0005F



							}

							//Call Component Macro
							//Call Component Macro: SetDutyCycle(0)
							FCD_PWM0_SetDutyCycle(0);
0829  01FE  	CLRF FCD_PWM0_S_00080_arg_nDuty
082A  118A  	BCF PCLATH,3
082B  26E7  	CALL FCD_PWM0_S_00080


							//Loop
							//Loop: Loop 10 times
							for (FCLV_LOOP5=0; FCLV_LOOP5<10; FCLV_LOOP5++)
082C  01F7  	CLRF gbl_FCLV_LOOP5
082D        label112
082D  300A  	MOVLW 0x0A
082E  0277  	SUBWF gbl_FCLV_LOOP5, W
082F  158A  	BSF PCLATH,3
0830  1803  	BTFSC STATUS,C
0831  2837  	GOTO	label113
0834  0AF7  	INCF gbl_FCLV_LOOP5, F
0835  158A  	BSF PCLATH,3
0836  282D  	GOTO	label112
0837        label113

							{

								//Call Macro
								//Call Macro: display_repeat()
								FCM_display_repeat();
0832  118A  	BCF PCLATH,3
0833  255C  	CALL FCM_displa_0005F



							}


						}

						//Goto Connection Point
						//Goto Connection Point: [E]: E
						goto FCC_Main_E;


					} else {

						//Output
						//Output: 1 -> C5
						trisc = trisc & 0xDF;
0839  30DF  	MOVLW 0xDF
083A  1683  	BSF STATUS, RP0
083B  0507  	ANDWF gbl_trisc, W
083C  0087  	MOVWF gbl_trisc

						if ((1))
							portc = (portc & 0xDF) | 0x20;
083D  30DF  	MOVLW 0xDF
083E  1283  	BCF STATUS, RP0
083F  0507  	ANDWF gbl_portc, W
0840  00FE  	MOVWF CompTempVar2319
0841  3020  	MOVLW 0x20
0842  047E  	IORWF CompTempVar2319, W
0843  0087  	MOVWF gbl_portc

						else
							portc = portc & 0xDF;

					}

				}

				//Call Component Macro
				//Call Component Macro: trim=ReadAsByte()
				FCV_TRIM = FCD_ADC0_ReadAsByte();
0844  118A  	BCF PCLATH,3
0845  22CB  	CALL FCD_ADC0_R_0005C
0846  0820  	MOVF CompTempVarRet2244, W
0847  1283  	BCF STATUS, RP0
0848  00D8  	MOVWF gbl_FCV_TRIM


				//Calculation
				//Calculation:
				//  trim_diff = trim - trim_prev
				FCV_TRIM_DIFF = FCV_TRIM - FCV_TRIM_PREV;
0849  0858  	MOVF gbl_FCV_TRIM, W
084A  00B8  	MOVWF gbl_FCV_TRIM_DIFF
084B  01B9  	CLRF gbl_FCV_TRIM_DIFF+D'1'
084C  01BA  	CLRF gbl_FCV_TRIM_DIFF+D'2'
084D  01BB  	CLRF gbl_FCV_TRIM_DIFF+D'3'
084E  0863  	MOVF gbl_FCV_TRIM_PREV, W
084F  1683  	BSF STATUS, RP0
0850  00A0  	MOVWF CompTempVar2320
0851  01A1  	CLRF CompTempVar2320+D'1'
0852  01A2  	CLRF CompTempVar2320+D'2'
0853  01A3  	CLRF CompTempVar2320+D'3'
0854  0820  	MOVF CompTempVar2320, W
0855  1283  	BCF STATUS, RP0
0856  02B8  	SUBWF gbl_FCV_TRIM_DIFF, F
0857  1683  	BSF STATUS, RP0
0858  0821  	MOVF CompTempVar2320+D'1', W
0859  158A  	BSF PCLATH,3
085A  1803  	BTFSC STATUS,C
085B  285F  	GOTO	label116
085C  0F21  	INCFSZ CompTempVar2320+D'1', W
085D  285F  	GOTO	label116
085E  2861  	GOTO	label117
085F        label116
085F  1283  	BCF STATUS, RP0
0860  02B9  	SUBWF gbl_FCV_TRIM_DIFF+D'1', F
0861        label117
0861  1683  	BSF STATUS, RP0
0862  0822  	MOVF CompTempVar2320+D'2', W
0863  1803  	BTFSC STATUS,C
0864  2868  	GOTO	label118
0865  0F22  	INCFSZ CompTempVar2320+D'2', W
0866  2868  	GOTO	label118
0867  286A  	GOTO	label119
0868        label118
0868  1283  	BCF STATUS, RP0
0869  02BA  	SUBWF gbl_FCV_TRIM_DIFF+D'2', F
086A        label119
086A  1683  	BSF STATUS, RP0
086B  0823  	MOVF CompTempVar2320+D'3', W
086C  1803  	BTFSC STATUS,C
086D  2871  	GOTO	label120
086E  0F23  	INCFSZ CompTempVar2320+D'3', W
086F  2871  	GOTO	label120
0870  2873  	GOTO	label121
0871        label120
0871  1283  	BCF STATUS, RP0
0872  02BB  	SUBWF gbl_FCV_TRIM_DIFF+D'3', F
0873        label121


				//Decision
				//Decision: trim_diff > 2 OR trim_diff < -2?
				if (FCV_TRIM_DIFF > 2 | FCV_TRIM_DIFF < -2)
0873  1283  	BCF STATUS, RP0
0874  01FD  	CLRF CompTempVar2318
0875  083B  	MOVF gbl_FCV_TRIM_DIFF+D'3', W
0876  3C00  	SUBLW 0x00
0877  1D03  	BTFSS STATUS,Z
0878  2883  	GOTO	label122
0879  083A  	MOVF gbl_FCV_TRIM_DIFF+D'2', W
087A  3C00  	SUBLW 0x00
087B  1D03  	BTFSS STATUS,Z
087C  2883  	GOTO	label122
087D  0839  	MOVF gbl_FCV_TRIM_DIFF+D'1', W
087E  3C00  	SUBLW 0x00
087F  1D03  	BTFSS STATUS,Z
0880  2883  	GOTO	label122
0881  0838  	MOVF gbl_FCV_TRIM_DIFF, W
0882  3C02  	SUBLW 0x02
0883        label122
0883  1BBB  	BTFSC gbl_FCV_TRIM_DIFF+D'3',7
0884  1403  	BSF STATUS,C
0885  1C03  	BTFSS STATUS,C
0886  0AFD  	INCF CompTempVar2318, F
0887  01FC  	CLRF CompTempVar2317
0888  083B  	MOVF gbl_FCV_TRIM_DIFF+D'3', W
0889  3A80  	XORLW 0x80
088A  00FE  	MOVWF CompTempVar2326
088B  30FF  	MOVLW 0xFF
088C  3A80  	XORLW 0x80
088D  027E  	SUBWF CompTempVar2326, W
088E  1D03  	BTFSS STATUS,Z
088F  289A  	GOTO	label123
0890  30FF  	MOVLW 0xFF
0891  023A  	SUBWF gbl_FCV_TRIM_DIFF+D'2', W
0892  1D03  	BTFSS STATUS,Z
0893  289A  	GOTO	label123
0894  30FF  	MOVLW 0xFF
0895  0239  	SUBWF gbl_FCV_TRIM_DIFF+D'1', W
0896  1D03  	BTFSS STATUS,Z
0897  289A  	GOTO	label123
0898  30FE  	MOVLW 0xFE
0899  0238  	SUBWF gbl_FCV_TRIM_DIFF, W
089A        label123
089A  1C03  	BTFSS STATUS,C
089B  0AFC  	INCF CompTempVar2317, F
089C  087C  	MOVF CompTempVar2317, W
089D  047D  	IORWF CompTempVar2318, W
089E  1903  	BTFSC STATUS,Z
089F  28A9  	GOTO	label125

				{

					//Calculation
					//Calculation:
					//  calib_var = 1
					FCV_CALIB_VAR = 1;
08A0  3001  	MOVLW 0x01
08A1  00ED  	MOVWF gbl_FCV_CALIB_VAR


					//Loop
					//Loop: While calib_var = 1
					while (FCV_CALIB_VAR == 1)
08A2        label124
08A2  036D  	DECF gbl_FCV_CALIB_VAR, W
08A3  1D03  	BTFSS STATUS,Z
08A4  28A9  	GOTO	label125
08A7  158A  	BSF PCLATH,3
08A8  28A2  	GOTO	label124
08A9        label125

					{

						//Call Macro
						//Call Macro: def_calib()
						FCM_def_calib();
08A5  118A  	BCF PCLATH,3
08A6  25CA  	CALL FCM_def_ca_00060



					}

				// } else {

				}


			}

			//Connection Point
			//Connection Point: [E]: E
FCC_Main_E:
;

			//Input
			//Input: C0 -> sw_ir
			trisc = trisc | 0x01;
08AC  3001  	MOVLW 0x01
08AD  1683  	BSF STATUS, RP0
08AE  0407  	IORWF gbl_trisc, W
08AF  0087  	MOVWF gbl_trisc

			FCV_SW_IR = ((portc & 0x01) == 0x01);
08B0  3001  	MOVLW 0x01
08B1  1283  	BCF STATUS, RP0
08B2  0507  	ANDWF gbl_portc, W
08B3  00FC  	MOVWF CompTempVar2327
08B4  01FD  	CLRF CompTempVar2328
08B5  037C  	DECF CompTempVar2327, W
08B6  1903  	BTFSC STATUS,Z
08B7  0AFD  	INCF CompTempVar2328, F
08B8  10EA  	BCF gbl_FCV_SW_IR,1
08B9  087D  	MOVF CompTempVar2328, W
08BA  1D03  	BTFSS STATUS,Z
08BB  14EA  	BSF gbl_FCV_SW_IR,1



			if ((FCV_SW_IR == 0) == 0) break;
08BC  01FB  	CLRF CompTempVar2316
08BD  1CEA  	BTFSS gbl_FCV_SW_IR,1
08BE  0AFB  	INCF CompTempVar2316, F
08BF  08FB  	MOVF CompTempVar2316, F
08C1  1D03  	BTFSS STATUS,Z

		}

		//Output
		//Output: 0 -> C5
		trisc = trisc & 0xDF;
08C3  30DF  	MOVLW 0xDF
08C4  1683  	BSF STATUS, RP0
08C5  0507  	ANDWF gbl_trisc, W
08C6  0087  	MOVWF gbl_trisc

		if ((0))
			portc = (portc & 0xDF) | 0x20;
		else
			portc = portc & 0xDF;
08C7  30DF  	MOVLW 0xDF
08C8  1283  	BCF STATUS, RP0
08C9  0507  	ANDWF gbl_portc, W
08CA  0087  	MOVWF gbl_portc



	}

	mainendloop: goto mainendloop;
}


void MX_INTERRUPT_MACRO(void)

{
}
092C  1283  	BCF STATUS, RP0
092D  1303  	BCF STATUS, RP1
092E  0E42  	SWAPF Int1BContext+D'2', W
092F  0084  	MOVWF FSR
0930  0E41  	SWAPF Int1BContext+D'1', W
0931  008A  	MOVWF PCLATH
0932  0E40  	SWAPF Int1BContext, W
0933  0083  	MOVWF STATUS
0934  0EFF  	SWAPF Int1Context, F
0935  0E7F  	SWAPF Int1Context, W
0936  0009  	RETFIE





/*********************************************************************
 *                  Flowcode CAL ADC File
 *
 * File: PIC_CAL_ADC.c
 *
 * (c) 2011 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * Company) for its Flowcode graphical programming language is
 * intended and supplied to you, the Companys customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 060911 | BR | Created
 * 200911 | BR | Updated to include all ADC type files
 */


//ADC Function Prototypes
void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge);
MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode);
void FC_CAL_Disable_ADC (void);


//ADC Global Variables
MX_UINT8 old_tris, tris_mask;
MX_UINT8 * tris_reg;					//TRIS register pointer


// ADC Type 1 Supported Devices ************************************************************
// 16F818, 16F819, 16F873A, 16F874A, 16F876A, 16F877A,
// *******************************************************************************************/

#ifdef MX_ADC_TYPE_1
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)

	{
		switch (Channel)
0051  2862  	GOTO	label8

		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					if (Vref == 0)
						adcon1 = 0x0E;
					else
						adcon1 = 0x05;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					if (Vref == 0)
						adcon1 = 0x04;
					else
						adcon1 = 0x05;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					if (Vref == 0)
						adcon1 = 0x02;
					else
						adcon1 = 0x03;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					if (Vref == 0)
						adcon1 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
004E  0820  	MOVF FC_CAL_Ena_0006B_arg_Channel, W
004F  3A04  	XORLW 0x04
0050  1D03  	BTFSS STATUS,Z

					tris_mask = 0x20;
0052  3020  	MOVLW 0x20
0053  1283  	BCF STATUS, RP0
0054  00FA  	MOVWF gbl_tris_mask

					tris_reg = &trisa;
0055  3000  	MOVLW HIGH(gbl_trisa+D'0')
0056  00CA  	MOVWF gbl_tris_reg+D'1'
0057  3085  	MOVLW LOW(gbl_trisa+D'0')
0058  00C9  	MOVWF gbl_tris_reg

					if (Vref == 0)
0059  1683  	BSF STATUS, RP0
005A  08A2  	MOVF FC_CAL_Ena_0006B_arg_Vref, F
005B  1D03  	BTFSS STATUS,Z
005C  2860  	GOTO	label7
0060        label7

						adcon1 = 0x02;
005D  3002  	MOVLW 0x02
005E  009F  	MOVWF gbl_adcon1

					else
005F  2862  	GOTO	label8
0062        label8

						adcon1 = 0x03;
0060  3003  	MOVLW 0x03
0061  009F  	MOVWF gbl_adcon1

					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x01;
					tris_reg = &trise;
					if (Vref == 0)
						adcon1 = 0x09;
					else
						adcon1 = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trise;
					if (Vref == 0)
						adcon1 = 0x00;
					else
						adcon1 = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trise;
					if (Vref == 0)
						adcon1 = 0x00;
					else
						adcon1 = 0x01;
					break;
			#endif
		}

		if (Conv_Speed > 3)										//assign conversion speed
0062  0821  	MOVF FC_CAL_Ena_0006B_arg_Conv_Speed, W
0063  3C03  	SUBLW 0x03
0064  1C03  	BTFSS STATUS,C

			st_bit(adcon1, ADCS2);
0065  171F  	BSF gbl_adcon1,6


		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
0066  1383  	BCF STATUS,IRP
0067  1283  	BCF STATUS, RP0
0068  184A  	BTFSC gbl_tris_reg+D'1',0
0069  1783  	BSF STATUS,IRP
006A  0849  	MOVF gbl_tris_reg, W
006B  0084  	MOVWF FSR
006C  0800  	MOVF INDF, W
006D  00F9  	MOVWF gbl_old_tris

		*tris_reg = old_tris | tris_mask;
006E  087A  	MOVF gbl_tris_mask, W
006F  0479  	IORWF gbl_old_tris, W
0070  1683  	BSF STATUS, RP0
0071  00A4  	MOVWF CompTempVar2260
0072  0080  	MOVWF INDF

		adcon0 = (0x01 | (Conv_Speed << 6)) | (Channel << 3);	//turn ADC on
0073  0821  	MOVF FC_CAL_Ena_0006B_arg_Conv_Speed, W
0074  00A4  	MOVWF CompTempVar2261
0075  01A5  	CLRF CompTempVar2262
0076  0DA4  	RLF CompTempVar2261, F
0077  0DA5  	RLF CompTempVar2262, F
0078  0DA4  	RLF CompTempVar2261, F
0079  0DA5  	RLF CompTempVar2262, F
007A  0DA4  	RLF CompTempVar2261, F
007B  0DA5  	RLF CompTempVar2262, F
007C  0DA4  	RLF CompTempVar2261, F
007D  0DA5  	RLF CompTempVar2262, F
007E  0DA4  	RLF CompTempVar2261, F
007F  0DA5  	RLF CompTempVar2262, F
0080  0DA4  	RLF CompTempVar2261, F
0081  0DA5  	RLF CompTempVar2262, F
0082  30C0  	MOVLW 0xC0
0083  0524  	ANDWF CompTempVar2261, W
0084  3801  	IORLW 0x01
0085  00A7  	MOVWF CompTempVar2265
0086  0820  	MOVF FC_CAL_Ena_0006B_arg_Channel, W
0087  00A6  	MOVWF CompTempVar2264
0088  0DA6  	RLF CompTempVar2264, F
0089  0DA6  	RLF CompTempVar2264, F
008A  0DA6  	RLF CompTempVar2264, F
008B  30F8  	MOVLW 0xF8
008C  0526  	ANDWF CompTempVar2264, W
008D  0427  	IORWF CompTempVar2265, W
008E  1283  	BCF STATUS, RP0
008F  009F  	MOVWF gbl_adcon0

		delay_us(T_Charge);										//wait the acquisition time
0090  1683  	BSF STATUS, RP0
0091  0823  	MOVF FC_CAL_Ena_0006B_arg_T_Charge, W
0092  00A4  	MOVWF delay_us_00000_arg_del
0093  2010  	CALL delay_us_00000

	}
0094  0008  	RETURN


	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)

	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x04;									//begin conversion and wait until it has finished
0026  3004  	MOVLW 0x04
0027  1283  	BCF STATUS, RP0
0028  041F  	IORWF gbl_adcon0, W
0029  009F  	MOVWF gbl_adcon0

		while (adcon0 & 0x04);
002A        label4
002A  191F  	BTFSC gbl_adcon0,2
002B  282A  	GOTO	label4

		if (Sample_Mode)
002C  1683  	BSF STATUS, RP0
002D  08A0  	MOVF FC_CAL_Sam_0006C_arg_Sample_Mode, F
002E  1903  	BTFSC STATUS,Z
002F  2844  	GOTO	label5
0044        label5

		{
			iRetVal = (adresh << 2);							//10-bit ADC
0030  1283  	BCF STATUS, RP0
0031  081E  	MOVF gbl_adresh, W
0032  1683  	BSF STATUS, RP0
0033  00A1  	MOVWF FC_CAL_Sam_0006C_1_iRetVal
0034  01A2  	CLRF FC_CAL_Sam_0006C_1_iRetVal+D'1'
0035  0DA1  	RLF FC_CAL_Sam_0006C_1_iRetVal, F
0036  0DA2  	RLF FC_CAL_Sam_0006C_1_iRetVal+D'1', F
0037  0DA1  	RLF FC_CAL_Sam_0006C_1_iRetVal, F
0038  0DA2  	RLF FC_CAL_Sam_0006C_1_iRetVal+D'1', F
0039  30FC  	MOVLW 0xFC
003A  05A1  	ANDWF FC_CAL_Sam_0006C_1_iRetVal, F

			iRetVal = iRetVal | (adresl >> 6);
003B  0C1E  	RRF gbl_adresl, W
003C  00A3  	MOVWF CompTempVar2269
003D  0CA3  	RRF CompTempVar2269, F
003E  0EA3  	SWAPF CompTempVar2269, F
003F  3003  	MOVLW 0x03
0040  0523  	ANDWF CompTempVar2269, W
0041  04A1  	IORWF FC_CAL_Sam_0006C_1_iRetVal, F
0042  08A2  	MOVF FC_CAL_Sam_0006C_1_iRetVal+D'1', F

		}
		else
0043  2849  	GOTO	label6
0049        label6

			iRetVal = adresh;									//8-bit ADC
0044  1283  	BCF STATUS, RP0
0045  081E  	MOVF gbl_adresh, W
0046  1683  	BSF STATUS, RP0
0047  00A1  	MOVWF FC_CAL_Sam_0006C_1_iRetVal
0048  01A2  	CLRF FC_CAL_Sam_0006C_1_iRetVal+D'1'


		return (iRetVal);
0049  0821  	MOVF FC_CAL_Sam_0006C_1_iRetVal, W
004A  00A3  	MOVWF CompTempVarRet2266
004B  0822  	MOVF FC_CAL_Sam_0006C_1_iRetVal+D'1', W
004C  00A4  	MOVWF CompTempVarRet2266+D'1'

	}
004D  0008  	RETURN


	void FC_CAL_Disable_ADC ()

	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
0095  1383  	BCF STATUS,IRP
0096  1283  	BCF STATUS, RP0
0097  1303  	BCF STATUS, RP1
0098  184A  	BTFSC gbl_tris_reg+D'1',0
0099  1783  	BSF STATUS,IRP
009A  0849  	MOVF gbl_tris_reg, W
009B  0084  	MOVWF FSR
009C  0879  	MOVF gbl_old_tris, W
009D  0080  	MOVWF INDF

		adcon1 = 0x07;
009E  3007  	MOVLW 0x07
009F  1683  	BSF STATUS, RP0
00A0  009F  	MOVWF gbl_adcon1

		adcon0 = 0x00;
00A1  1283  	BCF STATUS, RP0
00A2  019F  	CLRF gbl_adcon0

	}
00A3  0008  	RETURN

#endif


// ADC Type 2 Supported Devices ************************************************************
// 16F88
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_2
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		if (Vref == 1)											//assign VREF functionality
			st_bit(adcon1, VCFG1);

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ansel = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ansel = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ansel = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					ansel = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x10;
					tris_reg = &trisa;
					ansel = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x20;
					tris_reg = &trisb;
					ansel = 0x20;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x40;
					tris_reg = &trisb;
					ansel = 0x40;
					break;
			#endif
		}

		if (Conv_Speed > 3)										//assign conversion speed
			st_bit(adcon1, ADCS2);

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Conv_Speed << 6)) | (Channel << 3);	//turn ADC on
		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x04;									//begin conversion and wait until it has finished
		while (adcon0 & 0x04);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		ansel = 0x00;
		adcon0 = 0x00;
	}
#endif


// ADC Type 3 Supported Devices ************************************************************
// 16F616, 16F676, 16F677, 16F684, 16F685, 16F687, 16F688, 16F689, 16F690
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_3
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon1 = ((Conv_Speed & 0x07) << 4);				//assign conversion rate

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ansel = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ansel = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ansel = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x10;
					tris_reg = &trisa;
					ansel = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x01;
					tris_reg = &trisc;
					ansel = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x02;
					tris_reg = &trisc;
					ansel = 0x20;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x04;
					tris_reg = &trisc;
					ansel = 0x40;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x08;
					tris_reg = &trisc;
					ansel = 0x80;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x40;
					tris_reg = &trisc;
					anselh = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x80;
					tris_reg = &trisc;
					anselh = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x10;
					tris_reg = &trisb;
					anselh = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x20;
					tris_reg = &trisb;
					anselh = 0x08;
					break;
			#endif
		}

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on

		if (Vref == 1)											//assign VREF functionality
			st_bit(adcon0, VCFG);

		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x02;									//begin conversion and wait until it has finished
		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		ansel = 0x00;
		adcon0 = 0x00;
		#ifdef ANSELH
			anselh = 0x00;
		#endif
	}
#endif


// ADC Type 4 Supported Devices ************************************************************
// 16F737, 16F747, 16F767, 16F777
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_4
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon2 = 0x00;

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					adcon1 = 0x0E;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					adcon1 = 0x0D;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					adcon1 = 0x0C;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					adcon1 = 0x0B;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					adcon1 = 0x0A;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x01;
					tris_reg = &trise;
					adcon1 = 0x09;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trise;
					adcon1 = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trise;
					adcon1 = 0x07;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x04;
					tris_reg = &trisb;
					adcon1 = 0x06;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x08;
					tris_reg = &trisb;
					adcon1 = 0x05;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x02;
					tris_reg = &trisb;
					adcon1 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x10;
					tris_reg = &trisb;
					adcon1 = 0x03;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_12
				case (12):
					tris_mask = 0x01;
					tris_reg = &trisb;
					adcon1 = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_13
				case (13):
					tris_mask = 0x20;
					tris_reg = &trisb;
					adcon1 = 0x01;
					break;
			#endif
		}

		if (Vref == 1)											//assign VREF functionality
			st_bit(adcon1, VCFG0);

		if (Conv_Speed > 3)										//assign conversion speed
			st_bit(adcon1, ADCS2);

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Conv_Speed << 6));					//turn ADC on
		adcon0 = adcon0 | ((Channel & 0x07) << 3);
		adcon0 = adcon0 | ((Channel & 0x08) >> 2);
		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x04;									//begin conversion and wait until it has finished
		while (adcon0 & 0x04);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		adcon1 = 0x07;
		adcon0 = 0x00;
	}
#endif


// ADC Type 5 Supported Devices ************************************************************
// 12F615, 12HV615, 12F675, 12F683
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_5
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		tris_reg = &trisio;

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					ansel = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					ansel = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					ansel = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x10;
					ansel = 0x08;
					break;
			#endif
		}

		ansel = ansel | ((Conv_Speed & 0x07) << 4);				//assign conversion speed

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on

		if (Vref == 1)											//assign VREF functionality
			st_bit(adcon0, VCFG);

		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x02;									//begin conversion and wait until it has finished
		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		ansel = 0x00;
		adcon0 = 0x00;
	}
#endif


// ADC Type 6 Supported Devices ************************************************************
// 16C72, 16C72A, 16CR72, 16F72, 16C73, 16C73A, 16C73B, 16F73, 16C74, 16C74A, 16C74B, 16F74,
// 16C76, 16F76, 16C77, 16F77, 16C716, 16F716
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_6
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					adcon1 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					adcon1 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					adcon1 = 0x00;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					adcon1 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					adcon1 = 0x00;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x01;
					tris_reg = &trise;
					adcon1 = 0x00;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trise;
					adcon1 = 0x00;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trise;
					adcon1 = 0x00;
					break;
			#endif
		}

		if (Vref != 0)											//assign VREF functionality
			adcon1 = adcon1 + 1;

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Conv_Speed << 6)) | (Channel << 3);	//turn ADC on
		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x04;									//begin conversion and wait until it has finished
		while (adcon0 & 0x04);
		if (Sample_Mode)
		{
			iRetVal = (adres << 2);								//10-bit ADC
		}
		else
			iRetVal = adres;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		adcon1 = 0x07;
		adcon0 = 0x00;
	}
#endif



// ADC Type 7 Supported Devices ************************************************************
// 16F883, 16F884, 16F886, 16F887
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_7
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon1 = 0x00;

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ansel = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ansel = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ansel = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					ansel = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					ansel = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x01;
					tris_reg = &trise;
					ansel = 0x20;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trise;
					ansel = 0x40;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trise;
					ansel = 0x80;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x04;
					tris_reg = &trisb;
					anselh = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x08;
					tris_reg = &trisb;
					anselh = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x02;
					tris_reg = &trisb;
					anselh = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x10;
					tris_reg = &trisb;
					anselh = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_12
				case (13):
					tris_mask = 0x01;
					tris_reg = &trisb;
					anselh = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_13
				case (13):
					tris_mask = 0x20;
					tris_reg = &trisb;
					anselh = 0x20;
					break;
			#endif
		}

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Conv_Speed << 6)) | (Channel << 2);	//turn ADC on

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon0, VCFG0);

		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x02;									//begin conversion and wait until it has finished
		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		ansel = 0x00;
		adcon0 = 0x00;
		#ifdef ANSELH
			anselh = 0x00;
		#endif
	}
#endif


// ADC Type 8 Supported Devices ************************************************************
// 16F785
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_8
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ansel0 = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ansel0 = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ansel0 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x10;
					tris_reg = &trisa;
					ansel0 = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x01;
					tris_reg = &trisc;
					ansel0 = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x02;
					tris_reg = &trisc;
					ansel0 = 0x20;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x04;
					tris_reg = &trisc;
					ansel0 = 0x40;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x08;
					tris_reg = &trisc;
					ansel0 = 0x80;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x40;
					tris_reg = &trisc;
					ansel1 = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x80;
					tris_reg = &trisc;
					ansel1 = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x10;
					tris_reg = &trisb;
					ansel1 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x20;
					tris_reg = &trisb;
					ansel1 = 0x08;
					break;
			#endif
		}

		adcon1 = ((Conv_Speed & 0x07) << 4);					//assign conversion rate

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon0, VCFG);

		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x02;									//begin conversion and wait until it has finished
		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		ansel0 = 0x00;
		adcon0 = 0x00;
		#ifdef ANSEL1
			ansel1 = 0x00;
		#endif
	}
#endif


// ADC Type 9 Supported Devices ************************************************************
// 16F913, 16F914, 16F916, 16F917, 16F946
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_9
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ansel = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ansel = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ansel = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					ansel = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					ansel = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x01;
					tris_reg = &trise;
					ansel = 0x20;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trise;
					ansel = 0x40;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trise;
					ansel = 0x80;
					break;
			#endif
		}

		adcon1 = ((Conv_Speed & 0x07) << 4);					//assign conversion rate

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon0, VCFG0);

		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x02;									//begin conversion and wait until it has finished
		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		adcon0 = 0x00;
		ansel = 0x00;
	}
#endif


// ADC Type 10 Supported Devices ***********************************************************
// 12C671, 12C672, 12CE673, 12CE674
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_10
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		tris_reg = &trisio;

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					if (Vref == 0)
						adcon1 = 0x06;
					else
						adcon1 = 0x05;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					adcon1 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					if (Vref == 0)
						adcon1 = 0x02;
					else
						adcon1 = 0x03;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					if (Vref == 0)
						adcon1 = 0x00;
					else
						adcon1 = 0x01;
					break;
			#endif
		}

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Conv_Speed << 6)) | (Channel << 3);	//turn ADC on
		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x02;									//begin conversion and wait until it has finished
		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adres << 2);								//10-bit ADC
		}
		else
			iRetVal = adres;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		adcon1 = 0x07;
		adcon0 = 0x00;
	}
#endif


// ADC Type 11 Supported Devices ***********************************************************
// 16C717, 16C770, 16C771
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_11
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon1 = 0x00;

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ansel = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ansel = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ansel = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					ansel = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x01;
					tris_reg = &trisb;
					ansel = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x02;
					tris_reg = &trisb;
					ansel = 0x20;
					break;
			#endif
		}

		if (Conv_Speed > 3)										//assign conversion speed
			st_bit(adcon1, ADFM);

		if (Vref != 0)											//assign VREF functionality
		{
			st_bit(adcon1, VCFG0);
			st_bit(adcon1, VCFG1);
		}

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Conv_Speed << 6)) | (Channel << 3);	//turn ADC on
		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x04;									//begin conversion and wait until it has finished
		while (adcon0 & 0x04);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		adcon0 = 0x00;
		ansel = 0x00;
	}
#endif


// ADC Type 12 Supported Devices ***********************************************************
// 18F6310, 18F6390, 18F6410, 18F6490, 18F6520, 18F6527, 18F6585, 18F66J60, 18F66J65,
// 18F6620, 18F6622, 18F6627, 18F6680, 18F67J60, 18F6720, 18F6722, 18F8310, 18F8390,
// 18F8410, 18F8490, 18F8520, 18F8527, 18F8585, 18F86J60, 18F86J65, 18F8620, 18F8622,
// 18F8627, 18F8680, 18F87J60, 18F8720, 18F8722, 18F96J60, 18F96J65, 18F97J60
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_12
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon2 = Conv_Speed & 0x07;								//assign conversion rate

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					adcon1 = 0x0E;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					adcon1 = 0x0D;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					adcon1 = 0x0C;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					adcon1 = 0x0B;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					adcon1 = 0x0A;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x01;
					tris_reg = &trisf;
					adcon1 = 0x09;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trisf;
					adcon1 = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trisf;
					adcon1 = 0x07;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x08;
					tris_reg = &trisf;
					adcon1 = 0x06;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x10;
					tris_reg = &trisf;
					adcon1 = 0x05;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x20;
					tris_reg = &trisf;
					adcon1 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x40;
					tris_reg = &trisf;
					adcon1 = 0x03;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_12
				case (12):
					tris_mask = 0x10;
					tris_reg = &trish;
					adcon1 = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_13
				case (13):
					tris_mask = 0x20;
					tris_reg = &trish;
					adcon1 = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_14
				case (14):
					tris_mask = 0x40;
					tris_reg = &trish;
					adcon1 = 0x00;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_15
				case (15):
					tris_mask = 0x80;
					tris_reg = &trish;
					adcon1 = 0x00;
					break;
			#endif
		}

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon0, VCFG0);

		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x02;									//begin conversion and wait until it has finished
		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		adcon1 = 0x0f;
		adcon0 = 0x00;
	}
#endif


// ADC Type 13 Supported Devices ***********************************************************
// 18F2220, 18F2221, 18F2320, 18F2321, 18F24J10, 18F2410, 18F2420, 18F2423, 18F2450,
// 18F2455, 18F2480, 18F25J10, 18F2510, 18F2515, 18F2520, 18F2523, 18F2525, 18F2550,
// 18F2580, 18F2585, 18F2610, 18F2620, 18F2680, 18F4220, 18F4221, 18F4320, 18F4321,
// 18F44J10, 18F4410, 18F4420, 18F4423, 18F4450, 18F4455, 18F4480, 18F45J10, 18F4510,
// 18F4515, 18F4520, 18F4523, 18F4525, 18F4550, 18F4580, 18F4585, 18F4610, 18F4620,
// 18F4680, 18F4682, 18F4685
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_13
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon2 = Conv_Speed & 0x07;								//assign conversion rate

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					adcon1 = 0x0E;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					adcon1 = 0x0D;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					adcon1 = 0x0C;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					adcon1 = 0x0B;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					adcon1 = 0x0A;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x01;
					tris_reg = &trise;
					adcon1 = 0x09;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trise;
					adcon1 = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trise;
					adcon1 = 0x07;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x04;
					tris_reg = &trisb;
					adcon1 = 0x06;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x08;
					tris_reg = &trisb;
					adcon1 = 0x05;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x02;
					tris_reg = &trisb;
					adcon1 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x10;
					tris_reg = &trisb;
					adcon1 = 0x03;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_12
				case (12):
					tris_mask = 0x01;
					tris_reg = &trisb;
					adcon1 = 0x02;
					break;
			#endif
		}

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon0, VCFG0);

		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x02;									//begin conversion and wait until it has finished
		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
		  #ifdef MX_ADC_BITS_12
			iRetVal = (adresh << 4);							//12-bit ADC
			iRetVal = iRetVal | (adresl >> 4);
		  #else
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		  #endif
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		adcon1 = 0x0f;
		adcon0 = 0x00;
	}
#endif


// ADC Type 14 Supported Devices ***********************************************************
// 18F2331, 18F2431, 18F4331, 18F4431
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_14
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon1 = 0x00;											//set up ADC conversion
		adcon2 = Conv_Speed & 0x07;
		adcon3 = 0x00;
		adchs = 0x00;

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					adcon0 = 0x00;
					ansel0 = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					adcon0 = 0x04;
					ansel0 = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					adcon0 = 0x08;
					ansel0 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					adcon0 = 0x0C;
					ansel0 = 0x08;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x10;
					tris_reg = &trisa;
					adcon0 = 0x00;
					adchs = 0x01;
					ansel0 = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x20;
					tris_reg = &trisa;
					adcon0 = 0x04;
					adchs = 0x10;
					ansel0 = 0x20;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x01;
					tris_reg = &trise;
					adcon0 = 0x08;
					adchs = 0x04;
					ansel0 = 0x40;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x02;
					tris_reg = &trise;
					adcon0 = 0x0C;
					adchs = 0x40;
					ansel0 = 0x80;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x04;
					tris_reg = &trisb;
					adcon0 = 0x00;
					adchs = 0x02;
					ansel1 = 0x01;
					break;
			#endif
		}

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = adcon0 | 0x01;									//turn ADC on

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon0, VCFG0);

		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x02;									//begin conversion and wait until it has finished
		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		adcon0 = 0x00;
		ansel0 = 0x00;
		#ifdef ANSEL1
			ansel1 = 0x00;
		#endif
	}
#endif


// ADC Type 15 Supported Devices ***********************************************************
// 18F1220, 18F1320
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_15
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon2 = Conv_Speed & 0x07;								//assign conversion rate

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					adcon1 = 0x7E;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					adcon1 = 0x7D;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					adcon1 = 0x7B;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					adcon1 = 0x77;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x01;
					tris_reg = &trisb;
					adcon1 = 0x6F;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x02;
					tris_reg = &trisb;
					adcon1 = 0x5F;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x10;
					tris_reg = &trisb;
					adcon1 = 0x3F;
					break;
			#endif
		}

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon0, VCFG0);

		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x02;									//begin conversion and wait until it has finished
		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		adcon1 = 0x7f;
		adcon0 = 0x00;
	}
#endif


// ADC Type 16 Supported Devices ***********************************************************
// 18F242, 18F2439, 18F248, 18F252, 18F2539, 18F258, 18F442, 18F4439, 18F448, 18F452,
// 18F4539, 18F458
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_16
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					if (Vref != 0)
						adcon1 = 0x05;
					else
						adcon1 = 0x0E;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					if (Vref != 0)
						adcon1 = 0x05;
					else
						adcon1 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					if (Vref != 0)
						adcon1 = 0x03;
					else
						adcon1 = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					adcon1 = 0x04;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					if (Vref != 0)
						adcon1 = 0x03;
					else
						adcon1 = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x01;
					tris_reg = &trise;
					if (Vref != 0)
						adcon1 = 0x0A;
					else
						adcon1 = 0x09;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trise;
					if (Vref != 0)
						adcon1 = 0x01;
					else
						adcon1 = 0x00;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trise;
					if (Vref != 0)
						adcon1 = 0x01;
					else
						adcon1 = 0x00;
					break;
			#endif
		}

		if (Conv_Speed > 3)										//assign conversion speed
			st_bit(adcon1, ADCS2);

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Conv_Speed << 6)) | (Channel << 3);	//turn ADC on
		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x04;									//begin conversion and wait until it has finished
		while (adcon0 & 0x04);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		adcon1 = 0x07;
		adcon0 = 0x00;
	}
#endif


// ADC Type 17 Supported Devices ***********************************************************
// 18F1230, 18F1330
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_17
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon2 = Conv_Speed & 0x07;
		adcon1 = 0x00 | (0x01 << Channel);

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x10;
					tris_reg = &trisa;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x40;
					tris_reg = &trisa;
					break;
			#endif
		}

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon1, VCFG0);

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on
		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x02;									//begin conversion and wait until it has finished
		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		adcon1 = 0x00;
		adcon0 = 0x00;
	}
#endif


// ADC Type 18 Supported Devices ***********************************************************
// 16F722, 16F723, 16F724, 16F726, 16F727, 16F1933, 16F1934, 16F1936, 16F1937, 16F1939
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_18

	#ifndef ADREF1
		#define ADREF1 ADPREF1
	#endif

	MX_UINT8 * ansel_reg;					//ANSEL register pointer

	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon1 = (Conv_Speed & 0x07) << 4;						//assign conversion rate

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					ansel_reg = &ansela;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x01;
					tris_reg = &trise;
					ansel_reg = &ansele;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trise;
					ansel_reg = &ansele;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trise;
					ansel_reg = &ansele;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x04;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x08;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x02;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x10;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_12
				case (12):
					tris_mask = 0x01;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_13
				case (13):
					tris_mask = 0x20;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
		}

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon1, ADREF1);

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		*ansel_reg = *ansel_reg | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on
		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x02;									//begin conversion and wait until it has finished
		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		*ansel_reg = 0x00;
		adcon0 = 0x00;
	}
#endif


// ADC Type 19 Supported Devices ***********************************************************
// 18F13K50, 18F14K50, 18LF13K50, 18LF14K50
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_19
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon1 = 0;

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					ansel = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					ansel = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					ansel = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x10;
					tris_reg = &trisa;
					ansel = 0x08;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x01;
					tris_reg = &trisc;
					ansel = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x02;
					tris_reg = &trisc;
					ansel = 0x20;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x04;
					tris_reg = &trisc;
					ansel = 0x40;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x08;
					tris_reg = &trisc;
					adcon1 = 0x80;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x40;
					tris_reg = &trisc;
					anselh = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x80;
					tris_reg = &trisc;
					anselh = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x10;
					tris_reg = &trisb;
					anselh = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x20;
					tris_reg = &trisb;
					anselh = 0x08;
					break;
			#endif
		}

		adcon2 = Conv_Speed & 0x07;								//assign conversion rate

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon1, PVCFG0);

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on
		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x02;									//begin conversion and wait until it has finished
		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		ansel = 0;
		adcon0 = 0x00;
		#ifdef ANSELH
			anselh = 0;
		#endif
	}
#endif


// ADC Type 20 Supported Devices ***********************************************************
// 18F23K20, 18F24K20, 18F25K20, 18F26K20, 18F43K20, 18F44K20, 18F45K20, 18F16K20
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_20
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon1 = 0;

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ansel = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ansel = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ansel = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					ansel = 0x08;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					ansel = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x01;
					tris_reg = &trise;
					ansel = 0x20;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trise;
					ansel = 0x40;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trise;
					adcon1 = 0x80;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x04;
					tris_reg = &trisb;
					anselh = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x08;
					tris_reg = &trisb;
					anselh = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x02;
					tris_reg = &trisb;
					anselh = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x10;
					tris_reg = &trisb;
					anselh = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_12
				case (12):
					tris_mask = 0x01;
					tris_reg = &trisb;
					anselh = 0x10;
					break;
			#endif
		}

		adcon2 = Conv_Speed & 0x07;								//assign conversion rate

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon1, VCFG0);

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on
		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x02;									//begin conversion and wait until it has finished
		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		ansel = 0;
		adcon0 = 0x00;
		#ifdef ANSELH
			anselh = 0;
		#endif
	}
#endif


// ADC Type 21 Supported Devices ***********************************************************
// 18F2xJ11, 18F4xJ11
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_21
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon1 = 0;

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ancon0 = 0xFE;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ancon0 = 0xFD;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ancon0 = 0xFB;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					ancon0 = 0xF7;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					ancon0 = 0xEF;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x01;
					tris_reg = &trise;
					ancon0 = 0xDF;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trise;
					ancon0 = 0xBF;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trise;
					ancon0 = 0x7F;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x04;
					tris_reg = &trisb;
					ancon1 = 0x1E;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x08;
					tris_reg = &trisb;
					ancon1 = 0x1D;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x02;
					tris_reg = &trisb;
					ancon1 = 0x1B;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x10;
					tris_reg = &trisb;
					ancon1 = 0x17;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_12
				case (12):
					tris_mask = 0x01;
					tris_reg = &trisb;
					ancon1 = 0x0F;
					break;
			#endif
		}

		adcon1 = Conv_Speed & 0x07;								//assign conversion rate

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon0, VCFG0);

		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x02;									//begin conversion and wait until it has finished
		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		ancon0 = 0xFF;
		ancon1 = 0x1F;
		adcon0 = 0x00;
	}
#endif


// ADC Type 22 Supported Devices ***********************************************************
// 10F220, 10F222
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_22
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon0 = 0x00;

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					asm("movf 1,w");
					asm("tris 6");
					adcon0 = 0x40;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					asm("movf 2,w");
					asm("tris 6");
					adcon0 = 0x84;
					break;
			#endif
		}

		adcon0 = adcon0 | 0x01;									//turn ADC on
		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x02;									//begin conversion and wait until it has finished
		while (adcon0 & 0x02);
		if (Sample_Mode)
			iRetVal = (adres << 2);								//10-bit ADC
		else
			iRetVal = adres;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		adcon0 = 0x00;											//Reset ADC Registers
	}
#endif


// ADC Type 23 Supported Devices ***********************************************************
// 16F1826, 16F1827
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_23

	MX_UINT8 * ansel_reg;					//ANSEL register pointer

	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon1 = (Conv_Speed & 0x07) << 4;						//assign conversion rate

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					ansel_reg = &ansela;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x10;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x40;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x80;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x20;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x10;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x08;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x04;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x02;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
		}

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon1, ADPREF1);

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		*ansel_reg = *ansel_reg | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on
		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x02;									//begin conversion and wait until it has finished
		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		*ansel_reg = 0x00;
		adcon0 = 0x00;
	}
#endif


// ADC Type 24 Supported Devices ***********************************************************
// 18F65J50, 18F66J50, 18F66J55, 18F67J50, 18F85J50, 18F86J50, 18F86J55, 18F87J50
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_24
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon1 = (Conv_Speed & 0x07);

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ancon0 = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ancon0 = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ancon0 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					ancon0 = 0x08;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					ancon0 = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trisf;
					ancon0 = 0x80;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x20;
					tris_reg = &trisf;
					ancon1 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x40;
					tris_reg = &trisf;
					ancon1 = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_12
				case (12):
					tris_mask = 0x10;
					tris_reg = &trish;
					ancon1 = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_13
				case (13):
					tris_mask = 0x20;
					tris_reg = &trish;
					ancon1 = 0x20;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_14
				case (14):
					tris_mask = 0x40;
					tris_reg = &trish;
					ancon1 = 0x40;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_15
				case (15):
					tris_mask = 0x80;
					tris_reg = &trish;
					ancon1 = 0x80;
					break;
			#endif
		}

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon0, VCFG0);

		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x02;									//begin conversion and wait until it has finished
		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		ancon0 = 0x00;
		ancon1 = 0x00;
		adcon0 = 0x00;
	}
#endif


// ADC Type 25 Supported Devices ***********************************************************
// 18F66J93, 18F67J93, 18F86J93, 18F87J93, 18F66J90, 18F67J90, 18F86J90, 18F87J90
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_25
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon2 = Conv_Speed & 0x07;

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					adcon1 = 0x0E;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					adcon1 = 0x0D;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					adcon1 = 0x0C;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					adcon1 = 0x0B;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					adcon1 = 0x0A;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x80;
					tris_reg = &trisf;
					adcon1 = 0x09;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trisf;
					adcon1 = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trisf;
					adcon1 = 0x07;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x08;
					tris_reg = &trisf;
					adcon1 = 0x06;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x10;
					tris_reg = &trisf;
					adcon1 = 0x05;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x20;
					tris_reg = &trisf;
					adcon1 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x40;
					tris_reg = &trisf;
					adcon1 = 0x03;
					break;
			#endif
		}

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon1, VCFG0);

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on

		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x02;									//begin conversion and wait until it has finished
		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		adcon1 = 0x0f;
		adcon0 = 0x00;
	}
#endif


// ADC Type 26 Supported Devices ***********************************************************
// 16F1822, 16F1823, 16F1824, 16F1825, 16F1828, 16F1829
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_26

	MX_UINT8 * ansel_reg;					//ANSEL register pointer

	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon1 = (Conv_Speed & 0x07) << 4;						//assign conversion rate

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x10;
					tris_reg = &trisa;
					ansel_reg = &ansela;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x01;
					tris_reg = &trisc;
					ansel_reg = &anselc;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x02;
					tris_reg = &trisc;
					ansel_reg = &anselc;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x04;
					tris_reg = &trisc;
					ansel_reg = &anselc;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x08;
					tris_reg = &trisc;
					ansel_reg = &anselc;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x40;
					tris_reg = &trisc;
					ansel_reg = &anselc;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x80;
					tris_reg = &trisc;
					ansel_reg = &anselc;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x10;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x20;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
		}

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon1, ADPREF1);

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		*ansel_reg = *ansel_reg | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on
		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x02;									//begin conversion and wait until it has finished
		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		*ansel_reg = 0x00;
		adcon0 = 0x00;
	}
#endif


// ADC Type 27 Supported Devices ***********************************************************
// 16F1946, 16F1947
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_27

	MX_UINT8 * ansel_reg;					//ANSEL register pointer

	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon1 = (Conv_Speed & 0x07) << 4;						//assign conversion rate

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					ansel_reg = &ansela;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x80;
					tris_reg = &trisf;
					ansel_reg = &anself;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trisf;
					ansel_reg = &anself;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trisf;
					ansel_reg = &anself;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x08;
					tris_reg = &trisf;
					ansel_reg = &anself;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x10;
					tris_reg = &trisf;
					ansel_reg = &anself;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x20;
					tris_reg = &trisf;
					ansel_reg = &anself;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x40;
					tris_reg = &trisf;
					ansel_reg = &anself;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_12
				case (11):
					tris_mask = 0x10;
					tris_reg = &trisg;
					ansel_reg = &anselg;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_13
				case (11):
					tris_mask = 0x08;
					tris_reg = &trisg;
					ansel_reg = &anselg;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_14
				case (11):
					tris_mask = 0x04;
					tris_reg = &trisg;
					ansel_reg = &anselg;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_15
				case (11):
					tris_mask = 0x02;
					tris_reg = &trisg;
					ansel_reg = &anselg;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_16
				case (11):
					tris_mask = 0x01;
					tris_reg = &trisg;
					ansel_reg = &anselg;
					break;
			#endif
		}

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon1, ADPREF1);

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		*ansel_reg = *ansel_reg | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on
		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x02;									//begin conversion and wait until it has finished
		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		*ansel_reg = 0x00;
		adcon0 = 0x00;
	}
#endif


// ADC Type 28 Supported Devices ***********************************************************
// 18F65K22, 18F66K22, 18F67K22, 18F85K22, 18F86K22, 18F87K22,
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_28
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon2 = Conv_Speed & 0x07;

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ancon0 = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ancon0 = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ancon0 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					ancon0 = 0x08;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					ancon0 = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x80;
					tris_reg = &trisf;
					ancon0 = 0x20;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trisf;
					ancon0 = 0x40;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trisf;
					ancon0 = 0x80;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x08;
					tris_reg = &trisf;
					ancon1 = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x10;
					tris_reg = &trisf;
					ancon1 = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x20;
					tris_reg = &trisf;
					ancon1 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x40;
					tris_reg = &trisf;
					ancon1 = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_12
				case (12):
					tris_mask = 0x10;
					tris_reg = &trish;
					ancon1 = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_13
				case (13):
					tris_mask = 0x20;
					tris_reg = &trish;
					ancon1 = 0x20;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_14
				case (14):
					tris_mask = 0x40;
					tris_reg = &trish;
					ancon1 = 0x40;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_15
				case (15):
					tris_mask = 0x80;
					tris_reg = &trish;
					ancon1 = 0x80;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_16
				case (16):
					tris_mask = 0x10;
					tris_reg = &trisg;
					ancon2 = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_17
				case (17):
					tris_mask = 0x08;
					tris_reg = &trisg;
					ancon2 = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_18
				case (18):
					tris_mask = 0x04;
					tris_reg = &trisg;
					ancon2 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_19
				case (19):
					tris_mask = 0x02;
					tris_reg = &trisg;
					ancon2 = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_20
				case (20):
					tris_mask = 0x08;
					tris_reg = &trish;
					ancon2 = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_21
				case (21):
					tris_mask = 0x04;
					tris_reg = &trish;
					ancon2 = 0x20;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_22
				case (22):
					tris_mask = 0x02;
					tris_reg = &trish;
					ancon2 = 0x40;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_23
				case (23):
					tris_mask = 0x01;
					tris_reg = &trish;
					ancon2 = 0x80;
					break;
			#endif
		}

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon1, VCFG0);

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on

		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x02;									//begin conversion and wait until it has finished
		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 4);							//12-bit ADC
			iRetVal = iRetVal | (adresl >> 4);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		adcon0 = 0x00;
		ancon0 = 0x00;
		#ifdef ANCON1
			ancon1 = 0x00;
		#endif
		#ifdef ANCON2
			ancon2 = 0x00;
		#endif
	}
#endif


// ADC Type 29 Supported Devices ***********************************************************
// 18F23K22, 18F24K22, 18F25K22, 18F26K22, 18F43K22, 18F44K22, 18F45K22, 18F46K22,
// 18LF23K22, 18LF24K22, 18LF25K22, 18LF26K22, 18LF43K22, 18LF44K22, 18LF45K22, 18LF46K22,
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_29

	MX_UINT8 * ansel_reg;					//ANSEL register pointer

	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon2 = Conv_Speed & 0x07;

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					ansel_reg = &ansela;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x01;
					tris_reg = &trise;
					ansel_reg = &ansele;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trise;
					ansel_reg = &ansele;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trise;
					ansel_reg = &ansele;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x04;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x08;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x02;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x10;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_12
				case (12):
					tris_mask = 0x01;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_13
				case (13):
					tris_mask = 0x20;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_14
				case (14):
					tris_mask = 0x04;
					tris_reg = &trisc;
					ansel_reg = &anselc;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_15
				case (15):
					tris_mask = 0x08;
					tris_reg = &trisc;
					ansel_reg = &anselc;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_16
				case (16):
					tris_mask = 0x10;
					tris_reg = &trisc;
					ansel_reg = &anselc;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_17
				case (17):
					tris_mask = 0x20;
					tris_reg = &trisc;
					ansel_reg = &anselc;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_18
				case (18):
					tris_mask = 0x40;
					tris_reg = &trisc;
					ansel_reg = &anselc;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_19
				case (19):
					tris_mask = 0x80;
					tris_reg = &trisc;
					ansel_reg = &anselc;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_20
				case (20):
					tris_mask = 0x01;
					tris_reg = &trisd;
					ansel_reg = &anseld;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_21
				case (21):
					tris_mask = 0x02;
					tris_reg = &trisd;
					ansel_reg = &anseld;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_22
				case (22):
					tris_mask = 0x04;
					tris_reg = &trisd;
					ansel_reg = &anseld;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_23
				case (23):
					tris_mask = 0x08;
					tris_reg = &trisd;
					ansel_reg = &anseld;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_24
				case (24):
					tris_mask = 0x10;
					tris_reg = &trisd;
					ansel_reg = &anseld;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_25
				case (25):
					tris_mask = 0x20;
					tris_reg = &trisd;
					ansel_reg = &anseld;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_26
				case (26):
					tris_mask = 0x40;
					tris_reg = &trisd;
					ansel_reg = &anseld;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_27
				case (27):
					tris_mask = 0x80;
					tris_reg = &trisd;
					ansel_reg = &anseld;
					break;
			#endif
		}

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon1, PVCFG0);

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		*ansel_reg = ansel_reg | tris_mask;

		adcon0 = (0x01 | (Channel << 2));						//turn ADC on

		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x02;									//begin conversion and wait until it has finished
		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		*ansel_reg = 0x00;
		adcon0 = 0x00;
	}
#endif


// ADC Type 30 Supported Devices ************************************************************
// 16F870, 16F871, 16F872, 16F873, 16F874, 16F876, 16F877
// *******************************************************************************************/

#ifdef MX_ADC_TYPE_30
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					if (Vref == 0)
						adcon1 = 0x0E;
					else
						adcon1 = 0x05;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					if (Vref == 0)
						adcon1 = 0x04;
					else
						adcon1 = 0x05;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					if (Vref == 0)
						adcon1 = 0x02;
					else
						adcon1 = 0x03;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					if (Vref == 0)
						adcon1 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					if (Vref == 0)
						adcon1 = 0x02;
					else
						adcon1 = 0x03;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x01;
					tris_reg = &trise;
					if (Vref == 0)
						adcon1 = 0x09;
					else
						adcon1 = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trise;
					if (Vref == 0)
						adcon1 = 0x00;
					else
						adcon1 = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trise;
					if (Vref == 0)
						adcon1 = 0x00;
					else
						adcon1 = 0x01;
					break;
			#endif
		}

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Conv_Speed << 6)) | (Channel << 3);	//turn ADC on
		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x04;									//begin conversion and wait until it has finished
		while (adcon0 & 0x04);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		adcon1 = 0x07;
		adcon0 = 0x00;
	}
#endif

/*********************************************************************
 *                  Flowcode CAL I2C File
 *
 * File: PIC_CAL_I2C.c
 *
 * (c) 2011 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * Company) for its Flowcode graphical programming language is
 * intended and supplied to you, the Companys customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 210911 | BR | Created
 * 021211 | BR | Converted to new dynamic defines mechanism
 *
 */


//When using hardware I2C channels override port and pin conns with FCD conn definitions
#ifdef MX_I2C_REF1
	#if MX_I2C_CHANNEL_1 > 0
		#undef MX_I2C_SDA_PIN_1
		#undef MX_I2C_SDA_PORT_1
		#undef MX_I2C_SDA_TRIS_1
		#undef MX_I2C_SCL_PIN_1
		#undef MX_I2C_SCL_PORT_1
		#undef MX_I2C_SCL_TRIS_1
	#endif
	#if MX_I2C_CHANNEL_1 == 1
		#define MX_I2C_SDA_PIN_1		MX_I2C_1_SDA_PIN
		#define MX_I2C_SDA_PORT_1		MX_I2C_1_SDA_PORT
		#define MX_I2C_SDA_TRIS_1		MX_I2C_1_SDA_TRIS
		#define MX_I2C_SCL_PIN_1		MX_I2C_1_SCL_PIN
		#define MX_I2C_SCL_PORT_1		MX_I2C_1_SCL_PORT
		#define MX_I2C_SCL_TRIS_1		MX_I2C_1_SCL_TRIS
	#endif
	#if MX_I2C_CHANNEL_1 == 2
		#define MX_I2C_SDA_PIN_1		MX_I2C_2_SDA_PIN
		#define MX_I2C_SDA_PORT_1		MX_I2C_2_SDA_PORT
		#define MX_I2C_SDA_TRIS_1		MX_I2C_2_SDA_TRIS
		#define MX_I2C_SCL_PIN_1		MX_I2C_2_SCL_PIN
		#define MX_I2C_SCL_PORT_1		MX_I2C_2_SCL_PORT
		#define MX_I2C_SCL_TRIS_1		MX_I2C_2_SCL_TRIS
	#endif
	#if MX_I2C_CHANNEL_1 == 3
		#define MX_I2C_SDA_PIN_1		MX_I2C_3_SDA_PIN
		#define MX_I2C_SDA_PORT_1		MX_I2C_3_SDA_PORT
		#define MX_I2C_SDA_TRIS_1		MX_I2C_3_SDA_TRIS
		#define MX_I2C_SCL_PIN_1		MX_I2C_3_SCL_PIN
		#define MX_I2C_SCL_PORT_1		MX_I2C_3_SCL_PORT
		#define MX_I2C_SCL_TRIS_1		MX_I2C_3_SCL_TRIS
	#endif
	#if MX_I2C_CHANNEL_1 == 4
		#define MX_I2C_SDA_PIN_1		MX_I2C_4_SDA_PIN
		#define MX_I2C_SDA_PORT_1		MX_I2C_4_SDA_PORT
		#define MX_I2C_SDA_TRIS_1		MX_I2C_4_SDA_TRIS
		#define MX_I2C_SCL_PIN_1		MX_I2C_4_SCL_PIN
		#define MX_I2C_SCL_PORT_1		MX_I2C_4_SCL_PORT
		#define MX_I2C_SCL_TRIS_1		MX_I2C_4_SCL_TRIS
	#endif
#endif
#ifdef MX_I2C_REF2
	#if MX_I2C_CHANNEL_2 > 0
		#undef MX_I2C_SDA_PIN_2
		#undef MX_I2C_SDA_PORT_2
		#undef MX_I2C_SDA_TRIS_2
		#undef MX_I2C_SCL_PIN_2
		#undef MX_I2C_SCL_PORT_2
		#undef MX_I2C_SCL_TRIS_2
	#endif
	#if MX_I2C_CHANNEL_2 == 1
		#define MX_I2C_SDA_PIN_2		MX_I2C_1_SDA_PIN
		#define MX_I2C_SDA_PORT_2		MX_I2C_1_SDA_PORT
		#define MX_I2C_SDA_TRIS_2		MX_I2C_1_SDA_TRIS
		#define MX_I2C_SCL_PIN_2		MX_I2C_1_SCL_PIN
		#define MX_I2C_SCL_PORT_2		MX_I2C_1_SCL_PORT
		#define MX_I2C_SCL_TRIS_2		MX_I2C_1_SCL_TRIS
	#endif
	#if MX_I2C_CHANNEL_2 == 2
		#define MX_I2C_SDA_PIN_2		MX_I2C_2_SDA_PIN
		#define MX_I2C_SDA_PORT_2		MX_I2C_2_SDA_PORT
		#define MX_I2C_SDA_TRIS_2		MX_I2C_2_SDA_TRIS
		#define MX_I2C_SCL_PIN_2		MX_I2C_2_SCL_PIN
		#define MX_I2C_SCL_PORT_2		MX_I2C_2_SCL_PORT
		#define MX_I2C_SCL_TRIS_2		MX_I2C_2_SCL_TRIS
	#endif
	#if MX_I2C_CHANNEL_2 == 3
		#define MX_I2C_SDA_PIN_2		MX_I2C_3_SDA_PIN
		#define MX_I2C_SDA_PORT_2		MX_I2C_3_SDA_PORT
		#define MX_I2C_SDA_TRIS_2		MX_I2C_3_SDA_TRIS
		#define MX_I2C_SCL_PIN_2		MX_I2C_3_SCL_PIN
		#define MX_I2C_SCL_PORT_2		MX_I2C_3_SCL_PORT
		#define MX_I2C_SCL_TRIS_2		MX_I2C_3_SCL_TRIS
	#endif
	#if MX_I2C_CHANNEL_2 == 4
		#define MX_I2C_SDA_PIN_2		MX_I2C_4_SDA_PIN
		#define MX_I2C_SDA_PORT_2		MX_I2C_4_SDA_PORT
		#define MX_I2C_SDA_TRIS_2		MX_I2C_4_SDA_TRIS
		#define MX_I2C_SCL_PIN_2		MX_I2C_4_SCL_PIN
		#define MX_I2C_SCL_PORT_2		MX_I2C_4_SCL_PORT
		#define MX_I2C_SCL_TRIS_2		MX_I2C_4_SCL_TRIS
	#endif
#endif
#ifdef MX_I2C_REF3
	#if MX_I2C_CHANNEL_3 > 0
		#undef MX_I2C_SDA_PIN_3
		#undef MX_I2C_SDA_PORT_3
		#undef MX_I2C_SDA_TRIS_3
		#undef MX_I2C_SCL_PIN_3
		#undef MX_I2C_SCL_PORT_3
		#undef MX_I2C_SCL_TRIS_3
	#endif
	#if MX_I2C_CHANNEL_3 == 1
		#define MX_I2C_SDA_PIN_3		MX_I2C_1_SDA_PIN
		#define MX_I2C_SDA_PORT_3		MX_I2C_1_SDA_PORT
		#define MX_I2C_SDA_TRIS_3		MX_I2C_1_SDA_TRIS
		#define MX_I2C_SCL_PIN_3		MX_I2C_1_SCL_PIN
		#define MX_I2C_SCL_PORT_3		MX_I2C_1_SCL_PORT
		#define MX_I2C_SCL_TRIS_3		MX_I2C_1_SCL_TRIS
	#endif
	#if MX_I2C_CHANNEL_3 == 2
		#define MX_I2C_SDA_PIN_3		MX_I2C_2_SDA_PIN
		#define MX_I2C_SDA_PORT_3		MX_I2C_2_SDA_PORT
		#define MX_I2C_SDA_TRIS_3		MX_I2C_2_SDA_TRIS
		#define MX_I2C_SCL_PIN_3		MX_I2C_2_SCL_PIN
		#define MX_I2C_SCL_PORT_3		MX_I2C_2_SCL_PORT
		#define MX_I2C_SCL_TRIS_3		MX_I2C_2_SCL_TRIS
	#endif
	#if MX_I2C_CHANNEL_3 == 3
		#define MX_I2C_SDA_PIN_3		MX_I2C_3_SDA_PIN
		#define MX_I2C_SDA_PORT_3		MX_I2C_3_SDA_PORT
		#define MX_I2C_SDA_TRIS_3		MX_I2C_3_SDA_TRIS
		#define MX_I2C_SCL_PIN_3		MX_I2C_3_SCL_PIN
		#define MX_I2C_SCL_PORT_3		MX_I2C_3_SCL_PORT
		#define MX_I2C_SCL_TRIS_3		MX_I2C_3_SCL_TRIS
	#endif
	#if MX_I2C_CHANNEL_3 == 4
		#define MX_I2C_SDA_PIN_3		MX_I2C_4_SDA_PIN
		#define MX_I2C_SDA_PORT_3		MX_I2C_4_SDA_PORT
		#define MX_I2C_SDA_TRIS_3		MX_I2C_4_SDA_TRIS
		#define MX_I2C_SCL_PIN_3		MX_I2C_4_SCL_PIN
		#define MX_I2C_SCL_PORT_3		MX_I2C_4_SCL_PORT
		#define MX_I2C_SCL_TRIS_3		MX_I2C_4_SCL_TRIS
	#endif
#endif
#ifdef MX_I2C_REF4
	#if MX_I2C_CHANNEL_4 > 0
		#undef MX_I2C_SDA_PIN_4
		#undef MX_I2C_SDA_PORT_4
		#undef MX_I2C_SDA_TRIS_4
		#undef MX_I2C_SCL_PIN_4
		#undef MX_I2C_SCL_PORT_4
		#undef MX_I2C_SCL_TRIS_4
	#endif
	#if MX_I2C_CHANNEL_4 == 1
		#define MX_I2C_SDA_PIN_4		MX_I2C_1_SDA_PIN
		#define MX_I2C_SDA_PORT_4		MX_I2C_1_SDA_PORT
		#define MX_I2C_SDA_TRIS_4		MX_I2C_1_SDA_TRIS
		#define MX_I2C_SCL_PIN_4		MX_I2C_1_SCL_PIN
		#define MX_I2C_SCL_PORT_4		MX_I2C_1_SCL_PORT
		#define MX_I2C_SCL_TRIS_4		MX_I2C_1_SCL_TRIS
	#endif
	#if MX_I2C_CHANNEL_4 == 2
		#define MX_I2C_SDA_PIN_4		MX_I2C_2_SDA_PIN
		#define MX_I2C_SDA_PORT_4		MX_I2C_2_SDA_PORT
		#define MX_I2C_SDA_TRIS_4		MX_I2C_2_SDA_TRIS
		#define MX_I2C_SCL_PIN_4		MX_I2C_2_SCL_PIN
		#define MX_I2C_SCL_PORT_4		MX_I2C_2_SCL_PORT
		#define MX_I2C_SCL_TRIS_4		MX_I2C_2_SCL_TRIS
	#endif
	#if MX_I2C_CHANNEL_4 == 3
		#define MX_I2C_SDA_PIN_4		MX_I2C_3_SDA_PIN
		#define MX_I2C_SDA_PORT_4		MX_I2C_3_SDA_PORT
		#define MX_I2C_SDA_TRIS_4		MX_I2C_3_SDA_TRIS
		#define MX_I2C_SCL_PIN_4		MX_I2C_3_SCL_PIN
		#define MX_I2C_SCL_PORT_4		MX_I2C_3_SCL_PORT
		#define MX_I2C_SCL_TRIS_4		MX_I2C_3_SCL_TRIS
	#endif
	#if MX_I2C_CHANNEL_4 == 4
		#define MX_I2C_SDA_PIN_4		MX_I2C_4_SDA_PIN
		#define MX_I2C_SDA_PORT_4		MX_I2C_4_SDA_PORT
		#define MX_I2C_SDA_TRIS_4		MX_I2C_4_SDA_TRIS
		#define MX_I2C_SCL_PIN_4		MX_I2C_4_SCL_PIN
		#define MX_I2C_SCL_PORT_4		MX_I2C_4_SCL_PORT
		#define MX_I2C_SCL_TRIS_4		MX_I2C_4_SCL_TRIS
	#endif
#endif

#define MX_I2C_CHANNEL_X		CAL_APPEND(MX_I2C_CHANNEL_, MX_I2C_NUM)
#define MX_I2C_SDA_PIN_X		CAL_APPEND(MX_I2C_SDA_PIN_, MX_I2C_NUM)
#define MX_I2C_SDA_PORT_X		CAL_APPEND(MX_I2C_SDA_PORT_, MX_I2C_NUM)
#define MX_I2C_SDA_TRIS_X		CAL_APPEND(MX_I2C_SDA_TRIS_, MX_I2C_NUM)
#define MX_I2C_SCL_PIN_X		CAL_APPEND(MX_I2C_SCL_PIN_, MX_I2C_NUM)
#define MX_I2C_SCL_PORT_X		CAL_APPEND(MX_I2C_SCL_PORT_, MX_I2C_NUM)
#define MX_I2C_SCL_TRIS_X		CAL_APPEND(MX_I2C_SCL_TRIS_, MX_I2C_NUM)
#define MX_I2C_BMODE_X			CAL_APPEND(MX_I2C_BMODE_, MX_I2C_NUM)
#define MX_I2C_BAUD_X			CAL_APPEND(MX_I2C_BAUD_, MX_I2C_NUM)
#define MX_I2C_INT_X			CAL_APPEND(MX_I2C_INT_, MX_I2C_NUM)


//Function Prototypes
CALFUNCTION(void, FC_CAL_I2C_Master_Init_, (void));
CALFUNCTION(void, FC_CAL_I2C_Master_Uninit_, (void));
CALFUNCTION(void, FC_CAL_I2C_Master_Start_, (void));
CALFUNCTION(void, FC_CAL_I2C_Master_Restart_, (void));
CALFUNCTION(void, FC_CAL_I2C_Master_Stop_, (void));
CALFUNCTION(MX_UINT8, FC_CAL_I2C_Master_TX_Byte_, (MX_UINT8 Data));
CALFUNCTION(MX_UINT8, FC_CAL_I2C_Master_RX_Byte_, (MX_UINT8 Last));

CALFUNCTION(void, FC_CAL_I2C_Slave_Init_, (void));
CALFUNCTION(void, FC_CAL_I2C_Slave_Uninit_, (void));
CALFUNCTION(void, FC_CAL_I2C_Slave_SetTxData_, (MX_UINT8 Data));
CALFUNCTION(MX_UINT8, FC_CAL_I2C_Slave_GetRxData_, (MX_UINT8 Last));


//Ensure SSPCON register is defined correctly
#ifndef SSPCON
  #ifdef SSPCON1
	#define sspcon	sspcon1
  #else
	#ifdef SSP1CON1
		#define sspcon	ssp1con1
	#endif
  #endif
#endif

//Ensure SSPIF register is defined correctly
#ifndef SSPIF
  #ifdef SSP1IF
	#define SSPIF	SSP1IF
  #else
	#error "I2C does not have the SSPIF defined on this chip - does your chip support this feature?"
  #endif
#endif


//Ensure SSPCON2 register is defined correctly
#ifndef SSPCON2
  #ifdef SSP1CON2
	#define sspcon2	ssp1con2
  #endif
#endif


//Ensure SSPSTAT register is defined correctly
#ifndef SSPSTAT
  #ifdef SSP1STAT
	#define sspstat	ssp1stat
  #endif
#endif


//Ensure SSPADD register is defined correctly
#ifndef SSPADD
  #ifdef SSP1ADD
	#define sspadd	ssp1add
  #endif
#endif


//Ensure SSPBUFF register is defined correctly
#ifndef SSPBUFF
  #ifdef SSP1BUFF
	#define sspbuff	ssp1buff
  #endif
#endif


//If software channel is enabled then define bit delay.
#if (MX_I2C_CHANNEL_X == 0)
  #ifndef MX_I2C_SW_DEL
	#define MX_I2C_SW_DEL
	#define MX_I2C_DELAY	delay_us(20);
  #endif
#endif


CALFUNCTION(void, FC_CAL_I2C_Master_Init_, (void))

{

	#if (MX_I2C_CHANNEL_X == 0)															//Use Master I2C Software
		FC_CAL_Bit_In_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);		//Configure SDA as Input
		FC_CAL_Bit_In_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);		//Configure SCL as Input
	#endif

	#if (MX_I2C_CHANNEL_X == 1)												//Use Master I2C Hardware 1
		#ifndef MX_MI2C
			#error "This chip does not have Master I2C capability"
		#else

			#ifndef MX_I2C_1
				#error "This chip does not have Master I2C channel 1"
			#endif

			#if (MX_I2C_BMODE_X & 0x01)
				cr_bit (sspstat,SMP);										//Slew Rate Control Enabled
			#else
				st_bit (sspstat,SMP);										//Slew Rate Control Disabled
0341  1683  	BSF STATUS, RP0
0342  1303  	BCF STATUS, RP1
0343  1794  	BSF gbl_sspstat,7

		    #endif

			#if (MX_I2C_BMODE_X & 0x02)
				st_bit (sspstat,CKE);										//Enable SMBus specific inputs
			#else
				cr_bit (sspstat,CKE);										//Disable SMBus specific inputs
0344  1314  	BCF gbl_sspstat,6

			#endif

			sspcon = 0x28;													//Setup I2C into Master Mode
0345  3028  	MOVLW 0x28
0346  1283  	BCF STATUS, RP0
0347  0094  	MOVWF gbl_sspcon

			sspadd = MX_I2C_BAUD_X;											//Set the Baud Rate
0348  30A0  	MOVLW 0xA0
0349  1683  	BSF STATUS, RP0
034A  0093  	MOVWF gbl_sspadd

			sspcon2 = 0x00;													//Clear the control bits
034B  0191  	CLRF gbl_sspcon2

			st_bit(intcon, GIE);
034C  178B  	BSF gbl_intcon,7

			FC_CAL_Bit_In_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);		//Configure SDA as Input
034D  1607  	BSF gbl_trisc,4

			FC_CAL_Bit_In_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);		//Configure SCL as Input
034E  1587  	BSF gbl_trisc,3

		#endif
	#endif

	#if (MX_I2C_CHANNEL_X == 2)												//Use Master I2C Hardware 2
		#ifndef MX_MI2C
			#error "This chip does not have Master I2C capability"
		#else

			#ifndef MX_I2C_2
				#error "This chip does not have Master I2C channel 2"
			#endif

		  #ifdef MX_I2C_2_REMAPPABLE
			RPOR4 = 9;														//SDA2 - RB1 - RP4
			RPOR5 = 10;														//SCL2 - RB2 - RP5
		  #endif

			#if (MX_I2C_BMODE_X & 0x01)
				cr_bit (ssp2stat,SMP);										//Slew Rate Control Enabled
			#else
				st_bit (ssp2stat,SMP);										//Slew Rate Control Disabled
			#endif

			#if (MX_I2C_BMODE_X & 0x02)
				st_bit (ssp2stat,CKE);										//Enable SMBus specific inputs
			#else
				cr_bit (ssp2stat,CKE);										//Disable SMBus specific inputs
			#endif

			ssp2con = 0x28;													//Setup I2C into Master Mode
			ssp2add = MX_I2C_BAUD_X;										//Set the Baud Rate
			ssp2con2 = 0x00;												//Clear the control bits
			st_bit(intcon, GIE);
			FC_CAL_Bit_In_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);			//Configure SDA as Input
			FC_CAL_Bit_In_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);			//Configure SCL as Input
		#endif
	#endif
}
034F  0008  	RETURN


CALFUNCTION(void, FC_CAL_I2C_Master_Uninit_, (void))
{
	#if (MX_I2C_CHANNEL_X == 0)																//Use Master I2C Software
		FC_CAL_Bit_In_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);			//Configure SDA as Input
		FC_CAL_Bit_In_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);			//Configure SCL as Input
	#endif

	#if (MX_I2C_CHANNEL_X == 1)												//Use Master I2C Hardware 1
		cr_bit(sspcon, SSPEN);												//Disable SSP
	#endif

	#if (MX_I2C_CHANNEL_X == 2)												//Use Master I2C Hardware 2
		cr_bit(ssp2con, SSPEN);												//Disable SSP
	#endif
}

CALFUNCTION(void, FC_CAL_I2C_Master_Start_, (void))

{
	#if (MX_I2C_CHANNEL_X == 0)															//Use Master I2C Software
		FC_CAL_Bit_In_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);		//Make Sure SCL is Set
		FC_CAL_Bit_In_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);		//Make Sure SDA is Set
		MX_I2C_DELAY;																	//Small Delay
		FC_CAL_Bit_Low_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);		//Clear SDA
		MX_I2C_DELAY;																	//Small Delay
		FC_CAL_Bit_Low_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);		//Clear SCL
		MX_I2C_DELAY;																	//Small Delay
	#endif

	#if (MX_I2C_CHANNEL_X == 1)												//Use Master I2C Hardware 1
		cr_bit(pir1, SSPIF);												//Clear SSP interrupt flag
028F  1283  	BCF STATUS, RP0
0290  1303  	BCF STATUS, RP1
0291  118C  	BCF gbl_pir1,3

		st_bit(sspcon2,SEN);												//Initiate start condition
0292  1683  	BSF STATUS, RP0
0293  1411  	BSF gbl_sspcon2,0

		while(ts_bit(sspcon2,SEN));											//Wait for start bit to be generated
0294        label37
0294  1811  	BTFSC gbl_sspcon2,0
0295  2A94  	GOTO	label37

	#endif

	#if (MX_I2C_CHANNEL_X == 2)												//Use Master I2C Hardware 2
		cr_bit(pir3, SSP2IF);												//Clear SSP interrupt flag
		st_bit(ssp2con2,SEN);												//Initiate start condition
		while(ts_bit(ssp2con2,SEN));										//Wait for start bit to be generated
	#endif
}
0296  0008  	RETURN


CALFUNCTION(void, FC_CAL_I2C_Master_Restart_, (void))

{
	#if (MX_I2C_CHANNEL_X == 0)															//Use Master I2C Software
		FC_CAL_Bit_In_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);		//Set SDA High
		MX_I2C_DELAY;
		FC_CAL_Bit_In_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);		//Set SCL High
		MX_I2C_DELAY;
		FC_CAL_Bit_Low_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);		//Set SDA Low
		MX_I2C_DELAY;
		FC_CAL_Bit_Low_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);		//Set SCL Low
		MX_I2C_DELAY;
	#endif

	#if (MX_I2C_CHANNEL_X == 1)												//Use Master I2C Hardware 1
		cr_bit(pir1, SSPIF);												//Clear SSP interrupt flag
0287  1283  	BCF STATUS, RP0
0288  1303  	BCF STATUS, RP1
0289  118C  	BCF gbl_pir1,3

		st_bit(sspcon2,RSEN);												//Initiate restart condition
028A  1683  	BSF STATUS, RP0
028B  1491  	BSF gbl_sspcon2,1

		while(ts_bit(sspcon2,RSEN));										//Wait for restart bit to be generated
028C        label36
028C  1891  	BTFSC gbl_sspcon2,1
028D  2A8C  	GOTO	label36

	#endif

	#if (MX_I2C_CHANNEL_X == 2)												//Use Master I2C Hardware 2
		cr_bit(pir3, SSP2IF);												//Clear SSP interrupt flag
		st_bit(ssp2con2,RSEN);												//Initiate restart condition
		while(ts_bit(ssp2con2,RSEN));										//Wait for restart bit to be generated
	#endif
}
028E  0008  	RETURN


CALFUNCTION(void, FC_CAL_I2C_Master_Stop_, (void))

{
	#if (MX_I2C_CHANNEL_X == 0)															//Use Master I2C Software
		FC_CAL_Bit_Low_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);		//Set SCL Low
		FC_CAL_Bit_Low_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);		//Set SDA Low
		MX_I2C_DELAY;
		FC_CAL_Bit_In_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);		//Set SCL High
		MX_I2C_DELAY;
		FC_CAL_Bit_In_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);		//Set SDA High
	#endif

	#if (MX_I2C_CHANNEL_X == 1)												//Use Master I2C Hardware 1
		cr_bit(pir1,SSPIF);													//Clear SSP interrupt flag
027B  1283  	BCF STATUS, RP0
027C  1303  	BCF STATUS, RP1
027D  118C  	BCF gbl_pir1,3

		st_bit(sspcon2,PEN);												//Initiate stop condition
027E  1683  	BSF STATUS, RP0
027F  1511  	BSF gbl_sspcon2,2

		while(ts_bit(sspcon2,PEN));											//Wait for stop bit to be generated
0280        label35
0280  1911  	BTFSC gbl_sspcon2,2
0281  2A80  	GOTO	label35

	#endif

	#if (MX_I2C_CHANNEL_X == 2)												//Use Master I2C Hardware 2
		cr_bit(pir3,SSP2IF);												//Clear SSP interrupt flag
		st_bit(ssp2con2,PEN);												//Initiate stop condition
		while(ts_bit(ssp2con2,PEN));										//Wait for stop bit to be generated
	#endif

  delay_ms(10);																//Wait before reusing the I2C BUS
0282  300A  	MOVLW 0x0A
0283  1283  	BCF STATUS, RP0
0284  00FE  	MOVWF delay_ms_00000_arg_del
0285  201A  	CALL delay_ms_00000

}
0286  0008  	RETURN


CALFUNCTION(MX_UINT8, FC_CAL_I2C_Master_TX_Byte_, (MX_UINT8 Data))

{
	#if (MX_I2C_CHANNEL_X == 0)												//Use Master I2C Software
		char bit_mask;
		char local_ack = 0;
		for(bit_mask=0x80;bit_mask;bit_mask=bit_mask>>1)
		{
			if(Data & bit_mask)
			{
				FC_CAL_Bit_In_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);	//Set SDA High
			}
			else
			{
				FC_CAL_Bit_Low_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);	//Set SDA Low
			}
			MX_I2C_DELAY;
			FC_CAL_Bit_In_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);		//Set SCL High
			MX_I2C_DELAY;
			FC_CAL_Bit_Low_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);		//Set SCL Low
			MX_I2C_DELAY;
		}
		FC_CAL_Bit_In_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);			//Set SDA High
		MX_I2C_DELAY;
		FC_CAL_Bit_In_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);			//Set SCL High
		MX_I2C_DELAY;
		FC_CAL_Bit_In_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);
		if (FC_CAL_Bit_In(MX_I2C_SDA_PORT_X, MX_I2C_SDA_PIN_X))		//Get the Status Bit
			local_ack = 1;
		MX_I2C_DELAY;
		FC_CAL_Bit_Low_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);			//Set SCL Low
		MX_I2C_DELAY;
		return (local_ack);													//0 = Ack received : 1 = Ack not received
	#endif

	#if (MX_I2C_CHANNEL_X == 1)												//Use Master I2C Hardware 1
		cr_bit(pir1,SSPIF);													//Clear SSP interrupt flag
026C  118C  	BCF gbl_pir1,3

		sspbuf=Data;														//Send byte
026D  087C  	MOVF FC_CAL_I2C_00066_arg_Data, W
026E  0093  	MOVWF gbl_sspbuf

		while(ts_bit(pir1,SSPIF) == 0);										//Wait for control bit to be sent
026F        label33
026F  1D8C  	BTFSS gbl_pir1,3
0270  2A6F  	GOTO	label33

		if(ts_bit(sspcon2,ACKSTAT))											//Check Acknowledgement
0271  1683  	BSF STATUS, RP0
0272  1F11  	BTFSS gbl_sspcon2,6
0273  2A78  	GOTO	label34
0278        label34

			return (1);														//No Acknowledgement
0274  3001  	MOVLW 0x01
0275  1283  	BCF STATUS, RP0
0276  00FD  	MOVWF CompTempVarRet2254

		else return (0);													//Acknowledgement received
0278  1283  	BCF STATUS, RP0
0279  01FD  	CLRF CompTempVarRet2254

	#endif

	#if (MX_I2C_CHANNEL_X == 2)												//Use Master I2C Hardware 2
		cr_bit(pir3,SSP2IF);												//Clear SSP interrupt flag
		ssp2buf=Data;														//Send byte
		while(ts_bit(pir3,SSP2IF) == 0);									//Wait for control bit to be sent
		if(ts_bit(ssp2con2,ACKSTAT))										//Check Acknowledgement
			return (1);														//No Acknowledgement
		else return (0);													//Acknowledgement received
	#endif
}
0277  0008  	RETURN
027A  0008  	RETURN


CALFUNCTION(MX_UINT8, FC_CAL_I2C_Master_RX_Byte_, (MX_UINT8 Last))

{
	#if (MX_I2C_CHANNEL_X == 0)												//Use Master I2C Software
		char bit_mask;
		char Data = 0;
		char local_ack;
		FC_CAL_Bit_In_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);			//Set SDA High
		MX_I2C_DELAY;
		for(bit_mask=0x80;bit_mask;bit_mask=bit_mask>>1)
		{
			FC_CAL_Bit_In_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);		//Set SCL High
			MX_I2C_DELAY;
			FC_CAL_Bit_In_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);
			if(FC_CAL_Bit_In(MX_I2C_SDA_PORT_X, MX_I2C_SDA_PIN_X))	//Read Incoming Bit
				Data = Data | bit_mask;														//Add data to variable
			FC_CAL_Bit_Low_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);		//Set SCL Low
			MX_I2C_DELAY;
		}
		if (Last)																		//Acknowledge?
		{
			FC_CAL_Bit_In_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);	//Send Nack
		}
		else
		{
			FC_CAL_Bit_Low_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);	//Send Ack
		}
		MX_I2C_DELAY;
		FC_CAL_Bit_In_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);		//Set SCL High
		MX_I2C_DELAY;
		FC_CAL_Bit_Low_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);		//Set SCL Low
		MX_I2C_DELAY;
		return (Data);
	#endif

	#if (MX_I2C_CHANNEL_X == 1)						//Use Master I2C Hardware 1
		cr_bit(pir1,SSPIF);							//Clear SSP interrupt flag
0257  118C  	BCF gbl_pir1,3

		st_bit(sspcon2,RCEN);						//Initiate Read
0258  1683  	BSF STATUS, RP0
0259  1591  	BSF gbl_sspcon2,3

		while(ts_bit(pir1,3) == 0);					//Wait for data read
025A        label29
025A  1283  	BCF STATUS, RP0
025B  1D8C  	BTFSS gbl_pir1,3
025C  2A5A  	GOTO	label29

		if (Last)
025D  08FC  	MOVF FC_CAL_I2C_00067_arg_Last, F
025E  1903  	BTFSC STATUS,Z
025F  2A63  	GOTO	label30
0263        label30

			st_bit(sspcon2,ACKDT);					//Send Nack
0260  1683  	BSF STATUS, RP0
0261  1691  	BSF gbl_sspcon2,5

		else cr_bit(sspcon2,ACKDT);					//Send Ack
0262  2A65  	GOTO	label31
0263  1683  	BSF STATUS, RP0
0264  1291  	BCF gbl_sspcon2,5
0265        label31

		st_bit(sspcon2,ACKEN);						//Initiate Nack
0265  1611  	BSF gbl_sspcon2,4

		while(ts_bit(sspcon2,ACKEN));				//Wait for data read
0266        label32
0266  1A11  	BTFSC gbl_sspcon2,4
0267  2A66  	GOTO	label32

		return(sspbuf);								//Store incoming data
0268  1283  	BCF STATUS, RP0
0269  0813  	MOVF gbl_sspbuf, W
026A  00FD  	MOVWF CompTempVarRet2255

	#endif

	#if (MX_I2C_CHANNEL_X == 2)						//Use Master I2C Hardware 2
		cr_bit(pir3,SSP2IF);						//Clear SSP interrupt flag
		st_bit(ssp2con2,RCEN);						//Initiate Read
		while(ts_bit(pir3,SSP2IF) == 0);			//Wait for data read
		if (Last)
			st_bit(ssp2con2,ACKDT);					//Send Nack
		else cr_bit(ssp2con2,ACKDT);				//Send Ack
		st_bit(ssp2con2,ACKEN);						//Initiate Nack
		while(ts_bit(ssp2con2,ACKEN));				//Wait for data read
		return(ssp2buf);							//Store incoming data
	#endif
}
026B  0008  	RETURN





//Slave functions currently not implemented
CALFUNCTION(void, FC_CAL_I2C_Slave_Init_, (void))
{

}

CALFUNCTION(void, FC_CAL_I2C_Slave_Uninit_, (void))
{

}

CALFUNCTION(void, FC_CAL_I2C_Slave_SetTxData_, (MX_UINT8 Data))
{

}

CALFUNCTION(MX_UINT8, FC_CAL_I2C_Slave_GetRxData_, (MX_UINT8 Last))
{

}


/*********************************************************************
 *                  Flowcode CAL PWM File
 *
 * File: PIC_CAL_PWM.c
 *
 * (c) 2011 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * Company) for its Flowcode graphical programming language is
 * intended and supplied to you, the Companys customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 270911 | BR | Created
 * 021211 | BR | Converted to new dynamic defines mechanism
 *
 */


#define MX_PWM_CHANNEL_X		CAL_APPEND(MX_PWM_CHANNEL_, MX_PWM_NUM)
#define MX_PWM_HWALT_X			CAL_APPEND(MX_PWM_HWALT_, MX_PWM_NUM)


//I2C Master Functions
CALFUNCTION(void, FC_CAL_PWM_Enable_Channel_, (void));
CALFUNCTION(void, FC_CAL_PWM_Disable_Channel_, (void));
CALFUNCTION(void, FC_CAL_PWM_Set_Duty_8Bit_, (MX_UINT8 duty));
CALFUNCTION(void, FC_CAL_PWM_Change_Period_, (MX_UINT8 period, MX_UINT16 prescaler));
CALFUNCTION(void, FC_CAL_PWM_Set_Duty_10Bit_, (MX_UINT16 duty));


CALFUNCTION(void, FC_CAL_PWM_Enable_Channel_, (void))

{

 #ifdef MX_PWM

	#if (MX_PWM_CHANNEL_X == 1)
	  #ifdef MX_PWM_REMAPPABLE
	  	RPOR3 = 14;														//PWM1 - 14 - RB0 - RP3
	  #endif

		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
		  #ifndef MX_PWM_1_PORT											//Error checking
			#error "This chip does not have PWM channel 1 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_1_PORT, MX_PWM_1_TRIS, MX_PWM_1_PIN);			//PWM pin is an output
0339  1683  	BSF STATUS, RP0
033A  1303  	BCF STATUS, RP1
033B  1107  	BCF gbl_trisc,2
033C  1283  	BCF STATUS, RP0
033D  1107  	BCF gbl_portc,2

		#else															//Alternate PWM Pin
		  #ifndef MX_PWM_1_PORT_A										//Error checking
			#error "This chip does not have PWM alt channel 1 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_1_PORT_A, MX_PWM_1_TRIS_A, MX_PWM_1_PIN_A);		//PWM pin is an output
		#endif

		ccp1con = 0x0C;													//Enable Capture Compare Channel 1
033E  300C  	MOVLW 0x0C
033F  0097  	MOVWF gbl_ccp1con

	#endif

	#if (MX_PWM_CHANNEL_X == 2)
	  #ifdef MX_PWM_REMAPPABLE
	  	RPOR4 = 18;														//PWM2 - 18 - RB1 - RP4
	  #endif

		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
		  #ifndef MX_PWM_2_PORT											//Error checking
			#error "This chip does not have PWM channel 2 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_2_PORT, MX_PWM_2_TRIS, MX_PWM_2_PIN);			//PWM pin is an output
		#else															//Alternate PWM Pin
		  #ifndef MX_PWM_2_PORT_A										//Error checking
			#error "This chip does not have PWM alt channel 2 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_2_PORT_A, MX_PWM_2_TRIS_A, MX_PWM_2_PIN_A);		//PWM pin is an output
		#endif

		ccp2con = 0x0C;													//Enable Capture Compare Channel 2
	#endif

	#if (MX_PWM_CHANNEL_X == 3)
	  #ifdef MX_PWM_REMAPPABLE
	  	RPOR5 = 22;														//PWM3 - 22 - RB2 - RP5
	  #endif

		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
		  #ifndef MX_PWM_3_PORT											//Error checking
			#error "This chip does not have PWM channel 3 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_3_PORT, MX_PWM_3_TRIS, MX_PWM_3_PIN);			//PWM pin is an output
		#else															//Alternate PWM Pin
		  #ifndef MX_PWM_3_PORT_A										//Error checking
			#error "This chip does not have PWM alt channel 3 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_3_PORT_A, MX_PWM_3_TRIS_A, MX_PWM_3_PIN_A);		//PWM pin is an output
		#endif

		ccp3con = 0x0C;													//Enable Capture Compare Channel 3 *****************************************************************
	#endif

	#if (MX_PWM_CHANNEL_X == 4)
		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
		  #ifndef MX_PWM_4_PORT											//Error checking
			#error "This chip does not have PWM channel 4 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_4_PORT, MX_PWM_4_TRIS, MX_PWM_4_PIN);			//PWM pin is an output
		#else															//Alternate PWM Pin
		  #ifndef MX_PWM_4_PORT_A										//Error checking
			#error "This chip does not have PWM alt channel 4 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_4_PORT_A, MX_PWM_4_TRIS_A, MX_PWM_4_PIN_A);		//PWM pin is an output
		#endif

		ccp4con = 0x0C;													//Enable Capture Compare Channel 4 *****************************************************************
	#endif

	#if (MX_PWM_CHANNEL_X == 5)
		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
		  #ifndef MX_PWM_5_PORT											//Error checking
			#error "This chip does not have PWM channel 5 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_5_PORT, MX_PWM_5_TRIS, MX_PWM_5_PIN);			//PWM pin is an output
		#else															//Alternate PWM Pin
		  #ifndef MX_PWM_5_PORT_A										//Error checking
			#error "This chip does not have PWM alt channel 5 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_5_PORT_A, MX_PWM_5_TRIS_A, MX_PWM_5_PIN_A);		//PWM pin is an output
		#endif

		ccp5con = 0x0C;													//Enable Capture Compare Channel 5 *****************************************************************
	#endif

	#if (MX_PWM_CHANNEL_X == 6)
		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
		  #ifndef MX_PWM_6_PORT											//Error checking
			#error "This chip does not have PWM channel 6 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_6_PORT, MX_PWM_6_TRIS, MX_PWM_6_PIN);			//PWM pin is an output
		#else															//Alternate PWM Pin
		  #ifndef MX_PWM_6_PORT_A										//Error checking
			#error "This chip does not have PWM alt channel 6 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_6_PORT_A, MX_PWM_6_TRIS_A, MX_PWM_6_PIN_A);		//PWM pin is an output
		#endif

		ccp6con = 0x0C;													//Enable Capture Compare Channel 6 *****************************************************************
	#endif

	#if (MX_PWM_CHANNEL_X == 7)
		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
		  #ifndef MX_PWM_7_PORT											//Error checking
			#error "This chip does not have PWM channel 7 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_7_PORT, MX_PWM_7_TRIS, MX_PWM_7_PIN);			//PWM pin is an output
		#else															//Alternate PWM Pin
		  #ifndef MX_PWM_7_PORT_A										//Error checking
			#error "This chip does not have PWM alt channel 7 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_7_PORT_A, MX_PWM_7_TRIS_A, MX_PWM_7_PIN_A);		//PWM pin is an output
		#endif

		ccp7con = 0x0C;													//Enable Capture Compare Channel 5 *****************************************************************
	#endif

	#if (MX_PWM_CHANNEL_X == 8)
		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
		  #ifndef MX_PWM_8_PORT											//Error checking
			#error "This chip does not have PWM channel 8 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_8_PORT, MX_PWM_8_TRIS, MX_PWM_8_PIN);			//PWM pin is an output
		#else															//Alternate PWM Pin
		  #ifndef MX_PWM_8_PORT_A										//Error checking
			#error "This chip does not have PWM alt channel 8 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_8_PORT_A, MX_PWM_8_TRIS_A, MX_PWM_8_PIN_A);		//PWM pin is an output
		#endif

		ccp8con = 0x0C;													//Enable Capture Compare Channel 8 *****************************************************************
	#endif

	#if (MX_PWM_CHANNEL_X == 9)
		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
		  #ifndef MX_PWM_9_PORT											//Error checking
			#error "This chip does not have PWM channel 9 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_9_PORT, MX_PWM_9_TRIS, MX_PWM_9_PIN);			//PWM pin is an output
		#else															//Alternate PWM Pin
		  #ifndef MX_PWM_9_PORT_A										//Error checking
			#error "This chip does not have PWM alt channel 9 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_9_PORT_A, MX_PWM_9_TRIS_A, MX_PWM_9_PIN_A);		//PWM pin is an output
		#endif

		ccp9con = 0x0C;													//Enable Capture Compare Channel 9 *****************************************************************
	#endif

	#if (MX_PWM_CHANNEL_X == 10)
		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
		  #ifndef MX_PWM_10_PORT											//Error checking
			#error "This chip does not have PWM channel 10 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_10_PORT, MX_PWM_10_TRIS, MX_PWM_10_PIN);			//PWM pin is an output
		#else															//Alternate PWM Pin
		  #ifndef MX_PWM_10_PORT_A										//Error checking
			#error "This chip does not have PWM alt channel 10 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_10_PORT_A, MX_PWM_10_TRIS_A, MX_PWM_10_PIN_A);		//PWM pin is an output
		#endif

		ccp10con = 0x0C;												//Enable Capture Compare Channel 10 *****************************************************************
	#endif

 #else
 	#error "Hardware PWM not supported by Target microcontroller."
 #endif

}
0340  0008  	RETURN



CALFUNCTION(void, FC_CAL_PWM_Disable_Channel_, (void))

{
	#if (MX_PWM_CHANNEL_X == 1)
		ccp1con = 0x00;													//Disable Capture Compare Channel 1
0333  1283  	BCF STATUS, RP0
0334  1303  	BCF STATUS, RP1
0335  0197  	CLRF gbl_ccp1con

		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_1_PORT, MX_PWM_1_TRIS, MX_PWM_1_PIN);			//PWM pin is an input
0336  1683  	BSF STATUS, RP0
0337  1507  	BSF gbl_trisc,2

		#else															//Alternate PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_1_PORT_A, MX_PWM_1_TRIS_A, MX_PWM_1_PIN_A);		//PWM pin is an input
		#endif
	#endif

	#if (MX_PWM_CHANNEL_X == 2)
		ccp2con = 0x00;													//Disable Capture Compare Channel 2
		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_2_PORT, MX_PWM_2_TRIS, MX_PWM_2_PIN);			//PWM pin is an input
		#else															//Alternate PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_2_PORT_A, MX_PWM_2_TRIS_A, MX_PWM_2_PIN_A);		//PWM pin is an input
		#endif
	#endif

	#if (MX_PWM_CHANNEL_X == 3)
		ccp3con = 0x00;													//Disable Capture Compare Channel 3
		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_3_PORT, MX_PWM_3_TRIS, MX_PWM_3_PIN);			//PWM pin is an input
		#else															//Alternate PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_3_PORT_A, MX_PWM_3_TRIS_A, MX_PWM_3_PIN_A);		//PWM pin is an input
		#endif
	#endif

	#if (MX_PWM_CHANNEL_X == 4)
		ccp4con = 0x00;													//Disable Capture Compare Channel 4
		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_4_PORT, MX_PWM_4_TRIS, MX_PWM_4_PIN);			//PWM pin is an input
		#else															//Alternate PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_4_PORT_A, MX_PWM_4_TRIS_A, MX_PWM_4_PIN_A);		//PWM pin is an input
		#endif
	#endif

	#if (MX_PWM_CHANNEL_X == 5)
		ccp5con = 0x00;													//Disable Capture Compare Channel 5
		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_5_PORT, MX_PWM_5_TRIS, MX_PWM_5_PIN);			//PWM pin is an input
		#else															//Alternate PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_5_PORT_A, MX_PWM_5_TRIS_A, MX_PWM_5_PIN_A);		//PWM pin is an input
		#endif
	#endif

	#if (MX_PWM_CHANNEL_X == 6)
		ccp6con = 0x00;													//Disable Capture Compare Channel 6
		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_6_PORT, MX_PWM_6_TRIS, MX_PWM_6_PIN);			//PWM pin is an input
		#else															//Alternate PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_6_PORT_A, MX_PWM_6_TRIS_A, MX_PWM_6_PIN_A);		//PWM pin is an input
		#endif
	#endif

	#if (MX_PWM_CHANNEL_X == 7)
		ccp7con = 0x00;													//Disable Capture Compare Channel 7
		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_7_PORT, MX_PWM_7_TRIS, MX_PWM_7_PIN);			//PWM pin is an input
		#else															//Alternate PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_7_PORT_A, MX_PWM_7_TRIS_A, MX_PWM_7_PIN_A);		//PWM pin is an input
		#endif
	#endif

	#if (MX_PWM_CHANNEL_X == 8)
		ccp8con = 0x00;													//Disable Capture Compare Channel 8
		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_8_PORT, MX_PWM_8_TRIS, MX_PWM_8_PIN);			//PWM pin is an input
		#else															//Alternate PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_8_PORT_A, MX_PWM_8_TRIS_A, MX_PWM_8_PIN_A);		//PWM pin is an input
		#endif
	#endif

	#if (MX_PWM_CHANNEL_X == 9)
		ccp9con = 0x00;													//Disable Capture Compare Channel 9
		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_9_PORT, MX_PWM_9_TRIS, MX_PWM_9_PIN);			//PWM pin is an input
		#else															//Alternate PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_9_PORT_A, MX_PWM_9_TRIS_A, MX_PWM_9_PIN_A);		//PWM pin is an input
		#endif
	#endif

	#if (MX_PWM_CHANNEL_X == 10)
		ccp10con = 0x00;												//Disable Capture Compare Channel 10
		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_10_PORT, MX_PWM_10_TRIS, MX_PWM_10_PIN);			//PWM pin is an input
		#else															//Alternate PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_10_PORT_A, MX_PWM_10_TRIS_A, MX_PWM_10_PIN_A);		//PWM pin is an input
		#endif
	#endif
}
0338  0008  	RETURN



CALFUNCTION(void, FC_CAL_PWM_Set_Duty_8Bit_, (MX_UINT8 duty))

{
	#if (MX_PWM_CHANNEL_X == 1)
		ccpr1l = duty;													//Update Capture Compare Count 1
032F  0820  	MOVF FC_CAL_PWM_0007B_arg_duty, W
0330  1283  	BCF STATUS, RP0
0331  0095  	MOVWF gbl_ccpr1l

	#endif

	#if (MX_PWM_CHANNEL_X == 2)
		ccpr2l = duty;													//Update Capture Compare Count 2
	#endif

	#if (MX_PWM_CHANNEL_X == 3)
		ccpr3l = duty;													//Update Capture Compare Count 3
	#endif

	#if (MX_PWM_CHANNEL_X == 4)
		ccpr4l = duty;													//Update Capture Compare Count 4
	#endif

	#if (MX_PWM_CHANNEL_X == 5)
		ccpr5l = duty;													//Update Capture Compare Count 5
	#endif

	#if (MX_PWM_CHANNEL_X == 6)
		ccpr6l = duty;													//Update Capture Compare Count 6
	#endif

	#if (MX_PWM_CHANNEL_X == 7)
		ccpr7l = duty;													//Update Capture Compare Count 7
	#endif

	#if (MX_PWM_CHANNEL_X == 8)
		ccpr8l = duty;													//Update Capture Compare Count 8
	#endif

	#if (MX_PWM_CHANNEL_X == 9)
		ccpr9l = duty;													//Update Capture Compare Count 9
	#endif

	#if (MX_PWM_CHANNEL_X == 10)
		ccpr10l = duty;													//Update Capture Compare Count 10
	#endif
}
0332  0008  	RETURN



CALFUNCTION(void, FC_CAL_PWM_Change_Period_, (MX_UINT8 period, MX_UINT16 prescaler))

{
  #ifdef MX_PWM								//Hardware Mode
	pr2 = period;
030C  1283  	BCF STATUS, RP0
030D  087E  	MOVF FC_CAL_PWM_0007C_arg_period, W
030E  1683  	BSF STATUS, RP0
030F  0092  	MOVWF gbl_pr2

	switch (prescaler)
	{
	  #ifdef MX_PWM_PSCA1
		case 1:
0310  3001  	MOVLW 0x01
0311  0620  	XORWF FC_CAL_PWM_0007C_arg_prescaler, W
0312  1903  	BTFSC STATUS,Z
0313  0821  	MOVF FC_CAL_PWM_0007C_arg_prescaler+D'1', W
0314  1903  	BTFSC STATUS,Z
0315  2B23  	GOTO	label41
0323        label41

			t2con = 0x04;
0323  3004  	MOVLW 0x04
0324  1283  	BCF STATUS, RP0
0325  0092  	MOVWF gbl_t2con

			break;
	  #endif
	  #ifdef MX_PWM_PSCA4
		case 4:
0316  3004  	MOVLW 0x04
0317  0620  	XORWF FC_CAL_PWM_0007C_arg_prescaler, W
0318  1903  	BTFSC STATUS,Z
0319  0821  	MOVF FC_CAL_PWM_0007C_arg_prescaler+D'1', W
031A  1903  	BTFSC STATUS,Z
031B  2B27  	GOTO	label42
0327        label42

			t2con = 0x05;
0327  3005  	MOVLW 0x05
0328  1283  	BCF STATUS, RP0
0329  0092  	MOVWF gbl_t2con

			break;
	  #endif
	  #ifdef MX_PWM_PSCA16
		case 16:
031C  3010  	MOVLW 0x10
031D  0620  	XORWF FC_CAL_PWM_0007C_arg_prescaler, W
031E  1903  	BTFSC STATUS,Z
031F  0821  	MOVF FC_CAL_PWM_0007C_arg_prescaler+D'1', W
0320  1903  	BTFSC STATUS,Z
0321  2B2B  	GOTO	label43
032B        label43

			t2con = 0x06;
032B  3006  	MOVLW 0x06
032C  1283  	BCF STATUS, RP0
032D  0092  	MOVWF gbl_t2con

			break;
	  #endif
	  #ifdef MX_PWM_PSCA64
		case 64:
			t2con = 0x07;					//Note some earlier devices do not have the /64 option
			break;
	  #endif
	}
  #endif
}
0322  0008  	RETURN
0326  0008  	RETURN
032A  0008  	RETURN
032E  0008  	RETURN



CALFUNCTION(void, FC_CAL_PWM_Set_Duty_10Bit_, (MX_UINT16 duty))
{
	char nCCPxCONtemp;

	#if (MX_PWM_CHANNEL_X == 1)
		ccpr1l = (duty & 0x3FC) >> 2;									//Update Capture Compare Count 1
		duty = (duty & 0x03) << 4;
		nCCPxCONtemp = (ccp1con & 0xCF) | duty;
		ccp1con = nCCPxCONtemp;
	#endif

	#if (MX_PWM_CHANNEL_X == 2)
		ccpr2l = (duty & 0x3FC) >> 2;									//Update Capture Compare Count 2
		duty = (duty & 0x03) << 4;
		nCCPxCONtemp = (ccp2con & 0xCF) | duty;
		ccp2con = nCCPxCONtemp;
	#endif

	#if (MX_PWM_CHANNEL_X == 3)
		ccpr3l = (duty & 0x3FC) >> 2;									//Update Capture Compare Count 3
		duty = (duty & 0x03) << 4;
		nCCPxCONtemp = (ccp3con & 0xCF) | duty;
		ccp3con = nCCPxCONtemp;
	#endif

	#if (MX_PWM_CHANNEL_X == 4)
		ccpr4l = (duty & 0x3FC) >> 2;									//Update Capture Compare Count 4
		duty = (duty & 0x03) << 4;
		nCCPxCONtemp = (ccp4con & 0xCF) | duty;
		ccp4con = nCCPxCONtemp;
	#endif

	#if (MX_PWM_CHANNEL_X == 5)
		ccpr5l = (duty & 0x3FC) >> 2;									//Update Capture Compare Count 5
		duty = (duty & 0x03) << 4;
		nCCPxCONtemp = (ccp5con & 0xCF) | duty;
		ccp5con = nCCPxCONtemp;
	#endif

	#if (MX_PWM_CHANNEL_X == 6)
		ccpr6l = (duty & 0x3FC) >> 2;									//Update Capture Compare Count 6
		duty = (duty & 0x03) << 4;
		nCCPxCONtemp = (ccp6con & 0xCF) | duty;
		ccp6con = nCCPxCONtemp;
	#endif

	#if (MX_PWM_CHANNEL_X == 7)
		ccpr7l = (duty & 0x3FC) >> 2;									//Update Capture Compare Count 7
		duty = (duty & 0x03) << 4;
		nCCPxCONtemp = (ccp7con & 0xCF) | duty;
		ccp7con = nCCPxCONtemp;
	#endif

	#if (MX_PWM_CHANNEL_X == 8)
		ccpr8l = (duty & 0x3FC) >> 2;									//Update Capture Compare Count 8
		duty = (duty & 0x03) << 4;
		nCCPxCONtemp = (ccp8con & 0xCF) | duty;
		ccp8con = nCCPxCONtemp;
	#endif

	#if (MX_PWM_CHANNEL_X == 9)
		ccpr9l = (duty & 0x3FC) >> 2;									//Update Capture Compare Count 9
		duty = (duty & 0x03) << 4;
		nCCPxCONtemp = (ccp9con & 0xCF) | duty;
		ccp9con = nCCPxCONtemp;
	#endif

	#if (MX_PWM_CHANNEL_X == 10)
		ccpr10l = (duty & 0x3FC) >> 2;									//Update Capture Compare Count 10
		duty = (duty & 0x03) << 4;
		nCCPxCONtemp = (ccp10con & 0xCF) | duty;
		ccp10con = nCCPxCONtemp;
	#endif
}


////////////////////////////////////////
// Code with no source :-)
////////////////////////////////////////
0000  158A  	BSF PCLATH,3
0001  28CC  	GOTO	_startup

0004  00FF  	MOVWF Int1Context
0005  0E03  	SWAPF STATUS, W
0006  1283  	BCF STATUS, RP0
0007  1303  	BCF STATUS, RP1
0008  00C0  	MOVWF Int1BContext
0009  0E0A  	SWAPF PCLATH, W
000A  00C1  	MOVWF Int1BContext+D'1'
000B  0E04  	SWAPF FSR, W
000C  00C2  	MOVWF Int1BContext+D'2'
000D  158A  	BSF PCLATH,3
000E  120A  	BCF PCLATH,4
000F  292C  	GOTO	interrupt
0010        delay_us_00000
0010        ; { delay_us ; function begin
0010  3003  	MOVLW 0x03
0011  07A4  	ADDWF delay_us_00000_arg_del, F
0012  0CA4  	RRF delay_us_00000_arg_del, F
0013  0CA4  	RRF delay_us_00000_arg_del, F
0014  307F  	MOVLW 0x7F
0015  05A4  	ANDWF delay_us_00000_arg_del, F
0016        label1
0016  0000  	NOP
0017  0BA4  	DECFSZ delay_us_00000_arg_del, F
0018  2816  	GOTO	label1
0019  0008  	RETURN
001A        ; } delay_us function end

001A        delay_ms_00000
001A        ; { delay_ms ; function begin
001A  08FE  	MOVF delay_ms_00000_arg_del, F
001B  1D03  	BTFSS STATUS,Z
001C  281E  	GOTO	label2
001D  0008  	RETURN
001E        label2
001E  30CC  	MOVLW 0xCC
001F        label3
001F  3EFF  	ADDLW 0xFF
0020  1D03  	BTFSS STATUS,Z
0021  281F  	GOTO	label3
0022  0000  	NOP
0023  0BFE  	DECFSZ delay_ms_00000_arg_del, F
0024  281E  	GOTO	label2
0025  0008  	RETURN
0026        ; } delay_ms function end


01B8        __rem_8_8_00000
01B8        ; { __rem_8_8 ; function begin
01B8  1683  	BSF STATUS, RP0
01B9  01A4  	CLRF CompTempVarRet220
01BA  01A2  	CLRF __rem_8_8_00000_1_c
01BB  01A3  	CLRF __rem_8_8_00000_1_i
01BC        label19
01BC  19A3  	BTFSC __rem_8_8_00000_1_i,3
01BD  0008  	RETURN
01BE  1003  	BCF STATUS,C
01BF  0DA2  	RLF __rem_8_8_00000_1_c, F
01C0  1283  	BCF STATUS, RP0
01C1  0DFD  	RLF __rem_8_8_00000_arg_a, F
01C2  1683  	BSF STATUS, RP0
01C3  0DA4  	RLF CompTempVarRet220, F
01C4  1283  	BCF STATUS, RP0
01C5  087E  	MOVF __rem_8_8_00000_arg_b, W
01C6  1683  	BSF STATUS, RP0
01C7  0224  	SUBWF CompTempVarRet220, W
01C8  1C03  	BTFSS STATUS,C
01C9  29CC  	GOTO	label20
01CA  00A4  	MOVWF CompTempVarRet220
01CB  1422  	BSF __rem_8_8_00000_1_c,0
01CC        label20
01CC  0AA3  	INCF __rem_8_8_00000_1_i, F
01CD  29BC  	GOTO	label19
01CE        ; } __rem_8_8 function end

01CE        __rem_32_3_00002
01CE        ; { __rem_32_32 ; function begin
01CE  01AC  	CLRF CompTempVarRet212
01CF  01AD  	CLRF CompTempVarRet212+D'1'
01D0  01AE  	CLRF CompTempVarRet212+D'2'
01D1  01AF  	CLRF CompTempVarRet212+D'3'
01D2  01A8  	CLRF __rem_32_3_00002_1_c
01D3  01A9  	CLRF __rem_32_3_00002_1_c+D'1'
01D4  01AA  	CLRF __rem_32_3_00002_1_c+D'2'
01D5  01AB  	CLRF __rem_32_3_00002_1_c+D'3'
01D6  1283  	BCF STATUS, RP0
01D7  01FD  	CLRF __rem_32_3_00002_1_i
01D8        label21
01D8  1AFD  	BTFSC __rem_32_3_00002_1_i,5
01D9  0008  	RETURN
01DA  1003  	BCF STATUS,C
01DB  1683  	BSF STATUS, RP0
01DC  0DA8  	RLF __rem_32_3_00002_1_c, F
01DD  0DA9  	RLF __rem_32_3_00002_1_c+D'1', F
01DE  0DAA  	RLF __rem_32_3_00002_1_c+D'2', F
01DF  0DAB  	RLF __rem_32_3_00002_1_c+D'3', F
01E0  0DA0  	RLF __rem_32_3_00002_arg_a, F
01E1  0DA1  	RLF __rem_32_3_00002_arg_a+D'1', F
01E2  0DA2  	RLF __rem_32_3_00002_arg_a+D'2', F
01E3  0DA3  	RLF __rem_32_3_00002_arg_a+D'3', F
01E4  0DAC  	RLF CompTempVarRet212, F
01E5  0DAD  	RLF CompTempVarRet212+D'1', F
01E6  0DAE  	RLF CompTempVarRet212+D'2', F
01E7  0DAF  	RLF CompTempVarRet212+D'3', F
01E8  0827  	MOVF __rem_32_3_00002_arg_b+D'3', W
01E9  022F  	SUBWF CompTempVarRet212+D'3', W
01EA  1D03  	BTFSS STATUS,Z
01EB  29F6  	GOTO	label22
01EC  0826  	MOVF __rem_32_3_00002_arg_b+D'2', W
01ED  022E  	SUBWF CompTempVarRet212+D'2', W
01EE  1D03  	BTFSS STATUS,Z
01EF  29F6  	GOTO	label22
01F0  0825  	MOVF __rem_32_3_00002_arg_b+D'1', W
01F1  022D  	SUBWF CompTempVarRet212+D'1', W
01F2  1D03  	BTFSS STATUS,Z
01F3  29F6  	GOTO	label22
01F4  0824  	MOVF __rem_32_3_00002_arg_b, W
01F5  022C  	SUBWF CompTempVarRet212, W
01F6        label22
01F6  1C03  	BTFSS STATUS,C
01F7  2A07  	GOTO	label23
01F8  0824  	MOVF __rem_32_3_00002_arg_b, W
01F9  02AC  	SUBWF CompTempVarRet212, F
01FA  0825  	MOVF __rem_32_3_00002_arg_b+D'1', W
01FB  1C03  	BTFSS STATUS,C
01FC  0F25  	INCFSZ __rem_32_3_00002_arg_b+D'1', W
01FD  02AD  	SUBWF CompTempVarRet212+D'1', F
01FE  0826  	MOVF __rem_32_3_00002_arg_b+D'2', W
01FF  1C03  	BTFSS STATUS,C
0200  0F26  	INCFSZ __rem_32_3_00002_arg_b+D'2', W
0201  02AE  	SUBWF CompTempVarRet212+D'2', F
0202  0827  	MOVF __rem_32_3_00002_arg_b+D'3', W
0203  1C03  	BTFSS STATUS,C
0204  0F27  	INCFSZ __rem_32_3_00002_arg_b+D'3', W
0205  02AF  	SUBWF CompTempVarRet212+D'3', F
0206  1428  	BSF __rem_32_3_00002_1_c,0
0207        label23
0207  1283  	BCF STATUS, RP0
0208  0AFD  	INCF __rem_32_3_00002_1_i, F
0209  29D8  	GOTO	label21
020A        ; } __rem_32_32 function end

020A        __div_8_8_00000
020A        ; { __div_8_8 ; function begin
020A  01A2  	CLRF __div_8_8_00000_1_r
020B  01A4  	CLRF CompTempVarRet218
020C  01A3  	CLRF __div_8_8_00000_1_i
020D        label24
020D  19A3  	BTFSC __div_8_8_00000_1_i,3
020E  0008  	RETURN
020F  1003  	BCF STATUS,C
0210  0DA4  	RLF CompTempVarRet218, F
0211  0DA0  	RLF __div_8_8_00000_arg_a, F
0212  0DA2  	RLF __div_8_8_00000_1_r, F
0213  0821  	MOVF __div_8_8_00000_arg_b, W
0214  0222  	SUBWF __div_8_8_00000_1_r, W
0215  1C03  	BTFSS STATUS,C
0216  2A19  	GOTO	label25
0217  00A2  	MOVWF __div_8_8_00000_1_r
0218  1424  	BSF CompTempVarRet218,0
0219        label25
0219  0AA3  	INCF __div_8_8_00000_1_i, F
021A  2A0D  	GOTO	label24
021B        ; } __div_8_8 function end

021B        __div_32_3_00001
021B        ; { __div_32_32 ; function begin
021B  01AC  	CLRF __div_32_3_00001_1_r
021C  01AD  	CLRF __div_32_3_00001_1_r+D'1'
021D  01AE  	CLRF __div_32_3_00001_1_r+D'2'
021E  01AF  	CLRF __div_32_3_00001_1_r+D'3'
021F  01B0  	CLRF CompTempVarRet210
0220  01B1  	CLRF CompTempVarRet210+D'1'
0221  01B2  	CLRF CompTempVarRet210+D'2'
0222  01B3  	CLRF CompTempVarRet210+D'3'
0223  1283  	BCF STATUS, RP0
0224  01FE  	CLRF __div_32_3_00001_1_i
0225        label26
0225  1AFE  	BTFSC __div_32_3_00001_1_i,5
0226  0008  	RETURN
0227  1003  	BCF STATUS,C
0228  1683  	BSF STATUS, RP0
0229  0DB0  	RLF CompTempVarRet210, F
022A  0DB1  	RLF CompTempVarRet210+D'1', F
022B  0DB2  	RLF CompTempVarRet210+D'2', F
022C  0DB3  	RLF CompTempVarRet210+D'3', F
022D  0DA0  	RLF __div_32_3_00001_arg_a, F
022E  0DA1  	RLF __div_32_3_00001_arg_a+D'1', F
022F  0DA2  	RLF __div_32_3_00001_arg_a+D'2', F
0230  0DA3  	RLF __div_32_3_00001_arg_a+D'3', F
0231  0DAC  	RLF __div_32_3_00001_1_r, F
0232  0DAD  	RLF __div_32_3_00001_1_r+D'1', F
0233  0DAE  	RLF __div_32_3_00001_1_r+D'2', F
0234  0DAF  	RLF __div_32_3_00001_1_r+D'3', F
0235  0827  	MOVF __div_32_3_00001_arg_b+D'3', W
0236  022F  	SUBWF __div_32_3_00001_1_r+D'3', W
0237  1D03  	BTFSS STATUS,Z
0238  2A43  	GOTO	label27
0239  0826  	MOVF __div_32_3_00001_arg_b+D'2', W
023A  022E  	SUBWF __div_32_3_00001_1_r+D'2', W
023B  1D03  	BTFSS STATUS,Z
023C  2A43  	GOTO	label27
023D  0825  	MOVF __div_32_3_00001_arg_b+D'1', W
023E  022D  	SUBWF __div_32_3_00001_1_r+D'1', W
023F  1D03  	BTFSS STATUS,Z
0240  2A43  	GOTO	label27
0241  0824  	MOVF __div_32_3_00001_arg_b, W
0242  022C  	SUBWF __div_32_3_00001_1_r, W
0243        label27
0243  1C03  	BTFSS STATUS,C
0244  2A54  	GOTO	label28
0245  0824  	MOVF __div_32_3_00001_arg_b, W
0246  02AC  	SUBWF __div_32_3_00001_1_r, F
0247  0825  	MOVF __div_32_3_00001_arg_b+D'1', W
0248  1C03  	BTFSS STATUS,C
0249  0F25  	INCFSZ __div_32_3_00001_arg_b+D'1', W
024A  02AD  	SUBWF __div_32_3_00001_1_r+D'1', F
024B  0826  	MOVF __div_32_3_00001_arg_b+D'2', W
024C  1C03  	BTFSS STATUS,C
024D  0F26  	INCFSZ __div_32_3_00001_arg_b+D'2', W
024E  02AE  	SUBWF __div_32_3_00001_1_r+D'2', F
024F  0827  	MOVF __div_32_3_00001_arg_b+D'3', W
0250  1C03  	BTFSS STATUS,C
0251  0F27  	INCFSZ __div_32_3_00001_arg_b+D'3', W
0252  02AF  	SUBWF __div_32_3_00001_1_r+D'3', F
0253  1430  	BSF CompTempVarRet210,0
0254        label28
0254  1283  	BCF STATUS, RP0
0255  0AFE  	INCF __div_32_3_00001_1_i, F
0256  2A25  	GOTO	label26
0257        ; } __div_32_32 function end


02DF        __mul_16s__0000E
02DF        ; { __mul_16s_16s__16 ; function begin
02DF  01A2  	CLRF __mul_16s__0000E_1_i
02E0  01A5  	CLRF CompTempVarRet461
02E1  01A6  	CLRF CompTempVarRet461+D'1'
02E2  1283  	BCF STATUS, RP0
02E3  087D  	MOVF __mul_16s__0000E_arg_a, W
02E4  1683  	BSF STATUS, RP0
02E5  00A3  	MOVWF __mul_16s__0000E_1_t
02E6  1283  	BCF STATUS, RP0
02E7  087E  	MOVF __mul_16s__0000E_arg_a+D'1', W
02E8  1683  	BSF STATUS, RP0
02E9  00A4  	MOVWF __mul_16s__0000E_1_t+D'1'
02EA  1FA1  	BTFSS __mul_16s__0000E_arg_b+D'1',7
02EB  2AF2  	GOTO	label38
02EC  17A2  	BSF __mul_16s__0000E_1_i,7
02ED  09A0  	COMF __mul_16s__0000E_arg_b, F
02EE  09A1  	COMF __mul_16s__0000E_arg_b+D'1', F
02EF  0AA0  	INCF __mul_16s__0000E_arg_b, F
02F0  1903  	BTFSC gbl_status,2
02F1  0AA1  	INCF __mul_16s__0000E_arg_b+D'1', F
02F2        label38
02F2  1A22  	BTFSC __mul_16s__0000E_1_i,4
02F3  2B04  	GOTO	label40
02F4  1C20  	BTFSS __mul_16s__0000E_arg_b,0
02F5  2AFC  	GOTO	label39
02F6  0823  	MOVF __mul_16s__0000E_1_t, W
02F7  07A5  	ADDWF CompTempVarRet461, F
02F8  0824  	MOVF __mul_16s__0000E_1_t+D'1', W
02F9  1803  	BTFSC gbl_status,0
02FA  0F24  	INCFSZ __mul_16s__0000E_1_t+D'1', W
02FB  07A6  	ADDWF CompTempVarRet461+D'1', F
02FC        label39
02FC  1003  	BCF gbl_status,0
02FD  0CA1  	RRF __mul_16s__0000E_arg_b+D'1', F
02FE  0CA0  	RRF __mul_16s__0000E_arg_b, F
02FF  1003  	BCF gbl_status,0
0300  0DA3  	RLF __mul_16s__0000E_1_t, F
0301  0DA4  	RLF __mul_16s__0000E_1_t+D'1', F
0302  0AA2  	INCF __mul_16s__0000E_1_i, F
0303  2AF2  	GOTO	label38
0304        label40
0304  1FA2  	BTFSS __mul_16s__0000E_1_i,7
0305  0008  	RETURN
0306  09A5  	COMF CompTempVarRet461, F
0307  09A6  	COMF CompTempVarRet461+D'1', F
0308  0AA5  	INCF CompTempVarRet461, F
0309  1903  	BTFSC gbl_status,2
030A  0AA6  	INCF CompTempVarRet461+D'1', F
030B  0008  	RETURN
030C        ; } __mul_16s_16s__16 function end


08CC        _startup
08CC  30D5  	MOVLW 0xD5
08CD  1283  	BCF STATUS, RP0
08CE  1303  	BCF STATUS, RP1
08CF  00A0  	MOVWF gbl_14_LSR
08D0  30C4  	MOVLW 0xC4
08D1  00A1  	MOVWF gbl_14_LSR+D'1'
08D2  30BB  	MOVLW 0xBB
08D3  00A2  	MOVWF gbl_14_LSR+D'2'
08D4  30DC  	MOVLW 0xDC
08D5  00A3  	MOVWF gbl_14_LSR+D'3'
08D6  01A4  	CLRF gbl_15_gbl_aSig
08D7  01A5  	CLRF gbl_15_gbl_aSig+D'1'
08D8  01A6  	CLRF gbl_15_gbl_aSig+D'2'
08D9  01A7  	CLRF gbl_15_gbl_aSig+D'3'
08DA  01A8  	CLRF gbl_15_gbl_bSig
08DB  01A9  	CLRF gbl_15_gbl_bSig+D'1'
08DC  01AA  	CLRF gbl_15_gbl_bSig+D'2'
08DD  01AB  	CLRF gbl_15_gbl_bSig+D'3'
08DE  01AC  	CLRF gbl_15_gbl_zSig
08DF  01AD  	CLRF gbl_15_gbl_zSig+D'1'
08E0  01AE  	CLRF gbl_15_gbl_zSig+D'2'
08E1  01AF  	CLRF gbl_15_gbl_zSig+D'3'
08E2  01CE  	CLRF gbl_15_gbl_aExp
08E3  01CF  	CLRF gbl_15_gbl_bExp
08E4  01C3  	CLRF gbl_15_gbl_zExp
08E5  01C4  	CLRF gbl_15_gbl_zExp+D'1'
08E6  01D0  	CLRF gbl_15_gbl_aSign
08E7  01D1  	CLRF gbl_15_gbl_bSign
08E8  01D2  	CLRF gbl_15_gbl_zSign
08E9  01D3  	CLRF gbl_15_gbl_zSigZero
08EA  01B0  	CLRF gbl_15_gbl_ret
08EB  01B1  	CLRF gbl_15_gbl_ret+D'1'
08EC  01B2  	CLRF gbl_15_gbl_ret+D'2'
08ED  01B3  	CLRF gbl_15_gbl_ret+D'3'
08EE  01CC  	CLRF gbl_float_rounding_mode
08EF  01CD  	CLRF gbl_float_exception_flags
08F0  01CB  	CLRF gbl_float_detect_tininess

0929  118A  	BCF PCLATH,3
092A  120A  	BCF PCLATH,4
092B  2EFB  	GOTO	main

2007  1E72  	DW 0x1E72
