;/////////////////////////////////////////////////////////////////////////////////
;// Code Generator: BoostC Compiler - http://www.sourceboost.com
;// Version       : 7.03
;// License Type  : Pro License
;// Limitations   : PIC12,PIC16 max code size:Unlimited, max RAM banks:Unlimited
;/////////////////////////////////////////////////////////////////////////////////

//************************************************************************************
//**  
//**  File name:     C:\Users\gerpe\OneDrive\GER-PER 2016\Documents\KennyNeutron\2020\Thermometer\Flowcode\thermo873a_test_ed2.c
//**  Title:         
//**  Description:   
//**  
//**  Generated by:  Flowcode v5.2.0.0
//**  Date:          Friday, July 17, 2020 16:11:42
//**  Licence:       Professional
//**  Registered to: xyz
//**  Licence key:   WUK7B9
//**  
//**  
//**  http://www.matrixmultimedia.com
//**  
//************************************************************************************


#define MX_PIC

#define MX_USES_UINT8 1
#define MX_USES_SINT16 1
#define MX_USES_CHAR 0
#define MX_USES_FLOAT 1
#define MX_USES_SINT32 1
#define MX_USES_BOOL 1
#define MX_USES_UINT16 1
#define MX_USES_UINT32 0
//Defines for microcontroller
#define P16F873A
#define FC_CAL_PIC
#define MX_ADC
#define MX_ADC_TYPE_1
#define MX_ADC_BITS_10
#define MX_EE
#define MX_EE_TYPE2
#define MX_EE_SIZE 128
#define MX_SPI_1
#define MX_SPI_1_MISO_PORT portc
#define MX_SPI_1_MISO_TRIS trisc
#define MX_SPI_1_MISO_PIN 4
#define MX_SPI_1_MOSI_PORT portc
#define MX_SPI_1_MOSI_TRIS trisc
#define MX_SPI_1_MOSI_PIN 5
#define MX_SPI_1_CLK_PORT portc
#define MX_SPI_1_CLK_TRIS trisc
#define MX_SPI_1_CLK_PIN 3
#define MX_SPI_1_SS_PORT portc
#define MX_SPI_1_SS_TRIS trisc
#define MX_UART_1
#define MX_UART_1_TX_PORT portc
#define MX_UART_1_TX_TRIS trisc
#define MX_UART_1_TX_PIN 6
#define MX_UART_1_RX_PORT portc
#define MX_UART_1_RX_TRIS trisc
#define MX_UART_1_RX_PIN 7
#define MX_I2C
#define MX_MI2C
#define MX_I2C_1
#define MX_I2C_1_SDA_PORT portc
#define MX_I2C_1_SDA_TRIS trisc
#define MX_I2C_1_SDA_PIN 4
#define MX_I2C_1_SCL_PORT portc
#define MX_I2C_1_SCL_TRIS trisc
#define MX_I2C_1_SCL_PIN 3
#define MX_PWM
#define MX_PWM_CNT 2
#define MX_PWM_PSCA1
#define MX_PWM_PSCA4
#define MX_PWM_PSCA16
#define MX_PWM_1_PORT portc
#define MX_PWM_1_TRIS trisc
#define MX_PWM_1_PIN 2
#define MX_PWM_2_PORT portc
#define MX_PWM_2_TRIS trisc
#define MX_PWM_2_PIN 1

//Functions
#define MX_CLK_SPEED 3276800
#ifdef _BOOSTC
#include <system.h>
#endif
#ifdef HI_TECH_C
#include <pic.h>
#endif

//Configuration data
#ifdef _BOOSTC
#pragma DATA 0x2007, 0x1e72
#endif
#ifdef HI_TECH_C
__CONFIG(0x1e72);
#endif

//Internal functions
#include "C:\Program Files (x86)\Flowcode\v5\FCD\internals.c"

//Macro function declarations
void FCM_i2c_comm();
void FCM_intro();
void FCM_scan1();
void FCM_scan2();
void FCM_scan3();
void FCM_scan4();
void FCM_ikotled();
void FCM_seg_pattern();
void FCM_display_temp();
void FCM_scan_off();
void FCM_calc();
void FCM_calibrate();
void FCM_display_calib();
void FCM_display_error();
void FCM_error();
void FCM_display_repeat();
void FCM_ready();
void FCM_def_calib();


//Variable declarations
#define FCV_FALSE (0)
#define FCV_TRUE (1)
MX_UINT8 FCV_CALIB_ADD0_DAT = (0x0);
09D8  01D4  	CLRF gbl_FCV_CALIB_ADD0_DAT

MX_UINT8 FCV_TEMP_TENS = (0x0);
09D9  01D5  	CLRF gbl_FCV_TEMP_TENS

MX_UINT8 FCV_D_BYTE = (0x0);
09DA  01D6  	CLRF gbl_FCV_D_BYTE

MX_UINT8 FCV_CALIB_ADD1_DAT = (0x0);
09DB  01D7  	CLRF gbl_FCV_CALIB_ADD1_DAT

MX_UINT8 FCV_TRIM = (0xff);
09DC  30FF  	MOVLW 0xFF
09DD  00D8  	MOVWF gbl_FCV_TRIM

MX_UINT8 FCV_TEMP_CDP = (0x0);
09DE  01D9  	CLRF gbl_FCV_TEMP_CDP

MX_SINT32 FCV_RAW = (0);
09DF  01B4  	CLRF gbl_FCV_RAW
09E0  01B5  	CLRF gbl_FCV_RAW+D'1'
09E1  01B6  	CLRF gbl_FCV_RAW+D'2'
09E2  01B7  	CLRF gbl_FCV_RAW+D'3'

MX_UINT8 FCV_DATA0 = (0xff);
09E3  30FF  	MOVLW 0xFF
09E4  00DA  	MOVWF gbl_FCV_DATA0

MX_UINT8 FCV_SAVE_IDXH = (0x0);
09E5  01DB  	CLRF gbl_FCV_SAVE_IDXH

MX_UINT8 FCV_DATA1 = (0xff);
09E6  30FF  	MOVLW 0xFF
09E7  00DC  	MOVWF gbl_FCV_DATA1

MX_UINT8 FCV_DP2 = (0x0);
09E8  01DD  	CLRF gbl_FCV_DP2

MX_UINT8 FCV_DATA2 = (0xff);
09E9  30FF  	MOVLW 0xFF
09EA  00DE  	MOVWF gbl_FCV_DATA2

MX_UINT8 FCV_CALIB_ADD0 = (0x2);
09EB  3002  	MOVLW 0x02
09EC  00DF  	MOVWF gbl_FCV_CALIB_ADD0

MX_FLOAT FCV_FL;
MX_UINT8 FCV_TEMP_DEC = (0x0);
09ED  01E0  	CLRF gbl_FCV_TEMP_DEC

MX_UINT8 FCV_CALIB_ADD1 = (0x3);
09EE  3003  	MOVLW 0x03
09EF  00E1  	MOVWF gbl_FCV_CALIB_ADD1

MX_UINT8 FCV_SAVE_IDXL = (0x0);
09F0  01E2  	CLRF gbl_FCV_SAVE_IDXL

MX_UINT8 FCV_TRIM_PREV = (0xff);
09F1  30FF  	MOVLW 0xFF
09F2  00E3  	MOVWF gbl_FCV_TRIM_PREV

MX_UINT8 FCV_TEMP_ONES = (0x0);
09F3  01E4  	CLRF gbl_FCV_TEMP_ONES

MX_UINT8 FCV_LSB = (0x0);
09F4  01E5  	CLRF gbl_FCV_LSB

MX_UINT8 FCV_RT_BYTE = (0x1);
09F5  3001  	MOVLW 0x01
09F6  00E6  	MOVWF gbl_FCV_RT_BYTE

MX_UINT16 FCV_CALIB_SUBTRACTOR = (0x0);
09F7  01C5  	CLRF gbl_FCV_CALIB_SUBTRACTOR
09F8  01C6  	CLRF gbl_FCV_CALIB_SUBTRACTOR+D'1'

MX_UINT8 FCV_MSB = (0x0);
09F9  01E7  	CLRF gbl_FCV_MSB

MX_UINT8 FCV_DIGIT = (0x0);
09FA  01E8  	CLRF gbl_FCV_DIGIT

MX_UINT8 FCV_CALIB_TEMP = (0x0);
09FB  01E9  	CLRF gbl_FCV_CALIB_TEMP

MX_BOOL FCV_FLAGBIT = (0);
09FC  106A  	BCF gbl_FCV_FLAGBIT,0

MX_SINT32 FCV_TRIM_DIFF = (0);
09FD  01B8  	CLRF gbl_FCV_TRIM_DIFF
09FE  01B9  	CLRF gbl_FCV_TRIM_DIFF+D'1'
09FF  01BA  	CLRF gbl_FCV_TRIM_DIFF+D'2'
0A00  01BB  	CLRF gbl_FCV_TRIM_DIFF+D'3'

MX_SINT32 FCV_TEMP_C = (0);
0A01  01BC  	CLRF gbl_FCV_TEMP_C
0A02  01BD  	CLRF gbl_FCV_TEMP_C+D'1'
0A03  01BE  	CLRF gbl_FCV_TEMP_C+D'2'
0A04  01BF  	CLRF gbl_FCV_TEMP_C+D'3'

MX_UINT8 FCV_I2C_RX = (0x0);
0A05  01EB  	CLRF gbl_FCV_I2C_RX

MX_UINT8 FCV_CALIB_FACTOR;
MX_UINT8 FCV_CALIB_VAR = (0x0);
0A06  01ED  	CLRF gbl_FCV_CALIB_VAR

MX_UINT8 FCV_DATA_PREV = (0xff);
0A07  30FF  	MOVLW 0xFF
0A08  00EE  	MOVWF gbl_FCV_DATA_PREV

MX_UINT8 FCV_SW_COUNTER = (0x0);
0A09  01EF  	CLRF gbl_FCV_SW_COUNTER

MX_UINT8 FCV_IHAP = (0x0);
0A0A  01F0  	CLRF gbl_FCV_IHAP

MX_SINT16 FCV_CALIB_OFFSET = (0);
0A0B  01C7  	CLRF gbl_FCV_CALIB_OFFSET
0A0C  01C8  	CLRF gbl_FCV_CALIB_OFFSET+D'1'

MX_BOOL FCV_SW_IR = (1);
0A0D  14EA  	BSF gbl_FCV_SW_IR,1

MX_UINT8 FCV_DATA_DIFF = (0x0);
0A0E  01F1  	CLRF gbl_FCV_DATA_DIFF

MX_UINT8 FCV_ERRORCOUNT = (0x0);
0A0F  01F2  	CLRF gbl_FCV_ERRORCOUNT


MX_UINT8 FCLV_LOOP1;
MX_UINT8 FCLV_LOOP2;
MX_UINT8 FCLV_LOOP3;
MX_UINT8 FCLV_LOOP4;
MX_UINT8 FCLV_LOOP5;
MX_UINT8 FCLV_LOOP6;
MX_UINT8 FCLV_LOOP7;



//I2C_Master(0): //Defines:

/**** Macro Substitutions ****
a = Unique component ID
b = I2C Channel - 0=SW, 1-4=HW
c = Baud Rate
d = SM BUS Enable 0/2
e = Slew Rate Enable 0/1
f = Bitbanged Data Port Letter
g = Bitbanged Data Pin
h = Bitbanged Clock Port Letter
i = Bitbanged Clock Pin
******************************/

//BMODE
//Bit 0 - Slew Control
//Bit 1 - SMBus Control

//Definitions for I2C slot allocation
#ifndef	MX_I2C_REF1
	#define MX_I2C_REF1
	#define I2CMASTER_1_MX_I2C_UREF			1
	#define MX_I2C_CHANNEL_1		1
	#define MX_I2C_SDA_PIN_1		4
	#define MX_I2C_SDA_PORT_1		portd
	#define MX_I2C_SDA_TRIS_1		trisd
	#define MX_I2C_SCL_PIN_1		3
	#define MX_I2C_SCL_PORT_1		portd
	#define MX_I2C_SCL_TRIS_1		trisd
	#define MX_I2C_BMODE_1			0 | 0
	#define MX_I2C_BAUD_1			100000
	#define MX_I2C_INT_1			0
#else
 #ifndef MX_I2C_REF2
	#define MX_I2C_REF2
	#define I2CMASTER_1_MX_I2C_UREF			2
	#define MX_I2C_CHANNEL_2		1
	#define MX_I2C_SDA_PIN_2		4
	#define MX_I2C_SDA_PORT_2		portd
	#define MX_I2C_SDA_TRIS_2		trisd
	#define MX_I2C_SCL_PIN_2		3
	#define MX_I2C_SCL_PORT_2		portd
	#define MX_I2C_SCL_TRIS_2		trisd
	#define MX_I2C_BMODE_2			0 | 0
	#define MX_I2C_BAUD_2			100000
	#define MX_I2C_INT_2			0
 #else
  #ifndef MX_I2C_REF3
	#define MX_I2C_REF3
	#define I2CMASTER_1_MX_I2C_UREF			3
	#define MX_I2C_CHANNEL_3		1
	#define MX_I2C_SDA_PIN_3		4
	#define MX_I2C_SDA_PORT_3		portd
	#define MX_I2C_SDA_TRIS_3		trisd
	#define MX_I2C_SCL_PIN_3		3
	#define MX_I2C_SCL_PORT_3		portd
	#define MX_I2C_SCL_TRIS_3		trisd
	#define MX_I2C_BMODE_3			0 | 0
	#define MX_I2C_BAUD_3			100000
	#define MX_I2C_INT_3			0
  #else
   #ifndef MX_I2C_REF4
	#define MX_I2C_REF4
	#define I2CMASTER_1_MX_I2C_UREF			4
	#define MX_I2C_CHANNEL_4		1
	#define MX_I2C_SDA_PIN_4		4
	#define MX_I2C_SDA_PORT_4		portd
	#define MX_I2C_SDA_TRIS_4		trisd
	#define MX_I2C_SCL_PIN_4		3
	#define MX_I2C_SCL_PORT_4		portd
	#define MX_I2C_SCL_TRIS_4		trisd
	#define MX_I2C_BMODE_4			0 | 0
	#define MX_I2C_BAUD_4			100000
	#define MX_I2C_INT_4			0
   #endif
  #endif
 #endif
#endif

#define I2CMASTER_1_I2C_Master_Init		CAL_APPEND(FC_CAL_I2C_Master_Init_, I2CMASTER_1_MX_I2C_UREF)
#define I2CMASTER_1_I2C_Master_Uninit	CAL_APPEND(FC_CAL_I2C_Master_Uninit_, I2CMASTER_1_MX_I2C_UREF)
#define I2CMASTER_1_I2C_Master_Start		CAL_APPEND(FC_CAL_I2C_Master_Start_, I2CMASTER_1_MX_I2C_UREF)
#define I2CMASTER_1_I2C_Master_Restart	CAL_APPEND(FC_CAL_I2C_Master_Restart_, I2CMASTER_1_MX_I2C_UREF)
#define I2CMASTER_1_I2C_Master_Stop		CAL_APPEND(FC_CAL_I2C_Master_Stop_, I2CMASTER_1_MX_I2C_UREF)
#define I2CMASTER_1_I2C_Master_TX_Byte	CAL_APPEND(FC_CAL_I2C_Master_TX_Byte_, I2CMASTER_1_MX_I2C_UREF)
#define I2CMASTER_1_I2C_Master_RX_Byte	CAL_APPEND(FC_CAL_I2C_Master_RX_Byte_, I2CMASTER_1_MX_I2C_UREF)

extern void I2CMASTER_1_I2C_Master_Init ();
extern void I2CMASTER_1_I2C_Master_Uninit ();
extern void I2CMASTER_1_I2C_Master_Start ();
extern void I2CMASTER_1_I2C_Master_Restart ();
extern void I2CMASTER_1_I2C_Master_Stop ();
extern MX_UINT8 I2CMASTER_1_I2C_Master_TX_Byte (MX_UINT8 Data);
extern MX_UINT8 I2CMASTER_1_I2C_Master_RX_Byte (MX_UINT8 Last);




//I2C_Master(0): //Macro function declarations

void FCD_I2C_Master0_MI2C_Init();
void FCD_I2C_Master0_MI2C_Start();
void FCD_I2C_Master0_MI2C_Restart();
void FCD_I2C_Master0_MI2C_Stop();
MX_UINT8 FCD_I2C_Master0_MI2C_Transmit_Byte(MX_UINT8 Data);
MX_UINT8 FCD_I2C_Master0_MI2C_Receive_Byte(MX_UINT8 Last);
void FCD_I2C_Master0_MI2C_Send_Byte_Transaction(MX_UINT8 Device_ID, MX_UINT8 AddrH, MX_UINT8 AddrL, MX_UINT8 Data);
MX_UINT8 FCD_I2C_Master0_MI2C_Receive_Byte_Transaction(MX_UINT8 Device_ID, MX_UINT8 AddrH, MX_UINT8 AddrL);


//ADC(0): //Defines:

/**** Macro Substitutions ****
a = Unique Reference
b = Which ADC Channel
c = Acquisition time
d = Conversion Speed
e = VRef+ Option
f = VRef Voltage x 0.01V
******************************/

//Common Defines

#define ADC_3_MX_ADC_CHANNEL	4
#define ADC_3_MX_ADC_ACTIME	40
#define ADC_3_MX_ADC_CONVSP	3
#define ADC_3_MX_ADC_VREFOP	0
#define ADC_3_MX_ADC_VREFVOL	500

#ifndef MX_ADC_CHANNEL_4
 #define MX_ADC_CHANNEL_4			//Inform CAL ADC channel 4 is now in use.
#endif

#ifndef MX_ADC_REF					//Inform CAL ADC peripheral is now in use
 #define MX_ADC_REF
#endif

extern void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge);
extern MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode);
extern void FC_CAL_Disable_ADC (void);




//ADC(0): //Macro function declarations

void FCD_ADC0_SampleADC();
MX_UINT8 FCD_ADC0_ReadAsByte();
MX_UINT16 FCD_ADC0_ReadAsInt();
MX_FLOAT FCD_ADC0_ReadAsVoltage();
void FCD_ADC0_ReadAsString(MX_CHAR* FCR_RETVAL, MX_UINT8 FCR_RETVAL_SIZE);
void FCD_ADC0_ADC_RAW_Configure_Channel();
MX_UINT8 FCD_ADC0_ADC_RAW_Sample_Channel_Byte();
MX_UINT16 FCD_ADC0_ADC_RAW_Sample_Channel_Int();
MX_UINT8 FCD_ADC0_ADC_RAW_Average_Channel_Byte(MX_UINT8 NumSamples, MX_UINT8 DelayUs);
MX_UINT16 FCD_ADC0_ADC_RAW_Average_Channel_Int(MX_UINT8 NumSamples, MX_UINT8 DelayUs);
void FCD_ADC0_ADC_RAW_Disable_Channel();


//PWM(0): //Defines:

/**** Macro Substitutions ****
a = Unique Reference
b = PWM Channel - 0=SW / 1-8=HW
c = PWM Alt Pin FCD_PWM0_Enable - 0=Standard / 1=Alt
d = PWM Period
e = PWM Prescaler 1
******************************/

//Period and Prescaler Defines
#ifndef MX_PWM_PERIOD
  #define MX_PWM_PERIOD				150
#else
  #if (MX_PWM_PERIOD != 150)
    #error "PWM period value must be the same in all PWM modules"
  #endif
#endif

#ifndef MX_PWM_PRESCALE1
  #define MX_PWM_PRESCALE1			1
#else
  #if (MX_PWM_PRESCALE1 != 1)
    #error "PWM prescale value must be the same in all PWM modules"
  #endif
#endif

//Definitions for PWM slot allocation
#ifndef	MX_PWM_REF1
			#define MX_PWM_REF1
			#define PWM_5_MX_PWM_UREF			1
			#define MX_PWM_CHANNEL_1		1
			#define MX_PWM_HWALT_1			0
#else
 #ifndef	MX_PWM_REF2
			#define MX_PWM_REF2
			#define PWM_5_MX_PWM_UREF			2
			#define MX_PWM_CHANNEL_2		1
			#define MX_PWM_HWALT_2			0
 #else
  #ifndef	MX_PWM_REF3
			#define MX_PWM_REF3
			#define PWM_5_MX_PWM_UREF			3
			#define MX_PWM_CHANNEL_3		1
			#define MX_PWM_HWALT_3			0
  #else
   #ifndef	MX_PWM_REF4
			#define MX_PWM_REF4
			#define PWM_5_MX_PWM_UREF			4
			#define MX_PWM_CHANNEL_4		1
			#define MX_PWM_HWALT_4			0
   #else
    #ifndef	MX_PWM_REF5
			#define MX_PWM_REF5
			#define PWM_5_MX_PWM_UREF			5
			#define MX_PWM_CHANNEL_5		1
			#define MX_PWM_HWALT_5			0
    #else
     #ifndef	MX_PWM_REF6
			#define MX_PWM_REF6
			#define PWM_5_MX_PWM_UREF			6
			#define MX_PWM_CHANNEL_6		1
			#define MX_PWM_HWALT_6			0
     #else
      #ifndef	MX_PWM_REF7
			#define MX_PWM_REF7
			#define PWM_5_MX_PWM_UREF			7
			#define MX_PWM_CHANNEL_7		1
			#define MX_PWM_HWALT_7			0
      #else
       #ifndef	MX_PWM_REF8
			#define MX_PWM_REF8
			#define PWM_5_MX_PWM_UREF			8
			#define MX_PWM_CHANNEL_8		1
			#define MX_PWM_HWALT_8			0
       #else
        #ifndef	MX_PWM_REF9
			#define MX_PWM_REF9
			#define PWM_5_MX_PWM_UREF			9
			#define MX_PWM_CHANNEL_9		1
			#define MX_PWM_HWALT_9			0
        #else
         #ifndef	MX_PWM_REF10
			#define MX_PWM_REF10
			#define PWM_5_MX_PWM_UREF			10
			#define MX_PWM_CHANNEL_10		1
			#define MX_PWM_HWALT_10			0
         #endif
        #endif
       #endif
      #endif
     #endif
    #endif
   #endif
  #endif
 #endif
#endif

#define PWM_5_PWM_Enable_Channel		CAL_APPEND(FC_CAL_PWM_Enable_Channel_, PWM_5_MX_PWM_UREF)
#define PWM_5_PWM_Disable_Channel		CAL_APPEND(FC_CAL_PWM_Disable_Channel_, PWM_5_MX_PWM_UREF)
#define PWM_5_PWM_Set_Duty_8Bit		CAL_APPEND(FC_CAL_PWM_Set_Duty_8Bit_, PWM_5_MX_PWM_UREF)
#define PWM_5_PWM_Change_Period		CAL_APPEND(FC_CAL_PWM_Change_Period_, PWM_5_MX_PWM_UREF)
#define PWM_5_PWM_Set_Duty_10Bit		CAL_APPEND(FC_CAL_PWM_Set_Duty_10Bit_, PWM_5_MX_PWM_UREF)

extern void PWM_5_PWM_Enable_Channel ();
extern void PWM_5_PWM_Disable_Channel ();
extern void PWM_5_PWM_Set_Duty_8Bit (MX_UINT8 duty);
extern void PWM_5_PWM_Change_Period (MX_UINT8 period, MX_UINT16 prescaler);
extern void PWM_5_PWM_Set_Duty_10Bit (MX_UINT16 duty);




//PWM(0): //Macro function declarations

void FCD_PWM0_Enable();
void FCD_PWM0_Disable();
void FCD_PWM0_SetDutyCycle(MX_UINT8 nDuty);
void FCD_PWM0_ChangePeriod(MX_UINT8 nPeriodVal, MX_UINT8 nPrescalerVal);
void FCD_PWM0_SetDutyCycle10bit(MX_SINT16 nDuty);



//I2C_Master(0): //Macro implementations


void FCD_I2C_Master0_MI2C_Init()

{
	
		I2CMASTER_1_I2C_Master_Init();
07A5  2389  	CALL FC_CAL_I2C_00061


}
07A6  0008  	RETURN


void FCD_I2C_Master0_MI2C_Start()

{
	
		I2CMASTER_1_I2C_Master_Start();
0595  22DB  	CALL FC_CAL_I2C_00063


}
0596  0008  	RETURN


void FCD_I2C_Master0_MI2C_Restart()

{
	
		I2CMASTER_1_I2C_Master_Restart();
058D  22D3  	CALL FC_CAL_I2C_00064


}
058E  0008  	RETURN


void FCD_I2C_Master0_MI2C_Stop()

{
	
		I2CMASTER_1_I2C_Master_Stop();
0585  22C8  	CALL FC_CAL_I2C_00065


}
0586  0008  	RETURN


MX_UINT8 FCD_I2C_Master0_MI2C_Transmit_Byte(MX_UINT8 Data)

{
	
		return I2CMASTER_1_I2C_Master_TX_Byte(Data);
058F  087B  	MOVF FCD_I2C_Ma_00053_arg_Data, W
0590  00FC  	MOVWF FC_CAL_I2C_00066_arg_Data
0591  22B9  	CALL FC_CAL_I2C_00066
0592  087D  	MOVF CompTempVarRet2270, W
0593  00FC  	MOVWF CompTempVarRet2195


}
0594  0008  	RETURN


MX_UINT8 FCD_I2C_Master0_MI2C_Receive_Byte(MX_UINT8 Last)

{
	
		return I2CMASTER_1_I2C_Master_RX_Byte(Last);
0587  087B  	MOVF FCD_I2C_Ma_00055_arg_Last, W
0588  00FC  	MOVWF FC_CAL_I2C_00067_arg_Last
0589  22A4  	CALL FC_CAL_I2C_00067
058A  087D  	MOVF CompTempVarRet2271, W
058B  00FC  	MOVWF CompTempVarRet2196


}
058C  0008  	RETURN


void FCD_I2C_Master0_MI2C_Send_Byte_Transaction(MX_UINT8 Device_ID, MX_UINT8 AddrH, MX_UINT8 AddrL, MX_UINT8 Data)
{
	
		Device_ID = Device_ID << 1;					//Shift Device ID to enable write mode

		I2CMASTER_1_I2C_Master_Start();						//Start transaction
		I2CMASTER_1_I2C_Master_TX_Byte(Device_ID);			//Transmit Device Address
		I2CMASTER_1_I2C_Master_TX_Byte(AddrH);				//Transmit Internal Address
		I2CMASTER_1_I2C_Master_TX_Byte(AddrL);
		I2CMASTER_1_I2C_Master_TX_Byte(Data);				//Send Data byte
		I2CMASTER_1_I2C_Master_Stop();						//Stop Transaction

}

MX_UINT8 FCD_I2C_Master0_MI2C_Receive_Byte_Transaction(MX_UINT8 Device_ID, MX_UINT8 AddrH, MX_UINT8 AddrL)
{
	
		MX_UINT8 RetVal = 0;
		Device_ID = Device_ID << 1;					//Shift Device ID to enable write mode

		I2CMASTER_1_I2C_Master_Start();						//Start transaction
		I2CMASTER_1_I2C_Master_TX_Byte(Device_ID);			//Transmit Device Address
		I2CMASTER_1_I2C_Master_TX_Byte(AddrH);				//Transmit Internal Address
		I2CMASTER_1_I2C_Master_TX_Byte(AddrL);
		I2CMASTER_1_I2C_Master_Restart();					//Restart transaction

		Device_ID = Device_ID | 0x01;				//Change Device ID to read mode
		I2CMASTER_1_I2C_Master_TX_Byte(Device_ID);			//Transmit Device Address
		RetVal = I2CMASTER_1_I2C_Master_RX_Byte(1);			//Read data at address
		I2CMASTER_1_I2C_Master_Stop();						//Stop Transaction

		return RetVal;								//Return data

}



//ADC(0): //Macro implementations


void FCD_ADC0_SampleADC()
{
	
	    //unused

}

MX_UINT8 FCD_ADC0_ReadAsByte()

{
	
		MX_UINT8 retVal;

		//Configure & Enable ADC Channel
		FC_CAL_Enable_ADC ( ADC_3_MX_ADC_CHANNEL , ADC_3_MX_ADC_CONVSP , ADC_3_MX_ADC_VREFOP , ADC_3_MX_ADC_ACTIME );
0318  3004  	MOVLW 0x04
0319  1683  	BSF STATUS, RP0
031A  1303  	BCF STATUS, RP1
031B  00A2  	MOVWF FC_CAL_Ena_0006B_arg_Channel
031C  3003  	MOVLW 0x03
031D  00A3  	MOVWF FC_CAL_Ena_0006B_arg_Conv_Speed
031E  01A4  	CLRF FC_CAL_Ena_0006B_arg_Vref
031F  3028  	MOVLW 0x28
0320  00A5  	MOVWF FC_CAL_Ena_0006B_arg_T_Charge
0321  204E  	CALL FC_CAL_Ena_0006B


		retVal = FC_CAL_Sample_ADC( 0 );				//Perform Sample - Return as byte
0322  01A2  	CLRF FC_CAL_Sam_0006C_arg_Sample_Mode
0323  2026  	CALL FC_CAL_Sam_0006C
0324  0825  	MOVF CompTempVarRet2282, W
0325  00A1  	MOVWF FCD_ADC0_R_0005C_1_retVal


		FC_CAL_Disable_ADC ();
0326  2095  	CALL FC_CAL_Dis_0006D


		return (retVal);
0327  1683  	BSF STATUS, RP0
0328  0821  	MOVF FCD_ADC0_R_0005C_1_retVal, W
0329  00A2  	MOVWF CompTempVarRet2255


}
032A  0008  	RETURN


MX_UINT16 FCD_ADC0_ReadAsInt()
{
	
		MX_UINT16 retVal;

		//Configure & Enable ADC Channel
		FC_CAL_Enable_ADC ( ADC_3_MX_ADC_CHANNEL , ADC_3_MX_ADC_CONVSP , ADC_3_MX_ADC_VREFOP , ADC_3_MX_ADC_ACTIME );

		retVal = FC_CAL_Sample_ADC( 1 );				//Perform Sample - Return as MX_UINT16

		FC_CAL_Disable_ADC ();

		return (retVal);

}

MX_FLOAT FCD_ADC0_ReadAsVoltage()
{
	
		MX_UINT16 iSample;
		MX_FLOAT fSample, fVoltage, fVperDiv;

		//Configure & Enable ADC Channel
		FC_CAL_Enable_ADC ( ADC_3_MX_ADC_CHANNEL , ADC_3_MX_ADC_CONVSP , ADC_3_MX_ADC_VREFOP , ADC_3_MX_ADC_ACTIME );

	  #ifdef MX_ADC_BITS_8
		iSample = FC_CAL_Sample_ADC( 0 );								//Perform Sample - Return as byte
	  #else
		iSample = FC_CAL_Sample_ADC( 1 );								//Perform Sample - Return as MX_UINT16
	  #endif

	  	FC_CAL_Disable_ADC ();											//Switch off ADC peripheral
		fVoltage = flt_fromi( ADC_3_MX_ADC_VREFVOL );						//Convert reference voltage count to floating point (0 - 500 x 10mV)
		fVoltage = flt_mul(fVoltage, 0.01);								//Convert reference voltage count to actual voltage (0 - 5)

	  #ifdef MX_ADC_BITS_8
		fVperDiv = flt_mul(fVoltage, 0.00390625);						//Convert actual voltage to voltage per division (VRef / 256)
	  #endif
	  #ifdef MX_ADC_BITS_10
		fVperDiv = flt_mul(fVoltage, 0.000976);							//Convert actual voltage to voltage per division (VRef / 1024)
	  #endif
	  #ifdef MX_ADC_BITS_12
		fVperDiv = flt_mul(fVoltage, 0.00024414);						//Convert actual voltage to voltage per division (VRef / 4096)
	  #endif

		fSample = flt_fromi(iSample);									//Convert to floating point variable
		fVoltage = flt_mul(fSample, fVperDiv);							//Calculate floating point voltage

		return (fVoltage);

}

void FCD_ADC0_ReadAsString(MX_CHAR* FCR_RETVAL, MX_UINT8 FCR_RETVAL_SIZE)
{
	
		MX_FLOAT fVoltage;

		fVoltage = FCD_ADC0_ReadAsVoltage();
		FCI_FLOAT_TO_STRING(fVoltage, 2, FCR_RETVAL, FCR_RETVAL_SIZE);	//Convert to String

}

void FCD_ADC0_ADC_RAW_Configure_Channel()
{
	
		//Configure & Enable ADC Channel
		FC_CAL_Enable_ADC ( ADC_3_MX_ADC_CHANNEL , ADC_3_MX_ADC_CONVSP , ADC_3_MX_ADC_VREFOP , ADC_3_MX_ADC_ACTIME );

}

MX_UINT8 FCD_ADC0_ADC_RAW_Sample_Channel_Byte()
{
	
		return FC_CAL_Sample_ADC( 0 );									//Perform Sample - Return as byte

}

MX_UINT16 FCD_ADC0_ADC_RAW_Sample_Channel_Int()
{
	
		return FC_CAL_Sample_ADC( 1 );									//Perform Sample - Return as MX_UINT16

}

MX_UINT8 FCD_ADC0_ADC_RAW_Average_Channel_Byte(MX_UINT8 NumSamples, MX_UINT8 DelayUs)
{
	
		MX_UINT32 average = 0;
		MX_UINT8 count;

		for (count=0; count<NumSamples; count++)
		{
			average = average + FC_CAL_Sample_ADC( 0 );					//Perform Sample - Return as byte - add to average

			if (DelayUs)
				delay_us(DelayUs);										//If delay is not 0 then pause between samples
		}
		average = average / count;

		return (average & 0xFF);										//Return average as byte

}

MX_UINT16 FCD_ADC0_ADC_RAW_Average_Channel_Int(MX_UINT8 NumSamples, MX_UINT8 DelayUs)
{
	
		MX_UINT32 average = 0;
		MX_UINT8 count;

		for (count=0; count<NumSamples; count++)
		{
			average = average + FC_CAL_Sample_ADC( 1 );					//Perform Sample - Return as MX_UINT16 - add to average

			if (DelayUs)
				delay_us(DelayUs);										//If delay is not 0 then pause between samples
		}
		average = average / count;

		return (average & 0x1FFF);										//Return average as MX_SINT16

}

void FCD_ADC0_ADC_RAW_Disable_Channel()
{
	
		FC_CAL_Disable_ADC ();											//Disable ADC Channel

}



//PWM(0): //Macro implementations


void FCD_PWM0_Enable()

{
	
		PWM_5_PWM_Change_Period (MX_PWM_PERIOD, MX_PWM_PRESCALE1);
0798  3096  	MOVLW 0x96
0799  1283  	BCF STATUS, RP0
079A  1303  	BCF STATUS, RP1
079B  00FE  	MOVWF FC_CAL_PWM_0007C_arg_period
079C  3001  	MOVLW 0x01
079D  1683  	BSF STATUS, RP0
079E  00A0  	MOVWF FC_CAL_PWM_0007C_arg_prescaler
079F  01A1  	CLRF FC_CAL_PWM_0007C_arg_prescaler+D'1'
07A0  2354  	CALL FC_CAL_PWM_0007C

		PWM_5_PWM_Enable_Channel ();
07A1  2381  	CALL FC_CAL_PWM_00079


}
07A2  0008  	RETURN


void FCD_PWM0_Disable()

{
	
		PWM_5_PWM_Disable_Channel();
07A3  237B  	CALL FC_CAL_PWM_0007A


}
07A4  0008  	RETURN


void FCD_PWM0_SetDutyCycle(MX_UINT8 nDuty)

{
	
		PWM_5_PWM_Set_Duty_8Bit(nDuty);
0793  087E  	MOVF FCD_PWM0_S_00080_arg_nDuty, W
0794  1683  	BSF STATUS, RP0
0795  00A0  	MOVWF FC_CAL_PWM_0007B_arg_duty
0796  2377  	CALL FC_CAL_PWM_0007B


}
0797  0008  	RETURN


void FCD_PWM0_ChangePeriod(MX_UINT8 nPeriodVal, MX_UINT8 nPrescalerVal)
{
	
		PWM_5_PWM_Change_Period (nPeriodVal, nPrescalerVal);

}

void FCD_PWM0_SetDutyCycle10bit(MX_SINT16 nDuty)
{
	
		PWM_5_PWM_Set_Duty_10Bit(nDuty);

}

#include "C:\Program Files (x86)\Flowcode\v5\CAL\includes.c"

//Macro implementations


void FCM_i2c_comm()

{

	//Call Component Macro
	//Call Component Macro: MI2C_Start()
	FCD_I2C_Master0_MI2C_Start();
0597  2595  	CALL FCD_I2C_Ma_00052


	//Calculation
	//Calculation:
	//  rt_byte = 0
	FCV_RT_BYTE = 0;
0598  1283  	BCF STATUS, RP0
0599  01E6  	CLRF gbl_FCV_RT_BYTE


	//Call Component Macro
	//Call Component Macro: rt_byte=MI2C_Transmit_Byte(0xB4)
	FCV_RT_BYTE = FCD_I2C_Master0_MI2C_Transmit_Byte(0xB4);
059A  30B4  	MOVLW 0xB4
059B  00FB  	MOVWF FCD_I2C_Ma_00053_arg_Data
059C  258F  	CALL FCD_I2C_Ma_00053
059D  087C  	MOVF CompTempVarRet2195, W
059E  00E6  	MOVWF gbl_FCV_RT_BYTE


	//Calculation
	//Calculation:
	//  rt_byte = 0
	FCV_RT_BYTE = 0;
059F  01E6  	CLRF gbl_FCV_RT_BYTE


	//Call Component Macro
	//Call Component Macro: rt_byte=MI2C_Transmit_Byte(0x07)
	FCV_RT_BYTE = FCD_I2C_Master0_MI2C_Transmit_Byte(0x07);
05A0  3007  	MOVLW 0x07
05A1  00FB  	MOVWF FCD_I2C_Ma_00053_arg_Data
05A2  258F  	CALL FCD_I2C_Ma_00053
05A3  087C  	MOVF CompTempVarRet2195, W
05A4  00E6  	MOVWF gbl_FCV_RT_BYTE


	//Comment:
	//end of RD/WR cmd

	//Call Component Macro
	//Call Component Macro: MI2C_Restart()
	FCD_I2C_Master0_MI2C_Restart();
05A5  258D  	CALL FCD_I2C_Ma_00054


	//Calculation
	//Calculation:
	//  rt_byte = 0
	FCV_RT_BYTE = 0;
05A6  1283  	BCF STATUS, RP0
05A7  01E6  	CLRF gbl_FCV_RT_BYTE


	//Call Component Macro
	//Call Component Macro: rt_byte=MI2C_Transmit_Byte(0xB4)
	FCV_RT_BYTE = FCD_I2C_Master0_MI2C_Transmit_Byte(0xB4);
05A8  30B4  	MOVLW 0xB4
05A9  00FB  	MOVWF FCD_I2C_Ma_00053_arg_Data
05AA  258F  	CALL FCD_I2C_Ma_00053
05AB  087C  	MOVF CompTempVarRet2195, W
05AC  00E6  	MOVWF gbl_FCV_RT_BYTE


	//Call Component Macro
	//Call Component Macro: i2c_rx=MI2C_Receive_Byte(rt_byte)
	FCV_I2C_RX = FCD_I2C_Master0_MI2C_Receive_Byte(FCV_RT_BYTE);
05AD  0866  	MOVF gbl_FCV_RT_BYTE, W
05AE  00FB  	MOVWF FCD_I2C_Ma_00055_arg_Last
05AF  2587  	CALL FCD_I2C_Ma_00055
05B0  087C  	MOVF CompTempVarRet2196, W
05B1  00EB  	MOVWF gbl_FCV_I2C_RX


	//Calculation
	//Calculation:
	//  data0 = i2c_rx
	FCV_DATA0 = FCV_I2C_RX;
05B2  086B  	MOVF gbl_FCV_I2C_RX, W
05B3  00DA  	MOVWF gbl_FCV_DATA0


	//Call Component Macro
	//Call Component Macro: i2c_rx=MI2C_Receive_Byte(rt_byte)
	FCV_I2C_RX = FCD_I2C_Master0_MI2C_Receive_Byte(FCV_RT_BYTE);
05B4  0866  	MOVF gbl_FCV_RT_BYTE, W
05B5  00FB  	MOVWF FCD_I2C_Ma_00055_arg_Last
05B6  2587  	CALL FCD_I2C_Ma_00055
05B7  087C  	MOVF CompTempVarRet2196, W
05B8  00EB  	MOVWF gbl_FCV_I2C_RX


	//Calculation
	//Calculation:
	//  data1 = i2c_rx
	FCV_DATA1 = FCV_I2C_RX;
05B9  086B  	MOVF gbl_FCV_I2C_RX, W
05BA  00DC  	MOVWF gbl_FCV_DATA1


	//Call Component Macro
	//Call Component Macro: i2c_rx=MI2C_Receive_Byte(rt_byte)
	FCV_I2C_RX = FCD_I2C_Master0_MI2C_Receive_Byte(FCV_RT_BYTE);
05BB  0866  	MOVF gbl_FCV_RT_BYTE, W
05BC  00FB  	MOVWF FCD_I2C_Ma_00055_arg_Last
05BD  2587  	CALL FCD_I2C_Ma_00055
05BE  087C  	MOVF CompTempVarRet2196, W
05BF  00EB  	MOVWF gbl_FCV_I2C_RX


	//Calculation
	//Calculation:
	//  data2 = i2c_rx
	FCV_DATA2 = FCV_I2C_RX;
05C0  086B  	MOVF gbl_FCV_I2C_RX, W
05C1  00DE  	MOVWF gbl_FCV_DATA2


	//Call Component Macro
	//Call Component Macro: MI2C_Stop()
	FCD_I2C_Master0_MI2C_Stop();
05C2  2585  	CALL FCD_I2C_Ma_00056


}
05C3  0008  	RETURN



void FCM_intro()
{

	//Call Macro
	//Call Macro: scan1()
	FCM_scan1();

	//Call Macro
	//Call Macro: ikotled()
	FCM_ikotled();

	//Call Macro
	//Call Macro: scan2()
	FCM_scan2();

	//Call Macro
	//Call Macro: ikotled()
	FCM_ikotled();

	//Call Macro
	//Call Macro: scan3()
	FCM_scan3();

	//Call Macro
	//Call Macro: ikotled()
	FCM_ikotled();

	//Call Macro
	//Call Macro: scan4()
	FCM_scan4();

	//Call Macro
	//Call Macro: ikotled()
	FCM_ikotled();

	//Delay
	//Delay: 500 ms
	delay_ms(255);
	delay_ms(245);

}


void FCM_scan1()

{

	//Output
	//Output: 1 -> A0
	trisa = trisa & 0xFE;
01E9  30FE  	MOVLW 0xFE
01EA  1683  	BSF STATUS, RP0
01EB  1303  	BCF STATUS, RP1
01EC  0505  	ANDWF gbl_trisa, W
01ED  0085  	MOVWF gbl_trisa

	if ((1))
		porta = (porta & 0xFE) | 0x01;
01EE  30FE  	MOVLW 0xFE
01EF  1283  	BCF STATUS, RP0
01F0  0505  	ANDWF gbl_porta, W
01F1  1683  	BSF STATUS, RP0
01F2  00A1  	MOVWF CompTempVar2197
01F3  3001  	MOVLW 0x01
01F4  0421  	IORWF CompTempVar2197, W
01F5  1283  	BCF STATUS, RP0
01F6  0085  	MOVWF gbl_porta

	else
		porta = porta & 0xFE;

	//Output
	//Output: 0 -> A1
	trisa = trisa & 0xFD;
01F7  30FD  	MOVLW 0xFD
01F8  1683  	BSF STATUS, RP0
01F9  0505  	ANDWF gbl_trisa, W
01FA  0085  	MOVWF gbl_trisa

	if ((0))
		porta = (porta & 0xFD) | 0x02;
	else
		porta = porta & 0xFD;
01FB  30FD  	MOVLW 0xFD
01FC  1283  	BCF STATUS, RP0
01FD  0505  	ANDWF gbl_porta, W
01FE  0085  	MOVWF gbl_porta


	//Output
	//Output: 0 -> A2
	trisa = trisa & 0xFB;
01FF  30FB  	MOVLW 0xFB
0200  1683  	BSF STATUS, RP0
0201  0505  	ANDWF gbl_trisa, W
0202  0085  	MOVWF gbl_trisa

	if ((0))
		porta = (porta & 0xFB) | 0x04;
	else
		porta = porta & 0xFB;
0203  30FB  	MOVLW 0xFB
0204  1283  	BCF STATUS, RP0
0205  0505  	ANDWF gbl_porta, W
0206  0085  	MOVWF gbl_porta


	//Output
	//Output: 0 -> A3
	trisa = trisa & 0xF7;
0207  30F7  	MOVLW 0xF7
0208  1683  	BSF STATUS, RP0
0209  0505  	ANDWF gbl_trisa, W
020A  0085  	MOVWF gbl_trisa

	if ((0))
		porta = (porta & 0xF7) | 0x08;
	else
		porta = porta & 0xF7;
020B  30F7  	MOVLW 0xF7
020C  1283  	BCF STATUS, RP0
020D  0505  	ANDWF gbl_porta, W
020E  0085  	MOVWF gbl_porta


}
020F  0008  	RETURN



void FCM_scan2()

{

	//Output
	//Output: 0 -> A0
	trisa = trisa & 0xFE;
01C2  30FE  	MOVLW 0xFE
01C3  1683  	BSF STATUS, RP0
01C4  1303  	BCF STATUS, RP1
01C5  0505  	ANDWF gbl_trisa, W
01C6  0085  	MOVWF gbl_trisa

	if ((0))
		porta = (porta & 0xFE) | 0x01;
	else
		porta = porta & 0xFE;
01C7  30FE  	MOVLW 0xFE
01C8  1283  	BCF STATUS, RP0
01C9  0505  	ANDWF gbl_porta, W
01CA  0085  	MOVWF gbl_porta


	//Output
	//Output: 1 -> A1
	trisa = trisa & 0xFD;
01CB  30FD  	MOVLW 0xFD
01CC  1683  	BSF STATUS, RP0
01CD  0505  	ANDWF gbl_trisa, W
01CE  0085  	MOVWF gbl_trisa

	if ((1))
		porta = (porta & 0xFD) | 0x02;
01CF  30FD  	MOVLW 0xFD
01D0  1283  	BCF STATUS, RP0
01D1  0505  	ANDWF gbl_porta, W
01D2  1683  	BSF STATUS, RP0
01D3  00A1  	MOVWF CompTempVar2199
01D4  3002  	MOVLW 0x02
01D5  0421  	IORWF CompTempVar2199, W
01D6  1283  	BCF STATUS, RP0
01D7  0085  	MOVWF gbl_porta

	else
		porta = porta & 0xFD;

	//Output
	//Output: 0 -> A2
	trisa = trisa & 0xFB;
01D8  30FB  	MOVLW 0xFB
01D9  1683  	BSF STATUS, RP0
01DA  0505  	ANDWF gbl_trisa, W
01DB  0085  	MOVWF gbl_trisa

	if ((0))
		porta = (porta & 0xFB) | 0x04;
	else
		porta = porta & 0xFB;
01DC  30FB  	MOVLW 0xFB
01DD  1283  	BCF STATUS, RP0
01DE  0505  	ANDWF gbl_porta, W
01DF  0085  	MOVWF gbl_porta


	//Output
	//Output: 0 -> A3
	trisa = trisa & 0xF7;
01E0  30F7  	MOVLW 0xF7
01E1  1683  	BSF STATUS, RP0
01E2  0505  	ANDWF gbl_trisa, W
01E3  0085  	MOVWF gbl_trisa

	if ((0))
		porta = (porta & 0xF7) | 0x08;
	else
		porta = porta & 0xF7;
01E4  30F7  	MOVLW 0xF7
01E5  1283  	BCF STATUS, RP0
01E6  0505  	ANDWF gbl_porta, W
01E7  0085  	MOVWF gbl_porta


}
01E8  0008  	RETURN



void FCM_scan3()

{

	//Output
	//Output: 0 -> A0
	trisa = trisa & 0xFE;
019B  30FE  	MOVLW 0xFE
019C  1683  	BSF STATUS, RP0
019D  1303  	BCF STATUS, RP1
019E  0505  	ANDWF gbl_trisa, W
019F  0085  	MOVWF gbl_trisa

	if ((0))
		porta = (porta & 0xFE) | 0x01;
	else
		porta = porta & 0xFE;
01A0  30FE  	MOVLW 0xFE
01A1  1283  	BCF STATUS, RP0
01A2  0505  	ANDWF gbl_porta, W
01A3  0085  	MOVWF gbl_porta


	//Output
	//Output: 0 -> A1
	trisa = trisa & 0xFD;
01A4  30FD  	MOVLW 0xFD
01A5  1683  	BSF STATUS, RP0
01A6  0505  	ANDWF gbl_trisa, W
01A7  0085  	MOVWF gbl_trisa

	if ((0))
		porta = (porta & 0xFD) | 0x02;
	else
		porta = porta & 0xFD;
01A8  30FD  	MOVLW 0xFD
01A9  1283  	BCF STATUS, RP0
01AA  0505  	ANDWF gbl_porta, W
01AB  0085  	MOVWF gbl_porta


	//Output
	//Output: 1 -> A2
	trisa = trisa & 0xFB;
01AC  30FB  	MOVLW 0xFB
01AD  1683  	BSF STATUS, RP0
01AE  0505  	ANDWF gbl_trisa, W
01AF  0085  	MOVWF gbl_trisa

	if ((1))
		porta = (porta & 0xFB) | 0x04;
01B0  30FB  	MOVLW 0xFB
01B1  1283  	BCF STATUS, RP0
01B2  0505  	ANDWF gbl_porta, W
01B3  1683  	BSF STATUS, RP0
01B4  00A1  	MOVWF CompTempVar2200
01B5  3004  	MOVLW 0x04
01B6  0421  	IORWF CompTempVar2200, W
01B7  1283  	BCF STATUS, RP0
01B8  0085  	MOVWF gbl_porta

	else
		porta = porta & 0xFB;

	//Output
	//Output: 0 -> A3
	trisa = trisa & 0xF7;
01B9  30F7  	MOVLW 0xF7
01BA  1683  	BSF STATUS, RP0
01BB  0505  	ANDWF gbl_trisa, W
01BC  0085  	MOVWF gbl_trisa

	if ((0))
		porta = (porta & 0xF7) | 0x08;
	else
		porta = porta & 0xF7;
01BD  30F7  	MOVLW 0xF7
01BE  1283  	BCF STATUS, RP0
01BF  0505  	ANDWF gbl_porta, W
01C0  0085  	MOVWF gbl_porta


}
01C1  0008  	RETURN



void FCM_scan4()

{

	//Output
	//Output: 0 -> A0
	trisa = trisa & 0xFE;
0174  30FE  	MOVLW 0xFE
0175  1683  	BSF STATUS, RP0
0176  1303  	BCF STATUS, RP1
0177  0505  	ANDWF gbl_trisa, W
0178  0085  	MOVWF gbl_trisa

	if ((0))
		porta = (porta & 0xFE) | 0x01;
	else
		porta = porta & 0xFE;
0179  30FE  	MOVLW 0xFE
017A  1283  	BCF STATUS, RP0
017B  0505  	ANDWF gbl_porta, W
017C  0085  	MOVWF gbl_porta


	//Output
	//Output: 0 -> A1
	trisa = trisa & 0xFD;
017D  30FD  	MOVLW 0xFD
017E  1683  	BSF STATUS, RP0
017F  0505  	ANDWF gbl_trisa, W
0180  0085  	MOVWF gbl_trisa

	if ((0))
		porta = (porta & 0xFD) | 0x02;
	else
		porta = porta & 0xFD;
0181  30FD  	MOVLW 0xFD
0182  1283  	BCF STATUS, RP0
0183  0505  	ANDWF gbl_porta, W
0184  0085  	MOVWF gbl_porta


	//Output
	//Output: 0 -> A2
	trisa = trisa & 0xFB;
0185  30FB  	MOVLW 0xFB
0186  1683  	BSF STATUS, RP0
0187  0505  	ANDWF gbl_trisa, W
0188  0085  	MOVWF gbl_trisa

	if ((0))
		porta = (porta & 0xFB) | 0x04;
	else
		porta = porta & 0xFB;
0189  30FB  	MOVLW 0xFB
018A  1283  	BCF STATUS, RP0
018B  0505  	ANDWF gbl_porta, W
018C  0085  	MOVWF gbl_porta


	//Output
	//Output: 1 -> A3
	trisa = trisa & 0xF7;
018D  30F7  	MOVLW 0xF7
018E  1683  	BSF STATUS, RP0
018F  0505  	ANDWF gbl_trisa, W
0190  0085  	MOVWF gbl_trisa

	if ((1))
		porta = (porta & 0xF7) | 0x08;
0191  30F7  	MOVLW 0xF7
0192  1283  	BCF STATUS, RP0
0193  0505  	ANDWF gbl_porta, W
0194  1683  	BSF STATUS, RP0
0195  00A1  	MOVWF CompTempVar2201
0196  3008  	MOVLW 0x08
0197  0421  	IORWF CompTempVar2201, W
0198  1283  	BCF STATUS, RP0
0199  0085  	MOVWF gbl_porta

	else
		porta = porta & 0xF7;

}
019A  0008  	RETURN



void FCM_ikotled()
{

	//Output
	//Output: 0 -> PORTB
	trisb = 0x00;
	portb = (0);

	//Calculation
	//Calculation:
	//  d_byte = 1
	FCV_D_BYTE = 1;

	//Delay
	//Delay: 200 ms
	delay_ms(200);

	//Loop
	//Loop: Loop 8 times
	for (FCLV_LOOP6=0; FCLV_LOOP6<8; FCLV_LOOP6++)
	{

		//Output
		//Output: d_byte -> PORTB
		trisb = 0x00;
		portb = (FCV_D_BYTE);

		//Calculation
		//Calculation:
		//  d_byte = d_byte * 2
		FCV_D_BYTE = FCV_D_BYTE * 2;

		//Delay
		//Delay: 100 ms
		delay_ms(100);


	}

}


void FCM_seg_pattern()

{

	//Switch
	//Switch: digit?
	switch (FCV_DIGIT)

	{
		case 1:
00A4  1283  	BCF STATUS, RP0
00A5  1303  	BCF STATUS, RP1
00A6  0868  	MOVF gbl_FCV_DIGIT, W
00A7  3A01  	XORLW 0x01
00A8  1903  	BTFSC STATUS,Z
00A9  28C6  	GOTO	label9
00C6        label9

		{
			//Output
			//Output: 0b10010000 -> PORTB
			trisb = trisb & 0x01;
00C6  3001  	MOVLW 0x01
00C7  1683  	BSF STATUS, RP0
00C8  0506  	ANDWF gbl_trisb, W
00C9  0086  	MOVWF gbl_trisb

			portb = (portb & 0x01) | ((144) & 0xFE);
00CA  3001  	MOVLW 0x01
00CB  1283  	BCF STATUS, RP0
00CC  0506  	ANDWF gbl_portb, W
00CD  1683  	BSF STATUS, RP0
00CE  00A1  	MOVWF CompTempVar2202
00CF  3090  	MOVLW 0x90
00D0  0421  	IORWF CompTempVar2202, W
00D1  1283  	BCF STATUS, RP0
00D2  0086  	MOVWF gbl_portb


			break;

		}
		case 2:
00AA  3A03  	XORLW 0x03
00AB  1903  	BTFSC STATUS,Z
00AC  28D4  	GOTO	label10
00D4        label10

		{
			//Output
			//Output: 0b01111010 -> PORTB
			trisb = trisb & 0x01;
00D4  3001  	MOVLW 0x01
00D5  1683  	BSF STATUS, RP0
00D6  0506  	ANDWF gbl_trisb, W
00D7  0086  	MOVWF gbl_trisb

			portb = (portb & 0x01) | ((122) & 0xFE);
00D8  3001  	MOVLW 0x01
00D9  1283  	BCF STATUS, RP0
00DA  0506  	ANDWF gbl_portb, W
00DB  1683  	BSF STATUS, RP0
00DC  00A1  	MOVWF CompTempVar2203
00DD  307A  	MOVLW 0x7A
00DE  0421  	IORWF CompTempVar2203, W
00DF  1283  	BCF STATUS, RP0
00E0  0086  	MOVWF gbl_portb


			break;

		}
		case 3:
00AD  3A01  	XORLW 0x01
00AE  1903  	BTFSC STATUS,Z
00AF  28E2  	GOTO	label11
00E2        label11

		{
			//Output
			//Output: 0b11011010 -> PORTB
			trisb = trisb & 0x01;
00E2  3001  	MOVLW 0x01
00E3  1683  	BSF STATUS, RP0
00E4  0506  	ANDWF gbl_trisb, W
00E5  0086  	MOVWF gbl_trisb

			portb = (portb & 0x01) | ((218) & 0xFE);
00E6  3001  	MOVLW 0x01
00E7  1283  	BCF STATUS, RP0
00E8  0506  	ANDWF gbl_portb, W
00E9  1683  	BSF STATUS, RP0
00EA  00A1  	MOVWF CompTempVar2204
00EB  30DA  	MOVLW 0xDA
00EC  0421  	IORWF CompTempVar2204, W
00ED  1283  	BCF STATUS, RP0
00EE  0086  	MOVWF gbl_portb


			break;

		}
		case 4:
00B0  3A07  	XORLW 0x07
00B1  1903  	BTFSC STATUS,Z
00B2  28F0  	GOTO	label12
00F0        label12

		{
			//Output
			//Output: 0b010010110 -> PORTB
			trisb = trisb & 0x01;
00F0  3001  	MOVLW 0x01
00F1  1683  	BSF STATUS, RP0
00F2  0506  	ANDWF gbl_trisb, W
00F3  0086  	MOVWF gbl_trisb

			portb = (portb & 0x01) | ((150) & 0xFE);
00F4  3001  	MOVLW 0x01
00F5  1283  	BCF STATUS, RP0
00F6  0506  	ANDWF gbl_portb, W
00F7  1683  	BSF STATUS, RP0
00F8  00A1  	MOVWF CompTempVar2205
00F9  3096  	MOVLW 0x96
00FA  0421  	IORWF CompTempVar2205, W
00FB  1283  	BCF STATUS, RP0
00FC  0086  	MOVWF gbl_portb


			break;

		}
		case 5:
00B3  3A01  	XORLW 0x01
00B4  1903  	BTFSC STATUS,Z
00B5  28FE  	GOTO	label13
00FE        label13

		{
			//Output
			//Output: 0b11001110 -> PORTB
			trisb = trisb & 0x01;
00FE  3001  	MOVLW 0x01
00FF  1683  	BSF STATUS, RP0
0100  0506  	ANDWF gbl_trisb, W
0101  0086  	MOVWF gbl_trisb

			portb = (portb & 0x01) | ((206) & 0xFE);
0102  3001  	MOVLW 0x01
0103  1283  	BCF STATUS, RP0
0104  0506  	ANDWF gbl_portb, W
0105  1683  	BSF STATUS, RP0
0106  00A1  	MOVWF CompTempVar2206
0107  30CE  	MOVLW 0xCE
0108  0421  	IORWF CompTempVar2206, W
0109  1283  	BCF STATUS, RP0
010A  0086  	MOVWF gbl_portb


			break;

		}
		case 6:
00B6  3A03  	XORLW 0x03
00B7  1903  	BTFSC STATUS,Z
00B8  290C  	GOTO	label14
010C        label14

		{
			//Output
			//Output: 0b11101110 -> PORTB
			trisb = trisb & 0x01;
010C  3001  	MOVLW 0x01
010D  1683  	BSF STATUS, RP0
010E  0506  	ANDWF gbl_trisb, W
010F  0086  	MOVWF gbl_trisb

			portb = (portb & 0x01) | ((238) & 0xFE);
0110  3001  	MOVLW 0x01
0111  1283  	BCF STATUS, RP0
0112  0506  	ANDWF gbl_portb, W
0113  1683  	BSF STATUS, RP0
0114  00A1  	MOVWF CompTempVar2207
0115  30EE  	MOVLW 0xEE
0116  0421  	IORWF CompTempVar2207, W
0117  1283  	BCF STATUS, RP0
0118  0086  	MOVWF gbl_portb


			break;

		}
		case 7:
00B9  3A01  	XORLW 0x01
00BA  1903  	BTFSC STATUS,Z
00BB  291A  	GOTO	label15
011A        label15

		{
			//Output
			//Output: 0b10011000 -> PORTB
			trisb = trisb & 0x01;
011A  3001  	MOVLW 0x01
011B  1683  	BSF STATUS, RP0
011C  0506  	ANDWF gbl_trisb, W
011D  0086  	MOVWF gbl_trisb

			portb = (portb & 0x01) | ((152) & 0xFE);
011E  3001  	MOVLW 0x01
011F  1283  	BCF STATUS, RP0
0120  0506  	ANDWF gbl_portb, W
0121  1683  	BSF STATUS, RP0
0122  00A1  	MOVWF CompTempVar2208
0123  3098  	MOVLW 0x98
0124  0421  	IORWF CompTempVar2208, W
0125  1283  	BCF STATUS, RP0
0126  0086  	MOVWF gbl_portb


			break;

		}
		case 8:
00BC  3A0F  	XORLW 0x0F
00BD  1903  	BTFSC STATUS,Z
00BE  2928  	GOTO	label16
0128        label16

		{
			//Output
			//Output: 0b11111110 -> PORTB
			trisb = trisb & 0x01;
0128  3001  	MOVLW 0x01
0129  1683  	BSF STATUS, RP0
012A  0506  	ANDWF gbl_trisb, W
012B  0086  	MOVWF gbl_trisb

			portb = (portb & 0x01) | ((254) & 0xFE);
012C  3001  	MOVLW 0x01
012D  1283  	BCF STATUS, RP0
012E  0506  	ANDWF gbl_portb, W
012F  1683  	BSF STATUS, RP0
0130  00A1  	MOVWF CompTempVar2209
0131  30FE  	MOVLW 0xFE
0132  0421  	IORWF CompTempVar2209, W
0133  1283  	BCF STATUS, RP0
0134  0086  	MOVWF gbl_portb


			break;

		}
		case 9:
00BF  3A01  	XORLW 0x01
00C0  1903  	BTFSC STATUS,Z
00C1  2936  	GOTO	label17
0136        label17

		{
			//Output
			//Output: 0b11011110 -> PORTB
			trisb = trisb & 0x01;
0136  3001  	MOVLW 0x01
0137  1683  	BSF STATUS, RP0
0138  0506  	ANDWF gbl_trisb, W
0139  0086  	MOVWF gbl_trisb

			portb = (portb & 0x01) | ((222) & 0xFE);
013A  3001  	MOVLW 0x01
013B  1283  	BCF STATUS, RP0
013C  0506  	ANDWF gbl_portb, W
013D  1683  	BSF STATUS, RP0
013E  00A1  	MOVWF CompTempVar2210
013F  30DE  	MOVLW 0xDE
0140  0421  	IORWF CompTempVar2210, W
0141  1283  	BCF STATUS, RP0
0142  0086  	MOVWF gbl_portb


			break;

		}
		case 0:
00C2  3A09  	XORLW 0x09
00C3  1903  	BTFSC STATUS,Z
00C4  2944  	GOTO	label18
0144        label18

		{
			//Connection Point
			//Connection Point: [A]: A
FCC_seg_pattern_A:

;

			//Output
			//Output: 0b11111100 -> PORTB
			trisb = trisb & 0x01;
0144  3001  	MOVLW 0x01
0145  1683  	BSF STATUS, RP0
0146  0506  	ANDWF gbl_trisb, W
0147  0086  	MOVWF gbl_trisb

			portb = (portb & 0x01) | ((252) & 0xFE);
0148  3001  	MOVLW 0x01
0149  1283  	BCF STATUS, RP0
014A  0506  	ANDWF gbl_portb, W
014B  1683  	BSF STATUS, RP0
014C  00A1  	MOVWF CompTempVar2211
014D  30FC  	MOVLW 0xFC
014E  0421  	IORWF CompTempVar2211, W
014F  1283  	BCF STATUS, RP0
0150  0086  	MOVWF gbl_portb


			break;

		}
		default:
00C5  2944  	GOTO	label18

		{
			//Goto Connection Point
			//Goto Connection Point: [A]: A
			goto FCC_seg_pattern_A;


		}
	}

}
00D3  0008  	RETURN
00E1  0008  	RETURN
00EF  0008  	RETURN
00FD  0008  	RETURN
010B  0008  	RETURN
0119  0008  	RETURN
0127  0008  	RETURN
0135  0008  	RETURN
0143  0008  	RETURN
0151  0008  	RETURN



void FCM_display_temp()

{

	//Output
	//Output: 0 -> PORTB
	trisb = 0x00;
0627  1683  	BSF STATUS, RP0
0628  1303  	BCF STATUS, RP1
0629  0186  	CLRF gbl_trisb

	portb = (0);
062A  1283  	BCF STATUS, RP0
062B  0186  	CLRF gbl_portb


	//Call Macro
	//Call Macro: scan_off()
	FCM_scan_off();
062C  2152  	CALL FCM_scan_o_0005A


	//Call Macro
	//Call Macro: scan1()
	FCM_scan1();
062D  21E9  	CALL FCM_scan1_00000


	//Calculation
	//Calculation:
	//  digit = temp_tens
	FCV_DIGIT = FCV_TEMP_TENS;
062E  0855  	MOVF gbl_FCV_TEMP_TENS, W
062F  00E8  	MOVWF gbl_FCV_DIGIT


	//Call Macro
	//Call Macro: seg_pattern()
	FCM_seg_pattern();
0630  20A4  	CALL FCM_seg_pa_00058


	//Delay
	//Delay: 4 ms
	delay_ms(4);
0631  3004  	MOVLW 0x04
0632  1683  	BSF STATUS, RP0
0633  00A1  	MOVWF delay_ms_00000_arg_del
0634  201A  	CALL delay_ms_00000


	//Output
	//Output: 0 -> PORTB
	trisb = trisb & 0x01;
0635  3001  	MOVLW 0x01
0636  0506  	ANDWF gbl_trisb, W
0637  0086  	MOVWF gbl_trisb

	portb = (portb & 0x01) | ((0) & 0xFE);
0638  3001  	MOVLW 0x01
0639  1283  	BCF STATUS, RP0
063A  0506  	ANDWF gbl_portb, W
063B  0086  	MOVWF gbl_portb


	//Call Macro
	//Call Macro: scan_off()
	FCM_scan_off();
063C  2152  	CALL FCM_scan_o_0005A


	//Call Macro
	//Call Macro: scan2()
	FCM_scan2();
063D  21C2  	CALL FCM_scan2_00000


	//Calculation
	//Calculation:
	//  digit = temp_ones
	FCV_DIGIT = FCV_TEMP_ONES;
063E  0864  	MOVF gbl_FCV_TEMP_ONES, W
063F  00E8  	MOVWF gbl_FCV_DIGIT


	//Call Macro
	//Call Macro: seg_pattern()
	FCM_seg_pattern();
0640  20A4  	CALL FCM_seg_pa_00058


	//Delay
	//Delay: 4 ms
	delay_ms(4);
0641  3004  	MOVLW 0x04
0642  1683  	BSF STATUS, RP0
0643  00A1  	MOVWF delay_ms_00000_arg_del
0644  201A  	CALL delay_ms_00000


	//Output
	//Output: 0 -> PORTB
	trisb = trisb & 0x01;
0645  3001  	MOVLW 0x01
0646  0506  	ANDWF gbl_trisb, W
0647  0086  	MOVWF gbl_trisb

	portb = (portb & 0x01) | ((0) & 0xFE);
0648  3001  	MOVLW 0x01
0649  1283  	BCF STATUS, RP0
064A  0506  	ANDWF gbl_portb, W
064B  0086  	MOVWF gbl_portb


	//Call Macro
	//Call Macro: scan_off()
	FCM_scan_off();
064C  2152  	CALL FCM_scan_o_0005A


	//Call Macro
	//Call Macro: scan3()
	FCM_scan3();
064D  219B  	CALL FCM_scan3_00000


	//Calculation
	//Calculation:
	//  digit = temp_dec
	FCV_DIGIT = FCV_TEMP_DEC;
064E  0860  	MOVF gbl_FCV_TEMP_DEC, W
064F  00E8  	MOVWF gbl_FCV_DIGIT


	//Call Macro
	//Call Macro: seg_pattern()
	FCM_seg_pattern();
0650  20A4  	CALL FCM_seg_pa_00058


	//Delay
	//Delay: 4 ms
	delay_ms(4);
0651  3004  	MOVLW 0x04
0652  1683  	BSF STATUS, RP0
0653  00A1  	MOVWF delay_ms_00000_arg_del
0654  201A  	CALL delay_ms_00000


	//Output
	//Output: 0 -> PORTB
	trisb = trisb & 0x01;
0655  3001  	MOVLW 0x01
0656  0506  	ANDWF gbl_trisb, W
0657  0086  	MOVWF gbl_trisb

	portb = (portb & 0x01) | ((0) & 0xFE);
0658  3001  	MOVLW 0x01
0659  1283  	BCF STATUS, RP0
065A  0506  	ANDWF gbl_portb, W
065B  0086  	MOVWF gbl_portb


	//Call Macro
	//Call Macro: scan_off()
	FCM_scan_off();
065C  2152  	CALL FCM_scan_o_0005A


	//Call Macro
	//Call Macro: scan4()
	FCM_scan4();
065D  2174  	CALL FCM_scan4_00000


	//Output
	//Output: 0b00001111 -> PORTB
	trisb = trisb & 0x01;
065E  3001  	MOVLW 0x01
065F  1683  	BSF STATUS, RP0
0660  0506  	ANDWF gbl_trisb, W
0661  0086  	MOVWF gbl_trisb

	portb = (portb & 0x01) | ((15) & 0xFE);
0662  3001  	MOVLW 0x01
0663  1283  	BCF STATUS, RP0
0664  0506  	ANDWF gbl_portb, W
0665  00FE  	MOVWF CompTempVar2212
0666  300E  	MOVLW 0x0E
0667  047E  	IORWF CompTempVar2212, W
0668  0086  	MOVWF gbl_portb


	//Delay
	//Delay: 4 ms
	delay_ms(4);
0669  3004  	MOVLW 0x04
066A  1683  	BSF STATUS, RP0
066B  00A1  	MOVWF delay_ms_00000_arg_del
066C  201A  	CALL delay_ms_00000


}
066D  0008  	RETURN



void FCM_scan_off()

{

	//Output
	//Output: 0 -> A0
	trisa = trisa & 0xFE;
0152  30FE  	MOVLW 0xFE
0153  1683  	BSF STATUS, RP0
0154  1303  	BCF STATUS, RP1
0155  0505  	ANDWF gbl_trisa, W
0156  0085  	MOVWF gbl_trisa

	if ((0))
		porta = (porta & 0xFE) | 0x01;
	else
		porta = porta & 0xFE;
0157  30FE  	MOVLW 0xFE
0158  1283  	BCF STATUS, RP0
0159  0505  	ANDWF gbl_porta, W
015A  0085  	MOVWF gbl_porta


	//Output
	//Output: 0 -> A1
	trisa = trisa & 0xFD;
015B  30FD  	MOVLW 0xFD
015C  1683  	BSF STATUS, RP0
015D  0505  	ANDWF gbl_trisa, W
015E  0085  	MOVWF gbl_trisa

	if ((0))
		porta = (porta & 0xFD) | 0x02;
	else
		porta = porta & 0xFD;
015F  30FD  	MOVLW 0xFD
0160  1283  	BCF STATUS, RP0
0161  0505  	ANDWF gbl_porta, W
0162  0085  	MOVWF gbl_porta


	//Output
	//Output: 0 -> A2
	trisa = trisa & 0xFB;
0163  30FB  	MOVLW 0xFB
0164  1683  	BSF STATUS, RP0
0165  0505  	ANDWF gbl_trisa, W
0166  0085  	MOVWF gbl_trisa

	if ((0))
		porta = (porta & 0xFB) | 0x04;
	else
		porta = porta & 0xFB;
0167  30FB  	MOVLW 0xFB
0168  1283  	BCF STATUS, RP0
0169  0505  	ANDWF gbl_porta, W
016A  0085  	MOVWF gbl_porta


	//Output
	//Output: 0 -> A3
	trisa = trisa & 0xF7;
016B  30F7  	MOVLW 0xF7
016C  1683  	BSF STATUS, RP0
016D  0505  	ANDWF gbl_trisa, W
016E  0085  	MOVWF gbl_trisa

	if ((0))
		porta = (porta & 0xF7) | 0x08;
	else
		porta = porta & 0xF7;
016F  30F7  	MOVLW 0xF7
0170  1283  	BCF STATUS, RP0
0171  0505  	ANDWF gbl_porta, W
0172  0085  	MOVWF gbl_porta


}
0173  0008  	RETURN



void FCM_calc()

{

	//Calculation
	//Calculation:
	//  calib_offset = 3
	//  calib_subtractor = 271
	FCV_CALIB_OFFSET = 3;
0457  3003  	MOVLW 0x03
0458  1283  	BCF STATUS, RP0
0459  1303  	BCF STATUS, RP1
045A  00C7  	MOVWF gbl_FCV_CALIB_OFFSET
045B  01C8  	CLRF gbl_FCV_CALIB_OFFSET+D'1'

	FCV_CALIB_SUBTRACTOR = 271;
045C  300F  	MOVLW 0x0F
045D  00C5  	MOVWF gbl_FCV_CALIB_SUBTRACTOR
045E  3001  	MOVLW 0x01
045F  00C6  	MOVWF gbl_FCV_CALIB_SUBTRACTOR+D'1'


	//Calculation
	//Calculation:
	//  lsb = data0
	//  msb = data1
	FCV_LSB = FCV_DATA0;
0460  085A  	MOVF gbl_FCV_DATA0, W
0461  00E5  	MOVWF gbl_FCV_LSB

	FCV_MSB = FCV_DATA1;
0462  085C  	MOVF gbl_FCV_DATA1, W
0463  00E7  	MOVWF gbl_FCV_MSB


	//Calculation
	//Calculation:
	//  raw = msb
	FCV_RAW = FCV_MSB;
0464  0867  	MOVF gbl_FCV_MSB, W
0465  00B4  	MOVWF gbl_FCV_RAW
0466  01B5  	CLRF gbl_FCV_RAW+D'1'
0467  01B6  	CLRF gbl_FCV_RAW+D'2'
0468  01B7  	CLRF gbl_FCV_RAW+D'3'


	//Loop
	//Loop: Loop 8 times
	for (FCLV_LOOP7=0; FCLV_LOOP7<8; FCLV_LOOP7++)
0469  01F8  	CLRF gbl_FCLV_LOOP7
046A        label55
046A  3008  	MOVLW 0x08
046B  0278  	SUBWF gbl_FCLV_LOOP7, W
046C  1803  	BTFSC STATUS,C
046D  2C79  	GOTO	label56
0477  0AF8  	INCF gbl_FCLV_LOOP7, F
0478  2C6A  	GOTO	label55
0479        label56

	{

		//Calculation
		//Calculation:
		//  raw = raw << 1
		FCV_RAW = FCV_RAW << 1;
046E  08B4  	MOVF gbl_FCV_RAW, F
046F  08B5  	MOVF gbl_FCV_RAW+D'1', F
0470  08B6  	MOVF gbl_FCV_RAW+D'2', F
0471  08B7  	MOVF gbl_FCV_RAW+D'3', F
0472  1003  	BCF STATUS,C
0473  0DB4  	RLF gbl_FCV_RAW, F
0474  0DB5  	RLF gbl_FCV_RAW+D'1', F
0475  0DB6  	RLF gbl_FCV_RAW+D'2', F
0476  0DB7  	RLF gbl_FCV_RAW+D'3', F



	}

	//Calculation
	//Calculation:
	//  raw = raw + lsb
	FCV_RAW = FCV_RAW + FCV_LSB;
0479  0865  	MOVF gbl_FCV_LSB, W
047A  1683  	BSF STATUS, RP0
047B  00A1  	MOVWF CompTempVar2219
047C  01A2  	CLRF CompTempVar2220
047D  01A3  	CLRF CompTempVar2221
047E  01A4  	CLRF CompTempVar2222
047F  1283  	BCF STATUS, RP0
0480  0834  	MOVF gbl_FCV_RAW, W
0481  1683  	BSF STATUS, RP0
0482  07A1  	ADDWF CompTempVar2219, F
0483  1283  	BCF STATUS, RP0
0484  0835  	MOVF gbl_FCV_RAW+D'1', W
0485  1C03  	BTFSS STATUS,C
0486  2C8A  	GOTO	label57
0487  0F35  	INCFSZ gbl_FCV_RAW+D'1', W
0488  2C8A  	GOTO	label57
0489  2C8C  	GOTO	label58
048A        label57
048A  1683  	BSF STATUS, RP0
048B  07A2  	ADDWF CompTempVar2220, F
048C        label58
048C  1283  	BCF STATUS, RP0
048D  0836  	MOVF gbl_FCV_RAW+D'2', W
048E  1C03  	BTFSS STATUS,C
048F  2C93  	GOTO	label59
0490  0F36  	INCFSZ gbl_FCV_RAW+D'2', W
0491  2C93  	GOTO	label59
0492  2C95  	GOTO	label60
0493        label59
0493  1683  	BSF STATUS, RP0
0494  07A3  	ADDWF CompTempVar2221, F
0495        label60
0495  1283  	BCF STATUS, RP0
0496  0837  	MOVF gbl_FCV_RAW+D'3', W
0497  1C03  	BTFSS STATUS,C
0498  2C9C  	GOTO	label61
0499  0F37  	INCFSZ gbl_FCV_RAW+D'3', W
049A  2C9C  	GOTO	label61
049B  2C9E  	GOTO	label62
049C        label61
049C  1683  	BSF STATUS, RP0
049D  07A4  	ADDWF CompTempVar2222, F
049E        label62
049E  1683  	BSF STATUS, RP0
049F  0821  	MOVF CompTempVar2219, W
04A0  1283  	BCF STATUS, RP0
04A1  00B4  	MOVWF gbl_FCV_RAW
04A2  1683  	BSF STATUS, RP0
04A3  0822  	MOVF CompTempVar2220, W
04A4  1283  	BCF STATUS, RP0
04A5  00B5  	MOVWF gbl_FCV_RAW+D'1'
04A6  1683  	BSF STATUS, RP0
04A7  0823  	MOVF CompTempVar2221, W
04A8  1283  	BCF STATUS, RP0
04A9  00B6  	MOVWF gbl_FCV_RAW+D'2'
04AA  1683  	BSF STATUS, RP0
04AB  0824  	MOVF CompTempVar2222, W
04AC  1283  	BCF STATUS, RP0
04AD  00B7  	MOVWF gbl_FCV_RAW+D'3'


	//Calculation
	//Calculation:
	//  temp_c = (raw / 50) - calib_subtractor
	FCV_TEMP_C = (FCV_RAW / 50) - FCV_CALIB_SUBTRACTOR;
04AE  1683  	BSF STATUS, RP0
04AF  01AD  	CLRF CompTempVar2232
04B0  1283  	BCF STATUS, RP0
04B1  0834  	MOVF gbl_FCV_RAW, W
04B2  1683  	BSF STATUS, RP0
04B3  00A1  	MOVWF __div_32_3_00001_arg_a
04B4  1283  	BCF STATUS, RP0
04B5  0835  	MOVF gbl_FCV_RAW+D'1', W
04B6  1683  	BSF STATUS, RP0
04B7  00A2  	MOVWF __div_32_3_00001_arg_a+D'1'
04B8  1283  	BCF STATUS, RP0
04B9  0836  	MOVF gbl_FCV_RAW+D'2', W
04BA  1683  	BSF STATUS, RP0
04BB  00A3  	MOVWF __div_32_3_00001_arg_a+D'2'
04BC  1283  	BCF STATUS, RP0
04BD  0837  	MOVF gbl_FCV_RAW+D'3', W
04BE  1683  	BSF STATUS, RP0
04BF  00A4  	MOVWF __div_32_3_00001_arg_a+D'3'
04C0  1283  	BCF STATUS, RP0
04C1  1FB7  	BTFSS gbl_FCV_RAW+D'3',7
04C2  2CD0  	GOTO	label63
04C3  1683  	BSF STATUS, RP0
04C4  09A1  	COMF __div_32_3_00001_arg_a, F
04C5  09A2  	COMF __div_32_3_00001_arg_a+D'1', F
04C6  09A3  	COMF __div_32_3_00001_arg_a+D'2', F
04C7  09A4  	COMF __div_32_3_00001_arg_a+D'3', F
04C8  0AA1  	INCF __div_32_3_00001_arg_a, F
04C9  1903  	BTFSC STATUS,Z
04CA  0AA2  	INCF __div_32_3_00001_arg_a+D'1', F
04CB  1903  	BTFSC STATUS,Z
04CC  0AA3  	INCF __div_32_3_00001_arg_a+D'2', F
04CD  1903  	BTFSC STATUS,Z
04CE  0AA4  	INCF __div_32_3_00001_arg_a+D'3', F
04CF  0AAD  	INCF CompTempVar2232, F
04D0        label63
04D0  3032  	MOVLW 0x32
04D1  1683  	BSF STATUS, RP0
04D2  00A5  	MOVWF __div_32_3_00001_arg_b
04D3  01A6  	CLRF __div_32_3_00001_arg_b+D'1'
04D4  01A7  	CLRF __div_32_3_00001_arg_b+D'2'
04D5  01A8  	CLRF __div_32_3_00001_arg_b+D'3'
04D6  226B  	CALL __div_32_3_00001
04D7  0833  	MOVF CompTempVarRet210, W
04D8  1283  	BCF STATUS, RP0
04D9  00BC  	MOVWF gbl_FCV_TEMP_C
04DA  1683  	BSF STATUS, RP0
04DB  0834  	MOVF CompTempVarRet210+D'1', W
04DC  1283  	BCF STATUS, RP0
04DD  00BD  	MOVWF gbl_FCV_TEMP_C+D'1'
04DE  1683  	BSF STATUS, RP0
04DF  0835  	MOVF CompTempVarRet210+D'2', W
04E0  1283  	BCF STATUS, RP0
04E1  00BE  	MOVWF gbl_FCV_TEMP_C+D'2'
04E2  1683  	BSF STATUS, RP0
04E3  0836  	MOVF CompTempVarRet210+D'3', W
04E4  1283  	BCF STATUS, RP0
04E5  00BF  	MOVWF gbl_FCV_TEMP_C+D'3'
04E6  1683  	BSF STATUS, RP0
04E7  1C2D  	BTFSS CompTempVar2232,0
04E8  2CF5  	GOTO	label64
04E9  1283  	BCF STATUS, RP0
04EA  09BC  	COMF gbl_FCV_TEMP_C, F
04EB  09BD  	COMF gbl_FCV_TEMP_C+D'1', F
04EC  09BE  	COMF gbl_FCV_TEMP_C+D'2', F
04ED  09BF  	COMF gbl_FCV_TEMP_C+D'3', F
04EE  0ABC  	INCF gbl_FCV_TEMP_C, F
04EF  1903  	BTFSC STATUS,Z
04F0  0ABD  	INCF gbl_FCV_TEMP_C+D'1', F
04F1  1903  	BTFSC STATUS,Z
04F2  0ABE  	INCF gbl_FCV_TEMP_C+D'2', F
04F3  1903  	BTFSC STATUS,Z
04F4  0ABF  	INCF gbl_FCV_TEMP_C+D'3', F
04F5        label64
04F5  1283  	BCF STATUS, RP0
04F6  0845  	MOVF gbl_FCV_CALIB_SUBTRACTOR, W
04F7  1683  	BSF STATUS, RP0
04F8  00A9  	MOVWF CompTempVar2223
04F9  1283  	BCF STATUS, RP0
04FA  0846  	MOVF gbl_FCV_CALIB_SUBTRACTOR+D'1', W
04FB  1683  	BSF STATUS, RP0
04FC  00AA  	MOVWF CompTempVar2223+D'1'
04FD  01AB  	CLRF CompTempVar2223+D'2'
04FE  01AC  	CLRF CompTempVar2223+D'3'
04FF  0829  	MOVF CompTempVar2223, W
0500  1283  	BCF STATUS, RP0
0501  02BC  	SUBWF gbl_FCV_TEMP_C, F
0502  1683  	BSF STATUS, RP0
0503  082A  	MOVF CompTempVar2223+D'1', W
0504  1803  	BTFSC STATUS,C
0505  2D09  	GOTO	label65
0506  0F2A  	INCFSZ CompTempVar2223+D'1', W
0507  2D09  	GOTO	label65
0508  2D0B  	GOTO	label66
0509        label65
0509  1283  	BCF STATUS, RP0
050A  02BD  	SUBWF gbl_FCV_TEMP_C+D'1', F
050B        label66
050B  1683  	BSF STATUS, RP0
050C  082B  	MOVF CompTempVar2223+D'2', W
050D  1803  	BTFSC STATUS,C
050E  2D12  	GOTO	label67
050F  0F2B  	INCFSZ CompTempVar2223+D'2', W
0510  2D12  	GOTO	label67
0511  2D14  	GOTO	label68
0512        label67
0512  1283  	BCF STATUS, RP0
0513  02BE  	SUBWF gbl_FCV_TEMP_C+D'2', F
0514        label68
0514  1683  	BSF STATUS, RP0
0515  082C  	MOVF CompTempVar2223+D'3', W
0516  1803  	BTFSC STATUS,C
0517  2D1B  	GOTO	label69
0518  0F2C  	INCFSZ CompTempVar2223+D'3', W
0519  2D1B  	GOTO	label69
051A  2D1D  	GOTO	label70
051B        label69
051B  1283  	BCF STATUS, RP0
051C  02BF  	SUBWF gbl_FCV_TEMP_C+D'3', F
051D        label70


	//Calculation
	//Calculation:
	//  dp2 = raw % 50
	FCV_DP2 = FCV_RAW % 50;
051D  1283  	BCF STATUS, RP0
051E  0834  	MOVF gbl_FCV_RAW, W
051F  1683  	BSF STATUS, RP0
0520  00A1  	MOVWF __rem_32_3_00002_arg_a
0521  1283  	BCF STATUS, RP0
0522  0835  	MOVF gbl_FCV_RAW+D'1', W
0523  1683  	BSF STATUS, RP0
0524  00A2  	MOVWF __rem_32_3_00002_arg_a+D'1'
0525  1283  	BCF STATUS, RP0
0526  0836  	MOVF gbl_FCV_RAW+D'2', W
0527  1683  	BSF STATUS, RP0
0528  00A3  	MOVWF __rem_32_3_00002_arg_a+D'2'
0529  1283  	BCF STATUS, RP0
052A  0837  	MOVF gbl_FCV_RAW+D'3', W
052B  1683  	BSF STATUS, RP0
052C  00A4  	MOVWF __rem_32_3_00002_arg_a+D'3'
052D  1283  	BCF STATUS, RP0
052E  1FB7  	BTFSS gbl_FCV_RAW+D'3',7
052F  2D3C  	GOTO	label71
0530  1683  	BSF STATUS, RP0
0531  09A1  	COMF __rem_32_3_00002_arg_a, F
0532  09A2  	COMF __rem_32_3_00002_arg_a+D'1', F
0533  09A3  	COMF __rem_32_3_00002_arg_a+D'2', F
0534  09A4  	COMF __rem_32_3_00002_arg_a+D'3', F
0535  0AA1  	INCF __rem_32_3_00002_arg_a, F
0536  1903  	BTFSC STATUS,Z
0537  0AA2  	INCF __rem_32_3_00002_arg_a+D'1', F
0538  1903  	BTFSC STATUS,Z
0539  0AA3  	INCF __rem_32_3_00002_arg_a+D'2', F
053A  1903  	BTFSC STATUS,Z
053B  0AA4  	INCF __rem_32_3_00002_arg_a+D'3', F
053C        label71
053C  3032  	MOVLW 0x32
053D  1683  	BSF STATUS, RP0
053E  00A5  	MOVWF __rem_32_3_00002_arg_b
053F  01A6  	CLRF __rem_32_3_00002_arg_b+D'1'
0540  01A7  	CLRF __rem_32_3_00002_arg_b+D'2'
0541  01A8  	CLRF __rem_32_3_00002_arg_b+D'3'
0542  2221  	CALL __rem_32_3_00002
0543  082E  	MOVF CompTempVarRet212, W
0544  1283  	BCF STATUS, RP0
0545  00DD  	MOVWF gbl_FCV_DP2
0546  1FB7  	BTFSS gbl_FCV_RAW+D'3',7
0547  2D4A  	GOTO	label72
0548  09DD  	COMF gbl_FCV_DP2, F
0549  0ADD  	INCF gbl_FCV_DP2, F
054A        label72


	//Decision
	//Decision: dp2 >= 100?
	if (FCV_DP2 >= 100)
054A  3064  	MOVLW 0x64
054B  025D  	SUBWF gbl_FCV_DP2, W
054C  1C03  	BTFSS STATUS,C
054D  2D58  	GOTO	label73
0558        label73

	{

		//Calculation
		//Calculation:
		//  temp_cdp = dp2 / 100
		FCV_TEMP_CDP = FCV_DP2 / 100;
054E  085D  	MOVF gbl_FCV_DP2, W
054F  1683  	BSF STATUS, RP0
0550  00A3  	MOVWF __div_8_8_00000_arg_a
0551  3064  	MOVLW 0x64
0552  00A4  	MOVWF __div_8_8_00000_arg_b
0553  225A  	CALL __div_8_8_00000
0554  0827  	MOVF CompTempVarRet218, W
0555  1283  	BCF STATUS, RP0
0556  00D9  	MOVWF gbl_FCV_TEMP_CDP


	} else {
0557  2D81  	GOTO	label77


		//Decision
		//Decision: dp2 >= 10 AND dp2 <= 100?
		if (FCV_DP2 >= 10 & FCV_DP2 <= 100)
0558  1683  	BSF STATUS, RP0
0559  01A2  	CLRF CompTempVar2235
055A  300A  	MOVLW 0x0A
055B  1283  	BCF STATUS, RP0
055C  025D  	SUBWF gbl_FCV_DP2, W
055D  1C03  	BTFSS STATUS,C
055E  2D61  	GOTO	label74
055F  1683  	BSF STATUS, RP0
0560  0AA2  	INCF CompTempVar2235, F
0561  1683  	BSF STATUS, RP0
0562  01A1  	CLRF CompTempVar2234
0563  1283  	BCF STATUS, RP0
0564  085D  	MOVF gbl_FCV_DP2, W
0565  3C64  	SUBLW 0x64
0566  1C03  	BTFSS STATUS,C
0567  2D6A  	GOTO	label75
0568  1683  	BSF STATUS, RP0
0569  0AA1  	INCF CompTempVar2234, F
056A  1683  	BSF STATUS, RP0
056B  0821  	MOVF CompTempVar2234, W
056C  0522  	ANDWF CompTempVar2235, W
056D  1903  	BTFSC STATUS,Z
056E  2D7A  	GOTO	label76
057A        label76

		{

			//Calculation
			//Calculation:
			//  temp_cdp = dp2 / 10
			FCV_TEMP_CDP = FCV_DP2 / 10;
056F  1283  	BCF STATUS, RP0
0570  085D  	MOVF gbl_FCV_DP2, W
0571  1683  	BSF STATUS, RP0
0572  00A3  	MOVWF __div_8_8_00000_arg_a
0573  300A  	MOVLW 0x0A
0574  00A4  	MOVWF __div_8_8_00000_arg_b
0575  225A  	CALL __div_8_8_00000
0576  0827  	MOVF CompTempVarRet218, W
0577  1283  	BCF STATUS, RP0
0578  00D9  	MOVWF gbl_FCV_TEMP_CDP


		} else {
0579  2D81  	GOTO	label77


			//Decision
			//Decision: dp2 < 10?
			if (FCV_DP2 < 10)
057A  300A  	MOVLW 0x0A
057B  1283  	BCF STATUS, RP0
057C  025D  	SUBWF gbl_FCV_DP2, W
057D  1803  	BTFSC STATUS,C
057E  2D81  	GOTO	label77
0581        label77

			{

				//Calculation
				//Calculation:
				//  temp_cdp = dp2
				FCV_TEMP_CDP = FCV_DP2;
057F  085D  	MOVF gbl_FCV_DP2, W
0580  00D9  	MOVWF gbl_FCV_TEMP_CDP


			// } else {

			}

		}

	}

	//Calculation
	//Calculation:
	//  temp_cdp = temp_cdp + calib_offset
	FCV_TEMP_CDP = FCV_TEMP_CDP + FCV_CALIB_OFFSET;
0581  0847  	MOVF gbl_FCV_CALIB_OFFSET, W
0582  0759  	ADDWF gbl_FCV_TEMP_CDP, W
0583  00D9  	MOVWF gbl_FCV_TEMP_CDP


}
0584  0008  	RETURN



void FCM_calibrate()

{

	//Call Component Macro
	//Call Component Macro: trim=ReadAsByte()
	FCV_TRIM = FCD_ADC0_ReadAsByte();
066E  2318  	CALL FCD_ADC0_R_0005C
066F  0822  	MOVF CompTempVarRet2255, W
0670  1283  	BCF STATUS, RP0
0671  00D8  	MOVWF gbl_FCV_TRIM


	//Decision
	//Decision: trim = 255 OR trim = 0?
	if (FCV_TRIM == 255 | FCV_TRIM == 0)
0672  1683  	BSF STATUS, RP0
0673  01A0  	CLRF CompTempVar2237
0674  1283  	BCF STATUS, RP0
0675  0A58  	INCF gbl_FCV_TRIM, W
0676  1D03  	BTFSS STATUS,Z
0677  2E7A  	GOTO	label78
0678  1683  	BSF STATUS, RP0
0679  0AA0  	INCF CompTempVar2237, F
067A  1283  	BCF STATUS, RP0
067B  01FE  	CLRF CompTempVar2236
067C  0AFE  	INCF CompTempVar2236, F
067D  08D8  	MOVF gbl_FCV_TRIM, F
067E  1D03  	BTFSS STATUS,Z
067F  107E  	BCF CompTempVar2236,0
0680  087E  	MOVF CompTempVar2236, W
0681  1683  	BSF STATUS, RP0
0682  0420  	IORWF CompTempVar2237, W
0683  1D03  	BTFSS STATUS,Z

	{

		//Call Macro
		//Call Macro: error()
		FCM_error();
0684  2398  	CALL FCM_error_00000


	// } else {

	}

	//Calculation
	//Calculation:
	//  trim_diff = trim - trim_prev
	FCV_TRIM_DIFF = FCV_TRIM - FCV_TRIM_PREV;
0685  1283  	BCF STATUS, RP0
0686  0858  	MOVF gbl_FCV_TRIM, W
0687  00B8  	MOVWF gbl_FCV_TRIM_DIFF
0688  01B9  	CLRF gbl_FCV_TRIM_DIFF+D'1'
0689  01BA  	CLRF gbl_FCV_TRIM_DIFF+D'2'
068A  01BB  	CLRF gbl_FCV_TRIM_DIFF+D'3'
068B  0863  	MOVF gbl_FCV_TRIM_PREV, W
068C  1683  	BSF STATUS, RP0
068D  00A1  	MOVWF CompTempVar2238
068E  01A2  	CLRF CompTempVar2238+D'1'
068F  01A3  	CLRF CompTempVar2238+D'2'
0690  01A4  	CLRF CompTempVar2238+D'3'
0691  0821  	MOVF CompTempVar2238, W
0692  1283  	BCF STATUS, RP0
0693  02B8  	SUBWF gbl_FCV_TRIM_DIFF, F
0694  1683  	BSF STATUS, RP0
0695  0822  	MOVF CompTempVar2238+D'1', W
0696  1803  	BTFSC STATUS,C
0697  2E9B  	GOTO	label79
0698  0F22  	INCFSZ CompTempVar2238+D'1', W
0699  2E9B  	GOTO	label79
069A  2E9D  	GOTO	label80
069B        label79
069B  1283  	BCF STATUS, RP0
069C  02B9  	SUBWF gbl_FCV_TRIM_DIFF+D'1', F
069D        label80
069D  1683  	BSF STATUS, RP0
069E  0823  	MOVF CompTempVar2238+D'2', W
069F  1803  	BTFSC STATUS,C
06A0  2EA4  	GOTO	label81
06A1  0F23  	INCFSZ CompTempVar2238+D'2', W
06A2  2EA4  	GOTO	label81
06A3  2EA6  	GOTO	label82
06A4        label81
06A4  1283  	BCF STATUS, RP0
06A5  02BA  	SUBWF gbl_FCV_TRIM_DIFF+D'2', F
06A6        label82
06A6  1683  	BSF STATUS, RP0
06A7  0824  	MOVF CompTempVar2238+D'3', W
06A8  1803  	BTFSC STATUS,C
06A9  2EAD  	GOTO	label83
06AA  0F24  	INCFSZ CompTempVar2238+D'3', W
06AB  2EAD  	GOTO	label83
06AC  2EAF  	GOTO	label84
06AD        label83
06AD  1283  	BCF STATUS, RP0
06AE  02BB  	SUBWF gbl_FCV_TRIM_DIFF+D'3', F
06AF        label84


	//Decision
	//Decision: trim_diff = 0?
	if (FCV_TRIM_DIFF == 0)
06AF  1283  	BCF STATUS, RP0
06B0  0838  	MOVF gbl_FCV_TRIM_DIFF, W
06B1  0439  	IORWF gbl_FCV_TRIM_DIFF+D'1', W
06B2  043A  	IORWF gbl_FCV_TRIM_DIFF+D'2', W
06B3  043B  	IORWF gbl_FCV_TRIM_DIFF+D'3', W
06B4  39FF  	ANDLW 0xFF
06B5  1D03  	BTFSS STATUS,Z
06B6  2EBF  	GOTO	label85
06BF        label85

	{

		//Calculation
		//Calculation:
		//  ihap = ihap + 1
		FCV_IHAP = FCV_IHAP + 1;
06B7  0A70  	INCF gbl_FCV_IHAP, W
06B8  00F0  	MOVWF gbl_FCV_IHAP


		//Decision
		//Decision: ihap = 255?
		if (FCV_IHAP == 255)
06B9  0A70  	INCF gbl_FCV_IHAP, W
06BA  1D03  	BTFSS STATUS,Z
06BB  2EC0  	GOTO	label86

		{

			//Calculation
			//Calculation:
			//  ihap = 0
			//  calib_var = 0
			FCV_IHAP = 0;
06BC  01F0  	CLRF gbl_FCV_IHAP

			FCV_CALIB_VAR = 0;
06BD  01ED  	CLRF gbl_FCV_CALIB_VAR


		// } else {

		}

	} else {
06BE  2EC0  	GOTO	label86
06C0        label86


		//Calculation
		//Calculation:
		//  ihap = 0
		FCV_IHAP = 0;
06BF  01F0  	CLRF gbl_FCV_IHAP


	}

	//Calculation
	//Calculation:
	//  calib_factor = trim / 10
	FCV_CALIB_FACTOR = FCV_TRIM / 10;
06C0  0858  	MOVF gbl_FCV_TRIM, W
06C1  1683  	BSF STATUS, RP0
06C2  00A3  	MOVWF __div_8_8_00000_arg_a
06C3  300A  	MOVLW 0x0A
06C4  00A4  	MOVWF __div_8_8_00000_arg_b
06C5  225A  	CALL __div_8_8_00000
06C6  0827  	MOVF CompTempVarRet218, W
06C7  1283  	BCF STATUS, RP0
06C8  00EC  	MOVWF gbl_FCV_CALIB_FACTOR


	//Decision
	//Decision: calib_factor > 12?
	if (FCV_CALIB_FACTOR > 12)
06C9  086C  	MOVF gbl_FCV_CALIB_FACTOR, W
06CA  3C0C  	SUBLW 0x0C
06CB  1803  	BTFSC STATUS,C
06CC  2EF3  	GOTO	label88
06F3        label88

	{

		//Calculation
		//Calculation:
		//  calib_temp = calib_factor - 12
		FCV_CALIB_TEMP = FCV_CALIB_FACTOR - 12;
06CD  300C  	MOVLW 0x0C
06CE  026C  	SUBWF gbl_FCV_CALIB_FACTOR, W
06CF  00E9  	MOVWF gbl_FCV_CALIB_TEMP


		//Decision
		//Decision: calib_temp > 10?
		if (FCV_CALIB_TEMP > 10)
06D0  0869  	MOVF gbl_FCV_CALIB_TEMP, W
06D1  3C0A  	SUBLW 0x0A
06D2  1803  	BTFSC STATUS,C
06D3  2EDB  	GOTO	label87
06DB        label87

		{

			//Calculation
			//Calculation:
			//  calib_subtractor = 270 + 1
			//  calib_temp = calib_temp - 10
			FCV_CALIB_SUBTRACTOR = 270 + 1;
06D4  300F  	MOVLW 0x0F
06D5  00C5  	MOVWF gbl_FCV_CALIB_SUBTRACTOR
06D6  3001  	MOVLW 0x01
06D7  00C6  	MOVWF gbl_FCV_CALIB_SUBTRACTOR+D'1'

			FCV_CALIB_TEMP = FCV_CALIB_TEMP - 10;
06D8  300A  	MOVLW 0x0A
06D9  0269  	SUBWF gbl_FCV_CALIB_TEMP, W
06DA  00E9  	MOVWF gbl_FCV_CALIB_TEMP


		// } else {

		}

		//Calculation
		//Calculation:
		//  calib_offset = 3 + calib_temp
		FCV_CALIB_OFFSET = 3 + FCV_CALIB_TEMP;
06DB  01C8  	CLRF gbl_FCV_CALIB_OFFSET+D'1'
06DC  0869  	MOVF gbl_FCV_CALIB_TEMP, W
06DD  3E03  	ADDLW 0x03
06DE  00C7  	MOVWF gbl_FCV_CALIB_OFFSET
06DF  1803  	BTFSC STATUS,C
06E0  0AC8  	INCF gbl_FCV_CALIB_OFFSET+D'1', F


		//Decision
		//Decision: calib_offset > 10?
		if (FCV_CALIB_OFFSET > 10)
06E1  0847  	MOVF gbl_FCV_CALIB_OFFSET, W
06E2  3C0A  	SUBLW 0x0A
06E3  0848  	MOVF gbl_FCV_CALIB_OFFSET+D'1', W
06E4  1803  	BTFSC STATUS,C
06E5  1D03  	BTFSS STATUS,Z
06E6  1BC8  	BTFSC gbl_FCV_CALIB_OFFSET+D'1',7
06E7  2F2C  	GOTO	label90

		{

			//Calculation
			//Calculation:
			//  calib_subtractor = calib_subtractor + 1
			//  calib_offset = calib_offset - 10
			FCV_CALIB_SUBTRACTOR = FCV_CALIB_SUBTRACTOR + 1;
06E8  08C5  	MOVF gbl_FCV_CALIB_SUBTRACTOR, F
06E9  08C6  	MOVF gbl_FCV_CALIB_SUBTRACTOR+D'1', F
06EA  0AC5  	INCF gbl_FCV_CALIB_SUBTRACTOR, F
06EB  1903  	BTFSC STATUS,Z
06EC  0AC6  	INCF gbl_FCV_CALIB_SUBTRACTOR+D'1', F

			FCV_CALIB_OFFSET = FCV_CALIB_OFFSET - 10;
06ED  300A  	MOVLW 0x0A
06EE  02C7  	SUBWF gbl_FCV_CALIB_OFFSET, F
06EF  08C8  	MOVF gbl_FCV_CALIB_OFFSET+D'1', F
06F0  1C03  	BTFSS STATUS,C
06F1  03C8  	DECF gbl_FCV_CALIB_OFFSET+D'1', F


		// } else {

		}

	} else {
06F2  2F2C  	GOTO	label90


		//Decision
		//Decision: calib_factor < 12?
		if (FCV_CALIB_FACTOR < 12)
06F3  300C  	MOVLW 0x0C
06F4  026C  	SUBWF gbl_FCV_CALIB_FACTOR, W
06F5  1803  	BTFSC STATUS,C
06F6  2F21  	GOTO	label89
0721        label89

		{

			//Calculation
			//Calculation:
			//  calib_offset = 3 - calib_factor
			FCV_CALIB_OFFSET = 3 - FCV_CALIB_FACTOR;
06F7  1683  	BSF STATUS, RP0
06F8  01A2  	CLRF CompTempVar2251
06F9  1283  	BCF STATUS, RP0
06FA  086C  	MOVF gbl_FCV_CALIB_FACTOR, W
06FB  3C03  	SUBLW 0x03
06FC  1683  	BSF STATUS, RP0
06FD  00A1  	MOVWF CompTempVar2250
06FE  1C03  	BTFSS STATUS,C
06FF  03A2  	DECF CompTempVar2251, F
0700  0821  	MOVF CompTempVar2250, W
0701  1283  	BCF STATUS, RP0
0702  00C7  	MOVWF gbl_FCV_CALIB_OFFSET
0703  1683  	BSF STATUS, RP0
0704  0822  	MOVF CompTempVar2251, W
0705  1283  	BCF STATUS, RP0
0706  00C8  	MOVWF gbl_FCV_CALIB_OFFSET+D'1'


			//Decision
			//Decision: calib_offset < 0?
			if (FCV_CALIB_OFFSET < 0)
0707  1FC8  	BTFSS gbl_FCV_CALIB_OFFSET+D'1',7
0708  2F2C  	GOTO	label90

			{

				//Calculation
				//Calculation:
				//  calib_offset = calib_offset * -1
				//  calib_subtractor = 270 - 1
				FCV_CALIB_OFFSET = FCV_CALIB_OFFSET * -1;
0709  0847  	MOVF gbl_FCV_CALIB_OFFSET, W
070A  1683  	BSF STATUS, RP0
070B  00A1  	MOVWF __mul_16s__0000E_arg_a
070C  1283  	BCF STATUS, RP0
070D  0848  	MOVF gbl_FCV_CALIB_OFFSET+D'1', W
070E  1683  	BSF STATUS, RP0
070F  00A2  	MOVWF __mul_16s__0000E_arg_a+D'1'
0710  30FF  	MOVLW 0xFF
0711  00A3  	MOVWF __mul_16s__0000E_arg_b
0712  01A4  	CLRF __mul_16s__0000E_arg_b+D'1'
0713  03A4  	DECF __mul_16s__0000E_arg_b+D'1', F
0714  232B  	CALL __mul_16s__0000E
0715  0828  	MOVF CompTempVarRet461, W
0716  1283  	BCF STATUS, RP0
0717  00C7  	MOVWF gbl_FCV_CALIB_OFFSET
0718  1683  	BSF STATUS, RP0
0719  0829  	MOVF CompTempVarRet461+D'1', W
071A  1283  	BCF STATUS, RP0
071B  00C8  	MOVWF gbl_FCV_CALIB_OFFSET+D'1'

				FCV_CALIB_SUBTRACTOR = 270 - 1;
071C  300D  	MOVLW 0x0D
071D  00C5  	MOVWF gbl_FCV_CALIB_SUBTRACTOR
071E  3001  	MOVLW 0x01
071F  00C6  	MOVWF gbl_FCV_CALIB_SUBTRACTOR+D'1'


			// } else {

			}

		} else {
0720  2F2C  	GOTO	label90


			//Decision
			//Decision: calib_factor = 12?
			if (FCV_CALIB_FACTOR == 12)
0721  086C  	MOVF gbl_FCV_CALIB_FACTOR, W
0722  3A0C  	XORLW 0x0C
0723  1D03  	BTFSS STATUS,Z
0724  2F2C  	GOTO	label90
072C        label90

			{

				//Calculation
				//Calculation:
				//  calib_offset = 3
				//  calib_subtractor = 270
				FCV_CALIB_OFFSET = 3;
0725  3003  	MOVLW 0x03
0726  00C7  	MOVWF gbl_FCV_CALIB_OFFSET
0727  01C8  	CLRF gbl_FCV_CALIB_OFFSET+D'1'

				FCV_CALIB_SUBTRACTOR = 270;
0728  300E  	MOVLW 0x0E
0729  00C5  	MOVWF gbl_FCV_CALIB_SUBTRACTOR
072A  3001  	MOVLW 0x01
072B  00C6  	MOVWF gbl_FCV_CALIB_SUBTRACTOR+D'1'


			// } else {

			}

		}

	}

	//Calculation
	//Calculation:
	//  temp_tens = temp_c / 10
	//  temp_ones = temp_c % 10
	//  temp_dec = temp_cdp
	FCV_TEMP_TENS = FCV_TEMP_C / 10;
072C  1683  	BSF STATUS, RP0
072D  01A9  	CLRF CompTempVar2253
072E  1283  	BCF STATUS, RP0
072F  083C  	MOVF gbl_FCV_TEMP_C, W
0730  1683  	BSF STATUS, RP0
0731  00A1  	MOVWF __div_32_3_00001_arg_a
0732  1283  	BCF STATUS, RP0
0733  083D  	MOVF gbl_FCV_TEMP_C+D'1', W
0734  1683  	BSF STATUS, RP0
0735  00A2  	MOVWF __div_32_3_00001_arg_a+D'1'
0736  1283  	BCF STATUS, RP0
0737  083E  	MOVF gbl_FCV_TEMP_C+D'2', W
0738  1683  	BSF STATUS, RP0
0739  00A3  	MOVWF __div_32_3_00001_arg_a+D'2'
073A  1283  	BCF STATUS, RP0
073B  083F  	MOVF gbl_FCV_TEMP_C+D'3', W
073C  1683  	BSF STATUS, RP0
073D  00A4  	MOVWF __div_32_3_00001_arg_a+D'3'
073E  1283  	BCF STATUS, RP0
073F  1FBF  	BTFSS gbl_FCV_TEMP_C+D'3',7
0740  2F4E  	GOTO	label91
0741  1683  	BSF STATUS, RP0
0742  09A1  	COMF __div_32_3_00001_arg_a, F
0743  09A2  	COMF __div_32_3_00001_arg_a+D'1', F
0744  09A3  	COMF __div_32_3_00001_arg_a+D'2', F
0745  09A4  	COMF __div_32_3_00001_arg_a+D'3', F
0746  0AA1  	INCF __div_32_3_00001_arg_a, F
0747  1903  	BTFSC STATUS,Z
0748  0AA2  	INCF __div_32_3_00001_arg_a+D'1', F
0749  1903  	BTFSC STATUS,Z
074A  0AA3  	INCF __div_32_3_00001_arg_a+D'2', F
074B  1903  	BTFSC STATUS,Z
074C  0AA4  	INCF __div_32_3_00001_arg_a+D'3', F
074D  0AA9  	INCF CompTempVar2253, F
074E        label91
074E  300A  	MOVLW 0x0A
074F  1683  	BSF STATUS, RP0
0750  00A5  	MOVWF __div_32_3_00001_arg_b
0751  01A6  	CLRF __div_32_3_00001_arg_b+D'1'
0752  01A7  	CLRF __div_32_3_00001_arg_b+D'2'
0753  01A8  	CLRF __div_32_3_00001_arg_b+D'3'
0754  226B  	CALL __div_32_3_00001
0755  0833  	MOVF CompTempVarRet210, W
0756  1283  	BCF STATUS, RP0
0757  00D5  	MOVWF gbl_FCV_TEMP_TENS
0758  1683  	BSF STATUS, RP0
0759  1C29  	BTFSS CompTempVar2253,0
075A  2F5E  	GOTO	label92
075B  1283  	BCF STATUS, RP0
075C  09D5  	COMF gbl_FCV_TEMP_TENS, F
075D  0AD5  	INCF gbl_FCV_TEMP_TENS, F
075E        label92

	FCV_TEMP_ONES = FCV_TEMP_C % 10;
075E  1283  	BCF STATUS, RP0
075F  083C  	MOVF gbl_FCV_TEMP_C, W
0760  1683  	BSF STATUS, RP0
0761  00A1  	MOVWF __rem_32_3_00002_arg_a
0762  1283  	BCF STATUS, RP0
0763  083D  	MOVF gbl_FCV_TEMP_C+D'1', W
0764  1683  	BSF STATUS, RP0
0765  00A2  	MOVWF __rem_32_3_00002_arg_a+D'1'
0766  1283  	BCF STATUS, RP0
0767  083E  	MOVF gbl_FCV_TEMP_C+D'2', W
0768  1683  	BSF STATUS, RP0
0769  00A3  	MOVWF __rem_32_3_00002_arg_a+D'2'
076A  1283  	BCF STATUS, RP0
076B  083F  	MOVF gbl_FCV_TEMP_C+D'3', W
076C  1683  	BSF STATUS, RP0
076D  00A4  	MOVWF __rem_32_3_00002_arg_a+D'3'
076E  1283  	BCF STATUS, RP0
076F  1FBF  	BTFSS gbl_FCV_TEMP_C+D'3',7
0770  2F7D  	GOTO	label93
0771  1683  	BSF STATUS, RP0
0772  09A1  	COMF __rem_32_3_00002_arg_a, F
0773  09A2  	COMF __rem_32_3_00002_arg_a+D'1', F
0774  09A3  	COMF __rem_32_3_00002_arg_a+D'2', F
0775  09A4  	COMF __rem_32_3_00002_arg_a+D'3', F
0776  0AA1  	INCF __rem_32_3_00002_arg_a, F
0777  1903  	BTFSC STATUS,Z
0778  0AA2  	INCF __rem_32_3_00002_arg_a+D'1', F
0779  1903  	BTFSC STATUS,Z
077A  0AA3  	INCF __rem_32_3_00002_arg_a+D'2', F
077B  1903  	BTFSC STATUS,Z
077C  0AA4  	INCF __rem_32_3_00002_arg_a+D'3', F
077D        label93
077D  300A  	MOVLW 0x0A
077E  1683  	BSF STATUS, RP0
077F  00A5  	MOVWF __rem_32_3_00002_arg_b
0780  01A6  	CLRF __rem_32_3_00002_arg_b+D'1'
0781  01A7  	CLRF __rem_32_3_00002_arg_b+D'2'
0782  01A8  	CLRF __rem_32_3_00002_arg_b+D'3'
0783  2221  	CALL __rem_32_3_00002
0784  082E  	MOVF CompTempVarRet212, W
0785  1283  	BCF STATUS, RP0
0786  00E4  	MOVWF gbl_FCV_TEMP_ONES
0787  1FBF  	BTFSS gbl_FCV_TEMP_C+D'3',7
0788  2F8B  	GOTO	label94
0789  09E4  	COMF gbl_FCV_TEMP_ONES, F
078A  0AE4  	INCF gbl_FCV_TEMP_ONES, F
078B        label94

	FCV_TEMP_DEC = FCV_TEMP_CDP;
078B  0859  	MOVF gbl_FCV_TEMP_CDP, W
078C  00E0  	MOVWF gbl_FCV_TEMP_DEC


	//Call Macro
	//Call Macro: calc()
	FCM_calc();
078D  2457  	CALL FCM_calc_00000


	//Call Macro
	//Call Macro: display_calib()
	FCM_display_calib();
078E  2423  	CALL FCM_displa_0005D


	//Calculation
	//Calculation:
	//  trim_prev = trim
	FCV_TRIM_PREV = FCV_TRIM;
078F  1283  	BCF STATUS, RP0
0790  0858  	MOVF gbl_FCV_TRIM, W
0791  00E3  	MOVWF gbl_FCV_TRIM_PREV


}
0792  0008  	RETURN



void FCM_display_calib()

{

	//Output
	//Output: 0 -> PORTB
	trisb = 0x00;
0423  1683  	BSF STATUS, RP0
0424  1303  	BCF STATUS, RP1
0425  0186  	CLRF gbl_trisb

	portb = (0);
0426  1283  	BCF STATUS, RP0
0427  0186  	CLRF gbl_portb


	//Call Macro
	//Call Macro: scan_off()
	FCM_scan_off();
0428  2152  	CALL FCM_scan_o_0005A


	//Call Macro
	//Call Macro: scan1()
	FCM_scan1();
0429  21E9  	CALL FCM_scan1_00000


	//Calculation
	//Calculation:
	//  digit = temp_tens
	FCV_DIGIT = FCV_TEMP_TENS;
042A  0855  	MOVF gbl_FCV_TEMP_TENS, W
042B  00E8  	MOVWF gbl_FCV_DIGIT


	//Call Macro
	//Call Macro: seg_pattern()
	FCM_seg_pattern();
042C  20A4  	CALL FCM_seg_pa_00058


	//Delay
	//Delay: 4 ms
	delay_ms(4);
042D  3004  	MOVLW 0x04
042E  1683  	BSF STATUS, RP0
042F  00A1  	MOVWF delay_ms_00000_arg_del
0430  201A  	CALL delay_ms_00000


	//Output
	//Output: 0 -> PORTB
	trisb = 0x00;
0431  0186  	CLRF gbl_trisb

	portb = (0);
0432  1283  	BCF STATUS, RP0
0433  0186  	CLRF gbl_portb


	//Call Macro
	//Call Macro: scan_off()
	FCM_scan_off();
0434  2152  	CALL FCM_scan_o_0005A


	//Call Macro
	//Call Macro: scan2()
	FCM_scan2();
0435  21C2  	CALL FCM_scan2_00000


	//Calculation
	//Calculation:
	//  digit = temp_ones
	FCV_DIGIT = FCV_TEMP_ONES;
0436  0864  	MOVF gbl_FCV_TEMP_ONES, W
0437  00E8  	MOVWF gbl_FCV_DIGIT


	//Call Macro
	//Call Macro: seg_pattern()
	FCM_seg_pattern();
0438  20A4  	CALL FCM_seg_pa_00058


	//Delay
	//Delay: 4 ms
	delay_ms(4);
0439  3004  	MOVLW 0x04
043A  1683  	BSF STATUS, RP0
043B  00A1  	MOVWF delay_ms_00000_arg_del
043C  201A  	CALL delay_ms_00000


	//Output
	//Output: 0 -> PORTB
	trisb = 0x00;
043D  0186  	CLRF gbl_trisb

	portb = (0);
043E  1283  	BCF STATUS, RP0
043F  0186  	CLRF gbl_portb


	//Call Macro
	//Call Macro: scan_off()
	FCM_scan_off();
0440  2152  	CALL FCM_scan_o_0005A


	//Call Macro
	//Call Macro: scan3()
	FCM_scan3();
0441  219B  	CALL FCM_scan3_00000


	//Calculation
	//Calculation:
	//  digit = temp_dec
	FCV_DIGIT = FCV_TEMP_DEC;
0442  0860  	MOVF gbl_FCV_TEMP_DEC, W
0443  00E8  	MOVWF gbl_FCV_DIGIT


	//Call Macro
	//Call Macro: seg_pattern()
	FCM_seg_pattern();
0444  20A4  	CALL FCM_seg_pa_00058


	//Delay
	//Delay: 4 ms
	delay_ms(4);
0445  3004  	MOVLW 0x04
0446  1683  	BSF STATUS, RP0
0447  00A1  	MOVWF delay_ms_00000_arg_del
0448  201A  	CALL delay_ms_00000


	//Output
	//Output: 0 -> PORTB
	trisb = 0x00;
0449  0186  	CLRF gbl_trisb

	portb = (0);
044A  1283  	BCF STATUS, RP0
044B  0186  	CLRF gbl_portb


	//Call Macro
	//Call Macro: scan_off()
	FCM_scan_off();
044C  2152  	CALL FCM_scan_o_0005A


	//Call Macro
	//Call Macro: scan4()
	FCM_scan4();
044D  2174  	CALL FCM_scan4_00000


	//Output
	//Output: 0 -> PORTB
	trisb = 0x00;
044E  1683  	BSF STATUS, RP0
044F  0186  	CLRF gbl_trisb

	portb = (0);
0450  1283  	BCF STATUS, RP0
0451  0186  	CLRF gbl_portb


	//Delay
	//Delay: 4 ms
	delay_ms(4);
0452  3004  	MOVLW 0x04
0453  1683  	BSF STATUS, RP0
0454  00A1  	MOVWF delay_ms_00000_arg_del
0455  201A  	CALL delay_ms_00000


}
0456  0008  	RETURN



void FCM_display_error()

{

	//Output
	//Output: 0 -> PORTB
	trisb = 0x00;
02E3  1683  	BSF STATUS, RP0
02E4  1303  	BCF STATUS, RP1
02E5  0186  	CLRF gbl_trisb

	portb = (0);
02E6  1283  	BCF STATUS, RP0
02E7  0186  	CLRF gbl_portb


	//Call Macro
	//Call Macro: scan_off()
	FCM_scan_off();
02E8  2152  	CALL FCM_scan_o_0005A


	//Call Macro
	//Call Macro: scan1()
	FCM_scan1();
02E9  21E9  	CALL FCM_scan1_00000


	//Calculation
	//Calculation:
	//  digit = temp_tens
	FCV_DIGIT = FCV_TEMP_TENS;
02EA  0855  	MOVF gbl_FCV_TEMP_TENS, W
02EB  00E8  	MOVWF gbl_FCV_DIGIT


	//Call Macro
	//Call Macro: seg_pattern()
	FCM_seg_pattern();
02EC  20A4  	CALL FCM_seg_pa_00058


	//Delay
	//Delay: 4 ms
	delay_ms(4);
02ED  3004  	MOVLW 0x04
02EE  1683  	BSF STATUS, RP0
02EF  00A1  	MOVWF delay_ms_00000_arg_del
02F0  201A  	CALL delay_ms_00000


	//Output
	//Output: 0 -> PORTB
	trisb = 0x00;
02F1  0186  	CLRF gbl_trisb

	portb = (0);
02F2  1283  	BCF STATUS, RP0
02F3  0186  	CLRF gbl_portb


	//Call Macro
	//Call Macro: scan_off()
	FCM_scan_off();
02F4  2152  	CALL FCM_scan_o_0005A


	//Call Macro
	//Call Macro: scan2()
	FCM_scan2();
02F5  21C2  	CALL FCM_scan2_00000


	//Calculation
	//Calculation:
	//  digit = temp_ones
	FCV_DIGIT = FCV_TEMP_ONES;
02F6  0864  	MOVF gbl_FCV_TEMP_ONES, W
02F7  00E8  	MOVWF gbl_FCV_DIGIT


	//Call Macro
	//Call Macro: seg_pattern()
	FCM_seg_pattern();
02F8  20A4  	CALL FCM_seg_pa_00058


	//Delay
	//Delay: 4 ms
	delay_ms(4);
02F9  3004  	MOVLW 0x04
02FA  1683  	BSF STATUS, RP0
02FB  00A1  	MOVWF delay_ms_00000_arg_del
02FC  201A  	CALL delay_ms_00000


	//Output
	//Output: 0 -> PORTB
	trisb = 0x00;
02FD  0186  	CLRF gbl_trisb

	portb = (0);
02FE  1283  	BCF STATUS, RP0
02FF  0186  	CLRF gbl_portb


	//Call Macro
	//Call Macro: scan_off()
	FCM_scan_off();
0300  2152  	CALL FCM_scan_o_0005A


	//Call Macro
	//Call Macro: scan3()
	FCM_scan3();
0301  219B  	CALL FCM_scan3_00000


	//Calculation
	//Calculation:
	//  digit = temp_dec
	FCV_DIGIT = FCV_TEMP_DEC;
0302  0860  	MOVF gbl_FCV_TEMP_DEC, W
0303  00E8  	MOVWF gbl_FCV_DIGIT


	//Call Macro
	//Call Macro: seg_pattern()
	FCM_seg_pattern();
0304  20A4  	CALL FCM_seg_pa_00058


	//Delay
	//Delay: 4 ms
	delay_ms(4);
0305  3004  	MOVLW 0x04
0306  1683  	BSF STATUS, RP0
0307  00A1  	MOVWF delay_ms_00000_arg_del
0308  201A  	CALL delay_ms_00000


	//Output
	//Output: 0 -> PORTB
	trisb = 0x00;
0309  0186  	CLRF gbl_trisb

	portb = (0);
030A  1283  	BCF STATUS, RP0
030B  0186  	CLRF gbl_portb


	//Call Macro
	//Call Macro: scan_off()
	FCM_scan_off();
030C  2152  	CALL FCM_scan_o_0005A


	//Call Macro
	//Call Macro: scan4()
	FCM_scan4();
030D  2174  	CALL FCM_scan4_00000


	//Output
	//Output: 0b01101111 -> PORTB
	trisb = 0x00;
030E  1683  	BSF STATUS, RP0
030F  0186  	CLRF gbl_trisb

	portb = (111);
0310  306F  	MOVLW 0x6F
0311  1283  	BCF STATUS, RP0
0312  0086  	MOVWF gbl_portb


	//Delay
	//Delay: 4 ms
	delay_ms(4);
0313  3004  	MOVLW 0x04
0314  1683  	BSF STATUS, RP0
0315  00A1  	MOVWF delay_ms_00000_arg_del
0316  201A  	CALL delay_ms_00000


}
0317  0008  	RETURN



void FCM_error()

{

	//Loop
	//Loop: While 1
	while (1)
0398        label44
0422  2B98  	GOTO	label44

	{

		//Call Component Macro
		//Call Component Macro: trim=ReadAsByte()
		FCV_TRIM = FCD_ADC0_ReadAsByte();
0398  2318  	CALL FCD_ADC0_R_0005C
0399  0822  	MOVF CompTempVarRet2255, W
039A  1283  	BCF STATUS, RP0
039B  00D8  	MOVWF gbl_FCV_TRIM


		//Calculation
		//Calculation:
		//  temp_tens = trim / 100
		//  temp_ones = (trim % 100) / 10
		//  temp_dec = trim % 10
		FCV_TEMP_TENS = FCV_TRIM / 100;
039C  0858  	MOVF gbl_FCV_TRIM, W
039D  1683  	BSF STATUS, RP0
039E  00A3  	MOVWF __div_8_8_00000_arg_a
039F  3064  	MOVLW 0x64
03A0  00A4  	MOVWF __div_8_8_00000_arg_b
03A1  225A  	CALL __div_8_8_00000
03A2  0827  	MOVF CompTempVarRet218, W
03A3  1283  	BCF STATUS, RP0
03A4  00D5  	MOVWF gbl_FCV_TEMP_TENS

		FCV_TEMP_ONES = (FCV_TRIM % 100) / 10;
03A5  0858  	MOVF gbl_FCV_TRIM, W
03A6  1683  	BSF STATUS, RP0
03A7  00A1  	MOVWF __rem_8_8_00000_arg_a
03A8  3064  	MOVLW 0x64
03A9  00A2  	MOVWF __rem_8_8_00000_arg_b
03AA  2210  	CALL __rem_8_8_00000
03AB  0827  	MOVF CompTempVarRet220, W
03AC  00A3  	MOVWF __div_8_8_00000_arg_a
03AD  300A  	MOVLW 0x0A
03AE  00A4  	MOVWF __div_8_8_00000_arg_b
03AF  225A  	CALL __div_8_8_00000
03B0  0827  	MOVF CompTempVarRet218, W
03B1  1283  	BCF STATUS, RP0
03B2  00E4  	MOVWF gbl_FCV_TEMP_ONES

		FCV_TEMP_DEC = FCV_TRIM % 10;
03B3  0858  	MOVF gbl_FCV_TRIM, W
03B4  1683  	BSF STATUS, RP0
03B5  00A1  	MOVWF __rem_8_8_00000_arg_a
03B6  300A  	MOVLW 0x0A
03B7  00A2  	MOVWF __rem_8_8_00000_arg_b
03B8  2210  	CALL __rem_8_8_00000
03B9  0827  	MOVF CompTempVarRet220, W
03BA  1283  	BCF STATUS, RP0
03BB  00E0  	MOVWF gbl_FCV_TEMP_DEC


		//Call Macro
		//Call Macro: display_error()
		FCM_display_error();
03BC  22E3  	CALL FCM_displa_0005E


		//Decision
		//Decision: trim = 120?
		if (FCV_TRIM == 120)
03BD  1283  	BCF STATUS, RP0
03BE  0858  	MOVF gbl_FCV_TRIM, W
03BF  3A78  	XORLW 0x78
03C0  1D03  	BTFSS STATUS,Z
03C1  2C21  	GOTO	label54
0421        label54

		{

			//Calculation
			//Calculation:
			//  trim_diff = trim - trim_prev
			//  calib_offset = calib_offset + trim_diff
			FCV_TRIM_DIFF = FCV_TRIM - FCV_TRIM_PREV;
03C2  0858  	MOVF gbl_FCV_TRIM, W
03C3  00B8  	MOVWF gbl_FCV_TRIM_DIFF
03C4  01B9  	CLRF gbl_FCV_TRIM_DIFF+D'1'
03C5  01BA  	CLRF gbl_FCV_TRIM_DIFF+D'2'
03C6  01BB  	CLRF gbl_FCV_TRIM_DIFF+D'3'
03C7  0863  	MOVF gbl_FCV_TRIM_PREV, W
03C8  1683  	BSF STATUS, RP0
03C9  00A1  	MOVWF CompTempVar2256
03CA  01A2  	CLRF CompTempVar2256+D'1'
03CB  01A3  	CLRF CompTempVar2256+D'2'
03CC  01A4  	CLRF CompTempVar2256+D'3'
03CD  0821  	MOVF CompTempVar2256, W
03CE  1283  	BCF STATUS, RP0
03CF  02B8  	SUBWF gbl_FCV_TRIM_DIFF, F
03D0  1683  	BSF STATUS, RP0
03D1  0822  	MOVF CompTempVar2256+D'1', W
03D2  1803  	BTFSC STATUS,C
03D3  2BD7  	GOTO	label45
03D4  0F22  	INCFSZ CompTempVar2256+D'1', W
03D5  2BD7  	GOTO	label45
03D6  2BD9  	GOTO	label46
03D7        label45
03D7  1283  	BCF STATUS, RP0
03D8  02B9  	SUBWF gbl_FCV_TRIM_DIFF+D'1', F
03D9        label46
03D9  1683  	BSF STATUS, RP0
03DA  0823  	MOVF CompTempVar2256+D'2', W
03DB  1803  	BTFSC STATUS,C
03DC  2BE0  	GOTO	label47
03DD  0F23  	INCFSZ CompTempVar2256+D'2', W
03DE  2BE0  	GOTO	label47
03DF  2BE2  	GOTO	label48
03E0        label47
03E0  1283  	BCF STATUS, RP0
03E1  02BA  	SUBWF gbl_FCV_TRIM_DIFF+D'2', F
03E2        label48
03E2  1683  	BSF STATUS, RP0
03E3  0824  	MOVF CompTempVar2256+D'3', W
03E4  1803  	BTFSC STATUS,C
03E5  2BE9  	GOTO	label49
03E6  0F24  	INCFSZ CompTempVar2256+D'3', W
03E7  2BE9  	GOTO	label49
03E8  2BEB  	GOTO	label50
03E9        label49
03E9  1283  	BCF STATUS, RP0
03EA  02BB  	SUBWF gbl_FCV_TRIM_DIFF+D'3', F
03EB        label50

			FCV_CALIB_OFFSET = FCV_CALIB_OFFSET + FCV_TRIM_DIFF;
03EB  1283  	BCF STATUS, RP0
03EC  0847  	MOVF gbl_FCV_CALIB_OFFSET, W
03ED  1683  	BSF STATUS, RP0
03EE  00A1  	MOVWF CompTempVar2262
03EF  1283  	BCF STATUS, RP0
03F0  0848  	MOVF gbl_FCV_CALIB_OFFSET+D'1', W
03F1  1683  	BSF STATUS, RP0
03F2  00A2  	MOVWF CompTempVar2262+D'1'
03F3  01A3  	CLRF CompTempVar2262+D'2'
03F4  01A4  	CLRF CompTempVar2262+D'3'
03F5  1283  	BCF STATUS, RP0
03F6  1FC8  	BTFSS gbl_FCV_CALIB_OFFSET+D'1',7
03F7  2BFB  	GOTO	label51
03F8  1683  	BSF STATUS, RP0
03F9  03A3  	DECF CompTempVar2262+D'2', F
03FA  03A4  	DECF CompTempVar2262+D'3', F
03FB        label51
03FB  1283  	BCF STATUS, RP0
03FC  0838  	MOVF gbl_FCV_TRIM_DIFF, W
03FD  1683  	BSF STATUS, RP0
03FE  0721  	ADDWF CompTempVar2262, W
03FF  00A5  	MOVWF CompTempVar2263
0400  1283  	BCF STATUS, RP0
0401  0839  	MOVF gbl_FCV_TRIM_DIFF+D'1', W
0402  1683  	BSF STATUS, RP0
0403  00A6  	MOVWF CompTempVar2264
0404  0822  	MOVF CompTempVar2262+D'1', W
0405  1803  	BTFSC STATUS,C
0406  0F22  	INCFSZ CompTempVar2262+D'1', W
0407  07A6  	ADDWF CompTempVar2264, F
0408  0825  	MOVF CompTempVar2263, W
0409  1283  	BCF STATUS, RP0
040A  00C7  	MOVWF gbl_FCV_CALIB_OFFSET
040B  1683  	BSF STATUS, RP0
040C  0826  	MOVF CompTempVar2264, W
040D  1283  	BCF STATUS, RP0
040E  00C8  	MOVWF gbl_FCV_CALIB_OFFSET+D'1'


			//Decision
			//Decision: trim_diff = 0?
			if (FCV_TRIM_DIFF == 0)
040F  0838  	MOVF gbl_FCV_TRIM_DIFF, W
0410  0439  	IORWF gbl_FCV_TRIM_DIFF+D'1', W
0411  043A  	IORWF gbl_FCV_TRIM_DIFF+D'2', W
0412  043B  	IORWF gbl_FCV_TRIM_DIFF+D'3', W
0413  39FF  	ANDLW 0xFF
0414  1D03  	BTFSS STATUS,Z
0415  2C1D  	GOTO	label52
041D        label52

			{

				//Calculation
				//Calculation:
				//  errorcount = errorcount + 1
				FCV_ERRORCOUNT = FCV_ERRORCOUNT + 1;
0416  0A72  	INCF gbl_FCV_ERRORCOUNT, W
0417  00F2  	MOVWF gbl_FCV_ERRORCOUNT


				//Decision
				//Decision: errorcount = 255?
				if (FCV_ERRORCOUNT == 255)
0418  0A72  	INCF gbl_FCV_ERRORCOUNT, W
0419  1D03  	BTFSS STATUS,Z
041A  2C1E  	GOTO	label53

				{

					//Calculation
					//Calculation:
					//  errorcount = 0
					FCV_ERRORCOUNT = 0;
041B  01F2  	CLRF gbl_FCV_ERRORCOUNT


					//Goto Connection Point
					//Goto Connection Point: [A]: A
					goto FCC_error_A;


				// } else {

				}

			} else {
041E        label53


				//Calculation
				//Calculation:
				//  errorcount = 0
				FCV_ERRORCOUNT = 0;
041D  01F2  	CLRF gbl_FCV_ERRORCOUNT


			}

			//Calculation
			//Calculation:
			//  trim_prev = trim
			FCV_TRIM_PREV = FCV_TRIM;
041E  0858  	MOVF gbl_FCV_TRIM, W
041F  00E3  	MOVWF gbl_FCV_TRIM_PREV


		} else {
0420  2B98  	GOTO	label44


			//Calculation
			//Calculation:
			//  errorcount = 0
			FCV_ERRORCOUNT = 0;
0421  01F2  	CLRF gbl_FCV_ERRORCOUNT


		}


	}

	//Connection Point
	//Connection Point: [A]: A
FCC_error_A:
;

}
041C  0008  	RETURN



void FCM_display_repeat()

{

	//Output
	//Output: 0 -> PORTB
	trisb = trisb & 0x01;
05C4  3001  	MOVLW 0x01
05C5  1683  	BSF STATUS, RP0
05C6  1303  	BCF STATUS, RP1
05C7  0506  	ANDWF gbl_trisb, W
05C8  0086  	MOVWF gbl_trisb

	portb = (portb & 0x01) | ((0) & 0xFE);
05C9  3001  	MOVLW 0x01
05CA  1283  	BCF STATUS, RP0
05CB  0506  	ANDWF gbl_portb, W
05CC  0086  	MOVWF gbl_portb


	//Call Macro
	//Call Macro: scan_off()
	FCM_scan_off();
05CD  2152  	CALL FCM_scan_o_0005A


	//Call Macro
	//Call Macro: scan1()
	FCM_scan1();
05CE  21E9  	CALL FCM_scan1_00000


	//Output
	//Output: 0b00000010 -> PORTB
	trisb = trisb & 0x01;
05CF  3001  	MOVLW 0x01
05D0  1683  	BSF STATUS, RP0
05D1  0506  	ANDWF gbl_trisb, W
05D2  0086  	MOVWF gbl_trisb

	portb = (portb & 0x01) | ((2) & 0xFE);
05D3  3001  	MOVLW 0x01
05D4  1283  	BCF STATUS, RP0
05D5  0506  	ANDWF gbl_portb, W
05D6  00FE  	MOVWF CompTempVar2265
05D7  3002  	MOVLW 0x02
05D8  047E  	IORWF CompTempVar2265, W
05D9  0086  	MOVWF gbl_portb


	//Delay
	//Delay: 4 ms
	delay_ms(4);
05DA  3004  	MOVLW 0x04
05DB  1683  	BSF STATUS, RP0
05DC  00A1  	MOVWF delay_ms_00000_arg_del
05DD  201A  	CALL delay_ms_00000


	//Output
	//Output: 0 -> PORTB
	trisb = trisb & 0x01;
05DE  3001  	MOVLW 0x01
05DF  0506  	ANDWF gbl_trisb, W
05E0  0086  	MOVWF gbl_trisb

	portb = (portb & 0x01) | ((0) & 0xFE);
05E1  3001  	MOVLW 0x01
05E2  1283  	BCF STATUS, RP0
05E3  0506  	ANDWF gbl_portb, W
05E4  0086  	MOVWF gbl_portb


	//Call Macro
	//Call Macro: scan_off()
	FCM_scan_off();
05E5  2152  	CALL FCM_scan_o_0005A


	//Call Macro
	//Call Macro: scan2()
	FCM_scan2();
05E6  21C2  	CALL FCM_scan2_00000


	//Output
	//Output: 0b00000010 -> PORTB
	trisb = trisb & 0x01;
05E7  3001  	MOVLW 0x01
05E8  1683  	BSF STATUS, RP0
05E9  0506  	ANDWF gbl_trisb, W
05EA  0086  	MOVWF gbl_trisb

	portb = (portb & 0x01) | ((2) & 0xFE);
05EB  3001  	MOVLW 0x01
05EC  1283  	BCF STATUS, RP0
05ED  0506  	ANDWF gbl_portb, W
05EE  00FE  	MOVWF CompTempVar2266
05EF  3002  	MOVLW 0x02
05F0  047E  	IORWF CompTempVar2266, W
05F1  0086  	MOVWF gbl_portb


	//Delay
	//Delay: 4 ms
	delay_ms(4);
05F2  3004  	MOVLW 0x04
05F3  1683  	BSF STATUS, RP0
05F4  00A1  	MOVWF delay_ms_00000_arg_del
05F5  201A  	CALL delay_ms_00000


	//Output
	//Output: 0 -> PORTB
	trisb = trisb & 0x01;
05F6  3001  	MOVLW 0x01
05F7  0506  	ANDWF gbl_trisb, W
05F8  0086  	MOVWF gbl_trisb

	portb = (portb & 0x01) | ((0) & 0xFE);
05F9  3001  	MOVLW 0x01
05FA  1283  	BCF STATUS, RP0
05FB  0506  	ANDWF gbl_portb, W
05FC  0086  	MOVWF gbl_portb


	//Call Macro
	//Call Macro: scan_off()
	FCM_scan_off();
05FD  2152  	CALL FCM_scan_o_0005A


	//Call Macro
	//Call Macro: scan3()
	FCM_scan3();
05FE  219B  	CALL FCM_scan3_00000


	//Output
	//Output: 0b00000010 -> PORTB
	trisb = trisb & 0x01;
05FF  3001  	MOVLW 0x01
0600  1683  	BSF STATUS, RP0
0601  0506  	ANDWF gbl_trisb, W
0602  0086  	MOVWF gbl_trisb

	portb = (portb & 0x01) | ((2) & 0xFE);
0603  3001  	MOVLW 0x01
0604  1283  	BCF STATUS, RP0
0605  0506  	ANDWF gbl_portb, W
0606  00FE  	MOVWF CompTempVar2267
0607  3002  	MOVLW 0x02
0608  047E  	IORWF CompTempVar2267, W
0609  0086  	MOVWF gbl_portb


	//Delay
	//Delay: 4 ms
	delay_ms(4);
060A  3004  	MOVLW 0x04
060B  1683  	BSF STATUS, RP0
060C  00A1  	MOVWF delay_ms_00000_arg_del
060D  201A  	CALL delay_ms_00000


	//Output
	//Output: 0 -> PORTB
	trisb = trisb & 0x01;
060E  3001  	MOVLW 0x01
060F  0506  	ANDWF gbl_trisb, W
0610  0086  	MOVWF gbl_trisb

	portb = (portb & 0x01) | ((0) & 0xFE);
0611  3001  	MOVLW 0x01
0612  1283  	BCF STATUS, RP0
0613  0506  	ANDWF gbl_portb, W
0614  0086  	MOVWF gbl_portb


	//Call Macro
	//Call Macro: scan_off()
	FCM_scan_off();
0615  2152  	CALL FCM_scan_o_0005A


	//Call Macro
	//Call Macro: scan4()
	FCM_scan4();
0616  2174  	CALL FCM_scan4_00000


	//Output
	//Output: 0b00001111 -> PORTB
	trisb = trisb & 0x01;
0617  3001  	MOVLW 0x01
0618  1683  	BSF STATUS, RP0
0619  0506  	ANDWF gbl_trisb, W
061A  0086  	MOVWF gbl_trisb

	portb = (portb & 0x01) | ((15) & 0xFE);
061B  3001  	MOVLW 0x01
061C  1283  	BCF STATUS, RP0
061D  0506  	ANDWF gbl_portb, W
061E  00FE  	MOVWF CompTempVar2268
061F  300E  	MOVLW 0x0E
0620  047E  	IORWF CompTempVar2268, W
0621  0086  	MOVWF gbl_portb


	//Delay
	//Delay: 4 ms
	delay_ms(4);
0622  3004  	MOVLW 0x04
0623  1683  	BSF STATUS, RP0
0624  00A1  	MOVWF delay_ms_00000_arg_del
0625  201A  	CALL delay_ms_00000


}
0626  0008  	RETURN



void FCM_ready()
{

	//Output
	//Output: 0 -> PORTB
	trisb = 0x00;
	portb = (0);

	//Call Macro
	//Call Macro: scan_off()
	FCM_scan_off();

	//Call Macro
	//Call Macro: scan1()
	FCM_scan1();

	//Calculation
	//Calculation:
	//  digit = temp_tens
	FCV_DIGIT = FCV_TEMP_TENS;

	//Output
	//Output: 0 -> PORTB
	trisb = trisb & 0x01;
	portb = (portb & 0x01) | ((0) & 0xFE);

	//Delay
	//Delay: 4 ms
	delay_ms(4);

	//Output
	//Output: 0 -> PORTB
	trisb = trisb & 0x01;
	portb = (portb & 0x01) | ((0) & 0xFE);

	//Call Macro
	//Call Macro: scan_off()
	FCM_scan_off();

	//Call Macro
	//Call Macro: scan2()
	FCM_scan2();

	//Calculation
	//Calculation:
	//  digit = temp_ones
	FCV_DIGIT = FCV_TEMP_ONES;

	//Output
	//Output: 0 -> PORTB
	trisb = trisb & 0x01;
	portb = (portb & 0x01) | ((0) & 0xFE);

	//Delay
	//Delay: 4 ms
	delay_ms(4);

	//Output
	//Output: 0 -> PORTB
	trisb = trisb & 0x01;
	portb = (portb & 0x01) | ((0) & 0xFE);

	//Call Macro
	//Call Macro: scan_off()
	FCM_scan_off();

	//Call Macro
	//Call Macro: scan3()
	FCM_scan3();

	//Calculation
	//Calculation:
	//  digit = temp_dec
	FCV_DIGIT = FCV_TEMP_DEC;

	//Output
	//Output: 0 -> PORTB
	trisb = trisb & 0x01;
	portb = (portb & 0x01) | ((0) & 0xFE);

	//Delay
	//Delay: 4 ms
	delay_ms(4);

	//Output
	//Output: 0 -> PORTB
	trisb = trisb & 0x01;
	portb = (portb & 0x01) | ((0) & 0xFE);

	//Call Macro
	//Call Macro: scan_off()
	FCM_scan_off();

	//Call Macro
	//Call Macro: scan4()
	FCM_scan4();

	//Output
	//Output: 0b00001111 -> PORTB
	trisb = trisb & 0x01;
	portb = (portb & 0x01) | ((15) & 0xFE);

	//Delay
	//Delay: 4 ms
	delay_ms(4);

}


void FCM_def_calib()
{

	//Calculation
	//Calculation:
	//  calib_offset = 3
	//  calib_subtractor = 270
	FCV_CALIB_OFFSET = 3;
	FCV_CALIB_SUBTRACTOR = 270;

}



void main()

{
	//Initialization
	adcon1 = 0x07;
07A7  3007  	MOVLW 0x07
07A8  1683  	BSF STATUS, RP0
07A9  1303  	BCF STATUS, RP1
07AA  009F  	MOVWF gbl_adcon1



	//Interrupt initialization code
	option_reg = 0xC0;
07AB  30C0  	MOVLW 0xC0
07AC  0081  	MOVWF gbl_option_reg



	//Calculation
	//Calculation:
	//  data0 = 123
	//  data1 = 0xff
	//  data2 = 0xff
	//  lsb = 0x00
	//  msb = 0x00
	FCV_DATA0 = 123;
07AD  307B  	MOVLW 0x7B
07AE  1283  	BCF STATUS, RP0
07AF  00DA  	MOVWF gbl_FCV_DATA0

	FCV_DATA1 = 0xff;
07B0  30FF  	MOVLW 0xFF
07B1  00DC  	MOVWF gbl_FCV_DATA1

	FCV_DATA2 = 0xff;
07B2  00DE  	MOVWF gbl_FCV_DATA2

	FCV_LSB = 0x00;
07B3  01E5  	CLRF gbl_FCV_LSB

	FCV_MSB = 0x00;
07B4  01E7  	CLRF gbl_FCV_MSB


	//Calculation
	//Calculation:
	//  temp_tens = 0
	//  temp_ones = 0
	//  temp_dec = 0
	FCV_TEMP_TENS = 0;
07B5  01D5  	CLRF gbl_FCV_TEMP_TENS

	FCV_TEMP_ONES = 0;
07B6  01E4  	CLRF gbl_FCV_TEMP_ONES

	FCV_TEMP_DEC = 0;
07B7  01E0  	CLRF gbl_FCV_TEMP_DEC


	//Call Component Macro
	//Call Component Macro: MI2C_Init()
	FCD_I2C_Master0_MI2C_Init();
07B8  27A5  	CALL FCD_I2C_Ma_00068


	//Calculation
	//Calculation:
	//  temp_c = 35
	//  calib_offset = 3
	//  calib_subtractor = 270
	FCV_TEMP_C = 35;
07B9  3023  	MOVLW 0x23
07BA  1283  	BCF STATUS, RP0
07BB  00BC  	MOVWF gbl_FCV_TEMP_C
07BC  01BD  	CLRF gbl_FCV_TEMP_C+D'1'
07BD  01BE  	CLRF gbl_FCV_TEMP_C+D'2'
07BE  01BF  	CLRF gbl_FCV_TEMP_C+D'3'

	FCV_CALIB_OFFSET = 3;
07BF  3003  	MOVLW 0x03
07C0  00C7  	MOVWF gbl_FCV_CALIB_OFFSET
07C1  01C8  	CLRF gbl_FCV_CALIB_OFFSET+D'1'

	FCV_CALIB_SUBTRACTOR = 270;
07C2  300E  	MOVLW 0x0E
07C3  00C5  	MOVWF gbl_FCV_CALIB_SUBTRACTOR
07C4  3001  	MOVLW 0x01
07C5  00C6  	MOVWF gbl_FCV_CALIB_SUBTRACTOR+D'1'


	//Call Macro
	//Call Macro: calibrate()
	FCM_calibrate();
07C6  266E  	CALL FCM_calibr_0005B


	//Decision
	//Decision: trim = 120?
	if (FCV_TRIM == 120)
07C7  0858  	MOVF gbl_FCV_TRIM, W
07C8  3A78  	XORLW 0x78
07C9  1D03  	BTFSS STATUS,Z
07CA  2FD2  	GOTO	label95
07D2        label95

	{

		//Calculation
		//Calculation:
		//  calib_offset = 3
		//  calib_subtractor = 270
		FCV_CALIB_OFFSET = 3;
07CB  3003  	MOVLW 0x03
07CC  00C7  	MOVWF gbl_FCV_CALIB_OFFSET
07CD  01C8  	CLRF gbl_FCV_CALIB_OFFSET+D'1'

		FCV_CALIB_SUBTRACTOR = 270;
07CE  300E  	MOVLW 0x0E
07CF  00C5  	MOVWF gbl_FCV_CALIB_SUBTRACTOR
07D0  3001  	MOVLW 0x01
07D1  00C6  	MOVWF gbl_FCV_CALIB_SUBTRACTOR+D'1'


	// } else {

	}

	//Loop
	//Loop: While 1
	while (1)
09B1  118A  	BCF PCLATH,3
09B2  2FD2  	GOTO	label95

	{

		//Call Component Macro
		//Call Component Macro: trim=ReadAsByte()
		FCV_TRIM = FCD_ADC0_ReadAsByte();
07D2  2318  	CALL FCD_ADC0_R_0005C
07D3  0822  	MOVF CompTempVarRet2255, W
07D4  1283  	BCF STATUS, RP0
07D5  00D8  	MOVWF gbl_FCV_TRIM


		//Call Component Macro
		//Call Component Macro: Disable()
		FCD_PWM0_Disable();
07D6  27A3  	CALL FCD_PWM0_D_0007F


		//Output
		//Output: 0 -> B0
		trisb = trisb & 0xFE;
07D7  30FE  	MOVLW 0xFE
07D8  0506  	ANDWF gbl_trisb, W
07D9  0086  	MOVWF gbl_trisb

		if ((0))
			portb = (portb & 0xFE) | 0x01;
		else
			portb = portb & 0xFE;
07DA  30FE  	MOVLW 0xFE
07DB  1283  	BCF STATUS, RP0
07DC  0506  	ANDWF gbl_portb, W
07DD  0086  	MOVWF gbl_portb


		//Output
		//Output: 0 -> C5
		trisc = trisc & 0xDF;
07DE  30DF  	MOVLW 0xDF
07DF  1683  	BSF STATUS, RP0
07E0  0507  	ANDWF gbl_trisc, W
07E1  0087  	MOVWF gbl_trisc

		if ((0))
			portc = (portc & 0xDF) | 0x20;
		else
			portc = portc & 0xDF;
07E2  30DF  	MOVLW 0xDF
07E3  1283  	BCF STATUS, RP0
07E4  0507  	ANDWF gbl_portc, W
07E5  0087  	MOVWF gbl_portc


		//Connection Point
		//Connection Point: [C]: C
FCC_Main_C:
07E6        label96

;

		//Call Macro
		//Call Macro: scan_off()
		FCM_scan_off();
07E6  2152  	CALL FCM_scan_o_0005A


		//Calculation
		//Calculation:
		//  sw_counter = 0
		FCV_SW_COUNTER = 0;
07E7  01EF  	CLRF gbl_FCV_SW_COUNTER


		//Connection Point
		//Connection Point: [A]: A
FCC_Main_A:
07E8        label97

;

		//Input
		//Input: C0 -> sw_ir
		trisc = trisc | 0x01;
07E8  3001  	MOVLW 0x01
07E9  1683  	BSF STATUS, RP0
07EA  0407  	IORWF gbl_trisc, W
07EB  0087  	MOVWF gbl_trisc

		FCV_SW_IR = ((portc & 0x01) == 0x01);
07EC  3001  	MOVLW 0x01
07ED  1283  	BCF STATUS, RP0
07EE  0507  	ANDWF gbl_portc, W
07EF  00FB  	MOVWF CompTempVar2325
07F0  01FC  	CLRF CompTempVar2326
07F1  037B  	DECF CompTempVar2325, W
07F2  1903  	BTFSC STATUS,Z
07F3  0AFC  	INCF CompTempVar2326, F
07F4  10EA  	BCF gbl_FCV_SW_IR,1
07F5  087C  	MOVF CompTempVar2326, W
07F6  1D03  	BTFSS STATUS,Z
07F7  14EA  	BSF gbl_FCV_SW_IR,1


		//Decision
		//Decision: sw_ir = 0?
		if (FCV_SW_IR == 0)
07F8  18EA  	BTFSC gbl_FCV_SW_IR,1
07F9  2FE8  	GOTO	label97
07FA        label98

		{

			//Connection Point
			//Connection Point: [B]: B
FCC_Main_B:

;

			//Calculation
			//Calculation:
			//  sw_counter = sw_counter + 1
			FCV_SW_COUNTER = FCV_SW_COUNTER + 1;
07FA  0A6F  	INCF gbl_FCV_SW_COUNTER, W
07FB  00EF  	MOVWF gbl_FCV_SW_COUNTER


			//Delay
			//Delay: 100 ms
			delay_ms(100);
07FC  3064  	MOVLW 0x64
07FD  1683  	BSF STATUS, RP0
07FE  00A1  	MOVWF delay_ms_00000_arg_del
07FF  201A  	CALL delay_ms_00000


			//Input
			//Input: C0 -> sw_ir
			trisc = trisc | 0x01;
0800  3001  	MOVLW 0x01
0801  0407  	IORWF gbl_trisc, W
0802  0087  	MOVWF gbl_trisc

			FCV_SW_IR = ((portc & 0x01) == 0x01);
0803  3001  	MOVLW 0x01
0804  1283  	BCF STATUS, RP0
0805  0507  	ANDWF gbl_portc, W
0806  00FB  	MOVWF CompTempVar2327
0807  01FC  	CLRF CompTempVar2328
0808  037B  	DECF CompTempVar2327, W
0809  1903  	BTFSC STATUS,Z
080A  0AFC  	INCF CompTempVar2328, F
080B  10EA  	BCF gbl_FCV_SW_IR,1
080C  087C  	MOVF CompTempVar2328, W
080D  1D03  	BTFSS STATUS,Z
080E  14EA  	BSF gbl_FCV_SW_IR,1


			//Decision
			//Decision: sw_ir = 0?
			if (FCV_SW_IR == 0)
080F  18EA  	BTFSC gbl_FCV_SW_IR,1
0810  2FE6  	GOTO	label96

			{

				//Decision
				//Decision: sw_counter = 10?
				if (FCV_SW_COUNTER == 10)
0811  086F  	MOVF gbl_FCV_SW_COUNTER, W
0812  3A0A  	XORLW 0x0A
0813  1D03  	BTFSS STATUS,Z

				{

				} else {

					//Goto Connection Point
					//Goto Connection Point: [B]: B
					goto FCC_Main_B;
0814  2FFA  	GOTO	label98


				}

			} else {
0918  28F3  	GOTO	label112


				//Goto Connection Point
				//Goto Connection Point: [C]: C
				goto FCC_Main_C;


			}

		} else {

			//Goto Connection Point
			//Goto Connection Point: [A]: A
			goto FCC_Main_A;


		}

		//Call Component Macro
		//Call Component Macro: Enable()
		FCD_PWM0_Enable();
0815  2798  	CALL FCD_PWM0_E_0007E


		//Call Component Macro
		//Call Component Macro: SetDutyCycle(120)
		FCD_PWM0_SetDutyCycle(120);
0816  3078  	MOVLW 0x78
0817  00FE  	MOVWF FCD_PWM0_S_00080_arg_nDuty
0818  2793  	CALL FCD_PWM0_S_00080


		//Call Component Macro
		//Call Component Macro: SetDutyCycle(0)
		FCD_PWM0_SetDutyCycle(0);
0819  01FE  	CLRF FCD_PWM0_S_00080_arg_nDuty
081A  2793  	CALL FCD_PWM0_S_00080


		//Connection Point
		//Connection Point: [D]: D
FCC_Main_D:
081B        label99

;

		//Call Macro
		//Call Macro: i2c_comm()
		FCM_i2c_comm();
081B  118A  	BCF PCLATH,3
081C  2597  	CALL FCM_i2c_co_00051


		//Calculation
		//Calculation:
		//  data_prev = data1
		FCV_DATA_PREV = FCV_DATA1;
081D  1283  	BCF STATUS, RP0
081E  085C  	MOVF gbl_FCV_DATA1, W
081F  00EE  	MOVWF gbl_FCV_DATA_PREV


		//Call Macro
		//Call Macro: i2c_comm()
		FCM_i2c_comm();
0820  2597  	CALL FCM_i2c_co_00051


		//Calculation
		//Calculation:
		//  data_diff = data_prev - data1
		FCV_DATA_DIFF = FCV_DATA_PREV - FCV_DATA1;
0821  1283  	BCF STATUS, RP0
0822  085C  	MOVF gbl_FCV_DATA1, W
0823  026E  	SUBWF gbl_FCV_DATA_PREV, W
0824  00F1  	MOVWF gbl_FCV_DATA_DIFF


		//Decision
		//Decision: data_diff > 10?
		if (FCV_DATA_DIFF > 10)
0825  0871  	MOVF gbl_FCV_DATA_DIFF, W
0826  3C0A  	SUBLW 0x0A
0828  1C03  	BTFSS STATUS,C

		{

			//Goto Connection Point
			//Goto Connection Point: [D]: D
			goto FCC_Main_D;
0827  158A  	BSF PCLATH,3
0829  281B  	GOTO	label99


		// } else {

		}

		//Call Macro
		//Call Macro: calc()
		FCM_calc();
082A  118A  	BCF PCLATH,3
082B  2457  	CALL FCM_calc_00000


		//Calculation
		//Calculation:
		//  temp_tens = temp_c / 10
		//  temp_ones = temp_c % 10
		//  temp_dec = temp_cdp
		FCV_TEMP_TENS = FCV_TEMP_C / 10;
082C  01FB  	CLRF CompTempVar2330
082D  083C  	MOVF gbl_FCV_TEMP_C, W
082E  1683  	BSF STATUS, RP0
082F  00A1  	MOVWF __div_32_3_00001_arg_a
0830  1283  	BCF STATUS, RP0
0831  083D  	MOVF gbl_FCV_TEMP_C+D'1', W
0832  1683  	BSF STATUS, RP0
0833  00A2  	MOVWF __div_32_3_00001_arg_a+D'1'
0834  1283  	BCF STATUS, RP0
0835  083E  	MOVF gbl_FCV_TEMP_C+D'2', W
0836  1683  	BSF STATUS, RP0
0837  00A3  	MOVWF __div_32_3_00001_arg_a+D'2'
0838  1283  	BCF STATUS, RP0
0839  083F  	MOVF gbl_FCV_TEMP_C+D'3', W
083A  1683  	BSF STATUS, RP0
083B  00A4  	MOVWF __div_32_3_00001_arg_a+D'3'
083C  1283  	BCF STATUS, RP0
083D  158A  	BSF PCLATH,3
083E  1FBF  	BTFSS gbl_FCV_TEMP_C+D'3',7
083F  284E  	GOTO	label100
0840  1683  	BSF STATUS, RP0
0841  09A1  	COMF __div_32_3_00001_arg_a, F
0842  09A2  	COMF __div_32_3_00001_arg_a+D'1', F
0843  09A3  	COMF __div_32_3_00001_arg_a+D'2', F
0844  09A4  	COMF __div_32_3_00001_arg_a+D'3', F
0845  0AA1  	INCF __div_32_3_00001_arg_a, F
0846  1903  	BTFSC STATUS,Z
0847  0AA2  	INCF __div_32_3_00001_arg_a+D'1', F
0848  1903  	BTFSC STATUS,Z
0849  0AA3  	INCF __div_32_3_00001_arg_a+D'2', F
084A  1903  	BTFSC STATUS,Z
084B  0AA4  	INCF __div_32_3_00001_arg_a+D'3', F
084C  1283  	BCF STATUS, RP0
084D  0AFB  	INCF CompTempVar2330, F
084E        label100
084E  300A  	MOVLW 0x0A
084F  1683  	BSF STATUS, RP0
0850  00A5  	MOVWF __div_32_3_00001_arg_b
0851  01A6  	CLRF __div_32_3_00001_arg_b+D'1'
0852  01A7  	CLRF __div_32_3_00001_arg_b+D'2'
0853  01A8  	CLRF __div_32_3_00001_arg_b+D'3'
0854  118A  	BCF PCLATH,3
0855  226B  	CALL __div_32_3_00001
0856  0833  	MOVF CompTempVarRet210, W
0857  1283  	BCF STATUS, RP0
0858  00D5  	MOVWF gbl_FCV_TEMP_TENS
0859  158A  	BSF PCLATH,3
085A  1C7B  	BTFSS CompTempVar2330,0
085B  285E  	GOTO	label101
085C  09D5  	COMF gbl_FCV_TEMP_TENS, F
085D  0AD5  	INCF gbl_FCV_TEMP_TENS, F
085E        label101

		FCV_TEMP_ONES = FCV_TEMP_C % 10;
085E  083C  	MOVF gbl_FCV_TEMP_C, W
085F  1683  	BSF STATUS, RP0
0860  00A1  	MOVWF __rem_32_3_00002_arg_a
0861  1283  	BCF STATUS, RP0
0862  083D  	MOVF gbl_FCV_TEMP_C+D'1', W
0863  1683  	BSF STATUS, RP0
0864  00A2  	MOVWF __rem_32_3_00002_arg_a+D'1'
0865  1283  	BCF STATUS, RP0
0866  083E  	MOVF gbl_FCV_TEMP_C+D'2', W
0867  1683  	BSF STATUS, RP0
0868  00A3  	MOVWF __rem_32_3_00002_arg_a+D'2'
0869  1283  	BCF STATUS, RP0
086A  083F  	MOVF gbl_FCV_TEMP_C+D'3', W
086B  1683  	BSF STATUS, RP0
086C  00A4  	MOVWF __rem_32_3_00002_arg_a+D'3'
086D  1283  	BCF STATUS, RP0
086E  1FBF  	BTFSS gbl_FCV_TEMP_C+D'3',7
086F  287C  	GOTO	label102
0870  1683  	BSF STATUS, RP0
0871  09A1  	COMF __rem_32_3_00002_arg_a, F
0872  09A2  	COMF __rem_32_3_00002_arg_a+D'1', F
0873  09A3  	COMF __rem_32_3_00002_arg_a+D'2', F
0874  09A4  	COMF __rem_32_3_00002_arg_a+D'3', F
0875  0AA1  	INCF __rem_32_3_00002_arg_a, F
0876  1903  	BTFSC STATUS,Z
0877  0AA2  	INCF __rem_32_3_00002_arg_a+D'1', F
0878  1903  	BTFSC STATUS,Z
0879  0AA3  	INCF __rem_32_3_00002_arg_a+D'2', F
087A  1903  	BTFSC STATUS,Z
087B  0AA4  	INCF __rem_32_3_00002_arg_a+D'3', F
087C        label102
087C  300A  	MOVLW 0x0A
087D  1683  	BSF STATUS, RP0
087E  00A5  	MOVWF __rem_32_3_00002_arg_b
087F  01A6  	CLRF __rem_32_3_00002_arg_b+D'1'
0880  01A7  	CLRF __rem_32_3_00002_arg_b+D'2'
0881  01A8  	CLRF __rem_32_3_00002_arg_b+D'3'
0882  118A  	BCF PCLATH,3
0883  2221  	CALL __rem_32_3_00002
0884  082E  	MOVF CompTempVarRet212, W
0885  1283  	BCF STATUS, RP0
0886  00E4  	MOVWF gbl_FCV_TEMP_ONES
0887  158A  	BSF PCLATH,3
0888  1FBF  	BTFSS gbl_FCV_TEMP_C+D'3',7
0889  288C  	GOTO	label103
088A  09E4  	COMF gbl_FCV_TEMP_ONES, F
088B  0AE4  	INCF gbl_FCV_TEMP_ONES, F
088C        label103

		FCV_TEMP_DEC = FCV_TEMP_CDP;
088C  0859  	MOVF gbl_FCV_TEMP_CDP, W
088D  00E0  	MOVWF gbl_FCV_TEMP_DEC


		//Call Component Macro
		//Call Component Macro: trim=ReadAsByte()
		FCV_TRIM = FCD_ADC0_ReadAsByte();
088E  118A  	BCF PCLATH,3
088F  2318  	CALL FCD_ADC0_R_0005C
0890  0822  	MOVF CompTempVarRet2255, W
0891  1283  	BCF STATUS, RP0
0892  00D8  	MOVWF gbl_FCV_TRIM


		//Calculation
		//Calculation:
		//  trim_prev = trim
		FCV_TRIM_PREV = FCV_TRIM;
0893  0858  	MOVF gbl_FCV_TRIM, W
0894  00E3  	MOVWF gbl_FCV_TRIM_PREV


		//Call Component Macro
		//Call Component Macro: Enable()
		FCD_PWM0_Enable();
0895  2798  	CALL FCD_PWM0_E_0007E


		//Call Component Macro
		//Call Component Macro: SetDutyCycle(120)
		FCD_PWM0_SetDutyCycle(120);
0896  3078  	MOVLW 0x78
0897  00FE  	MOVWF FCD_PWM0_S_00080_arg_nDuty
0898  2793  	CALL FCD_PWM0_S_00080


		//Loop
		//Loop: Loop 10 times
		for (FCLV_LOOP1=0; FCLV_LOOP1<10; FCLV_LOOP1++)
0899  01F3  	CLRF gbl_FCLV_LOOP1
089A        label104
089A  300A  	MOVLW 0x0A
089B  0273  	SUBWF gbl_FCLV_LOOP1, W
089C  158A  	BSF PCLATH,3
089D  1803  	BTFSC STATUS,C
089E  28A5  	GOTO	label105
08A1  1283  	BCF STATUS, RP0
08A2  0AF3  	INCF gbl_FCLV_LOOP1, F
08A3  158A  	BSF PCLATH,3
08A4  289A  	GOTO	label104
08A5        label105

		{

			//Call Macro
			//Call Macro: display_temp()
			FCM_display_temp();
089F  118A  	BCF PCLATH,3
08A0  2627  	CALL FCM_displa_00059



		}

		//Call Component Macro
		//Call Component Macro: SetDutyCycle(0)
		FCD_PWM0_SetDutyCycle(0);
08A5  01FE  	CLRF FCD_PWM0_S_00080_arg_nDuty
08A6  118A  	BCF PCLATH,3
08A7  2793  	CALL FCD_PWM0_S_00080


		//Loop
		//Loop: While sw_ir = 0
		while (1)
08A8        label106
09A8  28A8  	GOTO	label106

		{

			//Loop
			//Loop: Loop 250 times
			for (FCLV_LOOP2=0; FCLV_LOOP2<250; FCLV_LOOP2++)
08A8  01F4  	CLRF gbl_FCLV_LOOP2
08A9        label107
08A9  30FA  	MOVLW 0xFA
08AA  0274  	SUBWF gbl_FCLV_LOOP2, W
08AB  158A  	BSF PCLATH,3
08AC  1803  	BTFSC STATUS,C
08AD  2993  	GOTO	label129
0991  0AF4  	INCF gbl_FCLV_LOOP2, F
0992  28A9  	GOTO	label107
0993        label129

			{

				//Call Macro
				//Call Macro: display_temp()
				FCM_display_temp();
08AE  118A  	BCF PCLATH,3
08AF  2627  	CALL FCM_displa_00059


				//Decision
				//Decision: temp_c > 37?
				if (FCV_TEMP_C > 37)
08B0  1283  	BCF STATUS, RP0
08B1  083F  	MOVF gbl_FCV_TEMP_C+D'3', W
08B2  3C00  	SUBLW 0x00
08B3  158A  	BSF PCLATH,3
08B4  1D03  	BTFSS STATUS,Z
08B5  28C0  	GOTO	label108
08B6  083E  	MOVF gbl_FCV_TEMP_C+D'2', W
08B7  3C00  	SUBLW 0x00
08B8  1D03  	BTFSS STATUS,Z
08B9  28C0  	GOTO	label108
08BA  083D  	MOVF gbl_FCV_TEMP_C+D'1', W
08BB  3C00  	SUBLW 0x00
08BC  1D03  	BTFSS STATUS,Z
08BD  28C0  	GOTO	label108
08BE  083C  	MOVF gbl_FCV_TEMP_C, W
08BF  3C25  	SUBLW 0x25
08C0        label108
08C0  1BBF  	BTFSC gbl_FCV_TEMP_C+D'3',7
08C1  1403  	BSF STATUS,C
08C2  1803  	BTFSC STATUS,C
08C3  28DE  	GOTO	label109
08DE        label109

				{

					//Call Component Macro
					//Call Component Macro: Enable()
					FCD_PWM0_Enable();
08C4  118A  	BCF PCLATH,3
08C5  2798  	CALL FCD_PWM0_E_0007E


					//Call Component Macro
					//Call Component Macro: SetDutyCycle(120)
					FCD_PWM0_SetDutyCycle(120);
08C6  3078  	MOVLW 0x78
08C7  00FE  	MOVWF FCD_PWM0_S_00080_arg_nDuty
08C8  2793  	CALL FCD_PWM0_S_00080


					//Output
					//Output: 1 -> B0
					trisb = trisb & 0xFE;
08C9  30FE  	MOVLW 0xFE
08CA  1683  	BSF STATUS, RP0
08CB  0506  	ANDWF gbl_trisb, W
08CC  0086  	MOVWF gbl_trisb

					if ((1))
						portb = (portb & 0xFE) | 0x01;
08CD  30FE  	MOVLW 0xFE
08CE  1283  	BCF STATUS, RP0
08CF  0506  	ANDWF gbl_portb, W
08D0  00FE  	MOVWF CompTempVar2335
08D1  3001  	MOVLW 0x01
08D2  047E  	IORWF CompTempVar2335, W
08D3  0086  	MOVWF gbl_portb

					else
						portb = portb & 0xFE;

					//Output
					//Output: 0 -> C5
					trisc = trisc & 0xDF;
08D4  30DF  	MOVLW 0xDF
08D5  1683  	BSF STATUS, RP0
08D6  0507  	ANDWF gbl_trisc, W
08D7  0087  	MOVWF gbl_trisc

					if ((0))
						portc = (portc & 0xDF) | 0x20;
					else
						portc = portc & 0xDF;
08D8  30DF  	MOVLW 0xDF
08D9  1283  	BCF STATUS, RP0
08DA  0507  	ANDWF gbl_portc, W
08DB  0087  	MOVWF gbl_portc


				} else {
08DC  158A  	BSF PCLATH,3
08DD  292C  	GOTO	label118
092C        label118


					//Decision
					//Decision: temp_c < 34?
					if (FCV_TEMP_C < 34)
08DE  3000  	MOVLW 0x00
08DF  023F  	SUBWF gbl_FCV_TEMP_C+D'3', W
08E0  1D03  	BTFSS STATUS,Z
08E1  28EC  	GOTO	label110
08E2  3000  	MOVLW 0x00
08E3  023E  	SUBWF gbl_FCV_TEMP_C+D'2', W
08E4  1D03  	BTFSS STATUS,Z
08E5  28EC  	GOTO	label110
08E6  3000  	MOVLW 0x00
08E7  023D  	SUBWF gbl_FCV_TEMP_C+D'1', W
08E8  1D03  	BTFSS STATUS,Z
08E9  28EC  	GOTO	label110
08EA  3022  	MOVLW 0x22
08EB  023C  	SUBWF gbl_FCV_TEMP_C, W
08EC        label110
08EC  1C03  	BTFSS STATUS,C
08ED  28F0  	GOTO	label111
08EE  1FBF  	BTFSS gbl_FCV_TEMP_C+D'3',7
08EF  2919  	GOTO	label117
08F0        label111
0919        label117

					{

						//Call Component Macro
						//Call Component Macro: Enable()
						FCD_PWM0_Enable();
08F0  118A  	BCF PCLATH,3
08F1  2798  	CALL FCD_PWM0_E_0007E


						//Loop
						//Loop: Loop 6 times
						for (FCLV_LOOP3=0; FCLV_LOOP3<6; FCLV_LOOP3++)
08F2  01F5  	CLRF gbl_FCLV_LOOP3
08F3        label112
08F3  3006  	MOVLW 0x06
08F4  0275  	SUBWF gbl_FCLV_LOOP3, W
08F5  158A  	BSF PCLATH,3
08F6  1803  	BTFSC STATUS,C
08F7  2993  	GOTO	label129
0917  0AF5  	INCF gbl_FCLV_LOOP3, F

						{

							//Call Component Macro
							//Call Component Macro: SetDutyCycle(120)
							FCD_PWM0_SetDutyCycle(120);
08F8  3078  	MOVLW 0x78
08F9  00FE  	MOVWF FCD_PWM0_S_00080_arg_nDuty
08FA  118A  	BCF PCLATH,3
08FB  2793  	CALL FCD_PWM0_S_00080


							//Loop
							//Loop: Loop 10 times
							for (FCLV_LOOP4=0; FCLV_LOOP4<10; FCLV_LOOP4++)
08FC  01F6  	CLRF gbl_FCLV_LOOP4
08FD        label113
08FD  300A  	MOVLW 0x0A
08FE  0276  	SUBWF gbl_FCLV_LOOP4, W
08FF  158A  	BSF PCLATH,3
0900  1803  	BTFSC STATUS,C
0901  2908  	GOTO	label114
0904  1283  	BCF STATUS, RP0
0905  0AF6  	INCF gbl_FCLV_LOOP4, F
0906  158A  	BSF PCLATH,3
0907  28FD  	GOTO	label113
0908        label114

							{

								//Call Macro
								//Call Macro: display_repeat()
								FCM_display_repeat();
0902  118A  	BCF PCLATH,3
0903  25C4  	CALL FCM_displa_0005F



							}

							//Call Component Macro
							//Call Component Macro: SetDutyCycle(0)
							FCD_PWM0_SetDutyCycle(0);
0908  01FE  	CLRF FCD_PWM0_S_00080_arg_nDuty
0909  118A  	BCF PCLATH,3
090A  2793  	CALL FCD_PWM0_S_00080


							//Loop
							//Loop: Loop 10 times
							for (FCLV_LOOP5=0; FCLV_LOOP5<10; FCLV_LOOP5++)
090B  01F7  	CLRF gbl_FCLV_LOOP5
090C        label115
090C  300A  	MOVLW 0x0A
090D  0277  	SUBWF gbl_FCLV_LOOP5, W
090E  158A  	BSF PCLATH,3
090F  1803  	BTFSC STATUS,C
0910  2917  	GOTO	label116
0913  1283  	BCF STATUS, RP0
0914  0AF7  	INCF gbl_FCLV_LOOP5, F
0915  158A  	BSF PCLATH,3
0916  290C  	GOTO	label115
0917        label116

							{

								//Call Macro
								//Call Macro: display_repeat()
								FCM_display_repeat();
0911  118A  	BCF PCLATH,3
0912  25C4  	CALL FCM_displa_0005F



							}


						}

						//Goto Connection Point
						//Goto Connection Point: [E]: E
						goto FCC_Main_E;


					} else {

						//Output
						//Output: 0 -> B0
						trisb = trisb & 0xFE;
0919  30FE  	MOVLW 0xFE
091A  1683  	BSF STATUS, RP0
091B  0506  	ANDWF gbl_trisb, W
091C  0086  	MOVWF gbl_trisb

						if ((0))
							portb = (portb & 0xFE) | 0x01;
						else
							portb = portb & 0xFE;
091D  30FE  	MOVLW 0xFE
091E  1283  	BCF STATUS, RP0
091F  0506  	ANDWF gbl_portb, W
0920  0086  	MOVWF gbl_portb


						//Output
						//Output: 1 -> C5
						trisc = trisc & 0xDF;
0921  30DF  	MOVLW 0xDF
0922  1683  	BSF STATUS, RP0
0923  0507  	ANDWF gbl_trisc, W
0924  0087  	MOVWF gbl_trisc

						if ((1))
							portc = (portc & 0xDF) | 0x20;
0925  30DF  	MOVLW 0xDF
0926  1283  	BCF STATUS, RP0
0927  0507  	ANDWF gbl_portc, W
0928  00FE  	MOVWF CompTempVar2336
0929  3020  	MOVLW 0x20
092A  047E  	IORWF CompTempVar2336, W
092B  0087  	MOVWF gbl_portc

						else
							portc = portc & 0xDF;

					}

				}

				//Call Component Macro
				//Call Component Macro: trim=ReadAsByte()
				FCV_TRIM = FCD_ADC0_ReadAsByte();
092C  118A  	BCF PCLATH,3
092D  2318  	CALL FCD_ADC0_R_0005C
092E  0822  	MOVF CompTempVarRet2255, W
092F  1283  	BCF STATUS, RP0
0930  00D8  	MOVWF gbl_FCV_TRIM


				//Calculation
				//Calculation:
				//  trim_diff = trim - trim_prev
				FCV_TRIM_DIFF = FCV_TRIM - FCV_TRIM_PREV;
0931  0858  	MOVF gbl_FCV_TRIM, W
0932  00B8  	MOVWF gbl_FCV_TRIM_DIFF
0933  01B9  	CLRF gbl_FCV_TRIM_DIFF+D'1'
0934  01BA  	CLRF gbl_FCV_TRIM_DIFF+D'2'
0935  01BB  	CLRF gbl_FCV_TRIM_DIFF+D'3'
0936  0863  	MOVF gbl_FCV_TRIM_PREV, W
0937  1683  	BSF STATUS, RP0
0938  00A0  	MOVWF CompTempVar2337
0939  01A1  	CLRF CompTempVar2337+D'1'
093A  01A2  	CLRF CompTempVar2337+D'2'
093B  01A3  	CLRF CompTempVar2337+D'3'
093C  0820  	MOVF CompTempVar2337, W
093D  1283  	BCF STATUS, RP0
093E  02B8  	SUBWF gbl_FCV_TRIM_DIFF, F
093F  1683  	BSF STATUS, RP0
0940  0821  	MOVF CompTempVar2337+D'1', W
0941  158A  	BSF PCLATH,3
0942  1803  	BTFSC STATUS,C
0943  2947  	GOTO	label119
0944  0F21  	INCFSZ CompTempVar2337+D'1', W
0945  2947  	GOTO	label119
0946  2949  	GOTO	label120
0947        label119
0947  1283  	BCF STATUS, RP0
0948  02B9  	SUBWF gbl_FCV_TRIM_DIFF+D'1', F
0949        label120
0949  1683  	BSF STATUS, RP0
094A  0822  	MOVF CompTempVar2337+D'2', W
094B  1803  	BTFSC STATUS,C
094C  2950  	GOTO	label121
094D  0F22  	INCFSZ CompTempVar2337+D'2', W
094E  2950  	GOTO	label121
094F  2952  	GOTO	label122
0950        label121
0950  1283  	BCF STATUS, RP0
0951  02BA  	SUBWF gbl_FCV_TRIM_DIFF+D'2', F
0952        label122
0952  1683  	BSF STATUS, RP0
0953  0823  	MOVF CompTempVar2337+D'3', W
0954  1803  	BTFSC STATUS,C
0955  2959  	GOTO	label123
0956  0F23  	INCFSZ CompTempVar2337+D'3', W
0957  2959  	GOTO	label123
0958  295B  	GOTO	label124
0959        label123
0959  1283  	BCF STATUS, RP0
095A  02BB  	SUBWF gbl_FCV_TRIM_DIFF+D'3', F
095B        label124


				//Decision
				//Decision: trim_diff > 2 OR trim_diff < -2?
				if (FCV_TRIM_DIFF > 2 | FCV_TRIM_DIFF < -2)
095B  1283  	BCF STATUS, RP0
095C  01FD  	CLRF CompTempVar2334
095D  083B  	MOVF gbl_FCV_TRIM_DIFF+D'3', W
095E  3C00  	SUBLW 0x00
095F  1D03  	BTFSS STATUS,Z
0960  296B  	GOTO	label125
0961  083A  	MOVF gbl_FCV_TRIM_DIFF+D'2', W
0962  3C00  	SUBLW 0x00
0963  1D03  	BTFSS STATUS,Z
0964  296B  	GOTO	label125
0965  0839  	MOVF gbl_FCV_TRIM_DIFF+D'1', W
0966  3C00  	SUBLW 0x00
0967  1D03  	BTFSS STATUS,Z
0968  296B  	GOTO	label125
0969  0838  	MOVF gbl_FCV_TRIM_DIFF, W
096A  3C02  	SUBLW 0x02
096B        label125
096B  1BBB  	BTFSC gbl_FCV_TRIM_DIFF+D'3',7
096C  1403  	BSF STATUS,C
096D  1C03  	BTFSS STATUS,C
096E  0AFD  	INCF CompTempVar2334, F
096F  01FC  	CLRF CompTempVar2333
0970  083B  	MOVF gbl_FCV_TRIM_DIFF+D'3', W
0971  3A80  	XORLW 0x80
0972  00FE  	MOVWF CompTempVar2343
0973  30FF  	MOVLW 0xFF
0974  3A80  	XORLW 0x80
0975  027E  	SUBWF CompTempVar2343, W
0976  1D03  	BTFSS STATUS,Z
0977  2982  	GOTO	label126
0978  30FF  	MOVLW 0xFF
0979  023A  	SUBWF gbl_FCV_TRIM_DIFF+D'2', W
097A  1D03  	BTFSS STATUS,Z
097B  2982  	GOTO	label126
097C  30FF  	MOVLW 0xFF
097D  0239  	SUBWF gbl_FCV_TRIM_DIFF+D'1', W
097E  1D03  	BTFSS STATUS,Z
097F  2982  	GOTO	label126
0980  30FE  	MOVLW 0xFE
0981  0238  	SUBWF gbl_FCV_TRIM_DIFF, W
0982        label126
0982  1C03  	BTFSS STATUS,C
0983  0AFC  	INCF CompTempVar2333, F
0984  087C  	MOVF CompTempVar2333, W
0985  047D  	IORWF CompTempVar2334, W
0986  1903  	BTFSC STATUS,Z
0987  2991  	GOTO	label128

				{

					//Calculation
					//Calculation:
					//  calib_var = 1
					FCV_CALIB_VAR = 1;
0988  3001  	MOVLW 0x01
0989  00ED  	MOVWF gbl_FCV_CALIB_VAR


					//Loop
					//Loop: While calib_var = 1
					while (FCV_CALIB_VAR == 1)
098A        label127
098A  036D  	DECF gbl_FCV_CALIB_VAR, W
098B  1D03  	BTFSS STATUS,Z
098C  2991  	GOTO	label128
098F  158A  	BSF PCLATH,3
0990  298A  	GOTO	label127
0991        label128

					{

						//Call Macro
						//Call Macro: calibrate()
						FCM_calibrate();
098D  118A  	BCF PCLATH,3
098E  266E  	CALL FCM_calibr_0005B



					}

				// } else {

				}


			}

			//Connection Point
			//Connection Point: [E]: E
FCC_Main_E:
;

			//Input
			//Input: C0 -> sw_ir
			trisc = trisc | 0x01;
0993  3001  	MOVLW 0x01
0994  1683  	BSF STATUS, RP0
0995  0407  	IORWF gbl_trisc, W
0996  0087  	MOVWF gbl_trisc

			FCV_SW_IR = ((portc & 0x01) == 0x01);
0997  3001  	MOVLW 0x01
0998  1283  	BCF STATUS, RP0
0999  0507  	ANDWF gbl_portc, W
099A  00FC  	MOVWF CompTempVar2344
099B  01FD  	CLRF CompTempVar2345
099C  037C  	DECF CompTempVar2344, W
099D  1903  	BTFSC STATUS,Z
099E  0AFD  	INCF CompTempVar2345, F
099F  10EA  	BCF gbl_FCV_SW_IR,1
09A0  087D  	MOVF CompTempVar2345, W
09A1  1D03  	BTFSS STATUS,Z
09A2  14EA  	BSF gbl_FCV_SW_IR,1



			if ((FCV_SW_IR == 0) == 0) break;
09A3  01FB  	CLRF CompTempVar2332
09A4  1CEA  	BTFSS gbl_FCV_SW_IR,1
09A5  0AFB  	INCF CompTempVar2332, F
09A6  08FB  	MOVF CompTempVar2332, F
09A7  1D03  	BTFSS STATUS,Z

		}

		//Output
		//Output: 0 -> C5
		trisc = trisc & 0xDF;
09A9  30DF  	MOVLW 0xDF
09AA  1683  	BSF STATUS, RP0
09AB  0507  	ANDWF gbl_trisc, W
09AC  0087  	MOVWF gbl_trisc

		if ((0))
			portc = (portc & 0xDF) | 0x20;
		else
			portc = portc & 0xDF;
09AD  30DF  	MOVLW 0xDF
09AE  1283  	BCF STATUS, RP0
09AF  0507  	ANDWF gbl_portc, W
09B0  0087  	MOVWF gbl_portc



	}

	mainendloop: goto mainendloop;
}


void MX_INTERRUPT_MACRO(void)

{
}
0A13  1283  	BCF STATUS, RP0
0A14  1303  	BCF STATUS, RP1
0A15  0E42  	SWAPF Int1BContext+D'2', W
0A16  0084  	MOVWF FSR
0A17  0E41  	SWAPF Int1BContext+D'1', W
0A18  008A  	MOVWF PCLATH
0A19  0E40  	SWAPF Int1BContext, W
0A1A  0083  	MOVWF STATUS
0A1B  0EFF  	SWAPF Int1Context, F
0A1C  0E7F  	SWAPF Int1Context, W
0A1D  0009  	RETFIE





/*********************************************************************
 *                  Flowcode CAL ADC File
 *
 * File: PIC_CAL_ADC.c
 *
 * (c) 2011 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * Company) for its Flowcode graphical programming language is
 * intended and supplied to you, the Companys customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 060911 | BR | Created
 * 200911 | BR | Updated to include all ADC type files
 */


//ADC Function Prototypes
void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge);
MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode);
void FC_CAL_Disable_ADC (void);


//ADC Global Variables
MX_UINT8 old_tris, tris_mask;
MX_UINT8 * tris_reg;					//TRIS register pointer


// ADC Type 1 Supported Devices ************************************************************
// 16F818, 16F819, 16F873A, 16F874A, 16F876A, 16F877A,
// *******************************************************************************************/

#ifdef MX_ADC_TYPE_1
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)

	{
		switch (Channel)
0051  2862  	GOTO	label8

		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					if (Vref == 0)
						adcon1 = 0x0E;
					else
						adcon1 = 0x05;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					if (Vref == 0)
						adcon1 = 0x04;
					else
						adcon1 = 0x05;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					if (Vref == 0)
						adcon1 = 0x02;
					else
						adcon1 = 0x03;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					if (Vref == 0)
						adcon1 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
004E  0822  	MOVF FC_CAL_Ena_0006B_arg_Channel, W
004F  3A04  	XORLW 0x04
0050  1D03  	BTFSS STATUS,Z

					tris_mask = 0x20;
0052  3020  	MOVLW 0x20
0053  1283  	BCF STATUS, RP0
0054  00FA  	MOVWF gbl_tris_mask

					tris_reg = &trisa;
0055  3000  	MOVLW HIGH(gbl_trisa+D'0')
0056  00CA  	MOVWF gbl_tris_reg+D'1'
0057  3085  	MOVLW LOW(gbl_trisa+D'0')
0058  00C9  	MOVWF gbl_tris_reg

					if (Vref == 0)
0059  1683  	BSF STATUS, RP0
005A  08A4  	MOVF FC_CAL_Ena_0006B_arg_Vref, F
005B  1D03  	BTFSS STATUS,Z
005C  2860  	GOTO	label7
0060        label7

						adcon1 = 0x02;
005D  3002  	MOVLW 0x02
005E  009F  	MOVWF gbl_adcon1

					else
005F  2862  	GOTO	label8
0062        label8

						adcon1 = 0x03;
0060  3003  	MOVLW 0x03
0061  009F  	MOVWF gbl_adcon1

					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x01;
					tris_reg = &trise;
					if (Vref == 0)
						adcon1 = 0x09;
					else
						adcon1 = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trise;
					if (Vref == 0)
						adcon1 = 0x00;
					else
						adcon1 = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trise;
					if (Vref == 0)
						adcon1 = 0x00;
					else
						adcon1 = 0x01;
					break;
			#endif
		}

		if (Conv_Speed > 3)										//assign conversion speed
0062  0823  	MOVF FC_CAL_Ena_0006B_arg_Conv_Speed, W
0063  3C03  	SUBLW 0x03
0064  1C03  	BTFSS STATUS,C

			st_bit(adcon1, ADCS2);
0065  171F  	BSF gbl_adcon1,6


		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
0066  1383  	BCF STATUS,IRP
0067  1283  	BCF STATUS, RP0
0068  184A  	BTFSC gbl_tris_reg+D'1',0
0069  1783  	BSF STATUS,IRP
006A  0849  	MOVF gbl_tris_reg, W
006B  0084  	MOVWF FSR
006C  0800  	MOVF INDF, W
006D  00F9  	MOVWF gbl_old_tris

		*tris_reg = old_tris | tris_mask;
006E  087A  	MOVF gbl_tris_mask, W
006F  0479  	IORWF gbl_old_tris, W
0070  1683  	BSF STATUS, RP0
0071  00A6  	MOVWF CompTempVar2276
0072  0080  	MOVWF INDF

		adcon0 = (0x01 | (Conv_Speed << 6)) | (Channel << 3);	//turn ADC on
0073  0823  	MOVF FC_CAL_Ena_0006B_arg_Conv_Speed, W
0074  00A6  	MOVWF CompTempVar2277
0075  01A7  	CLRF CompTempVar2278
0076  0DA6  	RLF CompTempVar2277, F
0077  0DA7  	RLF CompTempVar2278, F
0078  0DA6  	RLF CompTempVar2277, F
0079  0DA7  	RLF CompTempVar2278, F
007A  0DA6  	RLF CompTempVar2277, F
007B  0DA7  	RLF CompTempVar2278, F
007C  0DA6  	RLF CompTempVar2277, F
007D  0DA7  	RLF CompTempVar2278, F
007E  0DA6  	RLF CompTempVar2277, F
007F  0DA7  	RLF CompTempVar2278, F
0080  0DA6  	RLF CompTempVar2277, F
0081  0DA7  	RLF CompTempVar2278, F
0082  30C0  	MOVLW 0xC0
0083  0526  	ANDWF CompTempVar2277, W
0084  3801  	IORLW 0x01
0085  00A9  	MOVWF CompTempVar2281
0086  0822  	MOVF FC_CAL_Ena_0006B_arg_Channel, W
0087  00A8  	MOVWF CompTempVar2280
0088  0DA8  	RLF CompTempVar2280, F
0089  0DA8  	RLF CompTempVar2280, F
008A  0DA8  	RLF CompTempVar2280, F
008B  30F8  	MOVLW 0xF8
008C  0528  	ANDWF CompTempVar2280, W
008D  0429  	IORWF CompTempVar2281, W
008E  1283  	BCF STATUS, RP0
008F  009F  	MOVWF gbl_adcon0

		delay_us(T_Charge);										//wait the acquisition time
0090  1683  	BSF STATUS, RP0
0091  0825  	MOVF FC_CAL_Ena_0006B_arg_T_Charge, W
0092  00A6  	MOVWF delay_us_00000_arg_del
0093  2010  	CALL delay_us_00000

	}
0094  0008  	RETURN


	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)

	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x04;									//begin conversion and wait until it has finished
0026  3004  	MOVLW 0x04
0027  1283  	BCF STATUS, RP0
0028  041F  	IORWF gbl_adcon0, W
0029  009F  	MOVWF gbl_adcon0

		while (adcon0 & 0x04);
002A        label4
002A  191F  	BTFSC gbl_adcon0,2
002B  282A  	GOTO	label4

		if (Sample_Mode)
002C  1683  	BSF STATUS, RP0
002D  08A2  	MOVF FC_CAL_Sam_0006C_arg_Sample_Mode, F
002E  1903  	BTFSC STATUS,Z
002F  2844  	GOTO	label5
0044        label5

		{
			iRetVal = (adresh << 2);							//10-bit ADC
0030  1283  	BCF STATUS, RP0
0031  081E  	MOVF gbl_adresh, W
0032  1683  	BSF STATUS, RP0
0033  00A3  	MOVWF FC_CAL_Sam_0006C_1_iRetVal
0034  01A4  	CLRF FC_CAL_Sam_0006C_1_iRetVal+D'1'
0035  0DA3  	RLF FC_CAL_Sam_0006C_1_iRetVal, F
0036  0DA4  	RLF FC_CAL_Sam_0006C_1_iRetVal+D'1', F
0037  0DA3  	RLF FC_CAL_Sam_0006C_1_iRetVal, F
0038  0DA4  	RLF FC_CAL_Sam_0006C_1_iRetVal+D'1', F
0039  30FC  	MOVLW 0xFC
003A  05A3  	ANDWF FC_CAL_Sam_0006C_1_iRetVal, F

			iRetVal = iRetVal | (adresl >> 6);
003B  0C1E  	RRF gbl_adresl, W
003C  00A5  	MOVWF CompTempVar2285
003D  0CA5  	RRF CompTempVar2285, F
003E  0EA5  	SWAPF CompTempVar2285, F
003F  3003  	MOVLW 0x03
0040  0525  	ANDWF CompTempVar2285, W
0041  04A3  	IORWF FC_CAL_Sam_0006C_1_iRetVal, F
0042  08A4  	MOVF FC_CAL_Sam_0006C_1_iRetVal+D'1', F

		}
		else
0043  2849  	GOTO	label6
0049        label6

			iRetVal = adresh;									//8-bit ADC
0044  1283  	BCF STATUS, RP0
0045  081E  	MOVF gbl_adresh, W
0046  1683  	BSF STATUS, RP0
0047  00A3  	MOVWF FC_CAL_Sam_0006C_1_iRetVal
0048  01A4  	CLRF FC_CAL_Sam_0006C_1_iRetVal+D'1'


		return (iRetVal);
0049  0823  	MOVF FC_CAL_Sam_0006C_1_iRetVal, W
004A  00A5  	MOVWF CompTempVarRet2282
004B  0824  	MOVF FC_CAL_Sam_0006C_1_iRetVal+D'1', W
004C  00A6  	MOVWF CompTempVarRet2282+D'1'

	}
004D  0008  	RETURN


	void FC_CAL_Disable_ADC ()

	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
0095  1383  	BCF STATUS,IRP
0096  1283  	BCF STATUS, RP0
0097  1303  	BCF STATUS, RP1
0098  184A  	BTFSC gbl_tris_reg+D'1',0
0099  1783  	BSF STATUS,IRP
009A  0849  	MOVF gbl_tris_reg, W
009B  0084  	MOVWF FSR
009C  0879  	MOVF gbl_old_tris, W
009D  0080  	MOVWF INDF

		adcon1 = 0x07;
009E  3007  	MOVLW 0x07
009F  1683  	BSF STATUS, RP0
00A0  009F  	MOVWF gbl_adcon1

		adcon0 = 0x00;
00A1  1283  	BCF STATUS, RP0
00A2  019F  	CLRF gbl_adcon0

	}
00A3  0008  	RETURN

#endif


// ADC Type 2 Supported Devices ************************************************************
// 16F88
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_2
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		if (Vref == 1)											//assign VREF functionality
			st_bit(adcon1, VCFG1);

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ansel = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ansel = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ansel = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					ansel = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x10;
					tris_reg = &trisa;
					ansel = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x20;
					tris_reg = &trisb;
					ansel = 0x20;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x40;
					tris_reg = &trisb;
					ansel = 0x40;
					break;
			#endif
		}

		if (Conv_Speed > 3)										//assign conversion speed
			st_bit(adcon1, ADCS2);

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Conv_Speed << 6)) | (Channel << 3);	//turn ADC on
		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x04;									//begin conversion and wait until it has finished
		while (adcon0 & 0x04);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		ansel = 0x00;
		adcon0 = 0x00;
	}
#endif


// ADC Type 3 Supported Devices ************************************************************
// 16F616, 16F676, 16F677, 16F684, 16F685, 16F687, 16F688, 16F689, 16F690
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_3
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon1 = ((Conv_Speed & 0x07) << 4);				//assign conversion rate

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ansel = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ansel = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ansel = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x10;
					tris_reg = &trisa;
					ansel = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x01;
					tris_reg = &trisc;
					ansel = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x02;
					tris_reg = &trisc;
					ansel = 0x20;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x04;
					tris_reg = &trisc;
					ansel = 0x40;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x08;
					tris_reg = &trisc;
					ansel = 0x80;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x40;
					tris_reg = &trisc;
					anselh = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x80;
					tris_reg = &trisc;
					anselh = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x10;
					tris_reg = &trisb;
					anselh = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x20;
					tris_reg = &trisb;
					anselh = 0x08;
					break;
			#endif
		}

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on

		if (Vref == 1)											//assign VREF functionality
			st_bit(adcon0, VCFG);

		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x02;									//begin conversion and wait until it has finished
		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		ansel = 0x00;
		adcon0 = 0x00;
		#ifdef ANSELH
			anselh = 0x00;
		#endif
	}
#endif


// ADC Type 4 Supported Devices ************************************************************
// 16F737, 16F747, 16F767, 16F777
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_4
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon2 = 0x00;

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					adcon1 = 0x0E;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					adcon1 = 0x0D;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					adcon1 = 0x0C;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					adcon1 = 0x0B;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					adcon1 = 0x0A;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x01;
					tris_reg = &trise;
					adcon1 = 0x09;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trise;
					adcon1 = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trise;
					adcon1 = 0x07;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x04;
					tris_reg = &trisb;
					adcon1 = 0x06;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x08;
					tris_reg = &trisb;
					adcon1 = 0x05;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x02;
					tris_reg = &trisb;
					adcon1 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x10;
					tris_reg = &trisb;
					adcon1 = 0x03;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_12
				case (12):
					tris_mask = 0x01;
					tris_reg = &trisb;
					adcon1 = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_13
				case (13):
					tris_mask = 0x20;
					tris_reg = &trisb;
					adcon1 = 0x01;
					break;
			#endif
		}

		if (Vref == 1)											//assign VREF functionality
			st_bit(adcon1, VCFG0);

		if (Conv_Speed > 3)										//assign conversion speed
			st_bit(adcon1, ADCS2);

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Conv_Speed << 6));					//turn ADC on
		adcon0 = adcon0 | ((Channel & 0x07) << 3);
		adcon0 = adcon0 | ((Channel & 0x08) >> 2);
		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x04;									//begin conversion and wait until it has finished
		while (adcon0 & 0x04);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		adcon1 = 0x07;
		adcon0 = 0x00;
	}
#endif


// ADC Type 5 Supported Devices ************************************************************
// 12F615, 12HV615, 12F675, 12F683
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_5
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		tris_reg = &trisio;

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					ansel = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					ansel = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					ansel = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x10;
					ansel = 0x08;
					break;
			#endif
		}

		ansel = ansel | ((Conv_Speed & 0x07) << 4);				//assign conversion speed

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on

		if (Vref == 1)											//assign VREF functionality
			st_bit(adcon0, VCFG);

		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x02;									//begin conversion and wait until it has finished
		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		ansel = 0x00;
		adcon0 = 0x00;
	}
#endif


// ADC Type 6 Supported Devices ************************************************************
// 16C72, 16C72A, 16CR72, 16F72, 16C73, 16C73A, 16C73B, 16F73, 16C74, 16C74A, 16C74B, 16F74,
// 16C76, 16F76, 16C77, 16F77, 16C716, 16F716
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_6
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					adcon1 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					adcon1 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					adcon1 = 0x00;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					adcon1 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					adcon1 = 0x00;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x01;
					tris_reg = &trise;
					adcon1 = 0x00;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trise;
					adcon1 = 0x00;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trise;
					adcon1 = 0x00;
					break;
			#endif
		}

		if (Vref != 0)											//assign VREF functionality
			adcon1 = adcon1 + 1;

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Conv_Speed << 6)) | (Channel << 3);	//turn ADC on
		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x04;									//begin conversion and wait until it has finished
		while (adcon0 & 0x04);
		if (Sample_Mode)
		{
			iRetVal = (adres << 2);								//10-bit ADC
		}
		else
			iRetVal = adres;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		adcon1 = 0x07;
		adcon0 = 0x00;
	}
#endif



// ADC Type 7 Supported Devices ************************************************************
// 16F883, 16F884, 16F886, 16F887
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_7
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon1 = 0x00;

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ansel = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ansel = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ansel = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					ansel = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					ansel = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x01;
					tris_reg = &trise;
					ansel = 0x20;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trise;
					ansel = 0x40;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trise;
					ansel = 0x80;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x04;
					tris_reg = &trisb;
					anselh = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x08;
					tris_reg = &trisb;
					anselh = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x02;
					tris_reg = &trisb;
					anselh = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x10;
					tris_reg = &trisb;
					anselh = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_12
				case (13):
					tris_mask = 0x01;
					tris_reg = &trisb;
					anselh = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_13
				case (13):
					tris_mask = 0x20;
					tris_reg = &trisb;
					anselh = 0x20;
					break;
			#endif
		}

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Conv_Speed << 6)) | (Channel << 2);	//turn ADC on

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon0, VCFG0);

		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x02;									//begin conversion and wait until it has finished
		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		ansel = 0x00;
		adcon0 = 0x00;
		#ifdef ANSELH
			anselh = 0x00;
		#endif
	}
#endif


// ADC Type 8 Supported Devices ************************************************************
// 16F785
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_8
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ansel0 = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ansel0 = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ansel0 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x10;
					tris_reg = &trisa;
					ansel0 = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x01;
					tris_reg = &trisc;
					ansel0 = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x02;
					tris_reg = &trisc;
					ansel0 = 0x20;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x04;
					tris_reg = &trisc;
					ansel0 = 0x40;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x08;
					tris_reg = &trisc;
					ansel0 = 0x80;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x40;
					tris_reg = &trisc;
					ansel1 = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x80;
					tris_reg = &trisc;
					ansel1 = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x10;
					tris_reg = &trisb;
					ansel1 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x20;
					tris_reg = &trisb;
					ansel1 = 0x08;
					break;
			#endif
		}

		adcon1 = ((Conv_Speed & 0x07) << 4);					//assign conversion rate

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon0, VCFG);

		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x02;									//begin conversion and wait until it has finished
		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		ansel0 = 0x00;
		adcon0 = 0x00;
		#ifdef ANSEL1
			ansel1 = 0x00;
		#endif
	}
#endif


// ADC Type 9 Supported Devices ************************************************************
// 16F913, 16F914, 16F916, 16F917, 16F946
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_9
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ansel = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ansel = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ansel = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					ansel = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					ansel = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x01;
					tris_reg = &trise;
					ansel = 0x20;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trise;
					ansel = 0x40;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trise;
					ansel = 0x80;
					break;
			#endif
		}

		adcon1 = ((Conv_Speed & 0x07) << 4);					//assign conversion rate

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon0, VCFG0);

		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x02;									//begin conversion and wait until it has finished
		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		adcon0 = 0x00;
		ansel = 0x00;
	}
#endif


// ADC Type 10 Supported Devices ***********************************************************
// 12C671, 12C672, 12CE673, 12CE674
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_10
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		tris_reg = &trisio;

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					if (Vref == 0)
						adcon1 = 0x06;
					else
						adcon1 = 0x05;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					adcon1 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					if (Vref == 0)
						adcon1 = 0x02;
					else
						adcon1 = 0x03;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					if (Vref == 0)
						adcon1 = 0x00;
					else
						adcon1 = 0x01;
					break;
			#endif
		}

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Conv_Speed << 6)) | (Channel << 3);	//turn ADC on
		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x02;									//begin conversion and wait until it has finished
		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adres << 2);								//10-bit ADC
		}
		else
			iRetVal = adres;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		adcon1 = 0x07;
		adcon0 = 0x00;
	}
#endif


// ADC Type 11 Supported Devices ***********************************************************
// 16C717, 16C770, 16C771
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_11
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon1 = 0x00;

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ansel = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ansel = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ansel = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					ansel = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x01;
					tris_reg = &trisb;
					ansel = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x02;
					tris_reg = &trisb;
					ansel = 0x20;
					break;
			#endif
		}

		if (Conv_Speed > 3)										//assign conversion speed
			st_bit(adcon1, ADFM);

		if (Vref != 0)											//assign VREF functionality
		{
			st_bit(adcon1, VCFG0);
			st_bit(adcon1, VCFG1);
		}

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Conv_Speed << 6)) | (Channel << 3);	//turn ADC on
		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x04;									//begin conversion and wait until it has finished
		while (adcon0 & 0x04);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		adcon0 = 0x00;
		ansel = 0x00;
	}
#endif


// ADC Type 12 Supported Devices ***********************************************************
// 18F6310, 18F6390, 18F6410, 18F6490, 18F6520, 18F6527, 18F6585, 18F66J60, 18F66J65,
// 18F6620, 18F6622, 18F6627, 18F6680, 18F67J60, 18F6720, 18F6722, 18F8310, 18F8390,
// 18F8410, 18F8490, 18F8520, 18F8527, 18F8585, 18F86J60, 18F86J65, 18F8620, 18F8622,
// 18F8627, 18F8680, 18F87J60, 18F8720, 18F8722, 18F96J60, 18F96J65, 18F97J60
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_12
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon2 = Conv_Speed & 0x07;								//assign conversion rate

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					adcon1 = 0x0E;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					adcon1 = 0x0D;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					adcon1 = 0x0C;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					adcon1 = 0x0B;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					adcon1 = 0x0A;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x01;
					tris_reg = &trisf;
					adcon1 = 0x09;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trisf;
					adcon1 = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trisf;
					adcon1 = 0x07;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x08;
					tris_reg = &trisf;
					adcon1 = 0x06;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x10;
					tris_reg = &trisf;
					adcon1 = 0x05;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x20;
					tris_reg = &trisf;
					adcon1 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x40;
					tris_reg = &trisf;
					adcon1 = 0x03;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_12
				case (12):
					tris_mask = 0x10;
					tris_reg = &trish;
					adcon1 = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_13
				case (13):
					tris_mask = 0x20;
					tris_reg = &trish;
					adcon1 = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_14
				case (14):
					tris_mask = 0x40;
					tris_reg = &trish;
					adcon1 = 0x00;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_15
				case (15):
					tris_mask = 0x80;
					tris_reg = &trish;
					adcon1 = 0x00;
					break;
			#endif
		}

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon0, VCFG0);

		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x02;									//begin conversion and wait until it has finished
		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		adcon1 = 0x0f;
		adcon0 = 0x00;
	}
#endif


// ADC Type 13 Supported Devices ***********************************************************
// 18F2220, 18F2221, 18F2320, 18F2321, 18F24J10, 18F2410, 18F2420, 18F2423, 18F2450,
// 18F2455, 18F2480, 18F25J10, 18F2510, 18F2515, 18F2520, 18F2523, 18F2525, 18F2550,
// 18F2580, 18F2585, 18F2610, 18F2620, 18F2680, 18F4220, 18F4221, 18F4320, 18F4321,
// 18F44J10, 18F4410, 18F4420, 18F4423, 18F4450, 18F4455, 18F4480, 18F45J10, 18F4510,
// 18F4515, 18F4520, 18F4523, 18F4525, 18F4550, 18F4580, 18F4585, 18F4610, 18F4620,
// 18F4680, 18F4682, 18F4685
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_13
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon2 = Conv_Speed & 0x07;								//assign conversion rate

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					adcon1 = 0x0E;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					adcon1 = 0x0D;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					adcon1 = 0x0C;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					adcon1 = 0x0B;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					adcon1 = 0x0A;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x01;
					tris_reg = &trise;
					adcon1 = 0x09;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trise;
					adcon1 = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trise;
					adcon1 = 0x07;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x04;
					tris_reg = &trisb;
					adcon1 = 0x06;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x08;
					tris_reg = &trisb;
					adcon1 = 0x05;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x02;
					tris_reg = &trisb;
					adcon1 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x10;
					tris_reg = &trisb;
					adcon1 = 0x03;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_12
				case (12):
					tris_mask = 0x01;
					tris_reg = &trisb;
					adcon1 = 0x02;
					break;
			#endif
		}

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon0, VCFG0);

		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x02;									//begin conversion and wait until it has finished
		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
		  #ifdef MX_ADC_BITS_12
			iRetVal = (adresh << 4);							//12-bit ADC
			iRetVal = iRetVal | (adresl >> 4);
		  #else
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		  #endif
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		adcon1 = 0x0f;
		adcon0 = 0x00;
	}
#endif


// ADC Type 14 Supported Devices ***********************************************************
// 18F2331, 18F2431, 18F4331, 18F4431
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_14
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon1 = 0x00;											//set up ADC conversion
		adcon2 = Conv_Speed & 0x07;
		adcon3 = 0x00;
		adchs = 0x00;

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					adcon0 = 0x00;
					ansel0 = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					adcon0 = 0x04;
					ansel0 = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					adcon0 = 0x08;
					ansel0 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					adcon0 = 0x0C;
					ansel0 = 0x08;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x10;
					tris_reg = &trisa;
					adcon0 = 0x00;
					adchs = 0x01;
					ansel0 = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x20;
					tris_reg = &trisa;
					adcon0 = 0x04;
					adchs = 0x10;
					ansel0 = 0x20;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x01;
					tris_reg = &trise;
					adcon0 = 0x08;
					adchs = 0x04;
					ansel0 = 0x40;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x02;
					tris_reg = &trise;
					adcon0 = 0x0C;
					adchs = 0x40;
					ansel0 = 0x80;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x04;
					tris_reg = &trisb;
					adcon0 = 0x00;
					adchs = 0x02;
					ansel1 = 0x01;
					break;
			#endif
		}

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = adcon0 | 0x01;									//turn ADC on

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon0, VCFG0);

		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x02;									//begin conversion and wait until it has finished
		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		adcon0 = 0x00;
		ansel0 = 0x00;
		#ifdef ANSEL1
			ansel1 = 0x00;
		#endif
	}
#endif


// ADC Type 15 Supported Devices ***********************************************************
// 18F1220, 18F1320
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_15
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon2 = Conv_Speed & 0x07;								//assign conversion rate

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					adcon1 = 0x7E;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					adcon1 = 0x7D;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					adcon1 = 0x7B;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					adcon1 = 0x77;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x01;
					tris_reg = &trisb;
					adcon1 = 0x6F;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x02;
					tris_reg = &trisb;
					adcon1 = 0x5F;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x10;
					tris_reg = &trisb;
					adcon1 = 0x3F;
					break;
			#endif
		}

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon0, VCFG0);

		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x02;									//begin conversion and wait until it has finished
		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		adcon1 = 0x7f;
		adcon0 = 0x00;
	}
#endif


// ADC Type 16 Supported Devices ***********************************************************
// 18F242, 18F2439, 18F248, 18F252, 18F2539, 18F258, 18F442, 18F4439, 18F448, 18F452,
// 18F4539, 18F458
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_16
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					if (Vref != 0)
						adcon1 = 0x05;
					else
						adcon1 = 0x0E;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					if (Vref != 0)
						adcon1 = 0x05;
					else
						adcon1 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					if (Vref != 0)
						adcon1 = 0x03;
					else
						adcon1 = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					adcon1 = 0x04;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					if (Vref != 0)
						adcon1 = 0x03;
					else
						adcon1 = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x01;
					tris_reg = &trise;
					if (Vref != 0)
						adcon1 = 0x0A;
					else
						adcon1 = 0x09;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trise;
					if (Vref != 0)
						adcon1 = 0x01;
					else
						adcon1 = 0x00;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trise;
					if (Vref != 0)
						adcon1 = 0x01;
					else
						adcon1 = 0x00;
					break;
			#endif
		}

		if (Conv_Speed > 3)										//assign conversion speed
			st_bit(adcon1, ADCS2);

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Conv_Speed << 6)) | (Channel << 3);	//turn ADC on
		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x04;									//begin conversion and wait until it has finished
		while (adcon0 & 0x04);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		adcon1 = 0x07;
		adcon0 = 0x00;
	}
#endif


// ADC Type 17 Supported Devices ***********************************************************
// 18F1230, 18F1330
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_17
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon2 = Conv_Speed & 0x07;
		adcon1 = 0x00 | (0x01 << Channel);

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x10;
					tris_reg = &trisa;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x40;
					tris_reg = &trisa;
					break;
			#endif
		}

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon1, VCFG0);

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on
		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x02;									//begin conversion and wait until it has finished
		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		adcon1 = 0x00;
		adcon0 = 0x00;
	}
#endif


// ADC Type 18 Supported Devices ***********************************************************
// 16F722, 16F723, 16F724, 16F726, 16F727, 16F1933, 16F1934, 16F1936, 16F1937, 16F1939
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_18

	#ifndef ADREF1
		#define ADREF1 ADPREF1
	#endif

	MX_UINT8 * ansel_reg;					//ANSEL register pointer

	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon1 = (Conv_Speed & 0x07) << 4;						//assign conversion rate

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					ansel_reg = &ansela;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x01;
					tris_reg = &trise;
					ansel_reg = &ansele;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trise;
					ansel_reg = &ansele;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trise;
					ansel_reg = &ansele;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x04;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x08;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x02;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x10;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_12
				case (12):
					tris_mask = 0x01;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_13
				case (13):
					tris_mask = 0x20;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
		}

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon1, ADREF1);

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		*ansel_reg = *ansel_reg | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on
		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x02;									//begin conversion and wait until it has finished
		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		*ansel_reg = 0x00;
		adcon0 = 0x00;
	}
#endif


// ADC Type 19 Supported Devices ***********************************************************
// 18F13K50, 18F14K50, 18LF13K50, 18LF14K50
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_19
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon1 = 0;

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					ansel = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					ansel = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					ansel = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x10;
					tris_reg = &trisa;
					ansel = 0x08;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x01;
					tris_reg = &trisc;
					ansel = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x02;
					tris_reg = &trisc;
					ansel = 0x20;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x04;
					tris_reg = &trisc;
					ansel = 0x40;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x08;
					tris_reg = &trisc;
					adcon1 = 0x80;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x40;
					tris_reg = &trisc;
					anselh = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x80;
					tris_reg = &trisc;
					anselh = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x10;
					tris_reg = &trisb;
					anselh = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x20;
					tris_reg = &trisb;
					anselh = 0x08;
					break;
			#endif
		}

		adcon2 = Conv_Speed & 0x07;								//assign conversion rate

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon1, PVCFG0);

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on
		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x02;									//begin conversion and wait until it has finished
		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		ansel = 0;
		adcon0 = 0x00;
		#ifdef ANSELH
			anselh = 0;
		#endif
	}
#endif


// ADC Type 20 Supported Devices ***********************************************************
// 18F23K20, 18F24K20, 18F25K20, 18F26K20, 18F43K20, 18F44K20, 18F45K20, 18F16K20
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_20
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon1 = 0;

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ansel = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ansel = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ansel = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					ansel = 0x08;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					ansel = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x01;
					tris_reg = &trise;
					ansel = 0x20;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trise;
					ansel = 0x40;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trise;
					adcon1 = 0x80;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x04;
					tris_reg = &trisb;
					anselh = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x08;
					tris_reg = &trisb;
					anselh = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x02;
					tris_reg = &trisb;
					anselh = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x10;
					tris_reg = &trisb;
					anselh = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_12
				case (12):
					tris_mask = 0x01;
					tris_reg = &trisb;
					anselh = 0x10;
					break;
			#endif
		}

		adcon2 = Conv_Speed & 0x07;								//assign conversion rate

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon1, VCFG0);

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on
		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x02;									//begin conversion and wait until it has finished
		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		ansel = 0;
		adcon0 = 0x00;
		#ifdef ANSELH
			anselh = 0;
		#endif
	}
#endif


// ADC Type 21 Supported Devices ***********************************************************
// 18F2xJ11, 18F4xJ11
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_21
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon1 = 0;

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ancon0 = 0xFE;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ancon0 = 0xFD;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ancon0 = 0xFB;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					ancon0 = 0xF7;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					ancon0 = 0xEF;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x01;
					tris_reg = &trise;
					ancon0 = 0xDF;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trise;
					ancon0 = 0xBF;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trise;
					ancon0 = 0x7F;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x04;
					tris_reg = &trisb;
					ancon1 = 0x1E;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x08;
					tris_reg = &trisb;
					ancon1 = 0x1D;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x02;
					tris_reg = &trisb;
					ancon1 = 0x1B;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x10;
					tris_reg = &trisb;
					ancon1 = 0x17;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_12
				case (12):
					tris_mask = 0x01;
					tris_reg = &trisb;
					ancon1 = 0x0F;
					break;
			#endif
		}

		adcon1 = Conv_Speed & 0x07;								//assign conversion rate

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon0, VCFG0);

		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x02;									//begin conversion and wait until it has finished
		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		ancon0 = 0xFF;
		ancon1 = 0x1F;
		adcon0 = 0x00;
	}
#endif


// ADC Type 22 Supported Devices ***********************************************************
// 10F220, 10F222
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_22
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon0 = 0x00;

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					asm("movf 1,w");
					asm("tris 6");
					adcon0 = 0x40;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					asm("movf 2,w");
					asm("tris 6");
					adcon0 = 0x84;
					break;
			#endif
		}

		adcon0 = adcon0 | 0x01;									//turn ADC on
		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x02;									//begin conversion and wait until it has finished
		while (adcon0 & 0x02);
		if (Sample_Mode)
			iRetVal = (adres << 2);								//10-bit ADC
		else
			iRetVal = adres;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		adcon0 = 0x00;											//Reset ADC Registers
	}
#endif


// ADC Type 23 Supported Devices ***********************************************************
// 16F1826, 16F1827
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_23

	MX_UINT8 * ansel_reg;					//ANSEL register pointer

	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon1 = (Conv_Speed & 0x07) << 4;						//assign conversion rate

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					ansel_reg = &ansela;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x10;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x40;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x80;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x20;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x10;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x08;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x04;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x02;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
		}

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon1, ADPREF1);

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		*ansel_reg = *ansel_reg | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on
		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x02;									//begin conversion and wait until it has finished
		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		*ansel_reg = 0x00;
		adcon0 = 0x00;
	}
#endif


// ADC Type 24 Supported Devices ***********************************************************
// 18F65J50, 18F66J50, 18F66J55, 18F67J50, 18F85J50, 18F86J50, 18F86J55, 18F87J50
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_24
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon1 = (Conv_Speed & 0x07);

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ancon0 = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ancon0 = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ancon0 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					ancon0 = 0x08;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					ancon0 = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trisf;
					ancon0 = 0x80;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x20;
					tris_reg = &trisf;
					ancon1 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x40;
					tris_reg = &trisf;
					ancon1 = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_12
				case (12):
					tris_mask = 0x10;
					tris_reg = &trish;
					ancon1 = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_13
				case (13):
					tris_mask = 0x20;
					tris_reg = &trish;
					ancon1 = 0x20;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_14
				case (14):
					tris_mask = 0x40;
					tris_reg = &trish;
					ancon1 = 0x40;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_15
				case (15):
					tris_mask = 0x80;
					tris_reg = &trish;
					ancon1 = 0x80;
					break;
			#endif
		}

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon0, VCFG0);

		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x02;									//begin conversion and wait until it has finished
		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		ancon0 = 0x00;
		ancon1 = 0x00;
		adcon0 = 0x00;
	}
#endif


// ADC Type 25 Supported Devices ***********************************************************
// 18F66J93, 18F67J93, 18F86J93, 18F87J93, 18F66J90, 18F67J90, 18F86J90, 18F87J90
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_25
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon2 = Conv_Speed & 0x07;

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					adcon1 = 0x0E;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					adcon1 = 0x0D;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					adcon1 = 0x0C;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					adcon1 = 0x0B;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					adcon1 = 0x0A;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x80;
					tris_reg = &trisf;
					adcon1 = 0x09;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trisf;
					adcon1 = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trisf;
					adcon1 = 0x07;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x08;
					tris_reg = &trisf;
					adcon1 = 0x06;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x10;
					tris_reg = &trisf;
					adcon1 = 0x05;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x20;
					tris_reg = &trisf;
					adcon1 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x40;
					tris_reg = &trisf;
					adcon1 = 0x03;
					break;
			#endif
		}

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon1, VCFG0);

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on

		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x02;									//begin conversion and wait until it has finished
		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		adcon1 = 0x0f;
		adcon0 = 0x00;
	}
#endif


// ADC Type 26 Supported Devices ***********************************************************
// 16F1822, 16F1823, 16F1824, 16F1825, 16F1828, 16F1829
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_26

	MX_UINT8 * ansel_reg;					//ANSEL register pointer

	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon1 = (Conv_Speed & 0x07) << 4;						//assign conversion rate

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x10;
					tris_reg = &trisa;
					ansel_reg = &ansela;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x01;
					tris_reg = &trisc;
					ansel_reg = &anselc;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x02;
					tris_reg = &trisc;
					ansel_reg = &anselc;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x04;
					tris_reg = &trisc;
					ansel_reg = &anselc;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x08;
					tris_reg = &trisc;
					ansel_reg = &anselc;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x40;
					tris_reg = &trisc;
					ansel_reg = &anselc;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x80;
					tris_reg = &trisc;
					ansel_reg = &anselc;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x10;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x20;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
		}

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon1, ADPREF1);

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		*ansel_reg = *ansel_reg | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on
		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x02;									//begin conversion and wait until it has finished
		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		*ansel_reg = 0x00;
		adcon0 = 0x00;
	}
#endif


// ADC Type 27 Supported Devices ***********************************************************
// 16F1946, 16F1947
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_27

	MX_UINT8 * ansel_reg;					//ANSEL register pointer

	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon1 = (Conv_Speed & 0x07) << 4;						//assign conversion rate

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					ansel_reg = &ansela;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x80;
					tris_reg = &trisf;
					ansel_reg = &anself;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trisf;
					ansel_reg = &anself;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trisf;
					ansel_reg = &anself;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x08;
					tris_reg = &trisf;
					ansel_reg = &anself;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x10;
					tris_reg = &trisf;
					ansel_reg = &anself;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x20;
					tris_reg = &trisf;
					ansel_reg = &anself;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x40;
					tris_reg = &trisf;
					ansel_reg = &anself;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_12
				case (11):
					tris_mask = 0x10;
					tris_reg = &trisg;
					ansel_reg = &anselg;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_13
				case (11):
					tris_mask = 0x08;
					tris_reg = &trisg;
					ansel_reg = &anselg;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_14
				case (11):
					tris_mask = 0x04;
					tris_reg = &trisg;
					ansel_reg = &anselg;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_15
				case (11):
					tris_mask = 0x02;
					tris_reg = &trisg;
					ansel_reg = &anselg;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_16
				case (11):
					tris_mask = 0x01;
					tris_reg = &trisg;
					ansel_reg = &anselg;
					break;
			#endif
		}

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon1, ADPREF1);

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		*ansel_reg = *ansel_reg | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on
		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x02;									//begin conversion and wait until it has finished
		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		*ansel_reg = 0x00;
		adcon0 = 0x00;
	}
#endif


// ADC Type 28 Supported Devices ***********************************************************
// 18F65K22, 18F66K22, 18F67K22, 18F85K22, 18F86K22, 18F87K22,
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_28
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon2 = Conv_Speed & 0x07;

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ancon0 = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ancon0 = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ancon0 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					ancon0 = 0x08;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					ancon0 = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x80;
					tris_reg = &trisf;
					ancon0 = 0x20;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trisf;
					ancon0 = 0x40;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trisf;
					ancon0 = 0x80;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x08;
					tris_reg = &trisf;
					ancon1 = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x10;
					tris_reg = &trisf;
					ancon1 = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x20;
					tris_reg = &trisf;
					ancon1 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x40;
					tris_reg = &trisf;
					ancon1 = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_12
				case (12):
					tris_mask = 0x10;
					tris_reg = &trish;
					ancon1 = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_13
				case (13):
					tris_mask = 0x20;
					tris_reg = &trish;
					ancon1 = 0x20;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_14
				case (14):
					tris_mask = 0x40;
					tris_reg = &trish;
					ancon1 = 0x40;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_15
				case (15):
					tris_mask = 0x80;
					tris_reg = &trish;
					ancon1 = 0x80;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_16
				case (16):
					tris_mask = 0x10;
					tris_reg = &trisg;
					ancon2 = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_17
				case (17):
					tris_mask = 0x08;
					tris_reg = &trisg;
					ancon2 = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_18
				case (18):
					tris_mask = 0x04;
					tris_reg = &trisg;
					ancon2 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_19
				case (19):
					tris_mask = 0x02;
					tris_reg = &trisg;
					ancon2 = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_20
				case (20):
					tris_mask = 0x08;
					tris_reg = &trish;
					ancon2 = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_21
				case (21):
					tris_mask = 0x04;
					tris_reg = &trish;
					ancon2 = 0x20;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_22
				case (22):
					tris_mask = 0x02;
					tris_reg = &trish;
					ancon2 = 0x40;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_23
				case (23):
					tris_mask = 0x01;
					tris_reg = &trish;
					ancon2 = 0x80;
					break;
			#endif
		}

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon1, VCFG0);

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on

		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x02;									//begin conversion and wait until it has finished
		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 4);							//12-bit ADC
			iRetVal = iRetVal | (adresl >> 4);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		adcon0 = 0x00;
		ancon0 = 0x00;
		#ifdef ANCON1
			ancon1 = 0x00;
		#endif
		#ifdef ANCON2
			ancon2 = 0x00;
		#endif
	}
#endif


// ADC Type 29 Supported Devices ***********************************************************
// 18F23K22, 18F24K22, 18F25K22, 18F26K22, 18F43K22, 18F44K22, 18F45K22, 18F46K22,
// 18LF23K22, 18LF24K22, 18LF25K22, 18LF26K22, 18LF43K22, 18LF44K22, 18LF45K22, 18LF46K22,
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_29

	MX_UINT8 * ansel_reg;					//ANSEL register pointer

	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon2 = Conv_Speed & 0x07;

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					ansel_reg = &ansela;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x01;
					tris_reg = &trise;
					ansel_reg = &ansele;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trise;
					ansel_reg = &ansele;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trise;
					ansel_reg = &ansele;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x04;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x08;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x02;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x10;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_12
				case (12):
					tris_mask = 0x01;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_13
				case (13):
					tris_mask = 0x20;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_14
				case (14):
					tris_mask = 0x04;
					tris_reg = &trisc;
					ansel_reg = &anselc;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_15
				case (15):
					tris_mask = 0x08;
					tris_reg = &trisc;
					ansel_reg = &anselc;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_16
				case (16):
					tris_mask = 0x10;
					tris_reg = &trisc;
					ansel_reg = &anselc;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_17
				case (17):
					tris_mask = 0x20;
					tris_reg = &trisc;
					ansel_reg = &anselc;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_18
				case (18):
					tris_mask = 0x40;
					tris_reg = &trisc;
					ansel_reg = &anselc;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_19
				case (19):
					tris_mask = 0x80;
					tris_reg = &trisc;
					ansel_reg = &anselc;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_20
				case (20):
					tris_mask = 0x01;
					tris_reg = &trisd;
					ansel_reg = &anseld;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_21
				case (21):
					tris_mask = 0x02;
					tris_reg = &trisd;
					ansel_reg = &anseld;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_22
				case (22):
					tris_mask = 0x04;
					tris_reg = &trisd;
					ansel_reg = &anseld;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_23
				case (23):
					tris_mask = 0x08;
					tris_reg = &trisd;
					ansel_reg = &anseld;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_24
				case (24):
					tris_mask = 0x10;
					tris_reg = &trisd;
					ansel_reg = &anseld;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_25
				case (25):
					tris_mask = 0x20;
					tris_reg = &trisd;
					ansel_reg = &anseld;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_26
				case (26):
					tris_mask = 0x40;
					tris_reg = &trisd;
					ansel_reg = &anseld;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_27
				case (27):
					tris_mask = 0x80;
					tris_reg = &trisd;
					ansel_reg = &anseld;
					break;
			#endif
		}

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon1, PVCFG0);

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		*ansel_reg = ansel_reg | tris_mask;

		adcon0 = (0x01 | (Channel << 2));						//turn ADC on

		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x02;									//begin conversion and wait until it has finished
		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		*ansel_reg = 0x00;
		adcon0 = 0x00;
	}
#endif


// ADC Type 30 Supported Devices ************************************************************
// 16F870, 16F871, 16F872, 16F873, 16F874, 16F876, 16F877
// *******************************************************************************************/

#ifdef MX_ADC_TYPE_30
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					if (Vref == 0)
						adcon1 = 0x0E;
					else
						adcon1 = 0x05;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					if (Vref == 0)
						adcon1 = 0x04;
					else
						adcon1 = 0x05;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					if (Vref == 0)
						adcon1 = 0x02;
					else
						adcon1 = 0x03;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					if (Vref == 0)
						adcon1 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					if (Vref == 0)
						adcon1 = 0x02;
					else
						adcon1 = 0x03;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x01;
					tris_reg = &trise;
					if (Vref == 0)
						adcon1 = 0x09;
					else
						adcon1 = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trise;
					if (Vref == 0)
						adcon1 = 0x00;
					else
						adcon1 = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trise;
					if (Vref == 0)
						adcon1 = 0x00;
					else
						adcon1 = 0x01;
					break;
			#endif
		}

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Conv_Speed << 6)) | (Channel << 3);	//turn ADC on
		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x04;									//begin conversion and wait until it has finished
		while (adcon0 & 0x04);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		adcon1 = 0x07;
		adcon0 = 0x00;
	}
#endif

/*********************************************************************
 *                  Flowcode CAL I2C File
 *
 * File: PIC_CAL_I2C.c
 *
 * (c) 2011 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * Company) for its Flowcode graphical programming language is
 * intended and supplied to you, the Companys customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 210911 | BR | Created
 * 021211 | BR | Converted to new dynamic defines mechanism
 *
 */


//When using hardware I2C channels override port and pin conns with FCD conn definitions
#ifdef MX_I2C_REF1
	#if MX_I2C_CHANNEL_1 > 0
		#undef MX_I2C_SDA_PIN_1
		#undef MX_I2C_SDA_PORT_1
		#undef MX_I2C_SDA_TRIS_1
		#undef MX_I2C_SCL_PIN_1
		#undef MX_I2C_SCL_PORT_1
		#undef MX_I2C_SCL_TRIS_1
	#endif
	#if MX_I2C_CHANNEL_1 == 1
		#define MX_I2C_SDA_PIN_1		MX_I2C_1_SDA_PIN
		#define MX_I2C_SDA_PORT_1		MX_I2C_1_SDA_PORT
		#define MX_I2C_SDA_TRIS_1		MX_I2C_1_SDA_TRIS
		#define MX_I2C_SCL_PIN_1		MX_I2C_1_SCL_PIN
		#define MX_I2C_SCL_PORT_1		MX_I2C_1_SCL_PORT
		#define MX_I2C_SCL_TRIS_1		MX_I2C_1_SCL_TRIS
	#endif
	#if MX_I2C_CHANNEL_1 == 2
		#define MX_I2C_SDA_PIN_1		MX_I2C_2_SDA_PIN
		#define MX_I2C_SDA_PORT_1		MX_I2C_2_SDA_PORT
		#define MX_I2C_SDA_TRIS_1		MX_I2C_2_SDA_TRIS
		#define MX_I2C_SCL_PIN_1		MX_I2C_2_SCL_PIN
		#define MX_I2C_SCL_PORT_1		MX_I2C_2_SCL_PORT
		#define MX_I2C_SCL_TRIS_1		MX_I2C_2_SCL_TRIS
	#endif
	#if MX_I2C_CHANNEL_1 == 3
		#define MX_I2C_SDA_PIN_1		MX_I2C_3_SDA_PIN
		#define MX_I2C_SDA_PORT_1		MX_I2C_3_SDA_PORT
		#define MX_I2C_SDA_TRIS_1		MX_I2C_3_SDA_TRIS
		#define MX_I2C_SCL_PIN_1		MX_I2C_3_SCL_PIN
		#define MX_I2C_SCL_PORT_1		MX_I2C_3_SCL_PORT
		#define MX_I2C_SCL_TRIS_1		MX_I2C_3_SCL_TRIS
	#endif
	#if MX_I2C_CHANNEL_1 == 4
		#define MX_I2C_SDA_PIN_1		MX_I2C_4_SDA_PIN
		#define MX_I2C_SDA_PORT_1		MX_I2C_4_SDA_PORT
		#define MX_I2C_SDA_TRIS_1		MX_I2C_4_SDA_TRIS
		#define MX_I2C_SCL_PIN_1		MX_I2C_4_SCL_PIN
		#define MX_I2C_SCL_PORT_1		MX_I2C_4_SCL_PORT
		#define MX_I2C_SCL_TRIS_1		MX_I2C_4_SCL_TRIS
	#endif
#endif
#ifdef MX_I2C_REF2
	#if MX_I2C_CHANNEL_2 > 0
		#undef MX_I2C_SDA_PIN_2
		#undef MX_I2C_SDA_PORT_2
		#undef MX_I2C_SDA_TRIS_2
		#undef MX_I2C_SCL_PIN_2
		#undef MX_I2C_SCL_PORT_2
		#undef MX_I2C_SCL_TRIS_2
	#endif
	#if MX_I2C_CHANNEL_2 == 1
		#define MX_I2C_SDA_PIN_2		MX_I2C_1_SDA_PIN
		#define MX_I2C_SDA_PORT_2		MX_I2C_1_SDA_PORT
		#define MX_I2C_SDA_TRIS_2		MX_I2C_1_SDA_TRIS
		#define MX_I2C_SCL_PIN_2		MX_I2C_1_SCL_PIN
		#define MX_I2C_SCL_PORT_2		MX_I2C_1_SCL_PORT
		#define MX_I2C_SCL_TRIS_2		MX_I2C_1_SCL_TRIS
	#endif
	#if MX_I2C_CHANNEL_2 == 2
		#define MX_I2C_SDA_PIN_2		MX_I2C_2_SDA_PIN
		#define MX_I2C_SDA_PORT_2		MX_I2C_2_SDA_PORT
		#define MX_I2C_SDA_TRIS_2		MX_I2C_2_SDA_TRIS
		#define MX_I2C_SCL_PIN_2		MX_I2C_2_SCL_PIN
		#define MX_I2C_SCL_PORT_2		MX_I2C_2_SCL_PORT
		#define MX_I2C_SCL_TRIS_2		MX_I2C_2_SCL_TRIS
	#endif
	#if MX_I2C_CHANNEL_2 == 3
		#define MX_I2C_SDA_PIN_2		MX_I2C_3_SDA_PIN
		#define MX_I2C_SDA_PORT_2		MX_I2C_3_SDA_PORT
		#define MX_I2C_SDA_TRIS_2		MX_I2C_3_SDA_TRIS
		#define MX_I2C_SCL_PIN_2		MX_I2C_3_SCL_PIN
		#define MX_I2C_SCL_PORT_2		MX_I2C_3_SCL_PORT
		#define MX_I2C_SCL_TRIS_2		MX_I2C_3_SCL_TRIS
	#endif
	#if MX_I2C_CHANNEL_2 == 4
		#define MX_I2C_SDA_PIN_2		MX_I2C_4_SDA_PIN
		#define MX_I2C_SDA_PORT_2		MX_I2C_4_SDA_PORT
		#define MX_I2C_SDA_TRIS_2		MX_I2C_4_SDA_TRIS
		#define MX_I2C_SCL_PIN_2		MX_I2C_4_SCL_PIN
		#define MX_I2C_SCL_PORT_2		MX_I2C_4_SCL_PORT
		#define MX_I2C_SCL_TRIS_2		MX_I2C_4_SCL_TRIS
	#endif
#endif
#ifdef MX_I2C_REF3
	#if MX_I2C_CHANNEL_3 > 0
		#undef MX_I2C_SDA_PIN_3
		#undef MX_I2C_SDA_PORT_3
		#undef MX_I2C_SDA_TRIS_3
		#undef MX_I2C_SCL_PIN_3
		#undef MX_I2C_SCL_PORT_3
		#undef MX_I2C_SCL_TRIS_3
	#endif
	#if MX_I2C_CHANNEL_3 == 1
		#define MX_I2C_SDA_PIN_3		MX_I2C_1_SDA_PIN
		#define MX_I2C_SDA_PORT_3		MX_I2C_1_SDA_PORT
		#define MX_I2C_SDA_TRIS_3		MX_I2C_1_SDA_TRIS
		#define MX_I2C_SCL_PIN_3		MX_I2C_1_SCL_PIN
		#define MX_I2C_SCL_PORT_3		MX_I2C_1_SCL_PORT
		#define MX_I2C_SCL_TRIS_3		MX_I2C_1_SCL_TRIS
	#endif
	#if MX_I2C_CHANNEL_3 == 2
		#define MX_I2C_SDA_PIN_3		MX_I2C_2_SDA_PIN
		#define MX_I2C_SDA_PORT_3		MX_I2C_2_SDA_PORT
		#define MX_I2C_SDA_TRIS_3		MX_I2C_2_SDA_TRIS
		#define MX_I2C_SCL_PIN_3		MX_I2C_2_SCL_PIN
		#define MX_I2C_SCL_PORT_3		MX_I2C_2_SCL_PORT
		#define MX_I2C_SCL_TRIS_3		MX_I2C_2_SCL_TRIS
	#endif
	#if MX_I2C_CHANNEL_3 == 3
		#define MX_I2C_SDA_PIN_3		MX_I2C_3_SDA_PIN
		#define MX_I2C_SDA_PORT_3		MX_I2C_3_SDA_PORT
		#define MX_I2C_SDA_TRIS_3		MX_I2C_3_SDA_TRIS
		#define MX_I2C_SCL_PIN_3		MX_I2C_3_SCL_PIN
		#define MX_I2C_SCL_PORT_3		MX_I2C_3_SCL_PORT
		#define MX_I2C_SCL_TRIS_3		MX_I2C_3_SCL_TRIS
	#endif
	#if MX_I2C_CHANNEL_3 == 4
		#define MX_I2C_SDA_PIN_3		MX_I2C_4_SDA_PIN
		#define MX_I2C_SDA_PORT_3		MX_I2C_4_SDA_PORT
		#define MX_I2C_SDA_TRIS_3		MX_I2C_4_SDA_TRIS
		#define MX_I2C_SCL_PIN_3		MX_I2C_4_SCL_PIN
		#define MX_I2C_SCL_PORT_3		MX_I2C_4_SCL_PORT
		#define MX_I2C_SCL_TRIS_3		MX_I2C_4_SCL_TRIS
	#endif
#endif
#ifdef MX_I2C_REF4
	#if MX_I2C_CHANNEL_4 > 0
		#undef MX_I2C_SDA_PIN_4
		#undef MX_I2C_SDA_PORT_4
		#undef MX_I2C_SDA_TRIS_4
		#undef MX_I2C_SCL_PIN_4
		#undef MX_I2C_SCL_PORT_4
		#undef MX_I2C_SCL_TRIS_4
	#endif
	#if MX_I2C_CHANNEL_4 == 1
		#define MX_I2C_SDA_PIN_4		MX_I2C_1_SDA_PIN
		#define MX_I2C_SDA_PORT_4		MX_I2C_1_SDA_PORT
		#define MX_I2C_SDA_TRIS_4		MX_I2C_1_SDA_TRIS
		#define MX_I2C_SCL_PIN_4		MX_I2C_1_SCL_PIN
		#define MX_I2C_SCL_PORT_4		MX_I2C_1_SCL_PORT
		#define MX_I2C_SCL_TRIS_4		MX_I2C_1_SCL_TRIS
	#endif
	#if MX_I2C_CHANNEL_4 == 2
		#define MX_I2C_SDA_PIN_4		MX_I2C_2_SDA_PIN
		#define MX_I2C_SDA_PORT_4		MX_I2C_2_SDA_PORT
		#define MX_I2C_SDA_TRIS_4		MX_I2C_2_SDA_TRIS
		#define MX_I2C_SCL_PIN_4		MX_I2C_2_SCL_PIN
		#define MX_I2C_SCL_PORT_4		MX_I2C_2_SCL_PORT
		#define MX_I2C_SCL_TRIS_4		MX_I2C_2_SCL_TRIS
	#endif
	#if MX_I2C_CHANNEL_4 == 3
		#define MX_I2C_SDA_PIN_4		MX_I2C_3_SDA_PIN
		#define MX_I2C_SDA_PORT_4		MX_I2C_3_SDA_PORT
		#define MX_I2C_SDA_TRIS_4		MX_I2C_3_SDA_TRIS
		#define MX_I2C_SCL_PIN_4		MX_I2C_3_SCL_PIN
		#define MX_I2C_SCL_PORT_4		MX_I2C_3_SCL_PORT
		#define MX_I2C_SCL_TRIS_4		MX_I2C_3_SCL_TRIS
	#endif
	#if MX_I2C_CHANNEL_4 == 4
		#define MX_I2C_SDA_PIN_4		MX_I2C_4_SDA_PIN
		#define MX_I2C_SDA_PORT_4		MX_I2C_4_SDA_PORT
		#define MX_I2C_SDA_TRIS_4		MX_I2C_4_SDA_TRIS
		#define MX_I2C_SCL_PIN_4		MX_I2C_4_SCL_PIN
		#define MX_I2C_SCL_PORT_4		MX_I2C_4_SCL_PORT
		#define MX_I2C_SCL_TRIS_4		MX_I2C_4_SCL_TRIS
	#endif
#endif

#define MX_I2C_CHANNEL_X		CAL_APPEND(MX_I2C_CHANNEL_, MX_I2C_NUM)
#define MX_I2C_SDA_PIN_X		CAL_APPEND(MX_I2C_SDA_PIN_, MX_I2C_NUM)
#define MX_I2C_SDA_PORT_X		CAL_APPEND(MX_I2C_SDA_PORT_, MX_I2C_NUM)
#define MX_I2C_SDA_TRIS_X		CAL_APPEND(MX_I2C_SDA_TRIS_, MX_I2C_NUM)
#define MX_I2C_SCL_PIN_X		CAL_APPEND(MX_I2C_SCL_PIN_, MX_I2C_NUM)
#define MX_I2C_SCL_PORT_X		CAL_APPEND(MX_I2C_SCL_PORT_, MX_I2C_NUM)
#define MX_I2C_SCL_TRIS_X		CAL_APPEND(MX_I2C_SCL_TRIS_, MX_I2C_NUM)
#define MX_I2C_BMODE_X			CAL_APPEND(MX_I2C_BMODE_, MX_I2C_NUM)
#define MX_I2C_BAUD_X			CAL_APPEND(MX_I2C_BAUD_, MX_I2C_NUM)
#define MX_I2C_INT_X			CAL_APPEND(MX_I2C_INT_, MX_I2C_NUM)


//Function Prototypes
CALFUNCTION(void, FC_CAL_I2C_Master_Init_, (void));
CALFUNCTION(void, FC_CAL_I2C_Master_Uninit_, (void));
CALFUNCTION(void, FC_CAL_I2C_Master_Start_, (void));
CALFUNCTION(void, FC_CAL_I2C_Master_Restart_, (void));
CALFUNCTION(void, FC_CAL_I2C_Master_Stop_, (void));
CALFUNCTION(MX_UINT8, FC_CAL_I2C_Master_TX_Byte_, (MX_UINT8 Data));
CALFUNCTION(MX_UINT8, FC_CAL_I2C_Master_RX_Byte_, (MX_UINT8 Last));

CALFUNCTION(void, FC_CAL_I2C_Slave_Init_, (void));
CALFUNCTION(void, FC_CAL_I2C_Slave_Uninit_, (void));
CALFUNCTION(void, FC_CAL_I2C_Slave_SetTxData_, (MX_UINT8 Data));
CALFUNCTION(MX_UINT8, FC_CAL_I2C_Slave_GetRxData_, (MX_UINT8 Last));


//Ensure SSPCON register is defined correctly
#ifndef SSPCON
  #ifdef SSPCON1
	#define sspcon	sspcon1
  #else
	#ifdef SSP1CON1
		#define sspcon	ssp1con1
	#endif
  #endif
#endif

//Ensure SSPIF register is defined correctly
#ifndef SSPIF
  #ifdef SSP1IF
	#define SSPIF	SSP1IF
  #else
	#error "I2C does not have the SSPIF defined on this chip - does your chip support this feature?"
  #endif
#endif


//Ensure SSPCON2 register is defined correctly
#ifndef SSPCON2
  #ifdef SSP1CON2
	#define sspcon2	ssp1con2
  #endif
#endif


//Ensure SSPSTAT register is defined correctly
#ifndef SSPSTAT
  #ifdef SSP1STAT
	#define sspstat	ssp1stat
  #endif
#endif


//Ensure SSPADD register is defined correctly
#ifndef SSPADD
  #ifdef SSP1ADD
	#define sspadd	ssp1add
  #endif
#endif


//Ensure SSPBUFF register is defined correctly
#ifndef SSPBUFF
  #ifdef SSP1BUFF
	#define sspbuff	ssp1buff
  #endif
#endif


//If software channel is enabled then define bit delay.
#if (MX_I2C_CHANNEL_X == 0)
  #ifndef MX_I2C_SW_DEL
	#define MX_I2C_SW_DEL
	#define MX_I2C_DELAY	delay_us(20);
  #endif
#endif


CALFUNCTION(void, FC_CAL_I2C_Master_Init_, (void))

{

	#if (MX_I2C_CHANNEL_X == 0)															//Use Master I2C Software
		FC_CAL_Bit_In_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);		//Configure SDA as Input
		FC_CAL_Bit_In_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);		//Configure SCL as Input
	#endif

	#if (MX_I2C_CHANNEL_X == 1)												//Use Master I2C Hardware 1
		#ifndef MX_MI2C
			#error "This chip does not have Master I2C capability"
		#else

			#ifndef MX_I2C_1
				#error "This chip does not have Master I2C channel 1"
			#endif

			#if (MX_I2C_BMODE_X & 0x01)
				cr_bit (sspstat,SMP);										//Slew Rate Control Enabled
			#else
				st_bit (sspstat,SMP);										//Slew Rate Control Disabled
0389  1683  	BSF STATUS, RP0
038A  1303  	BCF STATUS, RP1
038B  1794  	BSF gbl_sspstat,7

		    #endif

			#if (MX_I2C_BMODE_X & 0x02)
				st_bit (sspstat,CKE);										//Enable SMBus specific inputs
			#else
				cr_bit (sspstat,CKE);										//Disable SMBus specific inputs
038C  1314  	BCF gbl_sspstat,6

			#endif

			sspcon = 0x28;													//Setup I2C into Master Mode
038D  3028  	MOVLW 0x28
038E  1283  	BCF STATUS, RP0
038F  0094  	MOVWF gbl_sspcon

			sspadd = MX_I2C_BAUD_X;											//Set the Baud Rate
0390  30A0  	MOVLW 0xA0
0391  1683  	BSF STATUS, RP0
0392  0093  	MOVWF gbl_sspadd

			sspcon2 = 0x00;													//Clear the control bits
0393  0191  	CLRF gbl_sspcon2

			st_bit(intcon, GIE);
0394  178B  	BSF gbl_intcon,7

			FC_CAL_Bit_In_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);		//Configure SDA as Input
0395  1607  	BSF gbl_trisc,4

			FC_CAL_Bit_In_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);		//Configure SCL as Input
0396  1587  	BSF gbl_trisc,3

		#endif
	#endif

	#if (MX_I2C_CHANNEL_X == 2)												//Use Master I2C Hardware 2
		#ifndef MX_MI2C
			#error "This chip does not have Master I2C capability"
		#else

			#ifndef MX_I2C_2
				#error "This chip does not have Master I2C channel 2"
			#endif

		  #ifdef MX_I2C_2_REMAPPABLE
			RPOR4 = 9;														//SDA2 - RB1 - RP4
			RPOR5 = 10;														//SCL2 - RB2 - RP5
		  #endif

			#if (MX_I2C_BMODE_X & 0x01)
				cr_bit (ssp2stat,SMP);										//Slew Rate Control Enabled
			#else
				st_bit (ssp2stat,SMP);										//Slew Rate Control Disabled
			#endif

			#if (MX_I2C_BMODE_X & 0x02)
				st_bit (ssp2stat,CKE);										//Enable SMBus specific inputs
			#else
				cr_bit (ssp2stat,CKE);										//Disable SMBus specific inputs
			#endif

			ssp2con = 0x28;													//Setup I2C into Master Mode
			ssp2add = MX_I2C_BAUD_X;										//Set the Baud Rate
			ssp2con2 = 0x00;												//Clear the control bits
			st_bit(intcon, GIE);
			FC_CAL_Bit_In_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);			//Configure SDA as Input
			FC_CAL_Bit_In_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);			//Configure SCL as Input
		#endif
	#endif
}
0397  0008  	RETURN


CALFUNCTION(void, FC_CAL_I2C_Master_Uninit_, (void))
{
	#if (MX_I2C_CHANNEL_X == 0)																//Use Master I2C Software
		FC_CAL_Bit_In_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);			//Configure SDA as Input
		FC_CAL_Bit_In_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);			//Configure SCL as Input
	#endif

	#if (MX_I2C_CHANNEL_X == 1)												//Use Master I2C Hardware 1
		cr_bit(sspcon, SSPEN);												//Disable SSP
	#endif

	#if (MX_I2C_CHANNEL_X == 2)												//Use Master I2C Hardware 2
		cr_bit(ssp2con, SSPEN);												//Disable SSP
	#endif
}

CALFUNCTION(void, FC_CAL_I2C_Master_Start_, (void))

{
	#if (MX_I2C_CHANNEL_X == 0)															//Use Master I2C Software
		FC_CAL_Bit_In_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);		//Make Sure SCL is Set
		FC_CAL_Bit_In_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);		//Make Sure SDA is Set
		MX_I2C_DELAY;																	//Small Delay
		FC_CAL_Bit_Low_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);		//Clear SDA
		MX_I2C_DELAY;																	//Small Delay
		FC_CAL_Bit_Low_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);		//Clear SCL
		MX_I2C_DELAY;																	//Small Delay
	#endif

	#if (MX_I2C_CHANNEL_X == 1)												//Use Master I2C Hardware 1
		cr_bit(pir1, SSPIF);												//Clear SSP interrupt flag
02DB  1283  	BCF STATUS, RP0
02DC  1303  	BCF STATUS, RP1
02DD  118C  	BCF gbl_pir1,3

		st_bit(sspcon2,SEN);												//Initiate start condition
02DE  1683  	BSF STATUS, RP0
02DF  1411  	BSF gbl_sspcon2,0

		while(ts_bit(sspcon2,SEN));											//Wait for start bit to be generated
02E0        label37
02E0  1811  	BTFSC gbl_sspcon2,0
02E1  2AE0  	GOTO	label37

	#endif

	#if (MX_I2C_CHANNEL_X == 2)												//Use Master I2C Hardware 2
		cr_bit(pir3, SSP2IF);												//Clear SSP interrupt flag
		st_bit(ssp2con2,SEN);												//Initiate start condition
		while(ts_bit(ssp2con2,SEN));										//Wait for start bit to be generated
	#endif
}
02E2  0008  	RETURN


CALFUNCTION(void, FC_CAL_I2C_Master_Restart_, (void))

{
	#if (MX_I2C_CHANNEL_X == 0)															//Use Master I2C Software
		FC_CAL_Bit_In_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);		//Set SDA High
		MX_I2C_DELAY;
		FC_CAL_Bit_In_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);		//Set SCL High
		MX_I2C_DELAY;
		FC_CAL_Bit_Low_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);		//Set SDA Low
		MX_I2C_DELAY;
		FC_CAL_Bit_Low_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);		//Set SCL Low
		MX_I2C_DELAY;
	#endif

	#if (MX_I2C_CHANNEL_X == 1)												//Use Master I2C Hardware 1
		cr_bit(pir1, SSPIF);												//Clear SSP interrupt flag
02D3  1283  	BCF STATUS, RP0
02D4  1303  	BCF STATUS, RP1
02D5  118C  	BCF gbl_pir1,3

		st_bit(sspcon2,RSEN);												//Initiate restart condition
02D6  1683  	BSF STATUS, RP0
02D7  1491  	BSF gbl_sspcon2,1

		while(ts_bit(sspcon2,RSEN));										//Wait for restart bit to be generated
02D8        label36
02D8  1891  	BTFSC gbl_sspcon2,1
02D9  2AD8  	GOTO	label36

	#endif

	#if (MX_I2C_CHANNEL_X == 2)												//Use Master I2C Hardware 2
		cr_bit(pir3, SSP2IF);												//Clear SSP interrupt flag
		st_bit(ssp2con2,RSEN);												//Initiate restart condition
		while(ts_bit(ssp2con2,RSEN));										//Wait for restart bit to be generated
	#endif
}
02DA  0008  	RETURN


CALFUNCTION(void, FC_CAL_I2C_Master_Stop_, (void))

{
	#if (MX_I2C_CHANNEL_X == 0)															//Use Master I2C Software
		FC_CAL_Bit_Low_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);		//Set SCL Low
		FC_CAL_Bit_Low_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);		//Set SDA Low
		MX_I2C_DELAY;
		FC_CAL_Bit_In_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);		//Set SCL High
		MX_I2C_DELAY;
		FC_CAL_Bit_In_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);		//Set SDA High
	#endif

	#if (MX_I2C_CHANNEL_X == 1)												//Use Master I2C Hardware 1
		cr_bit(pir1,SSPIF);													//Clear SSP interrupt flag
02C8  1283  	BCF STATUS, RP0
02C9  1303  	BCF STATUS, RP1
02CA  118C  	BCF gbl_pir1,3

		st_bit(sspcon2,PEN);												//Initiate stop condition
02CB  1683  	BSF STATUS, RP0
02CC  1511  	BSF gbl_sspcon2,2

		while(ts_bit(sspcon2,PEN));											//Wait for stop bit to be generated
02CD        label35
02CD  1911  	BTFSC gbl_sspcon2,2
02CE  2ACD  	GOTO	label35

	#endif

	#if (MX_I2C_CHANNEL_X == 2)												//Use Master I2C Hardware 2
		cr_bit(pir3,SSP2IF);												//Clear SSP interrupt flag
		st_bit(ssp2con2,PEN);												//Initiate stop condition
		while(ts_bit(ssp2con2,PEN));										//Wait for stop bit to be generated
	#endif

  delay_ms(10);																//Wait before reusing the I2C BUS
02CF  300A  	MOVLW 0x0A
02D0  00A1  	MOVWF delay_ms_00000_arg_del
02D1  201A  	CALL delay_ms_00000

}
02D2  0008  	RETURN


CALFUNCTION(MX_UINT8, FC_CAL_I2C_Master_TX_Byte_, (MX_UINT8 Data))

{
	#if (MX_I2C_CHANNEL_X == 0)												//Use Master I2C Software
		char bit_mask;
		char local_ack = 0;
		for(bit_mask=0x80;bit_mask;bit_mask=bit_mask>>1)
		{
			if(Data & bit_mask)
			{
				FC_CAL_Bit_In_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);	//Set SDA High
			}
			else
			{
				FC_CAL_Bit_Low_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);	//Set SDA Low
			}
			MX_I2C_DELAY;
			FC_CAL_Bit_In_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);		//Set SCL High
			MX_I2C_DELAY;
			FC_CAL_Bit_Low_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);		//Set SCL Low
			MX_I2C_DELAY;
		}
		FC_CAL_Bit_In_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);			//Set SDA High
		MX_I2C_DELAY;
		FC_CAL_Bit_In_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);			//Set SCL High
		MX_I2C_DELAY;
		FC_CAL_Bit_In_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);
		if (FC_CAL_Bit_In(MX_I2C_SDA_PORT_X, MX_I2C_SDA_PIN_X))		//Get the Status Bit
			local_ack = 1;
		MX_I2C_DELAY;
		FC_CAL_Bit_Low_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);			//Set SCL Low
		MX_I2C_DELAY;
		return (local_ack);													//0 = Ack received : 1 = Ack not received
	#endif

	#if (MX_I2C_CHANNEL_X == 1)												//Use Master I2C Hardware 1
		cr_bit(pir1,SSPIF);													//Clear SSP interrupt flag
02B9  118C  	BCF gbl_pir1,3

		sspbuf=Data;														//Send byte
02BA  087C  	MOVF FC_CAL_I2C_00066_arg_Data, W
02BB  0093  	MOVWF gbl_sspbuf

		while(ts_bit(pir1,SSPIF) == 0);										//Wait for control bit to be sent
02BC        label33
02BC  1D8C  	BTFSS gbl_pir1,3
02BD  2ABC  	GOTO	label33

		if(ts_bit(sspcon2,ACKSTAT))											//Check Acknowledgement
02BE  1683  	BSF STATUS, RP0
02BF  1F11  	BTFSS gbl_sspcon2,6
02C0  2AC5  	GOTO	label34
02C5        label34

			return (1);														//No Acknowledgement
02C1  3001  	MOVLW 0x01
02C2  1283  	BCF STATUS, RP0
02C3  00FD  	MOVWF CompTempVarRet2270

		else return (0);													//Acknowledgement received
02C5  1283  	BCF STATUS, RP0
02C6  01FD  	CLRF CompTempVarRet2270

	#endif

	#if (MX_I2C_CHANNEL_X == 2)												//Use Master I2C Hardware 2
		cr_bit(pir3,SSP2IF);												//Clear SSP interrupt flag
		ssp2buf=Data;														//Send byte
		while(ts_bit(pir3,SSP2IF) == 0);									//Wait for control bit to be sent
		if(ts_bit(ssp2con2,ACKSTAT))										//Check Acknowledgement
			return (1);														//No Acknowledgement
		else return (0);													//Acknowledgement received
	#endif
}
02C4  0008  	RETURN
02C7  0008  	RETURN


CALFUNCTION(MX_UINT8, FC_CAL_I2C_Master_RX_Byte_, (MX_UINT8 Last))

{
	#if (MX_I2C_CHANNEL_X == 0)												//Use Master I2C Software
		char bit_mask;
		char Data = 0;
		char local_ack;
		FC_CAL_Bit_In_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);			//Set SDA High
		MX_I2C_DELAY;
		for(bit_mask=0x80;bit_mask;bit_mask=bit_mask>>1)
		{
			FC_CAL_Bit_In_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);		//Set SCL High
			MX_I2C_DELAY;
			FC_CAL_Bit_In_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);
			if(FC_CAL_Bit_In(MX_I2C_SDA_PORT_X, MX_I2C_SDA_PIN_X))	//Read Incoming Bit
				Data = Data | bit_mask;														//Add data to variable
			FC_CAL_Bit_Low_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);		//Set SCL Low
			MX_I2C_DELAY;
		}
		if (Last)																		//Acknowledge?
		{
			FC_CAL_Bit_In_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);	//Send Nack
		}
		else
		{
			FC_CAL_Bit_Low_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);	//Send Ack
		}
		MX_I2C_DELAY;
		FC_CAL_Bit_In_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);		//Set SCL High
		MX_I2C_DELAY;
		FC_CAL_Bit_Low_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);		//Set SCL Low
		MX_I2C_DELAY;
		return (Data);
	#endif

	#if (MX_I2C_CHANNEL_X == 1)						//Use Master I2C Hardware 1
		cr_bit(pir1,SSPIF);							//Clear SSP interrupt flag
02A4  118C  	BCF gbl_pir1,3

		st_bit(sspcon2,RCEN);						//Initiate Read
02A5  1683  	BSF STATUS, RP0
02A6  1591  	BSF gbl_sspcon2,3

		while(ts_bit(pir1,3) == 0);					//Wait for data read
02A7        label29
02A7  1283  	BCF STATUS, RP0
02A8  1D8C  	BTFSS gbl_pir1,3
02A9  2AA7  	GOTO	label29

		if (Last)
02AA  08FC  	MOVF FC_CAL_I2C_00067_arg_Last, F
02AB  1903  	BTFSC STATUS,Z
02AC  2AB0  	GOTO	label30
02B0        label30

			st_bit(sspcon2,ACKDT);					//Send Nack
02AD  1683  	BSF STATUS, RP0
02AE  1691  	BSF gbl_sspcon2,5

		else cr_bit(sspcon2,ACKDT);					//Send Ack
02AF  2AB2  	GOTO	label31
02B0  1683  	BSF STATUS, RP0
02B1  1291  	BCF gbl_sspcon2,5
02B2        label31

		st_bit(sspcon2,ACKEN);						//Initiate Nack
02B2  1611  	BSF gbl_sspcon2,4

		while(ts_bit(sspcon2,ACKEN));				//Wait for data read
02B3        label32
02B3  1A11  	BTFSC gbl_sspcon2,4
02B4  2AB3  	GOTO	label32

		return(sspbuf);								//Store incoming data
02B5  1283  	BCF STATUS, RP0
02B6  0813  	MOVF gbl_sspbuf, W
02B7  00FD  	MOVWF CompTempVarRet2271

	#endif

	#if (MX_I2C_CHANNEL_X == 2)						//Use Master I2C Hardware 2
		cr_bit(pir3,SSP2IF);						//Clear SSP interrupt flag
		st_bit(ssp2con2,RCEN);						//Initiate Read
		while(ts_bit(pir3,SSP2IF) == 0);			//Wait for data read
		if (Last)
			st_bit(ssp2con2,ACKDT);					//Send Nack
		else cr_bit(ssp2con2,ACKDT);				//Send Ack
		st_bit(ssp2con2,ACKEN);						//Initiate Nack
		while(ts_bit(ssp2con2,ACKEN));				//Wait for data read
		return(ssp2buf);							//Store incoming data
	#endif
}
02B8  0008  	RETURN





//Slave functions currently not implemented
CALFUNCTION(void, FC_CAL_I2C_Slave_Init_, (void))
{

}

CALFUNCTION(void, FC_CAL_I2C_Slave_Uninit_, (void))
{

}

CALFUNCTION(void, FC_CAL_I2C_Slave_SetTxData_, (MX_UINT8 Data))
{

}

CALFUNCTION(MX_UINT8, FC_CAL_I2C_Slave_GetRxData_, (MX_UINT8 Last))
{

}


/*********************************************************************
 *                  Flowcode CAL PWM File
 *
 * File: PIC_CAL_PWM.c
 *
 * (c) 2011 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * Company) for its Flowcode graphical programming language is
 * intended and supplied to you, the Companys customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 270911 | BR | Created
 * 021211 | BR | Converted to new dynamic defines mechanism
 *
 */


#define MX_PWM_CHANNEL_X		CAL_APPEND(MX_PWM_CHANNEL_, MX_PWM_NUM)
#define MX_PWM_HWALT_X			CAL_APPEND(MX_PWM_HWALT_, MX_PWM_NUM)


//I2C Master Functions
CALFUNCTION(void, FC_CAL_PWM_Enable_Channel_, (void));
CALFUNCTION(void, FC_CAL_PWM_Disable_Channel_, (void));
CALFUNCTION(void, FC_CAL_PWM_Set_Duty_8Bit_, (MX_UINT8 duty));
CALFUNCTION(void, FC_CAL_PWM_Change_Period_, (MX_UINT8 period, MX_UINT16 prescaler));
CALFUNCTION(void, FC_CAL_PWM_Set_Duty_10Bit_, (MX_UINT16 duty));


CALFUNCTION(void, FC_CAL_PWM_Enable_Channel_, (void))

{

 #ifdef MX_PWM

	#if (MX_PWM_CHANNEL_X == 1)
	  #ifdef MX_PWM_REMAPPABLE
	  	RPOR3 = 14;														//PWM1 - 14 - RB0 - RP3
	  #endif

		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
		  #ifndef MX_PWM_1_PORT											//Error checking
			#error "This chip does not have PWM channel 1 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_1_PORT, MX_PWM_1_TRIS, MX_PWM_1_PIN);			//PWM pin is an output
0381  1683  	BSF STATUS, RP0
0382  1303  	BCF STATUS, RP1
0383  1107  	BCF gbl_trisc,2
0384  1283  	BCF STATUS, RP0
0385  1107  	BCF gbl_portc,2

		#else															//Alternate PWM Pin
		  #ifndef MX_PWM_1_PORT_A										//Error checking
			#error "This chip does not have PWM alt channel 1 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_1_PORT_A, MX_PWM_1_TRIS_A, MX_PWM_1_PIN_A);		//PWM pin is an output
		#endif

		ccp1con = 0x0C;													//Enable Capture Compare Channel 1
0386  300C  	MOVLW 0x0C
0387  0097  	MOVWF gbl_ccp1con

	#endif

	#if (MX_PWM_CHANNEL_X == 2)
	  #ifdef MX_PWM_REMAPPABLE
	  	RPOR4 = 18;														//PWM2 - 18 - RB1 - RP4
	  #endif

		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
		  #ifndef MX_PWM_2_PORT											//Error checking
			#error "This chip does not have PWM channel 2 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_2_PORT, MX_PWM_2_TRIS, MX_PWM_2_PIN);			//PWM pin is an output
		#else															//Alternate PWM Pin
		  #ifndef MX_PWM_2_PORT_A										//Error checking
			#error "This chip does not have PWM alt channel 2 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_2_PORT_A, MX_PWM_2_TRIS_A, MX_PWM_2_PIN_A);		//PWM pin is an output
		#endif

		ccp2con = 0x0C;													//Enable Capture Compare Channel 2
	#endif

	#if (MX_PWM_CHANNEL_X == 3)
	  #ifdef MX_PWM_REMAPPABLE
	  	RPOR5 = 22;														//PWM3 - 22 - RB2 - RP5
	  #endif

		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
		  #ifndef MX_PWM_3_PORT											//Error checking
			#error "This chip does not have PWM channel 3 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_3_PORT, MX_PWM_3_TRIS, MX_PWM_3_PIN);			//PWM pin is an output
		#else															//Alternate PWM Pin
		  #ifndef MX_PWM_3_PORT_A										//Error checking
			#error "This chip does not have PWM alt channel 3 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_3_PORT_A, MX_PWM_3_TRIS_A, MX_PWM_3_PIN_A);		//PWM pin is an output
		#endif

		ccp3con = 0x0C;													//Enable Capture Compare Channel 3 *****************************************************************
	#endif

	#if (MX_PWM_CHANNEL_X == 4)
		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
		  #ifndef MX_PWM_4_PORT											//Error checking
			#error "This chip does not have PWM channel 4 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_4_PORT, MX_PWM_4_TRIS, MX_PWM_4_PIN);			//PWM pin is an output
		#else															//Alternate PWM Pin
		  #ifndef MX_PWM_4_PORT_A										//Error checking
			#error "This chip does not have PWM alt channel 4 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_4_PORT_A, MX_PWM_4_TRIS_A, MX_PWM_4_PIN_A);		//PWM pin is an output
		#endif

		ccp4con = 0x0C;													//Enable Capture Compare Channel 4 *****************************************************************
	#endif

	#if (MX_PWM_CHANNEL_X == 5)
		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
		  #ifndef MX_PWM_5_PORT											//Error checking
			#error "This chip does not have PWM channel 5 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_5_PORT, MX_PWM_5_TRIS, MX_PWM_5_PIN);			//PWM pin is an output
		#else															//Alternate PWM Pin
		  #ifndef MX_PWM_5_PORT_A										//Error checking
			#error "This chip does not have PWM alt channel 5 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_5_PORT_A, MX_PWM_5_TRIS_A, MX_PWM_5_PIN_A);		//PWM pin is an output
		#endif

		ccp5con = 0x0C;													//Enable Capture Compare Channel 5 *****************************************************************
	#endif

	#if (MX_PWM_CHANNEL_X == 6)
		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
		  #ifndef MX_PWM_6_PORT											//Error checking
			#error "This chip does not have PWM channel 6 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_6_PORT, MX_PWM_6_TRIS, MX_PWM_6_PIN);			//PWM pin is an output
		#else															//Alternate PWM Pin
		  #ifndef MX_PWM_6_PORT_A										//Error checking
			#error "This chip does not have PWM alt channel 6 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_6_PORT_A, MX_PWM_6_TRIS_A, MX_PWM_6_PIN_A);		//PWM pin is an output
		#endif

		ccp6con = 0x0C;													//Enable Capture Compare Channel 6 *****************************************************************
	#endif

	#if (MX_PWM_CHANNEL_X == 7)
		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
		  #ifndef MX_PWM_7_PORT											//Error checking
			#error "This chip does not have PWM channel 7 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_7_PORT, MX_PWM_7_TRIS, MX_PWM_7_PIN);			//PWM pin is an output
		#else															//Alternate PWM Pin
		  #ifndef MX_PWM_7_PORT_A										//Error checking
			#error "This chip does not have PWM alt channel 7 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_7_PORT_A, MX_PWM_7_TRIS_A, MX_PWM_7_PIN_A);		//PWM pin is an output
		#endif

		ccp7con = 0x0C;													//Enable Capture Compare Channel 5 *****************************************************************
	#endif

	#if (MX_PWM_CHANNEL_X == 8)
		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
		  #ifndef MX_PWM_8_PORT											//Error checking
			#error "This chip does not have PWM channel 8 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_8_PORT, MX_PWM_8_TRIS, MX_PWM_8_PIN);			//PWM pin is an output
		#else															//Alternate PWM Pin
		  #ifndef MX_PWM_8_PORT_A										//Error checking
			#error "This chip does not have PWM alt channel 8 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_8_PORT_A, MX_PWM_8_TRIS_A, MX_PWM_8_PIN_A);		//PWM pin is an output
		#endif

		ccp8con = 0x0C;													//Enable Capture Compare Channel 8 *****************************************************************
	#endif

	#if (MX_PWM_CHANNEL_X == 9)
		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
		  #ifndef MX_PWM_9_PORT											//Error checking
			#error "This chip does not have PWM channel 9 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_9_PORT, MX_PWM_9_TRIS, MX_PWM_9_PIN);			//PWM pin is an output
		#else															//Alternate PWM Pin
		  #ifndef MX_PWM_9_PORT_A										//Error checking
			#error "This chip does not have PWM alt channel 9 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_9_PORT_A, MX_PWM_9_TRIS_A, MX_PWM_9_PIN_A);		//PWM pin is an output
		#endif

		ccp9con = 0x0C;													//Enable Capture Compare Channel 9 *****************************************************************
	#endif

	#if (MX_PWM_CHANNEL_X == 10)
		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
		  #ifndef MX_PWM_10_PORT											//Error checking
			#error "This chip does not have PWM channel 10 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_10_PORT, MX_PWM_10_TRIS, MX_PWM_10_PIN);			//PWM pin is an output
		#else															//Alternate PWM Pin
		  #ifndef MX_PWM_10_PORT_A										//Error checking
			#error "This chip does not have PWM alt channel 10 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_10_PORT_A, MX_PWM_10_TRIS_A, MX_PWM_10_PIN_A);		//PWM pin is an output
		#endif

		ccp10con = 0x0C;												//Enable Capture Compare Channel 10 *****************************************************************
	#endif

 #else
 	#error "Hardware PWM not supported by Target microcontroller."
 #endif

}
0388  0008  	RETURN



CALFUNCTION(void, FC_CAL_PWM_Disable_Channel_, (void))

{
	#if (MX_PWM_CHANNEL_X == 1)
		ccp1con = 0x00;													//Disable Capture Compare Channel 1
037B  1283  	BCF STATUS, RP0
037C  1303  	BCF STATUS, RP1
037D  0197  	CLRF gbl_ccp1con

		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_1_PORT, MX_PWM_1_TRIS, MX_PWM_1_PIN);			//PWM pin is an input
037E  1683  	BSF STATUS, RP0
037F  1507  	BSF gbl_trisc,2

		#else															//Alternate PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_1_PORT_A, MX_PWM_1_TRIS_A, MX_PWM_1_PIN_A);		//PWM pin is an input
		#endif
	#endif

	#if (MX_PWM_CHANNEL_X == 2)
		ccp2con = 0x00;													//Disable Capture Compare Channel 2
		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_2_PORT, MX_PWM_2_TRIS, MX_PWM_2_PIN);			//PWM pin is an input
		#else															//Alternate PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_2_PORT_A, MX_PWM_2_TRIS_A, MX_PWM_2_PIN_A);		//PWM pin is an input
		#endif
	#endif

	#if (MX_PWM_CHANNEL_X == 3)
		ccp3con = 0x00;													//Disable Capture Compare Channel 3
		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_3_PORT, MX_PWM_3_TRIS, MX_PWM_3_PIN);			//PWM pin is an input
		#else															//Alternate PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_3_PORT_A, MX_PWM_3_TRIS_A, MX_PWM_3_PIN_A);		//PWM pin is an input
		#endif
	#endif

	#if (MX_PWM_CHANNEL_X == 4)
		ccp4con = 0x00;													//Disable Capture Compare Channel 4
		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_4_PORT, MX_PWM_4_TRIS, MX_PWM_4_PIN);			//PWM pin is an input
		#else															//Alternate PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_4_PORT_A, MX_PWM_4_TRIS_A, MX_PWM_4_PIN_A);		//PWM pin is an input
		#endif
	#endif

	#if (MX_PWM_CHANNEL_X == 5)
		ccp5con = 0x00;													//Disable Capture Compare Channel 5
		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_5_PORT, MX_PWM_5_TRIS, MX_PWM_5_PIN);			//PWM pin is an input
		#else															//Alternate PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_5_PORT_A, MX_PWM_5_TRIS_A, MX_PWM_5_PIN_A);		//PWM pin is an input
		#endif
	#endif

	#if (MX_PWM_CHANNEL_X == 6)
		ccp6con = 0x00;													//Disable Capture Compare Channel 6
		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_6_PORT, MX_PWM_6_TRIS, MX_PWM_6_PIN);			//PWM pin is an input
		#else															//Alternate PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_6_PORT_A, MX_PWM_6_TRIS_A, MX_PWM_6_PIN_A);		//PWM pin is an input
		#endif
	#endif

	#if (MX_PWM_CHANNEL_X == 7)
		ccp7con = 0x00;													//Disable Capture Compare Channel 7
		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_7_PORT, MX_PWM_7_TRIS, MX_PWM_7_PIN);			//PWM pin is an input
		#else															//Alternate PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_7_PORT_A, MX_PWM_7_TRIS_A, MX_PWM_7_PIN_A);		//PWM pin is an input
		#endif
	#endif

	#if (MX_PWM_CHANNEL_X == 8)
		ccp8con = 0x00;													//Disable Capture Compare Channel 8
		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_8_PORT, MX_PWM_8_TRIS, MX_PWM_8_PIN);			//PWM pin is an input
		#else															//Alternate PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_8_PORT_A, MX_PWM_8_TRIS_A, MX_PWM_8_PIN_A);		//PWM pin is an input
		#endif
	#endif

	#if (MX_PWM_CHANNEL_X == 9)
		ccp9con = 0x00;													//Disable Capture Compare Channel 9
		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_9_PORT, MX_PWM_9_TRIS, MX_PWM_9_PIN);			//PWM pin is an input
		#else															//Alternate PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_9_PORT_A, MX_PWM_9_TRIS_A, MX_PWM_9_PIN_A);		//PWM pin is an input
		#endif
	#endif

	#if (MX_PWM_CHANNEL_X == 10)
		ccp10con = 0x00;												//Disable Capture Compare Channel 10
		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_10_PORT, MX_PWM_10_TRIS, MX_PWM_10_PIN);			//PWM pin is an input
		#else															//Alternate PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_10_PORT_A, MX_PWM_10_TRIS_A, MX_PWM_10_PIN_A);		//PWM pin is an input
		#endif
	#endif
}
0380  0008  	RETURN



CALFUNCTION(void, FC_CAL_PWM_Set_Duty_8Bit_, (MX_UINT8 duty))

{
	#if (MX_PWM_CHANNEL_X == 1)
		ccpr1l = duty;													//Update Capture Compare Count 1
0377  0820  	MOVF FC_CAL_PWM_0007B_arg_duty, W
0378  1283  	BCF STATUS, RP0
0379  0095  	MOVWF gbl_ccpr1l

	#endif

	#if (MX_PWM_CHANNEL_X == 2)
		ccpr2l = duty;													//Update Capture Compare Count 2
	#endif

	#if (MX_PWM_CHANNEL_X == 3)
		ccpr3l = duty;													//Update Capture Compare Count 3
	#endif

	#if (MX_PWM_CHANNEL_X == 4)
		ccpr4l = duty;													//Update Capture Compare Count 4
	#endif

	#if (MX_PWM_CHANNEL_X == 5)
		ccpr5l = duty;													//Update Capture Compare Count 5
	#endif

	#if (MX_PWM_CHANNEL_X == 6)
		ccpr6l = duty;													//Update Capture Compare Count 6
	#endif

	#if (MX_PWM_CHANNEL_X == 7)
		ccpr7l = duty;													//Update Capture Compare Count 7
	#endif

	#if (MX_PWM_CHANNEL_X == 8)
		ccpr8l = duty;													//Update Capture Compare Count 8
	#endif

	#if (MX_PWM_CHANNEL_X == 9)
		ccpr9l = duty;													//Update Capture Compare Count 9
	#endif

	#if (MX_PWM_CHANNEL_X == 10)
		ccpr10l = duty;													//Update Capture Compare Count 10
	#endif
}
037A  0008  	RETURN



CALFUNCTION(void, FC_CAL_PWM_Change_Period_, (MX_UINT8 period, MX_UINT16 prescaler))

{
  #ifdef MX_PWM								//Hardware Mode
	pr2 = period;
0354  1283  	BCF STATUS, RP0
0355  087E  	MOVF FC_CAL_PWM_0007C_arg_period, W
0356  1683  	BSF STATUS, RP0
0357  0092  	MOVWF gbl_pr2

	switch (prescaler)
	{
	  #ifdef MX_PWM_PSCA1
		case 1:
0358  3001  	MOVLW 0x01
0359  0620  	XORWF FC_CAL_PWM_0007C_arg_prescaler, W
035A  1903  	BTFSC STATUS,Z
035B  0821  	MOVF FC_CAL_PWM_0007C_arg_prescaler+D'1', W
035C  1903  	BTFSC STATUS,Z
035D  2B6B  	GOTO	label41
036B        label41

			t2con = 0x04;
036B  3004  	MOVLW 0x04
036C  1283  	BCF STATUS, RP0
036D  0092  	MOVWF gbl_t2con

			break;
	  #endif
	  #ifdef MX_PWM_PSCA4
		case 4:
035E  3004  	MOVLW 0x04
035F  0620  	XORWF FC_CAL_PWM_0007C_arg_prescaler, W
0360  1903  	BTFSC STATUS,Z
0361  0821  	MOVF FC_CAL_PWM_0007C_arg_prescaler+D'1', W
0362  1903  	BTFSC STATUS,Z
0363  2B6F  	GOTO	label42
036F        label42

			t2con = 0x05;
036F  3005  	MOVLW 0x05
0370  1283  	BCF STATUS, RP0
0371  0092  	MOVWF gbl_t2con

			break;
	  #endif
	  #ifdef MX_PWM_PSCA16
		case 16:
0364  3010  	MOVLW 0x10
0365  0620  	XORWF FC_CAL_PWM_0007C_arg_prescaler, W
0366  1903  	BTFSC STATUS,Z
0367  0821  	MOVF FC_CAL_PWM_0007C_arg_prescaler+D'1', W
0368  1903  	BTFSC STATUS,Z
0369  2B73  	GOTO	label43
0373        label43

			t2con = 0x06;
0373  3006  	MOVLW 0x06
0374  1283  	BCF STATUS, RP0
0375  0092  	MOVWF gbl_t2con

			break;
	  #endif
	  #ifdef MX_PWM_PSCA64
		case 64:
			t2con = 0x07;					//Note some earlier devices do not have the /64 option
			break;
	  #endif
	}
  #endif
}
036A  0008  	RETURN
036E  0008  	RETURN
0372  0008  	RETURN
0376  0008  	RETURN



CALFUNCTION(void, FC_CAL_PWM_Set_Duty_10Bit_, (MX_UINT16 duty))
{
	char nCCPxCONtemp;

	#if (MX_PWM_CHANNEL_X == 1)
		ccpr1l = (duty & 0x3FC) >> 2;									//Update Capture Compare Count 1
		duty = (duty & 0x03) << 4;
		nCCPxCONtemp = (ccp1con & 0xCF) | duty;
		ccp1con = nCCPxCONtemp;
	#endif

	#if (MX_PWM_CHANNEL_X == 2)
		ccpr2l = (duty & 0x3FC) >> 2;									//Update Capture Compare Count 2
		duty = (duty & 0x03) << 4;
		nCCPxCONtemp = (ccp2con & 0xCF) | duty;
		ccp2con = nCCPxCONtemp;
	#endif

	#if (MX_PWM_CHANNEL_X == 3)
		ccpr3l = (duty & 0x3FC) >> 2;									//Update Capture Compare Count 3
		duty = (duty & 0x03) << 4;
		nCCPxCONtemp = (ccp3con & 0xCF) | duty;
		ccp3con = nCCPxCONtemp;
	#endif

	#if (MX_PWM_CHANNEL_X == 4)
		ccpr4l = (duty & 0x3FC) >> 2;									//Update Capture Compare Count 4
		duty = (duty & 0x03) << 4;
		nCCPxCONtemp = (ccp4con & 0xCF) | duty;
		ccp4con = nCCPxCONtemp;
	#endif

	#if (MX_PWM_CHANNEL_X == 5)
		ccpr5l = (duty & 0x3FC) >> 2;									//Update Capture Compare Count 5
		duty = (duty & 0x03) << 4;
		nCCPxCONtemp = (ccp5con & 0xCF) | duty;
		ccp5con = nCCPxCONtemp;
	#endif

	#if (MX_PWM_CHANNEL_X == 6)
		ccpr6l = (duty & 0x3FC) >> 2;									//Update Capture Compare Count 6
		duty = (duty & 0x03) << 4;
		nCCPxCONtemp = (ccp6con & 0xCF) | duty;
		ccp6con = nCCPxCONtemp;
	#endif

	#if (MX_PWM_CHANNEL_X == 7)
		ccpr7l = (duty & 0x3FC) >> 2;									//Update Capture Compare Count 7
		duty = (duty & 0x03) << 4;
		nCCPxCONtemp = (ccp7con & 0xCF) | duty;
		ccp7con = nCCPxCONtemp;
	#endif

	#if (MX_PWM_CHANNEL_X == 8)
		ccpr8l = (duty & 0x3FC) >> 2;									//Update Capture Compare Count 8
		duty = (duty & 0x03) << 4;
		nCCPxCONtemp = (ccp8con & 0xCF) | duty;
		ccp8con = nCCPxCONtemp;
	#endif

	#if (MX_PWM_CHANNEL_X == 9)
		ccpr9l = (duty & 0x3FC) >> 2;									//Update Capture Compare Count 9
		duty = (duty & 0x03) << 4;
		nCCPxCONtemp = (ccp9con & 0xCF) | duty;
		ccp9con = nCCPxCONtemp;
	#endif

	#if (MX_PWM_CHANNEL_X == 10)
		ccpr10l = (duty & 0x3FC) >> 2;									//Update Capture Compare Count 10
		duty = (duty & 0x03) << 4;
		nCCPxCONtemp = (ccp10con & 0xCF) | duty;
		ccp10con = nCCPxCONtemp;
	#endif
}


////////////////////////////////////////
// Code with no source :-)
////////////////////////////////////////
0000  158A  	BSF PCLATH,3
0001  29B3  	GOTO	_startup

0004  00FF  	MOVWF Int1Context
0005  0E03  	SWAPF STATUS, W
0006  1283  	BCF STATUS, RP0
0007  1303  	BCF STATUS, RP1
0008  00C0  	MOVWF Int1BContext
0009  0E0A  	SWAPF PCLATH, W
000A  00C1  	MOVWF Int1BContext+D'1'
000B  0E04  	SWAPF FSR, W
000C  00C2  	MOVWF Int1BContext+D'2'
000D  158A  	BSF PCLATH,3
000E  120A  	BCF PCLATH,4
000F  2A13  	GOTO	interrupt
0010        delay_us_00000
0010        ; { delay_us ; function begin
0010  3003  	MOVLW 0x03
0011  07A6  	ADDWF delay_us_00000_arg_del, F
0012  0CA6  	RRF delay_us_00000_arg_del, F
0013  0CA6  	RRF delay_us_00000_arg_del, F
0014  307F  	MOVLW 0x7F
0015  05A6  	ANDWF delay_us_00000_arg_del, F
0016        label1
0016  0000  	NOP
0017  0BA6  	DECFSZ delay_us_00000_arg_del, F
0018  2816  	GOTO	label1
0019  0008  	RETURN
001A        ; } delay_us function end

001A        delay_ms_00000
001A        ; { delay_ms ; function begin
001A  08A1  	MOVF delay_ms_00000_arg_del, F
001B  1D03  	BTFSS STATUS,Z
001C  281E  	GOTO	label2
001D  0008  	RETURN
001E        label2
001E  30CC  	MOVLW 0xCC
001F        label3
001F  3EFF  	ADDLW 0xFF
0020  1D03  	BTFSS STATUS,Z
0021  281F  	GOTO	label3
0022  0000  	NOP
0023  0BA1  	DECFSZ delay_ms_00000_arg_del, F
0024  281E  	GOTO	label2
0025  0008  	RETURN
0026        ; } delay_ms function end


0210        __rem_8_8_00000
0210        ; { __rem_8_8 ; function begin
0210  01A7  	CLRF CompTempVarRet220
0211  01A5  	CLRF __rem_8_8_00000_1_c
0212  01A6  	CLRF __rem_8_8_00000_1_i
0213        label19
0213  19A6  	BTFSC __rem_8_8_00000_1_i,3
0214  0008  	RETURN
0215  1003  	BCF STATUS,C
0216  0DA5  	RLF __rem_8_8_00000_1_c, F
0217  0DA1  	RLF __rem_8_8_00000_arg_a, F
0218  0DA7  	RLF CompTempVarRet220, F
0219  0822  	MOVF __rem_8_8_00000_arg_b, W
021A  0227  	SUBWF CompTempVarRet220, W
021B  1C03  	BTFSS STATUS,C
021C  2A1F  	GOTO	label20
021D  00A7  	MOVWF CompTempVarRet220
021E  1425  	BSF __rem_8_8_00000_1_c,0
021F        label20
021F  0AA6  	INCF __rem_8_8_00000_1_i, F
0220  2A13  	GOTO	label19
0221        ; } __rem_8_8 function end

0221        __rem_32_3_00002
0221        ; { __rem_32_32 ; function begin
0221  01AE  	CLRF CompTempVarRet212
0222  01AF  	CLRF CompTempVarRet212+D'1'
0223  01B0  	CLRF CompTempVarRet212+D'2'
0224  01B1  	CLRF CompTempVarRet212+D'3'
0225  01A9  	CLRF __rem_32_3_00002_1_c
0226  01AA  	CLRF __rem_32_3_00002_1_c+D'1'
0227  01AB  	CLRF __rem_32_3_00002_1_c+D'2'
0228  01AC  	CLRF __rem_32_3_00002_1_c+D'3'
0229  01AD  	CLRF __rem_32_3_00002_1_i
022A        label21
022A  1AAD  	BTFSC __rem_32_3_00002_1_i,5
022B  0008  	RETURN
022C  1003  	BCF STATUS,C
022D  0DA9  	RLF __rem_32_3_00002_1_c, F
022E  0DAA  	RLF __rem_32_3_00002_1_c+D'1', F
022F  0DAB  	RLF __rem_32_3_00002_1_c+D'2', F
0230  0DAC  	RLF __rem_32_3_00002_1_c+D'3', F
0231  0DA1  	RLF __rem_32_3_00002_arg_a, F
0232  0DA2  	RLF __rem_32_3_00002_arg_a+D'1', F
0233  0DA3  	RLF __rem_32_3_00002_arg_a+D'2', F
0234  0DA4  	RLF __rem_32_3_00002_arg_a+D'3', F
0235  0DAE  	RLF CompTempVarRet212, F
0236  0DAF  	RLF CompTempVarRet212+D'1', F
0237  0DB0  	RLF CompTempVarRet212+D'2', F
0238  0DB1  	RLF CompTempVarRet212+D'3', F
0239  0828  	MOVF __rem_32_3_00002_arg_b+D'3', W
023A  0231  	SUBWF CompTempVarRet212+D'3', W
023B  1D03  	BTFSS STATUS,Z
023C  2A47  	GOTO	label22
023D  0827  	MOVF __rem_32_3_00002_arg_b+D'2', W
023E  0230  	SUBWF CompTempVarRet212+D'2', W
023F  1D03  	BTFSS STATUS,Z
0240  2A47  	GOTO	label22
0241  0826  	MOVF __rem_32_3_00002_arg_b+D'1', W
0242  022F  	SUBWF CompTempVarRet212+D'1', W
0243  1D03  	BTFSS STATUS,Z
0244  2A47  	GOTO	label22
0245  0825  	MOVF __rem_32_3_00002_arg_b, W
0246  022E  	SUBWF CompTempVarRet212, W
0247        label22
0247  1C03  	BTFSS STATUS,C
0248  2A58  	GOTO	label23
0249  0825  	MOVF __rem_32_3_00002_arg_b, W
024A  02AE  	SUBWF CompTempVarRet212, F
024B  0826  	MOVF __rem_32_3_00002_arg_b+D'1', W
024C  1C03  	BTFSS STATUS,C
024D  0F26  	INCFSZ __rem_32_3_00002_arg_b+D'1', W
024E  02AF  	SUBWF CompTempVarRet212+D'1', F
024F  0827  	MOVF __rem_32_3_00002_arg_b+D'2', W
0250  1C03  	BTFSS STATUS,C
0251  0F27  	INCFSZ __rem_32_3_00002_arg_b+D'2', W
0252  02B0  	SUBWF CompTempVarRet212+D'2', F
0253  0828  	MOVF __rem_32_3_00002_arg_b+D'3', W
0254  1C03  	BTFSS STATUS,C
0255  0F28  	INCFSZ __rem_32_3_00002_arg_b+D'3', W
0256  02B1  	SUBWF CompTempVarRet212+D'3', F
0257  1429  	BSF __rem_32_3_00002_1_c,0
0258        label23
0258  0AAD  	INCF __rem_32_3_00002_1_i, F
0259  2A2A  	GOTO	label21
025A        ; } __rem_32_32 function end

025A        __div_8_8_00000
025A        ; { __div_8_8 ; function begin
025A  01A5  	CLRF __div_8_8_00000_1_r
025B  01A7  	CLRF CompTempVarRet218
025C  01A6  	CLRF __div_8_8_00000_1_i
025D        label24
025D  19A6  	BTFSC __div_8_8_00000_1_i,3
025E  0008  	RETURN
025F  1003  	BCF STATUS,C
0260  0DA7  	RLF CompTempVarRet218, F
0261  0DA3  	RLF __div_8_8_00000_arg_a, F
0262  0DA5  	RLF __div_8_8_00000_1_r, F
0263  0824  	MOVF __div_8_8_00000_arg_b, W
0264  0225  	SUBWF __div_8_8_00000_1_r, W
0265  1C03  	BTFSS STATUS,C
0266  2A69  	GOTO	label25
0267  00A5  	MOVWF __div_8_8_00000_1_r
0268  1427  	BSF CompTempVarRet218,0
0269        label25
0269  0AA6  	INCF __div_8_8_00000_1_i, F
026A  2A5D  	GOTO	label24
026B        ; } __div_8_8 function end

026B        __div_32_3_00001
026B        ; { __div_32_32 ; function begin
026B  01AE  	CLRF __div_32_3_00001_1_r
026C  01AF  	CLRF __div_32_3_00001_1_r+D'1'
026D  01B0  	CLRF __div_32_3_00001_1_r+D'2'
026E  01B1  	CLRF __div_32_3_00001_1_r+D'3'
026F  01B3  	CLRF CompTempVarRet210
0270  01B4  	CLRF CompTempVarRet210+D'1'
0271  01B5  	CLRF CompTempVarRet210+D'2'
0272  01B6  	CLRF CompTempVarRet210+D'3'
0273  01B2  	CLRF __div_32_3_00001_1_i
0274        label26
0274  1AB2  	BTFSC __div_32_3_00001_1_i,5
0275  0008  	RETURN
0276  1003  	BCF STATUS,C
0277  0DB3  	RLF CompTempVarRet210, F
0278  0DB4  	RLF CompTempVarRet210+D'1', F
0279  0DB5  	RLF CompTempVarRet210+D'2', F
027A  0DB6  	RLF CompTempVarRet210+D'3', F
027B  0DA1  	RLF __div_32_3_00001_arg_a, F
027C  0DA2  	RLF __div_32_3_00001_arg_a+D'1', F
027D  0DA3  	RLF __div_32_3_00001_arg_a+D'2', F
027E  0DA4  	RLF __div_32_3_00001_arg_a+D'3', F
027F  0DAE  	RLF __div_32_3_00001_1_r, F
0280  0DAF  	RLF __div_32_3_00001_1_r+D'1', F
0281  0DB0  	RLF __div_32_3_00001_1_r+D'2', F
0282  0DB1  	RLF __div_32_3_00001_1_r+D'3', F
0283  0828  	MOVF __div_32_3_00001_arg_b+D'3', W
0284  0231  	SUBWF __div_32_3_00001_1_r+D'3', W
0285  1D03  	BTFSS STATUS,Z
0286  2A91  	GOTO	label27
0287  0827  	MOVF __div_32_3_00001_arg_b+D'2', W
0288  0230  	SUBWF __div_32_3_00001_1_r+D'2', W
0289  1D03  	BTFSS STATUS,Z
028A  2A91  	GOTO	label27
028B  0826  	MOVF __div_32_3_00001_arg_b+D'1', W
028C  022F  	SUBWF __div_32_3_00001_1_r+D'1', W
028D  1D03  	BTFSS STATUS,Z
028E  2A91  	GOTO	label27
028F  0825  	MOVF __div_32_3_00001_arg_b, W
0290  022E  	SUBWF __div_32_3_00001_1_r, W
0291        label27
0291  1C03  	BTFSS STATUS,C
0292  2AA2  	GOTO	label28
0293  0825  	MOVF __div_32_3_00001_arg_b, W
0294  02AE  	SUBWF __div_32_3_00001_1_r, F
0295  0826  	MOVF __div_32_3_00001_arg_b+D'1', W
0296  1C03  	BTFSS STATUS,C
0297  0F26  	INCFSZ __div_32_3_00001_arg_b+D'1', W
0298  02AF  	SUBWF __div_32_3_00001_1_r+D'1', F
0299  0827  	MOVF __div_32_3_00001_arg_b+D'2', W
029A  1C03  	BTFSS STATUS,C
029B  0F27  	INCFSZ __div_32_3_00001_arg_b+D'2', W
029C  02B0  	SUBWF __div_32_3_00001_1_r+D'2', F
029D  0828  	MOVF __div_32_3_00001_arg_b+D'3', W
029E  1C03  	BTFSS STATUS,C
029F  0F28  	INCFSZ __div_32_3_00001_arg_b+D'3', W
02A0  02B1  	SUBWF __div_32_3_00001_1_r+D'3', F
02A1  1433  	BSF CompTempVarRet210,0
02A2        label28
02A2  0AB2  	INCF __div_32_3_00001_1_i, F
02A3  2A74  	GOTO	label26
02A4        ; } __div_32_32 function end


032B        __mul_16s__0000E
032B        ; { __mul_16s_16s__16 ; function begin
032B  01A5  	CLRF __mul_16s__0000E_1_i
032C  01A8  	CLRF CompTempVarRet461
032D  01A9  	CLRF CompTempVarRet461+D'1'
032E  0821  	MOVF __mul_16s__0000E_arg_a, W
032F  00A6  	MOVWF __mul_16s__0000E_1_t
0330  0822  	MOVF __mul_16s__0000E_arg_a+D'1', W
0331  00A7  	MOVWF __mul_16s__0000E_1_t+D'1'
0332  1FA4  	BTFSS __mul_16s__0000E_arg_b+D'1',7
0333  2B3A  	GOTO	label38
0334  17A5  	BSF __mul_16s__0000E_1_i,7
0335  09A3  	COMF __mul_16s__0000E_arg_b, F
0336  09A4  	COMF __mul_16s__0000E_arg_b+D'1', F
0337  0AA3  	INCF __mul_16s__0000E_arg_b, F
0338  1903  	BTFSC gbl_status,2
0339  0AA4  	INCF __mul_16s__0000E_arg_b+D'1', F
033A        label38
033A  1A25  	BTFSC __mul_16s__0000E_1_i,4
033B  2B4C  	GOTO	label40
033C  1C23  	BTFSS __mul_16s__0000E_arg_b,0
033D  2B44  	GOTO	label39
033E  0826  	MOVF __mul_16s__0000E_1_t, W
033F  07A8  	ADDWF CompTempVarRet461, F
0340  0827  	MOVF __mul_16s__0000E_1_t+D'1', W
0341  1803  	BTFSC gbl_status,0
0342  0F27  	INCFSZ __mul_16s__0000E_1_t+D'1', W
0343  07A9  	ADDWF CompTempVarRet461+D'1', F
0344        label39
0344  1003  	BCF gbl_status,0
0345  0CA4  	RRF __mul_16s__0000E_arg_b+D'1', F
0346  0CA3  	RRF __mul_16s__0000E_arg_b, F
0347  1003  	BCF gbl_status,0
0348  0DA6  	RLF __mul_16s__0000E_1_t, F
0349  0DA7  	RLF __mul_16s__0000E_1_t+D'1', F
034A  0AA5  	INCF __mul_16s__0000E_1_i, F
034B  2B3A  	GOTO	label38
034C        label40
034C  1FA5  	BTFSS __mul_16s__0000E_1_i,7
034D  0008  	RETURN
034E  09A8  	COMF CompTempVarRet461, F
034F  09A9  	COMF CompTempVarRet461+D'1', F
0350  0AA8  	INCF CompTempVarRet461, F
0351  1903  	BTFSC gbl_status,2
0352  0AA9  	INCF CompTempVarRet461+D'1', F
0353  0008  	RETURN
0354        ; } __mul_16s_16s__16 function end


09B3        _startup
09B3  30D5  	MOVLW 0xD5
09B4  1283  	BCF STATUS, RP0
09B5  1303  	BCF STATUS, RP1
09B6  00A0  	MOVWF gbl_14_LSR
09B7  30C4  	MOVLW 0xC4
09B8  00A1  	MOVWF gbl_14_LSR+D'1'
09B9  30BB  	MOVLW 0xBB
09BA  00A2  	MOVWF gbl_14_LSR+D'2'
09BB  30DC  	MOVLW 0xDC
09BC  00A3  	MOVWF gbl_14_LSR+D'3'
09BD  01A4  	CLRF gbl_15_gbl_aSig
09BE  01A5  	CLRF gbl_15_gbl_aSig+D'1'
09BF  01A6  	CLRF gbl_15_gbl_aSig+D'2'
09C0  01A7  	CLRF gbl_15_gbl_aSig+D'3'
09C1  01A8  	CLRF gbl_15_gbl_bSig
09C2  01A9  	CLRF gbl_15_gbl_bSig+D'1'
09C3  01AA  	CLRF gbl_15_gbl_bSig+D'2'
09C4  01AB  	CLRF gbl_15_gbl_bSig+D'3'
09C5  01AC  	CLRF gbl_15_gbl_zSig
09C6  01AD  	CLRF gbl_15_gbl_zSig+D'1'
09C7  01AE  	CLRF gbl_15_gbl_zSig+D'2'
09C8  01AF  	CLRF gbl_15_gbl_zSig+D'3'
09C9  01CE  	CLRF gbl_15_gbl_aExp
09CA  01CF  	CLRF gbl_15_gbl_bExp
09CB  01C3  	CLRF gbl_15_gbl_zExp
09CC  01C4  	CLRF gbl_15_gbl_zExp+D'1'
09CD  01D0  	CLRF gbl_15_gbl_aSign
09CE  01D1  	CLRF gbl_15_gbl_bSign
09CF  01D2  	CLRF gbl_15_gbl_zSign
09D0  01D3  	CLRF gbl_15_gbl_zSigZero
09D1  01B0  	CLRF gbl_15_gbl_ret
09D2  01B1  	CLRF gbl_15_gbl_ret+D'1'
09D3  01B2  	CLRF gbl_15_gbl_ret+D'2'
09D4  01B3  	CLRF gbl_15_gbl_ret+D'3'
09D5  01CC  	CLRF gbl_float_rounding_mode
09D6  01CD  	CLRF gbl_float_exception_flags
09D7  01CB  	CLRF gbl_float_detect_tininess

0A10  118A  	BCF PCLATH,3
0A11  120A  	BCF PCLATH,4
0A12  2FA7  	GOTO	main

2007  1E72  	DW 0x1E72
