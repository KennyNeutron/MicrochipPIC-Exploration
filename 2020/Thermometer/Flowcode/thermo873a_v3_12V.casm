;/////////////////////////////////////////////////////////////////////////////////
;// Code Generator: BoostC Compiler - http://www.sourceboost.com
;// Version       : 7.03
;// License Type  : Pro License
;// Limitations   : PIC12,PIC16 max code size:Unlimited, max RAM banks:Unlimited
;/////////////////////////////////////////////////////////////////////////////////

//************************************************************************************
//**  
//**  File name:     C:\Users\gerpe\OneDrive\GER-PER 2016\Documents\KennyNeutron\2020\Thermometer\Flowcode\thermo873a_v3_12V.c
//**  Title:         
//**  Description:   
//**  
//**  Generated by:  Flowcode v5.2.0.0
//**  Date:          Wednesday, August 05, 2020 12:15:51
//**  Licence:       Professional
//**  Registered to: xyz
//**  Licence key:   WUK7B9
//**  
//**  
//**  http://www.matrixmultimedia.com
//**  
//************************************************************************************


#define MX_PIC

#define MX_USES_UINT8 1
#define MX_USES_SINT16 1
#define MX_USES_CHAR 0
#define MX_USES_FLOAT 0
#define MX_USES_SINT32 1
#define MX_USES_BOOL 1
#define MX_USES_UINT16 1
#define MX_USES_UINT32 0
//Defines for microcontroller
#define P16F873A
#define FC_CAL_PIC
#define MX_ADC
#define MX_ADC_TYPE_1
#define MX_ADC_BITS_10
#define MX_EE
#define MX_EE_TYPE2
#define MX_EE_SIZE 128
#define MX_SPI_1
#define MX_SPI_1_MISO_PORT portc
#define MX_SPI_1_MISO_TRIS trisc
#define MX_SPI_1_MISO_PIN 4
#define MX_SPI_1_MOSI_PORT portc
#define MX_SPI_1_MOSI_TRIS trisc
#define MX_SPI_1_MOSI_PIN 5
#define MX_SPI_1_CLK_PORT portc
#define MX_SPI_1_CLK_TRIS trisc
#define MX_SPI_1_CLK_PIN 3
#define MX_SPI_1_SS_PORT portc
#define MX_SPI_1_SS_TRIS trisc
#define MX_UART_1
#define MX_UART_1_TX_PORT portc
#define MX_UART_1_TX_TRIS trisc
#define MX_UART_1_TX_PIN 6
#define MX_UART_1_RX_PORT portc
#define MX_UART_1_RX_TRIS trisc
#define MX_UART_1_RX_PIN 7
#define MX_I2C
#define MX_MI2C
#define MX_I2C_1
#define MX_I2C_1_SDA_PORT portc
#define MX_I2C_1_SDA_TRIS trisc
#define MX_I2C_1_SDA_PIN 4
#define MX_I2C_1_SCL_PORT portc
#define MX_I2C_1_SCL_TRIS trisc
#define MX_I2C_1_SCL_PIN 3
#define MX_PWM
#define MX_PWM_CNT 2
#define MX_PWM_PSCA1
#define MX_PWM_PSCA4
#define MX_PWM_PSCA16
#define MX_PWM_1_PORT portc
#define MX_PWM_1_TRIS trisc
#define MX_PWM_1_PIN 2
#define MX_PWM_2_PORT portc
#define MX_PWM_2_TRIS trisc
#define MX_PWM_2_PIN 1

//Functions
#define MX_CLK_SPEED 3276800
#ifdef _BOOSTC
#include <system.h>
#endif
#ifdef HI_TECH_C
#include <pic.h>
#endif

//Configuration data
#ifdef _BOOSTC
#pragma DATA 0x2007, 0x1f32
#endif
#ifdef HI_TECH_C
__CONFIG(0x1f32);
#endif

//Internal functions
#include "C:\Program Files (x86)\Flowcode\v5\FCD\internals.c"

//Macro function declarations
void FCM_scan1();
void FCM_scan2();
void FCM_scan3();
void FCM_scan4();
void FCM_scan_off();
void FCM_test();
void FCM_seg_pattern();
void FCM_display_temp();
void FCM_all_input();
void FCM_pass();
void FCM_failed();
void FCM_calc();
void FCM_i2c_comm();
void FCM_lights_off();
void FCM_beep_once();
void FCM_get_temp();
void FCM_display_repeat();
void FCM_repeat();
void FCM_display_fail();
void FCM_calibrate();
void FCM_display_temp_calib();
void FCM_calc_calib();


//Variable declarations
#define FCV_FALSE (0)
#define FCV_TRUE (1)
MX_UINT8 FCV_TEMP_TENS = (0x0);
0934  01D2  	CLRF gbl_FCV_TEMP_TENS

MX_UINT8 FCV_D_BYTE = (0x0);
0935  01D3  	CLRF gbl_FCV_D_BYTE

MX_SINT32 FCV_RAW = (0);
0936  01B4  	CLRF gbl_FCV_RAW
0937  01B5  	CLRF gbl_FCV_RAW+D'1'
0938  01B6  	CLRF gbl_FCV_RAW+D'2'
0939  01B7  	CLRF gbl_FCV_RAW+D'3'

MX_UINT8 FCV_DATA0 = (0xff);
093A  30FF  	MOVLW 0xFF
093B  00D4  	MOVWF gbl_FCV_DATA0

MX_SINT16 FCV_TEMP_CDP = (0);
093C  01C1  	CLRF gbl_FCV_TEMP_CDP
093D  01C2  	CLRF gbl_FCV_TEMP_CDP+D'1'

MX_UINT8 FCV_DATA1 = (0xff);
093E  30FF  	MOVLW 0xFF
093F  00D5  	MOVWF gbl_FCV_DATA1

MX_UINT8 FCV_RET_BYTE = (0x0);
0940  01D6  	CLRF gbl_FCV_RET_BYTE

MX_UINT8 FCV_DP2 = (0x0);
0941  01D7  	CLRF gbl_FCV_DP2

MX_UINT8 FCV_DATA2 = (0xff);
0942  30FF  	MOVLW 0xFF
0943  00D8  	MOVWF gbl_FCV_DATA2

MX_UINT8 FCV_RESET_COUNTER = (0x0);
0944  01D9  	CLRF gbl_FCV_RESET_COUNTER

MX_UINT8 FCV_TEMP_DEC = (0x0);
0945  01DA  	CLRF gbl_FCV_TEMP_DEC

MX_BOOL FCV_PROX_BIT = (1);
0946  145B  	BSF gbl_FCV_PROX_BIT,0

MX_UINT8 FCV_TEMP_ONES = (0x0);
0947  01DC  	CLRF gbl_FCV_TEMP_ONES

MX_UINT8 FCV_LSB = (0xff);
0948  30FF  	MOVLW 0xFF
0949  00DD  	MOVWF gbl_FCV_LSB

MX_UINT8 FCV_RT_BYTE = (0xff);
094A  30FF  	MOVLW 0xFF
094B  00DE  	MOVWF gbl_FCV_RT_BYTE

MX_UINT8 FCV_PROX_COUNTER = (0x0);
094C  01DF  	CLRF gbl_FCV_PROX_COUNTER

MX_UINT8 FCV_MSB = (0xff);
094D  30FF  	MOVLW 0xFF
094E  00E0  	MOVWF gbl_FCV_MSB

MX_UINT8 FCV_DIGIT = (0x0);
094F  01E1  	CLRF gbl_FCV_DIGIT

MX_UINT16 FCV_CALIB_SUBTRACTOR;
MX_UINT8 FCV_SWR = (0x1);
0950  3001  	MOVLW 0x01
0951  00E2  	MOVWF gbl_FCV_SWR

MX_BOOL FCV_SW0 = (1);
0952  14DB  	BSF gbl_FCV_SW0,1

MX_BOOL FCV_FLAGBIT = (1);
0953  155B  	BSF gbl_FCV_FLAGBIT,2

MX_SINT32 FCV_TEMP_C;
MX_UINT8 FCV_I2C_RX = (0x0);
0954  01E3  	CLRF gbl_FCV_I2C_RX

MX_UINT8 FCV_CALIB_FACTOR = (0x0);
0955  01E4  	CLRF gbl_FCV_CALIB_FACTOR

MX_UINT8 FCV_CALIB_COUNT;
MX_UINT8 FCV_DATA_PREV = (0x0);
0956  01E6  	CLRF gbl_FCV_DATA_PREV

MX_UINT16 FCV_SAVE_CALIB0 = (0x0);
0957  01C5  	CLRF gbl_FCV_SAVE_CALIB0
0958  01C6  	CLRF gbl_FCV_SAVE_CALIB0+D'1'

MX_UINT8 FCV_SW_CALIB = (0x0);
0959  01E7  	CLRF gbl_FCV_SW_CALIB

MX_UINT8 FCV_SAVE_CALIB1;
MX_SINT16 FCV_CALIB_OFFSET;
MX_BOOL FCV_SWG = (1);
095A  15DB  	BSF gbl_FCV_SWG,3

MX_UINT8 FCV_DATA_DIFF = (0x0);
095B  01E9  	CLRF gbl_FCV_DATA_DIFF


MX_UINT8 FCLV_LOOP1;
MX_UINT8 FCLV_LOOP2;
MX_UINT8 FCLV_LOOP3;
MX_UINT8 FCLV_LOOP4;
MX_UINT8 FCLV_LOOP5;
MX_UINT8 FCLV_LOOP6;
MX_UINT8 FCLV_LOOP7;
MX_UINT8 FCLV_LOOP8;
MX_UINT8 FCLV_LOOP9;
MX_UINT8 FCLV_LOOP10;
MX_UINT8 FCLV_LOOP11;



//PWM(0): //Defines:

/**** Macro Substitutions ****
a = Unique Reference
b = PWM Channel - 0=SW / 1-8=HW
c = PWM Alt Pin FCD_PWM0_Enable - 0=Standard / 1=Alt
d = PWM Period
e = PWM Prescaler 1
******************************/

//Period and Prescaler Defines
#ifndef MX_PWM_PERIOD
  #define MX_PWM_PERIOD				255
#else
  #if (MX_PWM_PERIOD != 255)
    #error "PWM period value must be the same in all PWM modules"
  #endif
#endif

#ifndef MX_PWM_PRESCALE1
  #define MX_PWM_PRESCALE1			1
#else
  #if (MX_PWM_PRESCALE1 != 1)
    #error "PWM prescale value must be the same in all PWM modules"
  #endif
#endif

//Definitions for PWM slot allocation
#ifndef	MX_PWM_REF1
			#define MX_PWM_REF1
			#define PWM_1_MX_PWM_UREF			1
			#define MX_PWM_CHANNEL_1		2
			#define MX_PWM_HWALT_1			0
#else
 #ifndef	MX_PWM_REF2
			#define MX_PWM_REF2
			#define PWM_1_MX_PWM_UREF			2
			#define MX_PWM_CHANNEL_2		2
			#define MX_PWM_HWALT_2			0
 #else
  #ifndef	MX_PWM_REF3
			#define MX_PWM_REF3
			#define PWM_1_MX_PWM_UREF			3
			#define MX_PWM_CHANNEL_3		2
			#define MX_PWM_HWALT_3			0
  #else
   #ifndef	MX_PWM_REF4
			#define MX_PWM_REF4
			#define PWM_1_MX_PWM_UREF			4
			#define MX_PWM_CHANNEL_4		2
			#define MX_PWM_HWALT_4			0
   #else
    #ifndef	MX_PWM_REF5
			#define MX_PWM_REF5
			#define PWM_1_MX_PWM_UREF			5
			#define MX_PWM_CHANNEL_5		2
			#define MX_PWM_HWALT_5			0
    #else
     #ifndef	MX_PWM_REF6
			#define MX_PWM_REF6
			#define PWM_1_MX_PWM_UREF			6
			#define MX_PWM_CHANNEL_6		2
			#define MX_PWM_HWALT_6			0
     #else
      #ifndef	MX_PWM_REF7
			#define MX_PWM_REF7
			#define PWM_1_MX_PWM_UREF			7
			#define MX_PWM_CHANNEL_7		2
			#define MX_PWM_HWALT_7			0
      #else
       #ifndef	MX_PWM_REF8
			#define MX_PWM_REF8
			#define PWM_1_MX_PWM_UREF			8
			#define MX_PWM_CHANNEL_8		2
			#define MX_PWM_HWALT_8			0
       #else
        #ifndef	MX_PWM_REF9
			#define MX_PWM_REF9
			#define PWM_1_MX_PWM_UREF			9
			#define MX_PWM_CHANNEL_9		2
			#define MX_PWM_HWALT_9			0
        #else
         #ifndef	MX_PWM_REF10
			#define MX_PWM_REF10
			#define PWM_1_MX_PWM_UREF			10
			#define MX_PWM_CHANNEL_10		2
			#define MX_PWM_HWALT_10			0
         #endif
        #endif
       #endif
      #endif
     #endif
    #endif
   #endif
  #endif
 #endif
#endif

#define PWM_1_PWM_Enable_Channel		CAL_APPEND(FC_CAL_PWM_Enable_Channel_, PWM_1_MX_PWM_UREF)
#define PWM_1_PWM_Disable_Channel		CAL_APPEND(FC_CAL_PWM_Disable_Channel_, PWM_1_MX_PWM_UREF)
#define PWM_1_PWM_Set_Duty_8Bit		CAL_APPEND(FC_CAL_PWM_Set_Duty_8Bit_, PWM_1_MX_PWM_UREF)
#define PWM_1_PWM_Change_Period		CAL_APPEND(FC_CAL_PWM_Change_Period_, PWM_1_MX_PWM_UREF)
#define PWM_1_PWM_Set_Duty_10Bit		CAL_APPEND(FC_CAL_PWM_Set_Duty_10Bit_, PWM_1_MX_PWM_UREF)

extern void PWM_1_PWM_Enable_Channel ();
extern void PWM_1_PWM_Disable_Channel ();
extern void PWM_1_PWM_Set_Duty_8Bit (MX_UINT8 duty);
extern void PWM_1_PWM_Change_Period (MX_UINT8 period, MX_UINT16 prescaler);
extern void PWM_1_PWM_Set_Duty_10Bit (MX_UINT16 duty);




//PWM(0): //Macro function declarations

void FCD_PWM0_Enable();
void FCD_PWM0_Disable();
void FCD_PWM0_SetDutyCycle(MX_UINT8 nDuty);
void FCD_PWM0_ChangePeriod(MX_UINT8 nPeriodVal, MX_UINT8 nPrescalerVal);
void FCD_PWM0_SetDutyCycle10bit(MX_SINT16 nDuty);


//LED(0): //Defines:

/**** Macro Substitutions ****
a = Unique Reference
b = LED Port Letter
c = LED Pin Number
d = LED Active Polarity
******************************/

#define LED_2__LED_PORT		porta
#define LED_2__LED_TRIS		trisa
#define LED_2__LED_PIN		5
#define LED_2__LED_POLE		1




//LED(0): //Macro function declarations

void FCD_LED0_LEDOn();
void FCD_LED0_LEDOff();


//LED(1): //Defines:

/**** Macro Substitutions ****
a = Unique Reference
b = LED Port Letter
c = LED Pin Number
d = LED Active Polarity
******************************/

#define LED_3__LED_PORT		portc
#define LED_3__LED_TRIS		trisc
#define LED_3__LED_PIN		5
#define LED_3__LED_POLE		1




//LED(1): //Macro function declarations

void FCD_LED1_LEDOn();
void FCD_LED1_LEDOff();


//I2C_Master(0): //Defines:

/**** Macro Substitutions ****
a = Unique component ID
b = I2C Channel - 0=SW, 1-4=HW
c = Baud Rate
d = SM BUS Enable 0/2
e = Slew Rate Enable 0/1
f = Bitbanged Data Port Letter
g = Bitbanged Data Pin
h = Bitbanged Clock Port Letter
i = Bitbanged Clock Pin
******************************/

//BMODE
//Bit 0 - Slew Control
//Bit 1 - SMBus Control

//Definitions for I2C slot allocation
#ifndef	MX_I2C_REF1
	#define MX_I2C_REF1
	#define I2CMASTER_5_MX_I2C_UREF			1
	#define MX_I2C_CHANNEL_1		1
	#define MX_I2C_SDA_PIN_1		4
	#define MX_I2C_SDA_PORT_1		portd
	#define MX_I2C_SDA_TRIS_1		trisd
	#define MX_I2C_SCL_PIN_1		3
	#define MX_I2C_SCL_PORT_1		portd
	#define MX_I2C_SCL_TRIS_1		trisd
	#define MX_I2C_BMODE_1			0 | 0
	#define MX_I2C_BAUD_1			100000
	#define MX_I2C_INT_1			0
#else
 #ifndef MX_I2C_REF2
	#define MX_I2C_REF2
	#define I2CMASTER_5_MX_I2C_UREF			2
	#define MX_I2C_CHANNEL_2		1
	#define MX_I2C_SDA_PIN_2		4
	#define MX_I2C_SDA_PORT_2		portd
	#define MX_I2C_SDA_TRIS_2		trisd
	#define MX_I2C_SCL_PIN_2		3
	#define MX_I2C_SCL_PORT_2		portd
	#define MX_I2C_SCL_TRIS_2		trisd
	#define MX_I2C_BMODE_2			0 | 0
	#define MX_I2C_BAUD_2			100000
	#define MX_I2C_INT_2			0
 #else
  #ifndef MX_I2C_REF3
	#define MX_I2C_REF3
	#define I2CMASTER_5_MX_I2C_UREF			3
	#define MX_I2C_CHANNEL_3		1
	#define MX_I2C_SDA_PIN_3		4
	#define MX_I2C_SDA_PORT_3		portd
	#define MX_I2C_SDA_TRIS_3		trisd
	#define MX_I2C_SCL_PIN_3		3
	#define MX_I2C_SCL_PORT_3		portd
	#define MX_I2C_SCL_TRIS_3		trisd
	#define MX_I2C_BMODE_3			0 | 0
	#define MX_I2C_BAUD_3			100000
	#define MX_I2C_INT_3			0
  #else
   #ifndef MX_I2C_REF4
	#define MX_I2C_REF4
	#define I2CMASTER_5_MX_I2C_UREF			4
	#define MX_I2C_CHANNEL_4		1
	#define MX_I2C_SDA_PIN_4		4
	#define MX_I2C_SDA_PORT_4		portd
	#define MX_I2C_SDA_TRIS_4		trisd
	#define MX_I2C_SCL_PIN_4		3
	#define MX_I2C_SCL_PORT_4		portd
	#define MX_I2C_SCL_TRIS_4		trisd
	#define MX_I2C_BMODE_4			0 | 0
	#define MX_I2C_BAUD_4			100000
	#define MX_I2C_INT_4			0
   #endif
  #endif
 #endif
#endif

#define I2CMASTER_5_I2C_Master_Init		CAL_APPEND(FC_CAL_I2C_Master_Init_, I2CMASTER_5_MX_I2C_UREF)
#define I2CMASTER_5_I2C_Master_Uninit	CAL_APPEND(FC_CAL_I2C_Master_Uninit_, I2CMASTER_5_MX_I2C_UREF)
#define I2CMASTER_5_I2C_Master_Start		CAL_APPEND(FC_CAL_I2C_Master_Start_, I2CMASTER_5_MX_I2C_UREF)
#define I2CMASTER_5_I2C_Master_Restart	CAL_APPEND(FC_CAL_I2C_Master_Restart_, I2CMASTER_5_MX_I2C_UREF)
#define I2CMASTER_5_I2C_Master_Stop		CAL_APPEND(FC_CAL_I2C_Master_Stop_, I2CMASTER_5_MX_I2C_UREF)
#define I2CMASTER_5_I2C_Master_TX_Byte	CAL_APPEND(FC_CAL_I2C_Master_TX_Byte_, I2CMASTER_5_MX_I2C_UREF)
#define I2CMASTER_5_I2C_Master_RX_Byte	CAL_APPEND(FC_CAL_I2C_Master_RX_Byte_, I2CMASTER_5_MX_I2C_UREF)

extern void I2CMASTER_5_I2C_Master_Init ();
extern void I2CMASTER_5_I2C_Master_Uninit ();
extern void I2CMASTER_5_I2C_Master_Start ();
extern void I2CMASTER_5_I2C_Master_Restart ();
extern void I2CMASTER_5_I2C_Master_Stop ();
extern MX_UINT8 I2CMASTER_5_I2C_Master_TX_Byte (MX_UINT8 Data);
extern MX_UINT8 I2CMASTER_5_I2C_Master_RX_Byte (MX_UINT8 Last);




//I2C_Master(0): //Macro function declarations

void FCD_I2C_Master0_MI2C_Init();
void FCD_I2C_Master0_MI2C_Start();
void FCD_I2C_Master0_MI2C_Restart();
void FCD_I2C_Master0_MI2C_Stop();
MX_UINT8 FCD_I2C_Master0_MI2C_Transmit_Byte(MX_UINT8 Data);
MX_UINT8 FCD_I2C_Master0_MI2C_Receive_Byte(MX_UINT8 Last);
void FCD_I2C_Master0_MI2C_Send_Byte_Transaction(MX_UINT8 Device_ID, MX_UINT8 AddrH, MX_UINT8 AddrL, MX_UINT8 Data);
MX_UINT8 FCD_I2C_Master0_MI2C_Receive_Byte_Transaction(MX_UINT8 Device_ID, MX_UINT8 AddrH, MX_UINT8 AddrL);


//EEPROM(0): //Defines:

/**** Macro Substitutions ****
Component has no substitutions
******************************/

#ifndef MX_EEPROM_REF
	#define MX_EEPROM_REF

	#ifdef FC_CAL_PIC16BIT
		extern MX_UINT16 FC_CAL_EE_Read (MX_UINT16 Address);
		extern void FC_CAL_EE_Write (MX_UINT16 Address, MX_UINT16 Data);
	#else
		extern MX_UINT8 FC_CAL_EE_Read (MX_UINT16 Address);
		extern void FC_CAL_EE_Write (MX_UINT16 Address, MX_UINT8 Data);
	#endif
#endif




//EEPROM(0): //Macro function declarations

MX_UINT16 FCD_EEPROM0_EEPROMRead(MX_UINT16 addr);
void FCD_EEPROM0_WriteEEPROM(MX_UINT16 addr, MX_UINT16 data);


//RS232(0): //Defines:

/**** Macro Substitutions ****
a = Unique Reference
b = Uart Channel		(0-software / 1-4 hardware)
c = tx pin
d = tx port
e = rx pin
f = rx port
g = flow control		(0-Off / 1-On)
h = cts pin
i = cts port
j = rts pin
k = rts port
l = baud rate
m = data bits			(7/8/9) (7 only supported in software modes)
n = return type		(0-byte / 1-MX_UINT16)
o = echo enable		(0-Off / 1-On)
******************************/

//Definitions for RS232 UART slot allocation
#ifndef	MX_UART_REF1
	#define MX_UART_REF1
	#define RS232_7_MX_UART_UREF			1
	#define MX_UART_CHANNEL_1		1
	#define MX_UART_TX_PIN_1		0
	#define MX_UART_TX_PORT_1		porta
	#define MX_UART_TX_TRIS_1		trisa
	#define MX_UART_RX_PIN_1		0
	#define MX_UART_RX_PORT_1		porta
	#define MX_UART_RX_TRIS_1		trisa
	#define MX_UART_FLOWEN_1		0
	#define MX_UART_CTS_PIN_1		4
	#define MX_UART_CTS_PORT_1		portc
	#define MX_UART_CTS_TRIS_1		trisc
	#define MX_UART_RTS_PIN_1		0
	#define MX_UART_RTS_PORT_1		portc
	#define MX_UART_RTS_TRIS_1		trisc
	#define MX_UART_BAUD_1			9600
	#define MX_UART_DBITS_1			8
	#define MX_UART_RETURN_1		0
	#define MX_UART_ECHO_1			0
	#define MX_UART_INT_1			0
#else
 #ifndef	MX_UART_REF2
	#define MX_UART_REF2
	#define RS232_7_MX_UART_UREF			2
	#define MX_UART_CHANNEL_2		1
	#define MX_UART_TX_PIN_2		0
	#define MX_UART_TX_PORT_2		porta
	#define MX_UART_TX_TRIS_2		trisa
	#define MX_UART_RX_PIN_2		0
	#define MX_UART_RX_PORT_2		porta
	#define MX_UART_RX_TRIS_2		trisa
	#define MX_UART_FLOWEN_2		0
	#define MX_UART_CTS_PIN_2		4
	#define MX_UART_CTS_PORT_2		portc
	#define MX_UART_CTS_TRIS_2		trisc
	#define MX_UART_RTS_PIN_2		0
	#define MX_UART_RTS_PORT_2		portc
	#define MX_UART_RTS_TRIS_2		trisc
	#define MX_UART_BAUD_2			9600
	#define MX_UART_DBITS_2			8
	#define MX_UART_RETURN_2		0
	#define MX_UART_ECHO_2			0
	#define MX_UART_INT_2			0
 #else
  #ifndef	MX_UART_REF3
	#define MX_UART_REF3
	#define RS232_7_MX_UART_UREF			3
	#define MX_UART_CHANNEL_3		1
	#define MX_UART_TX_PIN_3		0
	#define MX_UART_TX_PORT_3		porta
	#define MX_UART_TX_TRIS_3		trisa
	#define MX_UART_RX_PIN_3		0
	#define MX_UART_RX_PORT_3		porta
	#define MX_UART_RX_TRIS_3		trisa
	#define MX_UART_FLOWEN_3		0
	#define MX_UART_CTS_PIN_3		4
	#define MX_UART_CTS_PORT_3		portc
	#define MX_UART_CTS_TRIS_3		trisc
	#define MX_UART_RTS_PIN_3		0
	#define MX_UART_RTS_PORT_3		portc
	#define MX_UART_RTS_TRIS_3		trisc
	#define MX_UART_BAUD_3			9600
	#define MX_UART_DBITS_3			8
	#define MX_UART_RETURN_3		0
	#define MX_UART_ECHO_3			0
	#define MX_UART_INT_3			0
  #else
   #ifndef	MX_UART_REF4
	#define MX_UART_REF4
	#define RS232_7_MX_UART_UREF			4
	#define MX_UART_CHANNEL_4		1
	#define MX_UART_TX_PIN_4		0
	#define MX_UART_TX_PORT_4		porta
	#define MX_UART_TX_TRIS_4		trisa
	#define MX_UART_RX_PIN_4		0
	#define MX_UART_RX_PORT_4		porta
	#define MX_UART_RX_TRIS_4		trisa
	#define MX_UART_FLOWEN_4		0
	#define MX_UART_CTS_PIN_4		4
	#define MX_UART_CTS_PORT_4		portc
	#define MX_UART_CTS_TRIS_4		trisc
	#define MX_UART_RTS_PIN_4		0
	#define MX_UART_RTS_PORT_4		portc
	#define MX_UART_RTS_TRIS_4		trisc
	#define MX_UART_BAUD_4			9600
	#define MX_UART_DBITS_4			8
	#define MX_UART_RETURN_4		0
	#define MX_UART_ECHO_4			0
	#define MX_UART_INT_4			0
   #endif
  #endif
 #endif
#endif

#define RS232_7_UART_Init		CAL_APPEND(FC_CAL_UART_Init_, RS232_7_MX_UART_UREF)
#define RS232_7_UART_Send		CAL_APPEND(FC_CAL_UART_Send_, RS232_7_MX_UART_UREF)
#define RS232_7_UART_Receive		CAL_APPEND(FC_CAL_UART_Receive_, RS232_7_MX_UART_UREF)
#define RS232_7_UART_Update_Baud CAL_APPEND(FC_CAL_UART_Update_Baud_, RS232_7_MX_UART_UREF)

extern void RS232_7_UART_Init();
extern void RS232_7_UART_Send(MX_UINT16 nChar);
extern MX_SINT16 RS232_7_UART_Receive(MX_UINT8 nTimeout);
extern void RS232_7_UART_Update_Baud(MX_UINT8 newbaud);




//RS232(0): //Macro function declarations

void FCD_RS2320_SendRS232Char(MX_SINT16 nChar);
void FCD_RS2320_SendRS232String(MX_STRING String, MX_UINT8 MSZ_String);
MX_SINT16 FCD_RS2320_ReceiveRS232Char(MX_UINT8 nTimeout);
void FCD_RS2320_ReceiveRS232String(MX_CHAR* FCR_RETVAL, MX_UINT8 FCR_RETVAL_SIZE, MX_UINT8 nTimeout, MX_UINT8 NumBytes);
void FCD_RS2320_ChangeHWBaud(MX_UINT8 newbaud);



//PWM(0): //Macro implementations


void FCD_PWM0_Enable()

{
	
		PWM_1_PWM_Change_Period (MX_PWM_PERIOD, MX_PWM_PRESCALE1);
0776  30FF  	MOVLW 0xFF
0777  1283  	BCF STATUS, RP0
0778  1303  	BCF STATUS, RP1
0779  00F5  	MOVWF FC_CAL_PWM_0006C_arg_period
077A  3001  	MOVLW 0x01
077B  00F6  	MOVWF FC_CAL_PWM_0006C_arg_prescaler
077C  01F7  	CLRF FC_CAL_PWM_0006C_arg_prescaler+D'1'
077D  22E5  	CALL FC_CAL_PWM_0006C

		PWM_1_PWM_Enable_Channel ();
077E  2305  	CALL FC_CAL_PWM_00069


}
077F  0008  	RETURN


void FCD_PWM0_Disable()
{
	
		PWM_1_PWM_Disable_Channel();

}

void FCD_PWM0_SetDutyCycle(MX_UINT8 nDuty)

{
	
		PWM_1_PWM_Set_Duty_8Bit(nDuty);
0272  087D  	MOVF FCD_PWM0_S_00061_arg_nDuty, W
0273  00FE  	MOVWF FC_CAL_PWM_0006B_arg_duty
0274  2035  	CALL FC_CAL_PWM_0006B


}
0275  0008  	RETURN


void FCD_PWM0_ChangePeriod(MX_UINT8 nPeriodVal, MX_UINT8 nPrescalerVal)
{
	
		PWM_1_PWM_Change_Period (nPeriodVal, nPrescalerVal);

}

void FCD_PWM0_SetDutyCycle10bit(MX_SINT16 nDuty)
{
	
		PWM_1_PWM_Set_Duty_10Bit(nDuty);

}



//LED(0): //Macro implementations


void FCD_LED0_LEDOn()

{
	
		#if( LED_2__LED_POLE == 1)									//Active high polarity
			FC_CAL_Bit_High_DDR( LED_2__LED_PORT , LED_2__LED_TRIS , LED_2__LED_PIN );
0276  1683  	BSF STATUS, RP0
0277  1303  	BCF STATUS, RP1
0278  1285  	BCF gbl_trisa,5
0279  1283  	BCF STATUS, RP0
027A  1685  	BSF gbl_porta,5

		#else													//Active low polarity
			FC_CAL_Bit_Low_DDR( LED_2__LED_PORT , LED_2__LED_TRIS , LED_2__LED_PIN );
		#endif

}
027B  0008  	RETURN


void FCD_LED0_LEDOff()

{
	
		#if( LED_2__LED_POLE == 1)									//Active high polarity
			FC_CAL_Bit_Low_DDR( LED_2__LED_PORT	, LED_2__LED_TRIS , LED_2__LED_PIN );
0134  1683  	BSF STATUS, RP0
0135  1303  	BCF STATUS, RP1
0136  1285  	BCF gbl_trisa,5
0137  1283  	BCF STATUS, RP0
0138  1285  	BCF gbl_porta,5

		#else													//Active low polarity
			FC_CAL_Bit_High_DDR( LED_2__LED_PORT , LED_2__LED_TRIS , LED_2__LED_PIN );
		#endif

}
0139  0008  	RETURN




//LED(1): //Macro implementations


void FCD_LED1_LEDOn()

{
	
		#if( LED_3__LED_POLE == 1)									//Active high polarity
			FC_CAL_Bit_High_DDR( LED_3__LED_PORT , LED_3__LED_TRIS , LED_3__LED_PIN );
0622  1683  	BSF STATUS, RP0
0623  1303  	BCF STATUS, RP1
0624  1287  	BCF gbl_trisc,5
0625  1283  	BCF STATUS, RP0
0626  1687  	BSF gbl_portc,5

		#else													//Active low polarity
			FC_CAL_Bit_Low_DDR( LED_3__LED_PORT , LED_3__LED_TRIS , LED_3__LED_PIN );
		#endif

}
0627  0008  	RETURN


void FCD_LED1_LEDOff()

{
	
		#if( LED_3__LED_POLE == 1)									//Active high polarity
			FC_CAL_Bit_Low_DDR( LED_3__LED_PORT	, LED_3__LED_TRIS , LED_3__LED_PIN );
012E  1683  	BSF STATUS, RP0
012F  1303  	BCF STATUS, RP1
0130  1287  	BCF gbl_trisc,5
0131  1283  	BCF STATUS, RP0
0132  1287  	BCF gbl_portc,5

		#else													//Active low polarity
			FC_CAL_Bit_High_DDR( LED_3__LED_PORT , LED_3__LED_TRIS , LED_3__LED_PIN );
		#endif

}
0133  0008  	RETURN




//I2C_Master(0): //Macro implementations


void FCD_I2C_Master0_MI2C_Init()

{
	
		I2CMASTER_5_I2C_Master_Init();
0780  230D  	CALL FC_CAL_I2C_00073


}
0781  0008  	RETURN


void FCD_I2C_Master0_MI2C_Start()

{
	
		I2CMASTER_5_I2C_Master_Start();
028C  2070  	CALL FC_CAL_I2C_00075


}
028D  0008  	RETURN


void FCD_I2C_Master0_MI2C_Restart()

{
	
		I2CMASTER_5_I2C_Master_Restart();
0284  2068  	CALL FC_CAL_I2C_00076


}
0285  0008  	RETURN


void FCD_I2C_Master0_MI2C_Stop()

{
	
		I2CMASTER_5_I2C_Master_Stop();
027C  205C  	CALL FC_CAL_I2C_00077


}
027D  0008  	RETURN


MX_UINT8 FCD_I2C_Master0_MI2C_Transmit_Byte(MX_UINT8 Data)

{
	
		return I2CMASTER_5_I2C_Master_TX_Byte(Data);
0286  0875  	MOVF FCD_I2C_Ma_0005B_arg_Data, W
0287  00F6  	MOVWF FC_CAL_I2C_00078_arg_Data
0288  204D  	CALL FC_CAL_I2C_00078
0289  0877  	MOVF CompTempVarRet2287, W
028A  00F6  	MOVWF CompTempVarRet2244


}
028B  0008  	RETURN


MX_UINT8 FCD_I2C_Master0_MI2C_Receive_Byte(MX_UINT8 Last)

{
	
		return I2CMASTER_5_I2C_Master_RX_Byte(Last);
027E  0875  	MOVF FCD_I2C_Ma_0005D_arg_Last, W
027F  00F6  	MOVWF FC_CAL_I2C_00079_arg_Last
0280  2038  	CALL FC_CAL_I2C_00079
0281  0877  	MOVF CompTempVarRet2288, W
0282  00F6  	MOVWF CompTempVarRet2245


}
0283  0008  	RETURN


void FCD_I2C_Master0_MI2C_Send_Byte_Transaction(MX_UINT8 Device_ID, MX_UINT8 AddrH, MX_UINT8 AddrL, MX_UINT8 Data)
{
	
		Device_ID = Device_ID << 1;					//Shift Device ID to enable write mode

		I2CMASTER_5_I2C_Master_Start();						//Start transaction
		I2CMASTER_5_I2C_Master_TX_Byte(Device_ID);			//Transmit Device Address
		I2CMASTER_5_I2C_Master_TX_Byte(AddrH);				//Transmit Internal Address
		I2CMASTER_5_I2C_Master_TX_Byte(AddrL);
		I2CMASTER_5_I2C_Master_TX_Byte(Data);				//Send Data byte
		I2CMASTER_5_I2C_Master_Stop();						//Stop Transaction

}

MX_UINT8 FCD_I2C_Master0_MI2C_Receive_Byte_Transaction(MX_UINT8 Device_ID, MX_UINT8 AddrH, MX_UINT8 AddrL)
{
	
		MX_UINT8 RetVal = 0;
		Device_ID = Device_ID << 1;					//Shift Device ID to enable write mode

		I2CMASTER_5_I2C_Master_Start();						//Start transaction
		I2CMASTER_5_I2C_Master_TX_Byte(Device_ID);			//Transmit Device Address
		I2CMASTER_5_I2C_Master_TX_Byte(AddrH);				//Transmit Internal Address
		I2CMASTER_5_I2C_Master_TX_Byte(AddrL);
		I2CMASTER_5_I2C_Master_Restart();					//Restart transaction

		Device_ID = Device_ID | 0x01;				//Change Device ID to read mode
		I2CMASTER_5_I2C_Master_TX_Byte(Device_ID);			//Transmit Device Address
		RetVal = I2CMASTER_5_I2C_Master_RX_Byte(1);			//Read data at address
		I2CMASTER_5_I2C_Master_Stop();						//Stop Transaction

		return RetVal;								//Return data

}



//EEPROM(0): //Macro implementations


MX_UINT16 FCD_EEPROM0_EEPROMRead(MX_UINT16 addr)

{
	
		return (FC_CAL_EE_Read (addr));
0782  0875  	MOVF FCD_EEPROM_00080_arg_addr, W
0783  00F7  	MOVWF FC_CAL_EE__0007D_arg_Address
0784  0876  	MOVF FCD_EEPROM_00080_arg_addr+D'1', W
0785  00F8  	MOVWF FC_CAL_EE__0007D_arg_Address+D'1'
0786  231C  	CALL FC_CAL_EE__0007D
0787  087A  	MOVF CompTempVarRet2292, W
0788  00F7  	MOVWF CompTempVarRet2293
0789  01F8  	CLRF CompTempVarRet2293+D'1'


}
078A  0008  	RETURN


void FCD_EEPROM0_WriteEEPROM(MX_UINT16 addr, MX_UINT16 data)

{
	
		FC_CAL_EE_Write (addr, data);
0628  1283  	BCF STATUS, RP0
0629  087D  	MOVF FCD_EEPROM_00067_arg_addr, W
062A  1683  	BSF STATUS, RP0
062B  00A2  	MOVWF FC_CAL_EE__0007E_arg_Address
062C  1283  	BCF STATUS, RP0
062D  087E  	MOVF FCD_EEPROM_00067_arg_addr+D'1', W
062E  1683  	BSF STATUS, RP0
062F  00A3  	MOVWF FC_CAL_EE__0007E_arg_Address+D'1'
0630  0820  	MOVF FCD_EEPROM_00067_arg_data, W
0631  00A4  	MOVWF FC_CAL_EE__0007E_arg_Data
0632  21BD  	CALL FC_CAL_EE__0007E


}
0633  0008  	RETURN




//RS232(0): //Macro implementations


void FCD_RS2320_SendRS232Char(MX_SINT16 nChar)
{
	
		RS232_7_UART_Send ( nChar);

}

void FCD_RS2320_SendRS232String(MX_STRING String, MX_UINT8 MSZ_String)

{
	
		MX_UINT8 idx;
		for(idx = 0; idx < MSZ_String; idx++)
075B  01FD  	CLRF FCD_RS2320_00087_1_idx
075C        label95
075C  087C  	MOVF FCD_RS2320_00087_arg_MSZ_String, W
075D  027D  	SUBWF FCD_RS2320_00087_1_idx, W
075E  1803  	BTFSC STATUS,C
0774  0AFD  	INCF FCD_RS2320_00087_1_idx, F
0775  2F5C  	GOTO	label95

		{
			if (String[idx] == 0)
0760  1383  	BCF STATUS,IRP
0761  1876  	BTFSC FCD_RS2320_00087_arg_String+D'1',0
0762  1783  	BSF STATUS,IRP
0763  0875  	MOVF FCD_RS2320_00087_arg_String, W
0764  077D  	ADDWF FCD_RS2320_00087_1_idx, W
0765  0084  	MOVWF FSR
0766  0880  	MOVF INDF, F
0767  1903  	BTFSC STATUS,Z

				break;
			else RS232_7_UART_Send ( String[idx] );
0769  1383  	BCF STATUS,IRP
076A  1876  	BTFSC FCD_RS2320_00087_arg_String+D'1',0
076B  1783  	BSF STATUS,IRP
076C  0875  	MOVF FCD_RS2320_00087_arg_String, W
076D  077D  	ADDWF FCD_RS2320_00087_1_idx, W
076E  0084  	MOVWF FSR
076F  0800  	MOVF INDF, W
0770  1683  	BSF STATUS, RP0
0771  00A0  	MOVWF FC_CAL_UAR_00082_arg_nChar
0772  01A1  	CLRF FC_CAL_UAR_00082_arg_nChar+D'1'
0773  22DD  	CALL FC_CAL_UAR_00082

		}

}
075F  0008  	RETURN
0768  0008  	RETURN


MX_SINT16 FCD_RS2320_ReceiveRS232Char(MX_UINT8 nTimeout)

{
	
		return ( RS232_7_UART_Receive ( nTimeout) );
0750  0877  	MOVF FCD_RS2320_00088_arg_nTimeout, W
0751  00F8  	MOVWF FC_CAL_UAR_00083_arg_nTimeout
0752  228E  	CALL FC_CAL_UAR_00083
0753  0820  	MOVF CompTempVarRet2294, W
0754  1283  	BCF STATUS, RP0
0755  00F8  	MOVWF CompTempVarRet2299
0756  1683  	BSF STATUS, RP0
0757  0821  	MOVF CompTempVarRet2294+D'1', W
0758  1283  	BCF STATUS, RP0
0759  00F9  	MOVWF CompTempVarRet2299+D'1'


}
075A  0008  	RETURN


void FCD_RS2320_ReceiveRS232String(MX_CHAR* FCR_RETVAL, MX_UINT8 FCR_RETVAL_SIZE, MX_UINT8 nTimeout, MX_UINT8 NumBytes)
{
	
		MX_UINT8 idx;
		MX_SINT16 RS232_TO = 255;
		MX_SINT16 in;

		if ( 0 != 0 )
			RS232_TO = 256;

		if (NumBytes > FCR_RETVAL_SIZE)
			NumBytes = FCR_RETVAL_SIZE;

		for (idx = 0; idx < NumBytes; idx++)
		{
			in = RS232_7_UART_Receive ( nTimeout);
			if(in < RS232_TO)
				FCR_RETVAL[idx] = in & 0xFF;
			else
				break;
		}

		if (idx < FCR_RETVAL_SIZE)
			FCR_RETVAL[idx] = 0;

}

void FCD_RS2320_ChangeHWBaud(MX_UINT8 newbaud)
{
	
		RS232_7_UART_Update_Baud (newbaud);

}

#include "C:\Program Files (x86)\Flowcode\v5\CAL\includes.c"

//Macro implementations


void FCM_scan1()

{

	//Output
	//Output: 0 -> A0
	trisa = trisa & 0xFE;
0109  30FE  	MOVLW 0xFE
010A  1683  	BSF STATUS, RP0
010B  1303  	BCF STATUS, RP1
010C  0505  	ANDWF gbl_trisa, W
010D  0085  	MOVWF gbl_trisa

	if ((0))
		porta = (porta & 0xFE) | 0x01;
	else
		porta = porta & 0xFE;
010E  30FE  	MOVLW 0xFE
010F  1283  	BCF STATUS, RP0
0110  0505  	ANDWF gbl_porta, W
0111  0085  	MOVWF gbl_porta


	//Output
	//Output: 0 -> A1
	trisa = trisa & 0xFD;
0112  30FD  	MOVLW 0xFD
0113  1683  	BSF STATUS, RP0
0114  0505  	ANDWF gbl_trisa, W
0115  0085  	MOVWF gbl_trisa

	if ((0))
		porta = (porta & 0xFD) | 0x02;
	else
		porta = porta & 0xFD;
0116  30FD  	MOVLW 0xFD
0117  1283  	BCF STATUS, RP0
0118  0505  	ANDWF gbl_porta, W
0119  0085  	MOVWF gbl_porta


	//Output
	//Output: 0 -> A2
	trisa = trisa & 0xFB;
011A  30FB  	MOVLW 0xFB
011B  1683  	BSF STATUS, RP0
011C  0505  	ANDWF gbl_trisa, W
011D  0085  	MOVWF gbl_trisa

	if ((0))
		porta = (porta & 0xFB) | 0x04;
	else
		porta = porta & 0xFB;
011E  30FB  	MOVLW 0xFB
011F  1283  	BCF STATUS, RP0
0120  0505  	ANDWF gbl_porta, W
0121  0085  	MOVWF gbl_porta


	//Output
	//Output: 1 -> A3
	trisa = trisa & 0xF7;
0122  30F7  	MOVLW 0xF7
0123  1683  	BSF STATUS, RP0
0124  0505  	ANDWF gbl_trisa, W
0125  0085  	MOVWF gbl_trisa

	if ((1))
		porta = (porta & 0xF7) | 0x08;
0126  30F7  	MOVLW 0xF7
0127  1283  	BCF STATUS, RP0
0128  0505  	ANDWF gbl_porta, W
0129  00FD  	MOVWF CompTempVar2195
012A  3008  	MOVLW 0x08
012B  047D  	IORWF CompTempVar2195, W
012C  0085  	MOVWF gbl_porta

	else
		porta = porta & 0xF7;

}
012D  0008  	RETURN



void FCM_scan2()

{

	//Output
	//Output: 0 -> A0
	trisa = trisa & 0xFE;
00E4  30FE  	MOVLW 0xFE
00E5  1683  	BSF STATUS, RP0
00E6  1303  	BCF STATUS, RP1
00E7  0505  	ANDWF gbl_trisa, W
00E8  0085  	MOVWF gbl_trisa

	if ((0))
		porta = (porta & 0xFE) | 0x01;
	else
		porta = porta & 0xFE;
00E9  30FE  	MOVLW 0xFE
00EA  1283  	BCF STATUS, RP0
00EB  0505  	ANDWF gbl_porta, W
00EC  0085  	MOVWF gbl_porta


	//Output
	//Output: 0 -> A1
	trisa = trisa & 0xFD;
00ED  30FD  	MOVLW 0xFD
00EE  1683  	BSF STATUS, RP0
00EF  0505  	ANDWF gbl_trisa, W
00F0  0085  	MOVWF gbl_trisa

	if ((0))
		porta = (porta & 0xFD) | 0x02;
	else
		porta = porta & 0xFD;
00F1  30FD  	MOVLW 0xFD
00F2  1283  	BCF STATUS, RP0
00F3  0505  	ANDWF gbl_porta, W
00F4  0085  	MOVWF gbl_porta


	//Output
	//Output: 1 -> A2
	trisa = trisa & 0xFB;
00F5  30FB  	MOVLW 0xFB
00F6  1683  	BSF STATUS, RP0
00F7  0505  	ANDWF gbl_trisa, W
00F8  0085  	MOVWF gbl_trisa

	if ((1))
		porta = (porta & 0xFB) | 0x04;
00F9  30FB  	MOVLW 0xFB
00FA  1283  	BCF STATUS, RP0
00FB  0505  	ANDWF gbl_porta, W
00FC  00FD  	MOVWF CompTempVar2196
00FD  3004  	MOVLW 0x04
00FE  047D  	IORWF CompTempVar2196, W
00FF  0085  	MOVWF gbl_porta

	else
		porta = porta & 0xFB;

	//Output
	//Output: 0 -> A3
	trisa = trisa & 0xF7;
0100  30F7  	MOVLW 0xF7
0101  1683  	BSF STATUS, RP0
0102  0505  	ANDWF gbl_trisa, W
0103  0085  	MOVWF gbl_trisa

	if ((0))
		porta = (porta & 0xF7) | 0x08;
	else
		porta = porta & 0xF7;
0104  30F7  	MOVLW 0xF7
0105  1283  	BCF STATUS, RP0
0106  0505  	ANDWF gbl_porta, W
0107  0085  	MOVWF gbl_porta


}
0108  0008  	RETURN



void FCM_scan3()

{

	//Output
	//Output: 0 -> A0
	trisa = trisa & 0xFE;
00BF  30FE  	MOVLW 0xFE
00C0  1683  	BSF STATUS, RP0
00C1  1303  	BCF STATUS, RP1
00C2  0505  	ANDWF gbl_trisa, W
00C3  0085  	MOVWF gbl_trisa

	if ((0))
		porta = (porta & 0xFE) | 0x01;
	else
		porta = porta & 0xFE;
00C4  30FE  	MOVLW 0xFE
00C5  1283  	BCF STATUS, RP0
00C6  0505  	ANDWF gbl_porta, W
00C7  0085  	MOVWF gbl_porta


	//Output
	//Output: 1 -> A1
	trisa = trisa & 0xFD;
00C8  30FD  	MOVLW 0xFD
00C9  1683  	BSF STATUS, RP0
00CA  0505  	ANDWF gbl_trisa, W
00CB  0085  	MOVWF gbl_trisa

	if ((1))
		porta = (porta & 0xFD) | 0x02;
00CC  30FD  	MOVLW 0xFD
00CD  1283  	BCF STATUS, RP0
00CE  0505  	ANDWF gbl_porta, W
00CF  00FD  	MOVWF CompTempVar2197
00D0  3002  	MOVLW 0x02
00D1  047D  	IORWF CompTempVar2197, W
00D2  0085  	MOVWF gbl_porta

	else
		porta = porta & 0xFD;

	//Output
	//Output: 0 -> A2
	trisa = trisa & 0xFB;
00D3  30FB  	MOVLW 0xFB
00D4  1683  	BSF STATUS, RP0
00D5  0505  	ANDWF gbl_trisa, W
00D6  0085  	MOVWF gbl_trisa

	if ((0))
		porta = (porta & 0xFB) | 0x04;
	else
		porta = porta & 0xFB;
00D7  30FB  	MOVLW 0xFB
00D8  1283  	BCF STATUS, RP0
00D9  0505  	ANDWF gbl_porta, W
00DA  0085  	MOVWF gbl_porta


	//Output
	//Output: 0 -> A3
	trisa = trisa & 0xF7;
00DB  30F7  	MOVLW 0xF7
00DC  1683  	BSF STATUS, RP0
00DD  0505  	ANDWF gbl_trisa, W
00DE  0085  	MOVWF gbl_trisa

	if ((0))
		porta = (porta & 0xF7) | 0x08;
	else
		porta = porta & 0xF7;
00DF  30F7  	MOVLW 0xF7
00E0  1283  	BCF STATUS, RP0
00E1  0505  	ANDWF gbl_porta, W
00E2  0085  	MOVWF gbl_porta


}
00E3  0008  	RETURN



void FCM_scan4()

{

	//Output
	//Output: 1 -> A0
	trisa = trisa & 0xFE;
009A  30FE  	MOVLW 0xFE
009B  1683  	BSF STATUS, RP0
009C  1303  	BCF STATUS, RP1
009D  0505  	ANDWF gbl_trisa, W
009E  0085  	MOVWF gbl_trisa

	if ((1))
		porta = (porta & 0xFE) | 0x01;
009F  30FE  	MOVLW 0xFE
00A0  1283  	BCF STATUS, RP0
00A1  0505  	ANDWF gbl_porta, W
00A2  00FD  	MOVWF CompTempVar2198
00A3  3001  	MOVLW 0x01
00A4  047D  	IORWF CompTempVar2198, W
00A5  0085  	MOVWF gbl_porta

	else
		porta = porta & 0xFE;

	//Output
	//Output: 0 -> A1
	trisa = trisa & 0xFD;
00A6  30FD  	MOVLW 0xFD
00A7  1683  	BSF STATUS, RP0
00A8  0505  	ANDWF gbl_trisa, W
00A9  0085  	MOVWF gbl_trisa

	if ((0))
		porta = (porta & 0xFD) | 0x02;
	else
		porta = porta & 0xFD;
00AA  30FD  	MOVLW 0xFD
00AB  1283  	BCF STATUS, RP0
00AC  0505  	ANDWF gbl_porta, W
00AD  0085  	MOVWF gbl_porta


	//Output
	//Output: 0 -> A2
	trisa = trisa & 0xFB;
00AE  30FB  	MOVLW 0xFB
00AF  1683  	BSF STATUS, RP0
00B0  0505  	ANDWF gbl_trisa, W
00B1  0085  	MOVWF gbl_trisa

	if ((0))
		porta = (porta & 0xFB) | 0x04;
	else
		porta = porta & 0xFB;
00B2  30FB  	MOVLW 0xFB
00B3  1283  	BCF STATUS, RP0
00B4  0505  	ANDWF gbl_porta, W
00B5  0085  	MOVWF gbl_porta


	//Output
	//Output: 0 -> A3
	trisa = trisa & 0xF7;
00B6  30F7  	MOVLW 0xF7
00B7  1683  	BSF STATUS, RP0
00B8  0505  	ANDWF gbl_trisa, W
00B9  0085  	MOVWF gbl_trisa

	if ((0))
		porta = (porta & 0xF7) | 0x08;
	else
		porta = porta & 0xF7;
00BA  30F7  	MOVLW 0xF7
00BB  1283  	BCF STATUS, RP0
00BC  0505  	ANDWF gbl_porta, W
00BD  0085  	MOVWF gbl_porta


}
00BE  0008  	RETURN



void FCM_scan_off()

{

	//Output
	//Output: 0 -> A0
	trisa = trisa & 0xFE;
0078  30FE  	MOVLW 0xFE
0079  1683  	BSF STATUS, RP0
007A  1303  	BCF STATUS, RP1
007B  0505  	ANDWF gbl_trisa, W
007C  0085  	MOVWF gbl_trisa

	if ((0))
		porta = (porta & 0xFE) | 0x01;
	else
		porta = porta & 0xFE;
007D  30FE  	MOVLW 0xFE
007E  1283  	BCF STATUS, RP0
007F  0505  	ANDWF gbl_porta, W
0080  0085  	MOVWF gbl_porta


	//Output
	//Output: 0 -> A1
	trisa = trisa & 0xFD;
0081  30FD  	MOVLW 0xFD
0082  1683  	BSF STATUS, RP0
0083  0505  	ANDWF gbl_trisa, W
0084  0085  	MOVWF gbl_trisa

	if ((0))
		porta = (porta & 0xFD) | 0x02;
	else
		porta = porta & 0xFD;
0085  30FD  	MOVLW 0xFD
0086  1283  	BCF STATUS, RP0
0087  0505  	ANDWF gbl_porta, W
0088  0085  	MOVWF gbl_porta


	//Output
	//Output: 0 -> A2
	trisa = trisa & 0xFB;
0089  30FB  	MOVLW 0xFB
008A  1683  	BSF STATUS, RP0
008B  0505  	ANDWF gbl_trisa, W
008C  0085  	MOVWF gbl_trisa

	if ((0))
		porta = (porta & 0xFB) | 0x04;
	else
		porta = porta & 0xFB;
008D  30FB  	MOVLW 0xFB
008E  1283  	BCF STATUS, RP0
008F  0505  	ANDWF gbl_porta, W
0090  0085  	MOVWF gbl_porta


	//Output
	//Output: 0 -> A3
	trisa = trisa & 0xF7;
0091  30F7  	MOVLW 0xF7
0092  1683  	BSF STATUS, RP0
0093  0505  	ANDWF gbl_trisa, W
0094  0085  	MOVWF gbl_trisa

	if ((0))
		porta = (porta & 0xF7) | 0x08;
	else
		porta = porta & 0xF7;
0095  30F7  	MOVLW 0xF7
0096  1283  	BCF STATUS, RP0
0097  0505  	ANDWF gbl_porta, W
0098  0085  	MOVWF gbl_porta


}
0099  0008  	RETURN



void FCM_test()
{

	//Output
	//Output: 0 -> B0
	trisb = trisb & 0xFE;
	if ((0))
		portb = (portb & 0xFE) | 0x01;
	else
		portb = portb & 0xFE;

	//Delay
	//Delay: 1 s
	delay_s(1);

	//Output
	//Output: 1 -> B1
	trisb = trisb & 0xFD;
	if ((1))
		portb = (portb & 0xFD) | 0x02;
	else
		portb = portb & 0xFD;

	//Delay
	//Delay: 1 s
	delay_s(1);

	//Output
	//Output: 1 -> B2
	trisb = trisb & 0xFB;
	if ((1))
		portb = (portb & 0xFB) | 0x04;
	else
		portb = portb & 0xFB;

	//Delay
	//Delay: 1 s
	delay_s(1);

	//Output
	//Output: 1 -> B3
	trisb = trisb & 0xF7;
	if ((1))
		portb = (portb & 0xF7) | 0x08;
	else
		portb = portb & 0xF7;

	//Delay
	//Delay: 1 s
	delay_s(1);

	//Output
	//Output: 1 -> B4
	trisb = trisb & 0xEF;
	if ((1))
		portb = (portb & 0xEF) | 0x10;
	else
		portb = portb & 0xEF;

	//Delay
	//Delay: 1 s
	delay_s(1);

	//Output
	//Output: 1 -> B5
	trisb = trisb & 0xDF;
	if ((1))
		portb = (portb & 0xDF) | 0x20;
	else
		portb = portb & 0xDF;

	//Delay
	//Delay: 1 s
	delay_s(1);

	//Output
	//Output: 1 -> B6
	trisb = trisb & 0xBF;
	if ((1))
		portb = (portb & 0xBF) | 0x40;
	else
		portb = portb & 0xBF;

	//Delay
	//Delay: 1 s
	delay_s(1);

	//Output
	//Output: 1 -> B7
	trisb = trisb & 0x7F;
	if ((1))
		portb = (portb & 0x7F) | 0x80;
	else
		portb = portb & 0x7F;

	//Delay
	//Delay: 1 s
	delay_s(1);

}


void FCM_seg_pattern()

{

	//Switch
	//Switch: digit?
	switch (FCV_DIGIT)

	{
		case 1:
01E3  1283  	BCF STATUS, RP0
01E4  1303  	BCF STATUS, RP1
01E5  0861  	MOVF gbl_FCV_DIGIT, W
01E6  3A01  	XORLW 0x01
01E7  1903  	BTFSC STATUS,Z
01E8  2A05  	GOTO	label25
0205        label25

		{
			//Output
			//Output: 0b00010011 -> PORTB
			trisb = 0x00;
0205  1683  	BSF STATUS, RP0
0206  0186  	CLRF gbl_trisb

			portb = (19);
0207  3013  	MOVLW 0x13
0208  1283  	BCF STATUS, RP0
0209  0086  	MOVWF gbl_portb


			break;

		}
		case 2:
01E9  3A03  	XORLW 0x03
01EA  1903  	BTFSC STATUS,Z
01EB  2A0B  	GOTO	label26
020B        label26

		{
			//Output
			//Output: 0b10111101 -> PORTB
			trisb = 0x00;
020B  1683  	BSF STATUS, RP0
020C  0186  	CLRF gbl_trisb

			portb = (189);
020D  30BD  	MOVLW 0xBD
020E  1283  	BCF STATUS, RP0
020F  0086  	MOVWF gbl_portb


			break;

		}
		case 3:
01EC  3A01  	XORLW 0x01
01ED  1903  	BTFSC STATUS,Z
01EE  2A11  	GOTO	label27
0211        label27

		{
			//Output
			//Output: 0b10110111 -> PORTB
			trisb = 0x00;
0211  1683  	BSF STATUS, RP0
0212  0186  	CLRF gbl_trisb

			portb = (183);
0213  30B7  	MOVLW 0xB7
0214  1283  	BCF STATUS, RP0
0215  0086  	MOVWF gbl_portb


			break;

		}
		case 4:
01EF  3A07  	XORLW 0x07
01F0  1903  	BTFSC STATUS,Z
01F1  2A17  	GOTO	label28
0217        label28

		{
			//Output
			//Output: 0b11010011 -> PORTB
			trisb = 0x00;
0217  1683  	BSF STATUS, RP0
0218  0186  	CLRF gbl_trisb

			portb = (211);
0219  30D3  	MOVLW 0xD3
021A  1283  	BCF STATUS, RP0
021B  0086  	MOVWF gbl_portb


			break;

		}
		case 5:
01F2  3A01  	XORLW 0x01
01F3  1903  	BTFSC STATUS,Z
01F4  2A1D  	GOTO	label29
021D        label29

		{
			//Output
			//Output: 0b11100111 -> PORTB
			trisb = 0x00;
021D  1683  	BSF STATUS, RP0
021E  0186  	CLRF gbl_trisb

			portb = (231);
021F  30E7  	MOVLW 0xE7
0220  1283  	BCF STATUS, RP0
0221  0086  	MOVWF gbl_portb


			break;

		}
		case 6:
01F5  3A03  	XORLW 0x03
01F6  1903  	BTFSC STATUS,Z
01F7  2A23  	GOTO	label30
0223        label30

		{
			//Output
			//Output: 0b11101111 -> PORTB
			trisb = 0x00;
0223  1683  	BSF STATUS, RP0
0224  0186  	CLRF gbl_trisb

			portb = (239);
0225  30EF  	MOVLW 0xEF
0226  1283  	BCF STATUS, RP0
0227  0086  	MOVWF gbl_portb


			break;

		}
		case 7:
01F8  3A01  	XORLW 0x01
01F9  1903  	BTFSC STATUS,Z
01FA  2A29  	GOTO	label31
0229        label31

		{
			//Output
			//Output: 0b00110011 -> PORTB
			trisb = 0x00;
0229  1683  	BSF STATUS, RP0
022A  0186  	CLRF gbl_trisb

			portb = (51);
022B  3033  	MOVLW 0x33
022C  1283  	BCF STATUS, RP0
022D  0086  	MOVWF gbl_portb


			break;

		}
		case 8:
01FB  3A0F  	XORLW 0x0F
01FC  1903  	BTFSC STATUS,Z
01FD  2A2F  	GOTO	label32
022F        label32

		{
			//Output
			//Output: 0b11111111 -> PORTB
			trisb = 0x00;
022F  1683  	BSF STATUS, RP0
0230  0186  	CLRF gbl_trisb

			portb = (255);
0231  30FF  	MOVLW 0xFF
0232  1283  	BCF STATUS, RP0
0233  0086  	MOVWF gbl_portb


			break;

		}
		case 9:
01FE  3A01  	XORLW 0x01
01FF  1903  	BTFSC STATUS,Z
0200  2A35  	GOTO	label33
0235        label33

		{
			//Output
			//Output: 0b11110111 -> PORTB
			trisb = 0x00;
0235  1683  	BSF STATUS, RP0
0236  0186  	CLRF gbl_trisb

			portb = (247);
0237  30F7  	MOVLW 0xF7
0238  1283  	BCF STATUS, RP0
0239  0086  	MOVWF gbl_portb


			break;

		}
		case 0:
0201  3A09  	XORLW 0x09
0202  1903  	BTFSC STATUS,Z
0203  2A3B  	GOTO	label34
023B        label34

		{
			//Connection Point
			//Connection Point: [A]: A
FCC_seg_pattern_A:

;

			//Output
			//Output: 0b01111111 -> PORTB
			trisb = 0x00;
023B  1683  	BSF STATUS, RP0
023C  0186  	CLRF gbl_trisb

			portb = (127);
023D  307F  	MOVLW 0x7F
023E  1283  	BCF STATUS, RP0
023F  0086  	MOVWF gbl_portb


			break;

		}
		default:
0204  2A3B  	GOTO	label34

		{
			//Goto Connection Point
			//Goto Connection Point: [A]: A
			goto FCC_seg_pattern_A;


		}
	}

}
020A  0008  	RETURN
0210  0008  	RETURN
0216  0008  	RETURN
021C  0008  	RETURN
0222  0008  	RETURN
0228  0008  	RETURN
022E  0008  	RETURN
0234  0008  	RETURN
023A  0008  	RETURN
0240  0008  	RETURN



void FCM_display_temp()

{

	//Calculation
	//Calculation:
	//  temp_tens = temp_c / 10
	//  temp_ones = temp_c MOD 10
	//  temp_dec = temp_cdp
	FCV_TEMP_TENS = FCV_TEMP_C / 10;
044D  1683  	BSF STATUS, RP0
044E  1303  	BCF STATUS, RP1
044F  01A8  	CLRF CompTempVar2207
0450  1283  	BCF STATUS, RP0
0451  0838  	MOVF gbl_FCV_TEMP_C, W
0452  1683  	BSF STATUS, RP0
0453  00A0  	MOVWF __div_32_3_00001_arg_a
0454  1283  	BCF STATUS, RP0
0455  0839  	MOVF gbl_FCV_TEMP_C+D'1', W
0456  1683  	BSF STATUS, RP0
0457  00A1  	MOVWF __div_32_3_00001_arg_a+D'1'
0458  1283  	BCF STATUS, RP0
0459  083A  	MOVF gbl_FCV_TEMP_C+D'2', W
045A  1683  	BSF STATUS, RP0
045B  00A2  	MOVWF __div_32_3_00001_arg_a+D'2'
045C  1283  	BCF STATUS, RP0
045D  083B  	MOVF gbl_FCV_TEMP_C+D'3', W
045E  1683  	BSF STATUS, RP0
045F  00A3  	MOVWF __div_32_3_00001_arg_a+D'3'
0460  1283  	BCF STATUS, RP0
0461  1FBB  	BTFSS gbl_FCV_TEMP_C+D'3',7
0462  2C70  	GOTO	label63
0463  1683  	BSF STATUS, RP0
0464  09A0  	COMF __div_32_3_00001_arg_a, F
0465  09A1  	COMF __div_32_3_00001_arg_a+D'1', F
0466  09A2  	COMF __div_32_3_00001_arg_a+D'2', F
0467  09A3  	COMF __div_32_3_00001_arg_a+D'3', F
0468  0AA0  	INCF __div_32_3_00001_arg_a, F
0469  1903  	BTFSC STATUS,Z
046A  0AA1  	INCF __div_32_3_00001_arg_a+D'1', F
046B  1903  	BTFSC STATUS,Z
046C  0AA2  	INCF __div_32_3_00001_arg_a+D'2', F
046D  1903  	BTFSC STATUS,Z
046E  0AA3  	INCF __div_32_3_00001_arg_a+D'3', F
046F  0AA8  	INCF CompTempVar2207, F
0470        label63
0470  300A  	MOVLW 0x0A
0471  1683  	BSF STATUS, RP0
0472  00A4  	MOVWF __div_32_3_00001_arg_b
0473  01A5  	CLRF __div_32_3_00001_arg_b+D'1'
0474  01A6  	CLRF __div_32_3_00001_arg_b+D'2'
0475  01A7  	CLRF __div_32_3_00001_arg_b+D'3'
0476  2184  	CALL __div_32_3_00001
0477  0831  	MOVF CompTempVarRet210, W
0478  1283  	BCF STATUS, RP0
0479  00D2  	MOVWF gbl_FCV_TEMP_TENS
047A  1683  	BSF STATUS, RP0
047B  1C28  	BTFSS CompTempVar2207,0
047C  2C80  	GOTO	label64
047D  1283  	BCF STATUS, RP0
047E  09D2  	COMF gbl_FCV_TEMP_TENS, F
047F  0AD2  	INCF gbl_FCV_TEMP_TENS, F
0480        label64

	FCV_TEMP_ONES = FCV_TEMP_C % 10;
0480  1283  	BCF STATUS, RP0
0481  0838  	MOVF gbl_FCV_TEMP_C, W
0482  1683  	BSF STATUS, RP0
0483  00A0  	MOVWF __rem_32_3_00002_arg_a
0484  1283  	BCF STATUS, RP0
0485  0839  	MOVF gbl_FCV_TEMP_C+D'1', W
0486  1683  	BSF STATUS, RP0
0487  00A1  	MOVWF __rem_32_3_00002_arg_a+D'1'
0488  1283  	BCF STATUS, RP0
0489  083A  	MOVF gbl_FCV_TEMP_C+D'2', W
048A  1683  	BSF STATUS, RP0
048B  00A2  	MOVWF __rem_32_3_00002_arg_a+D'2'
048C  1283  	BCF STATUS, RP0
048D  083B  	MOVF gbl_FCV_TEMP_C+D'3', W
048E  1683  	BSF STATUS, RP0
048F  00A3  	MOVWF __rem_32_3_00002_arg_a+D'3'
0490  1283  	BCF STATUS, RP0
0491  1FBB  	BTFSS gbl_FCV_TEMP_C+D'3',7
0492  2C9F  	GOTO	label65
0493  1683  	BSF STATUS, RP0
0494  09A0  	COMF __rem_32_3_00002_arg_a, F
0495  09A1  	COMF __rem_32_3_00002_arg_a+D'1', F
0496  09A2  	COMF __rem_32_3_00002_arg_a+D'2', F
0497  09A3  	COMF __rem_32_3_00002_arg_a+D'3', F
0498  0AA0  	INCF __rem_32_3_00002_arg_a, F
0499  1903  	BTFSC STATUS,Z
049A  0AA1  	INCF __rem_32_3_00002_arg_a+D'1', F
049B  1903  	BTFSC STATUS,Z
049C  0AA2  	INCF __rem_32_3_00002_arg_a+D'2', F
049D  1903  	BTFSC STATUS,Z
049E  0AA3  	INCF __rem_32_3_00002_arg_a+D'3', F
049F        label65
049F  300A  	MOVLW 0x0A
04A0  1683  	BSF STATUS, RP0
04A1  00A4  	MOVWF __rem_32_3_00002_arg_b
04A2  01A5  	CLRF __rem_32_3_00002_arg_b+D'1'
04A3  01A6  	CLRF __rem_32_3_00002_arg_b+D'2'
04A4  01A7  	CLRF __rem_32_3_00002_arg_b+D'3'
04A5  213A  	CALL __rem_32_3_00002
04A6  082D  	MOVF CompTempVarRet212, W
04A7  1283  	BCF STATUS, RP0
04A8  00DC  	MOVWF gbl_FCV_TEMP_ONES
04A9  1FBB  	BTFSS gbl_FCV_TEMP_C+D'3',7
04AA  2CAD  	GOTO	label66
04AB  09DC  	COMF gbl_FCV_TEMP_ONES, F
04AC  0ADC  	INCF gbl_FCV_TEMP_ONES, F
04AD        label66

	FCV_TEMP_DEC = FCV_TEMP_CDP;
04AD  0841  	MOVF gbl_FCV_TEMP_CDP, W
04AE  00DA  	MOVWF gbl_FCV_TEMP_DEC


	//Output
	//Output: 0b00000001 -> PORTB
	trisb = 0x00;
04AF  1683  	BSF STATUS, RP0
04B0  0186  	CLRF gbl_trisb

	portb = (1);
04B1  3001  	MOVLW 0x01
04B2  1283  	BCF STATUS, RP0
04B3  0086  	MOVWF gbl_portb


	//Call Macro
	//Call Macro: scan_off()
	FCM_scan_off();
04B4  2078  	CALL FCM_scan_o_00051


	//Call Macro
	//Call Macro: scan1()
	FCM_scan1();
04B5  2109  	CALL FCM_scan1_00000


	//Calculation
	//Calculation:
	//  digit = temp_tens
	FCV_DIGIT = FCV_TEMP_TENS;
04B6  0852  	MOVF gbl_FCV_TEMP_TENS, W
04B7  00E1  	MOVWF gbl_FCV_DIGIT


	//Call Macro
	//Call Macro: seg_pattern()
	FCM_seg_pattern();
04B8  21E3  	CALL FCM_seg_pa_00052


	//Delay
	//Delay: 4 ms
	delay_ms(4);
04B9  3004  	MOVLW 0x04
04BA  00FD  	MOVWF delay_ms_00000_arg_del
04BB  2010  	CALL delay_ms_00000


	//Output
	//Output: 0b00000001 -> PORTB
	trisb = 0x00;
04BC  1683  	BSF STATUS, RP0
04BD  0186  	CLRF gbl_trisb

	portb = (1);
04BE  3001  	MOVLW 0x01
04BF  1283  	BCF STATUS, RP0
04C0  0086  	MOVWF gbl_portb


	//Call Macro
	//Call Macro: scan_off()
	FCM_scan_off();
04C1  2078  	CALL FCM_scan_o_00051


	//Call Macro
	//Call Macro: scan2()
	FCM_scan2();
04C2  20E4  	CALL FCM_scan2_00000


	//Calculation
	//Calculation:
	//  digit = temp_ones
	FCV_DIGIT = FCV_TEMP_ONES;
04C3  085C  	MOVF gbl_FCV_TEMP_ONES, W
04C4  00E1  	MOVWF gbl_FCV_DIGIT


	//Call Macro
	//Call Macro: seg_pattern()
	FCM_seg_pattern();
04C5  21E3  	CALL FCM_seg_pa_00052


	//Output
	//Output: 0 -> B0
	trisb = trisb & 0xFE;
04C6  30FE  	MOVLW 0xFE
04C7  1683  	BSF STATUS, RP0
04C8  0506  	ANDWF gbl_trisb, W
04C9  0086  	MOVWF gbl_trisb

	if ((0))
		portb = (portb & 0xFE) | 0x01;
	else
		portb = portb & 0xFE;
04CA  30FE  	MOVLW 0xFE
04CB  1283  	BCF STATUS, RP0
04CC  0506  	ANDWF gbl_portb, W
04CD  0086  	MOVWF gbl_portb


	//Delay
	//Delay: 4 ms
	delay_ms(4);
04CE  3004  	MOVLW 0x04
04CF  00FD  	MOVWF delay_ms_00000_arg_del
04D0  2010  	CALL delay_ms_00000


	//Output
	//Output: 0b00000001 -> PORTB
	trisb = 0x00;
04D1  1683  	BSF STATUS, RP0
04D2  0186  	CLRF gbl_trisb

	portb = (1);
04D3  3001  	MOVLW 0x01
04D4  1283  	BCF STATUS, RP0
04D5  0086  	MOVWF gbl_portb


	//Call Macro
	//Call Macro: scan_off()
	FCM_scan_off();
04D6  2078  	CALL FCM_scan_o_00051


	//Call Macro
	//Call Macro: scan3()
	FCM_scan3();
04D7  20BF  	CALL FCM_scan3_00000


	//Calculation
	//Calculation:
	//  digit = temp_dec
	FCV_DIGIT = FCV_TEMP_DEC;
04D8  085A  	MOVF gbl_FCV_TEMP_DEC, W
04D9  00E1  	MOVWF gbl_FCV_DIGIT


	//Call Macro
	//Call Macro: seg_pattern()
	FCM_seg_pattern();
04DA  21E3  	CALL FCM_seg_pa_00052


	//Delay
	//Delay: 4 ms
	delay_ms(4);
04DB  3004  	MOVLW 0x04
04DC  00FD  	MOVWF delay_ms_00000_arg_del
04DD  2010  	CALL delay_ms_00000


	//Output
	//Output: 0b00000001 -> PORTB
	trisb = 0x00;
04DE  1683  	BSF STATUS, RP0
04DF  0186  	CLRF gbl_trisb

	portb = (1);
04E0  3001  	MOVLW 0x01
04E1  1283  	BCF STATUS, RP0
04E2  0086  	MOVWF gbl_portb


	//Call Macro
	//Call Macro: scan_off()
	FCM_scan_off();
04E3  2078  	CALL FCM_scan_o_00051


	//Call Macro
	//Call Macro: scan4()
	FCM_scan4();
04E4  209A  	CALL FCM_scan4_00000


	//Output
	//Output: 0b11100000 -> PORTB
	trisb = 0x00;
04E5  1683  	BSF STATUS, RP0
04E6  0186  	CLRF gbl_trisb

	portb = (224);
04E7  30E0  	MOVLW 0xE0
04E8  1283  	BCF STATUS, RP0
04E9  0086  	MOVWF gbl_portb


	//Delay
	//Delay: 4 ms
	delay_ms(4);
04EA  3004  	MOVLW 0x04
04EB  00FD  	MOVWF delay_ms_00000_arg_del
04EC  2010  	CALL delay_ms_00000


}
04ED  0008  	RETURN



void FCM_all_input()

{

	//Input
	//Input: C0 -> prox_bit
	trisc = trisc | 0x01;
05F2  3001  	MOVLW 0x01
05F3  1683  	BSF STATUS, RP0
05F4  1303  	BCF STATUS, RP1
05F5  0407  	IORWF gbl_trisc, W
05F6  0087  	MOVWF gbl_trisc

	FCV_PROX_BIT = ((portc & 0x01) == 0x01);
05F7  3001  	MOVLW 0x01
05F8  1283  	BCF STATUS, RP0
05F9  0507  	ANDWF gbl_portc, W
05FA  00FD  	MOVWF CompTempVar2209
05FB  01FE  	CLRF CompTempVar2210
05FC  037D  	DECF CompTempVar2209, W
05FD  1903  	BTFSC STATUS,Z
05FE  0AFE  	INCF CompTempVar2210, F
05FF  105B  	BCF gbl_FCV_PROX_BIT,0
0600  087E  	MOVF CompTempVar2210, W
0601  1D03  	BTFSS STATUS,Z
0602  145B  	BSF gbl_FCV_PROX_BIT,0


	//Input
	//Input: A4 -> swg
	trisa = trisa | 0x10;
0603  3010  	MOVLW 0x10
0604  1683  	BSF STATUS, RP0
0605  0405  	IORWF gbl_trisa, W
0606  0085  	MOVWF gbl_trisa

	FCV_SWG = ((porta & 0x10) == 0x10);
0607  3010  	MOVLW 0x10
0608  1283  	BCF STATUS, RP0
0609  0505  	ANDWF gbl_porta, W
060A  00FD  	MOVWF CompTempVar2211
060B  01FE  	CLRF CompTempVar2212
060C  3010  	MOVLW 0x10
060D  027D  	SUBWF CompTempVar2211, W
060E  1903  	BTFSC STATUS,Z
060F  0AFE  	INCF CompTempVar2212, F
0610  11DB  	BCF gbl_FCV_SWG,3
0611  087E  	MOVF CompTempVar2212, W
0612  1D03  	BTFSS STATUS,Z
0613  15DB  	BSF gbl_FCV_SWG,3


	//Input
	//Input: C2 -> swr
	trisc = trisc | 0x04;
0614  3004  	MOVLW 0x04
0615  1683  	BSF STATUS, RP0
0616  0407  	IORWF gbl_trisc, W
0617  0087  	MOVWF gbl_trisc

	FCV_SWR = ((portc & 0x04) == 0x04);
0618  3004  	MOVLW 0x04
0619  1283  	BCF STATUS, RP0
061A  0507  	ANDWF gbl_portc, W
061B  00FD  	MOVWF CompTempVar2213
061C  01E2  	CLRF gbl_FCV_SWR
061D  3004  	MOVLW 0x04
061E  027D  	SUBWF CompTempVar2213, W
061F  1903  	BTFSC STATUS,Z
0620  0AE2  	INCF gbl_FCV_SWR, F


}
0621  0008  	RETURN



void FCM_pass()

{

	//Call Component Macro
	//Call Component Macro: LEDOff()
	FCD_LED0_LEDOff();
0643  2134  	CALL FCD_LED0_L_00055


	//Call Component Macro
	//Call Component Macro: LEDOn()
	FCD_LED1_LEDOn();
0644  2622  	CALL FCD_LED1_L_00056


}
0645  0008  	RETURN



void FCM_failed()

{

	//Call Component Macro
	//Call Component Macro: LEDOn()
	FCD_LED0_LEDOn();
03A9  2276  	CALL FCD_LED0_L_00057


	//Call Component Macro
	//Call Component Macro: LEDOff()
	FCD_LED1_LEDOff();
03AA  212E  	CALL FCD_LED1_L_00058


}
03AB  0008  	RETURN



void FCM_calc()

{

	//Calculation
	//Calculation:
	//  lsb = data0
	//  msb = data1
	FCV_LSB = FCV_DATA0;
04EE  1283  	BCF STATUS, RP0
04EF  1303  	BCF STATUS, RP1
04F0  0854  	MOVF gbl_FCV_DATA0, W
04F1  00DD  	MOVWF gbl_FCV_LSB

	FCV_MSB = FCV_DATA1;
04F2  0855  	MOVF gbl_FCV_DATA1, W
04F3  00E0  	MOVWF gbl_FCV_MSB


	//Calculation
	//Calculation:
	//  raw = msb
	FCV_RAW = FCV_MSB;
04F4  0860  	MOVF gbl_FCV_MSB, W
04F5  00B4  	MOVWF gbl_FCV_RAW
04F6  01B5  	CLRF gbl_FCV_RAW+D'1'
04F7  01B6  	CLRF gbl_FCV_RAW+D'2'
04F8  01B7  	CLRF gbl_FCV_RAW+D'3'


	//Loop
	//Loop: Loop 8 times
	for (FCLV_LOOP3=0; FCLV_LOOP3<8; FCLV_LOOP3++)
04F9  01EC  	CLRF gbl_FCLV_LOOP3
04FA        label67
04FA  3008  	MOVLW 0x08
04FB  026C  	SUBWF gbl_FCLV_LOOP3, W
04FC  1803  	BTFSC STATUS,C
04FD  2D09  	GOTO	label68
0507  0AEC  	INCF gbl_FCLV_LOOP3, F
0508  2CFA  	GOTO	label67
0509        label68

	{

		//Calculation
		//Calculation:
		//  raw = raw << 1
		FCV_RAW = FCV_RAW << 1;
04FE  08B4  	MOVF gbl_FCV_RAW, F
04FF  08B5  	MOVF gbl_FCV_RAW+D'1', F
0500  08B6  	MOVF gbl_FCV_RAW+D'2', F
0501  08B7  	MOVF gbl_FCV_RAW+D'3', F
0502  1003  	BCF STATUS,C
0503  0DB4  	RLF gbl_FCV_RAW, F
0504  0DB5  	RLF gbl_FCV_RAW+D'1', F
0505  0DB6  	RLF gbl_FCV_RAW+D'2', F
0506  0DB7  	RLF gbl_FCV_RAW+D'3', F



	}

	//Calculation
	//Calculation:
	//  raw = raw + lsb
	FCV_RAW = FCV_RAW + FCV_LSB;
0509  085D  	MOVF gbl_FCV_LSB, W
050A  00F5  	MOVWF CompTempVar2221
050B  01F6  	CLRF CompTempVar2222
050C  01F7  	CLRF CompTempVar2223
050D  01F8  	CLRF CompTempVar2224
050E  0834  	MOVF gbl_FCV_RAW, W
050F  07F5  	ADDWF CompTempVar2221, F
0510  0835  	MOVF gbl_FCV_RAW+D'1', W
0511  1803  	BTFSC STATUS,C
0512  0F35  	INCFSZ gbl_FCV_RAW+D'1', W
0513  07F6  	ADDWF CompTempVar2222, F
0514  0836  	MOVF gbl_FCV_RAW+D'2', W
0515  1803  	BTFSC STATUS,C
0516  0F36  	INCFSZ gbl_FCV_RAW+D'2', W
0517  07F7  	ADDWF CompTempVar2223, F
0518  0837  	MOVF gbl_FCV_RAW+D'3', W
0519  1803  	BTFSC STATUS,C
051A  0F37  	INCFSZ gbl_FCV_RAW+D'3', W
051B  07F8  	ADDWF CompTempVar2224, F
051C  0875  	MOVF CompTempVar2221, W
051D  00B4  	MOVWF gbl_FCV_RAW
051E  0876  	MOVF CompTempVar2222, W
051F  00B5  	MOVWF gbl_FCV_RAW+D'1'
0520  0877  	MOVF CompTempVar2223, W
0521  00B6  	MOVWF gbl_FCV_RAW+D'2'
0522  0878  	MOVF CompTempVar2224, W
0523  00B7  	MOVWF gbl_FCV_RAW+D'3'


	//Calculation
	//Calculation:
	//  temp_c = (raw / 50) - calib_subtractor
	FCV_TEMP_C = (FCV_RAW / 50) - FCV_CALIB_SUBTRACTOR;
0524  01FD  	CLRF CompTempVar2234
0525  0834  	MOVF gbl_FCV_RAW, W
0526  1683  	BSF STATUS, RP0
0527  00A0  	MOVWF __div_32_3_00001_arg_a
0528  1283  	BCF STATUS, RP0
0529  0835  	MOVF gbl_FCV_RAW+D'1', W
052A  1683  	BSF STATUS, RP0
052B  00A1  	MOVWF __div_32_3_00001_arg_a+D'1'
052C  1283  	BCF STATUS, RP0
052D  0836  	MOVF gbl_FCV_RAW+D'2', W
052E  1683  	BSF STATUS, RP0
052F  00A2  	MOVWF __div_32_3_00001_arg_a+D'2'
0530  1283  	BCF STATUS, RP0
0531  0837  	MOVF gbl_FCV_RAW+D'3', W
0532  1683  	BSF STATUS, RP0
0533  00A3  	MOVWF __div_32_3_00001_arg_a+D'3'
0534  1283  	BCF STATUS, RP0
0535  1FB7  	BTFSS gbl_FCV_RAW+D'3',7
0536  2D45  	GOTO	label69
0537  1683  	BSF STATUS, RP0
0538  09A0  	COMF __div_32_3_00001_arg_a, F
0539  09A1  	COMF __div_32_3_00001_arg_a+D'1', F
053A  09A2  	COMF __div_32_3_00001_arg_a+D'2', F
053B  09A3  	COMF __div_32_3_00001_arg_a+D'3', F
053C  0AA0  	INCF __div_32_3_00001_arg_a, F
053D  1903  	BTFSC STATUS,Z
053E  0AA1  	INCF __div_32_3_00001_arg_a+D'1', F
053F  1903  	BTFSC STATUS,Z
0540  0AA2  	INCF __div_32_3_00001_arg_a+D'2', F
0541  1903  	BTFSC STATUS,Z
0542  0AA3  	INCF __div_32_3_00001_arg_a+D'3', F
0543  1283  	BCF STATUS, RP0
0544  0AFD  	INCF CompTempVar2234, F
0545        label69
0545  3032  	MOVLW 0x32
0546  1683  	BSF STATUS, RP0
0547  00A4  	MOVWF __div_32_3_00001_arg_b
0548  01A5  	CLRF __div_32_3_00001_arg_b+D'1'
0549  01A6  	CLRF __div_32_3_00001_arg_b+D'2'
054A  01A7  	CLRF __div_32_3_00001_arg_b+D'3'
054B  2184  	CALL __div_32_3_00001
054C  0831  	MOVF CompTempVarRet210, W
054D  1283  	BCF STATUS, RP0
054E  00B8  	MOVWF gbl_FCV_TEMP_C
054F  1683  	BSF STATUS, RP0
0550  0832  	MOVF CompTempVarRet210+D'1', W
0551  1283  	BCF STATUS, RP0
0552  00B9  	MOVWF gbl_FCV_TEMP_C+D'1'
0553  1683  	BSF STATUS, RP0
0554  0833  	MOVF CompTempVarRet210+D'2', W
0555  1283  	BCF STATUS, RP0
0556  00BA  	MOVWF gbl_FCV_TEMP_C+D'2'
0557  1683  	BSF STATUS, RP0
0558  0834  	MOVF CompTempVarRet210+D'3', W
0559  1283  	BCF STATUS, RP0
055A  00BB  	MOVWF gbl_FCV_TEMP_C+D'3'
055B  1C7D  	BTFSS CompTempVar2234,0
055C  2D68  	GOTO	label70
055D  09B8  	COMF gbl_FCV_TEMP_C, F
055E  09B9  	COMF gbl_FCV_TEMP_C+D'1', F
055F  09BA  	COMF gbl_FCV_TEMP_C+D'2', F
0560  09BB  	COMF gbl_FCV_TEMP_C+D'3', F
0561  0AB8  	INCF gbl_FCV_TEMP_C, F
0562  1903  	BTFSC STATUS,Z
0563  0AB9  	INCF gbl_FCV_TEMP_C+D'1', F
0564  1903  	BTFSC STATUS,Z
0565  0ABA  	INCF gbl_FCV_TEMP_C+D'2', F
0566  1903  	BTFSC STATUS,Z
0567  0ABB  	INCF gbl_FCV_TEMP_C+D'3', F
0568        label70
0568  0843  	MOVF gbl_FCV_CALIB_SUBTRACTOR, W
0569  1683  	BSF STATUS, RP0
056A  00A8  	MOVWF CompTempVar2225
056B  1283  	BCF STATUS, RP0
056C  0844  	MOVF gbl_FCV_CALIB_SUBTRACTOR+D'1', W
056D  1683  	BSF STATUS, RP0
056E  00A9  	MOVWF CompTempVar2225+D'1'
056F  01AA  	CLRF CompTempVar2225+D'2'
0570  01AB  	CLRF CompTempVar2225+D'3'
0571  0828  	MOVF CompTempVar2225, W
0572  1283  	BCF STATUS, RP0
0573  02B8  	SUBWF gbl_FCV_TEMP_C, F
0574  1683  	BSF STATUS, RP0
0575  0829  	MOVF CompTempVar2225+D'1', W
0576  1803  	BTFSC STATUS,C
0577  2D7B  	GOTO	label71
0578  0F29  	INCFSZ CompTempVar2225+D'1', W
0579  2D7B  	GOTO	label71
057A  2D7D  	GOTO	label72
057B        label71
057B  1283  	BCF STATUS, RP0
057C  02B9  	SUBWF gbl_FCV_TEMP_C+D'1', F
057D        label72
057D  1683  	BSF STATUS, RP0
057E  082A  	MOVF CompTempVar2225+D'2', W
057F  1803  	BTFSC STATUS,C
0580  2D84  	GOTO	label73
0581  0F2A  	INCFSZ CompTempVar2225+D'2', W
0582  2D84  	GOTO	label73
0583  2D86  	GOTO	label74
0584        label73
0584  1283  	BCF STATUS, RP0
0585  02BA  	SUBWF gbl_FCV_TEMP_C+D'2', F
0586        label74
0586  1683  	BSF STATUS, RP0
0587  082B  	MOVF CompTempVar2225+D'3', W
0588  1803  	BTFSC STATUS,C
0589  2D8D  	GOTO	label75
058A  0F2B  	INCFSZ CompTempVar2225+D'3', W
058B  2D8D  	GOTO	label75
058C  2D8F  	GOTO	label76
058D        label75
058D  1283  	BCF STATUS, RP0
058E  02BB  	SUBWF gbl_FCV_TEMP_C+D'3', F
058F        label76


	//Calculation
	//Calculation:
	//  dp2 = raw % 50
	FCV_DP2 = FCV_RAW % 50;
058F  1283  	BCF STATUS, RP0
0590  0834  	MOVF gbl_FCV_RAW, W
0591  1683  	BSF STATUS, RP0
0592  00A0  	MOVWF __rem_32_3_00002_arg_a
0593  1283  	BCF STATUS, RP0
0594  0835  	MOVF gbl_FCV_RAW+D'1', W
0595  1683  	BSF STATUS, RP0
0596  00A1  	MOVWF __rem_32_3_00002_arg_a+D'1'
0597  1283  	BCF STATUS, RP0
0598  0836  	MOVF gbl_FCV_RAW+D'2', W
0599  1683  	BSF STATUS, RP0
059A  00A2  	MOVWF __rem_32_3_00002_arg_a+D'2'
059B  1283  	BCF STATUS, RP0
059C  0837  	MOVF gbl_FCV_RAW+D'3', W
059D  1683  	BSF STATUS, RP0
059E  00A3  	MOVWF __rem_32_3_00002_arg_a+D'3'
059F  1283  	BCF STATUS, RP0
05A0  1FB7  	BTFSS gbl_FCV_RAW+D'3',7
05A1  2DAE  	GOTO	label77
05A2  1683  	BSF STATUS, RP0
05A3  09A0  	COMF __rem_32_3_00002_arg_a, F
05A4  09A1  	COMF __rem_32_3_00002_arg_a+D'1', F
05A5  09A2  	COMF __rem_32_3_00002_arg_a+D'2', F
05A6  09A3  	COMF __rem_32_3_00002_arg_a+D'3', F
05A7  0AA0  	INCF __rem_32_3_00002_arg_a, F
05A8  1903  	BTFSC STATUS,Z
05A9  0AA1  	INCF __rem_32_3_00002_arg_a+D'1', F
05AA  1903  	BTFSC STATUS,Z
05AB  0AA2  	INCF __rem_32_3_00002_arg_a+D'2', F
05AC  1903  	BTFSC STATUS,Z
05AD  0AA3  	INCF __rem_32_3_00002_arg_a+D'3', F
05AE        label77
05AE  3032  	MOVLW 0x32
05AF  1683  	BSF STATUS, RP0
05B0  00A4  	MOVWF __rem_32_3_00002_arg_b
05B1  01A5  	CLRF __rem_32_3_00002_arg_b+D'1'
05B2  01A6  	CLRF __rem_32_3_00002_arg_b+D'2'
05B3  01A7  	CLRF __rem_32_3_00002_arg_b+D'3'
05B4  213A  	CALL __rem_32_3_00002
05B5  082D  	MOVF CompTempVarRet212, W
05B6  1283  	BCF STATUS, RP0
05B7  00D7  	MOVWF gbl_FCV_DP2
05B8  1FB7  	BTFSS gbl_FCV_RAW+D'3',7
05B9  2DBC  	GOTO	label78
05BA  09D7  	COMF gbl_FCV_DP2, F
05BB  0AD7  	INCF gbl_FCV_DP2, F
05BC        label78


	//Decision
	//Decision: dp2 >= 100?
	if (FCV_DP2 >= 100)
05BC  3064  	MOVLW 0x64
05BD  0257  	SUBWF gbl_FCV_DP2, W
05BE  1C03  	BTFSS STATUS,C
05BF  2DC9  	GOTO	label79
05C9        label79

	{

		//Calculation
		//Calculation:
		//  temp_cdp = dp2 / 100
		FCV_TEMP_CDP = FCV_DP2 / 100;
05C0  0857  	MOVF gbl_FCV_DP2, W
05C1  00F7  	MOVWF __div_8_8_00000_arg_a
05C2  3064  	MOVLW 0x64
05C3  00F8  	MOVWF __div_8_8_00000_arg_b
05C4  2173  	CALL __div_8_8_00000
05C5  087B  	MOVF CompTempVarRet218, W
05C6  00C1  	MOVWF gbl_FCV_TEMP_CDP
05C7  01C2  	CLRF gbl_FCV_TEMP_CDP+D'1'


	} else {
05C8  2DE7  	GOTO	label81


		//Decision
		//Decision: dp2 >= 10 AND dp2 <= 100?
		if (FCV_DP2 >= 10 & FCV_DP2 <= 100)
05C9  01F6  	CLRF CompTempVar2239
05CA  300A  	MOVLW 0x0A
05CB  0257  	SUBWF gbl_FCV_DP2, W
05CC  1803  	BTFSC STATUS,C
05CD  0AF6  	INCF CompTempVar2239, F
05CE  01F5  	CLRF CompTempVar2238
05CF  0857  	MOVF gbl_FCV_DP2, W
05D0  3C64  	SUBLW 0x64
05D1  1803  	BTFSC STATUS,C
05D2  0AF5  	INCF CompTempVar2238, F
05D3  0875  	MOVF CompTempVar2238, W
05D4  0576  	ANDWF CompTempVar2239, W
05D5  1903  	BTFSC STATUS,Z
05D6  2DE0  	GOTO	label80
05E0        label80

		{

			//Calculation
			//Calculation:
			//  temp_cdp = dp2 / 10
			FCV_TEMP_CDP = FCV_DP2 / 10;
05D7  0857  	MOVF gbl_FCV_DP2, W
05D8  00F7  	MOVWF __div_8_8_00000_arg_a
05D9  300A  	MOVLW 0x0A
05DA  00F8  	MOVWF __div_8_8_00000_arg_b
05DB  2173  	CALL __div_8_8_00000
05DC  087B  	MOVF CompTempVarRet218, W
05DD  00C1  	MOVWF gbl_FCV_TEMP_CDP
05DE  01C2  	CLRF gbl_FCV_TEMP_CDP+D'1'


		} else {
05DF  2DE7  	GOTO	label81


			//Decision
			//Decision: dp2 < 10?
			if (FCV_DP2 < 10)
05E0  300A  	MOVLW 0x0A
05E1  0257  	SUBWF gbl_FCV_DP2, W
05E2  1803  	BTFSC STATUS,C
05E3  2DE7  	GOTO	label81
05E7        label81

			{

				//Calculation
				//Calculation:
				//  temp_cdp = dp2
				FCV_TEMP_CDP = FCV_DP2;
05E4  0857  	MOVF gbl_FCV_DP2, W
05E5  00C1  	MOVWF gbl_FCV_TEMP_CDP
05E6  01C2  	CLRF gbl_FCV_TEMP_CDP+D'1'


			// } else {

			}

		}

	}

	//Calculation
	//Calculation:
	//  temp_cdp = temp_cdp + calib_offset
	FCV_TEMP_CDP = FCV_TEMP_CDP + FCV_CALIB_OFFSET;
05E7  0847  	MOVF gbl_FCV_CALIB_OFFSET, W
05E8  07C1  	ADDWF gbl_FCV_TEMP_CDP, F
05E9  0848  	MOVF gbl_FCV_CALIB_OFFSET+D'1', W
05EA  00F5  	MOVWF CompTempVar2243
05EB  0842  	MOVF gbl_FCV_TEMP_CDP+D'1', W
05EC  1803  	BTFSC STATUS,C
05ED  0AF5  	INCF CompTempVar2243, F
05EE  07F5  	ADDWF CompTempVar2243, F
05EF  0875  	MOVF CompTempVar2243, W
05F0  00C2  	MOVWF gbl_FCV_TEMP_CDP+D'1'


}
05F1  0008  	RETURN



void FCM_i2c_comm()

{

	//Call Component Macro
	//Call Component Macro: MI2C_Start()
	FCD_I2C_Master0_MI2C_Start();
037C  228C  	CALL FCD_I2C_Ma_0005A


	//Calculation
	//Calculation:
	//  rt_byte = 0
	FCV_RT_BYTE = 0;
037D  1283  	BCF STATUS, RP0
037E  01DE  	CLRF gbl_FCV_RT_BYTE


	//Call Component Macro
	//Call Component Macro: rt_byte=MI2C_Transmit_Byte(0xB4)
	FCV_RT_BYTE = FCD_I2C_Master0_MI2C_Transmit_Byte(0xB4);
037F  30B4  	MOVLW 0xB4
0380  00F5  	MOVWF FCD_I2C_Ma_0005B_arg_Data
0381  2286  	CALL FCD_I2C_Ma_0005B
0382  0876  	MOVF CompTempVarRet2244, W
0383  00DE  	MOVWF gbl_FCV_RT_BYTE


	//Calculation
	//Calculation:
	//  rt_byte = 0
	FCV_RT_BYTE = 0;
0384  01DE  	CLRF gbl_FCV_RT_BYTE


	//Call Component Macro
	//Call Component Macro: rt_byte=MI2C_Transmit_Byte(0x07)
	FCV_RT_BYTE = FCD_I2C_Master0_MI2C_Transmit_Byte(0x07);
0385  3007  	MOVLW 0x07
0386  00F5  	MOVWF FCD_I2C_Ma_0005B_arg_Data
0387  2286  	CALL FCD_I2C_Ma_0005B
0388  0876  	MOVF CompTempVarRet2244, W
0389  00DE  	MOVWF gbl_FCV_RT_BYTE


	//Comment:
	//end of RD/WR cmd

	//Call Component Macro
	//Call Component Macro: MI2C_Restart()
	FCD_I2C_Master0_MI2C_Restart();
038A  2284  	CALL FCD_I2C_Ma_0005C


	//Calculation
	//Calculation:
	//  rt_byte = 0
	FCV_RT_BYTE = 0;
038B  1283  	BCF STATUS, RP0
038C  01DE  	CLRF gbl_FCV_RT_BYTE


	//Call Component Macro
	//Call Component Macro: rt_byte=MI2C_Transmit_Byte(0xB4)
	FCV_RT_BYTE = FCD_I2C_Master0_MI2C_Transmit_Byte(0xB4);
038D  30B4  	MOVLW 0xB4
038E  00F5  	MOVWF FCD_I2C_Ma_0005B_arg_Data
038F  2286  	CALL FCD_I2C_Ma_0005B
0390  0876  	MOVF CompTempVarRet2244, W
0391  00DE  	MOVWF gbl_FCV_RT_BYTE


	//Call Component Macro
	//Call Component Macro: i2c_rx=MI2C_Receive_Byte(rt_byte)
	FCV_I2C_RX = FCD_I2C_Master0_MI2C_Receive_Byte(FCV_RT_BYTE);
0392  085E  	MOVF gbl_FCV_RT_BYTE, W
0393  00F5  	MOVWF FCD_I2C_Ma_0005D_arg_Last
0394  227E  	CALL FCD_I2C_Ma_0005D
0395  0876  	MOVF CompTempVarRet2245, W
0396  00E3  	MOVWF gbl_FCV_I2C_RX


	//Calculation
	//Calculation:
	//  data0 = i2c_rx
	FCV_DATA0 = FCV_I2C_RX;
0397  0863  	MOVF gbl_FCV_I2C_RX, W
0398  00D4  	MOVWF gbl_FCV_DATA0


	//Call Component Macro
	//Call Component Macro: i2c_rx=MI2C_Receive_Byte(rt_byte)
	FCV_I2C_RX = FCD_I2C_Master0_MI2C_Receive_Byte(FCV_RT_BYTE);
0399  085E  	MOVF gbl_FCV_RT_BYTE, W
039A  00F5  	MOVWF FCD_I2C_Ma_0005D_arg_Last
039B  227E  	CALL FCD_I2C_Ma_0005D
039C  0876  	MOVF CompTempVarRet2245, W
039D  00E3  	MOVWF gbl_FCV_I2C_RX


	//Calculation
	//Calculation:
	//  data1 = i2c_rx
	FCV_DATA1 = FCV_I2C_RX;
039E  0863  	MOVF gbl_FCV_I2C_RX, W
039F  00D5  	MOVWF gbl_FCV_DATA1


	//Call Component Macro
	//Call Component Macro: i2c_rx=MI2C_Receive_Byte(rt_byte)
	FCV_I2C_RX = FCD_I2C_Master0_MI2C_Receive_Byte(FCV_RT_BYTE);
03A0  085E  	MOVF gbl_FCV_RT_BYTE, W
03A1  00F5  	MOVWF FCD_I2C_Ma_0005D_arg_Last
03A2  227E  	CALL FCD_I2C_Ma_0005D
03A3  0876  	MOVF CompTempVarRet2245, W
03A4  00E3  	MOVWF gbl_FCV_I2C_RX


	//Calculation
	//Calculation:
	//  data2 = i2c_rx
	FCV_DATA2 = FCV_I2C_RX;
03A5  0863  	MOVF gbl_FCV_I2C_RX, W
03A6  00D8  	MOVWF gbl_FCV_DATA2


	//Call Component Macro
	//Call Component Macro: MI2C_Stop()
	FCD_I2C_Master0_MI2C_Stop();
03A7  227C  	CALL FCD_I2C_Ma_0005E


}
03A8  0008  	RETURN



void FCM_lights_off()

{

	//Call Component Macro
	//Call Component Macro: LEDOff()
	FCD_LED0_LEDOff();
0241  2134  	CALL FCD_LED0_L_00055


	//Call Component Macro
	//Call Component Macro: LEDOff()
	FCD_LED1_LEDOff();
0242  212E  	CALL FCD_LED1_L_00058


}
0243  0008  	RETURN



void FCM_beep_once()

{

	//Call Component Macro
	//Call Component Macro: SetDutyCycle(160)
	FCD_PWM0_SetDutyCycle(160);
0745  30A0  	MOVLW 0xA0
0746  1283  	BCF STATUS, RP0
0747  1303  	BCF STATUS, RP1
0748  00FD  	MOVWF FCD_PWM0_S_00061_arg_nDuty
0749  2272  	CALL FCD_PWM0_S_00061


	//Delay
	//Delay: 100 ms
	delay_ms(100);
074A  3064  	MOVLW 0x64
074B  00FD  	MOVWF delay_ms_00000_arg_del
074C  2010  	CALL delay_ms_00000


	//Call Component Macro
	//Call Component Macro: SetDutyCycle(0)
	FCD_PWM0_SetDutyCycle(0);
074D  01FD  	CLRF FCD_PWM0_S_00061_arg_nDuty
074E  2272  	CALL FCD_PWM0_S_00061


}
074F  0008  	RETURN



void FCM_get_temp()

{

	//Connection Point
	//Connection Point: [A]: A
FCC_get_temp_A:
0646        label82

;

	//Call Macro
	//Call Macro: i2c_comm()
	FCM_i2c_comm();
0646  237C  	CALL FCM_i2c_co_00059


	//Calculation
	//Calculation:
	//  data_prev = data1
	FCV_DATA_PREV = FCV_DATA1;
0647  0855  	MOVF gbl_FCV_DATA1, W
0648  00E6  	MOVWF gbl_FCV_DATA_PREV


	//Call Macro
	//Call Macro: i2c_comm()
	FCM_i2c_comm();
0649  237C  	CALL FCM_i2c_co_00059


	//Calculation
	//Calculation:
	//  data_diff = data_prev - data1
	FCV_DATA_DIFF = FCV_DATA_PREV - FCV_DATA1;
064A  0855  	MOVF gbl_FCV_DATA1, W
064B  0266  	SUBWF gbl_FCV_DATA_PREV, W
064C  00E9  	MOVWF gbl_FCV_DATA_DIFF


	//Decision
	//Decision: data_diff > 10?
	if (FCV_DATA_DIFF > 10)
064D  0869  	MOVF gbl_FCV_DATA_DIFF, W
064E  3C0A  	SUBLW 0x0A
064F  1C03  	BTFSS STATUS,C

	{

		//Goto Connection Point
		//Goto Connection Point: [A]: A
		goto FCC_get_temp_A;
0650  2E46  	GOTO	label82
0651        label83


	// } else {

	}

	//Connection Point
	//Connection Point: [B]: B
FCC_get_temp_B:
;

	//Call Macro
	//Call Macro: i2c_comm()
	FCM_i2c_comm();
0651  237C  	CALL FCM_i2c_co_00059


	//Calculation
	//Calculation:
	//  data_prev = data1
	FCV_DATA_PREV = FCV_DATA1;
0652  0855  	MOVF gbl_FCV_DATA1, W
0653  00E6  	MOVWF gbl_FCV_DATA_PREV


	//Call Macro
	//Call Macro: i2c_comm()
	FCM_i2c_comm();
0654  237C  	CALL FCM_i2c_co_00059


	//Calculation
	//Calculation:
	//  data_diff = data_prev - data1
	FCV_DATA_DIFF = FCV_DATA_PREV - FCV_DATA1;
0655  0855  	MOVF gbl_FCV_DATA1, W
0656  0266  	SUBWF gbl_FCV_DATA_PREV, W
0657  00E9  	MOVWF gbl_FCV_DATA_DIFF


	//Decision
	//Decision: data_diff > 10?
	if (FCV_DATA_DIFF > 10)
0658  0869  	MOVF gbl_FCV_DATA_DIFF, W
0659  3C0A  	SUBLW 0x0A
065A  1C03  	BTFSS STATUS,C

	{

		//Goto Connection Point
		//Goto Connection Point: [B]: B
		goto FCC_get_temp_B;
065B  2E51  	GOTO	label83


	// } else {

	}

	//Call Macro
	//Call Macro: calc()
	FCM_calc();
065C  24EE  	CALL FCM_calc_00000


}
065D  0008  	RETURN



void FCM_display_repeat()

{

	//Call Macro
	//Call Macro: scan_off()
	FCM_scan_off();
0244  2078  	CALL FCM_scan_o_00051


	//Call Macro
	//Call Macro: scan1()
	FCM_scan1();
0245  2109  	CALL FCM_scan1_00000


	//Output
	//Output: 0b10000001 -> PORTB
	trisb = 0x00;
0246  1683  	BSF STATUS, RP0
0247  0186  	CLRF gbl_trisb

	portb = (129);
0248  3081  	MOVLW 0x81
0249  1283  	BCF STATUS, RP0
024A  0086  	MOVWF gbl_portb


	//Delay
	//Delay: 4 ms
	delay_ms(4);
024B  3004  	MOVLW 0x04
024C  00FD  	MOVWF delay_ms_00000_arg_del
024D  2010  	CALL delay_ms_00000


	//Call Macro
	//Call Macro: scan_off()
	FCM_scan_off();
024E  2078  	CALL FCM_scan_o_00051


	//Call Macro
	//Call Macro: scan2()
	FCM_scan2();
024F  20E4  	CALL FCM_scan2_00000


	//Output
	//Output: 0b10000001 -> PORTB
	trisb = 0x00;
0250  1683  	BSF STATUS, RP0
0251  0186  	CLRF gbl_trisb

	portb = (129);
0252  3081  	MOVLW 0x81
0253  1283  	BCF STATUS, RP0
0254  0086  	MOVWF gbl_portb


	//Delay
	//Delay: 4 ms
	delay_ms(4);
0255  3004  	MOVLW 0x04
0256  00FD  	MOVWF delay_ms_00000_arg_del
0257  2010  	CALL delay_ms_00000


	//Call Macro
	//Call Macro: scan_off()
	FCM_scan_off();
0258  2078  	CALL FCM_scan_o_00051


	//Call Macro
	//Call Macro: scan3()
	FCM_scan3();
0259  20BF  	CALL FCM_scan3_00000


	//Output
	//Output: 0b10000001 -> PORTB
	trisb = 0x00;
025A  1683  	BSF STATUS, RP0
025B  0186  	CLRF gbl_trisb

	portb = (129);
025C  3081  	MOVLW 0x81
025D  1283  	BCF STATUS, RP0
025E  0086  	MOVWF gbl_portb


	//Delay
	//Delay: 4 ms
	delay_ms(4);
025F  3004  	MOVLW 0x04
0260  00FD  	MOVWF delay_ms_00000_arg_del
0261  2010  	CALL delay_ms_00000


	//Output
	//Output: 0b10000001 -> PORTB
	trisb = 0x00;
0262  1683  	BSF STATUS, RP0
0263  0186  	CLRF gbl_trisb

	portb = (129);
0264  3081  	MOVLW 0x81
0265  1283  	BCF STATUS, RP0
0266  0086  	MOVWF gbl_portb


	//Call Macro
	//Call Macro: scan_off()
	FCM_scan_off();
0267  2078  	CALL FCM_scan_o_00051


	//Call Macro
	//Call Macro: scan4()
	FCM_scan4();
0268  209A  	CALL FCM_scan4_00000


	//Output
	//Output: 0b11100000 -> PORTB
	trisb = 0x00;
0269  1683  	BSF STATUS, RP0
026A  0186  	CLRF gbl_trisb

	portb = (224);
026B  30E0  	MOVLW 0xE0
026C  1283  	BCF STATUS, RP0
026D  0086  	MOVWF gbl_portb


	//Delay
	//Delay: 4 ms
	delay_ms(4);
026E  3004  	MOVLW 0x04
026F  00FD  	MOVWF delay_ms_00000_arg_del
0270  2010  	CALL delay_ms_00000


}
0271  0008  	RETURN



void FCM_repeat()

{

	//Loop
	//Loop: Loop 10 times
	for (FCLV_LOOP4=0; FCLV_LOOP4<10; FCLV_LOOP4++)
032A  1283  	BCF STATUS, RP0
032B  1303  	BCF STATUS, RP1
032C  01ED  	CLRF gbl_FCLV_LOOP4
032D        label46
032D  300A  	MOVLW 0x0A
032E  026D  	SUBWF gbl_FCLV_LOOP4, W
032F  1803  	BTFSC STATUS,C
0330  2B37  	GOTO	label47
0335  0AED  	INCF gbl_FCLV_LOOP4, F
0336  2B2D  	GOTO	label46
0337        label47

	{

		//Call Macro
		//Call Macro: display_repeat()
		FCM_display_repeat();
0331  2244  	CALL FCM_displa_00063


		//Call Macro
		//Call Macro: lights_off()
		FCM_lights_off();
0332  2241  	CALL FCM_lights_0005F


		//Call Component Macro
		//Call Component Macro: SetDutyCycle(0)
		FCD_PWM0_SetDutyCycle(0);
0333  01FD  	CLRF FCD_PWM0_S_00061_arg_nDuty
0334  2272  	CALL FCD_PWM0_S_00061



	}

	//Loop
	//Loop: Loop 10 times
	for (FCLV_LOOP5=0; FCLV_LOOP5<10; FCLV_LOOP5++)
0337  01EE  	CLRF gbl_FCLV_LOOP5
0338        label48
0338  300A  	MOVLW 0x0A
0339  026E  	SUBWF gbl_FCLV_LOOP5, W
033A  1803  	BTFSC STATUS,C
033B  2B43  	GOTO	label49
0341  0AEE  	INCF gbl_FCLV_LOOP5, F
0342  2B38  	GOTO	label48
0343        label49

	{

		//Call Macro
		//Call Macro: display_repeat()
		FCM_display_repeat();
033C  2244  	CALL FCM_displa_00063


		//Call Macro
		//Call Macro: lights_off()
		FCM_lights_off();
033D  2241  	CALL FCM_lights_0005F


		//Call Component Macro
		//Call Component Macro: SetDutyCycle(160)
		FCD_PWM0_SetDutyCycle(160);
033E  30A0  	MOVLW 0xA0
033F  00FD  	MOVWF FCD_PWM0_S_00061_arg_nDuty
0340  2272  	CALL FCD_PWM0_S_00061



	}

	//Loop
	//Loop: Loop 10 times
	for (FCLV_LOOP6=0; FCLV_LOOP6<10; FCLV_LOOP6++)
0343  01EF  	CLRF gbl_FCLV_LOOP6
0344        label50
0344  300A  	MOVLW 0x0A
0345  026F  	SUBWF gbl_FCLV_LOOP6, W
0346  1803  	BTFSC STATUS,C
0347  2B4E  	GOTO	label51
034C  0AEF  	INCF gbl_FCLV_LOOP6, F
034D  2B44  	GOTO	label50
034E        label51

	{

		//Call Macro
		//Call Macro: display_repeat()
		FCM_display_repeat();
0348  2244  	CALL FCM_displa_00063


		//Call Macro
		//Call Macro: lights_off()
		FCM_lights_off();
0349  2241  	CALL FCM_lights_0005F


		//Call Component Macro
		//Call Component Macro: SetDutyCycle(0)
		FCD_PWM0_SetDutyCycle(0);
034A  01FD  	CLRF FCD_PWM0_S_00061_arg_nDuty
034B  2272  	CALL FCD_PWM0_S_00061



	}

	//Loop
	//Loop: Loop 10 times
	for (FCLV_LOOP7=0; FCLV_LOOP7<10; FCLV_LOOP7++)
034E  01F0  	CLRF gbl_FCLV_LOOP7
034F        label52
034F  300A  	MOVLW 0x0A
0350  0270  	SUBWF gbl_FCLV_LOOP7, W
0351  1803  	BTFSC STATUS,C
0352  2B5A  	GOTO	label53
0358  0AF0  	INCF gbl_FCLV_LOOP7, F
0359  2B4F  	GOTO	label52
035A        label53

	{

		//Call Macro
		//Call Macro: display_repeat()
		FCM_display_repeat();
0353  2244  	CALL FCM_displa_00063


		//Call Macro
		//Call Macro: lights_off()
		FCM_lights_off();
0354  2241  	CALL FCM_lights_0005F


		//Call Component Macro
		//Call Component Macro: SetDutyCycle(160)
		FCD_PWM0_SetDutyCycle(160);
0355  30A0  	MOVLW 0xA0
0356  00FD  	MOVWF FCD_PWM0_S_00061_arg_nDuty
0357  2272  	CALL FCD_PWM0_S_00061



	}

	//Loop
	//Loop: Loop 10 times
	for (FCLV_LOOP8=0; FCLV_LOOP8<10; FCLV_LOOP8++)
035A  01F1  	CLRF gbl_FCLV_LOOP8
035B        label54
035B  300A  	MOVLW 0x0A
035C  0271  	SUBWF gbl_FCLV_LOOP8, W
035D  1803  	BTFSC STATUS,C
035E  2B65  	GOTO	label55
0363  0AF1  	INCF gbl_FCLV_LOOP8, F
0364  2B5B  	GOTO	label54
0365        label55

	{

		//Call Macro
		//Call Macro: display_repeat()
		FCM_display_repeat();
035F  2244  	CALL FCM_displa_00063


		//Call Macro
		//Call Macro: lights_off()
		FCM_lights_off();
0360  2241  	CALL FCM_lights_0005F


		//Call Component Macro
		//Call Component Macro: SetDutyCycle(0)
		FCD_PWM0_SetDutyCycle(0);
0361  01FD  	CLRF FCD_PWM0_S_00061_arg_nDuty
0362  2272  	CALL FCD_PWM0_S_00061



	}

	//Loop
	//Loop: Loop 10 times
	for (FCLV_LOOP9=0; FCLV_LOOP9<10; FCLV_LOOP9++)
0365  01F2  	CLRF gbl_FCLV_LOOP9
0366        label56
0366  300A  	MOVLW 0x0A
0367  0272  	SUBWF gbl_FCLV_LOOP9, W
0368  1803  	BTFSC STATUS,C
0369  2B71  	GOTO	label57
036F  0AF2  	INCF gbl_FCLV_LOOP9, F
0370  2B66  	GOTO	label56
0371        label57

	{

		//Call Macro
		//Call Macro: display_repeat()
		FCM_display_repeat();
036A  2244  	CALL FCM_displa_00063


		//Call Macro
		//Call Macro: lights_off()
		FCM_lights_off();
036B  2241  	CALL FCM_lights_0005F


		//Call Component Macro
		//Call Component Macro: SetDutyCycle(160)
		FCD_PWM0_SetDutyCycle(160);
036C  30A0  	MOVLW 0xA0
036D  00FD  	MOVWF FCD_PWM0_S_00061_arg_nDuty
036E  2272  	CALL FCD_PWM0_S_00061



	}

	//Loop
	//Loop: Loop 10 times
	for (FCLV_LOOP10=0; FCLV_LOOP10<10; FCLV_LOOP10++)
0371  01F3  	CLRF gbl_FCLV_LOOP10
0372        label58
0372  300A  	MOVLW 0x0A
0373  0273  	SUBWF gbl_FCLV_LOOP10, W
0374  1803  	BTFSC STATUS,C
037A  0AF3  	INCF gbl_FCLV_LOOP10, F
037B  2B72  	GOTO	label58

	{

		//Call Macro
		//Call Macro: display_repeat()
		FCM_display_repeat();
0376  2244  	CALL FCM_displa_00063


		//Call Macro
		//Call Macro: lights_off()
		FCM_lights_off();
0377  2241  	CALL FCM_lights_0005F


		//Call Component Macro
		//Call Component Macro: SetDutyCycle(0)
		FCD_PWM0_SetDutyCycle(0);
0378  01FD  	CLRF FCD_PWM0_S_00061_arg_nDuty
0379  2272  	CALL FCD_PWM0_S_00061



	}

}
0375  0008  	RETURN



void FCM_display_fail()

{

	//Loop
	//Loop: Loop 90 times
	for (FCLV_LOOP11=0; FCLV_LOOP11<90; FCLV_LOOP11++)
065E  1283  	BCF STATUS, RP0
065F  1303  	BCF STATUS, RP1
0660  01F4  	CLRF gbl_FCLV_LOOP11
0661        label84
0661  305A  	MOVLW 0x5A
0662  0274  	SUBWF gbl_FCLV_LOOP11, W
0663  1803  	BTFSC STATUS,C
066A  0AF4  	INCF gbl_FCLV_LOOP11, F
066B  2E61  	GOTO	label84

	{

		//Call Macro
		//Call Macro: display_temp()
		FCM_display_temp();
0665  244D  	CALL FCM_displa_00053


		//Call Macro
		//Call Macro: failed()
		FCM_failed();
0666  23A9  	CALL FCM_failed_00000


		//Call Component Macro
		//Call Component Macro: SetDutyCycle(160)
		FCD_PWM0_SetDutyCycle(160);
0667  30A0  	MOVLW 0xA0
0668  00FD  	MOVWF FCD_PWM0_S_00061_arg_nDuty
0669  2272  	CALL FCD_PWM0_S_00061



	}

}
0664  0008  	RETURN



void FCM_calibrate()

{

	//Call Macro
	//Call Macro: lights_off()
	FCM_lights_off();
066C  2241  	CALL FCM_lights_0005F


	//Loop
	//Loop: While swg = 0 OR swr = 0
	while (FCV_SWG == 0 | FCV_SWR == 0)
066D        label85
066D  01F8  	CLRF CompTempVar2247
066E  1DDB  	BTFSS gbl_FCV_SWG,3
066F  0AF8  	INCF CompTempVar2247, F
0670  01F7  	CLRF CompTempVar2246
0671  0AF7  	INCF CompTempVar2246, F
0672  08E2  	MOVF gbl_FCV_SWR, F
0673  1D03  	BTFSS STATUS,Z
0674  1077  	BCF CompTempVar2246,0
0675  0877  	MOVF CompTempVar2246, W
0676  0478  	IORWF CompTempVar2247, W
0677  1903  	BTFSC STATUS,Z
0678  2E7C  	GOTO	label86
067B  2E6D  	GOTO	label85
067C        label86
06BB  2EB7  	GOTO	label89

	{

		//Call Macro
		//Call Macro: all_input()
		FCM_all_input();
0679  25F2  	CALL FCM_all_in_00054


		//Call Macro
		//Call Macro: display_temp_calib()
		FCM_display_temp_calib();
067A  23AC  	CALL FCM_displa_00066



	}

	//Calculation
	//Calculation:
	//  calib_count = 0
	FCV_CALIB_COUNT = 0;
067C  01E5  	CLRF gbl_FCV_CALIB_COUNT


	//Loop
	//Loop: While 1
	while (1)
067D        label87
0720  2E7D  	GOTO	label87

	{

		//Connection Point
		//Connection Point: [A]: A
FCC_calibrate_A:
;

		//Calculation
		//Calculation:
		//  reset_counter = 0
		FCV_RESET_COUNTER = 0;
067D  01D9  	CLRF gbl_FCV_RESET_COUNTER


		//Call Macro
		//Call Macro: all_input()
		FCM_all_input();
067E  25F2  	CALL FCM_all_in_00054


		//Decision
		//Decision: swg = 0 AND swr = 1?
		if (FCV_SWG == 0 & FCV_SWR == 1)
067F  01FA  	CLRF CompTempVar2249
0680  1DDB  	BTFSS gbl_FCV_SWG,3
0681  0AFA  	INCF CompTempVar2249, F
0682  01F9  	CLRF CompTempVar2248
0683  0362  	DECF gbl_FCV_SWR, W
0684  1903  	BTFSC STATUS,Z
0685  0AF9  	INCF CompTempVar2248, F
0686  0879  	MOVF CompTempVar2248, W
0687  057A  	ANDWF CompTempVar2249, W
0688  1903  	BTFSC STATUS,Z
0689  2EBC  	GOTO	label90
06BC        label90

		{

			//Calculation
			//Calculation:
			//  calib_count = 0
			FCV_CALIB_COUNT = 0;
068A  01E5  	CLRF gbl_FCV_CALIB_COUNT


			//Calculation
			//Calculation:
			//  temp_cdp = temp_cdp + 1
			//  calib_offset = calib_offset + 1
			FCV_TEMP_CDP = FCV_TEMP_CDP + 1;
068B  08C1  	MOVF gbl_FCV_TEMP_CDP, F
068C  08C2  	MOVF gbl_FCV_TEMP_CDP+D'1', F
068D  0AC1  	INCF gbl_FCV_TEMP_CDP, F
068E  1903  	BTFSC STATUS,Z
068F  0AC2  	INCF gbl_FCV_TEMP_CDP+D'1', F

			FCV_CALIB_OFFSET = FCV_CALIB_OFFSET + 1;
0690  08C7  	MOVF gbl_FCV_CALIB_OFFSET, F
0691  08C8  	MOVF gbl_FCV_CALIB_OFFSET+D'1', F
0692  0AC7  	INCF gbl_FCV_CALIB_OFFSET, F
0693  1903  	BTFSC STATUS,Z
0694  0AC8  	INCF gbl_FCV_CALIB_OFFSET+D'1', F


			//Decision
			//Decision: calib_offset > 9?
			if (FCV_CALIB_OFFSET > 9)
0695  0847  	MOVF gbl_FCV_CALIB_OFFSET, W
0696  3C09  	SUBLW 0x09
0697  0848  	MOVF gbl_FCV_CALIB_OFFSET+D'1', W
0698  1803  	BTFSC STATUS,C
0699  1D03  	BTFSS STATUS,Z
069A  1BC8  	BTFSC gbl_FCV_CALIB_OFFSET+D'1',7
069B  2E9E  	GOTO	label88
069E        label88

			{

				//Calculation
				//Calculation:
				//  calib_offset = 0
				FCV_CALIB_OFFSET = 0;
069C  01C7  	CLRF gbl_FCV_CALIB_OFFSET
069D  01C8  	CLRF gbl_FCV_CALIB_OFFSET+D'1'


			// } else {

			}

			//Decision
			//Decision: temp_cdp > 9?
			if (FCV_TEMP_CDP > 9)
069E  0841  	MOVF gbl_FCV_TEMP_CDP, W
069F  3C09  	SUBLW 0x09
06A0  0842  	MOVF gbl_FCV_TEMP_CDP+D'1', W
06A1  1803  	BTFSC STATUS,C
06A2  1D03  	BTFSS STATUS,Z
06A3  1BC2  	BTFSC gbl_FCV_TEMP_CDP+D'1',7
06A4  2EB7  	GOTO	label89
06B7        label89

			{

				//Calculation
				//Calculation:
				//  calib_subtractor = calib_subtractor - 1
				//  temp_c = temp_c + 1
				//  temp_cdp = 0
				FCV_CALIB_SUBTRACTOR = FCV_CALIB_SUBTRACTOR - 1;
06A5  3001  	MOVLW 0x01
06A6  02C3  	SUBWF gbl_FCV_CALIB_SUBTRACTOR, F
06A7  08C4  	MOVF gbl_FCV_CALIB_SUBTRACTOR+D'1', F
06A8  1C03  	BTFSS STATUS,C
06A9  03C4  	DECF gbl_FCV_CALIB_SUBTRACTOR+D'1', F

				FCV_TEMP_C = FCV_TEMP_C + 1;
06AA  08B8  	MOVF gbl_FCV_TEMP_C, F
06AB  08B9  	MOVF gbl_FCV_TEMP_C+D'1', F
06AC  08BA  	MOVF gbl_FCV_TEMP_C+D'2', F
06AD  08BB  	MOVF gbl_FCV_TEMP_C+D'3', F
06AE  0AB8  	INCF gbl_FCV_TEMP_C, F
06AF  1903  	BTFSC STATUS,Z
06B0  0AB9  	INCF gbl_FCV_TEMP_C+D'1', F
06B1  1903  	BTFSC STATUS,Z
06B2  0ABA  	INCF gbl_FCV_TEMP_C+D'2', F
06B3  1903  	BTFSC STATUS,Z
06B4  0ABB  	INCF gbl_FCV_TEMP_C+D'3', F

				FCV_TEMP_CDP = 0;
06B5  01C1  	CLRF gbl_FCV_TEMP_CDP
06B6  01C2  	CLRF gbl_FCV_TEMP_CDP+D'1'


			// } else {

			}

			//Loop
			//Loop: While swg = 0
			while (FCV_SWG == 0)
06B7  19DB  	BTFSC gbl_FCV_SWG,3
06B8  2F1A  	GOTO	label94

			{

				//Call Macro
				//Call Macro: all_input()
				FCM_all_input();
06B9  25F2  	CALL FCM_all_in_00054


				//Call Macro
				//Call Macro: display_temp_calib()
				FCM_display_temp_calib();
06BA  23AC  	CALL FCM_displa_00066



			}

		} else {

			//Decision
			//Decision: swg = 1 AND swr = 0?
			if (FCV_SWG == 1 & FCV_SWR == 0)
06BC  01FC  	CLRF CompTempVar2261
06BD  19DB  	BTFSC gbl_FCV_SWG,3
06BE  0AFC  	INCF CompTempVar2261, F
06BF  01FB  	CLRF CompTempVar2260
06C0  0AFB  	INCF CompTempVar2260, F
06C1  08E2  	MOVF gbl_FCV_SWR, F
06C2  1D03  	BTFSS STATUS,Z
06C3  107B  	BCF CompTempVar2260,0
06C4  087B  	MOVF CompTempVar2260, W
06C5  057C  	ANDWF CompTempVar2261, W
06C6  1903  	BTFSC STATUS,Z
06C7  2F1A  	GOTO	label94

			{

				//Calculation
				//Calculation:
				//  calib_count = 0
				FCV_CALIB_COUNT = 0;
06C8  01E5  	CLRF gbl_FCV_CALIB_COUNT


				//Calculation
				//Calculation:
				//  temp_cdp = temp_cdp - 1
				//  calib_offset = calib_offset - 1
				FCV_TEMP_CDP = FCV_TEMP_CDP - 1;
06C9  3001  	MOVLW 0x01
06CA  02C1  	SUBWF gbl_FCV_TEMP_CDP, F
06CB  08C2  	MOVF gbl_FCV_TEMP_CDP+D'1', F
06CC  1C03  	BTFSS STATUS,C
06CD  03C2  	DECF gbl_FCV_TEMP_CDP+D'1', F

				FCV_CALIB_OFFSET = FCV_CALIB_OFFSET - 1;
06CE  3001  	MOVLW 0x01
06CF  02C7  	SUBWF gbl_FCV_CALIB_OFFSET, F
06D0  08C8  	MOVF gbl_FCV_CALIB_OFFSET+D'1', F
06D1  1C03  	BTFSS STATUS,C
06D2  03C8  	DECF gbl_FCV_CALIB_OFFSET+D'1', F


				//Decision
				//Decision: calib_offset < 0?
				if (FCV_CALIB_OFFSET < 0)
06D3  1FC8  	BTFSS gbl_FCV_CALIB_OFFSET+D'1',7
06D4  2ED8  	GOTO	label91
06D8        label91

				{

					//Calculation
					//Calculation:
					//  calib_offset = 9
					FCV_CALIB_OFFSET = 9;
06D5  3009  	MOVLW 0x09
06D6  00C7  	MOVWF gbl_FCV_CALIB_OFFSET
06D7  01C8  	CLRF gbl_FCV_CALIB_OFFSET+D'1'


				// } else {

				}

				//Decision
				//Decision: temp_cdp < 0?
				if (FCV_TEMP_CDP < 0)
06D8  1FC2  	BTFSS gbl_FCV_TEMP_CDP+D'1',7
06D9  2EF6  	GOTO	label92
06F6        label92

				{

					//Calculation
					//Calculation:
					//  calib_subtractor = calib_subtractor + 1
					//  temp_c = temp_c - 1
					//  temp_cdp = 9
					FCV_CALIB_SUBTRACTOR = FCV_CALIB_SUBTRACTOR + 1;
06DA  08C3  	MOVF gbl_FCV_CALIB_SUBTRACTOR, F
06DB  08C4  	MOVF gbl_FCV_CALIB_SUBTRACTOR+D'1', F
06DC  0AC3  	INCF gbl_FCV_CALIB_SUBTRACTOR, F
06DD  1903  	BTFSC STATUS,Z
06DE  0AC4  	INCF gbl_FCV_CALIB_SUBTRACTOR+D'1', F

					FCV_TEMP_C = FCV_TEMP_C - 1;
06DF  3001  	MOVLW 0x01
06E0  02B8  	SUBWF gbl_FCV_TEMP_C, F
06E1  08B9  	MOVF gbl_FCV_TEMP_C+D'1', F
06E2  08BA  	MOVF gbl_FCV_TEMP_C+D'2', F
06E3  08BB  	MOVF gbl_FCV_TEMP_C+D'3', F
06E4  3000  	MOVLW 0x00
06E5  00FD  	MOVWF CompTempVar2272
06E6  1C03  	BTFSS STATUS,C
06E7  0F7D  	INCFSZ CompTempVar2272, W
06E8  02B9  	SUBWF gbl_FCV_TEMP_C+D'1', F
06E9  3000  	MOVLW 0x00
06EA  00FD  	MOVWF CompTempVar2272
06EB  1C03  	BTFSS STATUS,C
06EC  0F7D  	INCFSZ CompTempVar2272, W
06ED  02BA  	SUBWF gbl_FCV_TEMP_C+D'2', F
06EE  3000  	MOVLW 0x00
06EF  00FD  	MOVWF CompTempVar2272
06F0  1C03  	BTFSS STATUS,C
06F1  0F7D  	INCFSZ CompTempVar2272, W
06F2  02BB  	SUBWF gbl_FCV_TEMP_C+D'3', F

					FCV_TEMP_CDP = 9;
06F3  3009  	MOVLW 0x09
06F4  00C1  	MOVWF gbl_FCV_TEMP_CDP
06F5  01C2  	CLRF gbl_FCV_TEMP_CDP+D'1'


				// } else {

				}

				//Loop
				//Loop: While swr = 0
				while (FCV_SWR == 0)
06F6  08E2  	MOVF gbl_FCV_SWR, F
06F7  1D03  	BTFSS STATUS,Z
06F8  2F1A  	GOTO	label94
0719  2EF6  	GOTO	label92
071A        label94

				{

					//Call Macro
					//Call Macro: all_input()
					FCM_all_input();
06F9  25F2  	CALL FCM_all_in_00054


					//Call Macro
					//Call Macro: display_temp_calib()
					FCM_display_temp_calib();
06FA  23AC  	CALL FCM_displa_00066


					//Decision
					//Decision: reset_counter = 255?
					if (FCV_RESET_COUNTER == 255)
06FB  0A59  	INCF gbl_FCV_RESET_COUNTER, W
06FC  1D03  	BTFSS STATUS,Z
06FD  2F17  	GOTO	label93
0717        label93

					{

						//Call Macro
						//Call Macro: repeat()
						FCM_repeat();
06FE  232A  	CALL FCM_repeat_00000


						//Call Component Macro
						//Call Component Macro: Write(1, 21)
						FCD_EEPROM0_WriteEEPROM(1, 21);
06FF  3001  	MOVLW 0x01
0700  00FD  	MOVWF FCD_EEPROM_00067_arg_addr
0701  01FE  	CLRF FCD_EEPROM_00067_arg_addr+D'1'
0702  3015  	MOVLW 0x15
0703  1683  	BSF STATUS, RP0
0704  00A0  	MOVWF FCD_EEPROM_00067_arg_data
0705  01A1  	CLRF FCD_EEPROM_00067_arg_data+D'1'
0706  2628  	CALL FCD_EEPROM_00067


						//Call Component Macro
						//Call Component Macro: Write(2, 3)
						FCD_EEPROM0_WriteEEPROM(2, 3);
0707  3002  	MOVLW 0x02
0708  1283  	BCF STATUS, RP0
0709  1303  	BCF STATUS, RP1
070A  00FD  	MOVWF FCD_EEPROM_00067_arg_addr
070B  01FE  	CLRF FCD_EEPROM_00067_arg_addr+D'1'
070C  3003  	MOVLW 0x03
070D  1683  	BSF STATUS, RP0
070E  00A0  	MOVWF FCD_EEPROM_00067_arg_data
070F  01A1  	CLRF FCD_EEPROM_00067_arg_data+D'1'
0710  2628  	CALL FCD_EEPROM_00067


						//Delay
						//Delay: 100 ms
						delay_ms(100);
0711  3064  	MOVLW 0x64
0712  1283  	BCF STATUS, RP0
0713  1303  	BCF STATUS, RP1
0714  00FD  	MOVWF delay_ms_00000_arg_del
0715  2010  	CALL delay_ms_00000


						//Goto Connection Point
						//Goto Connection Point: [C]: C
						goto FCC_calibrate_C;


					} else {

						//Calculation
						//Calculation:
						//  reset_counter = reset_counter + 1
						FCV_RESET_COUNTER = FCV_RESET_COUNTER + 1;
0717  0A59  	INCF gbl_FCV_RESET_COUNTER, W
0718  00D9  	MOVWF gbl_FCV_RESET_COUNTER


					}


				}

			// } else {

			}

		}

		//Call Macro
		//Call Macro: display_temp_calib()
		FCM_display_temp_calib();
071A  23AC  	CALL FCM_displa_00066


		//Calculation
		//Calculation:
		//  calib_count = calib_count + 1
		FCV_CALIB_COUNT = FCV_CALIB_COUNT + 1;
071B  0A65  	INCF gbl_FCV_CALIB_COUNT, W
071C  00E5  	MOVWF gbl_FCV_CALIB_COUNT


		//Decision
		//Decision: calib_count = 150?
		if (FCV_CALIB_COUNT == 150)
071D  0865  	MOVF gbl_FCV_CALIB_COUNT, W
071E  3A96  	XORLW 0x96
071F  1D03  	BTFSS STATUS,Z

		{

			//Goto Connection Point
			//Goto Connection Point: [B]: B
			goto FCC_calibrate_B;


		// } else {

		}


	}

	//Connection Point
	//Connection Point: [B]: B
FCC_calibrate_B:
;

	//Calculation
	//Calculation:
	//  save_calib0 = calib_subtractor - 250
	//  save_calib1 = calib_offset
	FCV_SAVE_CALIB0 = FCV_CALIB_SUBTRACTOR - 250;
0721  30FA  	MOVLW 0xFA
0722  0243  	SUBWF gbl_FCV_CALIB_SUBTRACTOR, W
0723  00C5  	MOVWF gbl_FCV_SAVE_CALIB0
0724  0844  	MOVF gbl_FCV_CALIB_SUBTRACTOR+D'1', W
0725  00C6  	MOVWF gbl_FCV_SAVE_CALIB0+D'1'
0726  1C03  	BTFSS STATUS,C
0727  03C6  	DECF gbl_FCV_SAVE_CALIB0+D'1', F

	FCV_SAVE_CALIB1 = FCV_CALIB_OFFSET;
0728  0847  	MOVF gbl_FCV_CALIB_OFFSET, W
0729  00E8  	MOVWF gbl_FCV_SAVE_CALIB1


	//Call Component Macro
	//Call Component Macro: Write(1, save_calib0)
	FCD_EEPROM0_WriteEEPROM(1, FCV_SAVE_CALIB0);
072A  3001  	MOVLW 0x01
072B  00FD  	MOVWF FCD_EEPROM_00067_arg_addr
072C  01FE  	CLRF FCD_EEPROM_00067_arg_addr+D'1'
072D  0845  	MOVF gbl_FCV_SAVE_CALIB0, W
072E  1683  	BSF STATUS, RP0
072F  00A0  	MOVWF FCD_EEPROM_00067_arg_data
0730  1283  	BCF STATUS, RP0
0731  0846  	MOVF gbl_FCV_SAVE_CALIB0+D'1', W
0732  1683  	BSF STATUS, RP0
0733  00A1  	MOVWF FCD_EEPROM_00067_arg_data+D'1'
0734  2628  	CALL FCD_EEPROM_00067


	//Call Component Macro
	//Call Component Macro: Write(2, save_calib1)
	FCD_EEPROM0_WriteEEPROM(2, FCV_SAVE_CALIB1);
0735  3002  	MOVLW 0x02
0736  1283  	BCF STATUS, RP0
0737  1303  	BCF STATUS, RP1
0738  00FD  	MOVWF FCD_EEPROM_00067_arg_addr
0739  01FE  	CLRF FCD_EEPROM_00067_arg_addr+D'1'
073A  0868  	MOVF gbl_FCV_SAVE_CALIB1, W
073B  1683  	BSF STATUS, RP0
073C  00A0  	MOVWF FCD_EEPROM_00067_arg_data
073D  01A1  	CLRF FCD_EEPROM_00067_arg_data+D'1'
073E  2628  	CALL FCD_EEPROM_00067


	//Delay
	//Delay: 100 ms
	delay_ms(100);
073F  3064  	MOVLW 0x64
0740  1283  	BCF STATUS, RP0
0741  1303  	BCF STATUS, RP1
0742  00FD  	MOVWF delay_ms_00000_arg_del
0743  2010  	CALL delay_ms_00000


	//Connection Point
	//Connection Point: [C]: C
FCC_calibrate_C:
;

}
0716  0008  	RETURN
0744  0008  	RETURN



void FCM_display_temp_calib()

{

	//Calculation
	//Calculation:
	//  temp_tens = temp_c / 10
	//  temp_ones = temp_c MOD 10
	//  temp_dec = temp_cdp
	FCV_TEMP_TENS = FCV_TEMP_C / 10;
03AC  1683  	BSF STATUS, RP0
03AD  1303  	BCF STATUS, RP1
03AE  01A8  	CLRF CompTempVar2276
03AF  1283  	BCF STATUS, RP0
03B0  0838  	MOVF gbl_FCV_TEMP_C, W
03B1  1683  	BSF STATUS, RP0
03B2  00A0  	MOVWF __div_32_3_00001_arg_a
03B3  1283  	BCF STATUS, RP0
03B4  0839  	MOVF gbl_FCV_TEMP_C+D'1', W
03B5  1683  	BSF STATUS, RP0
03B6  00A1  	MOVWF __div_32_3_00001_arg_a+D'1'
03B7  1283  	BCF STATUS, RP0
03B8  083A  	MOVF gbl_FCV_TEMP_C+D'2', W
03B9  1683  	BSF STATUS, RP0
03BA  00A2  	MOVWF __div_32_3_00001_arg_a+D'2'
03BB  1283  	BCF STATUS, RP0
03BC  083B  	MOVF gbl_FCV_TEMP_C+D'3', W
03BD  1683  	BSF STATUS, RP0
03BE  00A3  	MOVWF __div_32_3_00001_arg_a+D'3'
03BF  1283  	BCF STATUS, RP0
03C0  1FBB  	BTFSS gbl_FCV_TEMP_C+D'3',7
03C1  2BCF  	GOTO	label59
03C2  1683  	BSF STATUS, RP0
03C3  09A0  	COMF __div_32_3_00001_arg_a, F
03C4  09A1  	COMF __div_32_3_00001_arg_a+D'1', F
03C5  09A2  	COMF __div_32_3_00001_arg_a+D'2', F
03C6  09A3  	COMF __div_32_3_00001_arg_a+D'3', F
03C7  0AA0  	INCF __div_32_3_00001_arg_a, F
03C8  1903  	BTFSC STATUS,Z
03C9  0AA1  	INCF __div_32_3_00001_arg_a+D'1', F
03CA  1903  	BTFSC STATUS,Z
03CB  0AA2  	INCF __div_32_3_00001_arg_a+D'2', F
03CC  1903  	BTFSC STATUS,Z
03CD  0AA3  	INCF __div_32_3_00001_arg_a+D'3', F
03CE  0AA8  	INCF CompTempVar2276, F
03CF        label59
03CF  300A  	MOVLW 0x0A
03D0  1683  	BSF STATUS, RP0
03D1  00A4  	MOVWF __div_32_3_00001_arg_b
03D2  01A5  	CLRF __div_32_3_00001_arg_b+D'1'
03D3  01A6  	CLRF __div_32_3_00001_arg_b+D'2'
03D4  01A7  	CLRF __div_32_3_00001_arg_b+D'3'
03D5  2184  	CALL __div_32_3_00001
03D6  0831  	MOVF CompTempVarRet210, W
03D7  1283  	BCF STATUS, RP0
03D8  00D2  	MOVWF gbl_FCV_TEMP_TENS
03D9  1683  	BSF STATUS, RP0
03DA  1C28  	BTFSS CompTempVar2276,0
03DB  2BDF  	GOTO	label60
03DC  1283  	BCF STATUS, RP0
03DD  09D2  	COMF gbl_FCV_TEMP_TENS, F
03DE  0AD2  	INCF gbl_FCV_TEMP_TENS, F
03DF        label60

	FCV_TEMP_ONES = FCV_TEMP_C % 10;
03DF  1283  	BCF STATUS, RP0
03E0  0838  	MOVF gbl_FCV_TEMP_C, W
03E1  1683  	BSF STATUS, RP0
03E2  00A0  	MOVWF __rem_32_3_00002_arg_a
03E3  1283  	BCF STATUS, RP0
03E4  0839  	MOVF gbl_FCV_TEMP_C+D'1', W
03E5  1683  	BSF STATUS, RP0
03E6  00A1  	MOVWF __rem_32_3_00002_arg_a+D'1'
03E7  1283  	BCF STATUS, RP0
03E8  083A  	MOVF gbl_FCV_TEMP_C+D'2', W
03E9  1683  	BSF STATUS, RP0
03EA  00A2  	MOVWF __rem_32_3_00002_arg_a+D'2'
03EB  1283  	BCF STATUS, RP0
03EC  083B  	MOVF gbl_FCV_TEMP_C+D'3', W
03ED  1683  	BSF STATUS, RP0
03EE  00A3  	MOVWF __rem_32_3_00002_arg_a+D'3'
03EF  1283  	BCF STATUS, RP0
03F0  1FBB  	BTFSS gbl_FCV_TEMP_C+D'3',7
03F1  2BFE  	GOTO	label61
03F2  1683  	BSF STATUS, RP0
03F3  09A0  	COMF __rem_32_3_00002_arg_a, F
03F4  09A1  	COMF __rem_32_3_00002_arg_a+D'1', F
03F5  09A2  	COMF __rem_32_3_00002_arg_a+D'2', F
03F6  09A3  	COMF __rem_32_3_00002_arg_a+D'3', F
03F7  0AA0  	INCF __rem_32_3_00002_arg_a, F
03F8  1903  	BTFSC STATUS,Z
03F9  0AA1  	INCF __rem_32_3_00002_arg_a+D'1', F
03FA  1903  	BTFSC STATUS,Z
03FB  0AA2  	INCF __rem_32_3_00002_arg_a+D'2', F
03FC  1903  	BTFSC STATUS,Z
03FD  0AA3  	INCF __rem_32_3_00002_arg_a+D'3', F
03FE        label61
03FE  300A  	MOVLW 0x0A
03FF  1683  	BSF STATUS, RP0
0400  00A4  	MOVWF __rem_32_3_00002_arg_b
0401  01A5  	CLRF __rem_32_3_00002_arg_b+D'1'
0402  01A6  	CLRF __rem_32_3_00002_arg_b+D'2'
0403  01A7  	CLRF __rem_32_3_00002_arg_b+D'3'
0404  213A  	CALL __rem_32_3_00002
0405  082D  	MOVF CompTempVarRet212, W
0406  1283  	BCF STATUS, RP0
0407  00DC  	MOVWF gbl_FCV_TEMP_ONES
0408  1FBB  	BTFSS gbl_FCV_TEMP_C+D'3',7
0409  2C0C  	GOTO	label62
040A  09DC  	COMF gbl_FCV_TEMP_ONES, F
040B  0ADC  	INCF gbl_FCV_TEMP_ONES, F
040C        label62

	FCV_TEMP_DEC = FCV_TEMP_CDP;
040C  0841  	MOVF gbl_FCV_TEMP_CDP, W
040D  00DA  	MOVWF gbl_FCV_TEMP_DEC


	//Output
	//Output: 0b00000001 -> PORTB
	trisb = 0x00;
040E  1683  	BSF STATUS, RP0
040F  0186  	CLRF gbl_trisb

	portb = (1);
0410  3001  	MOVLW 0x01
0411  1283  	BCF STATUS, RP0
0412  0086  	MOVWF gbl_portb


	//Call Macro
	//Call Macro: scan_off()
	FCM_scan_off();
0413  2078  	CALL FCM_scan_o_00051


	//Call Macro
	//Call Macro: scan1()
	FCM_scan1();
0414  2109  	CALL FCM_scan1_00000


	//Calculation
	//Calculation:
	//  digit = temp_tens
	FCV_DIGIT = FCV_TEMP_TENS;
0415  0852  	MOVF gbl_FCV_TEMP_TENS, W
0416  00E1  	MOVWF gbl_FCV_DIGIT


	//Call Macro
	//Call Macro: seg_pattern()
	FCM_seg_pattern();
0417  21E3  	CALL FCM_seg_pa_00052


	//Delay
	//Delay: 4 ms
	delay_ms(4);
0418  3004  	MOVLW 0x04
0419  00FD  	MOVWF delay_ms_00000_arg_del
041A  2010  	CALL delay_ms_00000


	//Output
	//Output: 0b00000001 -> PORTB
	trisb = 0x00;
041B  1683  	BSF STATUS, RP0
041C  0186  	CLRF gbl_trisb

	portb = (1);
041D  3001  	MOVLW 0x01
041E  1283  	BCF STATUS, RP0
041F  0086  	MOVWF gbl_portb


	//Call Macro
	//Call Macro: scan_off()
	FCM_scan_off();
0420  2078  	CALL FCM_scan_o_00051


	//Call Macro
	//Call Macro: scan2()
	FCM_scan2();
0421  20E4  	CALL FCM_scan2_00000


	//Calculation
	//Calculation:
	//  digit = temp_ones
	FCV_DIGIT = FCV_TEMP_ONES;
0422  085C  	MOVF gbl_FCV_TEMP_ONES, W
0423  00E1  	MOVWF gbl_FCV_DIGIT


	//Call Macro
	//Call Macro: seg_pattern()
	FCM_seg_pattern();
0424  21E3  	CALL FCM_seg_pa_00052


	//Output
	//Output: 0 -> B0
	trisb = trisb & 0xFE;
0425  30FE  	MOVLW 0xFE
0426  1683  	BSF STATUS, RP0
0427  0506  	ANDWF gbl_trisb, W
0428  0086  	MOVWF gbl_trisb

	if ((0))
		portb = (portb & 0xFE) | 0x01;
	else
		portb = portb & 0xFE;
0429  30FE  	MOVLW 0xFE
042A  1283  	BCF STATUS, RP0
042B  0506  	ANDWF gbl_portb, W
042C  0086  	MOVWF gbl_portb


	//Delay
	//Delay: 4 ms
	delay_ms(4);
042D  3004  	MOVLW 0x04
042E  00FD  	MOVWF delay_ms_00000_arg_del
042F  2010  	CALL delay_ms_00000


	//Output
	//Output: 0b00000001 -> PORTB
	trisb = 0x00;
0430  1683  	BSF STATUS, RP0
0431  0186  	CLRF gbl_trisb

	portb = (1);
0432  3001  	MOVLW 0x01
0433  1283  	BCF STATUS, RP0
0434  0086  	MOVWF gbl_portb


	//Call Macro
	//Call Macro: scan_off()
	FCM_scan_off();
0435  2078  	CALL FCM_scan_o_00051


	//Call Macro
	//Call Macro: scan3()
	FCM_scan3();
0436  20BF  	CALL FCM_scan3_00000


	//Calculation
	//Calculation:
	//  digit = temp_dec
	FCV_DIGIT = FCV_TEMP_DEC;
0437  085A  	MOVF gbl_FCV_TEMP_DEC, W
0438  00E1  	MOVWF gbl_FCV_DIGIT


	//Call Macro
	//Call Macro: seg_pattern()
	FCM_seg_pattern();
0439  21E3  	CALL FCM_seg_pa_00052


	//Delay
	//Delay: 4 ms
	delay_ms(4);
043A  3004  	MOVLW 0x04
043B  00FD  	MOVWF delay_ms_00000_arg_del
043C  2010  	CALL delay_ms_00000


	//Output
	//Output: 0b00000001 -> PORTB
	trisb = 0x00;
043D  1683  	BSF STATUS, RP0
043E  0186  	CLRF gbl_trisb

	portb = (1);
043F  3001  	MOVLW 0x01
0440  1283  	BCF STATUS, RP0
0441  0086  	MOVWF gbl_portb


	//Call Macro
	//Call Macro: scan_off()
	FCM_scan_off();
0442  2078  	CALL FCM_scan_o_00051


	//Call Macro
	//Call Macro: scan4()
	FCM_scan4();
0443  209A  	CALL FCM_scan4_00000


	//Output
	//Output: 0b11110000 -> PORTB
	trisb = 0x00;
0444  1683  	BSF STATUS, RP0
0445  0186  	CLRF gbl_trisb

	portb = (240);
0446  30F0  	MOVLW 0xF0
0447  1283  	BCF STATUS, RP0
0448  0086  	MOVWF gbl_portb


	//Delay
	//Delay: 4 ms
	delay_ms(4);
0449  3004  	MOVLW 0x04
044A  00FD  	MOVWF delay_ms_00000_arg_del
044B  2010  	CALL delay_ms_00000


}
044C  0008  	RETURN



void FCM_calc_calib()
{

}



void main()

{
	//Initialization
	adcon1 = 0x07;
078B  3007  	MOVLW 0x07
078C  1683  	BSF STATUS, RP0
078D  1303  	BCF STATUS, RP1
078E  009F  	MOVWF gbl_adcon1


	
		RS232_7_UART_Init( );		//Call initialise function
078F  2634  	CALL FC_CAL_UAR_00081



	//Interrupt initialization code
	option_reg = 0xC0;
0790  30C0  	MOVLW 0xC0
0791  0081  	MOVWF gbl_option_reg



	//Calculation
	//Calculation:
	//  data0 = 123
	//  data1 = 0xff
	//  data2 = 0xff
	//  lsb = 0x00
	//  msb = 0x00
	FCV_DATA0 = 123;
0792  307B  	MOVLW 0x7B
0793  1283  	BCF STATUS, RP0
0794  00D4  	MOVWF gbl_FCV_DATA0

	FCV_DATA1 = 0xff;
0795  30FF  	MOVLW 0xFF
0796  00D5  	MOVWF gbl_FCV_DATA1

	FCV_DATA2 = 0xff;
0797  00D8  	MOVWF gbl_FCV_DATA2

	FCV_LSB = 0x00;
0798  01DD  	CLRF gbl_FCV_LSB

	FCV_MSB = 0x00;
0799  01E0  	CLRF gbl_FCV_MSB


	//Calculation
	//Calculation:
	//  temp_tens = 0
	//  temp_ones = 0
	//  temp_dec = 0
	FCV_TEMP_TENS = 0;
079A  01D2  	CLRF gbl_FCV_TEMP_TENS

	FCV_TEMP_ONES = 0;
079B  01DC  	CLRF gbl_FCV_TEMP_ONES

	FCV_TEMP_DEC = 0;
079C  01DA  	CLRF gbl_FCV_TEMP_DEC


	//Call Component Macro
	//Call Component Macro: MI2C_Init()
	FCD_I2C_Master0_MI2C_Init();
079D  2780  	CALL FCD_I2C_Ma_0007A


	//Call Component Macro
	//Call Component Macro: Enable()
	FCD_PWM0_Enable();
079E  2776  	CALL FCD_PWM0_E_0006E


	//Call Component Macro
	//Call Component Macro: LEDOff()
	FCD_LED0_LEDOff();
079F  2134  	CALL FCD_LED0_L_00055


	//Call Component Macro
	//Call Component Macro: LEDOff()
	FCD_LED1_LEDOff();
07A0  212E  	CALL FCD_LED1_L_00058


	//Delay
	//Delay: 300 ms
	delay_ms(255);
07A1  30FF  	MOVLW 0xFF
07A2  00FD  	MOVWF delay_ms_00000_arg_del
07A3  2010  	CALL delay_ms_00000

	delay_ms(45);
07A4  302D  	MOVLW 0x2D
07A5  00FD  	MOVWF delay_ms_00000_arg_del
07A6  2010  	CALL delay_ms_00000


	//Loop
	//Loop: While 1
	while (1)
07A7        label96
090E  2FA7  	GOTO	label96

	{

		//Call Macro
		//Call Macro: lights_off()
		FCM_lights_off();
07A7  2241  	CALL FCM_lights_0005F


		//Call Component Macro
		//Call Component Macro: calib_subtractor=Read(1)
		FCV_CALIB_SUBTRACTOR = FCD_EEPROM0_EEPROMRead(1);
07A8  3001  	MOVLW 0x01
07A9  00F5  	MOVWF FCD_EEPROM_00080_arg_addr
07AA  01F6  	CLRF FCD_EEPROM_00080_arg_addr+D'1'
07AB  2782  	CALL FCD_EEPROM_00080
07AC  0877  	MOVF CompTempVarRet2293, W
07AD  00C3  	MOVWF gbl_FCV_CALIB_SUBTRACTOR
07AE  0878  	MOVF CompTempVarRet2293+D'1', W
07AF  00C4  	MOVWF gbl_FCV_CALIB_SUBTRACTOR+D'1'


		//Call Component Macro
		//Call Component Macro: calib_offset=Read(2)
		FCV_CALIB_OFFSET = FCD_EEPROM0_EEPROMRead(2);
07B0  3002  	MOVLW 0x02
07B1  00F5  	MOVWF FCD_EEPROM_00080_arg_addr
07B2  01F6  	CLRF FCD_EEPROM_00080_arg_addr+D'1'
07B3  2782  	CALL FCD_EEPROM_00080
07B4  0877  	MOVF CompTempVarRet2293, W
07B5  00C7  	MOVWF gbl_FCV_CALIB_OFFSET
07B6  0878  	MOVF CompTempVarRet2293+D'1', W
07B7  00C8  	MOVWF gbl_FCV_CALIB_OFFSET+D'1'


		//Calculation
		//Calculation:
		//  calib_subtractor = calib_subtractor + 250
		FCV_CALIB_SUBTRACTOR = FCV_CALIB_SUBTRACTOR + 250;
07B8  30FA  	MOVLW 0xFA
07B9  07C3  	ADDWF gbl_FCV_CALIB_SUBTRACTOR, F
07BA  08C4  	MOVF gbl_FCV_CALIB_SUBTRACTOR+D'1', F
07BB  1803  	BTFSC STATUS,C
07BC  0AC4  	INCF gbl_FCV_CALIB_SUBTRACTOR+D'1', F
07BD        label97


		//Connection Point
		//Connection Point: [A]: A
FCC_Main_A:
;

		//Calculation
		//Calculation:
		//  prox_counter = 0
		//  sw_calib = 0
		FCV_PROX_COUNTER = 0;
07BD  01DF  	CLRF gbl_FCV_PROX_COUNTER

		FCV_SW_CALIB = 0;
07BE  01E7  	CLRF gbl_FCV_SW_CALIB


		//Connection Point
		//Connection Point: [B]: B
FCC_Main_B:
07BF        label98

;

		//Call Macro
		//Call Macro: all_input()
		FCM_all_input();
07BF  25F2  	CALL FCM_all_in_00054


		//Decision
		//Decision: prox_bit = 0?
		if (FCV_PROX_BIT == 0)
07C0  158A  	BSF PCLATH,3
07C1  185B  	BTFSC gbl_FCV_PROX_BIT,0
07C2  28B7  	GOTO	label115
08B7        label115

		{

			//Decision
			//Decision: prox_counter = 10?
			if (FCV_PROX_COUNTER == 10)
07C3  085F  	MOVF gbl_FCV_PROX_COUNTER, W
07C4  3A0A  	XORLW 0x0A
07C6  1903  	BTFSC STATUS,Z

			{

			} else {
07C5  118A  	BCF PCLATH,3
07C7  2FCE  	GOTO	label99
07CE        label99


				//Delay
				//Delay: 30 ms
				delay_ms(30);
07C8  301E  	MOVLW 0x1E
07C9  00FD  	MOVWF delay_ms_00000_arg_del
07CA  2010  	CALL delay_ms_00000


				//Calculation
				//Calculation:
				//  prox_counter = prox_counter + 1
				FCV_PROX_COUNTER = FCV_PROX_COUNTER + 1;
07CB  0A5F  	INCF gbl_FCV_PROX_COUNTER, W
07CC  00DF  	MOVWF gbl_FCV_PROX_COUNTER


				//Goto Connection Point
				//Goto Connection Point: [B]: B
				goto FCC_Main_B;
07CD  2FBF  	GOTO	label98
08B5  158A  	BSF PCLATH,3
08B6  28B1  	GOTO	label114


			}

			//Call Macro
			//Call Macro: beep_once()
			FCM_beep_once();
07CE  2745  	CALL FCM_beep_o_00060


			//Call Macro
			//Call Macro: get_temp()
			FCM_get_temp();
07CF  2646  	CALL FCM_get_te_00062


			//Calculation
			//Calculation:
			//  temp_tens = temp_c / 10
			//  temp_ones = temp_c MOD 10
			//  temp_dec = temp_cdp
			FCV_TEMP_TENS = FCV_TEMP_C / 10;
07D0  01FD  	CLRF CompTempVar2308
07D1  0838  	MOVF gbl_FCV_TEMP_C, W
07D2  1683  	BSF STATUS, RP0
07D3  00A0  	MOVWF __div_32_3_00001_arg_a
07D4  1283  	BCF STATUS, RP0
07D5  0839  	MOVF gbl_FCV_TEMP_C+D'1', W
07D6  1683  	BSF STATUS, RP0
07D7  00A1  	MOVWF __div_32_3_00001_arg_a+D'1'
07D8  1283  	BCF STATUS, RP0
07D9  083A  	MOVF gbl_FCV_TEMP_C+D'2', W
07DA  1683  	BSF STATUS, RP0
07DB  00A2  	MOVWF __div_32_3_00001_arg_a+D'2'
07DC  1283  	BCF STATUS, RP0
07DD  083B  	MOVF gbl_FCV_TEMP_C+D'3', W
07DE  1683  	BSF STATUS, RP0
07DF  00A3  	MOVWF __div_32_3_00001_arg_a+D'3'
07E0  1283  	BCF STATUS, RP0
07E1  1FBB  	BTFSS gbl_FCV_TEMP_C+D'3',7
07E2  2FF1  	GOTO	label100
07E3  1683  	BSF STATUS, RP0
07E4  09A0  	COMF __div_32_3_00001_arg_a, F
07E5  09A1  	COMF __div_32_3_00001_arg_a+D'1', F
07E6  09A2  	COMF __div_32_3_00001_arg_a+D'2', F
07E7  09A3  	COMF __div_32_3_00001_arg_a+D'3', F
07E8  0AA0  	INCF __div_32_3_00001_arg_a, F
07E9  1903  	BTFSC STATUS,Z
07EA  0AA1  	INCF __div_32_3_00001_arg_a+D'1', F
07EB  1903  	BTFSC STATUS,Z
07EC  0AA2  	INCF __div_32_3_00001_arg_a+D'2', F
07ED  1903  	BTFSC STATUS,Z
07EE  0AA3  	INCF __div_32_3_00001_arg_a+D'3', F
07EF  1283  	BCF STATUS, RP0
07F0  0AFD  	INCF CompTempVar2308, F
07F1        label100
07F1  300A  	MOVLW 0x0A
07F2  1683  	BSF STATUS, RP0
07F3  00A4  	MOVWF __div_32_3_00001_arg_b
07F4  01A5  	CLRF __div_32_3_00001_arg_b+D'1'
07F5  01A6  	CLRF __div_32_3_00001_arg_b+D'2'
07F6  01A7  	CLRF __div_32_3_00001_arg_b+D'3'
07F7  2184  	CALL __div_32_3_00001
07F8  0831  	MOVF CompTempVarRet210, W
07F9  1283  	BCF STATUS, RP0
07FA  00D2  	MOVWF gbl_FCV_TEMP_TENS
07FB  1C7D  	BTFSS CompTempVar2308,0
07FC  2FFF  	GOTO	label101
07FD  09D2  	COMF gbl_FCV_TEMP_TENS, F
07FE  0AD2  	INCF gbl_FCV_TEMP_TENS, F
07FF        label101

			FCV_TEMP_ONES = FCV_TEMP_C % 10;
07FF  0838  	MOVF gbl_FCV_TEMP_C, W
0800  1683  	BSF STATUS, RP0
0801  00A0  	MOVWF __rem_32_3_00002_arg_a
0802  1283  	BCF STATUS, RP0
0803  0839  	MOVF gbl_FCV_TEMP_C+D'1', W
0804  1683  	BSF STATUS, RP0
0805  00A1  	MOVWF __rem_32_3_00002_arg_a+D'1'
0806  1283  	BCF STATUS, RP0
0807  083A  	MOVF gbl_FCV_TEMP_C+D'2', W
0808  1683  	BSF STATUS, RP0
0809  00A2  	MOVWF __rem_32_3_00002_arg_a+D'2'
080A  1283  	BCF STATUS, RP0
080B  083B  	MOVF gbl_FCV_TEMP_C+D'3', W
080C  1683  	BSF STATUS, RP0
080D  00A3  	MOVWF __rem_32_3_00002_arg_a+D'3'
080E  1283  	BCF STATUS, RP0
080F  158A  	BSF PCLATH,3
0810  1FBB  	BTFSS gbl_FCV_TEMP_C+D'3',7
0811  281E  	GOTO	label102
0812  1683  	BSF STATUS, RP0
0813  09A0  	COMF __rem_32_3_00002_arg_a, F
0814  09A1  	COMF __rem_32_3_00002_arg_a+D'1', F
0815  09A2  	COMF __rem_32_3_00002_arg_a+D'2', F
0816  09A3  	COMF __rem_32_3_00002_arg_a+D'3', F
0817  0AA0  	INCF __rem_32_3_00002_arg_a, F
0818  1903  	BTFSC STATUS,Z
0819  0AA1  	INCF __rem_32_3_00002_arg_a+D'1', F
081A  1903  	BTFSC STATUS,Z
081B  0AA2  	INCF __rem_32_3_00002_arg_a+D'2', F
081C  1903  	BTFSC STATUS,Z
081D  0AA3  	INCF __rem_32_3_00002_arg_a+D'3', F
081E        label102
081E  300A  	MOVLW 0x0A
081F  1683  	BSF STATUS, RP0
0820  00A4  	MOVWF __rem_32_3_00002_arg_b
0821  01A5  	CLRF __rem_32_3_00002_arg_b+D'1'
0822  01A6  	CLRF __rem_32_3_00002_arg_b+D'2'
0823  01A7  	CLRF __rem_32_3_00002_arg_b+D'3'
0824  118A  	BCF PCLATH,3
0825  213A  	CALL __rem_32_3_00002
0826  082D  	MOVF CompTempVarRet212, W
0827  1283  	BCF STATUS, RP0
0828  00DC  	MOVWF gbl_FCV_TEMP_ONES
0829  158A  	BSF PCLATH,3
082A  1FBB  	BTFSS gbl_FCV_TEMP_C+D'3',7
082B  282E  	GOTO	label103
082C  09DC  	COMF gbl_FCV_TEMP_ONES, F
082D  0ADC  	INCF gbl_FCV_TEMP_ONES, F
082E        label103

			FCV_TEMP_DEC = FCV_TEMP_CDP;
082E  0841  	MOVF gbl_FCV_TEMP_CDP, W
082F  00DA  	MOVWF gbl_FCV_TEMP_DEC


			//Decision
			//Decision: temp_c < 34?
			if (FCV_TEMP_C < 34)
0830  3000  	MOVLW 0x00
0831  023B  	SUBWF gbl_FCV_TEMP_C+D'3', W
0832  1D03  	BTFSS STATUS,Z
0833  283E  	GOTO	label104
0834  3000  	MOVLW 0x00
0835  023A  	SUBWF gbl_FCV_TEMP_C+D'2', W
0836  1D03  	BTFSS STATUS,Z
0837  283E  	GOTO	label104
0838  3000  	MOVLW 0x00
0839  0239  	SUBWF gbl_FCV_TEMP_C+D'1', W
083A  1D03  	BTFSS STATUS,Z
083B  283E  	GOTO	label104
083C  3022  	MOVLW 0x22
083D  0238  	SUBWF gbl_FCV_TEMP_C, W
083E        label104
083E  1C03  	BTFSS STATUS,C
083F  2842  	GOTO	label105
0840  1FBB  	BTFSS gbl_FCV_TEMP_C+D'3',7
0841  2846  	GOTO	label106
0842        label105
0846        label106

			{

				//Call Macro
				//Call Macro: repeat()
				FCM_repeat();
0842  118A  	BCF PCLATH,3
0843  232A  	CALL FCM_repeat_00000


			} else {
0844  158A  	BSF PCLATH,3
0845  28AF  	GOTO	label113


				//Decision
				//Decision: temp_c >= 38?
				if (FCV_TEMP_C >= 38)
0846  3000  	MOVLW 0x00
0847  023B  	SUBWF gbl_FCV_TEMP_C+D'3', W
0848  1D03  	BTFSS STATUS,Z
0849  2854  	GOTO	label107
084A  3000  	MOVLW 0x00
084B  023A  	SUBWF gbl_FCV_TEMP_C+D'2', W
084C  1D03  	BTFSS STATUS,Z
084D  2854  	GOTO	label107
084E  3000  	MOVLW 0x00
084F  0239  	SUBWF gbl_FCV_TEMP_C+D'1', W
0850  1D03  	BTFSS STATUS,Z
0851  2854  	GOTO	label107
0852  3026  	MOVLW 0x26
0853  0238  	SUBWF gbl_FCV_TEMP_C, W
0854        label107
0854  1103  	BCF STATUS,Z
0855  1C03  	BTFSS STATUS,C
0856  286D  	GOTO	label109
0857  1BBB  	BTFSC gbl_FCV_TEMP_C+D'3',7
0858  286D  	GOTO	label109
0859        label108
086D        label109

				{

					//Connection Point
					//Connection Point: [C]: C
FCC_Main_C:

;

					//Call Component Macro
					//Call Component Macro: SendRS232String("FAIL")
					FCD_RS2320_SendRS232String("FAIL", 4);
0859  3046  	MOVLW 0x46
085A  00F7  	MOVWF CompTempVar2310
085B  3041  	MOVLW 0x41
085C  00F8  	MOVWF CompTempVar2310+D'1'
085D  3049  	MOVLW 0x49
085E  00F9  	MOVWF CompTempVar2310+D'2'
085F  304C  	MOVLW 0x4C
0860  00FA  	MOVWF CompTempVar2310+D'3'
0861  01FB  	CLRF CompTempVar2310+D'4'
0862  3000  	MOVLW HIGH(CompTempVar2310+D'0')
0863  00F6  	MOVWF FCD_RS2320_00087_arg_String+D'1'
0864  3077  	MOVLW LOW(CompTempVar2310+D'0')
0865  00F5  	MOVWF FCD_RS2320_00087_arg_String
0866  3004  	MOVLW 0x04
0867  00FC  	MOVWF FCD_RS2320_00087_arg_MSZ_String
0868  118A  	BCF PCLATH,3
0869  275B  	CALL FCD_RS2320_00087


					//Call Macro
					//Call Macro: display_fail()
					FCM_display_fail();
086A  265E  	CALL FCM_displa_00064


				} else {
086B  158A  	BSF PCLATH,3
086C  28AF  	GOTO	label113
08AF        label113


					//Decision
					//Decision: temp_c = 37 AND temp_cdp >= 8?
					if (FCV_TEMP_C == 37 & FCV_TEMP_CDP >= 8)
086D  01F6  	CLRF CompTempVar2313
086E  0AF6  	INCF CompTempVar2313, F
086F  0838  	MOVF gbl_FCV_TEMP_C, W
0870  3C25  	SUBLW 0x25
0871  1D03  	BTFSS STATUS,Z
0872  01F6  	CLRF CompTempVar2313
0873  0839  	MOVF gbl_FCV_TEMP_C+D'1', W
0874  3C00  	SUBLW 0x00
0875  1D03  	BTFSS STATUS,Z
0876  01F6  	CLRF CompTempVar2313
0877  083A  	MOVF gbl_FCV_TEMP_C+D'2', W
0878  3C00  	SUBLW 0x00
0879  1D03  	BTFSS STATUS,Z
087A  01F6  	CLRF CompTempVar2313
087B  083B  	MOVF gbl_FCV_TEMP_C+D'3', W
087C  3C00  	SUBLW 0x00
087D  1D03  	BTFSS STATUS,Z
087E  01F6  	CLRF CompTempVar2313
087F  01F5  	CLRF CompTempVar2312
0880  0842  	MOVF gbl_FCV_TEMP_CDP+D'1', W
0881  3A80  	XORLW 0x80
0882  00F7  	MOVWF CompTempVar2314
0883  3080  	MOVLW 0x80
0884  0277  	SUBWF CompTempVar2314, W
0885  1D03  	BTFSS STATUS,Z
0886  2889  	GOTO	label110
0887  3008  	MOVLW 0x08
0888  0241  	SUBWF gbl_FCV_TEMP_CDP, W
0889        label110
0889  1803  	BTFSC STATUS,C
088A  0AF5  	INCF CompTempVar2312, F
088B  0875  	MOVF CompTempVar2312, W
088C  0576  	ANDWF CompTempVar2313, W
088D  1D03  	BTFSS STATUS,Z

					{

						//Goto Connection Point
						//Goto Connection Point: [C]: C
						goto FCC_Main_C;
088E  2859  	GOTO	label108


					} else {

						//Loop
						//Loop: Loop 90 times
						for (FCLV_LOOP2=0; FCLV_LOOP2<90; FCLV_LOOP2++)
088F  01EB  	CLRF gbl_FCLV_LOOP2
0890        label111
0890  305A  	MOVLW 0x5A
0891  026B  	SUBWF gbl_FCLV_LOOP2, W
0892  1803  	BTFSC STATUS,C
0893  289A  	GOTO	label112
0897  0AEB  	INCF gbl_FCLV_LOOP2, F
0898  158A  	BSF PCLATH,3
0899  2890  	GOTO	label111
089A        label112

						{

							//Call Macro
							//Call Macro: display_temp()
							FCM_display_temp();
0894  118A  	BCF PCLATH,3
0895  244D  	CALL FCM_displa_00053


							//Call Macro
							//Call Macro: pass()
							FCM_pass();
0896  2643  	CALL FCM_pass_00000



						}

						//Call Component Macro
						//Call Component Macro: ret_byte=ReceiveRS232Char(temp_tens)
						FCV_RET_BYTE = FCD_RS2320_ReceiveRS232Char(FCV_TEMP_TENS);
089A  0852  	MOVF gbl_FCV_TEMP_TENS, W
089B  00F7  	MOVWF FCD_RS2320_00088_arg_nTimeout
089C  118A  	BCF PCLATH,3
089D  2750  	CALL FCD_RS2320_00088
089E  0878  	MOVF CompTempVarRet2299, W
089F  00D6  	MOVWF gbl_FCV_RET_BYTE


						//Call Component Macro
						//Call Component Macro: ret_byte=ReceiveRS232Char(temp_ones)
						FCV_RET_BYTE = FCD_RS2320_ReceiveRS232Char(FCV_TEMP_ONES);
08A0  085C  	MOVF gbl_FCV_TEMP_ONES, W
08A1  00F7  	MOVWF FCD_RS2320_00088_arg_nTimeout
08A2  2750  	CALL FCD_RS2320_00088
08A3  0878  	MOVF CompTempVarRet2299, W
08A4  00D6  	MOVWF gbl_FCV_RET_BYTE


						//Call Component Macro
						//Call Component Macro: ret_byte=ReceiveRS232Char('.')
						FCV_RET_BYTE = FCD_RS2320_ReceiveRS232Char('.');
08A5  302E  	MOVLW 0x2E
08A6  00F7  	MOVWF FCD_RS2320_00088_arg_nTimeout
08A7  2750  	CALL FCD_RS2320_00088
08A8  0878  	MOVF CompTempVarRet2299, W
08A9  00D6  	MOVWF gbl_FCV_RET_BYTE


						//Call Component Macro
						//Call Component Macro: ret_byte=ReceiveRS232Char(temp_dec)
						FCV_RET_BYTE = FCD_RS2320_ReceiveRS232Char(FCV_TEMP_DEC);
08AA  085A  	MOVF gbl_FCV_TEMP_DEC, W
08AB  00F7  	MOVWF FCD_RS2320_00088_arg_nTimeout
08AC  2750  	CALL FCD_RS2320_00088
08AD  0878  	MOVF CompTempVarRet2299, W
08AE  00D6  	MOVWF gbl_FCV_RET_BYTE


					}

				}

			}

			//Call Macro
			//Call Macro: scan_off()
			FCM_scan_off();
08AF  118A  	BCF PCLATH,3
08B0  2078  	CALL FCM_scan_o_00051


			//Loop
			//Loop: While prox_bit = 0
			while (FCV_PROX_BIT == 0)
08B1        label114
08B1  118A  	BCF PCLATH,3
08B2  185B  	BTFSC gbl_FCV_PROX_BIT,0
08B3  2FA7  	GOTO	label96

			{

				//Call Macro
				//Call Macro: all_input()
				FCM_all_input();
08B4  25F2  	CALL FCM_all_in_00054



			}

		} else {

			//Delay
			//Delay: 100 ms
			delay_ms(100);
08B7  3064  	MOVLW 0x64
08B8  00FD  	MOVWF delay_ms_00000_arg_del
08B9  118A  	BCF PCLATH,3
08BA  2010  	CALL delay_ms_00000


			//Decision
			//Decision: swg = 0 AND swr = 0?
			if (FCV_SWG == 0 & FCV_SWR == 0)
08BB  01F6  	CLRF CompTempVar2316
08BC  1DDB  	BTFSS gbl_FCV_SWG,3
08BD  0AF6  	INCF CompTempVar2316, F
08BE  01F5  	CLRF CompTempVar2315
08BF  0AF5  	INCF CompTempVar2315, F
08C0  08E2  	MOVF gbl_FCV_SWR, F
08C1  1D03  	BTFSS STATUS,Z
08C2  1075  	BCF CompTempVar2315,0
08C3  0875  	MOVF CompTempVar2315, W
08C4  0576  	ANDWF CompTempVar2316, W
08C5  158A  	BSF PCLATH,3
08C6  1903  	BTFSC STATUS,Z
08C7  28D6  	GOTO	label117
08D6        label117

			{

				//Decision
				//Decision: sw_calib = 10?
				if (FCV_SW_CALIB == 10)
08C8  0867  	MOVF gbl_FCV_SW_CALIB, W
08C9  3A0A  	XORLW 0x0A
08CA  1903  	BTFSC STATUS,Z

				{

				} else {
08CB  28D3  	GOTO	label116
08D3        label116


					//Delay
					//Delay: 30 ms
					delay_ms(30);
08CC  301E  	MOVLW 0x1E
08CD  00FD  	MOVWF delay_ms_00000_arg_del
08CE  118A  	BCF PCLATH,3
08CF  2010  	CALL delay_ms_00000


					//Calculation
					//Calculation:
					//  sw_calib = sw_calib + 1
					FCV_SW_CALIB = FCV_SW_CALIB + 1;
08D0  0A67  	INCF gbl_FCV_SW_CALIB, W
08D1  00E7  	MOVWF gbl_FCV_SW_CALIB


					//Goto Connection Point
					//Goto Connection Point: [B]: B
					goto FCC_Main_B;
08D2  2FBF  	GOTO	label98


				}

				//Call Macro
				//Call Macro: calibrate()
				FCM_calibrate();
08D3  118A  	BCF PCLATH,3
08D4  266C  	CALL FCM_calibr_00065


			} else {
08D5  2FA7  	GOTO	label96


				//Decision
				//Decision: swg = 1 AND swr = 0?
				if (FCV_SWG == 1 & FCV_SWR == 0)
08D6  01F8  	CLRF CompTempVar2318
08D7  19DB  	BTFSC gbl_FCV_SWG,3
08D8  0AF8  	INCF CompTempVar2318, F
08D9  01F7  	CLRF CompTempVar2317
08DA  0AF7  	INCF CompTempVar2317, F
08DB  08E2  	MOVF gbl_FCV_SWR, F
08DC  1D03  	BTFSS STATUS,Z
08DD  1077  	BCF CompTempVar2317,0
08DE  0877  	MOVF CompTempVar2317, W
08DF  0578  	ANDWF CompTempVar2318, W
08E0  1903  	BTFSC STATUS,Z
08E1  290A  	GOTO	label120
090A        label120

				{

					//Loop
					//Loop: Loop 30 times
					for (FCLV_LOOP1=0; FCLV_LOOP1<30; FCLV_LOOP1++)
08E2  01EA  	CLRF gbl_FCLV_LOOP1
08E3        label118
08E3  301E  	MOVLW 0x1E
08E4  026A  	SUBWF gbl_FCLV_LOOP1, W
08E5  1803  	BTFSC STATUS,C
08E6  28F2  	GOTO	label119
08EF  0AEA  	INCF gbl_FCLV_LOOP1, F
08F0  158A  	BSF PCLATH,3
08F1  28E3  	GOTO	label118
08F2        label119

					{

						//Call Macro
						//Call Macro: all_input()
						FCM_all_input();
08E7  118A  	BCF PCLATH,3
08E8  25F2  	CALL FCM_all_in_00054


						//Delay
						//Delay: 100 ms
						delay_ms(100);
08E9  3064  	MOVLW 0x64
08EA  00FD  	MOVWF delay_ms_00000_arg_del
08EB  2010  	CALL delay_ms_00000


						//Decision
						//Decision: swr = 1?
						if (FCV_SWR == 1)
08EC  0362  	DECF gbl_FCV_SWR, W
08ED  1903  	BTFSC STATUS,Z

						{

							//Goto Connection Point
							//Goto Connection Point: [A]: A
							goto FCC_Main_A;
08EE  2FBD  	GOTO	label97


						// } else {

						}


					}

					//Output
					//Output: 1 -> C5
					trisc = trisc & 0xDF;
08F2  30DF  	MOVLW 0xDF
08F3  1683  	BSF STATUS, RP0
08F4  0507  	ANDWF gbl_trisc, W
08F5  0087  	MOVWF gbl_trisc

					if ((1))
						portc = (portc & 0xDF) | 0x20;
08F6  30DF  	MOVLW 0xDF
08F7  1283  	BCF STATUS, RP0
08F8  0507  	ANDWF gbl_portc, W
08F9  00F9  	MOVWF CompTempVar2319
08FA  3020  	MOVLW 0x20
08FB  0479  	IORWF CompTempVar2319, W
08FC  0087  	MOVWF gbl_portc

					else
						portc = portc & 0xDF;

					//Delay
					//Delay: 3 s
					delay_s(3);
08FD  3003  	MOVLW 0x03
08FE  00F9  	MOVWF delay_s_00000_arg_del
08FF  118A  	BCF PCLATH,3
0900  2026  	CALL delay_s_00000


					//Output
					//Output: 0 -> C5
					trisc = trisc & 0xDF;
0901  30DF  	MOVLW 0xDF
0902  1683  	BSF STATUS, RP0
0903  0507  	ANDWF gbl_trisc, W
0904  0087  	MOVWF gbl_trisc

					if ((0))
						portc = (portc & 0xDF) | 0x20;
					else
						portc = portc & 0xDF;
0905  30DF  	MOVLW 0xDF
0906  1283  	BCF STATUS, RP0
0907  0507  	ANDWF gbl_portc, W
0908  0087  	MOVWF gbl_portc


				} else {
0909  2FA7  	GOTO	label96


					//Call Macro
					//Call Macro: scan_off()
					FCM_scan_off();
090A  118A  	BCF PCLATH,3
090B  2078  	CALL FCM_scan_o_00051


					//Call Component Macro
					//Call Component Macro: SetDutyCycle(0)
					FCD_PWM0_SetDutyCycle(0);
090C  01FD  	CLRF FCD_PWM0_S_00061_arg_nDuty
090D  2272  	CALL FCD_PWM0_S_00061


				}

			}

		}


	}

	mainendloop: goto mainendloop;
}


void MX_INTERRUPT_MACRO(void)

{
}
095F  1283  	BCF STATUS, RP0
0960  1303  	BCF STATUS, RP1
0961  0E3E  	SWAPF Int1BContext+D'2', W
0962  0084  	MOVWF FSR
0963  0E3D  	SWAPF Int1BContext+D'1', W
0964  008A  	MOVWF PCLATH
0965  0E3C  	SWAPF Int1BContext, W
0966  0083  	MOVWF STATUS
0967  0EFF  	SWAPF Int1Context, F
0968  0E7F  	SWAPF Int1Context, W
0969  0009  	RETFIE





/*********************************************************************
 *                  Flowcode CAL EEPROM File
 *
 * File: PIC_CAL_EEPROM.c
 *
 * (c) 2011 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * Company) for its Flowcode graphical programming language is
 * intended and supplied to you, the Companys customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 210911 | BR | Created
 */



//EEPROM Function Prototypes
MX_UINT8 FC_CAL_EE_Read (MX_UINT16 Address);
void FC_CAL_EE_Write (MX_UINT16 Address, MX_UINT8 Data);



MX_UINT8 FC_CAL_EE_Read (MX_UINT16 Address)

{
	char data = 0;
031C  01F9  	CLRF FC_CAL_EE__0007D_1_data

	#ifdef MX_EE
		#ifdef _BOOSTC

			#ifdef EEADR
			  #ifndef MX_EEADR
				#define MX_EEADR eeadr
			  #endif
			#endif
			#ifdef EEADRL
			  #ifndef MX_EEADR
				#define MX_EEADR eeadrl
			  #endif
			#endif

			#ifdef EEDATA
			  #ifndef MX_EEDATA
				#define MX_EEDATA eedata
			  #endif
			#endif
			#ifdef EEDATAL
			  #ifndef MX_EEDATA
				#define MX_EEDATA eedatal
			  #endif
			#endif
			#ifdef EEDATL
			  #ifndef MX_EEDATA
				#define MX_EEDATA eedatl
			  #endif
			#endif

			#ifndef MX_EEADR	//Catch Error
				#error "EEPROM error - MX_EEADR not set"
			#endif
			#ifndef MX_EEDATA
				#error "EEPROM error - MX_EEDATA not set"
			#endif

			MX_EEADR = Address & 0xff;
031D  0877  	MOVF FC_CAL_EE__0007D_arg_Address, W
031E  1703  	BSF STATUS, RP1
031F  008D  	MOVWF gbl_eeadr

			#if (MX_EE_SIZE > 256)
				eeadrh = (Address & 0xff00) >> 8;
			#endif
			#ifdef MX_EE_TYPE2
				clear_bit(eecon1, EEPGD);
0320  1683  	BSF STATUS, RP0
0321  138C  	BCF gbl_eecon1,7

			#endif
			#ifdef MX_EE_TYPE3
				clear_bit(eecon1, EEPGD);
				clear_bit(eecon1, CFGS);
			#endif
			set_bit(eecon1, RD);
0322  140C  	BSF gbl_eecon1,0

			data = MX_EEDATA;
0323  1283  	BCF STATUS, RP0
0324  080C  	MOVF gbl_eedata, W
0325  1303  	BCF STATUS, RP1
0326  00F9  	MOVWF FC_CAL_EE__0007D_1_data

		#endif
		#ifdef HI_TECH_C
			data = eeprom_read(Address);
		#endif
	#else
		#error "Chip does not have EEPROM memory"
	#endif
	return (data);
0327  0879  	MOVF FC_CAL_EE__0007D_1_data, W
0328  00FA  	MOVWF CompTempVarRet2292

}
0329  0008  	RETURN


void FC_CAL_EE_Write (MX_UINT16 Address, MX_UINT8 Data)

{
	#ifdef MX_EE
		#ifdef _BOOSTC

			#ifdef EEADR
			  #ifndef MX_EEADR
				#define MX_EEADR eeadr
			  #endif
			#endif
			#ifdef EEADRL
			  #ifndef MX_EEADR
				#define MX_EEADR eeadrl
			  #endif
			#endif

			#ifdef EEDATA
			  #ifndef MX_EEDATA
				#define MX_EEDATA eedata
			  #endif
			#endif
			#ifdef EEDATAL
			  #ifndef MX_EEDATA
				#define MX_EEDATA eedatal
			  #endif
			#endif
			#ifdef EEDATL
			  #ifndef MX_EEDATA
				#define MX_EEDATA eedatl
			  #endif
			#endif

			#ifndef MX_EEADR	//Catch Error
				#error "EEPROM error - MX_EEADR not set"
			#endif
			#ifndef MX_EEDATA
				#error "EEPROM error - MX_EEDATA not set"
			#endif

			char bInterruptsEnabled;
			//wait for previous EE writes to complete...
			while (test_bit(eecon1, WR));
01BD        label22
01BD  1703  	BSF STATUS, RP1
01BE  188C  	BTFSC gbl_eecon1,1
01BF  29BD  	GOTO	label22

			MX_EEADR = Address & 0xff;
01C0  1303  	BCF STATUS, RP1
01C1  0822  	MOVF FC_CAL_EE__0007E_arg_Address, W
01C2  1283  	BCF STATUS, RP0
01C3  1703  	BSF STATUS, RP1
01C4  008D  	MOVWF gbl_eeadr

			#if (MX_EE_SIZE > 256)
				eeadrh = (Address & 0xff00) >> 8;
			#endif
			MX_EEDATA = Data;
01C5  1683  	BSF STATUS, RP0
01C6  1303  	BCF STATUS, RP1
01C7  0824  	MOVF FC_CAL_EE__0007E_arg_Data, W
01C8  1283  	BCF STATUS, RP0
01C9  1703  	BSF STATUS, RP1
01CA  008C  	MOVWF gbl_eedata

			#ifdef MX_EE_TYPE2
				clear_bit(eecon1, EEPGD);
01CB  1683  	BSF STATUS, RP0
01CC  138C  	BCF gbl_eecon1,7

			#endif
			#ifdef MX_EE_TYPE3
				clear_bit(eecon1, EEPGD);
				clear_bit(eecon1, CFGS);
			#endif
			set_bit(eecon1, WREN);
01CD  150C  	BSF gbl_eecon1,2

			bInterruptsEnabled = test_bit(intcon, GIE);
01CE  3080  	MOVLW 0x80
01CF  050B  	ANDWF gbl_intcon, W
01D0  1303  	BCF STATUS, RP1
01D1  00A5  	MOVWF FC_CAL_EE__0007E_1_bInterr_0007F

			clear_bit(intcon, GIE);			//Disable Interrupts
01D2  138B  	BCF gbl_intcon,7

			eecon2 = 0x55;
01D3  3055  	MOVLW 0x55
01D4  1703  	BSF STATUS, RP1
01D5  008D  	MOVWF gbl_eecon2

			eecon2 = 0xAA;
01D6  30AA  	MOVLW 0xAA
01D7  008D  	MOVWF gbl_eecon2

			set_bit(eecon1, WR);
01D8  148C  	BSF gbl_eecon1,1

			while (test_bit(eecon1, WR));	//wait for EE write to complete...
01D9        label23
01D9  188C  	BTFSC gbl_eecon1,1
01DA  29D9  	GOTO	label23

			if (bInterruptsEnabled)
01DB  1303  	BCF STATUS, RP1
01DC  08A5  	MOVF FC_CAL_EE__0007E_1_bInterr_0007F, F
01DD  1903  	BTFSC STATUS,Z
01DE  29E0  	GOTO	label24
01E0        label24

				set_bit(intcon, GIE);		//Re-enable Interrupts
01DF  178B  	BSF gbl_intcon,7

			clear_bit(eecon1, WREN);
01E0  1703  	BSF STATUS, RP1
01E1  110C  	BCF gbl_eecon1,2

		#endif
		#ifdef HI_TECH_C
			eeprom_write(Address, Data);
		#endif
	#else
		#error "Chip does not have EEPROM memory"
	#endif
}
01E2  0008  	RETURN



/*********************************************************************
 *                  Flowcode CAL I2C File
 *
 * File: PIC_CAL_I2C.c
 *
 * (c) 2011 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * Company) for its Flowcode graphical programming language is
 * intended and supplied to you, the Companys customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 210911 | BR | Created
 * 021211 | BR | Converted to new dynamic defines mechanism
 *
 */


//When using hardware I2C channels override port and pin conns with FCD conn definitions
#ifdef MX_I2C_REF1
	#if MX_I2C_CHANNEL_1 > 0
		#undef MX_I2C_SDA_PIN_1
		#undef MX_I2C_SDA_PORT_1
		#undef MX_I2C_SDA_TRIS_1
		#undef MX_I2C_SCL_PIN_1
		#undef MX_I2C_SCL_PORT_1
		#undef MX_I2C_SCL_TRIS_1
	#endif
	#if MX_I2C_CHANNEL_1 == 1
		#define MX_I2C_SDA_PIN_1		MX_I2C_1_SDA_PIN
		#define MX_I2C_SDA_PORT_1		MX_I2C_1_SDA_PORT
		#define MX_I2C_SDA_TRIS_1		MX_I2C_1_SDA_TRIS
		#define MX_I2C_SCL_PIN_1		MX_I2C_1_SCL_PIN
		#define MX_I2C_SCL_PORT_1		MX_I2C_1_SCL_PORT
		#define MX_I2C_SCL_TRIS_1		MX_I2C_1_SCL_TRIS
	#endif
	#if MX_I2C_CHANNEL_1 == 2
		#define MX_I2C_SDA_PIN_1		MX_I2C_2_SDA_PIN
		#define MX_I2C_SDA_PORT_1		MX_I2C_2_SDA_PORT
		#define MX_I2C_SDA_TRIS_1		MX_I2C_2_SDA_TRIS
		#define MX_I2C_SCL_PIN_1		MX_I2C_2_SCL_PIN
		#define MX_I2C_SCL_PORT_1		MX_I2C_2_SCL_PORT
		#define MX_I2C_SCL_TRIS_1		MX_I2C_2_SCL_TRIS
	#endif
	#if MX_I2C_CHANNEL_1 == 3
		#define MX_I2C_SDA_PIN_1		MX_I2C_3_SDA_PIN
		#define MX_I2C_SDA_PORT_1		MX_I2C_3_SDA_PORT
		#define MX_I2C_SDA_TRIS_1		MX_I2C_3_SDA_TRIS
		#define MX_I2C_SCL_PIN_1		MX_I2C_3_SCL_PIN
		#define MX_I2C_SCL_PORT_1		MX_I2C_3_SCL_PORT
		#define MX_I2C_SCL_TRIS_1		MX_I2C_3_SCL_TRIS
	#endif
	#if MX_I2C_CHANNEL_1 == 4
		#define MX_I2C_SDA_PIN_1		MX_I2C_4_SDA_PIN
		#define MX_I2C_SDA_PORT_1		MX_I2C_4_SDA_PORT
		#define MX_I2C_SDA_TRIS_1		MX_I2C_4_SDA_TRIS
		#define MX_I2C_SCL_PIN_1		MX_I2C_4_SCL_PIN
		#define MX_I2C_SCL_PORT_1		MX_I2C_4_SCL_PORT
		#define MX_I2C_SCL_TRIS_1		MX_I2C_4_SCL_TRIS
	#endif
#endif
#ifdef MX_I2C_REF2
	#if MX_I2C_CHANNEL_2 > 0
		#undef MX_I2C_SDA_PIN_2
		#undef MX_I2C_SDA_PORT_2
		#undef MX_I2C_SDA_TRIS_2
		#undef MX_I2C_SCL_PIN_2
		#undef MX_I2C_SCL_PORT_2
		#undef MX_I2C_SCL_TRIS_2
	#endif
	#if MX_I2C_CHANNEL_2 == 1
		#define MX_I2C_SDA_PIN_2		MX_I2C_1_SDA_PIN
		#define MX_I2C_SDA_PORT_2		MX_I2C_1_SDA_PORT
		#define MX_I2C_SDA_TRIS_2		MX_I2C_1_SDA_TRIS
		#define MX_I2C_SCL_PIN_2		MX_I2C_1_SCL_PIN
		#define MX_I2C_SCL_PORT_2		MX_I2C_1_SCL_PORT
		#define MX_I2C_SCL_TRIS_2		MX_I2C_1_SCL_TRIS
	#endif
	#if MX_I2C_CHANNEL_2 == 2
		#define MX_I2C_SDA_PIN_2		MX_I2C_2_SDA_PIN
		#define MX_I2C_SDA_PORT_2		MX_I2C_2_SDA_PORT
		#define MX_I2C_SDA_TRIS_2		MX_I2C_2_SDA_TRIS
		#define MX_I2C_SCL_PIN_2		MX_I2C_2_SCL_PIN
		#define MX_I2C_SCL_PORT_2		MX_I2C_2_SCL_PORT
		#define MX_I2C_SCL_TRIS_2		MX_I2C_2_SCL_TRIS
	#endif
	#if MX_I2C_CHANNEL_2 == 3
		#define MX_I2C_SDA_PIN_2		MX_I2C_3_SDA_PIN
		#define MX_I2C_SDA_PORT_2		MX_I2C_3_SDA_PORT
		#define MX_I2C_SDA_TRIS_2		MX_I2C_3_SDA_TRIS
		#define MX_I2C_SCL_PIN_2		MX_I2C_3_SCL_PIN
		#define MX_I2C_SCL_PORT_2		MX_I2C_3_SCL_PORT
		#define MX_I2C_SCL_TRIS_2		MX_I2C_3_SCL_TRIS
	#endif
	#if MX_I2C_CHANNEL_2 == 4
		#define MX_I2C_SDA_PIN_2		MX_I2C_4_SDA_PIN
		#define MX_I2C_SDA_PORT_2		MX_I2C_4_SDA_PORT
		#define MX_I2C_SDA_TRIS_2		MX_I2C_4_SDA_TRIS
		#define MX_I2C_SCL_PIN_2		MX_I2C_4_SCL_PIN
		#define MX_I2C_SCL_PORT_2		MX_I2C_4_SCL_PORT
		#define MX_I2C_SCL_TRIS_2		MX_I2C_4_SCL_TRIS
	#endif
#endif
#ifdef MX_I2C_REF3
	#if MX_I2C_CHANNEL_3 > 0
		#undef MX_I2C_SDA_PIN_3
		#undef MX_I2C_SDA_PORT_3
		#undef MX_I2C_SDA_TRIS_3
		#undef MX_I2C_SCL_PIN_3
		#undef MX_I2C_SCL_PORT_3
		#undef MX_I2C_SCL_TRIS_3
	#endif
	#if MX_I2C_CHANNEL_3 == 1
		#define MX_I2C_SDA_PIN_3		MX_I2C_1_SDA_PIN
		#define MX_I2C_SDA_PORT_3		MX_I2C_1_SDA_PORT
		#define MX_I2C_SDA_TRIS_3		MX_I2C_1_SDA_TRIS
		#define MX_I2C_SCL_PIN_3		MX_I2C_1_SCL_PIN
		#define MX_I2C_SCL_PORT_3		MX_I2C_1_SCL_PORT
		#define MX_I2C_SCL_TRIS_3		MX_I2C_1_SCL_TRIS
	#endif
	#if MX_I2C_CHANNEL_3 == 2
		#define MX_I2C_SDA_PIN_3		MX_I2C_2_SDA_PIN
		#define MX_I2C_SDA_PORT_3		MX_I2C_2_SDA_PORT
		#define MX_I2C_SDA_TRIS_3		MX_I2C_2_SDA_TRIS
		#define MX_I2C_SCL_PIN_3		MX_I2C_2_SCL_PIN
		#define MX_I2C_SCL_PORT_3		MX_I2C_2_SCL_PORT
		#define MX_I2C_SCL_TRIS_3		MX_I2C_2_SCL_TRIS
	#endif
	#if MX_I2C_CHANNEL_3 == 3
		#define MX_I2C_SDA_PIN_3		MX_I2C_3_SDA_PIN
		#define MX_I2C_SDA_PORT_3		MX_I2C_3_SDA_PORT
		#define MX_I2C_SDA_TRIS_3		MX_I2C_3_SDA_TRIS
		#define MX_I2C_SCL_PIN_3		MX_I2C_3_SCL_PIN
		#define MX_I2C_SCL_PORT_3		MX_I2C_3_SCL_PORT
		#define MX_I2C_SCL_TRIS_3		MX_I2C_3_SCL_TRIS
	#endif
	#if MX_I2C_CHANNEL_3 == 4
		#define MX_I2C_SDA_PIN_3		MX_I2C_4_SDA_PIN
		#define MX_I2C_SDA_PORT_3		MX_I2C_4_SDA_PORT
		#define MX_I2C_SDA_TRIS_3		MX_I2C_4_SDA_TRIS
		#define MX_I2C_SCL_PIN_3		MX_I2C_4_SCL_PIN
		#define MX_I2C_SCL_PORT_3		MX_I2C_4_SCL_PORT
		#define MX_I2C_SCL_TRIS_3		MX_I2C_4_SCL_TRIS
	#endif
#endif
#ifdef MX_I2C_REF4
	#if MX_I2C_CHANNEL_4 > 0
		#undef MX_I2C_SDA_PIN_4
		#undef MX_I2C_SDA_PORT_4
		#undef MX_I2C_SDA_TRIS_4
		#undef MX_I2C_SCL_PIN_4
		#undef MX_I2C_SCL_PORT_4
		#undef MX_I2C_SCL_TRIS_4
	#endif
	#if MX_I2C_CHANNEL_4 == 1
		#define MX_I2C_SDA_PIN_4		MX_I2C_1_SDA_PIN
		#define MX_I2C_SDA_PORT_4		MX_I2C_1_SDA_PORT
		#define MX_I2C_SDA_TRIS_4		MX_I2C_1_SDA_TRIS
		#define MX_I2C_SCL_PIN_4		MX_I2C_1_SCL_PIN
		#define MX_I2C_SCL_PORT_4		MX_I2C_1_SCL_PORT
		#define MX_I2C_SCL_TRIS_4		MX_I2C_1_SCL_TRIS
	#endif
	#if MX_I2C_CHANNEL_4 == 2
		#define MX_I2C_SDA_PIN_4		MX_I2C_2_SDA_PIN
		#define MX_I2C_SDA_PORT_4		MX_I2C_2_SDA_PORT
		#define MX_I2C_SDA_TRIS_4		MX_I2C_2_SDA_TRIS
		#define MX_I2C_SCL_PIN_4		MX_I2C_2_SCL_PIN
		#define MX_I2C_SCL_PORT_4		MX_I2C_2_SCL_PORT
		#define MX_I2C_SCL_TRIS_4		MX_I2C_2_SCL_TRIS
	#endif
	#if MX_I2C_CHANNEL_4 == 3
		#define MX_I2C_SDA_PIN_4		MX_I2C_3_SDA_PIN
		#define MX_I2C_SDA_PORT_4		MX_I2C_3_SDA_PORT
		#define MX_I2C_SDA_TRIS_4		MX_I2C_3_SDA_TRIS
		#define MX_I2C_SCL_PIN_4		MX_I2C_3_SCL_PIN
		#define MX_I2C_SCL_PORT_4		MX_I2C_3_SCL_PORT
		#define MX_I2C_SCL_TRIS_4		MX_I2C_3_SCL_TRIS
	#endif
	#if MX_I2C_CHANNEL_4 == 4
		#define MX_I2C_SDA_PIN_4		MX_I2C_4_SDA_PIN
		#define MX_I2C_SDA_PORT_4		MX_I2C_4_SDA_PORT
		#define MX_I2C_SDA_TRIS_4		MX_I2C_4_SDA_TRIS
		#define MX_I2C_SCL_PIN_4		MX_I2C_4_SCL_PIN
		#define MX_I2C_SCL_PORT_4		MX_I2C_4_SCL_PORT
		#define MX_I2C_SCL_TRIS_4		MX_I2C_4_SCL_TRIS
	#endif
#endif

#define MX_I2C_CHANNEL_X		CAL_APPEND(MX_I2C_CHANNEL_, MX_I2C_NUM)
#define MX_I2C_SDA_PIN_X		CAL_APPEND(MX_I2C_SDA_PIN_, MX_I2C_NUM)
#define MX_I2C_SDA_PORT_X		CAL_APPEND(MX_I2C_SDA_PORT_, MX_I2C_NUM)
#define MX_I2C_SDA_TRIS_X		CAL_APPEND(MX_I2C_SDA_TRIS_, MX_I2C_NUM)
#define MX_I2C_SCL_PIN_X		CAL_APPEND(MX_I2C_SCL_PIN_, MX_I2C_NUM)
#define MX_I2C_SCL_PORT_X		CAL_APPEND(MX_I2C_SCL_PORT_, MX_I2C_NUM)
#define MX_I2C_SCL_TRIS_X		CAL_APPEND(MX_I2C_SCL_TRIS_, MX_I2C_NUM)
#define MX_I2C_BMODE_X			CAL_APPEND(MX_I2C_BMODE_, MX_I2C_NUM)
#define MX_I2C_BAUD_X			CAL_APPEND(MX_I2C_BAUD_, MX_I2C_NUM)
#define MX_I2C_INT_X			CAL_APPEND(MX_I2C_INT_, MX_I2C_NUM)


//Function Prototypes
CALFUNCTION(void, FC_CAL_I2C_Master_Init_, (void));
CALFUNCTION(void, FC_CAL_I2C_Master_Uninit_, (void));
CALFUNCTION(void, FC_CAL_I2C_Master_Start_, (void));
CALFUNCTION(void, FC_CAL_I2C_Master_Restart_, (void));
CALFUNCTION(void, FC_CAL_I2C_Master_Stop_, (void));
CALFUNCTION(MX_UINT8, FC_CAL_I2C_Master_TX_Byte_, (MX_UINT8 Data));
CALFUNCTION(MX_UINT8, FC_CAL_I2C_Master_RX_Byte_, (MX_UINT8 Last));

CALFUNCTION(void, FC_CAL_I2C_Slave_Init_, (void));
CALFUNCTION(void, FC_CAL_I2C_Slave_Uninit_, (void));
CALFUNCTION(void, FC_CAL_I2C_Slave_SetTxData_, (MX_UINT8 Data));
CALFUNCTION(MX_UINT8, FC_CAL_I2C_Slave_GetRxData_, (MX_UINT8 Last));


//Ensure SSPCON register is defined correctly
#ifndef SSPCON
  #ifdef SSPCON1
	#define sspcon	sspcon1
  #else
	#ifdef SSP1CON1
		#define sspcon	ssp1con1
	#endif
  #endif
#endif

//Ensure SSPIF register is defined correctly
#ifndef SSPIF
  #ifdef SSP1IF
	#define SSPIF	SSP1IF
  #else
	#error "I2C does not have the SSPIF defined on this chip - does your chip support this feature?"
  #endif
#endif


//Ensure SSPCON2 register is defined correctly
#ifndef SSPCON2
  #ifdef SSP1CON2
	#define sspcon2	ssp1con2
  #endif
#endif


//Ensure SSPSTAT register is defined correctly
#ifndef SSPSTAT
  #ifdef SSP1STAT
	#define sspstat	ssp1stat
  #endif
#endif


//Ensure SSPADD register is defined correctly
#ifndef SSPADD
  #ifdef SSP1ADD
	#define sspadd	ssp1add
  #endif
#endif


//Ensure SSPBUFF register is defined correctly
#ifndef SSPBUFF
  #ifdef SSP1BUFF
	#define sspbuff	ssp1buff
  #endif
#endif


//If software channel is enabled then define bit delay.
#if (MX_I2C_CHANNEL_X == 0)
  #ifndef MX_I2C_SW_DEL
	#define MX_I2C_SW_DEL
	#define MX_I2C_DELAY	delay_us(20);
  #endif
#endif


CALFUNCTION(void, FC_CAL_I2C_Master_Init_, (void))

{

	#if (MX_I2C_CHANNEL_X == 0)															//Use Master I2C Software
		FC_CAL_Bit_In_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);		//Configure SDA as Input
		FC_CAL_Bit_In_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);		//Configure SCL as Input
	#endif

	#if (MX_I2C_CHANNEL_X == 1)												//Use Master I2C Hardware 1
		#ifndef MX_MI2C
			#error "This chip does not have Master I2C capability"
		#else

			#ifndef MX_I2C_1
				#error "This chip does not have Master I2C channel 1"
			#endif

			#if (MX_I2C_BMODE_X & 0x01)
				cr_bit (sspstat,SMP);										//Slew Rate Control Enabled
			#else
				st_bit (sspstat,SMP);										//Slew Rate Control Disabled
030D  1683  	BSF STATUS, RP0
030E  1303  	BCF STATUS, RP1
030F  1794  	BSF gbl_sspstat,7

		    #endif

			#if (MX_I2C_BMODE_X & 0x02)
				st_bit (sspstat,CKE);										//Enable SMBus specific inputs
			#else
				cr_bit (sspstat,CKE);										//Disable SMBus specific inputs
0310  1314  	BCF gbl_sspstat,6

			#endif

			sspcon = 0x28;													//Setup I2C into Master Mode
0311  3028  	MOVLW 0x28
0312  1283  	BCF STATUS, RP0
0313  0094  	MOVWF gbl_sspcon

			sspadd = MX_I2C_BAUD_X;											//Set the Baud Rate
0314  30A0  	MOVLW 0xA0
0315  1683  	BSF STATUS, RP0
0316  0093  	MOVWF gbl_sspadd

			sspcon2 = 0x00;													//Clear the control bits
0317  0191  	CLRF gbl_sspcon2

			st_bit(intcon, GIE);
0318  178B  	BSF gbl_intcon,7

			FC_CAL_Bit_In_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);		//Configure SDA as Input
0319  1607  	BSF gbl_trisc,4

			FC_CAL_Bit_In_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);		//Configure SCL as Input
031A  1587  	BSF gbl_trisc,3

		#endif
	#endif

	#if (MX_I2C_CHANNEL_X == 2)												//Use Master I2C Hardware 2
		#ifndef MX_MI2C
			#error "This chip does not have Master I2C capability"
		#else

			#ifndef MX_I2C_2
				#error "This chip does not have Master I2C channel 2"
			#endif

		  #ifdef MX_I2C_2_REMAPPABLE
			RPOR4 = 9;														//SDA2 - RB1 - RP4
			RPOR5 = 10;														//SCL2 - RB2 - RP5
		  #endif

			#if (MX_I2C_BMODE_X & 0x01)
				cr_bit (ssp2stat,SMP);										//Slew Rate Control Enabled
			#else
				st_bit (ssp2stat,SMP);										//Slew Rate Control Disabled
			#endif

			#if (MX_I2C_BMODE_X & 0x02)
				st_bit (ssp2stat,CKE);										//Enable SMBus specific inputs
			#else
				cr_bit (ssp2stat,CKE);										//Disable SMBus specific inputs
			#endif

			ssp2con = 0x28;													//Setup I2C into Master Mode
			ssp2add = MX_I2C_BAUD_X;										//Set the Baud Rate
			ssp2con2 = 0x00;												//Clear the control bits
			st_bit(intcon, GIE);
			FC_CAL_Bit_In_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);			//Configure SDA as Input
			FC_CAL_Bit_In_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);			//Configure SCL as Input
		#endif
	#endif
}
031B  0008  	RETURN


CALFUNCTION(void, FC_CAL_I2C_Master_Uninit_, (void))
{
	#if (MX_I2C_CHANNEL_X == 0)																//Use Master I2C Software
		FC_CAL_Bit_In_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);			//Configure SDA as Input
		FC_CAL_Bit_In_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);			//Configure SCL as Input
	#endif

	#if (MX_I2C_CHANNEL_X == 1)												//Use Master I2C Hardware 1
		cr_bit(sspcon, SSPEN);												//Disable SSP
	#endif

	#if (MX_I2C_CHANNEL_X == 2)												//Use Master I2C Hardware 2
		cr_bit(ssp2con, SSPEN);												//Disable SSP
	#endif
}

CALFUNCTION(void, FC_CAL_I2C_Master_Start_, (void))

{
	#if (MX_I2C_CHANNEL_X == 0)															//Use Master I2C Software
		FC_CAL_Bit_In_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);		//Make Sure SCL is Set
		FC_CAL_Bit_In_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);		//Make Sure SDA is Set
		MX_I2C_DELAY;																	//Small Delay
		FC_CAL_Bit_Low_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);		//Clear SDA
		MX_I2C_DELAY;																	//Small Delay
		FC_CAL_Bit_Low_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);		//Clear SCL
		MX_I2C_DELAY;																	//Small Delay
	#endif

	#if (MX_I2C_CHANNEL_X == 1)												//Use Master I2C Hardware 1
		cr_bit(pir1, SSPIF);												//Clear SSP interrupt flag
0070  1283  	BCF STATUS, RP0
0071  1303  	BCF STATUS, RP1
0072  118C  	BCF gbl_pir1,3

		st_bit(sspcon2,SEN);												//Initiate start condition
0073  1683  	BSF STATUS, RP0
0074  1411  	BSF gbl_sspcon2,0

		while(ts_bit(sspcon2,SEN));											//Wait for start bit to be generated
0075        label13
0075  1811  	BTFSC gbl_sspcon2,0
0076  2875  	GOTO	label13

	#endif

	#if (MX_I2C_CHANNEL_X == 2)												//Use Master I2C Hardware 2
		cr_bit(pir3, SSP2IF);												//Clear SSP interrupt flag
		st_bit(ssp2con2,SEN);												//Initiate start condition
		while(ts_bit(ssp2con2,SEN));										//Wait for start bit to be generated
	#endif
}
0077  0008  	RETURN


CALFUNCTION(void, FC_CAL_I2C_Master_Restart_, (void))

{
	#if (MX_I2C_CHANNEL_X == 0)															//Use Master I2C Software
		FC_CAL_Bit_In_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);		//Set SDA High
		MX_I2C_DELAY;
		FC_CAL_Bit_In_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);		//Set SCL High
		MX_I2C_DELAY;
		FC_CAL_Bit_Low_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);		//Set SDA Low
		MX_I2C_DELAY;
		FC_CAL_Bit_Low_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);		//Set SCL Low
		MX_I2C_DELAY;
	#endif

	#if (MX_I2C_CHANNEL_X == 1)												//Use Master I2C Hardware 1
		cr_bit(pir1, SSPIF);												//Clear SSP interrupt flag
0068  1283  	BCF STATUS, RP0
0069  1303  	BCF STATUS, RP1
006A  118C  	BCF gbl_pir1,3

		st_bit(sspcon2,RSEN);												//Initiate restart condition
006B  1683  	BSF STATUS, RP0
006C  1491  	BSF gbl_sspcon2,1

		while(ts_bit(sspcon2,RSEN));										//Wait for restart bit to be generated
006D        label12
006D  1891  	BTFSC gbl_sspcon2,1
006E  286D  	GOTO	label12

	#endif

	#if (MX_I2C_CHANNEL_X == 2)												//Use Master I2C Hardware 2
		cr_bit(pir3, SSP2IF);												//Clear SSP interrupt flag
		st_bit(ssp2con2,RSEN);												//Initiate restart condition
		while(ts_bit(ssp2con2,RSEN));										//Wait for restart bit to be generated
	#endif
}
006F  0008  	RETURN


CALFUNCTION(void, FC_CAL_I2C_Master_Stop_, (void))

{
	#if (MX_I2C_CHANNEL_X == 0)															//Use Master I2C Software
		FC_CAL_Bit_Low_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);		//Set SCL Low
		FC_CAL_Bit_Low_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);		//Set SDA Low
		MX_I2C_DELAY;
		FC_CAL_Bit_In_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);		//Set SCL High
		MX_I2C_DELAY;
		FC_CAL_Bit_In_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);		//Set SDA High
	#endif

	#if (MX_I2C_CHANNEL_X == 1)												//Use Master I2C Hardware 1
		cr_bit(pir1,SSPIF);													//Clear SSP interrupt flag
005C  1283  	BCF STATUS, RP0
005D  1303  	BCF STATUS, RP1
005E  118C  	BCF gbl_pir1,3

		st_bit(sspcon2,PEN);												//Initiate stop condition
005F  1683  	BSF STATUS, RP0
0060  1511  	BSF gbl_sspcon2,2

		while(ts_bit(sspcon2,PEN));											//Wait for stop bit to be generated
0061        label11
0061  1911  	BTFSC gbl_sspcon2,2
0062  2861  	GOTO	label11

	#endif

	#if (MX_I2C_CHANNEL_X == 2)												//Use Master I2C Hardware 2
		cr_bit(pir3,SSP2IF);												//Clear SSP interrupt flag
		st_bit(ssp2con2,PEN);												//Initiate stop condition
		while(ts_bit(ssp2con2,PEN));										//Wait for stop bit to be generated
	#endif

  delay_ms(10);																//Wait before reusing the I2C BUS
0063  300A  	MOVLW 0x0A
0064  1283  	BCF STATUS, RP0
0065  00FD  	MOVWF delay_ms_00000_arg_del
0066  2010  	CALL delay_ms_00000

}
0067  0008  	RETURN


CALFUNCTION(MX_UINT8, FC_CAL_I2C_Master_TX_Byte_, (MX_UINT8 Data))

{
	#if (MX_I2C_CHANNEL_X == 0)												//Use Master I2C Software
		char bit_mask;
		char local_ack = 0;
		for(bit_mask=0x80;bit_mask;bit_mask=bit_mask>>1)
		{
			if(Data & bit_mask)
			{
				FC_CAL_Bit_In_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);	//Set SDA High
			}
			else
			{
				FC_CAL_Bit_Low_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);	//Set SDA Low
			}
			MX_I2C_DELAY;
			FC_CAL_Bit_In_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);		//Set SCL High
			MX_I2C_DELAY;
			FC_CAL_Bit_Low_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);		//Set SCL Low
			MX_I2C_DELAY;
		}
		FC_CAL_Bit_In_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);			//Set SDA High
		MX_I2C_DELAY;
		FC_CAL_Bit_In_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);			//Set SCL High
		MX_I2C_DELAY;
		FC_CAL_Bit_In_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);
		if (FC_CAL_Bit_In(MX_I2C_SDA_PORT_X, MX_I2C_SDA_PIN_X))		//Get the Status Bit
			local_ack = 1;
		MX_I2C_DELAY;
		FC_CAL_Bit_Low_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);			//Set SCL Low
		MX_I2C_DELAY;
		return (local_ack);													//0 = Ack received : 1 = Ack not received
	#endif

	#if (MX_I2C_CHANNEL_X == 1)												//Use Master I2C Hardware 1
		cr_bit(pir1,SSPIF);													//Clear SSP interrupt flag
004D  118C  	BCF gbl_pir1,3

		sspbuf=Data;														//Send byte
004E  0876  	MOVF FC_CAL_I2C_00078_arg_Data, W
004F  0093  	MOVWF gbl_sspbuf

		while(ts_bit(pir1,SSPIF) == 0);										//Wait for control bit to be sent
0050        label9
0050  1D8C  	BTFSS gbl_pir1,3
0051  2850  	GOTO	label9

		if(ts_bit(sspcon2,ACKSTAT))											//Check Acknowledgement
0052  1683  	BSF STATUS, RP0
0053  1F11  	BTFSS gbl_sspcon2,6
0054  2859  	GOTO	label10
0059        label10

			return (1);														//No Acknowledgement
0055  3001  	MOVLW 0x01
0056  1283  	BCF STATUS, RP0
0057  00F7  	MOVWF CompTempVarRet2287

		else return (0);													//Acknowledgement received
0059  1283  	BCF STATUS, RP0
005A  01F7  	CLRF CompTempVarRet2287

	#endif

	#if (MX_I2C_CHANNEL_X == 2)												//Use Master I2C Hardware 2
		cr_bit(pir3,SSP2IF);												//Clear SSP interrupt flag
		ssp2buf=Data;														//Send byte
		while(ts_bit(pir3,SSP2IF) == 0);									//Wait for control bit to be sent
		if(ts_bit(ssp2con2,ACKSTAT))										//Check Acknowledgement
			return (1);														//No Acknowledgement
		else return (0);													//Acknowledgement received
	#endif
}
0058  0008  	RETURN
005B  0008  	RETURN


CALFUNCTION(MX_UINT8, FC_CAL_I2C_Master_RX_Byte_, (MX_UINT8 Last))

{
	#if (MX_I2C_CHANNEL_X == 0)												//Use Master I2C Software
		char bit_mask;
		char Data = 0;
		char local_ack;
		FC_CAL_Bit_In_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);			//Set SDA High
		MX_I2C_DELAY;
		for(bit_mask=0x80;bit_mask;bit_mask=bit_mask>>1)
		{
			FC_CAL_Bit_In_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);		//Set SCL High
			MX_I2C_DELAY;
			FC_CAL_Bit_In_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);
			if(FC_CAL_Bit_In(MX_I2C_SDA_PORT_X, MX_I2C_SDA_PIN_X))	//Read Incoming Bit
				Data = Data | bit_mask;														//Add data to variable
			FC_CAL_Bit_Low_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);		//Set SCL Low
			MX_I2C_DELAY;
		}
		if (Last)																		//Acknowledge?
		{
			FC_CAL_Bit_In_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);	//Send Nack
		}
		else
		{
			FC_CAL_Bit_Low_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);	//Send Ack
		}
		MX_I2C_DELAY;
		FC_CAL_Bit_In_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);		//Set SCL High
		MX_I2C_DELAY;
		FC_CAL_Bit_Low_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);		//Set SCL Low
		MX_I2C_DELAY;
		return (Data);
	#endif

	#if (MX_I2C_CHANNEL_X == 1)						//Use Master I2C Hardware 1
		cr_bit(pir1,SSPIF);							//Clear SSP interrupt flag
0038  118C  	BCF gbl_pir1,3

		st_bit(sspcon2,RCEN);						//Initiate Read
0039  1683  	BSF STATUS, RP0
003A  1591  	BSF gbl_sspcon2,3

		while(ts_bit(pir1,3) == 0);					//Wait for data read
003B        label5
003B  1283  	BCF STATUS, RP0
003C  1D8C  	BTFSS gbl_pir1,3
003D  283B  	GOTO	label5

		if (Last)
003E  08F6  	MOVF FC_CAL_I2C_00079_arg_Last, F
003F  1903  	BTFSC STATUS,Z
0040  2844  	GOTO	label6
0044        label6

			st_bit(sspcon2,ACKDT);					//Send Nack
0041  1683  	BSF STATUS, RP0
0042  1691  	BSF gbl_sspcon2,5

		else cr_bit(sspcon2,ACKDT);					//Send Ack
0043  2846  	GOTO	label7
0044  1683  	BSF STATUS, RP0
0045  1291  	BCF gbl_sspcon2,5
0046        label7

		st_bit(sspcon2,ACKEN);						//Initiate Nack
0046  1611  	BSF gbl_sspcon2,4

		while(ts_bit(sspcon2,ACKEN));				//Wait for data read
0047        label8
0047  1A11  	BTFSC gbl_sspcon2,4
0048  2847  	GOTO	label8

		return(sspbuf);								//Store incoming data
0049  1283  	BCF STATUS, RP0
004A  0813  	MOVF gbl_sspbuf, W
004B  00F7  	MOVWF CompTempVarRet2288

	#endif

	#if (MX_I2C_CHANNEL_X == 2)						//Use Master I2C Hardware 2
		cr_bit(pir3,SSP2IF);						//Clear SSP interrupt flag
		st_bit(ssp2con2,RCEN);						//Initiate Read
		while(ts_bit(pir3,SSP2IF) == 0);			//Wait for data read
		if (Last)
			st_bit(ssp2con2,ACKDT);					//Send Nack
		else cr_bit(ssp2con2,ACKDT);				//Send Ack
		st_bit(ssp2con2,ACKEN);						//Initiate Nack
		while(ts_bit(ssp2con2,ACKEN));				//Wait for data read
		return(ssp2buf);							//Store incoming data
	#endif
}
004C  0008  	RETURN





//Slave functions currently not implemented
CALFUNCTION(void, FC_CAL_I2C_Slave_Init_, (void))
{

}

CALFUNCTION(void, FC_CAL_I2C_Slave_Uninit_, (void))
{

}

CALFUNCTION(void, FC_CAL_I2C_Slave_SetTxData_, (MX_UINT8 Data))
{

}

CALFUNCTION(MX_UINT8, FC_CAL_I2C_Slave_GetRxData_, (MX_UINT8 Last))
{

}


/*********************************************************************
 *                  Flowcode CAL PWM File
 *
 * File: PIC_CAL_PWM.c
 *
 * (c) 2011 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * Company) for its Flowcode graphical programming language is
 * intended and supplied to you, the Companys customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 270911 | BR | Created
 * 021211 | BR | Converted to new dynamic defines mechanism
 *
 */


#define MX_PWM_CHANNEL_X		CAL_APPEND(MX_PWM_CHANNEL_, MX_PWM_NUM)
#define MX_PWM_HWALT_X			CAL_APPEND(MX_PWM_HWALT_, MX_PWM_NUM)


//I2C Master Functions
CALFUNCTION(void, FC_CAL_PWM_Enable_Channel_, (void));
CALFUNCTION(void, FC_CAL_PWM_Disable_Channel_, (void));
CALFUNCTION(void, FC_CAL_PWM_Set_Duty_8Bit_, (MX_UINT8 duty));
CALFUNCTION(void, FC_CAL_PWM_Change_Period_, (MX_UINT8 period, MX_UINT16 prescaler));
CALFUNCTION(void, FC_CAL_PWM_Set_Duty_10Bit_, (MX_UINT16 duty));


CALFUNCTION(void, FC_CAL_PWM_Enable_Channel_, (void))

{

 #ifdef MX_PWM

	#if (MX_PWM_CHANNEL_X == 1)
	  #ifdef MX_PWM_REMAPPABLE
	  	RPOR3 = 14;														//PWM1 - 14 - RB0 - RP3
	  #endif

		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
		  #ifndef MX_PWM_1_PORT											//Error checking
			#error "This chip does not have PWM channel 1 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_1_PORT, MX_PWM_1_TRIS, MX_PWM_1_PIN);			//PWM pin is an output
		#else															//Alternate PWM Pin
		  #ifndef MX_PWM_1_PORT_A										//Error checking
			#error "This chip does not have PWM alt channel 1 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_1_PORT_A, MX_PWM_1_TRIS_A, MX_PWM_1_PIN_A);		//PWM pin is an output
		#endif

		ccp1con = 0x0C;													//Enable Capture Compare Channel 1
	#endif

	#if (MX_PWM_CHANNEL_X == 2)
	  #ifdef MX_PWM_REMAPPABLE
	  	RPOR4 = 18;														//PWM2 - 18 - RB1 - RP4
	  #endif

		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
		  #ifndef MX_PWM_2_PORT											//Error checking
			#error "This chip does not have PWM channel 2 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_2_PORT, MX_PWM_2_TRIS, MX_PWM_2_PIN);			//PWM pin is an output
0305  1683  	BSF STATUS, RP0
0306  1303  	BCF STATUS, RP1
0307  1087  	BCF gbl_trisc,1
0308  1283  	BCF STATUS, RP0
0309  1087  	BCF gbl_portc,1

		#else															//Alternate PWM Pin
		  #ifndef MX_PWM_2_PORT_A										//Error checking
			#error "This chip does not have PWM alt channel 2 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_2_PORT_A, MX_PWM_2_TRIS_A, MX_PWM_2_PIN_A);		//PWM pin is an output
		#endif

		ccp2con = 0x0C;													//Enable Capture Compare Channel 2
030A  300C  	MOVLW 0x0C
030B  009D  	MOVWF gbl_ccp2con

	#endif

	#if (MX_PWM_CHANNEL_X == 3)
	  #ifdef MX_PWM_REMAPPABLE
	  	RPOR5 = 22;														//PWM3 - 22 - RB2 - RP5
	  #endif

		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
		  #ifndef MX_PWM_3_PORT											//Error checking
			#error "This chip does not have PWM channel 3 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_3_PORT, MX_PWM_3_TRIS, MX_PWM_3_PIN);			//PWM pin is an output
		#else															//Alternate PWM Pin
		  #ifndef MX_PWM_3_PORT_A										//Error checking
			#error "This chip does not have PWM alt channel 3 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_3_PORT_A, MX_PWM_3_TRIS_A, MX_PWM_3_PIN_A);		//PWM pin is an output
		#endif

		ccp3con = 0x0C;													//Enable Capture Compare Channel 3 *****************************************************************
	#endif

	#if (MX_PWM_CHANNEL_X == 4)
		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
		  #ifndef MX_PWM_4_PORT											//Error checking
			#error "This chip does not have PWM channel 4 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_4_PORT, MX_PWM_4_TRIS, MX_PWM_4_PIN);			//PWM pin is an output
		#else															//Alternate PWM Pin
		  #ifndef MX_PWM_4_PORT_A										//Error checking
			#error "This chip does not have PWM alt channel 4 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_4_PORT_A, MX_PWM_4_TRIS_A, MX_PWM_4_PIN_A);		//PWM pin is an output
		#endif

		ccp4con = 0x0C;													//Enable Capture Compare Channel 4 *****************************************************************
	#endif

	#if (MX_PWM_CHANNEL_X == 5)
		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
		  #ifndef MX_PWM_5_PORT											//Error checking
			#error "This chip does not have PWM channel 5 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_5_PORT, MX_PWM_5_TRIS, MX_PWM_5_PIN);			//PWM pin is an output
		#else															//Alternate PWM Pin
		  #ifndef MX_PWM_5_PORT_A										//Error checking
			#error "This chip does not have PWM alt channel 5 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_5_PORT_A, MX_PWM_5_TRIS_A, MX_PWM_5_PIN_A);		//PWM pin is an output
		#endif

		ccp5con = 0x0C;													//Enable Capture Compare Channel 5 *****************************************************************
	#endif

	#if (MX_PWM_CHANNEL_X == 6)
		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
		  #ifndef MX_PWM_6_PORT											//Error checking
			#error "This chip does not have PWM channel 6 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_6_PORT, MX_PWM_6_TRIS, MX_PWM_6_PIN);			//PWM pin is an output
		#else															//Alternate PWM Pin
		  #ifndef MX_PWM_6_PORT_A										//Error checking
			#error "This chip does not have PWM alt channel 6 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_6_PORT_A, MX_PWM_6_TRIS_A, MX_PWM_6_PIN_A);		//PWM pin is an output
		#endif

		ccp6con = 0x0C;													//Enable Capture Compare Channel 6 *****************************************************************
	#endif

	#if (MX_PWM_CHANNEL_X == 7)
		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
		  #ifndef MX_PWM_7_PORT											//Error checking
			#error "This chip does not have PWM channel 7 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_7_PORT, MX_PWM_7_TRIS, MX_PWM_7_PIN);			//PWM pin is an output
		#else															//Alternate PWM Pin
		  #ifndef MX_PWM_7_PORT_A										//Error checking
			#error "This chip does not have PWM alt channel 7 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_7_PORT_A, MX_PWM_7_TRIS_A, MX_PWM_7_PIN_A);		//PWM pin is an output
		#endif

		ccp7con = 0x0C;													//Enable Capture Compare Channel 5 *****************************************************************
	#endif

	#if (MX_PWM_CHANNEL_X == 8)
		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
		  #ifndef MX_PWM_8_PORT											//Error checking
			#error "This chip does not have PWM channel 8 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_8_PORT, MX_PWM_8_TRIS, MX_PWM_8_PIN);			//PWM pin is an output
		#else															//Alternate PWM Pin
		  #ifndef MX_PWM_8_PORT_A										//Error checking
			#error "This chip does not have PWM alt channel 8 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_8_PORT_A, MX_PWM_8_TRIS_A, MX_PWM_8_PIN_A);		//PWM pin is an output
		#endif

		ccp8con = 0x0C;													//Enable Capture Compare Channel 8 *****************************************************************
	#endif

	#if (MX_PWM_CHANNEL_X == 9)
		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
		  #ifndef MX_PWM_9_PORT											//Error checking
			#error "This chip does not have PWM channel 9 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_9_PORT, MX_PWM_9_TRIS, MX_PWM_9_PIN);			//PWM pin is an output
		#else															//Alternate PWM Pin
		  #ifndef MX_PWM_9_PORT_A										//Error checking
			#error "This chip does not have PWM alt channel 9 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_9_PORT_A, MX_PWM_9_TRIS_A, MX_PWM_9_PIN_A);		//PWM pin is an output
		#endif

		ccp9con = 0x0C;													//Enable Capture Compare Channel 9 *****************************************************************
	#endif

	#if (MX_PWM_CHANNEL_X == 10)
		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
		  #ifndef MX_PWM_10_PORT											//Error checking
			#error "This chip does not have PWM channel 10 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_10_PORT, MX_PWM_10_TRIS, MX_PWM_10_PIN);			//PWM pin is an output
		#else															//Alternate PWM Pin
		  #ifndef MX_PWM_10_PORT_A										//Error checking
			#error "This chip does not have PWM alt channel 10 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_10_PORT_A, MX_PWM_10_TRIS_A, MX_PWM_10_PIN_A);		//PWM pin is an output
		#endif

		ccp10con = 0x0C;												//Enable Capture Compare Channel 10 *****************************************************************
	#endif

 #else
 	#error "Hardware PWM not supported by Target microcontroller."
 #endif

}
030C  0008  	RETURN



CALFUNCTION(void, FC_CAL_PWM_Disable_Channel_, (void))
{
	#if (MX_PWM_CHANNEL_X == 1)
		ccp1con = 0x00;													//Disable Capture Compare Channel 1
		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_1_PORT, MX_PWM_1_TRIS, MX_PWM_1_PIN);			//PWM pin is an input
		#else															//Alternate PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_1_PORT_A, MX_PWM_1_TRIS_A, MX_PWM_1_PIN_A);		//PWM pin is an input
		#endif
	#endif

	#if (MX_PWM_CHANNEL_X == 2)
		ccp2con = 0x00;													//Disable Capture Compare Channel 2
		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_2_PORT, MX_PWM_2_TRIS, MX_PWM_2_PIN);			//PWM pin is an input
		#else															//Alternate PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_2_PORT_A, MX_PWM_2_TRIS_A, MX_PWM_2_PIN_A);		//PWM pin is an input
		#endif
	#endif

	#if (MX_PWM_CHANNEL_X == 3)
		ccp3con = 0x00;													//Disable Capture Compare Channel 3
		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_3_PORT, MX_PWM_3_TRIS, MX_PWM_3_PIN);			//PWM pin is an input
		#else															//Alternate PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_3_PORT_A, MX_PWM_3_TRIS_A, MX_PWM_3_PIN_A);		//PWM pin is an input
		#endif
	#endif

	#if (MX_PWM_CHANNEL_X == 4)
		ccp4con = 0x00;													//Disable Capture Compare Channel 4
		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_4_PORT, MX_PWM_4_TRIS, MX_PWM_4_PIN);			//PWM pin is an input
		#else															//Alternate PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_4_PORT_A, MX_PWM_4_TRIS_A, MX_PWM_4_PIN_A);		//PWM pin is an input
		#endif
	#endif

	#if (MX_PWM_CHANNEL_X == 5)
		ccp5con = 0x00;													//Disable Capture Compare Channel 5
		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_5_PORT, MX_PWM_5_TRIS, MX_PWM_5_PIN);			//PWM pin is an input
		#else															//Alternate PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_5_PORT_A, MX_PWM_5_TRIS_A, MX_PWM_5_PIN_A);		//PWM pin is an input
		#endif
	#endif

	#if (MX_PWM_CHANNEL_X == 6)
		ccp6con = 0x00;													//Disable Capture Compare Channel 6
		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_6_PORT, MX_PWM_6_TRIS, MX_PWM_6_PIN);			//PWM pin is an input
		#else															//Alternate PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_6_PORT_A, MX_PWM_6_TRIS_A, MX_PWM_6_PIN_A);		//PWM pin is an input
		#endif
	#endif

	#if (MX_PWM_CHANNEL_X == 7)
		ccp7con = 0x00;													//Disable Capture Compare Channel 7
		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_7_PORT, MX_PWM_7_TRIS, MX_PWM_7_PIN);			//PWM pin is an input
		#else															//Alternate PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_7_PORT_A, MX_PWM_7_TRIS_A, MX_PWM_7_PIN_A);		//PWM pin is an input
		#endif
	#endif

	#if (MX_PWM_CHANNEL_X == 8)
		ccp8con = 0x00;													//Disable Capture Compare Channel 8
		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_8_PORT, MX_PWM_8_TRIS, MX_PWM_8_PIN);			//PWM pin is an input
		#else															//Alternate PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_8_PORT_A, MX_PWM_8_TRIS_A, MX_PWM_8_PIN_A);		//PWM pin is an input
		#endif
	#endif

	#if (MX_PWM_CHANNEL_X == 9)
		ccp9con = 0x00;													//Disable Capture Compare Channel 9
		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_9_PORT, MX_PWM_9_TRIS, MX_PWM_9_PIN);			//PWM pin is an input
		#else															//Alternate PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_9_PORT_A, MX_PWM_9_TRIS_A, MX_PWM_9_PIN_A);		//PWM pin is an input
		#endif
	#endif

	#if (MX_PWM_CHANNEL_X == 10)
		ccp10con = 0x00;												//Disable Capture Compare Channel 10
		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_10_PORT, MX_PWM_10_TRIS, MX_PWM_10_PIN);			//PWM pin is an input
		#else															//Alternate PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_10_PORT_A, MX_PWM_10_TRIS_A, MX_PWM_10_PIN_A);		//PWM pin is an input
		#endif
	#endif
}


CALFUNCTION(void, FC_CAL_PWM_Set_Duty_8Bit_, (MX_UINT8 duty))

{
	#if (MX_PWM_CHANNEL_X == 1)
		ccpr1l = duty;													//Update Capture Compare Count 1
	#endif

	#if (MX_PWM_CHANNEL_X == 2)
		ccpr2l = duty;													//Update Capture Compare Count 2
0035  087E  	MOVF FC_CAL_PWM_0006B_arg_duty, W
0036  009B  	MOVWF gbl_ccpr2l

	#endif

	#if (MX_PWM_CHANNEL_X == 3)
		ccpr3l = duty;													//Update Capture Compare Count 3
	#endif

	#if (MX_PWM_CHANNEL_X == 4)
		ccpr4l = duty;													//Update Capture Compare Count 4
	#endif

	#if (MX_PWM_CHANNEL_X == 5)
		ccpr5l = duty;													//Update Capture Compare Count 5
	#endif

	#if (MX_PWM_CHANNEL_X == 6)
		ccpr6l = duty;													//Update Capture Compare Count 6
	#endif

	#if (MX_PWM_CHANNEL_X == 7)
		ccpr7l = duty;													//Update Capture Compare Count 7
	#endif

	#if (MX_PWM_CHANNEL_X == 8)
		ccpr8l = duty;													//Update Capture Compare Count 8
	#endif

	#if (MX_PWM_CHANNEL_X == 9)
		ccpr9l = duty;													//Update Capture Compare Count 9
	#endif

	#if (MX_PWM_CHANNEL_X == 10)
		ccpr10l = duty;													//Update Capture Compare Count 10
	#endif
}
0037  0008  	RETURN



CALFUNCTION(void, FC_CAL_PWM_Change_Period_, (MX_UINT8 period, MX_UINT16 prescaler))

{
  #ifdef MX_PWM								//Hardware Mode
	pr2 = period;
02E5  0875  	MOVF FC_CAL_PWM_0006C_arg_period, W
02E6  1683  	BSF STATUS, RP0
02E7  0092  	MOVWF gbl_pr2

	switch (prescaler)
	{
	  #ifdef MX_PWM_PSCA1
		case 1:
02E8  3001  	MOVLW 0x01
02E9  1283  	BCF STATUS, RP0
02EA  0676  	XORWF FC_CAL_PWM_0006C_arg_prescaler, W
02EB  1903  	BTFSC STATUS,Z
02EC  0877  	MOVF FC_CAL_PWM_0006C_arg_prescaler+D'1', W
02ED  1903  	BTFSC STATUS,Z
02EE  2AFC  	GOTO	label43
02FC        label43

			t2con = 0x04;
02FC  3004  	MOVLW 0x04
02FD  0092  	MOVWF gbl_t2con

			break;
	  #endif
	  #ifdef MX_PWM_PSCA4
		case 4:
02EF  3004  	MOVLW 0x04
02F0  0676  	XORWF FC_CAL_PWM_0006C_arg_prescaler, W
02F1  1903  	BTFSC STATUS,Z
02F2  0877  	MOVF FC_CAL_PWM_0006C_arg_prescaler+D'1', W
02F3  1903  	BTFSC STATUS,Z
02F4  2AFF  	GOTO	label44
02FF        label44

			t2con = 0x05;
02FF  3005  	MOVLW 0x05
0300  0092  	MOVWF gbl_t2con

			break;
	  #endif
	  #ifdef MX_PWM_PSCA16
		case 16:
02F5  3010  	MOVLW 0x10
02F6  0676  	XORWF FC_CAL_PWM_0006C_arg_prescaler, W
02F7  1903  	BTFSC STATUS,Z
02F8  0877  	MOVF FC_CAL_PWM_0006C_arg_prescaler+D'1', W
02F9  1903  	BTFSC STATUS,Z
02FA  2B02  	GOTO	label45
0302        label45

			t2con = 0x06;
0302  3006  	MOVLW 0x06
0303  0092  	MOVWF gbl_t2con

			break;
	  #endif
	  #ifdef MX_PWM_PSCA64
		case 64:
			t2con = 0x07;					//Note some earlier devices do not have the /64 option
			break;
	  #endif
	}
  #endif
}
02FB  0008  	RETURN
02FE  0008  	RETURN
0301  0008  	RETURN
0304  0008  	RETURN



CALFUNCTION(void, FC_CAL_PWM_Set_Duty_10Bit_, (MX_UINT16 duty))
{
	char nCCPxCONtemp;

	#if (MX_PWM_CHANNEL_X == 1)
		ccpr1l = (duty & 0x3FC) >> 2;									//Update Capture Compare Count 1
		duty = (duty & 0x03) << 4;
		nCCPxCONtemp = (ccp1con & 0xCF) | duty;
		ccp1con = nCCPxCONtemp;
	#endif

	#if (MX_PWM_CHANNEL_X == 2)
		ccpr2l = (duty & 0x3FC) >> 2;									//Update Capture Compare Count 2
		duty = (duty & 0x03) << 4;
		nCCPxCONtemp = (ccp2con & 0xCF) | duty;
		ccp2con = nCCPxCONtemp;
	#endif

	#if (MX_PWM_CHANNEL_X == 3)
		ccpr3l = (duty & 0x3FC) >> 2;									//Update Capture Compare Count 3
		duty = (duty & 0x03) << 4;
		nCCPxCONtemp = (ccp3con & 0xCF) | duty;
		ccp3con = nCCPxCONtemp;
	#endif

	#if (MX_PWM_CHANNEL_X == 4)
		ccpr4l = (duty & 0x3FC) >> 2;									//Update Capture Compare Count 4
		duty = (duty & 0x03) << 4;
		nCCPxCONtemp = (ccp4con & 0xCF) | duty;
		ccp4con = nCCPxCONtemp;
	#endif

	#if (MX_PWM_CHANNEL_X == 5)
		ccpr5l = (duty & 0x3FC) >> 2;									//Update Capture Compare Count 5
		duty = (duty & 0x03) << 4;
		nCCPxCONtemp = (ccp5con & 0xCF) | duty;
		ccp5con = nCCPxCONtemp;
	#endif

	#if (MX_PWM_CHANNEL_X == 6)
		ccpr6l = (duty & 0x3FC) >> 2;									//Update Capture Compare Count 6
		duty = (duty & 0x03) << 4;
		nCCPxCONtemp = (ccp6con & 0xCF) | duty;
		ccp6con = nCCPxCONtemp;
	#endif

	#if (MX_PWM_CHANNEL_X == 7)
		ccpr7l = (duty & 0x3FC) >> 2;									//Update Capture Compare Count 7
		duty = (duty & 0x03) << 4;
		nCCPxCONtemp = (ccp7con & 0xCF) | duty;
		ccp7con = nCCPxCONtemp;
	#endif

	#if (MX_PWM_CHANNEL_X == 8)
		ccpr8l = (duty & 0x3FC) >> 2;									//Update Capture Compare Count 8
		duty = (duty & 0x03) << 4;
		nCCPxCONtemp = (ccp8con & 0xCF) | duty;
		ccp8con = nCCPxCONtemp;
	#endif

	#if (MX_PWM_CHANNEL_X == 9)
		ccpr9l = (duty & 0x3FC) >> 2;									//Update Capture Compare Count 9
		duty = (duty & 0x03) << 4;
		nCCPxCONtemp = (ccp9con & 0xCF) | duty;
		ccp9con = nCCPxCONtemp;
	#endif

	#if (MX_PWM_CHANNEL_X == 10)
		ccpr10l = (duty & 0x3FC) >> 2;									//Update Capture Compare Count 10
		duty = (duty & 0x03) << 4;
		nCCPxCONtemp = (ccp10con & 0xCF) | duty;
		ccp10con = nCCPxCONtemp;
	#endif
}


/*********************************************************************
 *                  Flowcode CAL UART File
 *
 * File: PIC_CAL_UART.c
 *
 * (c) 2011 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * Company) for its Flowcode graphical programming language is
 * intended and supplied to you, the Companys customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 010911 | BR | Created
 * 020911 | BR | Updated variables with typedef alternatives
 * 011211 | BR | Converted to new dynamic defines mechanism
 * 160112 | BR | Fixed issues with rx return type and low bauds on fast devices
 * 020212 | ST | Added <MX_UART_2_PIE4> routing to account for differences in 16F and 18F devices with 2 UARTs
 * 270212 | BR | Fixed a bug in the receive functionality
 * 280212 | BR | Sorted out auto echo functionality
 * 160412 | BR | Addition of HW change baud function
 */



#ifndef MX_UART_SW_DEFS
	#define MX_UART_SW_DEFS

	#ifdef _BOOSTC
		#define INST_COUNT	45	//65 for lower speeds or 40 for higher speeds.
	#endif
	#ifdef HI_TECH_C
		#define INST_COUNT	315
	#endif

	//Work out number of nops for software baud rate
	#define MX_INSTRUCTION_SPEED 	(MX_CLK_SPEED / 4)
	#define MX_OVERHEAD				(MX_INSTRUCTION_SPEED / INST_COUNT)
	#define SW_OFFSET				(1000000 / MX_OVERHEAD)

	//Work out software baud rates if required
	#define SW_1200_BAUD	(832 - SW_OFFSET)
	#define SW_2400_BAUD	(416 - SW_OFFSET)
	#define SW_4800_BAUD	(208 - SW_OFFSET)
	#define SW_9600_BAUD	(104 - SW_OFFSET)
	#define SW_19200_BAUD	(52 - SW_OFFSET)
	#define SW_31250_BAUD	(32 - SW_OFFSET)
	#define SW_115200_BAUD	(8 - SW_OFFSET)
#endif

 #if defined(MX_UART_CHANNEL_1) && (MX_UART_NUM==1)
	#if (MX_UART_CHANNEL_1 == 0)
		#if (MX_UART_BAUD_1 == 1200)
			#define MX_SOFT_BAUD_1	SW_1200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 1200 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_1 == 2400)
			#define MX_SOFT_BAUD_1	SW_2400_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 2400 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_1 == 4800)
			#define MX_SOFT_BAUD_1	SW_4800_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 4800 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_1 == 9600)
			#define MX_SOFT_BAUD_1	SW_9600_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 9600 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_1 == 19200)
			#define MX_SOFT_BAUD_1	SW_19200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 19200 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_1 == 31250)
			#define MX_SOFT_BAUD_1	SW_31250_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 31250 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_1 == 115200)
			#define MX_SOFT_BAUD_1	SW_115200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 115200 Not Available At This Clock Speed"
			#endif
		#endif
		#ifndef MX_SOFT_BAUD_1
			#error "UART Baud Rate not supported in Software Mode"
		#endif
	#else
		#define MX_SOFT_BAUD_1	1
		#define MX_HARD_BAUD_1	(((MX_CLK_SPEED / MX_UART_BAUD_1) - 16) / 16)
		#define MX_HARD_SLOW_1	0

		#if (MX_HARD_BAUD_1 > 255)
			#undef MX_HARD_BAUD_1
			#undef MX_HARD_SLOW_1
			#define MX_HARD_BAUD_1	(((MX_CLK_SPEED / MX_UART_BAUD_1) - 16)	/ 64)
			#define MX_HARD_SLOW_1	1
		#endif

	#endif
 #endif
 #if defined(MX_UART_CHANNEL_2) && (MX_UART_NUM==2)
	#if (MX_UART_CHANNEL_2 == 0)
		#if (MX_UART_BAUD_2 == 1200)
			#define MX_SOFT_BAUD_2	SW_1200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 1200 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_2 == 2400)
			#define MX_SOFT_BAUD_2	SW_2400_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 2400 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_2 == 4800)
			#define MX_SOFT_BAUD_2	SW_4800_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 4800 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_2 == 9600)
			#define MX_SOFT_BAUD_2	SW_9600_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 9600 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_2 == 19200)
			#define MX_SOFT_BAUD_2	SW_19200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 19200 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_2 == 31250)
			#define MX_SOFT_BAUD_2	SW_31250_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 31250 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_2 == 115200)
			#define MX_SOFT_BAUD_2	SW_115200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 115200 Not Available At This Clock Speed"
			#endif
		#endif
		#ifndef MX_SOFT_BAUD_2
			#error "UART Baud Rate not supported in Software Mode"
		#endif
	#else
		#define MX_SOFT_BAUD_2	1
		#define MX_HARD_BAUD_2	(((MX_CLK_SPEED / MX_UART_BAUD_2) - 16) / 16)
		#define MX_HARD_SLOW_2	0

		#if (MX_HARD_BAUD_2 > 255)
			#undef MX_HARD_BAUD_2
			#undef MX_HARD_SLOW_2
			#define MX_HARD_BAUD_2	(((MX_CLK_SPEED / MX_UART_BAUD_2) - 16)	/ 64)
			#define MX_HARD_SLOW_2	1
		#endif
 	#endif
 #endif
 #if defined(MX_UART_CHANNEL_3) && (MX_UART_NUM==3)
	#if (MX_UART_CHANNEL_3 == 0)
		#if (MX_UART_BAUD_3 == 1200)
			#define MX_SOFT_BAUD_3	SW_1200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 1200 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_3 == 2400)
			#define MX_SOFT_BAUD_3	SW_2400_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 2400 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_3 == 4800)
			#define MX_SOFT_BAUD_3	SW_4800_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 4800 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_3 == 9600)
			#define MX_SOFT_BAUD_3	SW_9600_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 9600 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_3 == 19200)
			#define MX_SOFT_BAUD_3	SW_19200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 19200 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_3 == 31250)
			#define MX_SOFT_BAUD_3	SW_31250_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 31250 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_3 == 115200)
			#define MX_SOFT_BAUD_3	SW_115200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 115200 Not Available At This Clock Speed"
			#endif
		#endif
		#ifndef MX_SOFT_BAUD_3
			#error "UART Baud Rate not supported in Software Mode"
		#endif
	#else
		#define MX_SOFT_BAUD_3	1
		#define MX_HARD_BAUD_3	(((MX_CLK_SPEED / MX_UART_BAUD_3) - 16) / 16)
		#define MX_HARD_SLOW_3	0

		#if (MX_HARD_BAUD_3 > 255)
			#undef MX_HARD_BAUD_3
			#undef MX_HARD_SLOW_3
			#define MX_HARD_BAUD_3	(((MX_CLK_SPEED / MX_UART_BAUD_3) - 16)	/ 64)
			#define MX_HARD_SLOW_3	1
		#endif
	#endif
 #endif
 #if defined(MX_UART_CHANNEL_4) && (MX_UART_NUM==4)
	#if (MX_UART_CHANNEL_4 == 0)
		#if (MX_UART_BAUD_4 == 1200)
			#define MX_SOFT_BAUD_4	SW_1200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 1200 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_4 == 2400)
			#define MX_SOFT_BAUD_4	SW_2400_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 2400 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_4 == 4800)
			#define MX_SOFT_BAUD_4	SW_4800_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 4800 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_4 == 9600)
			#define MX_SOFT_BAUD_4	SW_9600_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 9600 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_4 == 19200)
			#define MX_SOFT_BAUD_4	SW_19200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 19200 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_4 == 31250)
			#define MX_SOFT_BAUD_4	SW_31250_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 31250 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_4 == 115200)
			#define MX_SOFT_BAUD_4	SW_115200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 115200 Not Available At This Clock Speed"
			#endif
		#endif
		#ifndef MX_SOFT_BAUD_4
			#error "UART Baud Rate not supported in Software Mode"
		#endif
	#else
		#define MX_SOFT_BAUD_4	1
		#define MX_HARD_BAUD_4	(((MX_CLK_SPEED / MX_UART_BAUD_4) - 16) / 16)
		#define MX_HARD_SLOW_4	0

		#if (MX_HARD_BAUD_4 > 255)
			#undef MX_HARD_BAUD_4
			#undef MX_HARD_SLOW_4
			#define MX_HARD_BAUD_4	(((MX_CLK_SPEED / MX_UART_BAUD_4) - 16)	/ 64)
			#define MX_HARD_SLOW_4	1
		#endif
	#endif
 #endif


//Hardware Baud update definitions
#ifndef MX_HARD_BAUD_CHANGE_DEFS
	#define MX_HARD_BAUD_CHANGE_DEFS

	#define MX_HARD_BAUD_1200	(((MX_CLK_SPEED / 1200) - 16) / 16)
	#if (MX_HARD_BAUD_1200 > 255)
		#undef MX_HARD_BAUD_1200
		#define MX_HARD_BAUD_1200	(((MX_CLK_SPEED / 1200) - 16) / 64)
		#define MX_HARD_SLOW_1200	1
	#else
		#define MX_HARD_SLOW_1200	0
	#endif

	#define MX_HARD_BAUD_2400	(((MX_CLK_SPEED / 2400) - 16) / 16)
	#if (MX_HARD_BAUD_2400 > 255)
		#undef MX_HARD_BAUD_2400
		#define MX_HARD_BAUD_2400	(((MX_CLK_SPEED / 2400) - 16) / 64)
		#define MX_HARD_SLOW_2400	1
	#else
		#define MX_HARD_SLOW_2400	0
	#endif

	#define MX_HARD_BAUD_4800	(((MX_CLK_SPEED / 4800) - 16) / 16)
	#if (MX_HARD_BAUD_4800 > 255)
		#undef MX_HARD_BAUD_4800
		#define MX_HARD_BAUD_4800	(((MX_CLK_SPEED / 4800) - 16) / 64)
		#define MX_HARD_SLOW_4800	1
	#else
		#define MX_HARD_SLOW_4800	0
	#endif

	#define MX_HARD_BAUD_9600	(((MX_CLK_SPEED / 9600) - 16) / 16)
	#if (MX_HARD_BAUD_9600 > 255)
		#undef MX_HARD_BAUD_9600
		#define MX_HARD_BAUD_9600	(((MX_CLK_SPEED / 9600) - 16) / 64)
		#define MX_HARD_SLOW_9600	1
	#else
		#define MX_HARD_SLOW_9600	0
	#endif

	#define MX_HARD_BAUD_19200	(((MX_CLK_SPEED / 19200) - 16) / 16)
	#if (MX_HARD_BAUD_19200 > 255)
		#undef MX_HARD_BAUD_19200
		#define MX_HARD_BAUD_19200	(((MX_CLK_SPEED / 19200) - 16) / 64)
		#define MX_HARD_SLOW_19200	1
	#else
		#define MX_HARD_SLOW_19200	0
	#endif

	#define MX_HARD_BAUD_38400	(((MX_CLK_SPEED / 38400) - 16) / 16)
	#if (MX_HARD_BAUD_38400 > 255)
		#undef MX_HARD_BAUD_38400
		#define MX_HARD_BAUD_38400	(((MX_CLK_SPEED / 38400) - 16) / 64)
		#define MX_HARD_SLOW_38400	1
	#else
		#define MX_HARD_SLOW_38400	0
	#endif

	#define MX_HARD_BAUD_57600	(((MX_CLK_SPEED / 57600) - 16) / 16)
	#if (MX_HARD_BAUD_57600 > 255)
		#undef MX_HARD_BAUD_57600
		#define MX_HARD_BAUD_57600	(((MX_CLK_SPEED / 57600) - 16) / 64)
		#define MX_HARD_SLOW_57600	1
	#else
		#define MX_HARD_SLOW_57600	0
	#endif

	#define MX_HARD_BAUD_115200	(((MX_CLK_SPEED / 115200) - 16) / 16)
	#if (MX_HARD_BAUD_115200 > 255)
		#undef MX_HARD_BAUD_115200
		#define MX_HARD_BAUD_115200	(((MX_CLK_SPEED / 115200) - 16) / 64)
		#define MX_HARD_SLOW_115200	1
	#else
		#define MX_HARD_SLOW_115200	0
	#endif
#endif


//Dynamic function naming based on defines and index number
#define MX_UART_CHANNEL_X	CAL_APPEND(MX_UART_CHANNEL_, MX_UART_NUM)
#define MX_UART_TX_PIN_X	CAL_APPEND(MX_UART_TX_PIN_, MX_UART_NUM)
#define MX_UART_TX_PORT_X	CAL_APPEND(MX_UART_TX_PORT_, MX_UART_NUM)
#define MX_UART_TX_TRIS_X	CAL_APPEND(MX_UART_TX_TRIS_, MX_UART_NUM)
#define MX_UART_RX_PIN_X	CAL_APPEND(MX_UART_RX_PIN_, MX_UART_NUM)
#define MX_UART_RX_PORT_X	CAL_APPEND(MX_UART_RX_PORT_, MX_UART_NUM)
#define MX_UART_RX_TRIS_X	CAL_APPEND(MX_UART_RX_TRIS_, MX_UART_NUM)
#define MX_UART_FLOWEN_X	CAL_APPEND(MX_UART_FLOWEN_, MX_UART_NUM)
#define MX_UART_CTS_PIN_X	CAL_APPEND(MX_UART_CTS_PIN_, MX_UART_NUM)
#define MX_UART_CTS_PORT_X	CAL_APPEND(MX_UART_CTS_PORT_, MX_UART_NUM)
#define MX_UART_CTS_TRIS_X	CAL_APPEND(MX_UART_CTS_TRIS_, MX_UART_NUM)
#define MX_UART_RTS_PIN_X	CAL_APPEND(MX_UART_RTS_PIN_, MX_UART_NUM)
#define MX_UART_RTS_PORT_X	CAL_APPEND(MX_UART_RTS_PORT_, MX_UART_NUM)
#define MX_UART_RTS_TRIS_X	CAL_APPEND(MX_UART_RTS_TRIS_, MX_UART_NUM)
#define MX_UART_DBITS_X		CAL_APPEND(MX_UART_DBITS_, MX_UART_NUM)
#define MX_UART_RETURN_X	CAL_APPEND(MX_UART_RETURN_, MX_UART_NUM)
#define MX_UART_ECHO_X		CAL_APPEND(MX_UART_ECHO_, MX_UART_NUM)
#define MX_UART_INT_X		CAL_APPEND(MX_UART_INT_, MX_UART_NUM)
#define MX_UART_BAUD_X		CAL_APPEND(MX_HARD_BAUD_, MX_UART_NUM)
#define MX_SOFT_BAUD_X		CAL_APPEND(MX_SOFT_BAUD_, MX_UART_NUM)
#define MX_HARD_SLOW_X		CAL_APPEND(MX_HARD_SLOW_, MX_UART_NUM)

#define UART_Delay_CAL		CAL_APPEND(FC_CAL_UART_Delay_, MX_UART_NUM)
#define UART_Send			CAL_APPEND(FC_CAL_UART_Send_, MX_UART_NUM)
#define UART_Uninit			CAL_APPEND(FC_CAL_UART_Uninit_, MX_UART_NUM)


//Component Definitions
#define UART_STATUS_LOOP	0
#define UART_STATUS_TIMEOUT	1
#define UART_STATUS_RXBYTE	2


//Interrupt Definitions
#ifdef MX_UART_2_PIE4
  #define MX_UART2_PIE pie4
  #define MX_UART2_PIR pir4
  #define MX_UART2_TXSTA tx2sta
  #define MX_UART2_RCSTA rc2sta
  #define MX_UART2_TXREG tx2reg
  #define MX_UART2_RCREG rc2reg
#else
  #define MX_UART2_PIE pie3
  #define MX_UART2_PIR pir3
  #define MX_UART2_TXSTA txsta2
  #define MX_UART2_RCSTA rcsta2
  #define MX_UART2_TXREG txreg2
  #define MX_UART2_RCREG rcreg2
#endif

#if (MX_UART_INT_X == 1)

	#ifndef MX_UART_INT_DEFS
	#define MX_UART_INT_DEFS

		#define MX_UART_INT_CH1_FUNC
		#define MX_UART_INT_CH2_FUNC
		#define MX_UART_INT_FUNC_END

		#define MX_UART_INT_CH1_DET		ts_bit(pir1, RCIF) && ts_bit(pie1, RCIE)
		#define MX_UART_INT_CH2_DET		ts_bit(MX_UART2_PIR, RC2IF) && ts_bit(MX_UART2_PIE, RC2IE)

		#define MX_UART_INT_CH1_EN		st_bit (pie1, RCIE)
		#define MX_UART_INT_CH2_EN		st_bit (MX_UART2_PIE, RC2IE)

		#define MX_UART_INT_CH1_DIS		cr_bit (pie1, RCIE)
		#define MX_UART_INT_CH2_DIS		cr_bit (MX_UART2_PIE, RC2IE)

		#define MX_UART_INT_CH1_CLR		cr_bit (pir1, RCIF)
		#define MX_UART_INT_CH2_CLR		cr_bit (MX_UART2_PIR, RC2IF)

	#endif
#endif


//Function Prototypes
CALFUNCTION(void, FC_CAL_UART_Init_, (void));
CALFUNCTION(void, FC_CAL_UART_Uninit_, (void));
CALFUNCTION(void, FC_CAL_UART_Send_, (MX_UINT16 nChar));
CALFUNCTION(MX_SINT16, FC_CAL_UART_Receive_, (MX_UINT8 nTimeout));
CALFUNCTION(void, FC_CAL_UART_Delay_, (void));


//Peripheral Functions
CALFUNCTION(void, FC_CAL_UART_Init_, (void))

{

	#if (MX_UART_CHANNEL_X == 0)
		FC_CAL_Bit_In_DDR 	(MX_UART_RX_PORT_X, MX_UART_RX_TRIS_X, MX_UART_RX_PIN_X);		// Receive pin is a input
		FC_CAL_Bit_High_DDR (MX_UART_TX_PORT_X, MX_UART_TX_TRIS_X, MX_UART_TX_PIN_X);		// Transmit pin is default high
	#endif

	#if (MX_UART_CHANNEL_X == 1)
	  #ifndef MX_UART_1
	  	  #error "UART channel 1 not available on this device"
	  #else
		  #if (MX_HARD_SLOW_X == 1)
			cr_bit(txsta, BRGH);						//Low Speed
		  #else
			st_bit(txsta, BRGH);						//High Speed
0634  1683  	BSF STATUS, RP0
0635  1303  	BCF STATUS, RP1
0636  1518  	BSF gbl_txsta,2

		  #endif
			spbrg = MX_UART_BAUD_X;   					// set the baud rate
0637  3014  	MOVLW 0x14
0638  0099  	MOVWF gbl_spbrg

			rcsta = 0;                    				// 8-bit, disabled
0639  1283  	BCF STATUS, RP0
063A  0198  	CLRF gbl_rcsta


			#if(MX_UART_DBITS_X == 9)
				st_bit(txsta, TX9);   					// 9-bit TX
				st_bit(rcsta, RX9);                    	// 9-bit RX
			#endif

			st_bit(rcsta, SPEN);         				// turn on serial interface
063B  1798  	BSF gbl_rcsta,7

			st_bit(txsta, TXEN);
063C  1683  	BSF STATUS, RP0
063D  1698  	BSF gbl_txsta,5

			st_bit(rcsta, CREN);
063E  1283  	BCF STATUS, RP0
063F  1618  	BSF gbl_rcsta,4


			#if (MX_UART_INT_X == 1)
				MX_UART_INT_CH1_EN;
				st_bit(intcon, PEIE);
				st_bit(intcon, GIE);
			#else
				cr_bit (pie1, RCIE);
0640  1683  	BSF STATUS, RP0
0641  128C  	BCF gbl_pie1,5

			#endif
	  #endif
	#endif


	#if (MX_UART_CHANNEL_X == 2)

	  #ifndef MX_UART_2
		  #error "UART channel 2 not available on this device"
	  #else
		  #ifdef MX_UART_2_REMAPPABLE
			RPOR9 = 5;									//TX2 - RP9 - RB6
			RPINR16	= 10;								//RX2 - RP10 - RB7
		  #endif
		  #if (MX_HARD_SLOW_X == 1)
			cr_bit(MX_UART2_TXSTA, BRGH);						//Low Speed
		  #else
			st_bit(MX_UART2_TXSTA, BRGH);						//High Speed
		  #endif
			spbrg2 = MX_UART_BAUD_X;   				// set the baud rate
			MX_UART2_RCSTA = 0;                    				// 8-bit, disabled

			#if(MX_UART_DBITS_X == 9)
				st_bit(MX_UART2_TXSTA, TX9);   					// 9-bit TX
				st_bit(MX_UART2_RCSTA, RX9);                    // 9-bit RX
			#endif

			st_bit(MX_UART2_RCSTA, SPEN);         				// turn on serial interface
			st_bit(MX_UART2_TXSTA, TXEN);
			st_bit(MX_UART2_RCSTA, CREN);

			#if (MX_UART_INT_X == 1)
				MX_UART_INT_CH2_EN;
				st_bit(intcon, PEIE);
				st_bit(intcon, GIE);
			#else
				cr_bit (MX_UART2_PIE, RC2IE);
			#endif
	  #endif
	#endif

	#if (MX_UART_FLOWEN_X == 1)						//Flowcontrol enabled?
		FC_CAL_Bit_In_DDR (MX_UART_CTS_PORT_X, MX_UART_CTS_TRIS_X, MX_UART_CTS_PIN_X);	// CTS pin is a input
		FC_CAL_Bit_High_DDR (MX_UART_RTS_PORT_X, MX_UART_RTS_TRIS_X, MX_UART_RTS_PIN_X);	// RTS not ready to accept data
	#endif

}
0642  0008  	RETURN




CALFUNCTION(void, FC_CAL_UART_Uninit_, (void))
{

	#if (MX_UART_CHANNEL_X == 0)
		FC_CAL_Bit_In_DDR (MX_UART_RX_PORT_X, MX_UART_RX_TRIS_X, MX_UART_RX_PIN_X);		// Receive pin is a input
		FC_CAL_Bit_In_DDR (MX_UART_TX_PORT_X, MX_UART_TX_TRIS_X, MX_UART_TX_PIN_X);		// Transmit pin is default high
	#endif

	#if (MX_UART_CHANNEL_X == 1)
			rcsta = 0;                    								// 8-bit, disabled
			txsta = 0;
		  #ifdef MX_UART_RXINT
			MX_UART_INT_CH1_DIS;
		  #endif
	#endif

	#if (MX_UART_CHANNEL_X == 2)
			MX_UART2_RCSTA = 0;                    								// 8-bit, disabled
			MX_UART2_TXSTA = 0;
		  #ifdef MX_UART_RXINT
			MX_UART_INT_CH2_DIS;
		  #endif
	#endif

	#if (MX_UART_FLOWEN_X == 1)										//Flowcontrol enabled?
		FC_CAL_Bit_In_DDR (MX_UART_CTS_PORT_X, MX_UART_CTS_TRIS_X, MX_UART_CTS_PIN_X);		// CTS pin is a input
		FC_CAL_Bit_In_DDR (MX_UART_RTS_PORT_X, MX_UART_RTS_TRIS_X, MX_UART_RTS_PIN_X);		// RTS not ready to accept data
	#endif
}



CALFUNCTION(void, FC_CAL_UART_Send_, (MX_UINT16 nChar))

{
	#if (MX_UART_FLOWEN_X == 1)
		while (FC_CAL_Bit_In(MX_UART_CTS_PORT_X, MX_UART_CTS_PIN_X) != 0);	// Wait until CTS is low
	#endif

	#if (MX_UART_CHANNEL_X == 0)													// Software UART TX
		MX_UINT8 idx;
		FC_CAL_Bit_Low(MX_UART_TX_PORT_X, MX_UART_TX_PIN_X);					// Send Start bit
		UART_Delay_CAL();
		for (idx = 0; idx < MX_UART_DBITS_X; idx++)
		{
			if (nChar & 0x01)														// Mask off data bit
				FC_CAL_Bit_High(MX_UART_TX_PORT_X, MX_UART_TX_PIN_X);
			else
				FC_CAL_Bit_Low(MX_UART_TX_PORT_X, MX_UART_TX_PIN_X);
			UART_Delay_CAL();
			nChar = nChar >> 1;														// Move to next data bit
		}
		FC_CAL_Bit_High(MX_UART_TX_PORT_X, MX_UART_TX_PIN_X);					// Send Stop bit
		UART_Delay_CAL();
	#endif

	#if (MX_UART_CHANNEL_X == 1)
		while (ts_bit(pir1, TXIF) == 0);
02DD        label42
02DD  1283  	BCF STATUS, RP0
02DE  1E0C  	BTFSS gbl_pir1,4
02DF  2ADD  	GOTO	label42


		#if (MX_UART_DBITS_X == 9)
			if (test_bit(nChar, 8))
				st_bit(txsta, TX9D);
			else
				cr_bit(txsta, TX9D);
	  	#endif
		txreg = nChar;
02E0  1683  	BSF STATUS, RP0
02E1  0820  	MOVF FC_CAL_UAR_00082_arg_nChar, W
02E2  1283  	BCF STATUS, RP0
02E3  0099  	MOVWF gbl_txreg

	#endif

	#if (MX_UART_CHANNEL_X == 2)
		while (ts_bit(pir3, TX2IF) == 0);

		#if (MX_UART_DBITS_X == 9)
			if (test_bit(nChar, 8))
				st_bit(MX_UART2_TXSTA, TX9D);
			else
				cr_bit(MX_UART2_TXSTA, TX9D);
		#endif
		MX_UART2_TXREG = nChar;
	#endif
}
02E4  0008  	RETURN



CALFUNCTION(MX_SINT16, FC_CAL_UART_Receive_, (MX_UINT8 nTimeout))

{
  #if (MX_UART_RETURN_X == 1)
	MX_UINT16 retVal = 512;
  #else
  	MX_UINT8 retVal = 255;
028E  30FF  	MOVLW 0xFF
028F  00F9  	MOVWF FC_CAL_UAR_00083_1_retVal

  #endif

	MX_UINT8 delay1 = 0;
0290  01FA  	CLRF FC_CAL_UAR_00083_1_delay1

	MX_UINT8 regcheck = 0;
0291  01FB  	CLRF FC_CAL_UAR_00083_1_regcheck

	MX_UINT8 bWaitForever = 0;
0292  01FC  	CLRF FC_CAL_UAR_00083_1_bWaitForever

	MX_UINT8 rxStatus = UART_STATUS_LOOP;
0293  01FD  	CLRF FC_CAL_UAR_00083_1_rxStatus


  #if (MX_UART_CHANNEL_X == 0)
  	MX_UINT8 idx;
  #else
  	MX_UINT8 dummy = 0;
0294  01FE  	CLRF FC_CAL_UAR_00083_1_dummy

  #endif

	if (nTimeout == 255)
0295  0A78  	INCF FC_CAL_UAR_00083_arg_nTimeout, W
0296  1D03  	BTFSS STATUS,Z
0297  2A9A  	GOTO	label35
029A        label35

		bWaitForever = 1;
0298  3001  	MOVLW 0x01
0299  00FC  	MOVWF FC_CAL_UAR_00083_1_bWaitForever


	#if (MX_UART_FLOWEN_X == 1)
		FC_CAL_Bit_Low (MX_UART_RTS_PORT_X, MX_UART_RTS_PIN_X);			// Ready to accept data
	#endif

	while (rxStatus == UART_STATUS_LOOP)
029A  08FD  	MOVF FC_CAL_UAR_00083_1_rxStatus, F
029B  1D03  	BTFSS STATUS,Z
029C  2ABE  	GOTO	label38
02BD  2A9A  	GOTO	label35
02BE        label38

	{
		if (bWaitForever == 0)
029D  08FC  	MOVF FC_CAL_UAR_00083_1_bWaitForever, F
029E  1D03  	BTFSS STATUS,Z
029F  2AB5  	GOTO	label37

		{
			if (nTimeout == 0)							//don't wait forever, so do timeout thing...
02A0  08F8  	MOVF FC_CAL_UAR_00083_arg_nTimeout, F
02A1  1D03  	BTFSS STATUS,Z
02A2  2AA6  	GOTO	label36
02A6        label36

			{
				rxStatus = UART_STATUS_TIMEOUT;
02A3  3001  	MOVLW 0x01
02A4  00FD  	MOVWF FC_CAL_UAR_00083_1_rxStatus

			}
			else
02A5  2AB5  	GOTO	label37

			{
				delay_us(10);
02A6  300A  	MOVLW 0x0A
02A7  1683  	BSF STATUS, RP0
02A8  00A0  	MOVWF delay_us_00000_arg_del
02A9  201C  	CALL delay_us_00000

				delay1 = delay1 + 1;
02AA  1283  	BCF STATUS, RP0
02AB  0A7A  	INCF FC_CAL_UAR_00083_1_delay1, W
02AC  00FA  	MOVWF FC_CAL_UAR_00083_1_delay1

				if(delay1 == 100)
02AD  087A  	MOVF FC_CAL_UAR_00083_1_delay1, W
02AE  3A64  	XORLW 0x64
02AF  1D03  	BTFSS STATUS,Z
02B0  2AB5  	GOTO	label37
02B5        label37

				{
					nTimeout = nTimeout - 1;
02B1  0378  	DECF FC_CAL_UAR_00083_arg_nTimeout, W
02B2  00F8  	MOVWF FC_CAL_UAR_00083_arg_nTimeout

					MX_CLEAR_WATCHDOG;
02B3  0064  	CLRWDT

					delay1 = 0;
02B4  01FA  	CLRF FC_CAL_UAR_00083_1_delay1

				}
			}
		}

		#if (MX_UART_CHANNEL_X == 0)
			regcheck = FC_CAL_Bit_In(MX_UART_RX_PORT_1, MX_UART_RX_PIN_1);	//Test for start bit
			if (regcheck == 0)
				rxStatus = UART_STATUS_RXBYTE;
		#endif

		#if (MX_UART_CHANNEL_X == 1)
			regcheck = ts_bit(pir1, RCIF);
02B5  3020  	MOVLW 0x20
02B6  050C  	ANDWF gbl_pir1, W
02B7  00FB  	MOVWF FC_CAL_UAR_00083_1_regcheck

			if (regcheck != 0)
02B8  08FB  	MOVF FC_CAL_UAR_00083_1_regcheck, F
02B9  1903  	BTFSC STATUS,Z
02BA  2A9A  	GOTO	label35

				rxStatus = UART_STATUS_RXBYTE;
02BB  3002  	MOVLW 0x02
02BC  00FD  	MOVWF FC_CAL_UAR_00083_1_rxStatus

		#endif

		#if (MX_UART_CHANNEL_X == 2)
			regcheck = ts_bit(MX_UART2_PIR, RC2IF);
			if (regcheck != 0)
				rxStatus = UART_STATUS_RXBYTE;
		#endif

	}

	if (rxStatus == UART_STATUS_RXBYTE)
02BE  087D  	MOVF FC_CAL_UAR_00083_1_rxStatus, W
02BF  3A02  	XORLW 0x02
02C0  1D03  	BTFSS STATUS,Z
02C1  2AD8  	GOTO	label41

	{
		#if (MX_UART_CHANNEL_X == 0)

			retVal = 0;
			UART_Delay_CAL();

			for (idx = 0; idx < MX_UART_DBITS_X; idx++)
			{
				if (FC_CAL_Bit_In(MX_UART_RX_PORT_X, MX_UART_RX_PIN_X))
					retVal = retVal | (0x01 << idx);

				UART_Delay_CAL();
			}
		#endif

		#if (MX_UART_CHANNEL_X == 1)
			regcheck = ts_bit(rcsta, FERR);
02C2  3004  	MOVLW 0x04
02C3  0518  	ANDWF gbl_rcsta, W
02C4  00FB  	MOVWF FC_CAL_UAR_00083_1_regcheck

			if (regcheck != 0)
02C5  08FB  	MOVF FC_CAL_UAR_00083_1_regcheck, F
02C6  1903  	BTFSC STATUS,Z
02C7  2ACB  	GOTO	label39
02CB        label39

			{
				dummy = rcreg;						//need to read the rcreg to clear FERR
02C8  081A  	MOVF gbl_rcreg, W
02C9  00FE  	MOVWF FC_CAL_UAR_00083_1_dummy

				#if (MX_UART_RETURN_X == 1)
					retVal = 0x400;					//Framing Error Flag
				#endif
			}
			else
02CA  2AD8  	GOTO	label41

			{
				regcheck = ts_bit(rcsta, OERR);
02CB  3002  	MOVLW 0x02
02CC  0518  	ANDWF gbl_rcsta, W
02CD  00FB  	MOVWF FC_CAL_UAR_00083_1_regcheck

				if (regcheck != 0)
02CE  08FB  	MOVF FC_CAL_UAR_00083_1_regcheck, F
02CF  1903  	BTFSC STATUS,Z
02D0  2AD4  	GOTO	label40
02D4        label40

				{
					cr_bit(rcsta, CREN);			//Reset receiver to clear error
02D1  1218  	BCF gbl_rcsta,4

					st_bit(rcsta, CREN);
02D2  1618  	BSF gbl_rcsta,4


					#if (MX_UART_RETURN_X == 1)
						retVal = 0x800;				//Overrun Error Flag
					#endif
				}
				else
02D3  2AD8  	GOTO	label41
02D8        label41

				{
					retVal = 0;
02D4  01F9  	CLRF FC_CAL_UAR_00083_1_retVal


					#if (MX_UART_DBITS_X == 9)
						if(ts_bit(rcsta, RX9D))
							retVal = 0x100;
					#endif

					retVal = retVal | rcreg; 			//no error, so rx byte is valid
02D5  081A  	MOVF gbl_rcreg, W
02D6  0479  	IORWF FC_CAL_UAR_00083_1_retVal, W
02D7  00F9  	MOVWF FC_CAL_UAR_00083_1_retVal

				}
			}
		#endif

		#if (MX_UART_CHANNEL_X == 2)
			regcheck = ts_bit(MX_UART2_RCSTA, FERR);
			if (regcheck != 0)
			{
				dummy = MX_UART2_RCREG;			//need to read the rcreg to clear FERR
				#if (MX_UART_RETURN_X == 1)
					retVal = 0x400;					//Framing Error Flag
				#endif
			}
			else
			{
				regcheck = ts_bit(MX_UART2_RCSTA, OERR);
				if (regcheck != 0)
				{
					cr_bit(MX_UART2_RCSTA, CREN);	//Reset receiver to clear error
					st_bit(MX_UART2_RCSTA, CREN);
					#if (MX_UART_RETURN_X == 1)
						retVal = 0x800;				//Overrun Error Flag
					#endif
				}
				else
				{
					retVal = 0;

					#if (MX_UART_DBITS_X == 9)
						if(ts_bit(MX_UART2_RCSTA, RX9D))
							retVal = 0x100;
					#endif

					retVal = retVal | MX_UART2_RCREG; 			//no error, so rx byte is valid
				}
			}

		#endif

		#if (MX_UART_ECHO_X == 1)
			UART_Send(retVal);
		#endif
	}

	#if (MX_UART_FLOWEN_X == 1)
		FC_CAL_Bit_High(MX_UART_RTS_PORT_X, MX_UART_RTS_PIN_X);		//not ready to accept data
	#endif

	return (retVal);
02D8  0879  	MOVF FC_CAL_UAR_00083_1_retVal, W
02D9  1683  	BSF STATUS, RP0
02DA  00A0  	MOVWF CompTempVarRet2294
02DB  01A1  	CLRF CompTempVarRet2294+D'1'

}
02DC  0008  	RETURN



CALFUNCTION(void, FC_CAL_UART_Delay_, (void))
{
  #if (MX_UART_CHANNEL_X == 0)

	MX_UINT16 delay = MX_SOFT_BAUD_X;

	while (delay > 255)
	{
		delay_us(255);
		delay = delay - 255;
		MX_CLEAR_WATCHDOG;
	}
	delay_us(delay);
	MX_CLEAR_WATCHDOG;

  #endif
}


CALFUNCTION(void, FC_CAL_UART_Update_Baud_, (MX_UINT8 new_baud))
{
	//Baud Rates - Function compatible with hardware mode only
	/*
	0 - 1200
	1 - 2400
	2 - 4800
	3 - 9600
	4 - 19200
	5 - 38400
	6 - 57600
	7 - 115200
	*/

	MX_UINT8 baudrate, baudmode;

	if (new_baud > 7)
		return;

	if (new_baud == 0)
	{
		baudrate = MX_HARD_BAUD_1200;
		baudmode = MX_HARD_SLOW_1200;
	}
	else if (new_baud == 1)
	{
		baudrate = MX_HARD_BAUD_2400;
		baudmode = MX_HARD_SLOW_2400;
	}
	else if (new_baud == 2)
	{
		baudrate = MX_HARD_BAUD_4800;
		baudmode = MX_HARD_SLOW_4800;
	}
	else if (new_baud == 3)
	{
		baudrate = MX_HARD_BAUD_9600;
		baudmode = MX_HARD_SLOW_9600;
	}
	else if (new_baud == 4)
	{
		baudrate = MX_HARD_BAUD_19200;
		baudmode = MX_HARD_SLOW_19200;
	}
	else if (new_baud == 5)
	{
		baudrate = MX_HARD_BAUD_38400;
		baudmode = MX_HARD_SLOW_38400;
	}
	else if (new_baud == 6)
	{
		baudrate = MX_HARD_BAUD_57600;
		baudmode = MX_HARD_SLOW_57600;
	}
	else if (new_baud == 7)
	{
		baudrate = MX_HARD_BAUD_115200;
		baudmode = MX_HARD_SLOW_115200;
	}

	UART_Uninit();

	#if (MX_UART_CHANNEL_X == 1)

	    if (baudmode == 1)
			cr_bit(txsta, BRGH);					//Low Speed
	    else
			st_bit(txsta, BRGH);					//High Speed

		spbrg = baudrate;   						// set the baud rate
		rcsta = 0;                    				// 8-bit, disabled

		#if(MX_UART_DBITS_X == 9)
			st_bit(txsta, TX9);   					// 9-bit TX
			st_bit(rcsta, RX9);                    	// 9-bit RX
		#endif

		st_bit(rcsta, SPEN);         				// turn on serial interface
		st_bit(txsta, TXEN);
		st_bit(rcsta, CREN);

		#if (MX_UART_INT_X == 1)
			MX_UART_INT_CH1_EN;
			st_bit(intcon, PEIE);
			st_bit(intcon, GIE);
		#else
			cr_bit (pie1, RCIE);
		#endif
	#endif

	#if (MX_UART_CHANNEL_X == 2)

	  	if (baudmode == 1)
			cr_bit(MX_UART2_TXSTA, BRGH);			//Low Speed
	  	else
			st_bit(MX_UART2_TXSTA, BRGH);			//High Speed

		spbrg2 = baudrate;   						// set the baud rate
		MX_UART2_RCSTA = 0;                    		// 8-bit, disabled

		#if(MX_UART_DBITS_X == 9)
			st_bit(MX_UART2_TXSTA, TX9);   			// 9-bit TX
			st_bit(MX_UART2_RCSTA, RX9);            // 9-bit RX
		#endif

		st_bit(MX_UART2_RCSTA, SPEN);         		// turn on serial interface
		st_bit(MX_UART2_TXSTA, TXEN);
		st_bit(MX_UART2_RCSTA, CREN);

		#if (MX_UART_INT_X == 1)
			MX_UART_INT_CH2_EN;
			st_bit(intcon, PEIE);
			st_bit(intcon, GIE);
		#else
			cr_bit (MX_UART2_PIE, RC2IE);
		#endif
	#endif

	#if (MX_UART_FLOWEN_X == 1)						//Flowcontrol enabled?
		FC_CAL_Bit_In_DDR (MX_UART_CTS_PORT_X, MX_UART_CTS_TRIS_X, MX_UART_CTS_PIN_X);	// CTS pin is a input
		FC_CAL_Bit_High_DDR (MX_UART_RTS_PORT_X, MX_UART_RTS_TRIS_X, MX_UART_RTS_PIN_X);	// RTS not ready to accept data
	#endif

}

////////////////////////////////////////
// Code with no source :-)
////////////////////////////////////////
0000  158A  	BSF PCLATH,3
0001  290F  	GOTO	_startup

0004  00FF  	MOVWF Int1Context
0005  0E03  	SWAPF STATUS, W
0006  1283  	BCF STATUS, RP0
0007  1303  	BCF STATUS, RP1
0008  00BC  	MOVWF Int1BContext
0009  0E0A  	SWAPF PCLATH, W
000A  00BD  	MOVWF Int1BContext+D'1'
000B  0E04  	SWAPF FSR, W
000C  00BE  	MOVWF Int1BContext+D'2'
000D  158A  	BSF PCLATH,3
000E  120A  	BCF PCLATH,4
000F  295F  	GOTO	interrupt
0010        delay_ms_00000
0010        ; { delay_ms ; function begin
0010  08FD  	MOVF delay_ms_00000_arg_del, F
0011  1D03  	BTFSS STATUS,Z
0012  2814  	GOTO	label1
0013  0008  	RETURN
0014        label1
0014  30CC  	MOVLW 0xCC
0015        label2
0015  3EFF  	ADDLW 0xFF
0016  1D03  	BTFSS STATUS,Z
0017  2815  	GOTO	label2
0018  0000  	NOP
0019  0BFD  	DECFSZ delay_ms_00000_arg_del, F
001A  2814  	GOTO	label1
001B  0008  	RETURN
001C        ; } delay_ms function end

001C        delay_us_00000
001C        ; { delay_us ; function begin
001C  3003  	MOVLW 0x03
001D  07A0  	ADDWF delay_us_00000_arg_del, F
001E  0CA0  	RRF delay_us_00000_arg_del, F
001F  0CA0  	RRF delay_us_00000_arg_del, F
0020  307F  	MOVLW 0x7F
0021  05A0  	ANDWF delay_us_00000_arg_del, F
0022        label3
0022  0000  	NOP
0023  0BA0  	DECFSZ delay_us_00000_arg_del, F
0024  2822  	GOTO	label3
0025  0008  	RETURN
0026        ; } delay_us function end

0026        delay_s_00000
0026        ; { delay_s ; function begin
0026        label4
0026  30FA  	MOVLW 0xFA
0027  00FD  	MOVWF delay_ms_00000_arg_del
0028  2010  	CALL delay_ms_00000
0029  30FA  	MOVLW 0xFA
002A  00FD  	MOVWF delay_ms_00000_arg_del
002B  2010  	CALL delay_ms_00000
002C  30FA  	MOVLW 0xFA
002D  00FD  	MOVWF delay_ms_00000_arg_del
002E  2010  	CALL delay_ms_00000
002F  30FA  	MOVLW 0xFA
0030  00FD  	MOVWF delay_ms_00000_arg_del
0031  2010  	CALL delay_ms_00000
0032  0BF9  	DECFSZ delay_s_00000_arg_del, F
0033  2826  	GOTO	label4
0034  0008  	RETURN
0035        ; } delay_s function end


013A        __rem_32_3_00002
013A        ; { __rem_32_32 ; function begin
013A  01AD  	CLRF CompTempVarRet212
013B  01AE  	CLRF CompTempVarRet212+D'1'
013C  01AF  	CLRF CompTempVarRet212+D'2'
013D  01B0  	CLRF CompTempVarRet212+D'3'
013E  01A8  	CLRF __rem_32_3_00002_1_c
013F  01A9  	CLRF __rem_32_3_00002_1_c+D'1'
0140  01AA  	CLRF __rem_32_3_00002_1_c+D'2'
0141  01AB  	CLRF __rem_32_3_00002_1_c+D'3'
0142  01AC  	CLRF __rem_32_3_00002_1_i
0143        label14
0143  1AAC  	BTFSC __rem_32_3_00002_1_i,5
0144  0008  	RETURN
0145  1003  	BCF STATUS,C
0146  0DA8  	RLF __rem_32_3_00002_1_c, F
0147  0DA9  	RLF __rem_32_3_00002_1_c+D'1', F
0148  0DAA  	RLF __rem_32_3_00002_1_c+D'2', F
0149  0DAB  	RLF __rem_32_3_00002_1_c+D'3', F
014A  0DA0  	RLF __rem_32_3_00002_arg_a, F
014B  0DA1  	RLF __rem_32_3_00002_arg_a+D'1', F
014C  0DA2  	RLF __rem_32_3_00002_arg_a+D'2', F
014D  0DA3  	RLF __rem_32_3_00002_arg_a+D'3', F
014E  0DAD  	RLF CompTempVarRet212, F
014F  0DAE  	RLF CompTempVarRet212+D'1', F
0150  0DAF  	RLF CompTempVarRet212+D'2', F
0151  0DB0  	RLF CompTempVarRet212+D'3', F
0152  0827  	MOVF __rem_32_3_00002_arg_b+D'3', W
0153  0230  	SUBWF CompTempVarRet212+D'3', W
0154  1D03  	BTFSS STATUS,Z
0155  2960  	GOTO	label15
0156  0826  	MOVF __rem_32_3_00002_arg_b+D'2', W
0157  022F  	SUBWF CompTempVarRet212+D'2', W
0158  1D03  	BTFSS STATUS,Z
0159  2960  	GOTO	label15
015A  0825  	MOVF __rem_32_3_00002_arg_b+D'1', W
015B  022E  	SUBWF CompTempVarRet212+D'1', W
015C  1D03  	BTFSS STATUS,Z
015D  2960  	GOTO	label15
015E  0824  	MOVF __rem_32_3_00002_arg_b, W
015F  022D  	SUBWF CompTempVarRet212, W
0160        label15
0160  1C03  	BTFSS STATUS,C
0161  2971  	GOTO	label16
0162  0824  	MOVF __rem_32_3_00002_arg_b, W
0163  02AD  	SUBWF CompTempVarRet212, F
0164  0825  	MOVF __rem_32_3_00002_arg_b+D'1', W
0165  1C03  	BTFSS STATUS,C
0166  0F25  	INCFSZ __rem_32_3_00002_arg_b+D'1', W
0167  02AE  	SUBWF CompTempVarRet212+D'1', F
0168  0826  	MOVF __rem_32_3_00002_arg_b+D'2', W
0169  1C03  	BTFSS STATUS,C
016A  0F26  	INCFSZ __rem_32_3_00002_arg_b+D'2', W
016B  02AF  	SUBWF CompTempVarRet212+D'2', F
016C  0827  	MOVF __rem_32_3_00002_arg_b+D'3', W
016D  1C03  	BTFSS STATUS,C
016E  0F27  	INCFSZ __rem_32_3_00002_arg_b+D'3', W
016F  02B0  	SUBWF CompTempVarRet212+D'3', F
0170  1428  	BSF __rem_32_3_00002_1_c,0
0171        label16
0171  0AAC  	INCF __rem_32_3_00002_1_i, F
0172  2943  	GOTO	label14
0173        ; } __rem_32_32 function end

0173        __div_8_8_00000
0173        ; { __div_8_8 ; function begin
0173  01F9  	CLRF __div_8_8_00000_1_r
0174  01FB  	CLRF CompTempVarRet218
0175  01FA  	CLRF __div_8_8_00000_1_i
0176        label17
0176  19FA  	BTFSC __div_8_8_00000_1_i,3
0177  0008  	RETURN
0178  1003  	BCF STATUS,C
0179  0DFB  	RLF CompTempVarRet218, F
017A  0DF7  	RLF __div_8_8_00000_arg_a, F
017B  0DF9  	RLF __div_8_8_00000_1_r, F
017C  0878  	MOVF __div_8_8_00000_arg_b, W
017D  0279  	SUBWF __div_8_8_00000_1_r, W
017E  1C03  	BTFSS STATUS,C
017F  2982  	GOTO	label18
0180  00F9  	MOVWF __div_8_8_00000_1_r
0181  147B  	BSF CompTempVarRet218,0
0182        label18
0182  0AFA  	INCF __div_8_8_00000_1_i, F
0183  2976  	GOTO	label17
0184        ; } __div_8_8 function end

0184        __div_32_3_00001
0184        ; { __div_32_32 ; function begin
0184  01AC  	CLRF __div_32_3_00001_1_r
0185  01AD  	CLRF __div_32_3_00001_1_r+D'1'
0186  01AE  	CLRF __div_32_3_00001_1_r+D'2'
0187  01AF  	CLRF __div_32_3_00001_1_r+D'3'
0188  01B1  	CLRF CompTempVarRet210
0189  01B2  	CLRF CompTempVarRet210+D'1'
018A  01B3  	CLRF CompTempVarRet210+D'2'
018B  01B4  	CLRF CompTempVarRet210+D'3'
018C  01B0  	CLRF __div_32_3_00001_1_i
018D        label19
018D  1AB0  	BTFSC __div_32_3_00001_1_i,5
018E  0008  	RETURN
018F  1003  	BCF STATUS,C
0190  0DB1  	RLF CompTempVarRet210, F
0191  0DB2  	RLF CompTempVarRet210+D'1', F
0192  0DB3  	RLF CompTempVarRet210+D'2', F
0193  0DB4  	RLF CompTempVarRet210+D'3', F
0194  0DA0  	RLF __div_32_3_00001_arg_a, F
0195  0DA1  	RLF __div_32_3_00001_arg_a+D'1', F
0196  0DA2  	RLF __div_32_3_00001_arg_a+D'2', F
0197  0DA3  	RLF __div_32_3_00001_arg_a+D'3', F
0198  0DAC  	RLF __div_32_3_00001_1_r, F
0199  0DAD  	RLF __div_32_3_00001_1_r+D'1', F
019A  0DAE  	RLF __div_32_3_00001_1_r+D'2', F
019B  0DAF  	RLF __div_32_3_00001_1_r+D'3', F
019C  0827  	MOVF __div_32_3_00001_arg_b+D'3', W
019D  022F  	SUBWF __div_32_3_00001_1_r+D'3', W
019E  1D03  	BTFSS STATUS,Z
019F  29AA  	GOTO	label20
01A0  0826  	MOVF __div_32_3_00001_arg_b+D'2', W
01A1  022E  	SUBWF __div_32_3_00001_1_r+D'2', W
01A2  1D03  	BTFSS STATUS,Z
01A3  29AA  	GOTO	label20
01A4  0825  	MOVF __div_32_3_00001_arg_b+D'1', W
01A5  022D  	SUBWF __div_32_3_00001_1_r+D'1', W
01A6  1D03  	BTFSS STATUS,Z
01A7  29AA  	GOTO	label20
01A8  0824  	MOVF __div_32_3_00001_arg_b, W
01A9  022C  	SUBWF __div_32_3_00001_1_r, W
01AA        label20
01AA  1C03  	BTFSS STATUS,C
01AB  29BB  	GOTO	label21
01AC  0824  	MOVF __div_32_3_00001_arg_b, W
01AD  02AC  	SUBWF __div_32_3_00001_1_r, F
01AE  0825  	MOVF __div_32_3_00001_arg_b+D'1', W
01AF  1C03  	BTFSS STATUS,C
01B0  0F25  	INCFSZ __div_32_3_00001_arg_b+D'1', W
01B1  02AD  	SUBWF __div_32_3_00001_1_r+D'1', F
01B2  0826  	MOVF __div_32_3_00001_arg_b+D'2', W
01B3  1C03  	BTFSS STATUS,C
01B4  0F26  	INCFSZ __div_32_3_00001_arg_b+D'2', W
01B5  02AE  	SUBWF __div_32_3_00001_1_r+D'2', F
01B6  0827  	MOVF __div_32_3_00001_arg_b+D'3', W
01B7  1C03  	BTFSS STATUS,C
01B8  0F27  	INCFSZ __div_32_3_00001_arg_b+D'3', W
01B9  02AF  	SUBWF __div_32_3_00001_1_r+D'3', F
01BA  1431  	BSF CompTempVarRet210,0
01BB        label21
01BB  0AB0  	INCF __div_32_3_00001_1_i, F
01BC  298D  	GOTO	label19
01BD        ; } __div_32_32 function end


090F        _startup
090F  30D5  	MOVLW 0xD5
0910  1283  	BCF STATUS, RP0
0911  1303  	BCF STATUS, RP1
0912  00A0  	MOVWF gbl_14_LSR
0913  30C4  	MOVLW 0xC4
0914  00A1  	MOVWF gbl_14_LSR+D'1'
0915  30BB  	MOVLW 0xBB
0916  00A2  	MOVWF gbl_14_LSR+D'2'
0917  30DC  	MOVLW 0xDC
0918  00A3  	MOVWF gbl_14_LSR+D'3'
0919  01A4  	CLRF gbl_15_gbl_aSig
091A  01A5  	CLRF gbl_15_gbl_aSig+D'1'
091B  01A6  	CLRF gbl_15_gbl_aSig+D'2'
091C  01A7  	CLRF gbl_15_gbl_aSig+D'3'
091D  01A8  	CLRF gbl_15_gbl_bSig
091E  01A9  	CLRF gbl_15_gbl_bSig+D'1'
091F  01AA  	CLRF gbl_15_gbl_bSig+D'2'
0920  01AB  	CLRF gbl_15_gbl_bSig+D'3'
0921  01AC  	CLRF gbl_15_gbl_zSig
0922  01AD  	CLRF gbl_15_gbl_zSig+D'1'
0923  01AE  	CLRF gbl_15_gbl_zSig+D'2'
0924  01AF  	CLRF gbl_15_gbl_zSig+D'3'
0925  01CC  	CLRF gbl_15_gbl_aExp
0926  01CD  	CLRF gbl_15_gbl_bExp
0927  01BF  	CLRF gbl_15_gbl_zExp
0928  01C0  	CLRF gbl_15_gbl_zExp+D'1'
0929  01CE  	CLRF gbl_15_gbl_aSign
092A  01CF  	CLRF gbl_15_gbl_bSign
092B  01D0  	CLRF gbl_15_gbl_zSign
092C  01D1  	CLRF gbl_15_gbl_zSigZero
092D  01B0  	CLRF gbl_15_gbl_ret
092E  01B1  	CLRF gbl_15_gbl_ret+D'1'
092F  01B2  	CLRF gbl_15_gbl_ret+D'2'
0930  01B3  	CLRF gbl_15_gbl_ret+D'3'
0931  01CA  	CLRF gbl_float_rounding_mode
0932  01CB  	CLRF gbl_float_exception_flags
0933  01C9  	CLRF gbl_float_detect_tininess

095C  118A  	BCF PCLATH,3
095D  120A  	BCF PCLATH,4
095E  2F8B  	GOTO	main

2007  1F32  	DW 0x1F32
