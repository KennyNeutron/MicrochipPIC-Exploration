;/////////////////////////////////////////////////////////////////////////////////
;// Code Generator: BoostC Compiler - http://www.sourceboost.com
;// Version       : 7.03
;// License Type  : Pro License
;// Limitations   : PIC12,PIC16 max code size:Unlimited, max RAM banks:Unlimited
;/////////////////////////////////////////////////////////////////////////////////

//************************************************************************************
//**  
//**  File name:     C:\Users\gerpe\OneDrive\GER-PER 2016\Documents\KennyNeutron\2020\Thermometer\Flowcode\thermo883_test.c
//**  Title:         
//**  Description:   
//**  
//**  Generated by:  Flowcode v5.2.0.0
//**  Date:          Tuesday, June 30, 2020 13:47:57
//**  Licence:       Professional
//**  Registered to: xyz
//**  Licence key:   WUK7B9
//**  
//**  
//**  http://www.matrixmultimedia.com
//**  
//************************************************************************************


#define MX_PIC

#define MX_USES_UINT8 1
#define MX_USES_SINT16 0
#define MX_USES_CHAR 0
#define MX_USES_FLOAT 1
#define MX_USES_SINT32 1
#define MX_USES_BOOL 1
#define MX_USES_UINT16 0
#define MX_USES_UINT32 0
//Defines for microcontroller
#define P16F883
#define FC_CAL_PIC
#define MX_ADC
#define MX_ADC_TYPE_7
#define MX_ADC_BITS_10
#define MX_EE
#define MX_EE_TYPE2
#define MX_EE_SIZE 256
#define MX_SPI_1
#define MX_SPI_1_MISO_PORT portc
#define MX_SPI_1_MISO_TRIS trisc
#define MX_SPI_1_MISO_PIN 4
#define MX_SPI_1_MOSI_PORT portc
#define MX_SPI_1_MOSI_TRIS trisc
#define MX_SPI_1_MOSI_PIN 5
#define MX_SPI_1_CLK_PORT portc
#define MX_SPI_1_CLK_TRIS trisc
#define MX_SPI_1_CLK_PIN 3
#define MX_SPI_1_SS_PORT portc
#define MX_SPI_1_SS_TRIS trisc
#define MX_UART_1
#define MX_UART_1_TX_PORT portc
#define MX_UART_1_TX_TRIS trisc
#define MX_UART_1_TX_PIN 6
#define MX_UART_1_RX_PORT portc
#define MX_UART_1_RX_TRIS trisc
#define MX_UART_1_RX_PIN 7
#define MX_I2C
#define MX_MI2C
#define MX_I2C_1
#define MX_I2C_1_SDA_PORT portc
#define MX_I2C_1_SDA_TRIS trisc
#define MX_I2C_1_SDA_PIN 4
#define MX_I2C_1_SCL_PORT portc
#define MX_I2C_1_SCL_TRIS trisc
#define MX_I2C_1_SCL_PIN 3
#define MX_PWM
#define MX_PWM_CNT 2
#define MX_PWM_PSCA1
#define MX_PWM_PSCA4
#define MX_PWM_PSCA16
#define MX_PWM_1_PORT portc
#define MX_PWM_1_TRIS trisc
#define MX_PWM_1_PIN 2
#define MX_PWM_2_PORT portc
#define MX_PWM_2_TRIS trisc
#define MX_PWM_2_PIN 1

//Functions
#define MX_CLK_SPEED 3276800
#ifdef _BOOSTC
#include <system.h>
#endif
#ifdef HI_TECH_C
#include <pic.h>
#endif

//Configuration data
#ifdef _BOOSTC
#pragma DATA 0x2007, 0x20d2
#endif
#ifdef HI_TECH_C
__CONFIG(0x20d2);
#endif
#ifdef _BOOSTC
#pragma DATA 0x2008, 0x3eff
#endif
#ifdef HI_TECH_C
__CONFIG(0x3eff);
#endif

//Internal functions
#include "C:\Program Files (x86)\Flowcode\v5\FCD\internals.c"

//Macro function declarations
void FCM_i2c_comm();
void FCM_intro();
void FCM_scan1();
void FCM_scan2();
void FCM_scan3();
void FCM_scan4();
void FCM_ikotled();
void FCM_seg_pattern();
void FCM_display_temp();
void FCM_scan_off();


//Variable declarations
#define FCV_TRUE (1)
#define FCV_FALSE (0)
MX_UINT8 FCV_D_BYTE = (0x0);
02C7  01CA  	CLRF gbl_FCV_D_BYTE

MX_UINT8 FCV_TEMP_TENS = (0x0);
02C8  01CB  	CLRF gbl_FCV_TEMP_TENS

MX_UINT8 FCV_DATA0 = (0xff);
02C9  30FF  	MOVLW 0xFF
02CA  00CC  	MOVWF gbl_FCV_DATA0

MX_SINT32 FCV_RAW = (0);
02CB  01B4  	CLRF gbl_FCV_RAW
02CC  01B5  	CLRF gbl_FCV_RAW+D'1'
02CD  01B6  	CLRF gbl_FCV_RAW+D'2'
02CE  01B7  	CLRF gbl_FCV_RAW+D'3'

MX_UINT8 FCV_TEMP_CDP = (0x0);
02CF  01CD  	CLRF gbl_FCV_TEMP_CDP

MX_UINT8 FCV_DATA1 = (0xff);
02D0  30FF  	MOVLW 0xFF
02D1  00CE  	MOVWF gbl_FCV_DATA1

MX_UINT8 FCV_DATA2 = (0xff);
02D2  30FF  	MOVLW 0xFF
02D3  00CF  	MOVWF gbl_FCV_DATA2

MX_UINT8 FCV_DP2 = (0x0);
02D4  01D0  	CLRF gbl_FCV_DP2

MX_UINT8 FCV_TEMP_DEC = (0x0);
02D5  01D1  	CLRF gbl_FCV_TEMP_DEC

MX_FLOAT FCV_FL;
MX_UINT8 FCV_TEMP_ONES = (0x0);
02D6  01D2  	CLRF gbl_FCV_TEMP_ONES

MX_UINT8 FCV_RT_BYTE = (0x1);
02D7  3001  	MOVLW 0x01
02D8  00D3  	MOVWF gbl_FCV_RT_BYTE

MX_UINT8 FCV_LSB = (0x0);
02D9  01D4  	CLRF gbl_FCV_LSB

MX_UINT8 FCV_DIGIT = (0x0);
02DA  01D5  	CLRF gbl_FCV_DIGIT

MX_UINT8 FCV_MSB = (0x0);
02DB  01D6  	CLRF gbl_FCV_MSB

MX_UINT8 FCV_I2C_RX = (0x0);
02DC  01D7  	CLRF gbl_FCV_I2C_RX

MX_SINT32 FCV_TEMP_C = (0);
02DD  01B8  	CLRF gbl_FCV_TEMP_C
02DE  01B9  	CLRF gbl_FCV_TEMP_C+D'1'
02DF  01BA  	CLRF gbl_FCV_TEMP_C+D'2'
02E0  01BB  	CLRF gbl_FCV_TEMP_C+D'3'


MX_UINT8 FCLV_LOOP1;
MX_UINT8 FCLV_LOOP2;



//I2C_Master(0): //Defines:

/**** Macro Substitutions ****
a = Unique component ID
b = I2C Channel - 0=SW, 1-4=HW
c = Baud Rate
d = SM BUS Enable 0/2
e = Slew Rate Enable 0/1
f = Bitbanged Data Port Letter
g = Bitbanged Data Pin
h = Bitbanged Clock Port Letter
i = Bitbanged Clock Pin
******************************/

//BMODE
//Bit 0 - Slew Control
//Bit 1 - SMBus Control

//Definitions for I2C slot allocation
#ifndef	MX_I2C_REF1
	#define MX_I2C_REF1
	#define I2CMASTER_1_MX_I2C_UREF			1
	#define MX_I2C_CHANNEL_1		1
	#define MX_I2C_SDA_PIN_1		4
	#define MX_I2C_SDA_PORT_1		portd
	#define MX_I2C_SDA_TRIS_1		trisd
	#define MX_I2C_SCL_PIN_1		3
	#define MX_I2C_SCL_PORT_1		portd
	#define MX_I2C_SCL_TRIS_1		trisd
	#define MX_I2C_BMODE_1			0 | 0
	#define MX_I2C_BAUD_1			1000000
	#define MX_I2C_INT_1			0
#else
 #ifndef MX_I2C_REF2
	#define MX_I2C_REF2
	#define I2CMASTER_1_MX_I2C_UREF			2
	#define MX_I2C_CHANNEL_2		1
	#define MX_I2C_SDA_PIN_2		4
	#define MX_I2C_SDA_PORT_2		portd
	#define MX_I2C_SDA_TRIS_2		trisd
	#define MX_I2C_SCL_PIN_2		3
	#define MX_I2C_SCL_PORT_2		portd
	#define MX_I2C_SCL_TRIS_2		trisd
	#define MX_I2C_BMODE_2			0 | 0
	#define MX_I2C_BAUD_2			1000000
	#define MX_I2C_INT_2			0
 #else
  #ifndef MX_I2C_REF3
	#define MX_I2C_REF3
	#define I2CMASTER_1_MX_I2C_UREF			3
	#define MX_I2C_CHANNEL_3		1
	#define MX_I2C_SDA_PIN_3		4
	#define MX_I2C_SDA_PORT_3		portd
	#define MX_I2C_SDA_TRIS_3		trisd
	#define MX_I2C_SCL_PIN_3		3
	#define MX_I2C_SCL_PORT_3		portd
	#define MX_I2C_SCL_TRIS_3		trisd
	#define MX_I2C_BMODE_3			0 | 0
	#define MX_I2C_BAUD_3			1000000
	#define MX_I2C_INT_3			0
  #else
   #ifndef MX_I2C_REF4
	#define MX_I2C_REF4
	#define I2CMASTER_1_MX_I2C_UREF			4
	#define MX_I2C_CHANNEL_4		1
	#define MX_I2C_SDA_PIN_4		4
	#define MX_I2C_SDA_PORT_4		portd
	#define MX_I2C_SDA_TRIS_4		trisd
	#define MX_I2C_SCL_PIN_4		3
	#define MX_I2C_SCL_PORT_4		portd
	#define MX_I2C_SCL_TRIS_4		trisd
	#define MX_I2C_BMODE_4			0 | 0
	#define MX_I2C_BAUD_4			1000000
	#define MX_I2C_INT_4			0
   #endif
  #endif
 #endif
#endif

#define I2CMASTER_1_I2C_Master_Init		CAL_APPEND(FC_CAL_I2C_Master_Init_, I2CMASTER_1_MX_I2C_UREF)
#define I2CMASTER_1_I2C_Master_Uninit	CAL_APPEND(FC_CAL_I2C_Master_Uninit_, I2CMASTER_1_MX_I2C_UREF)
#define I2CMASTER_1_I2C_Master_Start		CAL_APPEND(FC_CAL_I2C_Master_Start_, I2CMASTER_1_MX_I2C_UREF)
#define I2CMASTER_1_I2C_Master_Restart	CAL_APPEND(FC_CAL_I2C_Master_Restart_, I2CMASTER_1_MX_I2C_UREF)
#define I2CMASTER_1_I2C_Master_Stop		CAL_APPEND(FC_CAL_I2C_Master_Stop_, I2CMASTER_1_MX_I2C_UREF)
#define I2CMASTER_1_I2C_Master_TX_Byte	CAL_APPEND(FC_CAL_I2C_Master_TX_Byte_, I2CMASTER_1_MX_I2C_UREF)
#define I2CMASTER_1_I2C_Master_RX_Byte	CAL_APPEND(FC_CAL_I2C_Master_RX_Byte_, I2CMASTER_1_MX_I2C_UREF)

extern void I2CMASTER_1_I2C_Master_Init ();
extern void I2CMASTER_1_I2C_Master_Uninit ();
extern void I2CMASTER_1_I2C_Master_Start ();
extern void I2CMASTER_1_I2C_Master_Restart ();
extern void I2CMASTER_1_I2C_Master_Stop ();
extern MX_UINT8 I2CMASTER_1_I2C_Master_TX_Byte (MX_UINT8 Data);
extern MX_UINT8 I2CMASTER_1_I2C_Master_RX_Byte (MX_UINT8 Last);




//I2C_Master(0): //Macro function declarations

void FCD_I2C_Master0_MI2C_Init();
void FCD_I2C_Master0_MI2C_Start();
void FCD_I2C_Master0_MI2C_Restart();
void FCD_I2C_Master0_MI2C_Stop();
MX_UINT8 FCD_I2C_Master0_MI2C_Transmit_Byte(MX_UINT8 Data);
MX_UINT8 FCD_I2C_Master0_MI2C_Receive_Byte(MX_UINT8 Last);
void FCD_I2C_Master0_MI2C_Send_Byte_Transaction(MX_UINT8 Device_ID, MX_UINT8 AddrH, MX_UINT8 AddrL, MX_UINT8 Data);
MX_UINT8 FCD_I2C_Master0_MI2C_Receive_Byte_Transaction(MX_UINT8 Device_ID, MX_UINT8 AddrH, MX_UINT8 AddrL);



//I2C_Master(0): //Macro implementations


void FCD_I2C_Master0_MI2C_Init()

{
	
		I2CMASTER_1_I2C_Master_Init();
0266  2075  	CALL FC_CAL_I2C_0005B


}
0267  0008  	RETURN


void FCD_I2C_Master0_MI2C_Start()

{
	
		I2CMASTER_1_I2C_Master_Start();
01CA  206D  	CALL FC_CAL_I2C_0005D


}
01CB  0008  	RETURN


void FCD_I2C_Master0_MI2C_Restart()

{
	
		I2CMASTER_1_I2C_Master_Restart();
01C2  2065  	CALL FC_CAL_I2C_0005E


}
01C3  0008  	RETURN


void FCD_I2C_Master0_MI2C_Stop()

{
	
		I2CMASTER_1_I2C_Master_Stop();
01BA  2059  	CALL FC_CAL_I2C_0005F


}
01BB  0008  	RETURN


MX_UINT8 FCD_I2C_Master0_MI2C_Transmit_Byte(MX_UINT8 Data)

{
	
		return I2CMASTER_1_I2C_Master_TX_Byte(Data);
01C4  085A  	MOVF FCD_I2C_Ma_00053_arg_Data, W
01C5  00DB  	MOVWF FC_CAL_I2C_00060_arg_Data
01C6  204A  	CALL FC_CAL_I2C_00060
01C7  085C  	MOVF CompTempVarRet2202, W
01C8  00DB  	MOVWF CompTempVarRet2195


}
01C9  0008  	RETURN


MX_UINT8 FCD_I2C_Master0_MI2C_Receive_Byte(MX_UINT8 Last)

{
	
		return I2CMASTER_1_I2C_Master_RX_Byte(Last);
01BC  085A  	MOVF FCD_I2C_Ma_00055_arg_Last, W
01BD  00DB  	MOVWF FC_CAL_I2C_00061_arg_Last
01BE  2035  	CALL FC_CAL_I2C_00061
01BF  085C  	MOVF CompTempVarRet2203, W
01C0  00DB  	MOVWF CompTempVarRet2196


}
01C1  0008  	RETURN


void FCD_I2C_Master0_MI2C_Send_Byte_Transaction(MX_UINT8 Device_ID, MX_UINT8 AddrH, MX_UINT8 AddrL, MX_UINT8 Data)
{
	
		Device_ID = Device_ID << 1;					//Shift Device ID to enable write mode

		I2CMASTER_1_I2C_Master_Start();						//Start transaction
		I2CMASTER_1_I2C_Master_TX_Byte(Device_ID);			//Transmit Device Address
		I2CMASTER_1_I2C_Master_TX_Byte(AddrH);				//Transmit Internal Address
		I2CMASTER_1_I2C_Master_TX_Byte(AddrL);
		I2CMASTER_1_I2C_Master_TX_Byte(Data);				//Send Data byte
		I2CMASTER_1_I2C_Master_Stop();						//Stop Transaction

}

MX_UINT8 FCD_I2C_Master0_MI2C_Receive_Byte_Transaction(MX_UINT8 Device_ID, MX_UINT8 AddrH, MX_UINT8 AddrL)
{
	
		MX_UINT8 RetVal = 0;
		Device_ID = Device_ID << 1;					//Shift Device ID to enable write mode

		I2CMASTER_1_I2C_Master_Start();						//Start transaction
		I2CMASTER_1_I2C_Master_TX_Byte(Device_ID);			//Transmit Device Address
		I2CMASTER_1_I2C_Master_TX_Byte(AddrH);				//Transmit Internal Address
		I2CMASTER_1_I2C_Master_TX_Byte(AddrL);
		I2CMASTER_1_I2C_Master_Restart();					//Restart transaction

		Device_ID = Device_ID | 0x01;				//Change Device ID to read mode
		I2CMASTER_1_I2C_Master_TX_Byte(Device_ID);			//Transmit Device Address
		RetVal = I2CMASTER_1_I2C_Master_RX_Byte(1);			//Read data at address
		I2CMASTER_1_I2C_Master_Stop();						//Stop Transaction

		return RetVal;								//Return data

}

#include "C:\Program Files (x86)\Flowcode\v5\CAL\includes.c"

//Macro implementations


void FCM_i2c_comm()

{

	//Call Component Macro
	//Call Component Macro: MI2C_Start()
	FCD_I2C_Master0_MI2C_Start();
0205  21CA  	CALL FCD_I2C_Ma_00052


	//Calculation
	//Calculation:
	//  rt_byte = 0
	FCV_RT_BYTE = 0;
0206  1283  	BCF STATUS, RP0
0207  01D3  	CLRF gbl_FCV_RT_BYTE


	//Call Component Macro
	//Call Component Macro: rt_byte=MI2C_Transmit_Byte(0xB4)
	FCV_RT_BYTE = FCD_I2C_Master0_MI2C_Transmit_Byte(0xB4);
0208  30B4  	MOVLW 0xB4
0209  00DA  	MOVWF FCD_I2C_Ma_00053_arg_Data
020A  21C4  	CALL FCD_I2C_Ma_00053
020B  085B  	MOVF CompTempVarRet2195, W
020C  00D3  	MOVWF gbl_FCV_RT_BYTE


	//Calculation
	//Calculation:
	//  rt_byte = 0
	FCV_RT_BYTE = 0;
020D  01D3  	CLRF gbl_FCV_RT_BYTE


	//Call Component Macro
	//Call Component Macro: rt_byte=MI2C_Transmit_Byte(0x07)
	FCV_RT_BYTE = FCD_I2C_Master0_MI2C_Transmit_Byte(0x07);
020E  3007  	MOVLW 0x07
020F  00DA  	MOVWF FCD_I2C_Ma_00053_arg_Data
0210  21C4  	CALL FCD_I2C_Ma_00053
0211  085B  	MOVF CompTempVarRet2195, W
0212  00D3  	MOVWF gbl_FCV_RT_BYTE


	//Comment:
	//end of RD/WR cmd

	//Call Component Macro
	//Call Component Macro: MI2C_Restart()
	FCD_I2C_Master0_MI2C_Restart();
0213  21C2  	CALL FCD_I2C_Ma_00054


	//Calculation
	//Calculation:
	//  rt_byte = 0
	FCV_RT_BYTE = 0;
0214  1283  	BCF STATUS, RP0
0215  01D3  	CLRF gbl_FCV_RT_BYTE


	//Call Component Macro
	//Call Component Macro: rt_byte=MI2C_Transmit_Byte(0xB4)
	FCV_RT_BYTE = FCD_I2C_Master0_MI2C_Transmit_Byte(0xB4);
0216  30B4  	MOVLW 0xB4
0217  00DA  	MOVWF FCD_I2C_Ma_00053_arg_Data
0218  21C4  	CALL FCD_I2C_Ma_00053
0219  085B  	MOVF CompTempVarRet2195, W
021A  00D3  	MOVWF gbl_FCV_RT_BYTE


	//Call Component Macro
	//Call Component Macro: i2c_rx=MI2C_Receive_Byte(rt_byte)
	FCV_I2C_RX = FCD_I2C_Master0_MI2C_Receive_Byte(FCV_RT_BYTE);
021B  0853  	MOVF gbl_FCV_RT_BYTE, W
021C  00DA  	MOVWF FCD_I2C_Ma_00055_arg_Last
021D  21BC  	CALL FCD_I2C_Ma_00055
021E  085B  	MOVF CompTempVarRet2196, W
021F  00D7  	MOVWF gbl_FCV_I2C_RX


	//Calculation
	//Calculation:
	//  data0 = i2c_rx
	FCV_DATA0 = FCV_I2C_RX;
0220  0857  	MOVF gbl_FCV_I2C_RX, W
0221  00CC  	MOVWF gbl_FCV_DATA0


	//Call Component Macro
	//Call Component Macro: i2c_rx=MI2C_Receive_Byte(rt_byte)
	FCV_I2C_RX = FCD_I2C_Master0_MI2C_Receive_Byte(FCV_RT_BYTE);
0222  0853  	MOVF gbl_FCV_RT_BYTE, W
0223  00DA  	MOVWF FCD_I2C_Ma_00055_arg_Last
0224  21BC  	CALL FCD_I2C_Ma_00055
0225  085B  	MOVF CompTempVarRet2196, W
0226  00D7  	MOVWF gbl_FCV_I2C_RX


	//Calculation
	//Calculation:
	//  data1 = i2c_rx
	FCV_DATA1 = FCV_I2C_RX;
0227  0857  	MOVF gbl_FCV_I2C_RX, W
0228  00CE  	MOVWF gbl_FCV_DATA1


	//Call Component Macro
	//Call Component Macro: i2c_rx=MI2C_Receive_Byte(rt_byte)
	FCV_I2C_RX = FCD_I2C_Master0_MI2C_Receive_Byte(FCV_RT_BYTE);
0229  0853  	MOVF gbl_FCV_RT_BYTE, W
022A  00DA  	MOVWF FCD_I2C_Ma_00055_arg_Last
022B  21BC  	CALL FCD_I2C_Ma_00055
022C  085B  	MOVF CompTempVarRet2196, W
022D  00D7  	MOVWF gbl_FCV_I2C_RX


	//Calculation
	//Calculation:
	//  data2 = i2c_rx
	FCV_DATA2 = FCV_I2C_RX;
022E  0857  	MOVF gbl_FCV_I2C_RX, W
022F  00CF  	MOVWF gbl_FCV_DATA2


	//Call Component Macro
	//Call Component Macro: MI2C_Stop()
	FCD_I2C_Master0_MI2C_Stop();
0230  21BA  	CALL FCD_I2C_Ma_00056


}
0231  0008  	RETURN



void FCM_intro()

{

	//Call Macro
	//Call Macro: scan1()
	FCM_scan1();
01EE  2179  	CALL FCM_scan1_00000


	//Call Macro
	//Call Macro: ikotled()
	FCM_ikotled();
01EF  219E  	CALL FCM_ikotle_00057


	//Call Macro
	//Call Macro: scan2()
	FCM_scan2();
01F0  2154  	CALL FCM_scan2_00000


	//Call Macro
	//Call Macro: ikotled()
	FCM_ikotled();
01F1  219E  	CALL FCM_ikotle_00057


	//Call Macro
	//Call Macro: scan3()
	FCM_scan3();
01F2  212F  	CALL FCM_scan3_00000


	//Call Macro
	//Call Macro: ikotled()
	FCM_ikotled();
01F3  219E  	CALL FCM_ikotle_00057


	//Call Macro
	//Call Macro: scan4()
	FCM_scan4();
01F4  210A  	CALL FCM_scan4_00000


	//Call Macro
	//Call Macro: ikotled()
	FCM_ikotled();
01F5  219E  	CALL FCM_ikotle_00057


	//Output
	//Output: 0b01000011 -> PORTA
	trisa = 0x00;
01F6  1683  	BSF STATUS, RP0
01F7  0185  	CLRF gbl_trisa

	porta = (67);
01F8  3043  	MOVLW 0x43
01F9  1283  	BCF STATUS, RP0
01FA  0085  	MOVWF gbl_porta


	//Delay
	//Delay: 1 s
	delay_s(1);
01FB  3001  	MOVLW 0x01
01FC  00DA  	MOVWF delay_s_00000_arg_del
01FD  2026  	CALL delay_s_00000


	//Delay
	//Delay: 500 ms
	delay_ms(255);
01FE  30FF  	MOVLW 0xFF
01FF  00DB  	MOVWF delay_ms_00000_arg_del
0200  2010  	CALL delay_ms_00000

	delay_ms(245);
0201  30F5  	MOVLW 0xF5
0202  00DB  	MOVWF delay_ms_00000_arg_del
0203  2010  	CALL delay_ms_00000


}
0204  0008  	RETURN



void FCM_scan1()

{

	//Output
	//Output: 1 -> B2
	trisb = trisb & 0xFB;
0179  30FB  	MOVLW 0xFB
017A  1683  	BSF STATUS, RP0
017B  1303  	BCF STATUS, RP1
017C  0506  	ANDWF gbl_trisb, W
017D  0086  	MOVWF gbl_trisb

	if ((1))
		portb = (portb & 0xFB) | 0x04;
017E  30FB  	MOVLW 0xFB
017F  1283  	BCF STATUS, RP0
0180  0506  	ANDWF gbl_portb, W
0181  00DA  	MOVWF CompTempVar2197
0182  3004  	MOVLW 0x04
0183  045A  	IORWF CompTempVar2197, W
0184  0086  	MOVWF gbl_portb

	else
		portb = portb & 0xFB;

	//Output
	//Output: 0 -> B3
	trisb = trisb & 0xF7;
0185  30F7  	MOVLW 0xF7
0186  1683  	BSF STATUS, RP0
0187  0506  	ANDWF gbl_trisb, W
0188  0086  	MOVWF gbl_trisb

	if ((0))
		portb = (portb & 0xF7) | 0x08;
	else
		portb = portb & 0xF7;
0189  30F7  	MOVLW 0xF7
018A  1283  	BCF STATUS, RP0
018B  0506  	ANDWF gbl_portb, W
018C  0086  	MOVWF gbl_portb


	//Output
	//Output: 0 -> B4
	trisb = trisb & 0xEF;
018D  30EF  	MOVLW 0xEF
018E  1683  	BSF STATUS, RP0
018F  0506  	ANDWF gbl_trisb, W
0190  0086  	MOVWF gbl_trisb

	if ((0))
		portb = (portb & 0xEF) | 0x10;
	else
		portb = portb & 0xEF;
0191  30EF  	MOVLW 0xEF
0192  1283  	BCF STATUS, RP0
0193  0506  	ANDWF gbl_portb, W
0194  0086  	MOVWF gbl_portb


	//Output
	//Output: 0 -> B5
	trisb = trisb & 0xDF;
0195  30DF  	MOVLW 0xDF
0196  1683  	BSF STATUS, RP0
0197  0506  	ANDWF gbl_trisb, W
0198  0086  	MOVWF gbl_trisb

	if ((0))
		portb = (portb & 0xDF) | 0x20;
	else
		portb = portb & 0xDF;
0199  30DF  	MOVLW 0xDF
019A  1283  	BCF STATUS, RP0
019B  0506  	ANDWF gbl_portb, W
019C  0086  	MOVWF gbl_portb


}
019D  0008  	RETURN



void FCM_scan2()

{

	//Output
	//Output: 0 -> B2
	trisb = trisb & 0xFB;
0154  30FB  	MOVLW 0xFB
0155  1683  	BSF STATUS, RP0
0156  1303  	BCF STATUS, RP1
0157  0506  	ANDWF gbl_trisb, W
0158  0086  	MOVWF gbl_trisb

	if ((0))
		portb = (portb & 0xFB) | 0x04;
	else
		portb = portb & 0xFB;
0159  30FB  	MOVLW 0xFB
015A  1283  	BCF STATUS, RP0
015B  0506  	ANDWF gbl_portb, W
015C  0086  	MOVWF gbl_portb


	//Output
	//Output: 1 -> B3
	trisb = trisb & 0xF7;
015D  30F7  	MOVLW 0xF7
015E  1683  	BSF STATUS, RP0
015F  0506  	ANDWF gbl_trisb, W
0160  0086  	MOVWF gbl_trisb

	if ((1))
		portb = (portb & 0xF7) | 0x08;
0161  30F7  	MOVLW 0xF7
0162  1283  	BCF STATUS, RP0
0163  0506  	ANDWF gbl_portb, W
0164  00DA  	MOVWF CompTempVar2199
0165  3008  	MOVLW 0x08
0166  045A  	IORWF CompTempVar2199, W
0167  0086  	MOVWF gbl_portb

	else
		portb = portb & 0xF7;

	//Output
	//Output: 0 -> B4
	trisb = trisb & 0xEF;
0168  30EF  	MOVLW 0xEF
0169  1683  	BSF STATUS, RP0
016A  0506  	ANDWF gbl_trisb, W
016B  0086  	MOVWF gbl_trisb

	if ((0))
		portb = (portb & 0xEF) | 0x10;
	else
		portb = portb & 0xEF;
016C  30EF  	MOVLW 0xEF
016D  1283  	BCF STATUS, RP0
016E  0506  	ANDWF gbl_portb, W
016F  0086  	MOVWF gbl_portb


	//Output
	//Output: 0 -> B5
	trisb = trisb & 0xDF;
0170  30DF  	MOVLW 0xDF
0171  1683  	BSF STATUS, RP0
0172  0506  	ANDWF gbl_trisb, W
0173  0086  	MOVWF gbl_trisb

	if ((0))
		portb = (portb & 0xDF) | 0x20;
	else
		portb = portb & 0xDF;
0174  30DF  	MOVLW 0xDF
0175  1283  	BCF STATUS, RP0
0176  0506  	ANDWF gbl_portb, W
0177  0086  	MOVWF gbl_portb


}
0178  0008  	RETURN



void FCM_scan3()

{

	//Output
	//Output: 0 -> B2
	trisb = trisb & 0xFB;
012F  30FB  	MOVLW 0xFB
0130  1683  	BSF STATUS, RP0
0131  1303  	BCF STATUS, RP1
0132  0506  	ANDWF gbl_trisb, W
0133  0086  	MOVWF gbl_trisb

	if ((0))
		portb = (portb & 0xFB) | 0x04;
	else
		portb = portb & 0xFB;
0134  30FB  	MOVLW 0xFB
0135  1283  	BCF STATUS, RP0
0136  0506  	ANDWF gbl_portb, W
0137  0086  	MOVWF gbl_portb


	//Output
	//Output: 0 -> B3
	trisb = trisb & 0xF7;
0138  30F7  	MOVLW 0xF7
0139  1683  	BSF STATUS, RP0
013A  0506  	ANDWF gbl_trisb, W
013B  0086  	MOVWF gbl_trisb

	if ((0))
		portb = (portb & 0xF7) | 0x08;
	else
		portb = portb & 0xF7;
013C  30F7  	MOVLW 0xF7
013D  1283  	BCF STATUS, RP0
013E  0506  	ANDWF gbl_portb, W
013F  0086  	MOVWF gbl_portb


	//Output
	//Output: 1 -> B4
	trisb = trisb & 0xEF;
0140  30EF  	MOVLW 0xEF
0141  1683  	BSF STATUS, RP0
0142  0506  	ANDWF gbl_trisb, W
0143  0086  	MOVWF gbl_trisb

	if ((1))
		portb = (portb & 0xEF) | 0x10;
0144  30EF  	MOVLW 0xEF
0145  1283  	BCF STATUS, RP0
0146  0506  	ANDWF gbl_portb, W
0147  00DA  	MOVWF CompTempVar2200
0148  3010  	MOVLW 0x10
0149  045A  	IORWF CompTempVar2200, W
014A  0086  	MOVWF gbl_portb

	else
		portb = portb & 0xEF;

	//Output
	//Output: 0 -> B5
	trisb = trisb & 0xDF;
014B  30DF  	MOVLW 0xDF
014C  1683  	BSF STATUS, RP0
014D  0506  	ANDWF gbl_trisb, W
014E  0086  	MOVWF gbl_trisb

	if ((0))
		portb = (portb & 0xDF) | 0x20;
	else
		portb = portb & 0xDF;
014F  30DF  	MOVLW 0xDF
0150  1283  	BCF STATUS, RP0
0151  0506  	ANDWF gbl_portb, W
0152  0086  	MOVWF gbl_portb


}
0153  0008  	RETURN



void FCM_scan4()

{

	//Output
	//Output: 0 -> B2
	trisb = trisb & 0xFB;
010A  30FB  	MOVLW 0xFB
010B  1683  	BSF STATUS, RP0
010C  1303  	BCF STATUS, RP1
010D  0506  	ANDWF gbl_trisb, W
010E  0086  	MOVWF gbl_trisb

	if ((0))
		portb = (portb & 0xFB) | 0x04;
	else
		portb = portb & 0xFB;
010F  30FB  	MOVLW 0xFB
0110  1283  	BCF STATUS, RP0
0111  0506  	ANDWF gbl_portb, W
0112  0086  	MOVWF gbl_portb


	//Output
	//Output: 0 -> B3
	trisb = trisb & 0xF7;
0113  30F7  	MOVLW 0xF7
0114  1683  	BSF STATUS, RP0
0115  0506  	ANDWF gbl_trisb, W
0116  0086  	MOVWF gbl_trisb

	if ((0))
		portb = (portb & 0xF7) | 0x08;
	else
		portb = portb & 0xF7;
0117  30F7  	MOVLW 0xF7
0118  1283  	BCF STATUS, RP0
0119  0506  	ANDWF gbl_portb, W
011A  0086  	MOVWF gbl_portb


	//Output
	//Output: 0 -> B4
	trisb = trisb & 0xEF;
011B  30EF  	MOVLW 0xEF
011C  1683  	BSF STATUS, RP0
011D  0506  	ANDWF gbl_trisb, W
011E  0086  	MOVWF gbl_trisb

	if ((0))
		portb = (portb & 0xEF) | 0x10;
	else
		portb = portb & 0xEF;
011F  30EF  	MOVLW 0xEF
0120  1283  	BCF STATUS, RP0
0121  0506  	ANDWF gbl_portb, W
0122  0086  	MOVWF gbl_portb


	//Output
	//Output: 1 -> B5
	trisb = trisb & 0xDF;
0123  30DF  	MOVLW 0xDF
0124  1683  	BSF STATUS, RP0
0125  0506  	ANDWF gbl_trisb, W
0126  0086  	MOVWF gbl_trisb

	if ((1))
		portb = (portb & 0xDF) | 0x20;
0127  30DF  	MOVLW 0xDF
0128  1283  	BCF STATUS, RP0
0129  0506  	ANDWF gbl_portb, W
012A  00DA  	MOVWF CompTempVar2201
012B  3020  	MOVLW 0x20
012C  045A  	IORWF CompTempVar2201, W
012D  0086  	MOVWF gbl_portb

	else
		portb = portb & 0xDF;

}
012E  0008  	RETURN



void FCM_ikotled()

{

	//Output
	//Output: 0 -> PORTA
	trisa = 0x00;
019E  1683  	BSF STATUS, RP0
019F  1303  	BCF STATUS, RP1
01A0  0185  	CLRF gbl_trisa

	porta = (0);
01A1  1283  	BCF STATUS, RP0
01A2  0185  	CLRF gbl_porta


	//Calculation
	//Calculation:
	//  d_byte = 1
	FCV_D_BYTE = 1;
01A3  3001  	MOVLW 0x01
01A4  00CA  	MOVWF gbl_FCV_D_BYTE


	//Delay
	//Delay: 200 ms
	delay_ms(200);
01A5  30C8  	MOVLW 0xC8
01A6  00DB  	MOVWF delay_ms_00000_arg_del
01A7  2010  	CALL delay_ms_00000


	//Loop
	//Loop: Loop 8 times
	for (FCLV_LOOP2=0; FCLV_LOOP2<8; FCLV_LOOP2++)
01A8  01D9  	CLRF gbl_FCLV_LOOP2
01A9        label25
01A9  3008  	MOVLW 0x08
01AA  0259  	SUBWF gbl_FCLV_LOOP2, W
01AB  1803  	BTFSC STATUS,C
01B8  0AD9  	INCF gbl_FCLV_LOOP2, F
01B9  29A9  	GOTO	label25

	{

		//Output
		//Output: d_byte -> PORTA
		trisa = 0x00;
01AD  1683  	BSF STATUS, RP0
01AE  0185  	CLRF gbl_trisa

		porta = (FCV_D_BYTE);
01AF  1283  	BCF STATUS, RP0
01B0  084A  	MOVF gbl_FCV_D_BYTE, W
01B1  0085  	MOVWF gbl_porta


		//Calculation
		//Calculation:
		//  d_byte = d_byte * 2
		FCV_D_BYTE = FCV_D_BYTE * 2;
01B2  08CA  	MOVF gbl_FCV_D_BYTE, F
01B3  1003  	BCF STATUS,C
01B4  0DCA  	RLF gbl_FCV_D_BYTE, F


		//Delay
		//Delay: 200 ms
		delay_ms(200);
01B5  30C8  	MOVLW 0xC8
01B6  00DB  	MOVWF delay_ms_00000_arg_del
01B7  2010  	CALL delay_ms_00000



	}

}
01AC  0008  	RETURN



void FCM_seg_pattern()

{

	//Switch
	//Switch: digit?
	switch (FCV_DIGIT)

	{
		case 1:
0084  1283  	BCF STATUS, RP0
0085  1303  	BCF STATUS, RP1
0086  0855  	MOVF gbl_FCV_DIGIT, W
0087  3A01  	XORLW 0x01
0088  1903  	BTFSC STATUS,Z
0089  28A6  	GOTO	label14
00A6        label14

		{
			//Output
			//Output: 0b00110000 -> PORTA
			trisa = 0x00;
00A6  1683  	BSF STATUS, RP0
00A7  0185  	CLRF gbl_trisa

			porta = (48);
00A8  3030  	MOVLW 0x30
00A9  1283  	BCF STATUS, RP0
00AA  0085  	MOVWF gbl_porta


			break;

		}
		case 2:
008A  3A03  	XORLW 0x03
008B  1903  	BTFSC STATUS,Z
008C  28AC  	GOTO	label15
00AC        label15

		{
			//Output
			//Output: 0b01101101 -> PORTA
			trisa = 0x00;
00AC  1683  	BSF STATUS, RP0
00AD  0185  	CLRF gbl_trisa

			porta = (109);
00AE  306D  	MOVLW 0x6D
00AF  1283  	BCF STATUS, RP0
00B0  0085  	MOVWF gbl_porta


			break;

		}
		case 3:
008D  3A01  	XORLW 0x01
008E  1903  	BTFSC STATUS,Z
008F  28B2  	GOTO	label16
00B2        label16

		{
			//Output
			//Output: 0b01111001 -> PORTA
			trisa = 0x00;
00B2  1683  	BSF STATUS, RP0
00B3  0185  	CLRF gbl_trisa

			porta = (121);
00B4  3079  	MOVLW 0x79
00B5  1283  	BCF STATUS, RP0
00B6  0085  	MOVWF gbl_porta


			break;

		}
		case 4:
0090  3A07  	XORLW 0x07
0091  1903  	BTFSC STATUS,Z
0092  28B8  	GOTO	label17
00B8        label17

		{
			//Output
			//Output: 0b00110011 -> PORTA
			trisa = 0x00;
00B8  1683  	BSF STATUS, RP0
00B9  0185  	CLRF gbl_trisa

			porta = (51);
00BA  3033  	MOVLW 0x33
00BB  1283  	BCF STATUS, RP0
00BC  0085  	MOVWF gbl_porta


			break;

		}
		case 5:
0093  3A01  	XORLW 0x01
0094  1903  	BTFSC STATUS,Z
0095  28BE  	GOTO	label18
00BE        label18

		{
			//Output
			//Output: 0b01011011 -> PORTA
			trisa = 0x00;
00BE  1683  	BSF STATUS, RP0
00BF  0185  	CLRF gbl_trisa

			porta = (91);
00C0  305B  	MOVLW 0x5B
00C1  1283  	BCF STATUS, RP0
00C2  0085  	MOVWF gbl_porta


			break;

		}
		case 6:
0096  3A03  	XORLW 0x03
0097  1903  	BTFSC STATUS,Z
0098  28C4  	GOTO	label19
00C4        label19

		{
			//Output
			//Output: 0b01011111 -> PORTA
			trisa = 0x00;
00C4  1683  	BSF STATUS, RP0
00C5  0185  	CLRF gbl_trisa

			porta = (95);
00C6  305F  	MOVLW 0x5F
00C7  1283  	BCF STATUS, RP0
00C8  0085  	MOVWF gbl_porta


			break;

		}
		case 7:
0099  3A01  	XORLW 0x01
009A  1903  	BTFSC STATUS,Z
009B  28CA  	GOTO	label20
00CA        label20

		{
			//Output
			//Output: 0b01110000 -> PORTA
			trisa = 0x00;
00CA  1683  	BSF STATUS, RP0
00CB  0185  	CLRF gbl_trisa

			porta = (112);
00CC  3070  	MOVLW 0x70
00CD  1283  	BCF STATUS, RP0
00CE  0085  	MOVWF gbl_porta


			break;

		}
		case 8:
009C  3A0F  	XORLW 0x0F
009D  1903  	BTFSC STATUS,Z
009E  28D0  	GOTO	label21
00D0        label21

		{
			//Output
			//Output: 0b01111111 -> PORTA
			trisa = 0x00;
00D0  1683  	BSF STATUS, RP0
00D1  0185  	CLRF gbl_trisa

			porta = (127);
00D2  307F  	MOVLW 0x7F
00D3  1283  	BCF STATUS, RP0
00D4  0085  	MOVWF gbl_porta


			break;

		}
		case 9:
009F  3A01  	XORLW 0x01
00A0  1903  	BTFSC STATUS,Z
00A1  28D6  	GOTO	label22
00D6        label22

		{
			//Output
			//Output: 0b01111011 -> PORTA
			trisa = 0x00;
00D6  1683  	BSF STATUS, RP0
00D7  0185  	CLRF gbl_trisa

			porta = (123);
00D8  307B  	MOVLW 0x7B
00D9  1283  	BCF STATUS, RP0
00DA  0085  	MOVWF gbl_porta


			break;

		}
		case 0:
00A2  3A09  	XORLW 0x09
00A3  1903  	BTFSC STATUS,Z
00A4  28DC  	GOTO	label23
00DC        label23

		{
			//Output
			//Output: 0b01111110 -> PORTA
			trisa = 0x00;
00DC  1683  	BSF STATUS, RP0
00DD  0185  	CLRF gbl_trisa

			porta = (126);
00DE  307E  	MOVLW 0x7E
00DF  1283  	BCF STATUS, RP0
00E0  0085  	MOVWF gbl_porta


			break;

		}
		default:
00A5  28E2  	GOTO	label24
00E2        label24

		{
			//Output
			//Output: 0b00000001 -> PORTA
			trisa = 0x00;
00E2  1683  	BSF STATUS, RP0
00E3  0185  	CLRF gbl_trisa

			porta = (1);
00E4  3001  	MOVLW 0x01
00E5  1283  	BCF STATUS, RP0
00E6  0085  	MOVWF gbl_porta


		}
	}

}
00AB  0008  	RETURN
00B1  0008  	RETURN
00B7  0008  	RETURN
00BD  0008  	RETURN
00C3  0008  	RETURN
00C9  0008  	RETURN
00CF  0008  	RETURN
00D5  0008  	RETURN
00DB  0008  	RETURN
00E1  0008  	RETURN
00E7  0008  	RETURN



void FCM_display_temp()

{

	//Output
	//Output: 0 -> PORTA
	trisa = 0x00;
0232  1683  	BSF STATUS, RP0
0233  1303  	BCF STATUS, RP1
0234  0185  	CLRF gbl_trisa

	porta = (0);
0235  1283  	BCF STATUS, RP0
0236  0185  	CLRF gbl_porta


	//Call Macro
	//Call Macro: scan_off()
	FCM_scan_off();
0237  20E8  	CALL FCM_scan_o_0005A


	//Call Macro
	//Call Macro: scan1()
	FCM_scan1();
0238  2179  	CALL FCM_scan1_00000


	//Calculation
	//Calculation:
	//  digit = temp_tens
	FCV_DIGIT = FCV_TEMP_TENS;
0239  084B  	MOVF gbl_FCV_TEMP_TENS, W
023A  00D5  	MOVWF gbl_FCV_DIGIT


	//Call Macro
	//Call Macro: seg_pattern()
	FCM_seg_pattern();
023B  2084  	CALL FCM_seg_pa_00058


	//Delay
	//Delay: 5 us
	delay_us(5);
023C  3005  	MOVLW 0x05
023D  00DA  	MOVWF delay_us_00000_arg_del
023E  201C  	CALL delay_us_00000


	//Call Macro
	//Call Macro: 
	//No code generated because there is no macro name

	//Output
	//Output: 0 -> PORTA
	trisa = 0x00;
023F  1683  	BSF STATUS, RP0
0240  0185  	CLRF gbl_trisa

	porta = (0);
0241  1283  	BCF STATUS, RP0
0242  0185  	CLRF gbl_porta


	//Call Macro
	//Call Macro: scan_off()
	FCM_scan_off();
0243  20E8  	CALL FCM_scan_o_0005A


	//Call Macro
	//Call Macro: scan2()
	FCM_scan2();
0244  2154  	CALL FCM_scan2_00000


	//Calculation
	//Calculation:
	//  digit = temp_ones
	FCV_DIGIT = FCV_TEMP_ONES;
0245  0852  	MOVF gbl_FCV_TEMP_ONES, W
0246  00D5  	MOVWF gbl_FCV_DIGIT


	//Call Macro
	//Call Macro: seg_pattern()
	FCM_seg_pattern();
0247  2084  	CALL FCM_seg_pa_00058


	//Delay
	//Delay: 5 us
	delay_us(5);
0248  3005  	MOVLW 0x05
0249  00DA  	MOVWF delay_us_00000_arg_del
024A  201C  	CALL delay_us_00000


	//Output
	//Output: 0 -> PORTA
	trisa = 0x00;
024B  1683  	BSF STATUS, RP0
024C  0185  	CLRF gbl_trisa

	porta = (0);
024D  1283  	BCF STATUS, RP0
024E  0185  	CLRF gbl_porta


	//Call Macro
	//Call Macro: scan_off()
	FCM_scan_off();
024F  20E8  	CALL FCM_scan_o_0005A


	//Call Macro
	//Call Macro: scan3()
	FCM_scan3();
0250  212F  	CALL FCM_scan3_00000


	//Calculation
	//Calculation:
	//  digit = temp_dec
	FCV_DIGIT = FCV_TEMP_DEC;
0251  0851  	MOVF gbl_FCV_TEMP_DEC, W
0252  00D5  	MOVWF gbl_FCV_DIGIT


	//Call Macro
	//Call Macro: seg_pattern()
	FCM_seg_pattern();
0253  2084  	CALL FCM_seg_pa_00058


	//Delay
	//Delay: 5 us
	delay_us(5);
0254  3005  	MOVLW 0x05
0255  00DA  	MOVWF delay_us_00000_arg_del
0256  201C  	CALL delay_us_00000


	//Output
	//Output: 0 -> PORTA
	trisa = 0x00;
0257  1683  	BSF STATUS, RP0
0258  0185  	CLRF gbl_trisa

	porta = (0);
0259  1283  	BCF STATUS, RP0
025A  0185  	CLRF gbl_porta


	//Call Macro
	//Call Macro: scan_off()
	FCM_scan_off();
025B  20E8  	CALL FCM_scan_o_0005A


	//Call Macro
	//Call Macro: scan4()
	FCM_scan4();
025C  210A  	CALL FCM_scan4_00000


	//Output
	//Output: 0b01000011 -> PORTA
	trisa = 0x00;
025D  1683  	BSF STATUS, RP0
025E  0185  	CLRF gbl_trisa

	porta = (67);
025F  3043  	MOVLW 0x43
0260  1283  	BCF STATUS, RP0
0261  0085  	MOVWF gbl_porta


	//Delay
	//Delay: 5 us
	delay_us(5);
0262  3005  	MOVLW 0x05
0263  00DA  	MOVWF delay_us_00000_arg_del
0264  201C  	CALL delay_us_00000


}
0265  0008  	RETURN



void FCM_scan_off()

{

	//Output
	//Output: 0 -> B2
	trisb = trisb & 0xFB;
00E8  30FB  	MOVLW 0xFB
00E9  1683  	BSF STATUS, RP0
00EA  1303  	BCF STATUS, RP1
00EB  0506  	ANDWF gbl_trisb, W
00EC  0086  	MOVWF gbl_trisb

	if ((0))
		portb = (portb & 0xFB) | 0x04;
	else
		portb = portb & 0xFB;
00ED  30FB  	MOVLW 0xFB
00EE  1283  	BCF STATUS, RP0
00EF  0506  	ANDWF gbl_portb, W
00F0  0086  	MOVWF gbl_portb


	//Output
	//Output: 0 -> B3
	trisb = trisb & 0xF7;
00F1  30F7  	MOVLW 0xF7
00F2  1683  	BSF STATUS, RP0
00F3  0506  	ANDWF gbl_trisb, W
00F4  0086  	MOVWF gbl_trisb

	if ((0))
		portb = (portb & 0xF7) | 0x08;
	else
		portb = portb & 0xF7;
00F5  30F7  	MOVLW 0xF7
00F6  1283  	BCF STATUS, RP0
00F7  0506  	ANDWF gbl_portb, W
00F8  0086  	MOVWF gbl_portb


	//Output
	//Output: 0 -> B4
	trisb = trisb & 0xEF;
00F9  30EF  	MOVLW 0xEF
00FA  1683  	BSF STATUS, RP0
00FB  0506  	ANDWF gbl_trisb, W
00FC  0086  	MOVWF gbl_trisb

	if ((0))
		portb = (portb & 0xEF) | 0x10;
	else
		portb = portb & 0xEF;
00FD  30EF  	MOVLW 0xEF
00FE  1283  	BCF STATUS, RP0
00FF  0506  	ANDWF gbl_portb, W
0100  0086  	MOVWF gbl_portb


	//Output
	//Output: 0 -> B5
	trisb = trisb & 0xDF;
0101  30DF  	MOVLW 0xDF
0102  1683  	BSF STATUS, RP0
0103  0506  	ANDWF gbl_trisb, W
0104  0086  	MOVWF gbl_trisb

	if ((0))
		portb = (portb & 0xDF) | 0x20;
	else
		portb = portb & 0xDF;
0105  30DF  	MOVLW 0xDF
0106  1283  	BCF STATUS, RP0
0107  0506  	ANDWF gbl_portb, W
0108  0086  	MOVWF gbl_portb


}
0109  0008  	RETURN




void main()

{
	//Initialization
	ansel = 0;
0268  1683  	BSF STATUS, RP0
0269  1703  	BSF STATUS, RP1
026A  0188  	CLRF gbl_ansel

anselh = 0;
026B  0189  	CLRF gbl_anselh



	//Interrupt initialization code
	option_reg = 0xC0;
026C  30C0  	MOVLW 0xC0
026D  1303  	BCF STATUS, RP1
026E  0081  	MOVWF gbl_option_reg



	//Calculation
	//Calculation:
	//  data0 = 123
	//  data1 = 0xff
	//  data2 = 0xff
	//  lsb = 0x00
	//  msb = 0x00
	FCV_DATA0 = 123;
026F  307B  	MOVLW 0x7B
0270  1283  	BCF STATUS, RP0
0271  00CC  	MOVWF gbl_FCV_DATA0

	FCV_DATA1 = 0xff;
0272  30FF  	MOVLW 0xFF
0273  00CE  	MOVWF gbl_FCV_DATA1

	FCV_DATA2 = 0xff;
0274  00CF  	MOVWF gbl_FCV_DATA2

	FCV_LSB = 0x00;
0275  01D4  	CLRF gbl_FCV_LSB

	FCV_MSB = 0x00;
0276  01D6  	CLRF gbl_FCV_MSB


	//Calculation
	//Calculation:
	//  temp_tens = 1
	//  temp_ones = 2
	//  temp_dec = 3
	FCV_TEMP_TENS = 1;
0277  3001  	MOVLW 0x01
0278  00CB  	MOVWF gbl_FCV_TEMP_TENS

	FCV_TEMP_ONES = 2;
0279  3002  	MOVLW 0x02
027A  00D2  	MOVWF gbl_FCV_TEMP_ONES

	FCV_TEMP_DEC = 3;
027B  3003  	MOVLW 0x03
027C  00D1  	MOVWF gbl_FCV_TEMP_DEC


	//Call Macro
	//Call Macro: intro()
	FCM_intro();
027D  21EE  	CALL FCM_intro_00000


	//Call Component Macro
	//Call Component Macro: MI2C_Init()
	FCD_I2C_Master0_MI2C_Init();
027E  2266  	CALL FCD_I2C_Ma_00062


	//Loop
	//Loop: While 1
	while (1)
027F        label30

	{

		//Call Macro
		//Call Macro: i2c_comm()
		FCM_i2c_comm();
027F  2205  	CALL FCM_i2c_co_00051


		//Calculation
		//Calculation:
		//  temp_tens = data0 / 100
		//  temp_ones = (data0 / 10) % 10
		//  temp_dec = data0 % 10
		FCV_TEMP_TENS = FCV_DATA0 / 100;
0280  084C  	MOVF gbl_FCV_DATA0, W
0281  00DA  	MOVWF __div_8_8_00000_arg_a
0282  3064  	MOVLW 0x64
0283  00DB  	MOVWF __div_8_8_00000_arg_b
0284  21DD  	CALL __div_8_8_00000
0285  0860  	MOVF CompTempVarRet218, W
0286  00CB  	MOVWF gbl_FCV_TEMP_TENS

		FCV_TEMP_ONES = (FCV_DATA0 / 10) % 10;
0287  084C  	MOVF gbl_FCV_DATA0, W
0288  00DA  	MOVWF __div_8_8_00000_arg_a
0289  300A  	MOVLW 0x0A
028A  00DB  	MOVWF __div_8_8_00000_arg_b
028B  21DD  	CALL __div_8_8_00000
028C  0860  	MOVF CompTempVarRet218, W
028D  00DC  	MOVWF __rem_8_8_00000_arg_a
028E  300A  	MOVLW 0x0A
028F  00DD  	MOVWF __rem_8_8_00000_arg_b
0290  21CC  	CALL __rem_8_8_00000
0291  0860  	MOVF CompTempVarRet220, W
0292  00D2  	MOVWF gbl_FCV_TEMP_ONES

		FCV_TEMP_DEC = FCV_DATA0 % 10;
0293  084C  	MOVF gbl_FCV_DATA0, W
0294  00DC  	MOVWF __rem_8_8_00000_arg_a
0295  300A  	MOVLW 0x0A
0296  00DD  	MOVWF __rem_8_8_00000_arg_b
0297  21CC  	CALL __rem_8_8_00000
0298  0860  	MOVF CompTempVarRet220, W
0299  00D1  	MOVWF gbl_FCV_TEMP_DEC


		//Loop
		//Loop: Loop 200 times
		for (FCLV_LOOP1=0; FCLV_LOOP1<200; FCLV_LOOP1++)
029A  01D8  	CLRF gbl_FCLV_LOOP1
029B        label31
029B  30C8  	MOVLW 0xC8
029C  0258  	SUBWF gbl_FCLV_LOOP1, W
029D  1803  	BTFSC STATUS,C
029E  2A7F  	GOTO	label30
02A0  0AD8  	INCF gbl_FCLV_LOOP1, F
02A1  2A9B  	GOTO	label31

		{

			//Call Macro
			//Call Macro: display_temp()
			FCM_display_temp();
029F  2232  	CALL FCM_displa_00059



		}


	}

	mainendloop: goto mainendloop;
}


void MX_INTERRUPT_MACRO(void)

{
}
02E4  1283  	BCF STATUS, RP0
02E5  1303  	BCF STATUS, RP1
02E6  0E3E  	SWAPF Int1BContext+D'2', W
02E7  0084  	MOVWF FSR
02E8  0E3D  	SWAPF Int1BContext+D'1', W
02E9  008A  	MOVWF PCLATH
02EA  0E3C  	SWAPF Int1BContext, W
02EB  0083  	MOVWF STATUS
02EC  0EFF  	SWAPF Int1Context, F
02ED  0E7F  	SWAPF Int1Context, W
02EE  0009  	RETFIE





/*********************************************************************
 *                  Flowcode CAL I2C File
 *
 * File: PIC_CAL_I2C.c
 *
 * (c) 2011 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * “Company”) for its Flowcode graphical programming language is
 * intended and supplied to you, the Company’s customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 210911 | BR | Created
 * 021211 | BR | Converted to new dynamic defines mechanism
 *
 */


//When using hardware I2C channels override port and pin conns with FCD conn definitions
#ifdef MX_I2C_REF1
	#if MX_I2C_CHANNEL_1 > 0
		#undef MX_I2C_SDA_PIN_1
		#undef MX_I2C_SDA_PORT_1
		#undef MX_I2C_SDA_TRIS_1
		#undef MX_I2C_SCL_PIN_1
		#undef MX_I2C_SCL_PORT_1
		#undef MX_I2C_SCL_TRIS_1
	#endif
	#if MX_I2C_CHANNEL_1 == 1
		#define MX_I2C_SDA_PIN_1		MX_I2C_1_SDA_PIN
		#define MX_I2C_SDA_PORT_1		MX_I2C_1_SDA_PORT
		#define MX_I2C_SDA_TRIS_1		MX_I2C_1_SDA_TRIS
		#define MX_I2C_SCL_PIN_1		MX_I2C_1_SCL_PIN
		#define MX_I2C_SCL_PORT_1		MX_I2C_1_SCL_PORT
		#define MX_I2C_SCL_TRIS_1		MX_I2C_1_SCL_TRIS
	#endif
	#if MX_I2C_CHANNEL_1 == 2
		#define MX_I2C_SDA_PIN_1		MX_I2C_2_SDA_PIN
		#define MX_I2C_SDA_PORT_1		MX_I2C_2_SDA_PORT
		#define MX_I2C_SDA_TRIS_1		MX_I2C_2_SDA_TRIS
		#define MX_I2C_SCL_PIN_1		MX_I2C_2_SCL_PIN
		#define MX_I2C_SCL_PORT_1		MX_I2C_2_SCL_PORT
		#define MX_I2C_SCL_TRIS_1		MX_I2C_2_SCL_TRIS
	#endif
	#if MX_I2C_CHANNEL_1 == 3
		#define MX_I2C_SDA_PIN_1		MX_I2C_3_SDA_PIN
		#define MX_I2C_SDA_PORT_1		MX_I2C_3_SDA_PORT
		#define MX_I2C_SDA_TRIS_1		MX_I2C_3_SDA_TRIS
		#define MX_I2C_SCL_PIN_1		MX_I2C_3_SCL_PIN
		#define MX_I2C_SCL_PORT_1		MX_I2C_3_SCL_PORT
		#define MX_I2C_SCL_TRIS_1		MX_I2C_3_SCL_TRIS
	#endif
	#if MX_I2C_CHANNEL_1 == 4
		#define MX_I2C_SDA_PIN_1		MX_I2C_4_SDA_PIN
		#define MX_I2C_SDA_PORT_1		MX_I2C_4_SDA_PORT
		#define MX_I2C_SDA_TRIS_1		MX_I2C_4_SDA_TRIS
		#define MX_I2C_SCL_PIN_1		MX_I2C_4_SCL_PIN
		#define MX_I2C_SCL_PORT_1		MX_I2C_4_SCL_PORT
		#define MX_I2C_SCL_TRIS_1		MX_I2C_4_SCL_TRIS
	#endif
#endif
#ifdef MX_I2C_REF2
	#if MX_I2C_CHANNEL_2 > 0
		#undef MX_I2C_SDA_PIN_2
		#undef MX_I2C_SDA_PORT_2
		#undef MX_I2C_SDA_TRIS_2
		#undef MX_I2C_SCL_PIN_2
		#undef MX_I2C_SCL_PORT_2
		#undef MX_I2C_SCL_TRIS_2
	#endif
	#if MX_I2C_CHANNEL_2 == 1
		#define MX_I2C_SDA_PIN_2		MX_I2C_1_SDA_PIN
		#define MX_I2C_SDA_PORT_2		MX_I2C_1_SDA_PORT
		#define MX_I2C_SDA_TRIS_2		MX_I2C_1_SDA_TRIS
		#define MX_I2C_SCL_PIN_2		MX_I2C_1_SCL_PIN
		#define MX_I2C_SCL_PORT_2		MX_I2C_1_SCL_PORT
		#define MX_I2C_SCL_TRIS_2		MX_I2C_1_SCL_TRIS
	#endif
	#if MX_I2C_CHANNEL_2 == 2
		#define MX_I2C_SDA_PIN_2		MX_I2C_2_SDA_PIN
		#define MX_I2C_SDA_PORT_2		MX_I2C_2_SDA_PORT
		#define MX_I2C_SDA_TRIS_2		MX_I2C_2_SDA_TRIS
		#define MX_I2C_SCL_PIN_2		MX_I2C_2_SCL_PIN
		#define MX_I2C_SCL_PORT_2		MX_I2C_2_SCL_PORT
		#define MX_I2C_SCL_TRIS_2		MX_I2C_2_SCL_TRIS
	#endif
	#if MX_I2C_CHANNEL_2 == 3
		#define MX_I2C_SDA_PIN_2		MX_I2C_3_SDA_PIN
		#define MX_I2C_SDA_PORT_2		MX_I2C_3_SDA_PORT
		#define MX_I2C_SDA_TRIS_2		MX_I2C_3_SDA_TRIS
		#define MX_I2C_SCL_PIN_2		MX_I2C_3_SCL_PIN
		#define MX_I2C_SCL_PORT_2		MX_I2C_3_SCL_PORT
		#define MX_I2C_SCL_TRIS_2		MX_I2C_3_SCL_TRIS
	#endif
	#if MX_I2C_CHANNEL_2 == 4
		#define MX_I2C_SDA_PIN_2		MX_I2C_4_SDA_PIN
		#define MX_I2C_SDA_PORT_2		MX_I2C_4_SDA_PORT
		#define MX_I2C_SDA_TRIS_2		MX_I2C_4_SDA_TRIS
		#define MX_I2C_SCL_PIN_2		MX_I2C_4_SCL_PIN
		#define MX_I2C_SCL_PORT_2		MX_I2C_4_SCL_PORT
		#define MX_I2C_SCL_TRIS_2		MX_I2C_4_SCL_TRIS
	#endif
#endif
#ifdef MX_I2C_REF3
	#if MX_I2C_CHANNEL_3 > 0
		#undef MX_I2C_SDA_PIN_3
		#undef MX_I2C_SDA_PORT_3
		#undef MX_I2C_SDA_TRIS_3
		#undef MX_I2C_SCL_PIN_3
		#undef MX_I2C_SCL_PORT_3
		#undef MX_I2C_SCL_TRIS_3
	#endif
	#if MX_I2C_CHANNEL_3 == 1
		#define MX_I2C_SDA_PIN_3		MX_I2C_1_SDA_PIN
		#define MX_I2C_SDA_PORT_3		MX_I2C_1_SDA_PORT
		#define MX_I2C_SDA_TRIS_3		MX_I2C_1_SDA_TRIS
		#define MX_I2C_SCL_PIN_3		MX_I2C_1_SCL_PIN
		#define MX_I2C_SCL_PORT_3		MX_I2C_1_SCL_PORT
		#define MX_I2C_SCL_TRIS_3		MX_I2C_1_SCL_TRIS
	#endif
	#if MX_I2C_CHANNEL_3 == 2
		#define MX_I2C_SDA_PIN_3		MX_I2C_2_SDA_PIN
		#define MX_I2C_SDA_PORT_3		MX_I2C_2_SDA_PORT
		#define MX_I2C_SDA_TRIS_3		MX_I2C_2_SDA_TRIS
		#define MX_I2C_SCL_PIN_3		MX_I2C_2_SCL_PIN
		#define MX_I2C_SCL_PORT_3		MX_I2C_2_SCL_PORT
		#define MX_I2C_SCL_TRIS_3		MX_I2C_2_SCL_TRIS
	#endif
	#if MX_I2C_CHANNEL_3 == 3
		#define MX_I2C_SDA_PIN_3		MX_I2C_3_SDA_PIN
		#define MX_I2C_SDA_PORT_3		MX_I2C_3_SDA_PORT
		#define MX_I2C_SDA_TRIS_3		MX_I2C_3_SDA_TRIS
		#define MX_I2C_SCL_PIN_3		MX_I2C_3_SCL_PIN
		#define MX_I2C_SCL_PORT_3		MX_I2C_3_SCL_PORT
		#define MX_I2C_SCL_TRIS_3		MX_I2C_3_SCL_TRIS
	#endif
	#if MX_I2C_CHANNEL_3 == 4
		#define MX_I2C_SDA_PIN_3		MX_I2C_4_SDA_PIN
		#define MX_I2C_SDA_PORT_3		MX_I2C_4_SDA_PORT
		#define MX_I2C_SDA_TRIS_3		MX_I2C_4_SDA_TRIS
		#define MX_I2C_SCL_PIN_3		MX_I2C_4_SCL_PIN
		#define MX_I2C_SCL_PORT_3		MX_I2C_4_SCL_PORT
		#define MX_I2C_SCL_TRIS_3		MX_I2C_4_SCL_TRIS
	#endif
#endif
#ifdef MX_I2C_REF4
	#if MX_I2C_CHANNEL_4 > 0
		#undef MX_I2C_SDA_PIN_4
		#undef MX_I2C_SDA_PORT_4
		#undef MX_I2C_SDA_TRIS_4
		#undef MX_I2C_SCL_PIN_4
		#undef MX_I2C_SCL_PORT_4
		#undef MX_I2C_SCL_TRIS_4
	#endif
	#if MX_I2C_CHANNEL_4 == 1
		#define MX_I2C_SDA_PIN_4		MX_I2C_1_SDA_PIN
		#define MX_I2C_SDA_PORT_4		MX_I2C_1_SDA_PORT
		#define MX_I2C_SDA_TRIS_4		MX_I2C_1_SDA_TRIS
		#define MX_I2C_SCL_PIN_4		MX_I2C_1_SCL_PIN
		#define MX_I2C_SCL_PORT_4		MX_I2C_1_SCL_PORT
		#define MX_I2C_SCL_TRIS_4		MX_I2C_1_SCL_TRIS
	#endif
	#if MX_I2C_CHANNEL_4 == 2
		#define MX_I2C_SDA_PIN_4		MX_I2C_2_SDA_PIN
		#define MX_I2C_SDA_PORT_4		MX_I2C_2_SDA_PORT
		#define MX_I2C_SDA_TRIS_4		MX_I2C_2_SDA_TRIS
		#define MX_I2C_SCL_PIN_4		MX_I2C_2_SCL_PIN
		#define MX_I2C_SCL_PORT_4		MX_I2C_2_SCL_PORT
		#define MX_I2C_SCL_TRIS_4		MX_I2C_2_SCL_TRIS
	#endif
	#if MX_I2C_CHANNEL_4 == 3
		#define MX_I2C_SDA_PIN_4		MX_I2C_3_SDA_PIN
		#define MX_I2C_SDA_PORT_4		MX_I2C_3_SDA_PORT
		#define MX_I2C_SDA_TRIS_4		MX_I2C_3_SDA_TRIS
		#define MX_I2C_SCL_PIN_4		MX_I2C_3_SCL_PIN
		#define MX_I2C_SCL_PORT_4		MX_I2C_3_SCL_PORT
		#define MX_I2C_SCL_TRIS_4		MX_I2C_3_SCL_TRIS
	#endif
	#if MX_I2C_CHANNEL_4 == 4
		#define MX_I2C_SDA_PIN_4		MX_I2C_4_SDA_PIN
		#define MX_I2C_SDA_PORT_4		MX_I2C_4_SDA_PORT
		#define MX_I2C_SDA_TRIS_4		MX_I2C_4_SDA_TRIS
		#define MX_I2C_SCL_PIN_4		MX_I2C_4_SCL_PIN
		#define MX_I2C_SCL_PORT_4		MX_I2C_4_SCL_PORT
		#define MX_I2C_SCL_TRIS_4		MX_I2C_4_SCL_TRIS
	#endif
#endif

#define MX_I2C_CHANNEL_X		CAL_APPEND(MX_I2C_CHANNEL_, MX_I2C_NUM)
#define MX_I2C_SDA_PIN_X		CAL_APPEND(MX_I2C_SDA_PIN_, MX_I2C_NUM)
#define MX_I2C_SDA_PORT_X		CAL_APPEND(MX_I2C_SDA_PORT_, MX_I2C_NUM)
#define MX_I2C_SDA_TRIS_X		CAL_APPEND(MX_I2C_SDA_TRIS_, MX_I2C_NUM)
#define MX_I2C_SCL_PIN_X		CAL_APPEND(MX_I2C_SCL_PIN_, MX_I2C_NUM)
#define MX_I2C_SCL_PORT_X		CAL_APPEND(MX_I2C_SCL_PORT_, MX_I2C_NUM)
#define MX_I2C_SCL_TRIS_X		CAL_APPEND(MX_I2C_SCL_TRIS_, MX_I2C_NUM)
#define MX_I2C_BMODE_X			CAL_APPEND(MX_I2C_BMODE_, MX_I2C_NUM)
#define MX_I2C_BAUD_X			CAL_APPEND(MX_I2C_BAUD_, MX_I2C_NUM)
#define MX_I2C_INT_X			CAL_APPEND(MX_I2C_INT_, MX_I2C_NUM)


//Function Prototypes
CALFUNCTION(void, FC_CAL_I2C_Master_Init_, (void));
CALFUNCTION(void, FC_CAL_I2C_Master_Uninit_, (void));
CALFUNCTION(void, FC_CAL_I2C_Master_Start_, (void));
CALFUNCTION(void, FC_CAL_I2C_Master_Restart_, (void));
CALFUNCTION(void, FC_CAL_I2C_Master_Stop_, (void));
CALFUNCTION(MX_UINT8, FC_CAL_I2C_Master_TX_Byte_, (MX_UINT8 Data));
CALFUNCTION(MX_UINT8, FC_CAL_I2C_Master_RX_Byte_, (MX_UINT8 Last));

CALFUNCTION(void, FC_CAL_I2C_Slave_Init_, (void));
CALFUNCTION(void, FC_CAL_I2C_Slave_Uninit_, (void));
CALFUNCTION(void, FC_CAL_I2C_Slave_SetTxData_, (MX_UINT8 Data));
CALFUNCTION(MX_UINT8, FC_CAL_I2C_Slave_GetRxData_, (MX_UINT8 Last));


//Ensure SSPCON register is defined correctly
#ifndef SSPCON
  #ifdef SSPCON1
	#define sspcon	sspcon1
  #else
	#ifdef SSP1CON1
		#define sspcon	ssp1con1
	#endif
  #endif
#endif

//Ensure SSPIF register is defined correctly
#ifndef SSPIF
  #ifdef SSP1IF
	#define SSPIF	SSP1IF
  #else
	#error "I2C does not have the SSPIF defined on this chip - does your chip support this feature?"
  #endif
#endif


//Ensure SSPCON2 register is defined correctly
#ifndef SSPCON2
  #ifdef SSP1CON2
	#define sspcon2	ssp1con2
  #endif
#endif


//Ensure SSPSTAT register is defined correctly
#ifndef SSPSTAT
  #ifdef SSP1STAT
	#define sspstat	ssp1stat
  #endif
#endif


//Ensure SSPADD register is defined correctly
#ifndef SSPADD
  #ifdef SSP1ADD
	#define sspadd	ssp1add
  #endif
#endif


//Ensure SSPBUFF register is defined correctly
#ifndef SSPBUFF
  #ifdef SSP1BUFF
	#define sspbuff	ssp1buff
  #endif
#endif


//If software channel is enabled then define bit delay.
#if (MX_I2C_CHANNEL_X == 0)
  #ifndef MX_I2C_SW_DEL
	#define MX_I2C_SW_DEL
	#define MX_I2C_DELAY	delay_us(20);
  #endif
#endif


CALFUNCTION(void, FC_CAL_I2C_Master_Init_, (void))

{

	#if (MX_I2C_CHANNEL_X == 0)															//Use Master I2C Software
		FC_CAL_Bit_In_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);		//Configure SDA as Input
		FC_CAL_Bit_In_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);		//Configure SCL as Input
	#endif

	#if (MX_I2C_CHANNEL_X == 1)												//Use Master I2C Hardware 1
		#ifndef MX_MI2C
			#error "This chip does not have Master I2C capability"
		#else

			#ifndef MX_I2C_1
				#error "This chip does not have Master I2C channel 1"
			#endif

			#if (MX_I2C_BMODE_X & 0x01)
				cr_bit (sspstat,SMP);										//Slew Rate Control Enabled
			#else
				st_bit (sspstat,SMP);										//Slew Rate Control Disabled
0075  1683  	BSF STATUS, RP0
0076  1303  	BCF STATUS, RP1
0077  1794  	BSF gbl_sspstat,7

		    #endif

			#if (MX_I2C_BMODE_X & 0x02)
				st_bit (sspstat,CKE);										//Enable SMBus specific inputs
			#else
				cr_bit (sspstat,CKE);										//Disable SMBus specific inputs
0078  1314  	BCF gbl_sspstat,6

			#endif

			sspcon = 0x28;													//Setup I2C into Master Mode
0079  3028  	MOVLW 0x28
007A  1283  	BCF STATUS, RP0
007B  0094  	MOVWF gbl_sspcon

			sspadd = MX_I2C_BAUD_X;											//Set the Baud Rate
007C  3040  	MOVLW 0x40
007D  1683  	BSF STATUS, RP0
007E  0093  	MOVWF gbl_sspadd

			sspcon2 = 0x00;													//Clear the control bits
007F  0191  	CLRF gbl_sspcon2

			st_bit(intcon, GIE);
0080  178B  	BSF gbl_intcon,7

			FC_CAL_Bit_In_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);		//Configure SDA as Input
0081  1607  	BSF gbl_trisc,4

			FC_CAL_Bit_In_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);		//Configure SCL as Input
0082  1587  	BSF gbl_trisc,3

		#endif
	#endif

	#if (MX_I2C_CHANNEL_X == 2)												//Use Master I2C Hardware 2
		#ifndef MX_MI2C
			#error "This chip does not have Master I2C capability"
		#else

			#ifndef MX_I2C_2
				#error "This chip does not have Master I2C channel 2"
			#endif

		  #ifdef MX_I2C_2_REMAPPABLE
			RPOR4 = 9;														//SDA2 - RB1 - RP4
			RPOR5 = 10;														//SCL2 - RB2 - RP5
		  #endif

			#if (MX_I2C_BMODE_X & 0x01)
				cr_bit (ssp2stat,SMP);										//Slew Rate Control Enabled
			#else
				st_bit (ssp2stat,SMP);										//Slew Rate Control Disabled
			#endif

			#if (MX_I2C_BMODE_X & 0x02)
				st_bit (ssp2stat,CKE);										//Enable SMBus specific inputs
			#else
				cr_bit (ssp2stat,CKE);										//Disable SMBus specific inputs
			#endif

			ssp2con = 0x28;													//Setup I2C into Master Mode
			ssp2add = MX_I2C_BAUD_X;										//Set the Baud Rate
			ssp2con2 = 0x00;												//Clear the control bits
			st_bit(intcon, GIE);
			FC_CAL_Bit_In_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);			//Configure SDA as Input
			FC_CAL_Bit_In_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);			//Configure SCL as Input
		#endif
	#endif
}
0083  0008  	RETURN


CALFUNCTION(void, FC_CAL_I2C_Master_Uninit_, (void))
{
	#if (MX_I2C_CHANNEL_X == 0)																//Use Master I2C Software
		FC_CAL_Bit_In_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);			//Configure SDA as Input
		FC_CAL_Bit_In_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);			//Configure SCL as Input
	#endif

	#if (MX_I2C_CHANNEL_X == 1)												//Use Master I2C Hardware 1
		cr_bit(sspcon, SSPEN);												//Disable SSP
	#endif

	#if (MX_I2C_CHANNEL_X == 2)												//Use Master I2C Hardware 2
		cr_bit(ssp2con, SSPEN);												//Disable SSP
	#endif
}

CALFUNCTION(void, FC_CAL_I2C_Master_Start_, (void))

{
	#if (MX_I2C_CHANNEL_X == 0)															//Use Master I2C Software
		FC_CAL_Bit_In_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);		//Make Sure SCL is Set
		FC_CAL_Bit_In_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);		//Make Sure SDA is Set
		MX_I2C_DELAY;																	//Small Delay
		FC_CAL_Bit_Low_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);		//Clear SDA
		MX_I2C_DELAY;																	//Small Delay
		FC_CAL_Bit_Low_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);		//Clear SCL
		MX_I2C_DELAY;																	//Small Delay
	#endif

	#if (MX_I2C_CHANNEL_X == 1)												//Use Master I2C Hardware 1
		cr_bit(pir1, SSPIF);												//Clear SSP interrupt flag
006D  1283  	BCF STATUS, RP0
006E  1303  	BCF STATUS, RP1
006F  118C  	BCF gbl_pir1,3

		st_bit(sspcon2,SEN);												//Initiate start condition
0070  1683  	BSF STATUS, RP0
0071  1411  	BSF gbl_sspcon2,0

		while(ts_bit(sspcon2,SEN));											//Wait for start bit to be generated
0072        label13
0072  1811  	BTFSC gbl_sspcon2,0
0073  2872  	GOTO	label13

	#endif

	#if (MX_I2C_CHANNEL_X == 2)												//Use Master I2C Hardware 2
		cr_bit(pir3, SSP2IF);												//Clear SSP interrupt flag
		st_bit(ssp2con2,SEN);												//Initiate start condition
		while(ts_bit(ssp2con2,SEN));										//Wait for start bit to be generated
	#endif
}
0074  0008  	RETURN


CALFUNCTION(void, FC_CAL_I2C_Master_Restart_, (void))

{
	#if (MX_I2C_CHANNEL_X == 0)															//Use Master I2C Software
		FC_CAL_Bit_In_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);		//Set SDA High
		MX_I2C_DELAY;
		FC_CAL_Bit_In_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);		//Set SCL High
		MX_I2C_DELAY;
		FC_CAL_Bit_Low_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);		//Set SDA Low
		MX_I2C_DELAY;
		FC_CAL_Bit_Low_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);		//Set SCL Low
		MX_I2C_DELAY;
	#endif

	#if (MX_I2C_CHANNEL_X == 1)												//Use Master I2C Hardware 1
		cr_bit(pir1, SSPIF);												//Clear SSP interrupt flag
0065  1283  	BCF STATUS, RP0
0066  1303  	BCF STATUS, RP1
0067  118C  	BCF gbl_pir1,3

		st_bit(sspcon2,RSEN);												//Initiate restart condition
0068  1683  	BSF STATUS, RP0
0069  1491  	BSF gbl_sspcon2,1

		while(ts_bit(sspcon2,RSEN));										//Wait for restart bit to be generated
006A        label12
006A  1891  	BTFSC gbl_sspcon2,1
006B  286A  	GOTO	label12

	#endif

	#if (MX_I2C_CHANNEL_X == 2)												//Use Master I2C Hardware 2
		cr_bit(pir3, SSP2IF);												//Clear SSP interrupt flag
		st_bit(ssp2con2,RSEN);												//Initiate restart condition
		while(ts_bit(ssp2con2,RSEN));										//Wait for restart bit to be generated
	#endif
}
006C  0008  	RETURN


CALFUNCTION(void, FC_CAL_I2C_Master_Stop_, (void))

{
	#if (MX_I2C_CHANNEL_X == 0)															//Use Master I2C Software
		FC_CAL_Bit_Low_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);		//Set SCL Low
		FC_CAL_Bit_Low_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);		//Set SDA Low
		MX_I2C_DELAY;
		FC_CAL_Bit_In_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);		//Set SCL High
		MX_I2C_DELAY;
		FC_CAL_Bit_In_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);		//Set SDA High
	#endif

	#if (MX_I2C_CHANNEL_X == 1)												//Use Master I2C Hardware 1
		cr_bit(pir1,SSPIF);													//Clear SSP interrupt flag
0059  1283  	BCF STATUS, RP0
005A  1303  	BCF STATUS, RP1
005B  118C  	BCF gbl_pir1,3

		st_bit(sspcon2,PEN);												//Initiate stop condition
005C  1683  	BSF STATUS, RP0
005D  1511  	BSF gbl_sspcon2,2

		while(ts_bit(sspcon2,PEN));											//Wait for stop bit to be generated
005E        label11
005E  1911  	BTFSC gbl_sspcon2,2
005F  285E  	GOTO	label11

	#endif

	#if (MX_I2C_CHANNEL_X == 2)												//Use Master I2C Hardware 2
		cr_bit(pir3,SSP2IF);												//Clear SSP interrupt flag
		st_bit(ssp2con2,PEN);												//Initiate stop condition
		while(ts_bit(ssp2con2,PEN));										//Wait for stop bit to be generated
	#endif

  delay_ms(10);																//Wait before reusing the I2C BUS
0060  300A  	MOVLW 0x0A
0061  1283  	BCF STATUS, RP0
0062  00DB  	MOVWF delay_ms_00000_arg_del
0063  2010  	CALL delay_ms_00000

}
0064  0008  	RETURN


CALFUNCTION(MX_UINT8, FC_CAL_I2C_Master_TX_Byte_, (MX_UINT8 Data))

{
	#if (MX_I2C_CHANNEL_X == 0)												//Use Master I2C Software
		char bit_mask;
		char local_ack = 0;
		for(bit_mask=0x80;bit_mask;bit_mask=bit_mask>>1)
		{
			if(Data & bit_mask)
			{
				FC_CAL_Bit_In_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);	//Set SDA High
			}
			else
			{
				FC_CAL_Bit_Low_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);	//Set SDA Low
			}
			MX_I2C_DELAY;
			FC_CAL_Bit_In_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);		//Set SCL High
			MX_I2C_DELAY;
			FC_CAL_Bit_Low_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);		//Set SCL Low
			MX_I2C_DELAY;
		}
		FC_CAL_Bit_In_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);			//Set SDA High
		MX_I2C_DELAY;
		FC_CAL_Bit_In_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);			//Set SCL High
		MX_I2C_DELAY;
		FC_CAL_Bit_In_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);
		if (FC_CAL_Bit_In(MX_I2C_SDA_PORT_X, MX_I2C_SDA_PIN_X))		//Get the Status Bit
			local_ack = 1;
		MX_I2C_DELAY;
		FC_CAL_Bit_Low_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);			//Set SCL Low
		MX_I2C_DELAY;
		return (local_ack);													//0 = Ack received : 1 = Ack not received
	#endif

	#if (MX_I2C_CHANNEL_X == 1)												//Use Master I2C Hardware 1
		cr_bit(pir1,SSPIF);													//Clear SSP interrupt flag
004A  118C  	BCF gbl_pir1,3

		sspbuf=Data;														//Send byte
004B  085B  	MOVF FC_CAL_I2C_00060_arg_Data, W
004C  0093  	MOVWF gbl_sspbuf

		while(ts_bit(pir1,SSPIF) == 0);										//Wait for control bit to be sent
004D        label9
004D  1D8C  	BTFSS gbl_pir1,3
004E  284D  	GOTO	label9

		if(ts_bit(sspcon2,ACKSTAT))											//Check Acknowledgement
004F  1683  	BSF STATUS, RP0
0050  1F11  	BTFSS gbl_sspcon2,6
0051  2856  	GOTO	label10
0056        label10

			return (1);														//No Acknowledgement
0052  3001  	MOVLW 0x01
0053  1283  	BCF STATUS, RP0
0054  00DC  	MOVWF CompTempVarRet2202

		else return (0);													//Acknowledgement received
0056  1283  	BCF STATUS, RP0
0057  01DC  	CLRF CompTempVarRet2202

	#endif

	#if (MX_I2C_CHANNEL_X == 2)												//Use Master I2C Hardware 2
		cr_bit(pir3,SSP2IF);												//Clear SSP interrupt flag
		ssp2buf=Data;														//Send byte
		while(ts_bit(pir3,SSP2IF) == 0);									//Wait for control bit to be sent
		if(ts_bit(ssp2con2,ACKSTAT))										//Check Acknowledgement
			return (1);														//No Acknowledgement
		else return (0);													//Acknowledgement received
	#endif
}
0055  0008  	RETURN
0058  0008  	RETURN


CALFUNCTION(MX_UINT8, FC_CAL_I2C_Master_RX_Byte_, (MX_UINT8 Last))

{
	#if (MX_I2C_CHANNEL_X == 0)												//Use Master I2C Software
		char bit_mask;
		char Data = 0;
		char local_ack;
		FC_CAL_Bit_In_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);			//Set SDA High
		MX_I2C_DELAY;
		for(bit_mask=0x80;bit_mask;bit_mask=bit_mask>>1)
		{
			FC_CAL_Bit_In_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);		//Set SCL High
			MX_I2C_DELAY;
			FC_CAL_Bit_In_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);
			if(FC_CAL_Bit_In(MX_I2C_SDA_PORT_X, MX_I2C_SDA_PIN_X))	//Read Incoming Bit
				Data = Data | bit_mask;														//Add data to variable
			FC_CAL_Bit_Low_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);		//Set SCL Low
			MX_I2C_DELAY;
		}
		if (Last)																		//Acknowledge?
		{
			FC_CAL_Bit_In_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);	//Send Nack
		}
		else
		{
			FC_CAL_Bit_Low_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);	//Send Ack
		}
		MX_I2C_DELAY;
		FC_CAL_Bit_In_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);		//Set SCL High
		MX_I2C_DELAY;
		FC_CAL_Bit_Low_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);		//Set SCL Low
		MX_I2C_DELAY;
		return (Data);
	#endif

	#if (MX_I2C_CHANNEL_X == 1)						//Use Master I2C Hardware 1
		cr_bit(pir1,SSPIF);							//Clear SSP interrupt flag
0035  118C  	BCF gbl_pir1,3

		st_bit(sspcon2,RCEN);						//Initiate Read
0036  1683  	BSF STATUS, RP0
0037  1591  	BSF gbl_sspcon2,3

		while(ts_bit(pir1,3) == 0);					//Wait for data read
0038        label5
0038  1283  	BCF STATUS, RP0
0039  1D8C  	BTFSS gbl_pir1,3
003A  2838  	GOTO	label5

		if (Last)
003B  08DB  	MOVF FC_CAL_I2C_00061_arg_Last, F
003C  1903  	BTFSC STATUS,Z
003D  2841  	GOTO	label6
0041        label6

			st_bit(sspcon2,ACKDT);					//Send Nack
003E  1683  	BSF STATUS, RP0
003F  1691  	BSF gbl_sspcon2,5

		else cr_bit(sspcon2,ACKDT);					//Send Ack
0040  2843  	GOTO	label7
0041  1683  	BSF STATUS, RP0
0042  1291  	BCF gbl_sspcon2,5
0043        label7

		st_bit(sspcon2,ACKEN);						//Initiate Nack
0043  1611  	BSF gbl_sspcon2,4

		while(ts_bit(sspcon2,ACKEN));				//Wait for data read
0044        label8
0044  1A11  	BTFSC gbl_sspcon2,4
0045  2844  	GOTO	label8

		return(sspbuf);								//Store incoming data
0046  1283  	BCF STATUS, RP0
0047  0813  	MOVF gbl_sspbuf, W
0048  00DC  	MOVWF CompTempVarRet2203

	#endif

	#if (MX_I2C_CHANNEL_X == 2)						//Use Master I2C Hardware 2
		cr_bit(pir3,SSP2IF);						//Clear SSP interrupt flag
		st_bit(ssp2con2,RCEN);						//Initiate Read
		while(ts_bit(pir3,SSP2IF) == 0);			//Wait for data read
		if (Last)
			st_bit(ssp2con2,ACKDT);					//Send Nack
		else cr_bit(ssp2con2,ACKDT);				//Send Ack
		st_bit(ssp2con2,ACKEN);						//Initiate Nack
		while(ts_bit(ssp2con2,ACKEN));				//Wait for data read
		return(ssp2buf);							//Store incoming data
	#endif
}
0049  0008  	RETURN





//Slave functions currently not implemented
CALFUNCTION(void, FC_CAL_I2C_Slave_Init_, (void))
{

}

CALFUNCTION(void, FC_CAL_I2C_Slave_Uninit_, (void))
{

}

CALFUNCTION(void, FC_CAL_I2C_Slave_SetTxData_, (MX_UINT8 Data))
{

}

CALFUNCTION(MX_UINT8, FC_CAL_I2C_Slave_GetRxData_, (MX_UINT8 Last))
{

}


////////////////////////////////////////
// Code with no source :-)
////////////////////////////////////////
0000  2AA2  	GOTO	_startup

0004  00FF  	MOVWF Int1Context
0005  0E03  	SWAPF STATUS, W
0006  1283  	BCF STATUS, RP0
0007  1303  	BCF STATUS, RP1
0008  00BC  	MOVWF Int1BContext
0009  0E0A  	SWAPF PCLATH, W
000A  00BD  	MOVWF Int1BContext+D'1'
000B  0E04  	SWAPF FSR, W
000C  00BE  	MOVWF Int1BContext+D'2'
000D  118A  	BCF PCLATH,3
000E  120A  	BCF PCLATH,4
000F  2AE4  	GOTO	interrupt
0010        delay_ms_00000
0010        ; { delay_ms ; function begin
0010  08DB  	MOVF delay_ms_00000_arg_del, F
0011  1D03  	BTFSS STATUS,Z
0012  2814  	GOTO	label1
0013  0008  	RETURN
0014        label1
0014  30CC  	MOVLW 0xCC
0015        label2
0015  3EFF  	ADDLW 0xFF
0016  1D03  	BTFSS STATUS,Z
0017  2815  	GOTO	label2
0018  0000  	NOP
0019  0BDB  	DECFSZ delay_ms_00000_arg_del, F
001A  2814  	GOTO	label1
001B  0008  	RETURN
001C        ; } delay_ms function end

001C        delay_us_00000
001C        ; { delay_us ; function begin
001C  3003  	MOVLW 0x03
001D  07DA  	ADDWF delay_us_00000_arg_del, F
001E  0CDA  	RRF delay_us_00000_arg_del, F
001F  0CDA  	RRF delay_us_00000_arg_del, F
0020  307F  	MOVLW 0x7F
0021  05DA  	ANDWF delay_us_00000_arg_del, F
0022        label3
0022  0000  	NOP
0023  0BDA  	DECFSZ delay_us_00000_arg_del, F
0024  2822  	GOTO	label3
0025  0008  	RETURN
0026        ; } delay_us function end

0026        delay_s_00000
0026        ; { delay_s ; function begin
0026        label4
0026  30FA  	MOVLW 0xFA
0027  00DB  	MOVWF delay_ms_00000_arg_del
0028  2010  	CALL delay_ms_00000
0029  30FA  	MOVLW 0xFA
002A  00DB  	MOVWF delay_ms_00000_arg_del
002B  2010  	CALL delay_ms_00000
002C  30FA  	MOVLW 0xFA
002D  00DB  	MOVWF delay_ms_00000_arg_del
002E  2010  	CALL delay_ms_00000
002F  30FA  	MOVLW 0xFA
0030  00DB  	MOVWF delay_ms_00000_arg_del
0031  2010  	CALL delay_ms_00000
0032  0BDA  	DECFSZ delay_s_00000_arg_del, F
0033  2826  	GOTO	label4
0034  0008  	RETURN
0035        ; } delay_s function end


01CC        __rem_8_8_00000
01CC        ; { __rem_8_8 ; function begin
01CC  01E0  	CLRF CompTempVarRet220
01CD  01DE  	CLRF __rem_8_8_00000_1_c
01CE  01DF  	CLRF __rem_8_8_00000_1_i
01CF        label26
01CF  19DF  	BTFSC __rem_8_8_00000_1_i,3
01D0  0008  	RETURN
01D1  1003  	BCF STATUS,C
01D2  0DDE  	RLF __rem_8_8_00000_1_c, F
01D3  0DDC  	RLF __rem_8_8_00000_arg_a, F
01D4  0DE0  	RLF CompTempVarRet220, F
01D5  085D  	MOVF __rem_8_8_00000_arg_b, W
01D6  0260  	SUBWF CompTempVarRet220, W
01D7  1C03  	BTFSS STATUS,C
01D8  29DB  	GOTO	label27
01D9  00E0  	MOVWF CompTempVarRet220
01DA  145E  	BSF __rem_8_8_00000_1_c,0
01DB        label27
01DB  0ADF  	INCF __rem_8_8_00000_1_i, F
01DC  29CF  	GOTO	label26
01DD        ; } __rem_8_8 function end

01DD        __div_8_8_00000
01DD        ; { __div_8_8 ; function begin
01DD  01DE  	CLRF __div_8_8_00000_1_r
01DE  01E0  	CLRF CompTempVarRet218
01DF  01DF  	CLRF __div_8_8_00000_1_i
01E0        label28
01E0  19DF  	BTFSC __div_8_8_00000_1_i,3
01E1  0008  	RETURN
01E2  1003  	BCF STATUS,C
01E3  0DE0  	RLF CompTempVarRet218, F
01E4  0DDA  	RLF __div_8_8_00000_arg_a, F
01E5  0DDE  	RLF __div_8_8_00000_1_r, F
01E6  085B  	MOVF __div_8_8_00000_arg_b, W
01E7  025E  	SUBWF __div_8_8_00000_1_r, W
01E8  1C03  	BTFSS STATUS,C
01E9  29EC  	GOTO	label29
01EA  00DE  	MOVWF __div_8_8_00000_1_r
01EB  1460  	BSF CompTempVarRet218,0
01EC        label29
01EC  0ADF  	INCF __div_8_8_00000_1_i, F
01ED  29E0  	GOTO	label28
01EE        ; } __div_8_8 function end


02A2        _startup
02A2  30D5  	MOVLW 0xD5
02A3  1283  	BCF STATUS, RP0
02A4  1303  	BCF STATUS, RP1
02A5  00A0  	MOVWF gbl_14_LSR
02A6  30C4  	MOVLW 0xC4
02A7  00A1  	MOVWF gbl_14_LSR+D'1'
02A8  30BB  	MOVLW 0xBB
02A9  00A2  	MOVWF gbl_14_LSR+D'2'
02AA  30DC  	MOVLW 0xDC
02AB  00A3  	MOVWF gbl_14_LSR+D'3'
02AC  01A4  	CLRF gbl_15_gbl_aSig
02AD  01A5  	CLRF gbl_15_gbl_aSig+D'1'
02AE  01A6  	CLRF gbl_15_gbl_aSig+D'2'
02AF  01A7  	CLRF gbl_15_gbl_aSig+D'3'
02B0  01A8  	CLRF gbl_15_gbl_bSig
02B1  01A9  	CLRF gbl_15_gbl_bSig+D'1'
02B2  01AA  	CLRF gbl_15_gbl_bSig+D'2'
02B3  01AB  	CLRF gbl_15_gbl_bSig+D'3'
02B4  01AC  	CLRF gbl_15_gbl_zSig
02B5  01AD  	CLRF gbl_15_gbl_zSig+D'1'
02B6  01AE  	CLRF gbl_15_gbl_zSig+D'2'
02B7  01AF  	CLRF gbl_15_gbl_zSig+D'3'
02B8  01C4  	CLRF gbl_15_gbl_aExp
02B9  01C5  	CLRF gbl_15_gbl_bExp
02BA  01BF  	CLRF gbl_15_gbl_zExp
02BB  01C0  	CLRF gbl_15_gbl_zExp+D'1'
02BC  01C6  	CLRF gbl_15_gbl_aSign
02BD  01C7  	CLRF gbl_15_gbl_bSign
02BE  01C8  	CLRF gbl_15_gbl_zSign
02BF  01C9  	CLRF gbl_15_gbl_zSigZero
02C0  01B0  	CLRF gbl_15_gbl_ret
02C1  01B1  	CLRF gbl_15_gbl_ret+D'1'
02C2  01B2  	CLRF gbl_15_gbl_ret+D'2'
02C3  01B3  	CLRF gbl_15_gbl_ret+D'3'
02C4  01C2  	CLRF gbl_float_rounding_mode
02C5  01C3  	CLRF gbl_float_exception_flags
02C6  01C1  	CLRF gbl_float_detect_tininess

02E1  118A  	BCF PCLATH,3
02E2  120A  	BCF PCLATH,4
02E3  2A68  	GOTO	main

2007  20D2  	DW 0x20D2
2008  3EFF  	DW 0x3EFF
