;/////////////////////////////////////////////////////////////////////////////////
;// Code Generator: BoostC Compiler - http://www.sourceboost.com
;// Version       : 7.03
;// License Type  : Pro License
;// Limitations   : PIC12,PIC16 max code size:Unlimited, max RAM banks:Unlimited
;/////////////////////////////////////////////////////////////////////////////////

//************************************************************************************
//**  
//**  File name:     C:\Users\gerpe\OneDrive\GER-PER 2016\Documents\KennyNeutron\2020\Thermometer\Flowcode\thermo883.c
//**  Title:         
//**  Description:   
//**  
//**  Generated by:  Flowcode v5.2.0.0
//**  Date:          Tuesday, June 30, 2020 12:00:39
//**  Licence:       Professional
//**  Registered to: xyz
//**  Licence key:   WUK7B9
//**  
//**  
//**  http://www.matrixmultimedia.com
//**  
//************************************************************************************


#define MX_PIC

#define MX_USES_UINT8 1
#define MX_USES_SINT16 0
#define MX_USES_CHAR 0
#define MX_USES_FLOAT 1
#define MX_USES_SINT32 1
#define MX_USES_BOOL 1
#define MX_USES_UINT16 0
#define MX_USES_UINT32 0
//Defines for microcontroller
#define P16F883
#define FC_CAL_PIC
#define MX_ADC
#define MX_ADC_TYPE_7
#define MX_ADC_BITS_10
#define MX_EE
#define MX_EE_TYPE2
#define MX_EE_SIZE 256
#define MX_SPI_1
#define MX_SPI_1_MISO_PORT portc
#define MX_SPI_1_MISO_TRIS trisc
#define MX_SPI_1_MISO_PIN 4
#define MX_SPI_1_MOSI_PORT portc
#define MX_SPI_1_MOSI_TRIS trisc
#define MX_SPI_1_MOSI_PIN 5
#define MX_SPI_1_CLK_PORT portc
#define MX_SPI_1_CLK_TRIS trisc
#define MX_SPI_1_CLK_PIN 3
#define MX_SPI_1_SS_PORT portc
#define MX_SPI_1_SS_TRIS trisc
#define MX_UART_1
#define MX_UART_1_TX_PORT portc
#define MX_UART_1_TX_TRIS trisc
#define MX_UART_1_TX_PIN 6
#define MX_UART_1_RX_PORT portc
#define MX_UART_1_RX_TRIS trisc
#define MX_UART_1_RX_PIN 7
#define MX_I2C
#define MX_MI2C
#define MX_I2C_1
#define MX_I2C_1_SDA_PORT portc
#define MX_I2C_1_SDA_TRIS trisc
#define MX_I2C_1_SDA_PIN 4
#define MX_I2C_1_SCL_PORT portc
#define MX_I2C_1_SCL_TRIS trisc
#define MX_I2C_1_SCL_PIN 3
#define MX_PWM
#define MX_PWM_CNT 2
#define MX_PWM_PSCA1
#define MX_PWM_PSCA4
#define MX_PWM_PSCA16
#define MX_PWM_1_PORT portc
#define MX_PWM_1_TRIS trisc
#define MX_PWM_1_PIN 2
#define MX_PWM_2_PORT portc
#define MX_PWM_2_TRIS trisc
#define MX_PWM_2_PIN 1

//Functions
#define MX_CLK_SPEED 4000000
#ifdef _BOOSTC
#include <system.h>
#endif
#ifdef HI_TECH_C
#include <pic.h>
#endif

//Configuration data
#ifdef _BOOSTC
#pragma DATA 0x2007, 0x20d4
#endif
#ifdef HI_TECH_C
__CONFIG(0x20d4);
#endif
#ifdef _BOOSTC
#pragma DATA 0x2008, 0x3eff
#endif
#ifdef HI_TECH_C
__CONFIG(0x3eff);
#endif

//Internal functions
#include "C:\Program Files (x86)\Flowcode\v5\FCD\internals.c"

//Macro function declarations
void FCM_intro();
void FCM_ikotled();
void FCM_display_temp();
void FCM_seg_pattern();
void FCM_scan1();
void FCM_scan2();
void FCM_scan3();
void FCM_scan4();
void FCM_scan_off();
void FCM_i2c_comm();
void FCM_calc();
void FCM_get_temp();


//Variable declarations
#define FCV_TRUE (1)
#define FCV_FALSE (0)
MX_UINT8 FCV_TEMP_TENS = (0x0);
034F  01CA  	CLRF gbl_FCV_TEMP_TENS

MX_UINT8 FCV_D_BYTE = (0xff);
0350  30FF  	MOVLW 0xFF
0351  00CB  	MOVWF gbl_FCV_D_BYTE

MX_UINT8 FCV_TEMP_CDP = (0x0);
0352  01CC  	CLRF gbl_FCV_TEMP_CDP

MX_SINT32 FCV_RAW = (0);
0353  01B4  	CLRF gbl_FCV_RAW
0354  01B5  	CLRF gbl_FCV_RAW+D'1'
0355  01B6  	CLRF gbl_FCV_RAW+D'2'
0356  01B7  	CLRF gbl_FCV_RAW+D'3'

MX_UINT8 FCV_DATA0 = (0xff);
0357  30FF  	MOVLW 0xFF
0358  00CD  	MOVWF gbl_FCV_DATA0

MX_UINT8 FCV_DATA1 = (0xff);
0359  30FF  	MOVLW 0xFF
035A  00CE  	MOVWF gbl_FCV_DATA1

MX_UINT8 FCV_DP2 = (0x0);
035B  01CF  	CLRF gbl_FCV_DP2

MX_UINT8 FCV_DATA2 = (0xff);
035C  30FF  	MOVLW 0xFF
035D  00D0  	MOVWF gbl_FCV_DATA2

MX_FLOAT FCV_FL;
MX_UINT8 FCV_TEMP_DEC = (0x0);
035E  01D1  	CLRF gbl_FCV_TEMP_DEC

MX_UINT8 FCV_TEMP_ONES = (0x0);
035F  01D2  	CLRF gbl_FCV_TEMP_ONES

MX_UINT8 FCV_RT_BYTE = (0x1);
0360  3001  	MOVLW 0x01
0361  00D3  	MOVWF gbl_FCV_RT_BYTE

MX_UINT8 FCV_LSB = (0x0);
0362  01D4  	CLRF gbl_FCV_LSB

MX_UINT8 FCV_MSB = (0x0);
0363  01D5  	CLRF gbl_FCV_MSB

MX_UINT8 FCV_DIGIT = (0x0);
0364  01D6  	CLRF gbl_FCV_DIGIT

MX_SINT32 FCV_TEMP_C = (0);
0365  01B8  	CLRF gbl_FCV_TEMP_C
0366  01B9  	CLRF gbl_FCV_TEMP_C+D'1'
0367  01BA  	CLRF gbl_FCV_TEMP_C+D'2'
0368  01BB  	CLRF gbl_FCV_TEMP_C+D'3'

MX_UINT8 FCV_I2C_RX = (0x0);
0369  01D7  	CLRF gbl_FCV_I2C_RX


MX_UINT8 FCLV_LOOP1;
MX_UINT8 FCLV_LOOP2;
MX_UINT8 FCLV_LOOP3;



//I2C_Master(0): //Defines:

/**** Macro Substitutions ****
a = Unique component ID
b = I2C Channel - 0=SW, 1-4=HW
c = Baud Rate
d = SM BUS Enable 0/2
e = Slew Rate Enable 0/1
f = Bitbanged Data Port Letter
g = Bitbanged Data Pin
h = Bitbanged Clock Port Letter
i = Bitbanged Clock Pin
******************************/

//BMODE
//Bit 0 - Slew Control
//Bit 1 - SMBus Control

//Definitions for I2C slot allocation
#ifndef	MX_I2C_REF1
	#define MX_I2C_REF1
	#define I2CMASTER_1_MX_I2C_UREF			1
	#define MX_I2C_CHANNEL_1		0
	#define MX_I2C_SDA_PIN_1		4
	#define MX_I2C_SDA_PORT_1		portc
	#define MX_I2C_SDA_TRIS_1		trisc
	#define MX_I2C_SCL_PIN_1		3
	#define MX_I2C_SCL_PORT_1		portc
	#define MX_I2C_SCL_TRIS_1		trisc
	#define MX_I2C_BMODE_1			0 | 0
	#define MX_I2C_BAUD_1			1000000
	#define MX_I2C_INT_1			0
#else
 #ifndef MX_I2C_REF2
	#define MX_I2C_REF2
	#define I2CMASTER_1_MX_I2C_UREF			2
	#define MX_I2C_CHANNEL_2		0
	#define MX_I2C_SDA_PIN_2		4
	#define MX_I2C_SDA_PORT_2		portc
	#define MX_I2C_SDA_TRIS_2		trisc
	#define MX_I2C_SCL_PIN_2		3
	#define MX_I2C_SCL_PORT_2		portc
	#define MX_I2C_SCL_TRIS_2		trisc
	#define MX_I2C_BMODE_2			0 | 0
	#define MX_I2C_BAUD_2			1000000
	#define MX_I2C_INT_2			0
 #else
  #ifndef MX_I2C_REF3
	#define MX_I2C_REF3
	#define I2CMASTER_1_MX_I2C_UREF			3
	#define MX_I2C_CHANNEL_3		0
	#define MX_I2C_SDA_PIN_3		4
	#define MX_I2C_SDA_PORT_3		portc
	#define MX_I2C_SDA_TRIS_3		trisc
	#define MX_I2C_SCL_PIN_3		3
	#define MX_I2C_SCL_PORT_3		portc
	#define MX_I2C_SCL_TRIS_3		trisc
	#define MX_I2C_BMODE_3			0 | 0
	#define MX_I2C_BAUD_3			1000000
	#define MX_I2C_INT_3			0
  #else
   #ifndef MX_I2C_REF4
	#define MX_I2C_REF4
	#define I2CMASTER_1_MX_I2C_UREF			4
	#define MX_I2C_CHANNEL_4		0
	#define MX_I2C_SDA_PIN_4		4
	#define MX_I2C_SDA_PORT_4		portc
	#define MX_I2C_SDA_TRIS_4		trisc
	#define MX_I2C_SCL_PIN_4		3
	#define MX_I2C_SCL_PORT_4		portc
	#define MX_I2C_SCL_TRIS_4		trisc
	#define MX_I2C_BMODE_4			0 | 0
	#define MX_I2C_BAUD_4			1000000
	#define MX_I2C_INT_4			0
   #endif
  #endif
 #endif
#endif

#define I2CMASTER_1_I2C_Master_Init		CAL_APPEND(FC_CAL_I2C_Master_Init_, I2CMASTER_1_MX_I2C_UREF)
#define I2CMASTER_1_I2C_Master_Uninit	CAL_APPEND(FC_CAL_I2C_Master_Uninit_, I2CMASTER_1_MX_I2C_UREF)
#define I2CMASTER_1_I2C_Master_Start		CAL_APPEND(FC_CAL_I2C_Master_Start_, I2CMASTER_1_MX_I2C_UREF)
#define I2CMASTER_1_I2C_Master_Restart	CAL_APPEND(FC_CAL_I2C_Master_Restart_, I2CMASTER_1_MX_I2C_UREF)
#define I2CMASTER_1_I2C_Master_Stop		CAL_APPEND(FC_CAL_I2C_Master_Stop_, I2CMASTER_1_MX_I2C_UREF)
#define I2CMASTER_1_I2C_Master_TX_Byte	CAL_APPEND(FC_CAL_I2C_Master_TX_Byte_, I2CMASTER_1_MX_I2C_UREF)
#define I2CMASTER_1_I2C_Master_RX_Byte	CAL_APPEND(FC_CAL_I2C_Master_RX_Byte_, I2CMASTER_1_MX_I2C_UREF)

extern void I2CMASTER_1_I2C_Master_Init ();
extern void I2CMASTER_1_I2C_Master_Uninit ();
extern void I2CMASTER_1_I2C_Master_Start ();
extern void I2CMASTER_1_I2C_Master_Restart ();
extern void I2CMASTER_1_I2C_Master_Stop ();
extern MX_UINT8 I2CMASTER_1_I2C_Master_TX_Byte (MX_UINT8 Data);
extern MX_UINT8 I2CMASTER_1_I2C_Master_RX_Byte (MX_UINT8 Last);




//I2C_Master(0): //Macro function declarations

void FCD_I2C_Master0_MI2C_Init();
void FCD_I2C_Master0_MI2C_Start();
void FCD_I2C_Master0_MI2C_Restart();
void FCD_I2C_Master0_MI2C_Stop();
MX_UINT8 FCD_I2C_Master0_MI2C_Transmit_Byte(MX_UINT8 Data);
MX_UINT8 FCD_I2C_Master0_MI2C_Receive_Byte(MX_UINT8 Last);
void FCD_I2C_Master0_MI2C_Send_Byte_Transaction(MX_UINT8 Device_ID, MX_UINT8 AddrH, MX_UINT8 AddrL, MX_UINT8 Data);
MX_UINT8 FCD_I2C_Master0_MI2C_Receive_Byte_Transaction(MX_UINT8 Device_ID, MX_UINT8 AddrH, MX_UINT8 AddrL);



//I2C_Master(0): //Macro implementations


void FCD_I2C_Master0_MI2C_Init()

{
	
		I2CMASTER_1_I2C_Master_Init();
02EE  210A  	CALL FC_CAL_I2C_0005C


}
02EF  0008  	RETURN


void FCD_I2C_Master0_MI2C_Start()

{
	
		I2CMASTER_1_I2C_Master_Start();
0255  20F3  	CALL FC_CAL_I2C_0005E


}
0256  0008  	RETURN


void FCD_I2C_Master0_MI2C_Restart()

{
	
		I2CMASTER_1_I2C_Master_Restart();
024D  20D7  	CALL FC_CAL_I2C_0005F


}
024E  0008  	RETURN


void FCD_I2C_Master0_MI2C_Stop()

{
	
		I2CMASTER_1_I2C_Master_Stop();
0245  20BE  	CALL FC_CAL_I2C_00060


}
0246  0008  	RETURN


MX_UINT8 FCD_I2C_Master0_MI2C_Transmit_Byte(MX_UINT8 Data)

{
	
		return I2CMASTER_1_I2C_Master_TX_Byte(Data);
024F  085A  	MOVF FCD_I2C_Ma_00057_arg_Data, W
0250  00DB  	MOVWF FC_CAL_I2C_00061_arg_Data
0251  2078  	CALL FC_CAL_I2C_00061
0252  085E  	MOVF CompTempVarRet2226, W
0253  00DB  	MOVWF CompTempVarRet2200


}
0254  0008  	RETURN


MX_UINT8 FCD_I2C_Master0_MI2C_Receive_Byte(MX_UINT8 Last)

{
	
		return I2CMASTER_1_I2C_Master_RX_Byte(Last);
0247  085A  	MOVF FCD_I2C_Ma_00059_arg_Last, W
0248  00DB  	MOVWF FC_CAL_I2C_00062_arg_Last
0249  2035  	CALL FC_CAL_I2C_00062
024A  085E  	MOVF CompTempVarRet2228, W
024B  00DB  	MOVWF CompTempVarRet2201


}
024C  0008  	RETURN


void FCD_I2C_Master0_MI2C_Send_Byte_Transaction(MX_UINT8 Device_ID, MX_UINT8 AddrH, MX_UINT8 AddrL, MX_UINT8 Data)
{
	
		Device_ID = Device_ID << 1;					//Shift Device ID to enable write mode

		I2CMASTER_1_I2C_Master_Start();						//Start transaction
		I2CMASTER_1_I2C_Master_TX_Byte(Device_ID);			//Transmit Device Address
		I2CMASTER_1_I2C_Master_TX_Byte(AddrH);				//Transmit Internal Address
		I2CMASTER_1_I2C_Master_TX_Byte(AddrL);
		I2CMASTER_1_I2C_Master_TX_Byte(Data);				//Send Data byte
		I2CMASTER_1_I2C_Master_Stop();						//Stop Transaction

}

MX_UINT8 FCD_I2C_Master0_MI2C_Receive_Byte_Transaction(MX_UINT8 Device_ID, MX_UINT8 AddrH, MX_UINT8 AddrL)
{
	
		MX_UINT8 RetVal = 0;
		Device_ID = Device_ID << 1;					//Shift Device ID to enable write mode

		I2CMASTER_1_I2C_Master_Start();						//Start transaction
		I2CMASTER_1_I2C_Master_TX_Byte(Device_ID);			//Transmit Device Address
		I2CMASTER_1_I2C_Master_TX_Byte(AddrH);				//Transmit Internal Address
		I2CMASTER_1_I2C_Master_TX_Byte(AddrL);
		I2CMASTER_1_I2C_Master_Restart();					//Restart transaction

		Device_ID = Device_ID | 0x01;				//Change Device ID to read mode
		I2CMASTER_1_I2C_Master_TX_Byte(Device_ID);			//Transmit Device Address
		RetVal = I2CMASTER_1_I2C_Master_RX_Byte(1);			//Read data at address
		I2CMASTER_1_I2C_Master_Stop();						//Stop Transaction

		return RetVal;								//Return data

}

#include "C:\Program Files (x86)\Flowcode\v5\CAL\includes.c"

//Macro implementations


void FCM_intro()

{

	//Call Macro
	//Call Macro: scan1()
	FCM_scan1();
0279  2204  	CALL FCM_scan1_00000


	//Call Macro
	//Call Macro: ikotled()
	FCM_ikotled();
027A  2229  	CALL FCM_ikotle_00051


	//Call Macro
	//Call Macro: scan2()
	FCM_scan2();
027B  21DF  	CALL FCM_scan2_00000


	//Call Macro
	//Call Macro: ikotled()
	FCM_ikotled();
027C  2229  	CALL FCM_ikotle_00051


	//Call Macro
	//Call Macro: scan3()
	FCM_scan3();
027D  21BA  	CALL FCM_scan3_00000


	//Call Macro
	//Call Macro: ikotled()
	FCM_ikotled();
027E  2229  	CALL FCM_ikotle_00051


	//Call Macro
	//Call Macro: scan4()
	FCM_scan4();
027F  2195  	CALL FCM_scan4_00000


	//Output
	//Output: 0b01000011 -> PORTA
	trisa = 0x00;
0280  1683  	BSF STATUS, RP0
0281  0185  	CLRF gbl_trisa

	porta = (67);
0282  3043  	MOVLW 0x43
0283  1283  	BCF STATUS, RP0
0284  0085  	MOVWF gbl_porta


	//Delay
	//Delay: 1 s
	delay_s(1);
0285  3001  	MOVLW 0x01
0286  00DA  	MOVWF delay_s_00000_arg_del
0287  2026  	CALL delay_s_00000


	//Delay
	//Delay: 500 ms
	delay_ms(255);
0288  30FF  	MOVLW 0xFF
0289  00DB  	MOVWF delay_ms_00000_arg_del
028A  201A  	CALL delay_ms_00000

	delay_ms(245);
028B  30F5  	MOVLW 0xF5
028C  00DB  	MOVWF delay_ms_00000_arg_del
028D  201A  	CALL delay_ms_00000


}
028E  0008  	RETURN



void FCM_ikotled()

{

	//Output
	//Output: 0 -> PORTA
	trisa = 0x00;
0229  1683  	BSF STATUS, RP0
022A  1303  	BCF STATUS, RP1
022B  0185  	CLRF gbl_trisa

	porta = (0);
022C  1283  	BCF STATUS, RP0
022D  0185  	CLRF gbl_porta


	//Calculation
	//Calculation:
	//  d_byte = 1
	FCV_D_BYTE = 1;
022E  3001  	MOVLW 0x01
022F  00CB  	MOVWF gbl_FCV_D_BYTE


	//Delay
	//Delay: 200 ms
	delay_ms(200);
0230  30C8  	MOVLW 0xC8
0231  00DB  	MOVWF delay_ms_00000_arg_del
0232  201A  	CALL delay_ms_00000


	//Loop
	//Loop: Loop 8 times
	for (FCLV_LOOP2=0; FCLV_LOOP2<8; FCLV_LOOP2++)
0233  01D9  	CLRF gbl_FCLV_LOOP2
0234        label26
0234  3008  	MOVLW 0x08
0235  0259  	SUBWF gbl_FCLV_LOOP2, W
0236  1803  	BTFSC STATUS,C
0243  0AD9  	INCF gbl_FCLV_LOOP2, F
0244  2A34  	GOTO	label26

	{

		//Output
		//Output: d_byte -> PORTA
		trisa = 0x00;
0238  1683  	BSF STATUS, RP0
0239  0185  	CLRF gbl_trisa

		porta = (FCV_D_BYTE);
023A  1283  	BCF STATUS, RP0
023B  084B  	MOVF gbl_FCV_D_BYTE, W
023C  0085  	MOVWF gbl_porta


		//Calculation
		//Calculation:
		//  d_byte = d_byte * 2
		FCV_D_BYTE = FCV_D_BYTE * 2;
023D  08CB  	MOVF gbl_FCV_D_BYTE, F
023E  1003  	BCF STATUS,C
023F  0DCB  	RLF gbl_FCV_D_BYTE, F


		//Delay
		//Delay: 200 ms
		delay_ms(200);
0240  30C8  	MOVLW 0xC8
0241  00DB  	MOVWF delay_ms_00000_arg_del
0242  201A  	CALL delay_ms_00000



	}

}
0237  0008  	RETURN



void FCM_display_temp()

{

	//Output
	//Output: 0 -> PORTA
	trisa = 0x00;
02BA  1683  	BSF STATUS, RP0
02BB  1303  	BCF STATUS, RP1
02BC  0185  	CLRF gbl_trisa

	porta = (0);
02BD  1283  	BCF STATUS, RP0
02BE  0185  	CLRF gbl_porta


	//Call Macro
	//Call Macro: scan_off()
	FCM_scan_off();
02BF  2173  	CALL FCM_scan_o_00053


	//Call Macro
	//Call Macro: scan1()
	FCM_scan1();
02C0  2204  	CALL FCM_scan1_00000


	//Calculation
	//Calculation:
	//  digit = temp_tens
	FCV_DIGIT = FCV_TEMP_TENS;
02C1  084A  	MOVF gbl_FCV_TEMP_TENS, W
02C2  00D6  	MOVWF gbl_FCV_DIGIT


	//Call Macro
	//Call Macro: seg_pattern()
	FCM_seg_pattern();
02C3  210F  	CALL FCM_seg_pa_00054


	//Delay
	//Delay: 5 us
	delay_us(5);
02C4  3005  	MOVLW 0x05
02C5  00DE  	MOVWF delay_us_00000_arg_del
02C6  2010  	CALL delay_us_00000


	//Call Macro
	//Call Macro: 
	//No code generated because there is no macro name

	//Output
	//Output: 0 -> PORTA
	trisa = 0x00;
02C7  1683  	BSF STATUS, RP0
02C8  0185  	CLRF gbl_trisa

	porta = (0);
02C9  1283  	BCF STATUS, RP0
02CA  0185  	CLRF gbl_porta


	//Call Macro
	//Call Macro: scan_off()
	FCM_scan_off();
02CB  2173  	CALL FCM_scan_o_00053


	//Call Macro
	//Call Macro: scan2()
	FCM_scan2();
02CC  21DF  	CALL FCM_scan2_00000


	//Calculation
	//Calculation:
	//  digit = temp_ones
	FCV_DIGIT = FCV_TEMP_ONES;
02CD  0852  	MOVF gbl_FCV_TEMP_ONES, W
02CE  00D6  	MOVWF gbl_FCV_DIGIT


	//Call Macro
	//Call Macro: seg_pattern()
	FCM_seg_pattern();
02CF  210F  	CALL FCM_seg_pa_00054


	//Delay
	//Delay: 5 us
	delay_us(5);
02D0  3005  	MOVLW 0x05
02D1  00DE  	MOVWF delay_us_00000_arg_del
02D2  2010  	CALL delay_us_00000


	//Output
	//Output: 0 -> PORTA
	trisa = 0x00;
02D3  1683  	BSF STATUS, RP0
02D4  0185  	CLRF gbl_trisa

	porta = (0);
02D5  1283  	BCF STATUS, RP0
02D6  0185  	CLRF gbl_porta


	//Call Macro
	//Call Macro: scan_off()
	FCM_scan_off();
02D7  2173  	CALL FCM_scan_o_00053


	//Call Macro
	//Call Macro: scan3()
	FCM_scan3();
02D8  21BA  	CALL FCM_scan3_00000


	//Calculation
	//Calculation:
	//  digit = temp_dec
	FCV_DIGIT = FCV_TEMP_DEC;
02D9  0851  	MOVF gbl_FCV_TEMP_DEC, W
02DA  00D6  	MOVWF gbl_FCV_DIGIT


	//Call Macro
	//Call Macro: seg_pattern()
	FCM_seg_pattern();
02DB  210F  	CALL FCM_seg_pa_00054


	//Delay
	//Delay: 5 us
	delay_us(5);
02DC  3005  	MOVLW 0x05
02DD  00DE  	MOVWF delay_us_00000_arg_del
02DE  2010  	CALL delay_us_00000


	//Output
	//Output: 0 -> PORTA
	trisa = 0x00;
02DF  1683  	BSF STATUS, RP0
02E0  0185  	CLRF gbl_trisa

	porta = (0);
02E1  1283  	BCF STATUS, RP0
02E2  0185  	CLRF gbl_porta


	//Call Macro
	//Call Macro: scan_off()
	FCM_scan_off();
02E3  2173  	CALL FCM_scan_o_00053


	//Call Macro
	//Call Macro: scan4()
	FCM_scan4();
02E4  2195  	CALL FCM_scan4_00000


	//Output
	//Output: 0b01000011 -> PORTA
	trisa = 0x00;
02E5  1683  	BSF STATUS, RP0
02E6  0185  	CLRF gbl_trisa

	porta = (67);
02E7  3043  	MOVLW 0x43
02E8  1283  	BCF STATUS, RP0
02E9  0085  	MOVWF gbl_porta


	//Delay
	//Delay: 5 us
	delay_us(5);
02EA  3005  	MOVLW 0x05
02EB  00DE  	MOVWF delay_us_00000_arg_del
02EC  2010  	CALL delay_us_00000


}
02ED  0008  	RETURN



void FCM_seg_pattern()

{

	//Switch
	//Switch: digit?
	switch (FCV_DIGIT)

	{
		case 1:
010F  1283  	BCF STATUS, RP0
0110  1303  	BCF STATUS, RP1
0111  0856  	MOVF gbl_FCV_DIGIT, W
0112  3A01  	XORLW 0x01
0113  1903  	BTFSC STATUS,Z
0114  2931  	GOTO	label15
0131        label15

		{
			//Output
			//Output: 0b00110000 -> PORTA
			trisa = 0x00;
0131  1683  	BSF STATUS, RP0
0132  0185  	CLRF gbl_trisa

			porta = (48);
0133  3030  	MOVLW 0x30
0134  1283  	BCF STATUS, RP0
0135  0085  	MOVWF gbl_porta


			break;

		}
		case 2:
0115  3A03  	XORLW 0x03
0116  1903  	BTFSC STATUS,Z
0117  2937  	GOTO	label16
0137        label16

		{
			//Output
			//Output: 0b01101101 -> PORTA
			trisa = 0x00;
0137  1683  	BSF STATUS, RP0
0138  0185  	CLRF gbl_trisa

			porta = (109);
0139  306D  	MOVLW 0x6D
013A  1283  	BCF STATUS, RP0
013B  0085  	MOVWF gbl_porta


			break;

		}
		case 3:
0118  3A01  	XORLW 0x01
0119  1903  	BTFSC STATUS,Z
011A  293D  	GOTO	label17
013D        label17

		{
			//Output
			//Output: 0b01111001 -> PORTA
			trisa = 0x00;
013D  1683  	BSF STATUS, RP0
013E  0185  	CLRF gbl_trisa

			porta = (121);
013F  3079  	MOVLW 0x79
0140  1283  	BCF STATUS, RP0
0141  0085  	MOVWF gbl_porta


			break;

		}
		case 4:
011B  3A07  	XORLW 0x07
011C  1903  	BTFSC STATUS,Z
011D  2943  	GOTO	label18
0143        label18

		{
			//Output
			//Output: 0b00110011 -> PORTA
			trisa = 0x00;
0143  1683  	BSF STATUS, RP0
0144  0185  	CLRF gbl_trisa

			porta = (51);
0145  3033  	MOVLW 0x33
0146  1283  	BCF STATUS, RP0
0147  0085  	MOVWF gbl_porta


			break;

		}
		case 5:
011E  3A01  	XORLW 0x01
011F  1903  	BTFSC STATUS,Z
0120  2949  	GOTO	label19
0149        label19

		{
			//Output
			//Output: 0b01011011 -> PORTA
			trisa = 0x00;
0149  1683  	BSF STATUS, RP0
014A  0185  	CLRF gbl_trisa

			porta = (91);
014B  305B  	MOVLW 0x5B
014C  1283  	BCF STATUS, RP0
014D  0085  	MOVWF gbl_porta


			break;

		}
		case 6:
0121  3A03  	XORLW 0x03
0122  1903  	BTFSC STATUS,Z
0123  294F  	GOTO	label20
014F        label20

		{
			//Output
			//Output: 0b01011111 -> PORTA
			trisa = 0x00;
014F  1683  	BSF STATUS, RP0
0150  0185  	CLRF gbl_trisa

			porta = (95);
0151  305F  	MOVLW 0x5F
0152  1283  	BCF STATUS, RP0
0153  0085  	MOVWF gbl_porta


			break;

		}
		case 7:
0124  3A01  	XORLW 0x01
0125  1903  	BTFSC STATUS,Z
0126  2955  	GOTO	label21
0155        label21

		{
			//Output
			//Output: 0b01110000 -> PORTA
			trisa = 0x00;
0155  1683  	BSF STATUS, RP0
0156  0185  	CLRF gbl_trisa

			porta = (112);
0157  3070  	MOVLW 0x70
0158  1283  	BCF STATUS, RP0
0159  0085  	MOVWF gbl_porta


			break;

		}
		case 8:
0127  3A0F  	XORLW 0x0F
0128  1903  	BTFSC STATUS,Z
0129  295B  	GOTO	label22
015B        label22

		{
			//Output
			//Output: 0b01111111 -> PORTA
			trisa = 0x00;
015B  1683  	BSF STATUS, RP0
015C  0185  	CLRF gbl_trisa

			porta = (127);
015D  307F  	MOVLW 0x7F
015E  1283  	BCF STATUS, RP0
015F  0085  	MOVWF gbl_porta


			break;

		}
		case 9:
012A  3A01  	XORLW 0x01
012B  1903  	BTFSC STATUS,Z
012C  2961  	GOTO	label23
0161        label23

		{
			//Output
			//Output: 0b01111011 -> PORTA
			trisa = 0x00;
0161  1683  	BSF STATUS, RP0
0162  0185  	CLRF gbl_trisa

			porta = (123);
0163  307B  	MOVLW 0x7B
0164  1283  	BCF STATUS, RP0
0165  0085  	MOVWF gbl_porta


			break;

		}
		case 0:
012D  3A09  	XORLW 0x09
012E  1903  	BTFSC STATUS,Z
012F  2967  	GOTO	label24
0167        label24

		{
			//Output
			//Output: 0b01111110 -> PORTA
			trisa = 0x00;
0167  1683  	BSF STATUS, RP0
0168  0185  	CLRF gbl_trisa

			porta = (126);
0169  307E  	MOVLW 0x7E
016A  1283  	BCF STATUS, RP0
016B  0085  	MOVWF gbl_porta


			break;

		}
		default:
0130  296D  	GOTO	label25
016D        label25

		{
			//Output
			//Output: 0b00000001 -> PORTA
			trisa = 0x00;
016D  1683  	BSF STATUS, RP0
016E  0185  	CLRF gbl_trisa

			porta = (1);
016F  3001  	MOVLW 0x01
0170  1283  	BCF STATUS, RP0
0171  0085  	MOVWF gbl_porta


		}
	}

}
0136  0008  	RETURN
013C  0008  	RETURN
0142  0008  	RETURN
0148  0008  	RETURN
014E  0008  	RETURN
0154  0008  	RETURN
015A  0008  	RETURN
0160  0008  	RETURN
0166  0008  	RETURN
016C  0008  	RETURN
0172  0008  	RETURN



void FCM_scan1()

{

	//Output
	//Output: 1 -> B2
	trisb = trisb & 0xFB;
0204  30FB  	MOVLW 0xFB
0205  1683  	BSF STATUS, RP0
0206  1303  	BCF STATUS, RP1
0207  0506  	ANDWF gbl_trisb, W
0208  0086  	MOVWF gbl_trisb

	if ((1))
		portb = (portb & 0xFB) | 0x04;
0209  30FB  	MOVLW 0xFB
020A  1283  	BCF STATUS, RP0
020B  0506  	ANDWF gbl_portb, W
020C  00DA  	MOVWF CompTempVar2195
020D  3004  	MOVLW 0x04
020E  045A  	IORWF CompTempVar2195, W
020F  0086  	MOVWF gbl_portb

	else
		portb = portb & 0xFB;

	//Output
	//Output: 0 -> B3
	trisb = trisb & 0xF7;
0210  30F7  	MOVLW 0xF7
0211  1683  	BSF STATUS, RP0
0212  0506  	ANDWF gbl_trisb, W
0213  0086  	MOVWF gbl_trisb

	if ((0))
		portb = (portb & 0xF7) | 0x08;
	else
		portb = portb & 0xF7;
0214  30F7  	MOVLW 0xF7
0215  1283  	BCF STATUS, RP0
0216  0506  	ANDWF gbl_portb, W
0217  0086  	MOVWF gbl_portb


	//Output
	//Output: 0 -> B4
	trisb = trisb & 0xEF;
0218  30EF  	MOVLW 0xEF
0219  1683  	BSF STATUS, RP0
021A  0506  	ANDWF gbl_trisb, W
021B  0086  	MOVWF gbl_trisb

	if ((0))
		portb = (portb & 0xEF) | 0x10;
	else
		portb = portb & 0xEF;
021C  30EF  	MOVLW 0xEF
021D  1283  	BCF STATUS, RP0
021E  0506  	ANDWF gbl_portb, W
021F  0086  	MOVWF gbl_portb


	//Output
	//Output: 0 -> B5
	trisb = trisb & 0xDF;
0220  30DF  	MOVLW 0xDF
0221  1683  	BSF STATUS, RP0
0222  0506  	ANDWF gbl_trisb, W
0223  0086  	MOVWF gbl_trisb

	if ((0))
		portb = (portb & 0xDF) | 0x20;
	else
		portb = portb & 0xDF;
0224  30DF  	MOVLW 0xDF
0225  1283  	BCF STATUS, RP0
0226  0506  	ANDWF gbl_portb, W
0227  0086  	MOVWF gbl_portb


}
0228  0008  	RETURN



void FCM_scan2()

{

	//Output
	//Output: 0 -> B2
	trisb = trisb & 0xFB;
01DF  30FB  	MOVLW 0xFB
01E0  1683  	BSF STATUS, RP0
01E1  1303  	BCF STATUS, RP1
01E2  0506  	ANDWF gbl_trisb, W
01E3  0086  	MOVWF gbl_trisb

	if ((0))
		portb = (portb & 0xFB) | 0x04;
	else
		portb = portb & 0xFB;
01E4  30FB  	MOVLW 0xFB
01E5  1283  	BCF STATUS, RP0
01E6  0506  	ANDWF gbl_portb, W
01E7  0086  	MOVWF gbl_portb


	//Output
	//Output: 1 -> B3
	trisb = trisb & 0xF7;
01E8  30F7  	MOVLW 0xF7
01E9  1683  	BSF STATUS, RP0
01EA  0506  	ANDWF gbl_trisb, W
01EB  0086  	MOVWF gbl_trisb

	if ((1))
		portb = (portb & 0xF7) | 0x08;
01EC  30F7  	MOVLW 0xF7
01ED  1283  	BCF STATUS, RP0
01EE  0506  	ANDWF gbl_portb, W
01EF  00DA  	MOVWF CompTempVar2197
01F0  3008  	MOVLW 0x08
01F1  045A  	IORWF CompTempVar2197, W
01F2  0086  	MOVWF gbl_portb

	else
		portb = portb & 0xF7;

	//Output
	//Output: 0 -> B4
	trisb = trisb & 0xEF;
01F3  30EF  	MOVLW 0xEF
01F4  1683  	BSF STATUS, RP0
01F5  0506  	ANDWF gbl_trisb, W
01F6  0086  	MOVWF gbl_trisb

	if ((0))
		portb = (portb & 0xEF) | 0x10;
	else
		portb = portb & 0xEF;
01F7  30EF  	MOVLW 0xEF
01F8  1283  	BCF STATUS, RP0
01F9  0506  	ANDWF gbl_portb, W
01FA  0086  	MOVWF gbl_portb


	//Output
	//Output: 0 -> B5
	trisb = trisb & 0xDF;
01FB  30DF  	MOVLW 0xDF
01FC  1683  	BSF STATUS, RP0
01FD  0506  	ANDWF gbl_trisb, W
01FE  0086  	MOVWF gbl_trisb

	if ((0))
		portb = (portb & 0xDF) | 0x20;
	else
		portb = portb & 0xDF;
01FF  30DF  	MOVLW 0xDF
0200  1283  	BCF STATUS, RP0
0201  0506  	ANDWF gbl_portb, W
0202  0086  	MOVWF gbl_portb


}
0203  0008  	RETURN



void FCM_scan3()

{

	//Output
	//Output: 0 -> B2
	trisb = trisb & 0xFB;
01BA  30FB  	MOVLW 0xFB
01BB  1683  	BSF STATUS, RP0
01BC  1303  	BCF STATUS, RP1
01BD  0506  	ANDWF gbl_trisb, W
01BE  0086  	MOVWF gbl_trisb

	if ((0))
		portb = (portb & 0xFB) | 0x04;
	else
		portb = portb & 0xFB;
01BF  30FB  	MOVLW 0xFB
01C0  1283  	BCF STATUS, RP0
01C1  0506  	ANDWF gbl_portb, W
01C2  0086  	MOVWF gbl_portb


	//Output
	//Output: 0 -> B3
	trisb = trisb & 0xF7;
01C3  30F7  	MOVLW 0xF7
01C4  1683  	BSF STATUS, RP0
01C5  0506  	ANDWF gbl_trisb, W
01C6  0086  	MOVWF gbl_trisb

	if ((0))
		portb = (portb & 0xF7) | 0x08;
	else
		portb = portb & 0xF7;
01C7  30F7  	MOVLW 0xF7
01C8  1283  	BCF STATUS, RP0
01C9  0506  	ANDWF gbl_portb, W
01CA  0086  	MOVWF gbl_portb


	//Output
	//Output: 1 -> B4
	trisb = trisb & 0xEF;
01CB  30EF  	MOVLW 0xEF
01CC  1683  	BSF STATUS, RP0
01CD  0506  	ANDWF gbl_trisb, W
01CE  0086  	MOVWF gbl_trisb

	if ((1))
		portb = (portb & 0xEF) | 0x10;
01CF  30EF  	MOVLW 0xEF
01D0  1283  	BCF STATUS, RP0
01D1  0506  	ANDWF gbl_portb, W
01D2  00DA  	MOVWF CompTempVar2198
01D3  3010  	MOVLW 0x10
01D4  045A  	IORWF CompTempVar2198, W
01D5  0086  	MOVWF gbl_portb

	else
		portb = portb & 0xEF;

	//Output
	//Output: 0 -> B5
	trisb = trisb & 0xDF;
01D6  30DF  	MOVLW 0xDF
01D7  1683  	BSF STATUS, RP0
01D8  0506  	ANDWF gbl_trisb, W
01D9  0086  	MOVWF gbl_trisb

	if ((0))
		portb = (portb & 0xDF) | 0x20;
	else
		portb = portb & 0xDF;
01DA  30DF  	MOVLW 0xDF
01DB  1283  	BCF STATUS, RP0
01DC  0506  	ANDWF gbl_portb, W
01DD  0086  	MOVWF gbl_portb


}
01DE  0008  	RETURN



void FCM_scan4()

{

	//Output
	//Output: 0 -> B2
	trisb = trisb & 0xFB;
0195  30FB  	MOVLW 0xFB
0196  1683  	BSF STATUS, RP0
0197  1303  	BCF STATUS, RP1
0198  0506  	ANDWF gbl_trisb, W
0199  0086  	MOVWF gbl_trisb

	if ((0))
		portb = (portb & 0xFB) | 0x04;
	else
		portb = portb & 0xFB;
019A  30FB  	MOVLW 0xFB
019B  1283  	BCF STATUS, RP0
019C  0506  	ANDWF gbl_portb, W
019D  0086  	MOVWF gbl_portb


	//Output
	//Output: 0 -> B3
	trisb = trisb & 0xF7;
019E  30F7  	MOVLW 0xF7
019F  1683  	BSF STATUS, RP0
01A0  0506  	ANDWF gbl_trisb, W
01A1  0086  	MOVWF gbl_trisb

	if ((0))
		portb = (portb & 0xF7) | 0x08;
	else
		portb = portb & 0xF7;
01A2  30F7  	MOVLW 0xF7
01A3  1283  	BCF STATUS, RP0
01A4  0506  	ANDWF gbl_portb, W
01A5  0086  	MOVWF gbl_portb


	//Output
	//Output: 0 -> B4
	trisb = trisb & 0xEF;
01A6  30EF  	MOVLW 0xEF
01A7  1683  	BSF STATUS, RP0
01A8  0506  	ANDWF gbl_trisb, W
01A9  0086  	MOVWF gbl_trisb

	if ((0))
		portb = (portb & 0xEF) | 0x10;
	else
		portb = portb & 0xEF;
01AA  30EF  	MOVLW 0xEF
01AB  1283  	BCF STATUS, RP0
01AC  0506  	ANDWF gbl_portb, W
01AD  0086  	MOVWF gbl_portb


	//Output
	//Output: 1 -> B5
	trisb = trisb & 0xDF;
01AE  30DF  	MOVLW 0xDF
01AF  1683  	BSF STATUS, RP0
01B0  0506  	ANDWF gbl_trisb, W
01B1  0086  	MOVWF gbl_trisb

	if ((1))
		portb = (portb & 0xDF) | 0x20;
01B2  30DF  	MOVLW 0xDF
01B3  1283  	BCF STATUS, RP0
01B4  0506  	ANDWF gbl_portb, W
01B5  00DA  	MOVWF CompTempVar2199
01B6  3020  	MOVLW 0x20
01B7  045A  	IORWF CompTempVar2199, W
01B8  0086  	MOVWF gbl_portb

	else
		portb = portb & 0xDF;

}
01B9  0008  	RETURN



void FCM_scan_off()

{

	//Output
	//Output: 0 -> B2
	trisb = trisb & 0xFB;
0173  30FB  	MOVLW 0xFB
0174  1683  	BSF STATUS, RP0
0175  1303  	BCF STATUS, RP1
0176  0506  	ANDWF gbl_trisb, W
0177  0086  	MOVWF gbl_trisb

	if ((0))
		portb = (portb & 0xFB) | 0x04;
	else
		portb = portb & 0xFB;
0178  30FB  	MOVLW 0xFB
0179  1283  	BCF STATUS, RP0
017A  0506  	ANDWF gbl_portb, W
017B  0086  	MOVWF gbl_portb


	//Output
	//Output: 0 -> B3
	trisb = trisb & 0xF7;
017C  30F7  	MOVLW 0xF7
017D  1683  	BSF STATUS, RP0
017E  0506  	ANDWF gbl_trisb, W
017F  0086  	MOVWF gbl_trisb

	if ((0))
		portb = (portb & 0xF7) | 0x08;
	else
		portb = portb & 0xF7;
0180  30F7  	MOVLW 0xF7
0181  1283  	BCF STATUS, RP0
0182  0506  	ANDWF gbl_portb, W
0183  0086  	MOVWF gbl_portb


	//Output
	//Output: 0 -> B4
	trisb = trisb & 0xEF;
0184  30EF  	MOVLW 0xEF
0185  1683  	BSF STATUS, RP0
0186  0506  	ANDWF gbl_trisb, W
0187  0086  	MOVWF gbl_trisb

	if ((0))
		portb = (portb & 0xEF) | 0x10;
	else
		portb = portb & 0xEF;
0188  30EF  	MOVLW 0xEF
0189  1283  	BCF STATUS, RP0
018A  0506  	ANDWF gbl_portb, W
018B  0086  	MOVWF gbl_portb


	//Output
	//Output: 0 -> B5
	trisb = trisb & 0xDF;
018C  30DF  	MOVLW 0xDF
018D  1683  	BSF STATUS, RP0
018E  0506  	ANDWF gbl_trisb, W
018F  0086  	MOVWF gbl_trisb

	if ((0))
		portb = (portb & 0xDF) | 0x20;
	else
		portb = portb & 0xDF;
0190  30DF  	MOVLW 0xDF
0191  1283  	BCF STATUS, RP0
0192  0506  	ANDWF gbl_portb, W
0193  0086  	MOVWF gbl_portb


}
0194  0008  	RETURN



void FCM_i2c_comm()

{

	//Call Component Macro
	//Call Component Macro: MI2C_Start()
	FCD_I2C_Master0_MI2C_Start();
028F  2255  	CALL FCD_I2C_Ma_00056


	//Calculation
	//Calculation:
	//  rt_byte = 0
	FCV_RT_BYTE = 0;
0290  01D3  	CLRF gbl_FCV_RT_BYTE


	//Call Component Macro
	//Call Component Macro: rt_byte=MI2C_Transmit_Byte(0xB4)
	FCV_RT_BYTE = FCD_I2C_Master0_MI2C_Transmit_Byte(0xB4);
0291  30B4  	MOVLW 0xB4
0292  00DA  	MOVWF FCD_I2C_Ma_00057_arg_Data
0293  224F  	CALL FCD_I2C_Ma_00057
0294  085B  	MOVF CompTempVarRet2200, W
0295  00D3  	MOVWF gbl_FCV_RT_BYTE


	//Calculation
	//Calculation:
	//  rt_byte = 0
	FCV_RT_BYTE = 0;
0296  01D3  	CLRF gbl_FCV_RT_BYTE


	//Call Component Macro
	//Call Component Macro: rt_byte=MI2C_Transmit_Byte(0x07)
	FCV_RT_BYTE = FCD_I2C_Master0_MI2C_Transmit_Byte(0x07);
0297  3007  	MOVLW 0x07
0298  00DA  	MOVWF FCD_I2C_Ma_00057_arg_Data
0299  224F  	CALL FCD_I2C_Ma_00057
029A  085B  	MOVF CompTempVarRet2200, W
029B  00D3  	MOVWF gbl_FCV_RT_BYTE


	//Comment:
	//end of RD/WR cmd

	//Call Component Macro
	//Call Component Macro: MI2C_Restart()
	FCD_I2C_Master0_MI2C_Restart();
029C  224D  	CALL FCD_I2C_Ma_00058


	//Calculation
	//Calculation:
	//  rt_byte = 0
	FCV_RT_BYTE = 0;
029D  01D3  	CLRF gbl_FCV_RT_BYTE


	//Call Component Macro
	//Call Component Macro: rt_byte=MI2C_Transmit_Byte(0xB4)
	FCV_RT_BYTE = FCD_I2C_Master0_MI2C_Transmit_Byte(0xB4);
029E  30B4  	MOVLW 0xB4
029F  00DA  	MOVWF FCD_I2C_Ma_00057_arg_Data
02A0  224F  	CALL FCD_I2C_Ma_00057
02A1  085B  	MOVF CompTempVarRet2200, W
02A2  00D3  	MOVWF gbl_FCV_RT_BYTE


	//Call Component Macro
	//Call Component Macro: i2c_rx=MI2C_Receive_Byte(rt_byte)
	FCV_I2C_RX = FCD_I2C_Master0_MI2C_Receive_Byte(FCV_RT_BYTE);
02A3  0853  	MOVF gbl_FCV_RT_BYTE, W
02A4  00DA  	MOVWF FCD_I2C_Ma_00059_arg_Last
02A5  2247  	CALL FCD_I2C_Ma_00059
02A6  085B  	MOVF CompTempVarRet2201, W
02A7  00D7  	MOVWF gbl_FCV_I2C_RX


	//Calculation
	//Calculation:
	//  data0 = i2c_rx
	FCV_DATA0 = FCV_I2C_RX;
02A8  0857  	MOVF gbl_FCV_I2C_RX, W
02A9  00CD  	MOVWF gbl_FCV_DATA0


	//Call Component Macro
	//Call Component Macro: i2c_rx=MI2C_Receive_Byte(rt_byte)
	FCV_I2C_RX = FCD_I2C_Master0_MI2C_Receive_Byte(FCV_RT_BYTE);
02AA  0853  	MOVF gbl_FCV_RT_BYTE, W
02AB  00DA  	MOVWF FCD_I2C_Ma_00059_arg_Last
02AC  2247  	CALL FCD_I2C_Ma_00059
02AD  085B  	MOVF CompTempVarRet2201, W
02AE  00D7  	MOVWF gbl_FCV_I2C_RX


	//Calculation
	//Calculation:
	//  data1 = i2c_rx
	FCV_DATA1 = FCV_I2C_RX;
02AF  0857  	MOVF gbl_FCV_I2C_RX, W
02B0  00CE  	MOVWF gbl_FCV_DATA1


	//Call Component Macro
	//Call Component Macro: i2c_rx=MI2C_Receive_Byte(rt_byte)
	FCV_I2C_RX = FCD_I2C_Master0_MI2C_Receive_Byte(FCV_RT_BYTE);
02B1  0853  	MOVF gbl_FCV_RT_BYTE, W
02B2  00DA  	MOVWF FCD_I2C_Ma_00059_arg_Last
02B3  2247  	CALL FCD_I2C_Ma_00059
02B4  085B  	MOVF CompTempVarRet2201, W
02B5  00D7  	MOVWF gbl_FCV_I2C_RX


	//Calculation
	//Calculation:
	//  data2 = i2c_rx
	FCV_DATA2 = FCV_I2C_RX;
02B6  0857  	MOVF gbl_FCV_I2C_RX, W
02B7  00D0  	MOVWF gbl_FCV_DATA2


	//Call Component Macro
	//Call Component Macro: MI2C_Stop()
	FCD_I2C_Master0_MI2C_Stop();
02B8  2245  	CALL FCD_I2C_Ma_0005A


}
02B9  0008  	RETURN



void FCM_calc()
{

	//Calculation
	//Calculation:
	//  lsb = data0
	//  msb = data1
	FCV_LSB = FCV_DATA0;
	FCV_MSB = FCV_DATA1;

	//Calculation
	//Calculation:
	//  raw = msb
	FCV_RAW = FCV_MSB;

	//Loop
	//Loop: Loop 8 times
	for (FCLV_LOOP3=0; FCLV_LOOP3<8; FCLV_LOOP3++)
	{

		//Calculation
		//Calculation:
		//  raw = raw << 1
		FCV_RAW = FCV_RAW << 1;


	}

	//Calculation
	//Calculation:
	//  raw = raw + lsb
	FCV_RAW = FCV_RAW + FCV_LSB;

	//Calculation
	//Calculation:
	//  fl = (raw / 50) - 270
	FCV_FL = flt_fromi((FCV_RAW / 50) - 270);

	//Calculation
	//Calculation:
	//  temp_c = fl
	FCV_TEMP_C = flt_toi(FCV_FL);

	//Calculation
	//Calculation:
	//  dp2 = (fl - temp_c) * 100
	FCV_DP2 = flt_toi(flt_mul((flt_sub(FCV_FL, flt_fromi(FCV_TEMP_C))), 100));

	//Calculation
	//Calculation:
	//  temp_cdp = dp2
	FCV_TEMP_CDP = FCV_DP2;

}


void FCM_get_temp()
{

	//Call Macro
	//Call Macro: i2c_comm()
	FCM_i2c_comm();

	//Call Macro
	//Call Macro: calc()
	FCM_calc();

}



void main()

{
	//Initialization
	ansel = 0;
02F0  1683  	BSF STATUS, RP0
02F1  1703  	BSF STATUS, RP1
02F2  0188  	CLRF gbl_ansel

anselh = 0;
02F3  0189  	CLRF gbl_anselh



	//Interrupt initialization code
	option_reg = 0xC0;
02F4  30C0  	MOVLW 0xC0
02F5  1303  	BCF STATUS, RP1
02F6  0081  	MOVWF gbl_option_reg



	//Calculation
	//Calculation:
	//  data0 = 123
	//  data1 = 0xff
	//  data2 = 0xff
	//  lsb = 0x00
	//  msb = 0x00
	FCV_DATA0 = 123;
02F7  307B  	MOVLW 0x7B
02F8  1283  	BCF STATUS, RP0
02F9  00CD  	MOVWF gbl_FCV_DATA0

	FCV_DATA1 = 0xff;
02FA  30FF  	MOVLW 0xFF
02FB  00CE  	MOVWF gbl_FCV_DATA1

	FCV_DATA2 = 0xff;
02FC  00D0  	MOVWF gbl_FCV_DATA2

	FCV_LSB = 0x00;
02FD  01D4  	CLRF gbl_FCV_LSB

	FCV_MSB = 0x00;
02FE  01D5  	CLRF gbl_FCV_MSB


	//Calculation
	//Calculation:
	//  temp_tens = 1
	//  temp_ones = 2
	//  temp_dec = 3
	FCV_TEMP_TENS = 1;
02FF  3001  	MOVLW 0x01
0300  00CA  	MOVWF gbl_FCV_TEMP_TENS

	FCV_TEMP_ONES = 2;
0301  3002  	MOVLW 0x02
0302  00D2  	MOVWF gbl_FCV_TEMP_ONES

	FCV_TEMP_DEC = 3;
0303  3003  	MOVLW 0x03
0304  00D1  	MOVWF gbl_FCV_TEMP_DEC


	//Call Macro
	//Call Macro: intro()
	FCM_intro();
0305  2279  	CALL FCM_intro_00000


	//Call Component Macro
	//Call Component Macro: MI2C_Init()
	FCD_I2C_Master0_MI2C_Init();
0306  22EE  	CALL FCD_I2C_Ma_00063


	//Loop
	//Loop: While 1
	while (1)
0307        label31

	{

		//Call Macro
		//Call Macro: i2c_comm()
		FCM_i2c_comm();
0307  228F  	CALL FCM_i2c_co_00055


		//Calculation
		//Calculation:
		//  temp_tens = data0 / 100
		//  temp_ones = (data0 / 10) % 10
		//  temp_dec = data0 % 10
		FCV_TEMP_TENS = FCV_DATA0 / 100;
0308  084D  	MOVF gbl_FCV_DATA0, W
0309  00DA  	MOVWF __div_8_8_00000_arg_a
030A  3064  	MOVLW 0x64
030B  00DB  	MOVWF __div_8_8_00000_arg_b
030C  2268  	CALL __div_8_8_00000
030D  0860  	MOVF CompTempVarRet218, W
030E  00CA  	MOVWF gbl_FCV_TEMP_TENS

		FCV_TEMP_ONES = (FCV_DATA0 / 10) % 10;
030F  084D  	MOVF gbl_FCV_DATA0, W
0310  00DA  	MOVWF __div_8_8_00000_arg_a
0311  300A  	MOVLW 0x0A
0312  00DB  	MOVWF __div_8_8_00000_arg_b
0313  2268  	CALL __div_8_8_00000
0314  0860  	MOVF CompTempVarRet218, W
0315  00DC  	MOVWF __rem_8_8_00000_arg_a
0316  300A  	MOVLW 0x0A
0317  00DD  	MOVWF __rem_8_8_00000_arg_b
0318  2257  	CALL __rem_8_8_00000
0319  0860  	MOVF CompTempVarRet220, W
031A  00D2  	MOVWF gbl_FCV_TEMP_ONES

		FCV_TEMP_DEC = FCV_DATA0 % 10;
031B  084D  	MOVF gbl_FCV_DATA0, W
031C  00DC  	MOVWF __rem_8_8_00000_arg_a
031D  300A  	MOVLW 0x0A
031E  00DD  	MOVWF __rem_8_8_00000_arg_b
031F  2257  	CALL __rem_8_8_00000
0320  0860  	MOVF CompTempVarRet220, W
0321  00D1  	MOVWF gbl_FCV_TEMP_DEC


		//Loop
		//Loop: Loop 200 times
		for (FCLV_LOOP1=0; FCLV_LOOP1<200; FCLV_LOOP1++)
0322  01D8  	CLRF gbl_FCLV_LOOP1
0323        label32
0323  30C8  	MOVLW 0xC8
0324  0258  	SUBWF gbl_FCLV_LOOP1, W
0325  1803  	BTFSC STATUS,C
0326  2B07  	GOTO	label31
0328  0AD8  	INCF gbl_FCLV_LOOP1, F
0329  2B23  	GOTO	label32

		{

			//Call Macro
			//Call Macro: display_temp()
			FCM_display_temp();
0327  22BA  	CALL FCM_displa_00052



		}


	}

	mainendloop: goto mainendloop;
}


void MX_INTERRUPT_MACRO(void)

{
}
036D  1283  	BCF STATUS, RP0
036E  1303  	BCF STATUS, RP1
036F  0E3E  	SWAPF Int1BContext+D'2', W
0370  0084  	MOVWF FSR
0371  0E3D  	SWAPF Int1BContext+D'1', W
0372  008A  	MOVWF PCLATH
0373  0E3C  	SWAPF Int1BContext, W
0374  0083  	MOVWF STATUS
0375  0EFF  	SWAPF Int1Context, F
0376  0E7F  	SWAPF Int1Context, W
0377  0009  	RETFIE





/*********************************************************************
 *                  Flowcode CAL I2C File
 *
 * File: PIC_CAL_I2C.c
 *
 * (c) 2011 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * “Company”) for its Flowcode graphical programming language is
 * intended and supplied to you, the Company’s customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 210911 | BR | Created
 * 021211 | BR | Converted to new dynamic defines mechanism
 *
 */


//When using hardware I2C channels override port and pin conns with FCD conn definitions
#ifdef MX_I2C_REF1
	#if MX_I2C_CHANNEL_1 > 0
		#undef MX_I2C_SDA_PIN_1
		#undef MX_I2C_SDA_PORT_1
		#undef MX_I2C_SDA_TRIS_1
		#undef MX_I2C_SCL_PIN_1
		#undef MX_I2C_SCL_PORT_1
		#undef MX_I2C_SCL_TRIS_1
	#endif
	#if MX_I2C_CHANNEL_1 == 1
		#define MX_I2C_SDA_PIN_1		MX_I2C_1_SDA_PIN
		#define MX_I2C_SDA_PORT_1		MX_I2C_1_SDA_PORT
		#define MX_I2C_SDA_TRIS_1		MX_I2C_1_SDA_TRIS
		#define MX_I2C_SCL_PIN_1		MX_I2C_1_SCL_PIN
		#define MX_I2C_SCL_PORT_1		MX_I2C_1_SCL_PORT
		#define MX_I2C_SCL_TRIS_1		MX_I2C_1_SCL_TRIS
	#endif
	#if MX_I2C_CHANNEL_1 == 2
		#define MX_I2C_SDA_PIN_1		MX_I2C_2_SDA_PIN
		#define MX_I2C_SDA_PORT_1		MX_I2C_2_SDA_PORT
		#define MX_I2C_SDA_TRIS_1		MX_I2C_2_SDA_TRIS
		#define MX_I2C_SCL_PIN_1		MX_I2C_2_SCL_PIN
		#define MX_I2C_SCL_PORT_1		MX_I2C_2_SCL_PORT
		#define MX_I2C_SCL_TRIS_1		MX_I2C_2_SCL_TRIS
	#endif
	#if MX_I2C_CHANNEL_1 == 3
		#define MX_I2C_SDA_PIN_1		MX_I2C_3_SDA_PIN
		#define MX_I2C_SDA_PORT_1		MX_I2C_3_SDA_PORT
		#define MX_I2C_SDA_TRIS_1		MX_I2C_3_SDA_TRIS
		#define MX_I2C_SCL_PIN_1		MX_I2C_3_SCL_PIN
		#define MX_I2C_SCL_PORT_1		MX_I2C_3_SCL_PORT
		#define MX_I2C_SCL_TRIS_1		MX_I2C_3_SCL_TRIS
	#endif
	#if MX_I2C_CHANNEL_1 == 4
		#define MX_I2C_SDA_PIN_1		MX_I2C_4_SDA_PIN
		#define MX_I2C_SDA_PORT_1		MX_I2C_4_SDA_PORT
		#define MX_I2C_SDA_TRIS_1		MX_I2C_4_SDA_TRIS
		#define MX_I2C_SCL_PIN_1		MX_I2C_4_SCL_PIN
		#define MX_I2C_SCL_PORT_1		MX_I2C_4_SCL_PORT
		#define MX_I2C_SCL_TRIS_1		MX_I2C_4_SCL_TRIS
	#endif
#endif
#ifdef MX_I2C_REF2
	#if MX_I2C_CHANNEL_2 > 0
		#undef MX_I2C_SDA_PIN_2
		#undef MX_I2C_SDA_PORT_2
		#undef MX_I2C_SDA_TRIS_2
		#undef MX_I2C_SCL_PIN_2
		#undef MX_I2C_SCL_PORT_2
		#undef MX_I2C_SCL_TRIS_2
	#endif
	#if MX_I2C_CHANNEL_2 == 1
		#define MX_I2C_SDA_PIN_2		MX_I2C_1_SDA_PIN
		#define MX_I2C_SDA_PORT_2		MX_I2C_1_SDA_PORT
		#define MX_I2C_SDA_TRIS_2		MX_I2C_1_SDA_TRIS
		#define MX_I2C_SCL_PIN_2		MX_I2C_1_SCL_PIN
		#define MX_I2C_SCL_PORT_2		MX_I2C_1_SCL_PORT
		#define MX_I2C_SCL_TRIS_2		MX_I2C_1_SCL_TRIS
	#endif
	#if MX_I2C_CHANNEL_2 == 2
		#define MX_I2C_SDA_PIN_2		MX_I2C_2_SDA_PIN
		#define MX_I2C_SDA_PORT_2		MX_I2C_2_SDA_PORT
		#define MX_I2C_SDA_TRIS_2		MX_I2C_2_SDA_TRIS
		#define MX_I2C_SCL_PIN_2		MX_I2C_2_SCL_PIN
		#define MX_I2C_SCL_PORT_2		MX_I2C_2_SCL_PORT
		#define MX_I2C_SCL_TRIS_2		MX_I2C_2_SCL_TRIS
	#endif
	#if MX_I2C_CHANNEL_2 == 3
		#define MX_I2C_SDA_PIN_2		MX_I2C_3_SDA_PIN
		#define MX_I2C_SDA_PORT_2		MX_I2C_3_SDA_PORT
		#define MX_I2C_SDA_TRIS_2		MX_I2C_3_SDA_TRIS
		#define MX_I2C_SCL_PIN_2		MX_I2C_3_SCL_PIN
		#define MX_I2C_SCL_PORT_2		MX_I2C_3_SCL_PORT
		#define MX_I2C_SCL_TRIS_2		MX_I2C_3_SCL_TRIS
	#endif
	#if MX_I2C_CHANNEL_2 == 4
		#define MX_I2C_SDA_PIN_2		MX_I2C_4_SDA_PIN
		#define MX_I2C_SDA_PORT_2		MX_I2C_4_SDA_PORT
		#define MX_I2C_SDA_TRIS_2		MX_I2C_4_SDA_TRIS
		#define MX_I2C_SCL_PIN_2		MX_I2C_4_SCL_PIN
		#define MX_I2C_SCL_PORT_2		MX_I2C_4_SCL_PORT
		#define MX_I2C_SCL_TRIS_2		MX_I2C_4_SCL_TRIS
	#endif
#endif
#ifdef MX_I2C_REF3
	#if MX_I2C_CHANNEL_3 > 0
		#undef MX_I2C_SDA_PIN_3
		#undef MX_I2C_SDA_PORT_3
		#undef MX_I2C_SDA_TRIS_3
		#undef MX_I2C_SCL_PIN_3
		#undef MX_I2C_SCL_PORT_3
		#undef MX_I2C_SCL_TRIS_3
	#endif
	#if MX_I2C_CHANNEL_3 == 1
		#define MX_I2C_SDA_PIN_3		MX_I2C_1_SDA_PIN
		#define MX_I2C_SDA_PORT_3		MX_I2C_1_SDA_PORT
		#define MX_I2C_SDA_TRIS_3		MX_I2C_1_SDA_TRIS
		#define MX_I2C_SCL_PIN_3		MX_I2C_1_SCL_PIN
		#define MX_I2C_SCL_PORT_3		MX_I2C_1_SCL_PORT
		#define MX_I2C_SCL_TRIS_3		MX_I2C_1_SCL_TRIS
	#endif
	#if MX_I2C_CHANNEL_3 == 2
		#define MX_I2C_SDA_PIN_3		MX_I2C_2_SDA_PIN
		#define MX_I2C_SDA_PORT_3		MX_I2C_2_SDA_PORT
		#define MX_I2C_SDA_TRIS_3		MX_I2C_2_SDA_TRIS
		#define MX_I2C_SCL_PIN_3		MX_I2C_2_SCL_PIN
		#define MX_I2C_SCL_PORT_3		MX_I2C_2_SCL_PORT
		#define MX_I2C_SCL_TRIS_3		MX_I2C_2_SCL_TRIS
	#endif
	#if MX_I2C_CHANNEL_3 == 3
		#define MX_I2C_SDA_PIN_3		MX_I2C_3_SDA_PIN
		#define MX_I2C_SDA_PORT_3		MX_I2C_3_SDA_PORT
		#define MX_I2C_SDA_TRIS_3		MX_I2C_3_SDA_TRIS
		#define MX_I2C_SCL_PIN_3		MX_I2C_3_SCL_PIN
		#define MX_I2C_SCL_PORT_3		MX_I2C_3_SCL_PORT
		#define MX_I2C_SCL_TRIS_3		MX_I2C_3_SCL_TRIS
	#endif
	#if MX_I2C_CHANNEL_3 == 4
		#define MX_I2C_SDA_PIN_3		MX_I2C_4_SDA_PIN
		#define MX_I2C_SDA_PORT_3		MX_I2C_4_SDA_PORT
		#define MX_I2C_SDA_TRIS_3		MX_I2C_4_SDA_TRIS
		#define MX_I2C_SCL_PIN_3		MX_I2C_4_SCL_PIN
		#define MX_I2C_SCL_PORT_3		MX_I2C_4_SCL_PORT
		#define MX_I2C_SCL_TRIS_3		MX_I2C_4_SCL_TRIS
	#endif
#endif
#ifdef MX_I2C_REF4
	#if MX_I2C_CHANNEL_4 > 0
		#undef MX_I2C_SDA_PIN_4
		#undef MX_I2C_SDA_PORT_4
		#undef MX_I2C_SDA_TRIS_4
		#undef MX_I2C_SCL_PIN_4
		#undef MX_I2C_SCL_PORT_4
		#undef MX_I2C_SCL_TRIS_4
	#endif
	#if MX_I2C_CHANNEL_4 == 1
		#define MX_I2C_SDA_PIN_4		MX_I2C_1_SDA_PIN
		#define MX_I2C_SDA_PORT_4		MX_I2C_1_SDA_PORT
		#define MX_I2C_SDA_TRIS_4		MX_I2C_1_SDA_TRIS
		#define MX_I2C_SCL_PIN_4		MX_I2C_1_SCL_PIN
		#define MX_I2C_SCL_PORT_4		MX_I2C_1_SCL_PORT
		#define MX_I2C_SCL_TRIS_4		MX_I2C_1_SCL_TRIS
	#endif
	#if MX_I2C_CHANNEL_4 == 2
		#define MX_I2C_SDA_PIN_4		MX_I2C_2_SDA_PIN
		#define MX_I2C_SDA_PORT_4		MX_I2C_2_SDA_PORT
		#define MX_I2C_SDA_TRIS_4		MX_I2C_2_SDA_TRIS
		#define MX_I2C_SCL_PIN_4		MX_I2C_2_SCL_PIN
		#define MX_I2C_SCL_PORT_4		MX_I2C_2_SCL_PORT
		#define MX_I2C_SCL_TRIS_4		MX_I2C_2_SCL_TRIS
	#endif
	#if MX_I2C_CHANNEL_4 == 3
		#define MX_I2C_SDA_PIN_4		MX_I2C_3_SDA_PIN
		#define MX_I2C_SDA_PORT_4		MX_I2C_3_SDA_PORT
		#define MX_I2C_SDA_TRIS_4		MX_I2C_3_SDA_TRIS
		#define MX_I2C_SCL_PIN_4		MX_I2C_3_SCL_PIN
		#define MX_I2C_SCL_PORT_4		MX_I2C_3_SCL_PORT
		#define MX_I2C_SCL_TRIS_4		MX_I2C_3_SCL_TRIS
	#endif
	#if MX_I2C_CHANNEL_4 == 4
		#define MX_I2C_SDA_PIN_4		MX_I2C_4_SDA_PIN
		#define MX_I2C_SDA_PORT_4		MX_I2C_4_SDA_PORT
		#define MX_I2C_SDA_TRIS_4		MX_I2C_4_SDA_TRIS
		#define MX_I2C_SCL_PIN_4		MX_I2C_4_SCL_PIN
		#define MX_I2C_SCL_PORT_4		MX_I2C_4_SCL_PORT
		#define MX_I2C_SCL_TRIS_4		MX_I2C_4_SCL_TRIS
	#endif
#endif

#define MX_I2C_CHANNEL_X		CAL_APPEND(MX_I2C_CHANNEL_, MX_I2C_NUM)
#define MX_I2C_SDA_PIN_X		CAL_APPEND(MX_I2C_SDA_PIN_, MX_I2C_NUM)
#define MX_I2C_SDA_PORT_X		CAL_APPEND(MX_I2C_SDA_PORT_, MX_I2C_NUM)
#define MX_I2C_SDA_TRIS_X		CAL_APPEND(MX_I2C_SDA_TRIS_, MX_I2C_NUM)
#define MX_I2C_SCL_PIN_X		CAL_APPEND(MX_I2C_SCL_PIN_, MX_I2C_NUM)
#define MX_I2C_SCL_PORT_X		CAL_APPEND(MX_I2C_SCL_PORT_, MX_I2C_NUM)
#define MX_I2C_SCL_TRIS_X		CAL_APPEND(MX_I2C_SCL_TRIS_, MX_I2C_NUM)
#define MX_I2C_BMODE_X			CAL_APPEND(MX_I2C_BMODE_, MX_I2C_NUM)
#define MX_I2C_BAUD_X			CAL_APPEND(MX_I2C_BAUD_, MX_I2C_NUM)
#define MX_I2C_INT_X			CAL_APPEND(MX_I2C_INT_, MX_I2C_NUM)


//Function Prototypes
CALFUNCTION(void, FC_CAL_I2C_Master_Init_, (void));
CALFUNCTION(void, FC_CAL_I2C_Master_Uninit_, (void));
CALFUNCTION(void, FC_CAL_I2C_Master_Start_, (void));
CALFUNCTION(void, FC_CAL_I2C_Master_Restart_, (void));
CALFUNCTION(void, FC_CAL_I2C_Master_Stop_, (void));
CALFUNCTION(MX_UINT8, FC_CAL_I2C_Master_TX_Byte_, (MX_UINT8 Data));
CALFUNCTION(MX_UINT8, FC_CAL_I2C_Master_RX_Byte_, (MX_UINT8 Last));

CALFUNCTION(void, FC_CAL_I2C_Slave_Init_, (void));
CALFUNCTION(void, FC_CAL_I2C_Slave_Uninit_, (void));
CALFUNCTION(void, FC_CAL_I2C_Slave_SetTxData_, (MX_UINT8 Data));
CALFUNCTION(MX_UINT8, FC_CAL_I2C_Slave_GetRxData_, (MX_UINT8 Last));


//Ensure SSPCON register is defined correctly
#ifndef SSPCON
  #ifdef SSPCON1
	#define sspcon	sspcon1
  #else
	#ifdef SSP1CON1
		#define sspcon	ssp1con1
	#endif
  #endif
#endif

//Ensure SSPIF register is defined correctly
#ifndef SSPIF
  #ifdef SSP1IF
	#define SSPIF	SSP1IF
  #else
	#error "I2C does not have the SSPIF defined on this chip - does your chip support this feature?"
  #endif
#endif


//Ensure SSPCON2 register is defined correctly
#ifndef SSPCON2
  #ifdef SSP1CON2
	#define sspcon2	ssp1con2
  #endif
#endif


//Ensure SSPSTAT register is defined correctly
#ifndef SSPSTAT
  #ifdef SSP1STAT
	#define sspstat	ssp1stat
  #endif
#endif


//Ensure SSPADD register is defined correctly
#ifndef SSPADD
  #ifdef SSP1ADD
	#define sspadd	ssp1add
  #endif
#endif


//Ensure SSPBUFF register is defined correctly
#ifndef SSPBUFF
  #ifdef SSP1BUFF
	#define sspbuff	ssp1buff
  #endif
#endif


//If software channel is enabled then define bit delay.
#if (MX_I2C_CHANNEL_X == 0)
  #ifndef MX_I2C_SW_DEL
	#define MX_I2C_SW_DEL
	#define MX_I2C_DELAY	delay_us(20);
  #endif
#endif


CALFUNCTION(void, FC_CAL_I2C_Master_Init_, (void))

{

	#if (MX_I2C_CHANNEL_X == 0)															//Use Master I2C Software
		FC_CAL_Bit_In_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);		//Configure SDA as Input
010A  1683  	BSF STATUS, RP0
010B  1303  	BCF STATUS, RP1
010C  1607  	BSF gbl_trisc,4

		FC_CAL_Bit_In_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);		//Configure SCL as Input
010D  1587  	BSF gbl_trisc,3

	#endif

	#if (MX_I2C_CHANNEL_X == 1)												//Use Master I2C Hardware 1
		#ifndef MX_MI2C
			#error "This chip does not have Master I2C capability"
		#else

			#ifndef MX_I2C_1
				#error "This chip does not have Master I2C channel 1"
			#endif

			#if (MX_I2C_BMODE_X & 0x01)
				cr_bit (sspstat,SMP);										//Slew Rate Control Enabled
			#else
				st_bit (sspstat,SMP);										//Slew Rate Control Disabled
		    #endif

			#if (MX_I2C_BMODE_X & 0x02)
				st_bit (sspstat,CKE);										//Enable SMBus specific inputs
			#else
				cr_bit (sspstat,CKE);										//Disable SMBus specific inputs
			#endif

			sspcon = 0x28;													//Setup I2C into Master Mode
			sspadd = MX_I2C_BAUD_X;											//Set the Baud Rate
			sspcon2 = 0x00;													//Clear the control bits
			st_bit(intcon, GIE);
			FC_CAL_Bit_In_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);		//Configure SDA as Input
			FC_CAL_Bit_In_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);		//Configure SCL as Input
		#endif
	#endif

	#if (MX_I2C_CHANNEL_X == 2)												//Use Master I2C Hardware 2
		#ifndef MX_MI2C
			#error "This chip does not have Master I2C capability"
		#else

			#ifndef MX_I2C_2
				#error "This chip does not have Master I2C channel 2"
			#endif

		  #ifdef MX_I2C_2_REMAPPABLE
			RPOR4 = 9;														//SDA2 - RB1 - RP4
			RPOR5 = 10;														//SCL2 - RB2 - RP5
		  #endif

			#if (MX_I2C_BMODE_X & 0x01)
				cr_bit (ssp2stat,SMP);										//Slew Rate Control Enabled
			#else
				st_bit (ssp2stat,SMP);										//Slew Rate Control Disabled
			#endif

			#if (MX_I2C_BMODE_X & 0x02)
				st_bit (ssp2stat,CKE);										//Enable SMBus specific inputs
			#else
				cr_bit (ssp2stat,CKE);										//Disable SMBus specific inputs
			#endif

			ssp2con = 0x28;													//Setup I2C into Master Mode
			ssp2add = MX_I2C_BAUD_X;										//Set the Baud Rate
			ssp2con2 = 0x00;												//Clear the control bits
			st_bit(intcon, GIE);
			FC_CAL_Bit_In_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);			//Configure SDA as Input
			FC_CAL_Bit_In_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);			//Configure SCL as Input
		#endif
	#endif
}
010E  0008  	RETURN


CALFUNCTION(void, FC_CAL_I2C_Master_Uninit_, (void))
{
	#if (MX_I2C_CHANNEL_X == 0)																//Use Master I2C Software
		FC_CAL_Bit_In_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);			//Configure SDA as Input
		FC_CAL_Bit_In_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);			//Configure SCL as Input
	#endif

	#if (MX_I2C_CHANNEL_X == 1)												//Use Master I2C Hardware 1
		cr_bit(sspcon, SSPEN);												//Disable SSP
	#endif

	#if (MX_I2C_CHANNEL_X == 2)												//Use Master I2C Hardware 2
		cr_bit(ssp2con, SSPEN);												//Disable SSP
	#endif
}

CALFUNCTION(void, FC_CAL_I2C_Master_Start_, (void))

{
	#if (MX_I2C_CHANNEL_X == 0)															//Use Master I2C Software
		FC_CAL_Bit_In_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);		//Make Sure SCL is Set
00F3  1683  	BSF STATUS, RP0
00F4  1303  	BCF STATUS, RP1
00F5  1587  	BSF gbl_trisc,3

		FC_CAL_Bit_In_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);		//Make Sure SDA is Set
00F6  1607  	BSF gbl_trisc,4

		MX_I2C_DELAY;																	//Small Delay
00F7  3014  	MOVLW 0x14
00F8  1283  	BCF STATUS, RP0
00F9  00DE  	MOVWF delay_us_00000_arg_del
00FA  2010  	CALL delay_us_00000

		FC_CAL_Bit_Low_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);		//Clear SDA
00FB  1683  	BSF STATUS, RP0
00FC  1207  	BCF gbl_trisc,4
00FD  1283  	BCF STATUS, RP0
00FE  1207  	BCF gbl_portc,4

		MX_I2C_DELAY;																	//Small Delay
00FF  3014  	MOVLW 0x14
0100  00DE  	MOVWF delay_us_00000_arg_del
0101  2010  	CALL delay_us_00000

		FC_CAL_Bit_Low_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);		//Clear SCL
0102  1683  	BSF STATUS, RP0
0103  1187  	BCF gbl_trisc,3
0104  1283  	BCF STATUS, RP0
0105  1187  	BCF gbl_portc,3

		MX_I2C_DELAY;																	//Small Delay
0106  3014  	MOVLW 0x14
0107  00DE  	MOVWF delay_us_00000_arg_del
0108  2010  	CALL delay_us_00000

	#endif

	#if (MX_I2C_CHANNEL_X == 1)												//Use Master I2C Hardware 1
		cr_bit(pir1, SSPIF);												//Clear SSP interrupt flag
		st_bit(sspcon2,SEN);												//Initiate start condition
		while(ts_bit(sspcon2,SEN));											//Wait for start bit to be generated
	#endif

	#if (MX_I2C_CHANNEL_X == 2)												//Use Master I2C Hardware 2
		cr_bit(pir3, SSP2IF);												//Clear SSP interrupt flag
		st_bit(ssp2con2,SEN);												//Initiate start condition
		while(ts_bit(ssp2con2,SEN));										//Wait for start bit to be generated
	#endif
}
0109  0008  	RETURN


CALFUNCTION(void, FC_CAL_I2C_Master_Restart_, (void))

{
	#if (MX_I2C_CHANNEL_X == 0)															//Use Master I2C Software
		FC_CAL_Bit_In_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);		//Set SDA High
00D7  1683  	BSF STATUS, RP0
00D8  1303  	BCF STATUS, RP1
00D9  1607  	BSF gbl_trisc,4

		MX_I2C_DELAY;
00DA  3014  	MOVLW 0x14
00DB  1283  	BCF STATUS, RP0
00DC  00DE  	MOVWF delay_us_00000_arg_del
00DD  2010  	CALL delay_us_00000

		FC_CAL_Bit_In_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);		//Set SCL High
00DE  1683  	BSF STATUS, RP0
00DF  1587  	BSF gbl_trisc,3

		MX_I2C_DELAY;
00E0  3014  	MOVLW 0x14
00E1  1283  	BCF STATUS, RP0
00E2  00DE  	MOVWF delay_us_00000_arg_del
00E3  2010  	CALL delay_us_00000

		FC_CAL_Bit_Low_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);		//Set SDA Low
00E4  1683  	BSF STATUS, RP0
00E5  1207  	BCF gbl_trisc,4
00E6  1283  	BCF STATUS, RP0
00E7  1207  	BCF gbl_portc,4

		MX_I2C_DELAY;
00E8  3014  	MOVLW 0x14
00E9  00DE  	MOVWF delay_us_00000_arg_del
00EA  2010  	CALL delay_us_00000

		FC_CAL_Bit_Low_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);		//Set SCL Low
00EB  1683  	BSF STATUS, RP0
00EC  1187  	BCF gbl_trisc,3
00ED  1283  	BCF STATUS, RP0
00EE  1187  	BCF gbl_portc,3

		MX_I2C_DELAY;
00EF  3014  	MOVLW 0x14
00F0  00DE  	MOVWF delay_us_00000_arg_del
00F1  2010  	CALL delay_us_00000

	#endif

	#if (MX_I2C_CHANNEL_X == 1)												//Use Master I2C Hardware 1
		cr_bit(pir1, SSPIF);												//Clear SSP interrupt flag
		st_bit(sspcon2,RSEN);												//Initiate restart condition
		while(ts_bit(sspcon2,RSEN));										//Wait for restart bit to be generated
	#endif

	#if (MX_I2C_CHANNEL_X == 2)												//Use Master I2C Hardware 2
		cr_bit(pir3, SSP2IF);												//Clear SSP interrupt flag
		st_bit(ssp2con2,RSEN);												//Initiate restart condition
		while(ts_bit(ssp2con2,RSEN));										//Wait for restart bit to be generated
	#endif
}
00F2  0008  	RETURN


CALFUNCTION(void, FC_CAL_I2C_Master_Stop_, (void))

{
	#if (MX_I2C_CHANNEL_X == 0)															//Use Master I2C Software
		FC_CAL_Bit_Low_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);		//Set SCL Low
00BE  1683  	BSF STATUS, RP0
00BF  1303  	BCF STATUS, RP1
00C0  1187  	BCF gbl_trisc,3
00C1  1283  	BCF STATUS, RP0
00C2  1187  	BCF gbl_portc,3

		FC_CAL_Bit_Low_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);		//Set SDA Low
00C3  1683  	BSF STATUS, RP0
00C4  1207  	BCF gbl_trisc,4
00C5  1283  	BCF STATUS, RP0
00C6  1207  	BCF gbl_portc,4

		MX_I2C_DELAY;
00C7  3014  	MOVLW 0x14
00C8  00DE  	MOVWF delay_us_00000_arg_del
00C9  2010  	CALL delay_us_00000

		FC_CAL_Bit_In_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);		//Set SCL High
00CA  1683  	BSF STATUS, RP0
00CB  1587  	BSF gbl_trisc,3

		MX_I2C_DELAY;
00CC  3014  	MOVLW 0x14
00CD  1283  	BCF STATUS, RP0
00CE  00DE  	MOVWF delay_us_00000_arg_del
00CF  2010  	CALL delay_us_00000

		FC_CAL_Bit_In_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);		//Set SDA High
00D0  1683  	BSF STATUS, RP0
00D1  1607  	BSF gbl_trisc,4

	#endif

	#if (MX_I2C_CHANNEL_X == 1)												//Use Master I2C Hardware 1
		cr_bit(pir1,SSPIF);													//Clear SSP interrupt flag
		st_bit(sspcon2,PEN);												//Initiate stop condition
		while(ts_bit(sspcon2,PEN));											//Wait for stop bit to be generated
	#endif

	#if (MX_I2C_CHANNEL_X == 2)												//Use Master I2C Hardware 2
		cr_bit(pir3,SSP2IF);												//Clear SSP interrupt flag
		st_bit(ssp2con2,PEN);												//Initiate stop condition
		while(ts_bit(ssp2con2,PEN));										//Wait for stop bit to be generated
	#endif

  delay_ms(10);																//Wait before reusing the I2C BUS
00D2  300A  	MOVLW 0x0A
00D3  1283  	BCF STATUS, RP0
00D4  00DB  	MOVWF delay_ms_00000_arg_del
00D5  201A  	CALL delay_ms_00000

}
00D6  0008  	RETURN


CALFUNCTION(MX_UINT8, FC_CAL_I2C_Master_TX_Byte_, (MX_UINT8 Data))

{
	#if (MX_I2C_CHANNEL_X == 0)												//Use Master I2C Software
		char bit_mask;
		char local_ack = 0;
0078  01DD  	CLRF FC_CAL_I2C_00061_1_local_ack

		for(bit_mask=0x80;bit_mask;bit_mask=bit_mask>>1)
0079  3080  	MOVLW 0x80
007A  00DC  	MOVWF FC_CAL_I2C_00061_1_bit_mask
007B        label10
007B  08DC  	MOVF FC_CAL_I2C_00061_1_bit_mask, F
007C  1903  	BTFSC STATUS,Z
007D  289E  	GOTO	label13
009A  08DC  	MOVF FC_CAL_I2C_00061_1_bit_mask, F
009B  1003  	BCF STATUS,C
009C  0CDC  	RRF FC_CAL_I2C_00061_1_bit_mask, F
009D  287B  	GOTO	label10
009E        label13

		{
			if(Data & bit_mask)
007E  085C  	MOVF FC_CAL_I2C_00061_1_bit_mask, W
007F  055B  	ANDWF FC_CAL_I2C_00061_arg_Data, W
0080  1903  	BTFSC STATUS,Z
0081  2885  	GOTO	label11
0085        label11

			{
				FC_CAL_Bit_In_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);	//Set SDA High
0082  1683  	BSF STATUS, RP0
0083  1607  	BSF gbl_trisc,4

			}
			else
0084  2889  	GOTO	label12
0089        label12

			{
				FC_CAL_Bit_Low_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);	//Set SDA Low
0085  1683  	BSF STATUS, RP0
0086  1207  	BCF gbl_trisc,4
0087  1283  	BCF STATUS, RP0
0088  1207  	BCF gbl_portc,4

			}
			MX_I2C_DELAY;
0089  3014  	MOVLW 0x14
008A  1283  	BCF STATUS, RP0
008B  00DE  	MOVWF delay_us_00000_arg_del
008C  2010  	CALL delay_us_00000

			FC_CAL_Bit_In_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);		//Set SCL High
008D  1683  	BSF STATUS, RP0
008E  1587  	BSF gbl_trisc,3

			MX_I2C_DELAY;
008F  3014  	MOVLW 0x14
0090  1283  	BCF STATUS, RP0
0091  00DE  	MOVWF delay_us_00000_arg_del
0092  2010  	CALL delay_us_00000

			FC_CAL_Bit_Low_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);		//Set SCL Low
0093  1683  	BSF STATUS, RP0
0094  1187  	BCF gbl_trisc,3
0095  1283  	BCF STATUS, RP0
0096  1187  	BCF gbl_portc,3

			MX_I2C_DELAY;
0097  3014  	MOVLW 0x14
0098  00DE  	MOVWF delay_us_00000_arg_del
0099  2010  	CALL delay_us_00000

		}
		FC_CAL_Bit_In_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);			//Set SDA High
009E  1683  	BSF STATUS, RP0
009F  1607  	BSF gbl_trisc,4

		MX_I2C_DELAY;
00A0  3014  	MOVLW 0x14
00A1  1283  	BCF STATUS, RP0
00A2  00DE  	MOVWF delay_us_00000_arg_del
00A3  2010  	CALL delay_us_00000

		FC_CAL_Bit_In_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);			//Set SCL High
00A4  1683  	BSF STATUS, RP0
00A5  1587  	BSF gbl_trisc,3

		MX_I2C_DELAY;
00A6  3014  	MOVLW 0x14
00A7  1283  	BCF STATUS, RP0
00A8  00DE  	MOVWF delay_us_00000_arg_del
00A9  2010  	CALL delay_us_00000

		FC_CAL_Bit_In_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);
00AA  1683  	BSF STATUS, RP0
00AB  1607  	BSF gbl_trisc,4

		if (FC_CAL_Bit_In(MX_I2C_SDA_PORT_X, MX_I2C_SDA_PIN_X))		//Get the Status Bit
00AC  1283  	BCF STATUS, RP0
00AD  1E07  	BTFSS gbl_portc,4
00AE  28B1  	GOTO	label14
00B1        label14

			local_ack = 1;
00AF  3001  	MOVLW 0x01
00B0  00DD  	MOVWF FC_CAL_I2C_00061_1_local_ack

		MX_I2C_DELAY;
00B1  3014  	MOVLW 0x14
00B2  00DE  	MOVWF delay_us_00000_arg_del
00B3  2010  	CALL delay_us_00000

		FC_CAL_Bit_Low_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);			//Set SCL Low
00B4  1683  	BSF STATUS, RP0
00B5  1187  	BCF gbl_trisc,3
00B6  1283  	BCF STATUS, RP0
00B7  1187  	BCF gbl_portc,3

		MX_I2C_DELAY;
00B8  3014  	MOVLW 0x14
00B9  00DE  	MOVWF delay_us_00000_arg_del
00BA  2010  	CALL delay_us_00000

		return (local_ack);													//0 = Ack received : 1 = Ack not received
00BB  085D  	MOVF FC_CAL_I2C_00061_1_local_ack, W
00BC  00DE  	MOVWF CompTempVarRet2226

	#endif

	#if (MX_I2C_CHANNEL_X == 1)												//Use Master I2C Hardware 1
		cr_bit(pir1,SSPIF);													//Clear SSP interrupt flag
		sspbuf=Data;														//Send byte
		while(ts_bit(pir1,SSPIF) == 0);										//Wait for control bit to be sent
		if(ts_bit(sspcon2,ACKSTAT))											//Check Acknowledgement
			return (1);														//No Acknowledgement
		else return (0);													//Acknowledgement received
	#endif

	#if (MX_I2C_CHANNEL_X == 2)												//Use Master I2C Hardware 2
		cr_bit(pir3,SSP2IF);												//Clear SSP interrupt flag
		ssp2buf=Data;														//Send byte
		while(ts_bit(pir3,SSP2IF) == 0);									//Wait for control bit to be sent
		if(ts_bit(ssp2con2,ACKSTAT))										//Check Acknowledgement
			return (1);														//No Acknowledgement
		else return (0);													//Acknowledgement received
	#endif
}
00BD  0008  	RETURN


CALFUNCTION(MX_UINT8, FC_CAL_I2C_Master_RX_Byte_, (MX_UINT8 Last))

{
	#if (MX_I2C_CHANNEL_X == 0)												//Use Master I2C Software
		char bit_mask;
		char Data = 0;
0035  01DD  	CLRF FC_CAL_I2C_00062_1_Data

		char local_ack;
		FC_CAL_Bit_In_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);			//Set SDA High
0036  1683  	BSF STATUS, RP0
0037  1607  	BSF gbl_trisc,4

		MX_I2C_DELAY;
0038  3014  	MOVLW 0x14
0039  1283  	BCF STATUS, RP0
003A  00DE  	MOVWF delay_us_00000_arg_del
003B  2010  	CALL delay_us_00000

		for(bit_mask=0x80;bit_mask;bit_mask=bit_mask>>1)
003C  3080  	MOVLW 0x80
003D  00DC  	MOVWF FC_CAL_I2C_00062_1_bit_mask
003E        label5
003E  08DC  	MOVF FC_CAL_I2C_00062_1_bit_mask, F
003F  1903  	BTFSC STATUS,Z
0040  285A  	GOTO	label7
0056  08DC  	MOVF FC_CAL_I2C_00062_1_bit_mask, F
0057  1003  	BCF STATUS,C
0058  0CDC  	RRF FC_CAL_I2C_00062_1_bit_mask, F
0059  283E  	GOTO	label5
005A        label7

		{
			FC_CAL_Bit_In_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);		//Set SCL High
0041  1683  	BSF STATUS, RP0
0042  1587  	BSF gbl_trisc,3

			MX_I2C_DELAY;
0043  3014  	MOVLW 0x14
0044  1283  	BCF STATUS, RP0
0045  00DE  	MOVWF delay_us_00000_arg_del
0046  2010  	CALL delay_us_00000

			FC_CAL_Bit_In_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);
0047  1683  	BSF STATUS, RP0
0048  1607  	BSF gbl_trisc,4

			if(FC_CAL_Bit_In(MX_I2C_SDA_PORT_X, MX_I2C_SDA_PIN_X))	//Read Incoming Bit
0049  1283  	BCF STATUS, RP0
004A  1E07  	BTFSS gbl_portc,4
004B  284F  	GOTO	label6
004F        label6

				Data = Data | bit_mask;														//Add data to variable
004C  085C  	MOVF FC_CAL_I2C_00062_1_bit_mask, W
004D  045D  	IORWF FC_CAL_I2C_00062_1_Data, W
004E  00DD  	MOVWF FC_CAL_I2C_00062_1_Data

			FC_CAL_Bit_Low_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);		//Set SCL Low
004F  1683  	BSF STATUS, RP0
0050  1187  	BCF gbl_trisc,3
0051  1283  	BCF STATUS, RP0
0052  1187  	BCF gbl_portc,3

			MX_I2C_DELAY;
0053  3014  	MOVLW 0x14
0054  00DE  	MOVWF delay_us_00000_arg_del
0055  2010  	CALL delay_us_00000

		}
		if (Last)																		//Acknowledge?
005A  08DB  	MOVF FC_CAL_I2C_00062_arg_Last, F
005B  1903  	BTFSC STATUS,Z
005C  2860  	GOTO	label8
0060        label8

		{
			FC_CAL_Bit_In_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);	//Send Nack
005D  1683  	BSF STATUS, RP0
005E  1607  	BSF gbl_trisc,4

		}
		else
005F  2864  	GOTO	label9
0064        label9

		{
			FC_CAL_Bit_Low_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);	//Send Ack
0060  1683  	BSF STATUS, RP0
0061  1207  	BCF gbl_trisc,4
0062  1283  	BCF STATUS, RP0
0063  1207  	BCF gbl_portc,4

		}
		MX_I2C_DELAY;
0064  3014  	MOVLW 0x14
0065  1283  	BCF STATUS, RP0
0066  00DE  	MOVWF delay_us_00000_arg_del
0067  2010  	CALL delay_us_00000

		FC_CAL_Bit_In_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);		//Set SCL High
0068  1683  	BSF STATUS, RP0
0069  1587  	BSF gbl_trisc,3

		MX_I2C_DELAY;
006A  3014  	MOVLW 0x14
006B  1283  	BCF STATUS, RP0
006C  00DE  	MOVWF delay_us_00000_arg_del
006D  2010  	CALL delay_us_00000

		FC_CAL_Bit_Low_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);		//Set SCL Low
006E  1683  	BSF STATUS, RP0
006F  1187  	BCF gbl_trisc,3
0070  1283  	BCF STATUS, RP0
0071  1187  	BCF gbl_portc,3

		MX_I2C_DELAY;
0072  3014  	MOVLW 0x14
0073  00DE  	MOVWF delay_us_00000_arg_del
0074  2010  	CALL delay_us_00000

		return (Data);
0075  085D  	MOVF FC_CAL_I2C_00062_1_Data, W
0076  00DE  	MOVWF CompTempVarRet2228

	#endif

	#if (MX_I2C_CHANNEL_X == 1)						//Use Master I2C Hardware 1
		cr_bit(pir1,SSPIF);							//Clear SSP interrupt flag
		st_bit(sspcon2,RCEN);						//Initiate Read
		while(ts_bit(pir1,3) == 0);					//Wait for data read
		if (Last)
			st_bit(sspcon2,ACKDT);					//Send Nack
		else cr_bit(sspcon2,ACKDT);					//Send Ack
		st_bit(sspcon2,ACKEN);						//Initiate Nack
		while(ts_bit(sspcon2,ACKEN));				//Wait for data read
		return(sspbuf);								//Store incoming data
	#endif

	#if (MX_I2C_CHANNEL_X == 2)						//Use Master I2C Hardware 2
		cr_bit(pir3,SSP2IF);						//Clear SSP interrupt flag
		st_bit(ssp2con2,RCEN);						//Initiate Read
		while(ts_bit(pir3,SSP2IF) == 0);			//Wait for data read
		if (Last)
			st_bit(ssp2con2,ACKDT);					//Send Nack
		else cr_bit(ssp2con2,ACKDT);				//Send Ack
		st_bit(ssp2con2,ACKEN);						//Initiate Nack
		while(ts_bit(ssp2con2,ACKEN));				//Wait for data read
		return(ssp2buf);							//Store incoming data
	#endif
}
0077  0008  	RETURN





//Slave functions currently not implemented
CALFUNCTION(void, FC_CAL_I2C_Slave_Init_, (void))
{

}

CALFUNCTION(void, FC_CAL_I2C_Slave_Uninit_, (void))
{

}

CALFUNCTION(void, FC_CAL_I2C_Slave_SetTxData_, (MX_UINT8 Data))
{

}

CALFUNCTION(MX_UINT8, FC_CAL_I2C_Slave_GetRxData_, (MX_UINT8 Last))
{

}


////////////////////////////////////////
// Code with no source :-)
////////////////////////////////////////
0000  2B2A  	GOTO	_startup

0004  00FF  	MOVWF Int1Context
0005  0E03  	SWAPF STATUS, W
0006  1283  	BCF STATUS, RP0
0007  1303  	BCF STATUS, RP1
0008  00BC  	MOVWF Int1BContext
0009  0E0A  	SWAPF PCLATH, W
000A  00BD  	MOVWF Int1BContext+D'1'
000B  0E04  	SWAPF FSR, W
000C  00BE  	MOVWF Int1BContext+D'2'
000D  118A  	BCF PCLATH,3
000E  120A  	BCF PCLATH,4
000F  2B6D  	GOTO	interrupt
0010        delay_us_00000
0010        ; { delay_us ; function begin
0010  3003  	MOVLW 0x03
0011  07DE  	ADDWF delay_us_00000_arg_del, F
0012  0CDE  	RRF delay_us_00000_arg_del, F
0013  0CDE  	RRF delay_us_00000_arg_del, F
0014  307F  	MOVLW 0x7F
0015  05DE  	ANDWF delay_us_00000_arg_del, F
0016        label1
0016  0000  	NOP
0017  0BDE  	DECFSZ delay_us_00000_arg_del, F
0018  2816  	GOTO	label1
0019  0008  	RETURN
001A        ; } delay_us function end

001A        delay_ms_00000
001A        ; { delay_ms ; function begin
001A  08DB  	MOVF delay_ms_00000_arg_del, F
001B  1D03  	BTFSS STATUS,Z
001C  281E  	GOTO	label2
001D  0008  	RETURN
001E        label2
001E  30F9  	MOVLW 0xF9
001F        label3
001F  3EFF  	ADDLW 0xFF
0020  1D03  	BTFSS STATUS,Z
0021  281F  	GOTO	label3
0022  0000  	NOP
0023  0BDB  	DECFSZ delay_ms_00000_arg_del, F
0024  281E  	GOTO	label2
0025  0008  	RETURN
0026        ; } delay_ms function end

0026        delay_s_00000
0026        ; { delay_s ; function begin
0026        label4
0026  30FA  	MOVLW 0xFA
0027  00DB  	MOVWF delay_ms_00000_arg_del
0028  201A  	CALL delay_ms_00000
0029  30FA  	MOVLW 0xFA
002A  00DB  	MOVWF delay_ms_00000_arg_del
002B  201A  	CALL delay_ms_00000
002C  30FA  	MOVLW 0xFA
002D  00DB  	MOVWF delay_ms_00000_arg_del
002E  201A  	CALL delay_ms_00000
002F  30FA  	MOVLW 0xFA
0030  00DB  	MOVWF delay_ms_00000_arg_del
0031  201A  	CALL delay_ms_00000
0032  0BDA  	DECFSZ delay_s_00000_arg_del, F
0033  2826  	GOTO	label4
0034  0008  	RETURN
0035        ; } delay_s function end


0257        __rem_8_8_00000
0257        ; { __rem_8_8 ; function begin
0257  01E0  	CLRF CompTempVarRet220
0258  01DE  	CLRF __rem_8_8_00000_1_c
0259  01DF  	CLRF __rem_8_8_00000_1_i
025A        label27
025A  19DF  	BTFSC __rem_8_8_00000_1_i,3
025B  0008  	RETURN
025C  1003  	BCF STATUS,C
025D  0DDE  	RLF __rem_8_8_00000_1_c, F
025E  0DDC  	RLF __rem_8_8_00000_arg_a, F
025F  0DE0  	RLF CompTempVarRet220, F
0260  085D  	MOVF __rem_8_8_00000_arg_b, W
0261  0260  	SUBWF CompTempVarRet220, W
0262  1C03  	BTFSS STATUS,C
0263  2A66  	GOTO	label28
0264  00E0  	MOVWF CompTempVarRet220
0265  145E  	BSF __rem_8_8_00000_1_c,0
0266        label28
0266  0ADF  	INCF __rem_8_8_00000_1_i, F
0267  2A5A  	GOTO	label27
0268        ; } __rem_8_8 function end

0268        __div_8_8_00000
0268        ; { __div_8_8 ; function begin
0268  01DE  	CLRF __div_8_8_00000_1_r
0269  01E0  	CLRF CompTempVarRet218
026A  01DF  	CLRF __div_8_8_00000_1_i
026B        label29
026B  19DF  	BTFSC __div_8_8_00000_1_i,3
026C  0008  	RETURN
026D  1003  	BCF STATUS,C
026E  0DE0  	RLF CompTempVarRet218, F
026F  0DDA  	RLF __div_8_8_00000_arg_a, F
0270  0DDE  	RLF __div_8_8_00000_1_r, F
0271  085B  	MOVF __div_8_8_00000_arg_b, W
0272  025E  	SUBWF __div_8_8_00000_1_r, W
0273  1C03  	BTFSS STATUS,C
0274  2A77  	GOTO	label30
0275  00DE  	MOVWF __div_8_8_00000_1_r
0276  1460  	BSF CompTempVarRet218,0
0277        label30
0277  0ADF  	INCF __div_8_8_00000_1_i, F
0278  2A6B  	GOTO	label29
0279        ; } __div_8_8 function end


032A        _startup
032A  30D5  	MOVLW 0xD5
032B  1283  	BCF STATUS, RP0
032C  1303  	BCF STATUS, RP1
032D  00A0  	MOVWF gbl_14_LSR
032E  30C4  	MOVLW 0xC4
032F  00A1  	MOVWF gbl_14_LSR+D'1'
0330  30BB  	MOVLW 0xBB
0331  00A2  	MOVWF gbl_14_LSR+D'2'
0332  30DC  	MOVLW 0xDC
0333  00A3  	MOVWF gbl_14_LSR+D'3'
0334  01A4  	CLRF gbl_15_gbl_aSig
0335  01A5  	CLRF gbl_15_gbl_aSig+D'1'
0336  01A6  	CLRF gbl_15_gbl_aSig+D'2'
0337  01A7  	CLRF gbl_15_gbl_aSig+D'3'
0338  01A8  	CLRF gbl_15_gbl_bSig
0339  01A9  	CLRF gbl_15_gbl_bSig+D'1'
033A  01AA  	CLRF gbl_15_gbl_bSig+D'2'
033B  01AB  	CLRF gbl_15_gbl_bSig+D'3'
033C  01AC  	CLRF gbl_15_gbl_zSig
033D  01AD  	CLRF gbl_15_gbl_zSig+D'1'
033E  01AE  	CLRF gbl_15_gbl_zSig+D'2'
033F  01AF  	CLRF gbl_15_gbl_zSig+D'3'
0340  01C4  	CLRF gbl_15_gbl_aExp
0341  01C5  	CLRF gbl_15_gbl_bExp
0342  01BF  	CLRF gbl_15_gbl_zExp
0343  01C0  	CLRF gbl_15_gbl_zExp+D'1'
0344  01C6  	CLRF gbl_15_gbl_aSign
0345  01C7  	CLRF gbl_15_gbl_bSign
0346  01C8  	CLRF gbl_15_gbl_zSign
0347  01C9  	CLRF gbl_15_gbl_zSigZero
0348  01B0  	CLRF gbl_15_gbl_ret
0349  01B1  	CLRF gbl_15_gbl_ret+D'1'
034A  01B2  	CLRF gbl_15_gbl_ret+D'2'
034B  01B3  	CLRF gbl_15_gbl_ret+D'3'
034C  01C2  	CLRF gbl_float_rounding_mode
034D  01C3  	CLRF gbl_float_exception_flags
034E  01C1  	CLRF gbl_float_detect_tininess

036A  118A  	BCF PCLATH,3
036B  120A  	BCF PCLATH,4
036C  2AF0  	GOTO	main

2007  20D4  	DW 0x20D4
2008  3EFF  	DW 0x3EFF
