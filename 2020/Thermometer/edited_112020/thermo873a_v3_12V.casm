;/////////////////////////////////////////////////////////////////////////////////
;// Code Generator: BoostC Compiler - http://www.sourceboost.com
;// Version       : 7.03
;// License Type  : Pro License
;// Limitations   : PIC12,PIC16 max code size:Unlimited, max RAM banks:Unlimited
;/////////////////////////////////////////////////////////////////////////////////

//************************************************************************************
//**  
//**  File name:     C:\Users\gerpe\OneDrive\GER-PER 2016\Documents\KennyNeutron\2020\Thermometer\edited_112020\thermo873a_v3_12V.c
//**  Title:         
//**  Description:   
//**  
//**  Generated by:  Flowcode v5.2.0.0
//**  Date:          Tuesday, December 01, 2020 12:32:25
//**  Licence:       Professional
//**  Registered to: xyz
//**  Licence key:   WUK7B9
//**  
//**  
//**  http://www.matrixmultimedia.com
//**  
//************************************************************************************


#define MX_PIC

#define MX_USES_UINT8 1
#define MX_USES_SINT16 1
#define MX_USES_CHAR 0
#define MX_USES_FLOAT 0
#define MX_USES_SINT32 1
#define MX_USES_BOOL 1
#define MX_USES_UINT16 1
#define MX_USES_UINT32 0
//Defines for microcontroller
#define P16F873A
#define FC_CAL_PIC
#define MX_ADC
#define MX_ADC_TYPE_1
#define MX_ADC_BITS_10
#define MX_EE
#define MX_EE_TYPE2
#define MX_EE_SIZE 128
#define MX_SPI_1
#define MX_SPI_1_MISO_PORT portc
#define MX_SPI_1_MISO_TRIS trisc
#define MX_SPI_1_MISO_PIN 4
#define MX_SPI_1_MOSI_PORT portc
#define MX_SPI_1_MOSI_TRIS trisc
#define MX_SPI_1_MOSI_PIN 5
#define MX_SPI_1_CLK_PORT portc
#define MX_SPI_1_CLK_TRIS trisc
#define MX_SPI_1_CLK_PIN 3
#define MX_SPI_1_SS_PORT portc
#define MX_SPI_1_SS_TRIS trisc
#define MX_UART_1
#define MX_UART_1_TX_PORT portc
#define MX_UART_1_TX_TRIS trisc
#define MX_UART_1_TX_PIN 6
#define MX_UART_1_RX_PORT portc
#define MX_UART_1_RX_TRIS trisc
#define MX_UART_1_RX_PIN 7
#define MX_I2C
#define MX_MI2C
#define MX_I2C_1
#define MX_I2C_1_SDA_PORT portc
#define MX_I2C_1_SDA_TRIS trisc
#define MX_I2C_1_SDA_PIN 4
#define MX_I2C_1_SCL_PORT portc
#define MX_I2C_1_SCL_TRIS trisc
#define MX_I2C_1_SCL_PIN 3
#define MX_PWM
#define MX_PWM_CNT 2
#define MX_PWM_PSCA1
#define MX_PWM_PSCA4
#define MX_PWM_PSCA16
#define MX_PWM_1_PORT portc
#define MX_PWM_1_TRIS trisc
#define MX_PWM_1_PIN 2
#define MX_PWM_2_PORT portc
#define MX_PWM_2_TRIS trisc
#define MX_PWM_2_PIN 1

//Functions
#define MX_CLK_SPEED 3276800
#ifdef _BOOSTC
#include <system.h>
#endif
#ifdef HI_TECH_C
#include <pic.h>
#endif

//Configuration data
#ifdef _BOOSTC
#pragma DATA 0x2007, 0x1f32
#endif
#ifdef HI_TECH_C
__CONFIG(0x1f32);
#endif

//Internal functions
#include "C:\Program Files (x86)\Flowcode\v5\FCD\internals.c"

//Macro function declarations
void FCM_scan1();
void FCM_scan2();
void FCM_scan3();
void FCM_scan4();
void FCM_scan_off();
void FCM_test();
void FCM_seg_pattern();
void FCM_display_temp();
void FCM_all_input();
void FCM_pass();
void FCM_failed();
void FCM_calc();
void FCM_i2c_comm();
void FCM_lights_off();
void FCM_beep_once();
void FCM_get_temp();
void FCM_display_repeat();
void FCM_repeat();
void FCM_display_fail();
void FCM_calibrate();
void FCM_display_temp_calib();
void FCM_calc_calib();


//Variable declarations
#define FCV_TRUE (1)
#define FCV_FALSE (0)
MX_UINT8 FCV_D_BYTE = (0x0);
0869  01D2  	CLRF gbl_FCV_D_BYTE

MX_UINT8 FCV_TEMP_TENS = (0x0);
086A  01D3  	CLRF gbl_FCV_TEMP_TENS

MX_SINT16 FCV_TEMP_CDP = (0);
086B  01C1  	CLRF gbl_FCV_TEMP_CDP
086C  01C2  	CLRF gbl_FCV_TEMP_CDP+D'1'

MX_UINT8 FCV_DATA0 = (0xff);
086D  30FF  	MOVLW 0xFF
086E  00D4  	MOVWF gbl_FCV_DATA0

MX_SINT32 FCV_RAW = (0);
086F  01B4  	CLRF gbl_FCV_RAW
0870  01B5  	CLRF gbl_FCV_RAW+D'1'
0871  01B6  	CLRF gbl_FCV_RAW+D'2'
0872  01B7  	CLRF gbl_FCV_RAW+D'3'

MX_UINT8 FCV_DATA1 = (0xff);
0873  30FF  	MOVLW 0xFF
0874  00D5  	MOVWF gbl_FCV_DATA1

MX_UINT8 FCV_DATA2 = (0xff);
0875  30FF  	MOVLW 0xFF
0876  00D6  	MOVWF gbl_FCV_DATA2

MX_UINT8 FCV_DP2 = (0x0);
0877  01D7  	CLRF gbl_FCV_DP2

MX_UINT8 FCV_RET_BYTE = (0x0);
0878  01D8  	CLRF gbl_FCV_RET_BYTE

MX_UINT8 FCV_TEMP_DEC = (0x0);
0879  01D9  	CLRF gbl_FCV_TEMP_DEC

MX_UINT8 FCV_RESET_COUNTER = (0x0);
087A  01DA  	CLRF gbl_FCV_RESET_COUNTER

MX_UINT8 FCV_TEMP_ONES = (0x0);
087B  01DB  	CLRF gbl_FCV_TEMP_ONES

MX_BOOL FCV_PROX_BIT = (1);
087C  145C  	BSF gbl_FCV_PROX_BIT,0

MX_UINT8 FCV_PROX_COUNTER = (0x0);
087D  01DD  	CLRF gbl_FCV_PROX_COUNTER

MX_UINT8 FCV_RT_BYTE = (0xff);
087E  30FF  	MOVLW 0xFF
087F  00DE  	MOVWF gbl_FCV_RT_BYTE

MX_UINT8 FCV_LSB = (0xff);
0880  30FF  	MOVLW 0xFF
0881  00DF  	MOVWF gbl_FCV_LSB

MX_UINT16 FCV_CALIB_SUBTRACTOR;
MX_UINT8 FCV_DIGIT = (0x0);
0882  01E0  	CLRF gbl_FCV_DIGIT

MX_UINT8 FCV_MSB = (0xff);
0883  30FF  	MOVLW 0xFF
0884  00E1  	MOVWF gbl_FCV_MSB

MX_BOOL FCV_FLAGBIT = (1);
0885  14DC  	BSF gbl_FCV_FLAGBIT,1

MX_BOOL FCV_SW0 = (1);
0886  155C  	BSF gbl_FCV_SW0,2

MX_UINT8 FCV_SWR = (0x1);
0887  3001  	MOVLW 0x01
0888  00E2  	MOVWF gbl_FCV_SWR

MX_UINT8 FCV_CALIB_FACTOR = (0x0);
0889  01E3  	CLRF gbl_FCV_CALIB_FACTOR

MX_UINT8 FCV_I2C_RX = (0x0);
088A  01E4  	CLRF gbl_FCV_I2C_RX

MX_SINT32 FCV_TEMP_C;
MX_UINT8 FCV_CALIB_COUNT;
MX_UINT8 FCV_DATA_PREV = (0x0);
088B  01E6  	CLRF gbl_FCV_DATA_PREV

MX_UINT8 FCV_SW_CALIB = (0x0);
088C  01E7  	CLRF gbl_FCV_SW_CALIB

MX_UINT16 FCV_SAVE_CALIB0 = (0x0);
088D  01C5  	CLRF gbl_FCV_SAVE_CALIB0
088E  01C6  	CLRF gbl_FCV_SAVE_CALIB0+D'1'

MX_SINT16 FCV_CALIB_OFFSET;
MX_UINT8 FCV_SAVE_CALIB1;
MX_UINT8 FCV_DATA_DIFF = (0x0);
088F  01E9  	CLRF gbl_FCV_DATA_DIFF

MX_BOOL FCV_SWG = (1);
0890  15DC  	BSF gbl_FCV_SWG,3


MX_UINT8 FCLV_LOOP1;
MX_UINT8 FCLV_LOOP2;
MX_UINT8 FCLV_LOOP3;
MX_UINT8 FCLV_LOOP4;
MX_UINT8 FCLV_LOOP5;
MX_UINT8 FCLV_LOOP6;
MX_UINT8 FCLV_LOOP7;
MX_UINT8 FCLV_LOOP8;
MX_UINT8 FCLV_LOOP9;
MX_UINT8 FCLV_LOOP10;
MX_UINT8 FCLV_LOOP11;



//PWM(0): //Defines:

/**** Macro Substitutions ****
a = Unique Reference
b = PWM Channel - 0=SW / 1-8=HW
c = PWM Alt Pin FCD_PWM0_Enable - 0=Standard / 1=Alt
d = PWM Period
e = PWM Prescaler 1
******************************/

//Period and Prescaler Defines
#ifndef MX_PWM_PERIOD
  #define MX_PWM_PERIOD				255
#else
  #if (MX_PWM_PERIOD != 255)
    #error "PWM period value must be the same in all PWM modules"
  #endif
#endif

#ifndef MX_PWM_PRESCALE1
  #define MX_PWM_PRESCALE1			1
#else
  #if (MX_PWM_PRESCALE1 != 1)
    #error "PWM prescale value must be the same in all PWM modules"
  #endif
#endif

//Definitions for PWM slot allocation
#ifndef	MX_PWM_REF1
			#define MX_PWM_REF1
			#define PWM_1_MX_PWM_UREF			1
			#define MX_PWM_CHANNEL_1		2
			#define MX_PWM_HWALT_1			0
#else
 #ifndef	MX_PWM_REF2
			#define MX_PWM_REF2
			#define PWM_1_MX_PWM_UREF			2
			#define MX_PWM_CHANNEL_2		2
			#define MX_PWM_HWALT_2			0
 #else
  #ifndef	MX_PWM_REF3
			#define MX_PWM_REF3
			#define PWM_1_MX_PWM_UREF			3
			#define MX_PWM_CHANNEL_3		2
			#define MX_PWM_HWALT_3			0
  #else
   #ifndef	MX_PWM_REF4
			#define MX_PWM_REF4
			#define PWM_1_MX_PWM_UREF			4
			#define MX_PWM_CHANNEL_4		2
			#define MX_PWM_HWALT_4			0
   #else
    #ifndef	MX_PWM_REF5
			#define MX_PWM_REF5
			#define PWM_1_MX_PWM_UREF			5
			#define MX_PWM_CHANNEL_5		2
			#define MX_PWM_HWALT_5			0
    #else
     #ifndef	MX_PWM_REF6
			#define MX_PWM_REF6
			#define PWM_1_MX_PWM_UREF			6
			#define MX_PWM_CHANNEL_6		2
			#define MX_PWM_HWALT_6			0
     #else
      #ifndef	MX_PWM_REF7
			#define MX_PWM_REF7
			#define PWM_1_MX_PWM_UREF			7
			#define MX_PWM_CHANNEL_7		2
			#define MX_PWM_HWALT_7			0
      #else
       #ifndef	MX_PWM_REF8
			#define MX_PWM_REF8
			#define PWM_1_MX_PWM_UREF			8
			#define MX_PWM_CHANNEL_8		2
			#define MX_PWM_HWALT_8			0
       #else
        #ifndef	MX_PWM_REF9
			#define MX_PWM_REF9
			#define PWM_1_MX_PWM_UREF			9
			#define MX_PWM_CHANNEL_9		2
			#define MX_PWM_HWALT_9			0
        #else
         #ifndef	MX_PWM_REF10
			#define MX_PWM_REF10
			#define PWM_1_MX_PWM_UREF			10
			#define MX_PWM_CHANNEL_10		2
			#define MX_PWM_HWALT_10			0
         #endif
        #endif
       #endif
      #endif
     #endif
    #endif
   #endif
  #endif
 #endif
#endif

#define PWM_1_PWM_Enable_Channel		CAL_APPEND(FC_CAL_PWM_Enable_Channel_, PWM_1_MX_PWM_UREF)
#define PWM_1_PWM_Disable_Channel		CAL_APPEND(FC_CAL_PWM_Disable_Channel_, PWM_1_MX_PWM_UREF)
#define PWM_1_PWM_Set_Duty_8Bit		CAL_APPEND(FC_CAL_PWM_Set_Duty_8Bit_, PWM_1_MX_PWM_UREF)
#define PWM_1_PWM_Change_Period		CAL_APPEND(FC_CAL_PWM_Change_Period_, PWM_1_MX_PWM_UREF)
#define PWM_1_PWM_Set_Duty_10Bit		CAL_APPEND(FC_CAL_PWM_Set_Duty_10Bit_, PWM_1_MX_PWM_UREF)

extern void PWM_1_PWM_Enable_Channel ();
extern void PWM_1_PWM_Disable_Channel ();
extern void PWM_1_PWM_Set_Duty_8Bit (MX_UINT8 duty);
extern void PWM_1_PWM_Change_Period (MX_UINT8 period, MX_UINT16 prescaler);
extern void PWM_1_PWM_Set_Duty_10Bit (MX_UINT16 duty);




//PWM(0): //Macro function declarations

void FCD_PWM0_Enable();
void FCD_PWM0_Disable();
void FCD_PWM0_SetDutyCycle(MX_UINT8 nDuty);
void FCD_PWM0_ChangePeriod(MX_UINT8 nPeriodVal, MX_UINT8 nPrescalerVal);
void FCD_PWM0_SetDutyCycle10bit(MX_SINT16 nDuty);


//LED(0): //Defines:

/**** Macro Substitutions ****
a = Unique Reference
b = LED Port Letter
c = LED Pin Number
d = LED Active Polarity
******************************/

#define LED_2__LED_PORT		porta
#define LED_2__LED_TRIS		trisa
#define LED_2__LED_PIN		5
#define LED_2__LED_POLE		1




//LED(0): //Macro function declarations

void FCD_LED0_LEDOn();
void FCD_LED0_LEDOff();


//LED(1): //Defines:

/**** Macro Substitutions ****
a = Unique Reference
b = LED Port Letter
c = LED Pin Number
d = LED Active Polarity
******************************/

#define LED_3__LED_PORT		portc
#define LED_3__LED_TRIS		trisc
#define LED_3__LED_PIN		5
#define LED_3__LED_POLE		1




//LED(1): //Macro function declarations

void FCD_LED1_LEDOn();
void FCD_LED1_LEDOff();


//I2C_Master(0): //Defines:

/**** Macro Substitutions ****
a = Unique component ID
b = I2C Channel - 0=SW, 1-4=HW
c = Baud Rate
d = SM BUS Enable 0/2
e = Slew Rate Enable 0/1
f = Bitbanged Data Port Letter
g = Bitbanged Data Pin
h = Bitbanged Clock Port Letter
i = Bitbanged Clock Pin
******************************/

//BMODE
//Bit 0 - Slew Control
//Bit 1 - SMBus Control

//Definitions for I2C slot allocation
#ifndef	MX_I2C_REF1
	#define MX_I2C_REF1
	#define I2CMASTER_5_MX_I2C_UREF			1
	#define MX_I2C_CHANNEL_1		1
	#define MX_I2C_SDA_PIN_1		4
	#define MX_I2C_SDA_PORT_1		portd
	#define MX_I2C_SDA_TRIS_1		trisd
	#define MX_I2C_SCL_PIN_1		3
	#define MX_I2C_SCL_PORT_1		portd
	#define MX_I2C_SCL_TRIS_1		trisd
	#define MX_I2C_BMODE_1			0 | 0
	#define MX_I2C_BAUD_1			100000
	#define MX_I2C_INT_1			0
#else
 #ifndef MX_I2C_REF2
	#define MX_I2C_REF2
	#define I2CMASTER_5_MX_I2C_UREF			2
	#define MX_I2C_CHANNEL_2		1
	#define MX_I2C_SDA_PIN_2		4
	#define MX_I2C_SDA_PORT_2		portd
	#define MX_I2C_SDA_TRIS_2		trisd
	#define MX_I2C_SCL_PIN_2		3
	#define MX_I2C_SCL_PORT_2		portd
	#define MX_I2C_SCL_TRIS_2		trisd
	#define MX_I2C_BMODE_2			0 | 0
	#define MX_I2C_BAUD_2			100000
	#define MX_I2C_INT_2			0
 #else
  #ifndef MX_I2C_REF3
	#define MX_I2C_REF3
	#define I2CMASTER_5_MX_I2C_UREF			3
	#define MX_I2C_CHANNEL_3		1
	#define MX_I2C_SDA_PIN_3		4
	#define MX_I2C_SDA_PORT_3		portd
	#define MX_I2C_SDA_TRIS_3		trisd
	#define MX_I2C_SCL_PIN_3		3
	#define MX_I2C_SCL_PORT_3		portd
	#define MX_I2C_SCL_TRIS_3		trisd
	#define MX_I2C_BMODE_3			0 | 0
	#define MX_I2C_BAUD_3			100000
	#define MX_I2C_INT_3			0
  #else
   #ifndef MX_I2C_REF4
	#define MX_I2C_REF4
	#define I2CMASTER_5_MX_I2C_UREF			4
	#define MX_I2C_CHANNEL_4		1
	#define MX_I2C_SDA_PIN_4		4
	#define MX_I2C_SDA_PORT_4		portd
	#define MX_I2C_SDA_TRIS_4		trisd
	#define MX_I2C_SCL_PIN_4		3
	#define MX_I2C_SCL_PORT_4		portd
	#define MX_I2C_SCL_TRIS_4		trisd
	#define MX_I2C_BMODE_4			0 | 0
	#define MX_I2C_BAUD_4			100000
	#define MX_I2C_INT_4			0
   #endif
  #endif
 #endif
#endif

#define I2CMASTER_5_I2C_Master_Init		CAL_APPEND(FC_CAL_I2C_Master_Init_, I2CMASTER_5_MX_I2C_UREF)
#define I2CMASTER_5_I2C_Master_Uninit	CAL_APPEND(FC_CAL_I2C_Master_Uninit_, I2CMASTER_5_MX_I2C_UREF)
#define I2CMASTER_5_I2C_Master_Start		CAL_APPEND(FC_CAL_I2C_Master_Start_, I2CMASTER_5_MX_I2C_UREF)
#define I2CMASTER_5_I2C_Master_Restart	CAL_APPEND(FC_CAL_I2C_Master_Restart_, I2CMASTER_5_MX_I2C_UREF)
#define I2CMASTER_5_I2C_Master_Stop		CAL_APPEND(FC_CAL_I2C_Master_Stop_, I2CMASTER_5_MX_I2C_UREF)
#define I2CMASTER_5_I2C_Master_TX_Byte	CAL_APPEND(FC_CAL_I2C_Master_TX_Byte_, I2CMASTER_5_MX_I2C_UREF)
#define I2CMASTER_5_I2C_Master_RX_Byte	CAL_APPEND(FC_CAL_I2C_Master_RX_Byte_, I2CMASTER_5_MX_I2C_UREF)

extern void I2CMASTER_5_I2C_Master_Init ();
extern void I2CMASTER_5_I2C_Master_Uninit ();
extern void I2CMASTER_5_I2C_Master_Start ();
extern void I2CMASTER_5_I2C_Master_Restart ();
extern void I2CMASTER_5_I2C_Master_Stop ();
extern MX_UINT8 I2CMASTER_5_I2C_Master_TX_Byte (MX_UINT8 Data);
extern MX_UINT8 I2CMASTER_5_I2C_Master_RX_Byte (MX_UINT8 Last);




//I2C_Master(0): //Macro function declarations

void FCD_I2C_Master0_MI2C_Init();
void FCD_I2C_Master0_MI2C_Start();
void FCD_I2C_Master0_MI2C_Restart();
void FCD_I2C_Master0_MI2C_Stop();
MX_UINT8 FCD_I2C_Master0_MI2C_Transmit_Byte(MX_UINT8 Data);
MX_UINT8 FCD_I2C_Master0_MI2C_Receive_Byte(MX_UINT8 Last);
void FCD_I2C_Master0_MI2C_Send_Byte_Transaction(MX_UINT8 Device_ID, MX_UINT8 AddrH, MX_UINT8 AddrL, MX_UINT8 Data);
MX_UINT8 FCD_I2C_Master0_MI2C_Receive_Byte_Transaction(MX_UINT8 Device_ID, MX_UINT8 AddrH, MX_UINT8 AddrL);


//EEPROM(0): //Defines:

/**** Macro Substitutions ****
Component has no substitutions
******************************/

#ifndef MX_EEPROM_REF
	#define MX_EEPROM_REF

	#ifdef FC_CAL_PIC16BIT
		extern MX_UINT16 FC_CAL_EE_Read (MX_UINT16 Address);
		extern void FC_CAL_EE_Write (MX_UINT16 Address, MX_UINT16 Data);
	#else
		extern MX_UINT8 FC_CAL_EE_Read (MX_UINT16 Address);
		extern void FC_CAL_EE_Write (MX_UINT16 Address, MX_UINT8 Data);
	#endif
#endif




//EEPROM(0): //Macro function declarations

MX_UINT16 FCD_EEPROM0_EEPROMRead(MX_UINT16 addr);
void FCD_EEPROM0_WriteEEPROM(MX_UINT16 addr, MX_UINT16 data);



//PWM(0): //Macro implementations


void FCD_PWM0_Enable()

{
	
		PWM_1_PWM_Change_Period (MX_PWM_PERIOD, MX_PWM_PRESCALE1);
06E0  30FF  	MOVLW 0xFF
06E1  1283  	BCF STATUS, RP0
06E2  1303  	BCF STATUS, RP1
06E3  00F5  	MOVWF FC_CAL_PWM_0006C_arg_period
06E4  3001  	MOVLW 0x01
06E5  00F6  	MOVWF FC_CAL_PWM_0006C_arg_prescaler
06E6  01F7  	CLRF FC_CAL_PWM_0006C_arg_prescaler+D'1'
06E7  2284  	CALL FC_CAL_PWM_0006C

		PWM_1_PWM_Enable_Channel ();
06E8  22A4  	CALL FC_CAL_PWM_00069


}
06E9  0008  	RETURN


void FCD_PWM0_Disable()
{
	
		PWM_1_PWM_Disable_Channel();

}

void FCD_PWM0_SetDutyCycle(MX_UINT8 nDuty)

{
	
		PWM_1_PWM_Set_Duty_8Bit(nDuty);
0268  087D  	MOVF FCD_PWM0_S_00061_arg_nDuty, W
0269  00FE  	MOVWF FC_CAL_PWM_0006B_arg_duty
026A  202B  	CALL FC_CAL_PWM_0006B


}
026B  0008  	RETURN


void FCD_PWM0_ChangePeriod(MX_UINT8 nPeriodVal, MX_UINT8 nPrescalerVal)
{
	
		PWM_1_PWM_Change_Period (nPeriodVal, nPrescalerVal);

}

void FCD_PWM0_SetDutyCycle10bit(MX_SINT16 nDuty)
{
	
		PWM_1_PWM_Set_Duty_10Bit(nDuty);

}



//LED(0): //Macro implementations


void FCD_LED0_LEDOn()

{
	
		#if( LED_2__LED_POLE == 1)									//Active high polarity
			FC_CAL_Bit_High_DDR( LED_2__LED_PORT , LED_2__LED_TRIS , LED_2__LED_PIN );
026C  1683  	BSF STATUS, RP0
026D  1303  	BCF STATUS, RP1
026E  1285  	BCF gbl_trisa,5
026F  1283  	BCF STATUS, RP0
0270  1685  	BSF gbl_porta,5

		#else													//Active low polarity
			FC_CAL_Bit_Low_DDR( LED_2__LED_PORT , LED_2__LED_TRIS , LED_2__LED_PIN );
		#endif

}
0271  0008  	RETURN


void FCD_LED0_LEDOff()

{
	
		#if( LED_2__LED_POLE == 1)									//Active high polarity
			FC_CAL_Bit_Low_DDR( LED_2__LED_PORT	, LED_2__LED_TRIS , LED_2__LED_PIN );
012A  1683  	BSF STATUS, RP0
012B  1303  	BCF STATUS, RP1
012C  1285  	BCF gbl_trisa,5
012D  1283  	BCF STATUS, RP0
012E  1285  	BCF gbl_porta,5

		#else													//Active low polarity
			FC_CAL_Bit_High_DDR( LED_2__LED_PORT , LED_2__LED_TRIS , LED_2__LED_PIN );
		#endif

}
012F  0008  	RETURN




//LED(1): //Macro implementations


void FCD_LED1_LEDOn()

{
	
		#if( LED_3__LED_POLE == 1)									//Active high polarity
			FC_CAL_Bit_High_DDR( LED_3__LED_PORT , LED_3__LED_TRIS , LED_3__LED_PIN );
05C1  1683  	BSF STATUS, RP0
05C2  1303  	BCF STATUS, RP1
05C3  1287  	BCF gbl_trisc,5
05C4  1283  	BCF STATUS, RP0
05C5  1687  	BSF gbl_portc,5

		#else													//Active low polarity
			FC_CAL_Bit_Low_DDR( LED_3__LED_PORT , LED_3__LED_TRIS , LED_3__LED_PIN );
		#endif

}
05C6  0008  	RETURN


void FCD_LED1_LEDOff()

{
	
		#if( LED_3__LED_POLE == 1)									//Active high polarity
			FC_CAL_Bit_Low_DDR( LED_3__LED_PORT	, LED_3__LED_TRIS , LED_3__LED_PIN );
0124  1683  	BSF STATUS, RP0
0125  1303  	BCF STATUS, RP1
0126  1287  	BCF gbl_trisc,5
0127  1283  	BCF STATUS, RP0
0128  1287  	BCF gbl_portc,5

		#else													//Active low polarity
			FC_CAL_Bit_High_DDR( LED_3__LED_PORT , LED_3__LED_TRIS , LED_3__LED_PIN );
		#endif

}
0129  0008  	RETURN




//I2C_Master(0): //Macro implementations


void FCD_I2C_Master0_MI2C_Init()

{
	
		I2CMASTER_5_I2C_Master_Init();
06EA  22AC  	CALL FC_CAL_I2C_00073


}
06EB  0008  	RETURN


void FCD_I2C_Master0_MI2C_Start()

{
	
		I2CMASTER_5_I2C_Master_Start();
0282  2066  	CALL FC_CAL_I2C_00075


}
0283  0008  	RETURN


void FCD_I2C_Master0_MI2C_Restart()

{
	
		I2CMASTER_5_I2C_Master_Restart();
027A  205E  	CALL FC_CAL_I2C_00076


}
027B  0008  	RETURN


void FCD_I2C_Master0_MI2C_Stop()

{
	
		I2CMASTER_5_I2C_Master_Stop();
0272  2052  	CALL FC_CAL_I2C_00077


}
0273  0008  	RETURN


MX_UINT8 FCD_I2C_Master0_MI2C_Transmit_Byte(MX_UINT8 Data)

{
	
		return I2CMASTER_5_I2C_Master_TX_Byte(Data);
027C  0875  	MOVF FCD_I2C_Ma_0005B_arg_Data, W
027D  00F6  	MOVWF FC_CAL_I2C_00078_arg_Data
027E  2043  	CALL FC_CAL_I2C_00078
027F  0877  	MOVF CompTempVarRet2287, W
0280  00F6  	MOVWF CompTempVarRet2244


}
0281  0008  	RETURN


MX_UINT8 FCD_I2C_Master0_MI2C_Receive_Byte(MX_UINT8 Last)

{
	
		return I2CMASTER_5_I2C_Master_RX_Byte(Last);
0274  0875  	MOVF FCD_I2C_Ma_0005D_arg_Last, W
0275  00F6  	MOVWF FC_CAL_I2C_00079_arg_Last
0276  202E  	CALL FC_CAL_I2C_00079
0277  0877  	MOVF CompTempVarRet2288, W
0278  00F6  	MOVWF CompTempVarRet2245


}
0279  0008  	RETURN


void FCD_I2C_Master0_MI2C_Send_Byte_Transaction(MX_UINT8 Device_ID, MX_UINT8 AddrH, MX_UINT8 AddrL, MX_UINT8 Data)
{
	
		Device_ID = Device_ID << 1;					//Shift Device ID to enable write mode

		I2CMASTER_5_I2C_Master_Start();						//Start transaction
		I2CMASTER_5_I2C_Master_TX_Byte(Device_ID);			//Transmit Device Address
		I2CMASTER_5_I2C_Master_TX_Byte(AddrH);				//Transmit Internal Address
		I2CMASTER_5_I2C_Master_TX_Byte(AddrL);
		I2CMASTER_5_I2C_Master_TX_Byte(Data);				//Send Data byte
		I2CMASTER_5_I2C_Master_Stop();						//Stop Transaction

}

MX_UINT8 FCD_I2C_Master0_MI2C_Receive_Byte_Transaction(MX_UINT8 Device_ID, MX_UINT8 AddrH, MX_UINT8 AddrL)
{
	
		MX_UINT8 RetVal = 0;
		Device_ID = Device_ID << 1;					//Shift Device ID to enable write mode

		I2CMASTER_5_I2C_Master_Start();						//Start transaction
		I2CMASTER_5_I2C_Master_TX_Byte(Device_ID);			//Transmit Device Address
		I2CMASTER_5_I2C_Master_TX_Byte(AddrH);				//Transmit Internal Address
		I2CMASTER_5_I2C_Master_TX_Byte(AddrL);
		I2CMASTER_5_I2C_Master_Restart();					//Restart transaction

		Device_ID = Device_ID | 0x01;				//Change Device ID to read mode
		I2CMASTER_5_I2C_Master_TX_Byte(Device_ID);			//Transmit Device Address
		RetVal = I2CMASTER_5_I2C_Master_RX_Byte(1);			//Read data at address
		I2CMASTER_5_I2C_Master_Stop();						//Stop Transaction

		return RetVal;								//Return data

}



//EEPROM(0): //Macro implementations


MX_UINT16 FCD_EEPROM0_EEPROMRead(MX_UINT16 addr)

{
	
		return (FC_CAL_EE_Read (addr));
06EC  0875  	MOVF FCD_EEPROM_00080_arg_addr, W
06ED  00F7  	MOVWF FC_CAL_EE__0007D_arg_Address
06EE  0876  	MOVF FCD_EEPROM_00080_arg_addr+D'1', W
06EF  00F8  	MOVWF FC_CAL_EE__0007D_arg_Address+D'1'
06F0  22BB  	CALL FC_CAL_EE__0007D
06F1  087A  	MOVF CompTempVarRet2292, W
06F2  00F7  	MOVWF CompTempVarRet2293
06F3  01F8  	CLRF CompTempVarRet2293+D'1'


}
06F4  0008  	RETURN


void FCD_EEPROM0_WriteEEPROM(MX_UINT16 addr, MX_UINT16 data)

{
	
		FC_CAL_EE_Write (addr, data);
05C7  1283  	BCF STATUS, RP0
05C8  087D  	MOVF FCD_EEPROM_00067_arg_addr, W
05C9  1683  	BSF STATUS, RP0
05CA  00A2  	MOVWF FC_CAL_EE__0007E_arg_Address
05CB  1283  	BCF STATUS, RP0
05CC  087E  	MOVF FCD_EEPROM_00067_arg_addr+D'1', W
05CD  1683  	BSF STATUS, RP0
05CE  00A3  	MOVWF FC_CAL_EE__0007E_arg_Address+D'1'
05CF  0820  	MOVF FCD_EEPROM_00067_arg_data, W
05D0  00A4  	MOVWF FC_CAL_EE__0007E_arg_Data
05D1  21B3  	CALL FC_CAL_EE__0007E


}
05D2  0008  	RETURN


#include "C:\Program Files (x86)\Flowcode\v5\CAL\includes.c"

//Macro implementations


void FCM_scan1()

{

	//Output
	//Output: 0 -> A0
	trisa = trisa & 0xFE;
00FF  30FE  	MOVLW 0xFE
0100  1683  	BSF STATUS, RP0
0101  1303  	BCF STATUS, RP1
0102  0505  	ANDWF gbl_trisa, W
0103  0085  	MOVWF gbl_trisa

	if ((0))
		porta = (porta & 0xFE) | 0x01;
	else
		porta = porta & 0xFE;
0104  30FE  	MOVLW 0xFE
0105  1283  	BCF STATUS, RP0
0106  0505  	ANDWF gbl_porta, W
0107  0085  	MOVWF gbl_porta


	//Output
	//Output: 0 -> A1
	trisa = trisa & 0xFD;
0108  30FD  	MOVLW 0xFD
0109  1683  	BSF STATUS, RP0
010A  0505  	ANDWF gbl_trisa, W
010B  0085  	MOVWF gbl_trisa

	if ((0))
		porta = (porta & 0xFD) | 0x02;
	else
		porta = porta & 0xFD;
010C  30FD  	MOVLW 0xFD
010D  1283  	BCF STATUS, RP0
010E  0505  	ANDWF gbl_porta, W
010F  0085  	MOVWF gbl_porta


	//Output
	//Output: 0 -> A2
	trisa = trisa & 0xFB;
0110  30FB  	MOVLW 0xFB
0111  1683  	BSF STATUS, RP0
0112  0505  	ANDWF gbl_trisa, W
0113  0085  	MOVWF gbl_trisa

	if ((0))
		porta = (porta & 0xFB) | 0x04;
	else
		porta = porta & 0xFB;
0114  30FB  	MOVLW 0xFB
0115  1283  	BCF STATUS, RP0
0116  0505  	ANDWF gbl_porta, W
0117  0085  	MOVWF gbl_porta


	//Output
	//Output: 1 -> A3
	trisa = trisa & 0xF7;
0118  30F7  	MOVLW 0xF7
0119  1683  	BSF STATUS, RP0
011A  0505  	ANDWF gbl_trisa, W
011B  0085  	MOVWF gbl_trisa

	if ((1))
		porta = (porta & 0xF7) | 0x08;
011C  30F7  	MOVLW 0xF7
011D  1283  	BCF STATUS, RP0
011E  0505  	ANDWF gbl_porta, W
011F  00FD  	MOVWF CompTempVar2195
0120  3008  	MOVLW 0x08
0121  047D  	IORWF CompTempVar2195, W
0122  0085  	MOVWF gbl_porta

	else
		porta = porta & 0xF7;

}
0123  0008  	RETURN



void FCM_scan2()

{

	//Output
	//Output: 0 -> A0
	trisa = trisa & 0xFE;
00DA  30FE  	MOVLW 0xFE
00DB  1683  	BSF STATUS, RP0
00DC  1303  	BCF STATUS, RP1
00DD  0505  	ANDWF gbl_trisa, W
00DE  0085  	MOVWF gbl_trisa

	if ((0))
		porta = (porta & 0xFE) | 0x01;
	else
		porta = porta & 0xFE;
00DF  30FE  	MOVLW 0xFE
00E0  1283  	BCF STATUS, RP0
00E1  0505  	ANDWF gbl_porta, W
00E2  0085  	MOVWF gbl_porta


	//Output
	//Output: 0 -> A1
	trisa = trisa & 0xFD;
00E3  30FD  	MOVLW 0xFD
00E4  1683  	BSF STATUS, RP0
00E5  0505  	ANDWF gbl_trisa, W
00E6  0085  	MOVWF gbl_trisa

	if ((0))
		porta = (porta & 0xFD) | 0x02;
	else
		porta = porta & 0xFD;
00E7  30FD  	MOVLW 0xFD
00E8  1283  	BCF STATUS, RP0
00E9  0505  	ANDWF gbl_porta, W
00EA  0085  	MOVWF gbl_porta


	//Output
	//Output: 1 -> A2
	trisa = trisa & 0xFB;
00EB  30FB  	MOVLW 0xFB
00EC  1683  	BSF STATUS, RP0
00ED  0505  	ANDWF gbl_trisa, W
00EE  0085  	MOVWF gbl_trisa

	if ((1))
		porta = (porta & 0xFB) | 0x04;
00EF  30FB  	MOVLW 0xFB
00F0  1283  	BCF STATUS, RP0
00F1  0505  	ANDWF gbl_porta, W
00F2  00FD  	MOVWF CompTempVar2196
00F3  3004  	MOVLW 0x04
00F4  047D  	IORWF CompTempVar2196, W
00F5  0085  	MOVWF gbl_porta

	else
		porta = porta & 0xFB;

	//Output
	//Output: 0 -> A3
	trisa = trisa & 0xF7;
00F6  30F7  	MOVLW 0xF7
00F7  1683  	BSF STATUS, RP0
00F8  0505  	ANDWF gbl_trisa, W
00F9  0085  	MOVWF gbl_trisa

	if ((0))
		porta = (porta & 0xF7) | 0x08;
	else
		porta = porta & 0xF7;
00FA  30F7  	MOVLW 0xF7
00FB  1283  	BCF STATUS, RP0
00FC  0505  	ANDWF gbl_porta, W
00FD  0085  	MOVWF gbl_porta


}
00FE  0008  	RETURN



void FCM_scan3()

{

	//Output
	//Output: 0 -> A0
	trisa = trisa & 0xFE;
00B5  30FE  	MOVLW 0xFE
00B6  1683  	BSF STATUS, RP0
00B7  1303  	BCF STATUS, RP1
00B8  0505  	ANDWF gbl_trisa, W
00B9  0085  	MOVWF gbl_trisa

	if ((0))
		porta = (porta & 0xFE) | 0x01;
	else
		porta = porta & 0xFE;
00BA  30FE  	MOVLW 0xFE
00BB  1283  	BCF STATUS, RP0
00BC  0505  	ANDWF gbl_porta, W
00BD  0085  	MOVWF gbl_porta


	//Output
	//Output: 1 -> A1
	trisa = trisa & 0xFD;
00BE  30FD  	MOVLW 0xFD
00BF  1683  	BSF STATUS, RP0
00C0  0505  	ANDWF gbl_trisa, W
00C1  0085  	MOVWF gbl_trisa

	if ((1))
		porta = (porta & 0xFD) | 0x02;
00C2  30FD  	MOVLW 0xFD
00C3  1283  	BCF STATUS, RP0
00C4  0505  	ANDWF gbl_porta, W
00C5  00FD  	MOVWF CompTempVar2197
00C6  3002  	MOVLW 0x02
00C7  047D  	IORWF CompTempVar2197, W
00C8  0085  	MOVWF gbl_porta

	else
		porta = porta & 0xFD;

	//Output
	//Output: 0 -> A2
	trisa = trisa & 0xFB;
00C9  30FB  	MOVLW 0xFB
00CA  1683  	BSF STATUS, RP0
00CB  0505  	ANDWF gbl_trisa, W
00CC  0085  	MOVWF gbl_trisa

	if ((0))
		porta = (porta & 0xFB) | 0x04;
	else
		porta = porta & 0xFB;
00CD  30FB  	MOVLW 0xFB
00CE  1283  	BCF STATUS, RP0
00CF  0505  	ANDWF gbl_porta, W
00D0  0085  	MOVWF gbl_porta


	//Output
	//Output: 0 -> A3
	trisa = trisa & 0xF7;
00D1  30F7  	MOVLW 0xF7
00D2  1683  	BSF STATUS, RP0
00D3  0505  	ANDWF gbl_trisa, W
00D4  0085  	MOVWF gbl_trisa

	if ((0))
		porta = (porta & 0xF7) | 0x08;
	else
		porta = porta & 0xF7;
00D5  30F7  	MOVLW 0xF7
00D6  1283  	BCF STATUS, RP0
00D7  0505  	ANDWF gbl_porta, W
00D8  0085  	MOVWF gbl_porta


}
00D9  0008  	RETURN



void FCM_scan4()

{

	//Output
	//Output: 1 -> A0
	trisa = trisa & 0xFE;
0090  30FE  	MOVLW 0xFE
0091  1683  	BSF STATUS, RP0
0092  1303  	BCF STATUS, RP1
0093  0505  	ANDWF gbl_trisa, W
0094  0085  	MOVWF gbl_trisa

	if ((1))
		porta = (porta & 0xFE) | 0x01;
0095  30FE  	MOVLW 0xFE
0096  1283  	BCF STATUS, RP0
0097  0505  	ANDWF gbl_porta, W
0098  00FD  	MOVWF CompTempVar2198
0099  3001  	MOVLW 0x01
009A  047D  	IORWF CompTempVar2198, W
009B  0085  	MOVWF gbl_porta

	else
		porta = porta & 0xFE;

	//Output
	//Output: 0 -> A1
	trisa = trisa & 0xFD;
009C  30FD  	MOVLW 0xFD
009D  1683  	BSF STATUS, RP0
009E  0505  	ANDWF gbl_trisa, W
009F  0085  	MOVWF gbl_trisa

	if ((0))
		porta = (porta & 0xFD) | 0x02;
	else
		porta = porta & 0xFD;
00A0  30FD  	MOVLW 0xFD
00A1  1283  	BCF STATUS, RP0
00A2  0505  	ANDWF gbl_porta, W
00A3  0085  	MOVWF gbl_porta


	//Output
	//Output: 0 -> A2
	trisa = trisa & 0xFB;
00A4  30FB  	MOVLW 0xFB
00A5  1683  	BSF STATUS, RP0
00A6  0505  	ANDWF gbl_trisa, W
00A7  0085  	MOVWF gbl_trisa

	if ((0))
		porta = (porta & 0xFB) | 0x04;
	else
		porta = porta & 0xFB;
00A8  30FB  	MOVLW 0xFB
00A9  1283  	BCF STATUS, RP0
00AA  0505  	ANDWF gbl_porta, W
00AB  0085  	MOVWF gbl_porta


	//Output
	//Output: 0 -> A3
	trisa = trisa & 0xF7;
00AC  30F7  	MOVLW 0xF7
00AD  1683  	BSF STATUS, RP0
00AE  0505  	ANDWF gbl_trisa, W
00AF  0085  	MOVWF gbl_trisa

	if ((0))
		porta = (porta & 0xF7) | 0x08;
	else
		porta = porta & 0xF7;
00B0  30F7  	MOVLW 0xF7
00B1  1283  	BCF STATUS, RP0
00B2  0505  	ANDWF gbl_porta, W
00B3  0085  	MOVWF gbl_porta


}
00B4  0008  	RETURN



void FCM_scan_off()

{

	//Output
	//Output: 0 -> A0
	trisa = trisa & 0xFE;
006E  30FE  	MOVLW 0xFE
006F  1683  	BSF STATUS, RP0
0070  1303  	BCF STATUS, RP1
0071  0505  	ANDWF gbl_trisa, W
0072  0085  	MOVWF gbl_trisa

	if ((0))
		porta = (porta & 0xFE) | 0x01;
	else
		porta = porta & 0xFE;
0073  30FE  	MOVLW 0xFE
0074  1283  	BCF STATUS, RP0
0075  0505  	ANDWF gbl_porta, W
0076  0085  	MOVWF gbl_porta


	//Output
	//Output: 0 -> A1
	trisa = trisa & 0xFD;
0077  30FD  	MOVLW 0xFD
0078  1683  	BSF STATUS, RP0
0079  0505  	ANDWF gbl_trisa, W
007A  0085  	MOVWF gbl_trisa

	if ((0))
		porta = (porta & 0xFD) | 0x02;
	else
		porta = porta & 0xFD;
007B  30FD  	MOVLW 0xFD
007C  1283  	BCF STATUS, RP0
007D  0505  	ANDWF gbl_porta, W
007E  0085  	MOVWF gbl_porta


	//Output
	//Output: 0 -> A2
	trisa = trisa & 0xFB;
007F  30FB  	MOVLW 0xFB
0080  1683  	BSF STATUS, RP0
0081  0505  	ANDWF gbl_trisa, W
0082  0085  	MOVWF gbl_trisa

	if ((0))
		porta = (porta & 0xFB) | 0x04;
	else
		porta = porta & 0xFB;
0083  30FB  	MOVLW 0xFB
0084  1283  	BCF STATUS, RP0
0085  0505  	ANDWF gbl_porta, W
0086  0085  	MOVWF gbl_porta


	//Output
	//Output: 0 -> A3
	trisa = trisa & 0xF7;
0087  30F7  	MOVLW 0xF7
0088  1683  	BSF STATUS, RP0
0089  0505  	ANDWF gbl_trisa, W
008A  0085  	MOVWF gbl_trisa

	if ((0))
		porta = (porta & 0xF7) | 0x08;
	else
		porta = porta & 0xF7;
008B  30F7  	MOVLW 0xF7
008C  1283  	BCF STATUS, RP0
008D  0505  	ANDWF gbl_porta, W
008E  0085  	MOVWF gbl_porta


}
008F  0008  	RETURN



void FCM_test()
{

	//Output
	//Output: 0 -> B0
	trisb = trisb & 0xFE;
	if ((0))
		portb = (portb & 0xFE) | 0x01;
	else
		portb = portb & 0xFE;

	//Delay
	//Delay: 1 s
	delay_s(1);

	//Output
	//Output: 1 -> B1
	trisb = trisb & 0xFD;
	if ((1))
		portb = (portb & 0xFD) | 0x02;
	else
		portb = portb & 0xFD;

	//Delay
	//Delay: 1 s
	delay_s(1);

	//Output
	//Output: 1 -> B2
	trisb = trisb & 0xFB;
	if ((1))
		portb = (portb & 0xFB) | 0x04;
	else
		portb = portb & 0xFB;

	//Delay
	//Delay: 1 s
	delay_s(1);

	//Output
	//Output: 1 -> B3
	trisb = trisb & 0xF7;
	if ((1))
		portb = (portb & 0xF7) | 0x08;
	else
		portb = portb & 0xF7;

	//Delay
	//Delay: 1 s
	delay_s(1);

	//Output
	//Output: 1 -> B4
	trisb = trisb & 0xEF;
	if ((1))
		portb = (portb & 0xEF) | 0x10;
	else
		portb = portb & 0xEF;

	//Delay
	//Delay: 1 s
	delay_s(1);

	//Output
	//Output: 1 -> B5
	trisb = trisb & 0xDF;
	if ((1))
		portb = (portb & 0xDF) | 0x20;
	else
		portb = portb & 0xDF;

	//Delay
	//Delay: 1 s
	delay_s(1);

	//Output
	//Output: 1 -> B6
	trisb = trisb & 0xBF;
	if ((1))
		portb = (portb & 0xBF) | 0x40;
	else
		portb = portb & 0xBF;

	//Delay
	//Delay: 1 s
	delay_s(1);

	//Output
	//Output: 1 -> B7
	trisb = trisb & 0x7F;
	if ((1))
		portb = (portb & 0x7F) | 0x80;
	else
		portb = portb & 0x7F;

	//Delay
	//Delay: 1 s
	delay_s(1);

}


void FCM_seg_pattern()

{

	//Switch
	//Switch: digit?
	switch (FCV_DIGIT)

	{
		case 1:
01D9  1283  	BCF STATUS, RP0
01DA  1303  	BCF STATUS, RP1
01DB  0860  	MOVF gbl_FCV_DIGIT, W
01DC  3A01  	XORLW 0x01
01DD  1903  	BTFSC STATUS,Z
01DE  29FB  	GOTO	label24
01FB        label24

		{
			//Output
			//Output: 0b00010011 -> PORTB
			trisb = 0x00;
01FB  1683  	BSF STATUS, RP0
01FC  0186  	CLRF gbl_trisb

			portb = (19);
01FD  3013  	MOVLW 0x13
01FE  1283  	BCF STATUS, RP0
01FF  0086  	MOVWF gbl_portb


			break;

		}
		case 2:
01DF  3A03  	XORLW 0x03
01E0  1903  	BTFSC STATUS,Z
01E1  2A01  	GOTO	label25
0201        label25

		{
			//Output
			//Output: 0b10111101 -> PORTB
			trisb = 0x00;
0201  1683  	BSF STATUS, RP0
0202  0186  	CLRF gbl_trisb

			portb = (189);
0203  30BD  	MOVLW 0xBD
0204  1283  	BCF STATUS, RP0
0205  0086  	MOVWF gbl_portb


			break;

		}
		case 3:
01E2  3A01  	XORLW 0x01
01E3  1903  	BTFSC STATUS,Z
01E4  2A07  	GOTO	label26
0207        label26

		{
			//Output
			//Output: 0b10110111 -> PORTB
			trisb = 0x00;
0207  1683  	BSF STATUS, RP0
0208  0186  	CLRF gbl_trisb

			portb = (183);
0209  30B7  	MOVLW 0xB7
020A  1283  	BCF STATUS, RP0
020B  0086  	MOVWF gbl_portb


			break;

		}
		case 4:
01E5  3A07  	XORLW 0x07
01E6  1903  	BTFSC STATUS,Z
01E7  2A0D  	GOTO	label27
020D        label27

		{
			//Output
			//Output: 0b11010011 -> PORTB
			trisb = 0x00;
020D  1683  	BSF STATUS, RP0
020E  0186  	CLRF gbl_trisb

			portb = (211);
020F  30D3  	MOVLW 0xD3
0210  1283  	BCF STATUS, RP0
0211  0086  	MOVWF gbl_portb


			break;

		}
		case 5:
01E8  3A01  	XORLW 0x01
01E9  1903  	BTFSC STATUS,Z
01EA  2A13  	GOTO	label28
0213        label28

		{
			//Output
			//Output: 0b11100111 -> PORTB
			trisb = 0x00;
0213  1683  	BSF STATUS, RP0
0214  0186  	CLRF gbl_trisb

			portb = (231);
0215  30E7  	MOVLW 0xE7
0216  1283  	BCF STATUS, RP0
0217  0086  	MOVWF gbl_portb


			break;

		}
		case 6:
01EB  3A03  	XORLW 0x03
01EC  1903  	BTFSC STATUS,Z
01ED  2A19  	GOTO	label29
0219        label29

		{
			//Output
			//Output: 0b11101111 -> PORTB
			trisb = 0x00;
0219  1683  	BSF STATUS, RP0
021A  0186  	CLRF gbl_trisb

			portb = (239);
021B  30EF  	MOVLW 0xEF
021C  1283  	BCF STATUS, RP0
021D  0086  	MOVWF gbl_portb


			break;

		}
		case 7:
01EE  3A01  	XORLW 0x01
01EF  1903  	BTFSC STATUS,Z
01F0  2A1F  	GOTO	label30
021F        label30

		{
			//Output
			//Output: 0b00110011 -> PORTB
			trisb = 0x00;
021F  1683  	BSF STATUS, RP0
0220  0186  	CLRF gbl_trisb

			portb = (51);
0221  3033  	MOVLW 0x33
0222  1283  	BCF STATUS, RP0
0223  0086  	MOVWF gbl_portb


			break;

		}
		case 8:
01F1  3A0F  	XORLW 0x0F
01F2  1903  	BTFSC STATUS,Z
01F3  2A25  	GOTO	label31
0225        label31

		{
			//Output
			//Output: 0b11111111 -> PORTB
			trisb = 0x00;
0225  1683  	BSF STATUS, RP0
0226  0186  	CLRF gbl_trisb

			portb = (255);
0227  30FF  	MOVLW 0xFF
0228  1283  	BCF STATUS, RP0
0229  0086  	MOVWF gbl_portb


			break;

		}
		case 9:
01F4  3A01  	XORLW 0x01
01F5  1903  	BTFSC STATUS,Z
01F6  2A2B  	GOTO	label32
022B        label32

		{
			//Output
			//Output: 0b11110111 -> PORTB
			trisb = 0x00;
022B  1683  	BSF STATUS, RP0
022C  0186  	CLRF gbl_trisb

			portb = (247);
022D  30F7  	MOVLW 0xF7
022E  1283  	BCF STATUS, RP0
022F  0086  	MOVWF gbl_portb


			break;

		}
		case 0:
01F7  3A09  	XORLW 0x09
01F8  1903  	BTFSC STATUS,Z
01F9  2A31  	GOTO	label33
0231        label33

		{
			//Connection Point
			//Connection Point: [A]: A
FCC_seg_pattern_A:

;

			//Output
			//Output: 0b01111111 -> PORTB
			trisb = 0x00;
0231  1683  	BSF STATUS, RP0
0232  0186  	CLRF gbl_trisb

			portb = (127);
0233  307F  	MOVLW 0x7F
0234  1283  	BCF STATUS, RP0
0235  0086  	MOVWF gbl_portb


			break;

		}
		default:
01FA  2A31  	GOTO	label33

		{
			//Goto Connection Point
			//Goto Connection Point: [A]: A
			goto FCC_seg_pattern_A;


		}
	}

}
0200  0008  	RETURN
0206  0008  	RETURN
020C  0008  	RETURN
0212  0008  	RETURN
0218  0008  	RETURN
021E  0008  	RETURN
0224  0008  	RETURN
022A  0008  	RETURN
0230  0008  	RETURN
0236  0008  	RETURN



void FCM_display_temp()

{

	//Calculation
	//Calculation:
	//  temp_tens = temp_c / 10
	//  temp_ones = temp_c MOD 10
	//  temp_dec = temp_cdp
	FCV_TEMP_TENS = FCV_TEMP_C / 10;
03EC  1683  	BSF STATUS, RP0
03ED  1303  	BCF STATUS, RP1
03EE  01A8  	CLRF CompTempVar2207
03EF  1283  	BCF STATUS, RP0
03F0  0838  	MOVF gbl_FCV_TEMP_C, W
03F1  1683  	BSF STATUS, RP0
03F2  00A0  	MOVWF __div_32_3_00001_arg_a
03F3  1283  	BCF STATUS, RP0
03F4  0839  	MOVF gbl_FCV_TEMP_C+D'1', W
03F5  1683  	BSF STATUS, RP0
03F6  00A1  	MOVWF __div_32_3_00001_arg_a+D'1'
03F7  1283  	BCF STATUS, RP0
03F8  083A  	MOVF gbl_FCV_TEMP_C+D'2', W
03F9  1683  	BSF STATUS, RP0
03FA  00A2  	MOVWF __div_32_3_00001_arg_a+D'2'
03FB  1283  	BCF STATUS, RP0
03FC  083B  	MOVF gbl_FCV_TEMP_C+D'3', W
03FD  1683  	BSF STATUS, RP0
03FE  00A3  	MOVWF __div_32_3_00001_arg_a+D'3'
03FF  1283  	BCF STATUS, RP0
0400  1FBB  	BTFSS gbl_FCV_TEMP_C+D'3',7
0401  2C0F  	GOTO	label54
0402  1683  	BSF STATUS, RP0
0403  09A0  	COMF __div_32_3_00001_arg_a, F
0404  09A1  	COMF __div_32_3_00001_arg_a+D'1', F
0405  09A2  	COMF __div_32_3_00001_arg_a+D'2', F
0406  09A3  	COMF __div_32_3_00001_arg_a+D'3', F
0407  0AA0  	INCF __div_32_3_00001_arg_a, F
0408  1903  	BTFSC STATUS,Z
0409  0AA1  	INCF __div_32_3_00001_arg_a+D'1', F
040A  1903  	BTFSC STATUS,Z
040B  0AA2  	INCF __div_32_3_00001_arg_a+D'2', F
040C  1903  	BTFSC STATUS,Z
040D  0AA3  	INCF __div_32_3_00001_arg_a+D'3', F
040E  0AA8  	INCF CompTempVar2207, F
040F        label54
040F  300A  	MOVLW 0x0A
0410  1683  	BSF STATUS, RP0
0411  00A4  	MOVWF __div_32_3_00001_arg_b
0412  01A5  	CLRF __div_32_3_00001_arg_b+D'1'
0413  01A6  	CLRF __div_32_3_00001_arg_b+D'2'
0414  01A7  	CLRF __div_32_3_00001_arg_b+D'3'
0415  217A  	CALL __div_32_3_00001
0416  0831  	MOVF CompTempVarRet210, W
0417  1283  	BCF STATUS, RP0
0418  00D3  	MOVWF gbl_FCV_TEMP_TENS
0419  1683  	BSF STATUS, RP0
041A  1C28  	BTFSS CompTempVar2207,0
041B  2C1F  	GOTO	label55
041C  1283  	BCF STATUS, RP0
041D  09D3  	COMF gbl_FCV_TEMP_TENS, F
041E  0AD3  	INCF gbl_FCV_TEMP_TENS, F
041F        label55

	FCV_TEMP_ONES = FCV_TEMP_C % 10;
041F  1283  	BCF STATUS, RP0
0420  0838  	MOVF gbl_FCV_TEMP_C, W
0421  1683  	BSF STATUS, RP0
0422  00A0  	MOVWF __rem_32_3_00002_arg_a
0423  1283  	BCF STATUS, RP0
0424  0839  	MOVF gbl_FCV_TEMP_C+D'1', W
0425  1683  	BSF STATUS, RP0
0426  00A1  	MOVWF __rem_32_3_00002_arg_a+D'1'
0427  1283  	BCF STATUS, RP0
0428  083A  	MOVF gbl_FCV_TEMP_C+D'2', W
0429  1683  	BSF STATUS, RP0
042A  00A2  	MOVWF __rem_32_3_00002_arg_a+D'2'
042B  1283  	BCF STATUS, RP0
042C  083B  	MOVF gbl_FCV_TEMP_C+D'3', W
042D  1683  	BSF STATUS, RP0
042E  00A3  	MOVWF __rem_32_3_00002_arg_a+D'3'
042F  1283  	BCF STATUS, RP0
0430  1FBB  	BTFSS gbl_FCV_TEMP_C+D'3',7
0431  2C3E  	GOTO	label56
0432  1683  	BSF STATUS, RP0
0433  09A0  	COMF __rem_32_3_00002_arg_a, F
0434  09A1  	COMF __rem_32_3_00002_arg_a+D'1', F
0435  09A2  	COMF __rem_32_3_00002_arg_a+D'2', F
0436  09A3  	COMF __rem_32_3_00002_arg_a+D'3', F
0437  0AA0  	INCF __rem_32_3_00002_arg_a, F
0438  1903  	BTFSC STATUS,Z
0439  0AA1  	INCF __rem_32_3_00002_arg_a+D'1', F
043A  1903  	BTFSC STATUS,Z
043B  0AA2  	INCF __rem_32_3_00002_arg_a+D'2', F
043C  1903  	BTFSC STATUS,Z
043D  0AA3  	INCF __rem_32_3_00002_arg_a+D'3', F
043E        label56
043E  300A  	MOVLW 0x0A
043F  1683  	BSF STATUS, RP0
0440  00A4  	MOVWF __rem_32_3_00002_arg_b
0441  01A5  	CLRF __rem_32_3_00002_arg_b+D'1'
0442  01A6  	CLRF __rem_32_3_00002_arg_b+D'2'
0443  01A7  	CLRF __rem_32_3_00002_arg_b+D'3'
0444  2130  	CALL __rem_32_3_00002
0445  082D  	MOVF CompTempVarRet212, W
0446  1283  	BCF STATUS, RP0
0447  00DB  	MOVWF gbl_FCV_TEMP_ONES
0448  1FBB  	BTFSS gbl_FCV_TEMP_C+D'3',7
0449  2C4C  	GOTO	label57
044A  09DB  	COMF gbl_FCV_TEMP_ONES, F
044B  0ADB  	INCF gbl_FCV_TEMP_ONES, F
044C        label57

	FCV_TEMP_DEC = FCV_TEMP_CDP;
044C  0841  	MOVF gbl_FCV_TEMP_CDP, W
044D  00D9  	MOVWF gbl_FCV_TEMP_DEC


	//Output
	//Output: 0b00000001 -> PORTB
	trisb = 0x00;
044E  1683  	BSF STATUS, RP0
044F  0186  	CLRF gbl_trisb

	portb = (1);
0450  3001  	MOVLW 0x01
0451  1283  	BCF STATUS, RP0
0452  0086  	MOVWF gbl_portb


	//Call Macro
	//Call Macro: scan_off()
	FCM_scan_off();
0453  206E  	CALL FCM_scan_o_00051


	//Call Macro
	//Call Macro: scan1()
	FCM_scan1();
0454  20FF  	CALL FCM_scan1_00000


	//Calculation
	//Calculation:
	//  digit = temp_tens
	FCV_DIGIT = FCV_TEMP_TENS;
0455  0853  	MOVF gbl_FCV_TEMP_TENS, W
0456  00E0  	MOVWF gbl_FCV_DIGIT


	//Call Macro
	//Call Macro: seg_pattern()
	FCM_seg_pattern();
0457  21D9  	CALL FCM_seg_pa_00052


	//Delay
	//Delay: 4 ms
	delay_ms(4);
0458  3004  	MOVLW 0x04
0459  00FD  	MOVWF delay_ms_00000_arg_del
045A  2010  	CALL delay_ms_00000


	//Output
	//Output: 0b00000001 -> PORTB
	trisb = 0x00;
045B  1683  	BSF STATUS, RP0
045C  0186  	CLRF gbl_trisb

	portb = (1);
045D  3001  	MOVLW 0x01
045E  1283  	BCF STATUS, RP0
045F  0086  	MOVWF gbl_portb


	//Call Macro
	//Call Macro: scan_off()
	FCM_scan_off();
0460  206E  	CALL FCM_scan_o_00051


	//Call Macro
	//Call Macro: scan2()
	FCM_scan2();
0461  20DA  	CALL FCM_scan2_00000


	//Calculation
	//Calculation:
	//  digit = temp_ones
	FCV_DIGIT = FCV_TEMP_ONES;
0462  085B  	MOVF gbl_FCV_TEMP_ONES, W
0463  00E0  	MOVWF gbl_FCV_DIGIT


	//Call Macro
	//Call Macro: seg_pattern()
	FCM_seg_pattern();
0464  21D9  	CALL FCM_seg_pa_00052


	//Output
	//Output: 0 -> B0
	trisb = trisb & 0xFE;
0465  30FE  	MOVLW 0xFE
0466  1683  	BSF STATUS, RP0
0467  0506  	ANDWF gbl_trisb, W
0468  0086  	MOVWF gbl_trisb

	if ((0))
		portb = (portb & 0xFE) | 0x01;
	else
		portb = portb & 0xFE;
0469  30FE  	MOVLW 0xFE
046A  1283  	BCF STATUS, RP0
046B  0506  	ANDWF gbl_portb, W
046C  0086  	MOVWF gbl_portb


	//Delay
	//Delay: 4 ms
	delay_ms(4);
046D  3004  	MOVLW 0x04
046E  00FD  	MOVWF delay_ms_00000_arg_del
046F  2010  	CALL delay_ms_00000


	//Output
	//Output: 0b00000001 -> PORTB
	trisb = 0x00;
0470  1683  	BSF STATUS, RP0
0471  0186  	CLRF gbl_trisb

	portb = (1);
0472  3001  	MOVLW 0x01
0473  1283  	BCF STATUS, RP0
0474  0086  	MOVWF gbl_portb


	//Call Macro
	//Call Macro: scan_off()
	FCM_scan_off();
0475  206E  	CALL FCM_scan_o_00051


	//Call Macro
	//Call Macro: scan3()
	FCM_scan3();
0476  20B5  	CALL FCM_scan3_00000


	//Calculation
	//Calculation:
	//  digit = temp_dec
	FCV_DIGIT = FCV_TEMP_DEC;
0477  0859  	MOVF gbl_FCV_TEMP_DEC, W
0478  00E0  	MOVWF gbl_FCV_DIGIT


	//Call Macro
	//Call Macro: seg_pattern()
	FCM_seg_pattern();
0479  21D9  	CALL FCM_seg_pa_00052


	//Delay
	//Delay: 4 ms
	delay_ms(4);
047A  3004  	MOVLW 0x04
047B  00FD  	MOVWF delay_ms_00000_arg_del
047C  2010  	CALL delay_ms_00000


	//Output
	//Output: 0b00000001 -> PORTB
	trisb = 0x00;
047D  1683  	BSF STATUS, RP0
047E  0186  	CLRF gbl_trisb

	portb = (1);
047F  3001  	MOVLW 0x01
0480  1283  	BCF STATUS, RP0
0481  0086  	MOVWF gbl_portb


	//Call Macro
	//Call Macro: scan_off()
	FCM_scan_off();
0482  206E  	CALL FCM_scan_o_00051


	//Call Macro
	//Call Macro: scan4()
	FCM_scan4();
0483  2090  	CALL FCM_scan4_00000


	//Output
	//Output: 0b11100000 -> PORTB
	trisb = 0x00;
0484  1683  	BSF STATUS, RP0
0485  0186  	CLRF gbl_trisb

	portb = (224);
0486  30E0  	MOVLW 0xE0
0487  1283  	BCF STATUS, RP0
0488  0086  	MOVWF gbl_portb


	//Delay
	//Delay: 4 ms
	delay_ms(4);
0489  3004  	MOVLW 0x04
048A  00FD  	MOVWF delay_ms_00000_arg_del
048B  2010  	CALL delay_ms_00000


}
048C  0008  	RETURN



void FCM_all_input()

{

	//Input
	//Input: C0 -> prox_bit
	trisc = trisc | 0x01;
0591  3001  	MOVLW 0x01
0592  1683  	BSF STATUS, RP0
0593  1303  	BCF STATUS, RP1
0594  0407  	IORWF gbl_trisc, W
0595  0087  	MOVWF gbl_trisc

	FCV_PROX_BIT = ((portc & 0x01) == 0x01);
0596  3001  	MOVLW 0x01
0597  1283  	BCF STATUS, RP0
0598  0507  	ANDWF gbl_portc, W
0599  00FD  	MOVWF CompTempVar2209
059A  01FE  	CLRF CompTempVar2210
059B  037D  	DECF CompTempVar2209, W
059C  1903  	BTFSC STATUS,Z
059D  0AFE  	INCF CompTempVar2210, F
059E  105C  	BCF gbl_FCV_PROX_BIT,0
059F  087E  	MOVF CompTempVar2210, W
05A0  1D03  	BTFSS STATUS,Z
05A1  145C  	BSF gbl_FCV_PROX_BIT,0


	//Input
	//Input: C6 -> swg
	trisc = trisc | 0x40;
05A2  3040  	MOVLW 0x40
05A3  1683  	BSF STATUS, RP0
05A4  0407  	IORWF gbl_trisc, W
05A5  0087  	MOVWF gbl_trisc

	FCV_SWG = ((portc & 0x40) == 0x40);
05A6  3040  	MOVLW 0x40
05A7  1283  	BCF STATUS, RP0
05A8  0507  	ANDWF gbl_portc, W
05A9  00FD  	MOVWF CompTempVar2211
05AA  01FE  	CLRF CompTempVar2212
05AB  3040  	MOVLW 0x40
05AC  027D  	SUBWF CompTempVar2211, W
05AD  1903  	BTFSC STATUS,Z
05AE  0AFE  	INCF CompTempVar2212, F
05AF  11DC  	BCF gbl_FCV_SWG,3
05B0  087E  	MOVF CompTempVar2212, W
05B1  1D03  	BTFSS STATUS,Z
05B2  15DC  	BSF gbl_FCV_SWG,3


	//Input
	//Input: C7 -> swr
	trisc = trisc | 0x80;
05B3  3080  	MOVLW 0x80
05B4  1683  	BSF STATUS, RP0
05B5  0407  	IORWF gbl_trisc, W
05B6  0087  	MOVWF gbl_trisc

	FCV_SWR = ((portc & 0x80) == 0x80);
05B7  3080  	MOVLW 0x80
05B8  1283  	BCF STATUS, RP0
05B9  0507  	ANDWF gbl_portc, W
05BA  00FD  	MOVWF CompTempVar2213
05BB  01E2  	CLRF gbl_FCV_SWR
05BC  3080  	MOVLW 0x80
05BD  027D  	SUBWF CompTempVar2213, W
05BE  1903  	BTFSC STATUS,Z
05BF  0AE2  	INCF gbl_FCV_SWR, F


}
05C0  0008  	RETURN



void FCM_pass()

{

	//Call Component Macro
	//Call Component Macro: LEDOff()
	FCD_LED0_LEDOff();
05D3  212A  	CALL FCD_LED0_L_00055


	//Call Component Macro
	//Call Component Macro: LEDOn()
	FCD_LED1_LEDOn();
05D4  25C1  	CALL FCD_LED1_L_00056


}
05D5  0008  	RETURN



void FCM_failed()

{

	//Call Component Macro
	//Call Component Macro: LEDOn()
	FCD_LED0_LEDOn();
0348  226C  	CALL FCD_LED0_L_00057


	//Call Component Macro
	//Call Component Macro: LEDOff()
	FCD_LED1_LEDOff();
0349  2124  	CALL FCD_LED1_L_00058


}
034A  0008  	RETURN



void FCM_calc()

{

	//Calculation
	//Calculation:
	//  lsb = data0
	//  msb = data1
	FCV_LSB = FCV_DATA0;
048D  1283  	BCF STATUS, RP0
048E  1303  	BCF STATUS, RP1
048F  0854  	MOVF gbl_FCV_DATA0, W
0490  00DF  	MOVWF gbl_FCV_LSB

	FCV_MSB = FCV_DATA1;
0491  0855  	MOVF gbl_FCV_DATA1, W
0492  00E1  	MOVWF gbl_FCV_MSB


	//Calculation
	//Calculation:
	//  raw = msb
	FCV_RAW = FCV_MSB;
0493  0861  	MOVF gbl_FCV_MSB, W
0494  00B4  	MOVWF gbl_FCV_RAW
0495  01B5  	CLRF gbl_FCV_RAW+D'1'
0496  01B6  	CLRF gbl_FCV_RAW+D'2'
0497  01B7  	CLRF gbl_FCV_RAW+D'3'


	//Loop
	//Loop: Loop 8 times
	for (FCLV_LOOP3=0; FCLV_LOOP3<8; FCLV_LOOP3++)
0498  01EC  	CLRF gbl_FCLV_LOOP3
0499        label58
0499  3008  	MOVLW 0x08
049A  026C  	SUBWF gbl_FCLV_LOOP3, W
049B  1803  	BTFSC STATUS,C
049C  2CA8  	GOTO	label59
04A6  0AEC  	INCF gbl_FCLV_LOOP3, F
04A7  2C99  	GOTO	label58
04A8        label59

	{

		//Calculation
		//Calculation:
		//  raw = raw << 1
		FCV_RAW = FCV_RAW << 1;
049D  08B4  	MOVF gbl_FCV_RAW, F
049E  08B5  	MOVF gbl_FCV_RAW+D'1', F
049F  08B6  	MOVF gbl_FCV_RAW+D'2', F
04A0  08B7  	MOVF gbl_FCV_RAW+D'3', F
04A1  1003  	BCF STATUS,C
04A2  0DB4  	RLF gbl_FCV_RAW, F
04A3  0DB5  	RLF gbl_FCV_RAW+D'1', F
04A4  0DB6  	RLF gbl_FCV_RAW+D'2', F
04A5  0DB7  	RLF gbl_FCV_RAW+D'3', F



	}

	//Calculation
	//Calculation:
	//  raw = raw + lsb
	FCV_RAW = FCV_RAW + FCV_LSB;
04A8  085F  	MOVF gbl_FCV_LSB, W
04A9  00F5  	MOVWF CompTempVar2221
04AA  01F6  	CLRF CompTempVar2222
04AB  01F7  	CLRF CompTempVar2223
04AC  01F8  	CLRF CompTempVar2224
04AD  0834  	MOVF gbl_FCV_RAW, W
04AE  07F5  	ADDWF CompTempVar2221, F
04AF  0835  	MOVF gbl_FCV_RAW+D'1', W
04B0  1803  	BTFSC STATUS,C
04B1  0F35  	INCFSZ gbl_FCV_RAW+D'1', W
04B2  07F6  	ADDWF CompTempVar2222, F
04B3  0836  	MOVF gbl_FCV_RAW+D'2', W
04B4  1803  	BTFSC STATUS,C
04B5  0F36  	INCFSZ gbl_FCV_RAW+D'2', W
04B6  07F7  	ADDWF CompTempVar2223, F
04B7  0837  	MOVF gbl_FCV_RAW+D'3', W
04B8  1803  	BTFSC STATUS,C
04B9  0F37  	INCFSZ gbl_FCV_RAW+D'3', W
04BA  07F8  	ADDWF CompTempVar2224, F
04BB  0875  	MOVF CompTempVar2221, W
04BC  00B4  	MOVWF gbl_FCV_RAW
04BD  0876  	MOVF CompTempVar2222, W
04BE  00B5  	MOVWF gbl_FCV_RAW+D'1'
04BF  0877  	MOVF CompTempVar2223, W
04C0  00B6  	MOVWF gbl_FCV_RAW+D'2'
04C1  0878  	MOVF CompTempVar2224, W
04C2  00B7  	MOVWF gbl_FCV_RAW+D'3'


	//Calculation
	//Calculation:
	//  temp_c = (raw / 50) - calib_subtractor
	FCV_TEMP_C = (FCV_RAW / 50) - FCV_CALIB_SUBTRACTOR;
04C3  01FD  	CLRF CompTempVar2234
04C4  0834  	MOVF gbl_FCV_RAW, W
04C5  1683  	BSF STATUS, RP0
04C6  00A0  	MOVWF __div_32_3_00001_arg_a
04C7  1283  	BCF STATUS, RP0
04C8  0835  	MOVF gbl_FCV_RAW+D'1', W
04C9  1683  	BSF STATUS, RP0
04CA  00A1  	MOVWF __div_32_3_00001_arg_a+D'1'
04CB  1283  	BCF STATUS, RP0
04CC  0836  	MOVF gbl_FCV_RAW+D'2', W
04CD  1683  	BSF STATUS, RP0
04CE  00A2  	MOVWF __div_32_3_00001_arg_a+D'2'
04CF  1283  	BCF STATUS, RP0
04D0  0837  	MOVF gbl_FCV_RAW+D'3', W
04D1  1683  	BSF STATUS, RP0
04D2  00A3  	MOVWF __div_32_3_00001_arg_a+D'3'
04D3  1283  	BCF STATUS, RP0
04D4  1FB7  	BTFSS gbl_FCV_RAW+D'3',7
04D5  2CE4  	GOTO	label60
04D6  1683  	BSF STATUS, RP0
04D7  09A0  	COMF __div_32_3_00001_arg_a, F
04D8  09A1  	COMF __div_32_3_00001_arg_a+D'1', F
04D9  09A2  	COMF __div_32_3_00001_arg_a+D'2', F
04DA  09A3  	COMF __div_32_3_00001_arg_a+D'3', F
04DB  0AA0  	INCF __div_32_3_00001_arg_a, F
04DC  1903  	BTFSC STATUS,Z
04DD  0AA1  	INCF __div_32_3_00001_arg_a+D'1', F
04DE  1903  	BTFSC STATUS,Z
04DF  0AA2  	INCF __div_32_3_00001_arg_a+D'2', F
04E0  1903  	BTFSC STATUS,Z
04E1  0AA3  	INCF __div_32_3_00001_arg_a+D'3', F
04E2  1283  	BCF STATUS, RP0
04E3  0AFD  	INCF CompTempVar2234, F
04E4        label60
04E4  3032  	MOVLW 0x32
04E5  1683  	BSF STATUS, RP0
04E6  00A4  	MOVWF __div_32_3_00001_arg_b
04E7  01A5  	CLRF __div_32_3_00001_arg_b+D'1'
04E8  01A6  	CLRF __div_32_3_00001_arg_b+D'2'
04E9  01A7  	CLRF __div_32_3_00001_arg_b+D'3'
04EA  217A  	CALL __div_32_3_00001
04EB  0831  	MOVF CompTempVarRet210, W
04EC  1283  	BCF STATUS, RP0
04ED  00B8  	MOVWF gbl_FCV_TEMP_C
04EE  1683  	BSF STATUS, RP0
04EF  0832  	MOVF CompTempVarRet210+D'1', W
04F0  1283  	BCF STATUS, RP0
04F1  00B9  	MOVWF gbl_FCV_TEMP_C+D'1'
04F2  1683  	BSF STATUS, RP0
04F3  0833  	MOVF CompTempVarRet210+D'2', W
04F4  1283  	BCF STATUS, RP0
04F5  00BA  	MOVWF gbl_FCV_TEMP_C+D'2'
04F6  1683  	BSF STATUS, RP0
04F7  0834  	MOVF CompTempVarRet210+D'3', W
04F8  1283  	BCF STATUS, RP0
04F9  00BB  	MOVWF gbl_FCV_TEMP_C+D'3'
04FA  1C7D  	BTFSS CompTempVar2234,0
04FB  2D07  	GOTO	label61
04FC  09B8  	COMF gbl_FCV_TEMP_C, F
04FD  09B9  	COMF gbl_FCV_TEMP_C+D'1', F
04FE  09BA  	COMF gbl_FCV_TEMP_C+D'2', F
04FF  09BB  	COMF gbl_FCV_TEMP_C+D'3', F
0500  0AB8  	INCF gbl_FCV_TEMP_C, F
0501  1903  	BTFSC STATUS,Z
0502  0AB9  	INCF gbl_FCV_TEMP_C+D'1', F
0503  1903  	BTFSC STATUS,Z
0504  0ABA  	INCF gbl_FCV_TEMP_C+D'2', F
0505  1903  	BTFSC STATUS,Z
0506  0ABB  	INCF gbl_FCV_TEMP_C+D'3', F
0507        label61
0507  0843  	MOVF gbl_FCV_CALIB_SUBTRACTOR, W
0508  1683  	BSF STATUS, RP0
0509  00A8  	MOVWF CompTempVar2225
050A  1283  	BCF STATUS, RP0
050B  0844  	MOVF gbl_FCV_CALIB_SUBTRACTOR+D'1', W
050C  1683  	BSF STATUS, RP0
050D  00A9  	MOVWF CompTempVar2225+D'1'
050E  01AA  	CLRF CompTempVar2225+D'2'
050F  01AB  	CLRF CompTempVar2225+D'3'
0510  0828  	MOVF CompTempVar2225, W
0511  1283  	BCF STATUS, RP0
0512  02B8  	SUBWF gbl_FCV_TEMP_C, F
0513  1683  	BSF STATUS, RP0
0514  0829  	MOVF CompTempVar2225+D'1', W
0515  1803  	BTFSC STATUS,C
0516  2D1A  	GOTO	label62
0517  0F29  	INCFSZ CompTempVar2225+D'1', W
0518  2D1A  	GOTO	label62
0519  2D1C  	GOTO	label63
051A        label62
051A  1283  	BCF STATUS, RP0
051B  02B9  	SUBWF gbl_FCV_TEMP_C+D'1', F
051C        label63
051C  1683  	BSF STATUS, RP0
051D  082A  	MOVF CompTempVar2225+D'2', W
051E  1803  	BTFSC STATUS,C
051F  2D23  	GOTO	label64
0520  0F2A  	INCFSZ CompTempVar2225+D'2', W
0521  2D23  	GOTO	label64
0522  2D25  	GOTO	label65
0523        label64
0523  1283  	BCF STATUS, RP0
0524  02BA  	SUBWF gbl_FCV_TEMP_C+D'2', F
0525        label65
0525  1683  	BSF STATUS, RP0
0526  082B  	MOVF CompTempVar2225+D'3', W
0527  1803  	BTFSC STATUS,C
0528  2D2C  	GOTO	label66
0529  0F2B  	INCFSZ CompTempVar2225+D'3', W
052A  2D2C  	GOTO	label66
052B  2D2E  	GOTO	label67
052C        label66
052C  1283  	BCF STATUS, RP0
052D  02BB  	SUBWF gbl_FCV_TEMP_C+D'3', F
052E        label67


	//Calculation
	//Calculation:
	//  dp2 = raw % 50
	FCV_DP2 = FCV_RAW % 50;
052E  1283  	BCF STATUS, RP0
052F  0834  	MOVF gbl_FCV_RAW, W
0530  1683  	BSF STATUS, RP0
0531  00A0  	MOVWF __rem_32_3_00002_arg_a
0532  1283  	BCF STATUS, RP0
0533  0835  	MOVF gbl_FCV_RAW+D'1', W
0534  1683  	BSF STATUS, RP0
0535  00A1  	MOVWF __rem_32_3_00002_arg_a+D'1'
0536  1283  	BCF STATUS, RP0
0537  0836  	MOVF gbl_FCV_RAW+D'2', W
0538  1683  	BSF STATUS, RP0
0539  00A2  	MOVWF __rem_32_3_00002_arg_a+D'2'
053A  1283  	BCF STATUS, RP0
053B  0837  	MOVF gbl_FCV_RAW+D'3', W
053C  1683  	BSF STATUS, RP0
053D  00A3  	MOVWF __rem_32_3_00002_arg_a+D'3'
053E  1283  	BCF STATUS, RP0
053F  1FB7  	BTFSS gbl_FCV_RAW+D'3',7
0540  2D4D  	GOTO	label68
0541  1683  	BSF STATUS, RP0
0542  09A0  	COMF __rem_32_3_00002_arg_a, F
0543  09A1  	COMF __rem_32_3_00002_arg_a+D'1', F
0544  09A2  	COMF __rem_32_3_00002_arg_a+D'2', F
0545  09A3  	COMF __rem_32_3_00002_arg_a+D'3', F
0546  0AA0  	INCF __rem_32_3_00002_arg_a, F
0547  1903  	BTFSC STATUS,Z
0548  0AA1  	INCF __rem_32_3_00002_arg_a+D'1', F
0549  1903  	BTFSC STATUS,Z
054A  0AA2  	INCF __rem_32_3_00002_arg_a+D'2', F
054B  1903  	BTFSC STATUS,Z
054C  0AA3  	INCF __rem_32_3_00002_arg_a+D'3', F
054D        label68
054D  3032  	MOVLW 0x32
054E  1683  	BSF STATUS, RP0
054F  00A4  	MOVWF __rem_32_3_00002_arg_b
0550  01A5  	CLRF __rem_32_3_00002_arg_b+D'1'
0551  01A6  	CLRF __rem_32_3_00002_arg_b+D'2'
0552  01A7  	CLRF __rem_32_3_00002_arg_b+D'3'
0553  2130  	CALL __rem_32_3_00002
0554  082D  	MOVF CompTempVarRet212, W
0555  1283  	BCF STATUS, RP0
0556  00D7  	MOVWF gbl_FCV_DP2
0557  1FB7  	BTFSS gbl_FCV_RAW+D'3',7
0558  2D5B  	GOTO	label69
0559  09D7  	COMF gbl_FCV_DP2, F
055A  0AD7  	INCF gbl_FCV_DP2, F
055B        label69


	//Decision
	//Decision: dp2 >= 100?
	if (FCV_DP2 >= 100)
055B  3064  	MOVLW 0x64
055C  0257  	SUBWF gbl_FCV_DP2, W
055D  1C03  	BTFSS STATUS,C
055E  2D68  	GOTO	label70
0568        label70

	{

		//Calculation
		//Calculation:
		//  temp_cdp = dp2 / 100
		FCV_TEMP_CDP = FCV_DP2 / 100;
055F  0857  	MOVF gbl_FCV_DP2, W
0560  00F7  	MOVWF __div_8_8_00000_arg_a
0561  3064  	MOVLW 0x64
0562  00F8  	MOVWF __div_8_8_00000_arg_b
0563  2169  	CALL __div_8_8_00000
0564  087B  	MOVF CompTempVarRet218, W
0565  00C1  	MOVWF gbl_FCV_TEMP_CDP
0566  01C2  	CLRF gbl_FCV_TEMP_CDP+D'1'


	} else {
0567  2D86  	GOTO	label72


		//Decision
		//Decision: dp2 >= 10 AND dp2 <= 100?
		if (FCV_DP2 >= 10 & FCV_DP2 <= 100)
0568  01F6  	CLRF CompTempVar2239
0569  300A  	MOVLW 0x0A
056A  0257  	SUBWF gbl_FCV_DP2, W
056B  1803  	BTFSC STATUS,C
056C  0AF6  	INCF CompTempVar2239, F
056D  01F5  	CLRF CompTempVar2238
056E  0857  	MOVF gbl_FCV_DP2, W
056F  3C64  	SUBLW 0x64
0570  1803  	BTFSC STATUS,C
0571  0AF5  	INCF CompTempVar2238, F
0572  0875  	MOVF CompTempVar2238, W
0573  0576  	ANDWF CompTempVar2239, W
0574  1903  	BTFSC STATUS,Z
0575  2D7F  	GOTO	label71
057F        label71

		{

			//Calculation
			//Calculation:
			//  temp_cdp = dp2 / 10
			FCV_TEMP_CDP = FCV_DP2 / 10;
0576  0857  	MOVF gbl_FCV_DP2, W
0577  00F7  	MOVWF __div_8_8_00000_arg_a
0578  300A  	MOVLW 0x0A
0579  00F8  	MOVWF __div_8_8_00000_arg_b
057A  2169  	CALL __div_8_8_00000
057B  087B  	MOVF CompTempVarRet218, W
057C  00C1  	MOVWF gbl_FCV_TEMP_CDP
057D  01C2  	CLRF gbl_FCV_TEMP_CDP+D'1'


		} else {
057E  2D86  	GOTO	label72


			//Decision
			//Decision: dp2 < 10?
			if (FCV_DP2 < 10)
057F  300A  	MOVLW 0x0A
0580  0257  	SUBWF gbl_FCV_DP2, W
0581  1803  	BTFSC STATUS,C
0582  2D86  	GOTO	label72
0586        label72

			{

				//Calculation
				//Calculation:
				//  temp_cdp = dp2
				FCV_TEMP_CDP = FCV_DP2;
0583  0857  	MOVF gbl_FCV_DP2, W
0584  00C1  	MOVWF gbl_FCV_TEMP_CDP
0585  01C2  	CLRF gbl_FCV_TEMP_CDP+D'1'


			// } else {

			}

		}

	}

	//Calculation
	//Calculation:
	//  temp_cdp = temp_cdp + calib_offset
	FCV_TEMP_CDP = FCV_TEMP_CDP + FCV_CALIB_OFFSET;
0586  0847  	MOVF gbl_FCV_CALIB_OFFSET, W
0587  07C1  	ADDWF gbl_FCV_TEMP_CDP, F
0588  0848  	MOVF gbl_FCV_CALIB_OFFSET+D'1', W
0589  00F5  	MOVWF CompTempVar2243
058A  0842  	MOVF gbl_FCV_TEMP_CDP+D'1', W
058B  1803  	BTFSC STATUS,C
058C  0AF5  	INCF CompTempVar2243, F
058D  07F5  	ADDWF CompTempVar2243, F
058E  0875  	MOVF CompTempVar2243, W
058F  00C2  	MOVWF gbl_FCV_TEMP_CDP+D'1'


}
0590  0008  	RETURN



void FCM_i2c_comm()

{

	//Call Component Macro
	//Call Component Macro: MI2C_Start()
	FCD_I2C_Master0_MI2C_Start();
031B  2282  	CALL FCD_I2C_Ma_0005A


	//Calculation
	//Calculation:
	//  rt_byte = 0
	FCV_RT_BYTE = 0;
031C  1283  	BCF STATUS, RP0
031D  01DE  	CLRF gbl_FCV_RT_BYTE


	//Call Component Macro
	//Call Component Macro: rt_byte=MI2C_Transmit_Byte(0xB4)
	FCV_RT_BYTE = FCD_I2C_Master0_MI2C_Transmit_Byte(0xB4);
031E  30B4  	MOVLW 0xB4
031F  00F5  	MOVWF FCD_I2C_Ma_0005B_arg_Data
0320  227C  	CALL FCD_I2C_Ma_0005B
0321  0876  	MOVF CompTempVarRet2244, W
0322  00DE  	MOVWF gbl_FCV_RT_BYTE


	//Calculation
	//Calculation:
	//  rt_byte = 0
	FCV_RT_BYTE = 0;
0323  01DE  	CLRF gbl_FCV_RT_BYTE


	//Call Component Macro
	//Call Component Macro: rt_byte=MI2C_Transmit_Byte(0x07)
	FCV_RT_BYTE = FCD_I2C_Master0_MI2C_Transmit_Byte(0x07);
0324  3007  	MOVLW 0x07
0325  00F5  	MOVWF FCD_I2C_Ma_0005B_arg_Data
0326  227C  	CALL FCD_I2C_Ma_0005B
0327  0876  	MOVF CompTempVarRet2244, W
0328  00DE  	MOVWF gbl_FCV_RT_BYTE


	//Comment:
	//end of RD/WR cmd

	//Call Component Macro
	//Call Component Macro: MI2C_Restart()
	FCD_I2C_Master0_MI2C_Restart();
0329  227A  	CALL FCD_I2C_Ma_0005C


	//Calculation
	//Calculation:
	//  rt_byte = 0
	FCV_RT_BYTE = 0;
032A  1283  	BCF STATUS, RP0
032B  01DE  	CLRF gbl_FCV_RT_BYTE


	//Call Component Macro
	//Call Component Macro: rt_byte=MI2C_Transmit_Byte(0xB4)
	FCV_RT_BYTE = FCD_I2C_Master0_MI2C_Transmit_Byte(0xB4);
032C  30B4  	MOVLW 0xB4
032D  00F5  	MOVWF FCD_I2C_Ma_0005B_arg_Data
032E  227C  	CALL FCD_I2C_Ma_0005B
032F  0876  	MOVF CompTempVarRet2244, W
0330  00DE  	MOVWF gbl_FCV_RT_BYTE


	//Call Component Macro
	//Call Component Macro: i2c_rx=MI2C_Receive_Byte(rt_byte)
	FCV_I2C_RX = FCD_I2C_Master0_MI2C_Receive_Byte(FCV_RT_BYTE);
0331  085E  	MOVF gbl_FCV_RT_BYTE, W
0332  00F5  	MOVWF FCD_I2C_Ma_0005D_arg_Last
0333  2274  	CALL FCD_I2C_Ma_0005D
0334  0876  	MOVF CompTempVarRet2245, W
0335  00E4  	MOVWF gbl_FCV_I2C_RX


	//Calculation
	//Calculation:
	//  data0 = i2c_rx
	FCV_DATA0 = FCV_I2C_RX;
0336  0864  	MOVF gbl_FCV_I2C_RX, W
0337  00D4  	MOVWF gbl_FCV_DATA0


	//Call Component Macro
	//Call Component Macro: i2c_rx=MI2C_Receive_Byte(rt_byte)
	FCV_I2C_RX = FCD_I2C_Master0_MI2C_Receive_Byte(FCV_RT_BYTE);
0338  085E  	MOVF gbl_FCV_RT_BYTE, W
0339  00F5  	MOVWF FCD_I2C_Ma_0005D_arg_Last
033A  2274  	CALL FCD_I2C_Ma_0005D
033B  0876  	MOVF CompTempVarRet2245, W
033C  00E4  	MOVWF gbl_FCV_I2C_RX


	//Calculation
	//Calculation:
	//  data1 = i2c_rx
	FCV_DATA1 = FCV_I2C_RX;
033D  0864  	MOVF gbl_FCV_I2C_RX, W
033E  00D5  	MOVWF gbl_FCV_DATA1


	//Call Component Macro
	//Call Component Macro: i2c_rx=MI2C_Receive_Byte(rt_byte)
	FCV_I2C_RX = FCD_I2C_Master0_MI2C_Receive_Byte(FCV_RT_BYTE);
033F  085E  	MOVF gbl_FCV_RT_BYTE, W
0340  00F5  	MOVWF FCD_I2C_Ma_0005D_arg_Last
0341  2274  	CALL FCD_I2C_Ma_0005D
0342  0876  	MOVF CompTempVarRet2245, W
0343  00E4  	MOVWF gbl_FCV_I2C_RX


	//Calculation
	//Calculation:
	//  data2 = i2c_rx
	FCV_DATA2 = FCV_I2C_RX;
0344  0864  	MOVF gbl_FCV_I2C_RX, W
0345  00D6  	MOVWF gbl_FCV_DATA2


	//Call Component Macro
	//Call Component Macro: MI2C_Stop()
	FCD_I2C_Master0_MI2C_Stop();
0346  2272  	CALL FCD_I2C_Ma_0005E


}
0347  0008  	RETURN



void FCM_lights_off()

{

	//Call Component Macro
	//Call Component Macro: LEDOff()
	FCD_LED0_LEDOff();
0237  212A  	CALL FCD_LED0_L_00055


	//Call Component Macro
	//Call Component Macro: LEDOff()
	FCD_LED1_LEDOff();
0238  2124  	CALL FCD_LED1_L_00058


}
0239  0008  	RETURN



void FCM_beep_once()

{

	//Call Component Macro
	//Call Component Macro: SetDutyCycle(160)
	FCD_PWM0_SetDutyCycle(160);
06D5  30A0  	MOVLW 0xA0
06D6  1283  	BCF STATUS, RP0
06D7  1303  	BCF STATUS, RP1
06D8  00FD  	MOVWF FCD_PWM0_S_00061_arg_nDuty
06D9  2268  	CALL FCD_PWM0_S_00061


	//Delay
	//Delay: 100 ms
	delay_ms(100);
06DA  3064  	MOVLW 0x64
06DB  00FD  	MOVWF delay_ms_00000_arg_del
06DC  2010  	CALL delay_ms_00000


	//Call Component Macro
	//Call Component Macro: SetDutyCycle(0)
	FCD_PWM0_SetDutyCycle(0);
06DD  01FD  	CLRF FCD_PWM0_S_00061_arg_nDuty
06DE  2268  	CALL FCD_PWM0_S_00061


}
06DF  0008  	RETURN



void FCM_get_temp()

{

	//Connection Point
	//Connection Point: [A]: A
FCC_get_temp_A:
05D6        label73

;

	//Call Macro
	//Call Macro: i2c_comm()
	FCM_i2c_comm();
05D6  231B  	CALL FCM_i2c_co_00059


	//Calculation
	//Calculation:
	//  data_prev = data1
	FCV_DATA_PREV = FCV_DATA1;
05D7  0855  	MOVF gbl_FCV_DATA1, W
05D8  00E6  	MOVWF gbl_FCV_DATA_PREV


	//Call Macro
	//Call Macro: i2c_comm()
	FCM_i2c_comm();
05D9  231B  	CALL FCM_i2c_co_00059


	//Calculation
	//Calculation:
	//  data_diff = data_prev - data1
	FCV_DATA_DIFF = FCV_DATA_PREV - FCV_DATA1;
05DA  0855  	MOVF gbl_FCV_DATA1, W
05DB  0266  	SUBWF gbl_FCV_DATA_PREV, W
05DC  00E9  	MOVWF gbl_FCV_DATA_DIFF


	//Decision
	//Decision: data_diff > 10?
	if (FCV_DATA_DIFF > 10)
05DD  0869  	MOVF gbl_FCV_DATA_DIFF, W
05DE  3C0A  	SUBLW 0x0A
05DF  1C03  	BTFSS STATUS,C

	{

		//Goto Connection Point
		//Goto Connection Point: [A]: A
		goto FCC_get_temp_A;
05E0  2DD6  	GOTO	label73
05E1        label74


	// } else {

	}

	//Connection Point
	//Connection Point: [B]: B
FCC_get_temp_B:
;

	//Call Macro
	//Call Macro: i2c_comm()
	FCM_i2c_comm();
05E1  231B  	CALL FCM_i2c_co_00059


	//Calculation
	//Calculation:
	//  data_prev = data1
	FCV_DATA_PREV = FCV_DATA1;
05E2  0855  	MOVF gbl_FCV_DATA1, W
05E3  00E6  	MOVWF gbl_FCV_DATA_PREV


	//Call Macro
	//Call Macro: i2c_comm()
	FCM_i2c_comm();
05E4  231B  	CALL FCM_i2c_co_00059


	//Calculation
	//Calculation:
	//  data_diff = data_prev - data1
	FCV_DATA_DIFF = FCV_DATA_PREV - FCV_DATA1;
05E5  0855  	MOVF gbl_FCV_DATA1, W
05E6  0266  	SUBWF gbl_FCV_DATA_PREV, W
05E7  00E9  	MOVWF gbl_FCV_DATA_DIFF


	//Decision
	//Decision: data_diff > 10?
	if (FCV_DATA_DIFF > 10)
05E8  0869  	MOVF gbl_FCV_DATA_DIFF, W
05E9  3C0A  	SUBLW 0x0A
05EA  1C03  	BTFSS STATUS,C

	{

		//Goto Connection Point
		//Goto Connection Point: [B]: B
		goto FCC_get_temp_B;
05EB  2DE1  	GOTO	label74


	// } else {

	}

	//Call Macro
	//Call Macro: calc()
	FCM_calc();
05EC  248D  	CALL FCM_calc_00000


}
05ED  0008  	RETURN



void FCM_display_repeat()

{

	//Call Macro
	//Call Macro: scan_off()
	FCM_scan_off();
023A  206E  	CALL FCM_scan_o_00051


	//Call Macro
	//Call Macro: scan1()
	FCM_scan1();
023B  20FF  	CALL FCM_scan1_00000


	//Output
	//Output: 0b10000001 -> PORTB
	trisb = 0x00;
023C  1683  	BSF STATUS, RP0
023D  0186  	CLRF gbl_trisb

	portb = (129);
023E  3081  	MOVLW 0x81
023F  1283  	BCF STATUS, RP0
0240  0086  	MOVWF gbl_portb


	//Delay
	//Delay: 4 ms
	delay_ms(4);
0241  3004  	MOVLW 0x04
0242  00FD  	MOVWF delay_ms_00000_arg_del
0243  2010  	CALL delay_ms_00000


	//Call Macro
	//Call Macro: scan_off()
	FCM_scan_off();
0244  206E  	CALL FCM_scan_o_00051


	//Call Macro
	//Call Macro: scan2()
	FCM_scan2();
0245  20DA  	CALL FCM_scan2_00000


	//Output
	//Output: 0b10000001 -> PORTB
	trisb = 0x00;
0246  1683  	BSF STATUS, RP0
0247  0186  	CLRF gbl_trisb

	portb = (129);
0248  3081  	MOVLW 0x81
0249  1283  	BCF STATUS, RP0
024A  0086  	MOVWF gbl_portb


	//Delay
	//Delay: 4 ms
	delay_ms(4);
024B  3004  	MOVLW 0x04
024C  00FD  	MOVWF delay_ms_00000_arg_del
024D  2010  	CALL delay_ms_00000


	//Call Macro
	//Call Macro: scan_off()
	FCM_scan_off();
024E  206E  	CALL FCM_scan_o_00051


	//Call Macro
	//Call Macro: scan3()
	FCM_scan3();
024F  20B5  	CALL FCM_scan3_00000


	//Output
	//Output: 0b10000001 -> PORTB
	trisb = 0x00;
0250  1683  	BSF STATUS, RP0
0251  0186  	CLRF gbl_trisb

	portb = (129);
0252  3081  	MOVLW 0x81
0253  1283  	BCF STATUS, RP0
0254  0086  	MOVWF gbl_portb


	//Delay
	//Delay: 4 ms
	delay_ms(4);
0255  3004  	MOVLW 0x04
0256  00FD  	MOVWF delay_ms_00000_arg_del
0257  2010  	CALL delay_ms_00000


	//Output
	//Output: 0b10000001 -> PORTB
	trisb = 0x00;
0258  1683  	BSF STATUS, RP0
0259  0186  	CLRF gbl_trisb

	portb = (129);
025A  3081  	MOVLW 0x81
025B  1283  	BCF STATUS, RP0
025C  0086  	MOVWF gbl_portb


	//Call Macro
	//Call Macro: scan_off()
	FCM_scan_off();
025D  206E  	CALL FCM_scan_o_00051


	//Call Macro
	//Call Macro: scan4()
	FCM_scan4();
025E  2090  	CALL FCM_scan4_00000


	//Output
	//Output: 0b11100000 -> PORTB
	trisb = 0x00;
025F  1683  	BSF STATUS, RP0
0260  0186  	CLRF gbl_trisb

	portb = (224);
0261  30E0  	MOVLW 0xE0
0262  1283  	BCF STATUS, RP0
0263  0086  	MOVWF gbl_portb


	//Delay
	//Delay: 4 ms
	delay_ms(4);
0264  3004  	MOVLW 0x04
0265  00FD  	MOVWF delay_ms_00000_arg_del
0266  2010  	CALL delay_ms_00000


}
0267  0008  	RETURN



void FCM_repeat()

{

	//Loop
	//Loop: Loop 10 times
	for (FCLV_LOOP4=0; FCLV_LOOP4<10; FCLV_LOOP4++)
02C9  1283  	BCF STATUS, RP0
02CA  1303  	BCF STATUS, RP1
02CB  01ED  	CLRF gbl_FCLV_LOOP4
02CC        label37
02CC  300A  	MOVLW 0x0A
02CD  026D  	SUBWF gbl_FCLV_LOOP4, W
02CE  1803  	BTFSC STATUS,C
02CF  2AD6  	GOTO	label38
02D4  0AED  	INCF gbl_FCLV_LOOP4, F
02D5  2ACC  	GOTO	label37
02D6        label38

	{

		//Call Macro
		//Call Macro: display_repeat()
		FCM_display_repeat();
02D0  223A  	CALL FCM_displa_00063


		//Call Macro
		//Call Macro: lights_off()
		FCM_lights_off();
02D1  2237  	CALL FCM_lights_0005F


		//Call Component Macro
		//Call Component Macro: SetDutyCycle(0)
		FCD_PWM0_SetDutyCycle(0);
02D2  01FD  	CLRF FCD_PWM0_S_00061_arg_nDuty
02D3  2268  	CALL FCD_PWM0_S_00061



	}

	//Loop
	//Loop: Loop 10 times
	for (FCLV_LOOP5=0; FCLV_LOOP5<10; FCLV_LOOP5++)
02D6  01EE  	CLRF gbl_FCLV_LOOP5
02D7        label39
02D7  300A  	MOVLW 0x0A
02D8  026E  	SUBWF gbl_FCLV_LOOP5, W
02D9  1803  	BTFSC STATUS,C
02DA  2AE2  	GOTO	label40
02E0  0AEE  	INCF gbl_FCLV_LOOP5, F
02E1  2AD7  	GOTO	label39
02E2        label40

	{

		//Call Macro
		//Call Macro: display_repeat()
		FCM_display_repeat();
02DB  223A  	CALL FCM_displa_00063


		//Call Macro
		//Call Macro: lights_off()
		FCM_lights_off();
02DC  2237  	CALL FCM_lights_0005F


		//Call Component Macro
		//Call Component Macro: SetDutyCycle(160)
		FCD_PWM0_SetDutyCycle(160);
02DD  30A0  	MOVLW 0xA0
02DE  00FD  	MOVWF FCD_PWM0_S_00061_arg_nDuty
02DF  2268  	CALL FCD_PWM0_S_00061



	}

	//Loop
	//Loop: Loop 10 times
	for (FCLV_LOOP6=0; FCLV_LOOP6<10; FCLV_LOOP6++)
02E2  01EF  	CLRF gbl_FCLV_LOOP6
02E3        label41
02E3  300A  	MOVLW 0x0A
02E4  026F  	SUBWF gbl_FCLV_LOOP6, W
02E5  1803  	BTFSC STATUS,C
02E6  2AED  	GOTO	label42
02EB  0AEF  	INCF gbl_FCLV_LOOP6, F
02EC  2AE3  	GOTO	label41
02ED        label42

	{

		//Call Macro
		//Call Macro: display_repeat()
		FCM_display_repeat();
02E7  223A  	CALL FCM_displa_00063


		//Call Macro
		//Call Macro: lights_off()
		FCM_lights_off();
02E8  2237  	CALL FCM_lights_0005F


		//Call Component Macro
		//Call Component Macro: SetDutyCycle(0)
		FCD_PWM0_SetDutyCycle(0);
02E9  01FD  	CLRF FCD_PWM0_S_00061_arg_nDuty
02EA  2268  	CALL FCD_PWM0_S_00061



	}

	//Loop
	//Loop: Loop 10 times
	for (FCLV_LOOP7=0; FCLV_LOOP7<10; FCLV_LOOP7++)
02ED  01F0  	CLRF gbl_FCLV_LOOP7
02EE        label43
02EE  300A  	MOVLW 0x0A
02EF  0270  	SUBWF gbl_FCLV_LOOP7, W
02F0  1803  	BTFSC STATUS,C
02F1  2AF9  	GOTO	label44
02F7  0AF0  	INCF gbl_FCLV_LOOP7, F
02F8  2AEE  	GOTO	label43
02F9        label44

	{

		//Call Macro
		//Call Macro: display_repeat()
		FCM_display_repeat();
02F2  223A  	CALL FCM_displa_00063


		//Call Macro
		//Call Macro: lights_off()
		FCM_lights_off();
02F3  2237  	CALL FCM_lights_0005F


		//Call Component Macro
		//Call Component Macro: SetDutyCycle(160)
		FCD_PWM0_SetDutyCycle(160);
02F4  30A0  	MOVLW 0xA0
02F5  00FD  	MOVWF FCD_PWM0_S_00061_arg_nDuty
02F6  2268  	CALL FCD_PWM0_S_00061



	}

	//Loop
	//Loop: Loop 10 times
	for (FCLV_LOOP8=0; FCLV_LOOP8<10; FCLV_LOOP8++)
02F9  01F1  	CLRF gbl_FCLV_LOOP8
02FA        label45
02FA  300A  	MOVLW 0x0A
02FB  0271  	SUBWF gbl_FCLV_LOOP8, W
02FC  1803  	BTFSC STATUS,C
02FD  2B04  	GOTO	label46
0302  0AF1  	INCF gbl_FCLV_LOOP8, F
0303  2AFA  	GOTO	label45
0304        label46

	{

		//Call Macro
		//Call Macro: display_repeat()
		FCM_display_repeat();
02FE  223A  	CALL FCM_displa_00063


		//Call Macro
		//Call Macro: lights_off()
		FCM_lights_off();
02FF  2237  	CALL FCM_lights_0005F


		//Call Component Macro
		//Call Component Macro: SetDutyCycle(0)
		FCD_PWM0_SetDutyCycle(0);
0300  01FD  	CLRF FCD_PWM0_S_00061_arg_nDuty
0301  2268  	CALL FCD_PWM0_S_00061



	}

	//Loop
	//Loop: Loop 10 times
	for (FCLV_LOOP9=0; FCLV_LOOP9<10; FCLV_LOOP9++)
0304  01F2  	CLRF gbl_FCLV_LOOP9
0305        label47
0305  300A  	MOVLW 0x0A
0306  0272  	SUBWF gbl_FCLV_LOOP9, W
0307  1803  	BTFSC STATUS,C
0308  2B10  	GOTO	label48
030E  0AF2  	INCF gbl_FCLV_LOOP9, F
030F  2B05  	GOTO	label47
0310        label48

	{

		//Call Macro
		//Call Macro: display_repeat()
		FCM_display_repeat();
0309  223A  	CALL FCM_displa_00063


		//Call Macro
		//Call Macro: lights_off()
		FCM_lights_off();
030A  2237  	CALL FCM_lights_0005F


		//Call Component Macro
		//Call Component Macro: SetDutyCycle(160)
		FCD_PWM0_SetDutyCycle(160);
030B  30A0  	MOVLW 0xA0
030C  00FD  	MOVWF FCD_PWM0_S_00061_arg_nDuty
030D  2268  	CALL FCD_PWM0_S_00061



	}

	//Loop
	//Loop: Loop 10 times
	for (FCLV_LOOP10=0; FCLV_LOOP10<10; FCLV_LOOP10++)
0310  01F3  	CLRF gbl_FCLV_LOOP10
0311        label49
0311  300A  	MOVLW 0x0A
0312  0273  	SUBWF gbl_FCLV_LOOP10, W
0313  1803  	BTFSC STATUS,C
0319  0AF3  	INCF gbl_FCLV_LOOP10, F
031A  2B11  	GOTO	label49

	{

		//Call Macro
		//Call Macro: display_repeat()
		FCM_display_repeat();
0315  223A  	CALL FCM_displa_00063


		//Call Macro
		//Call Macro: lights_off()
		FCM_lights_off();
0316  2237  	CALL FCM_lights_0005F


		//Call Component Macro
		//Call Component Macro: SetDutyCycle(0)
		FCD_PWM0_SetDutyCycle(0);
0317  01FD  	CLRF FCD_PWM0_S_00061_arg_nDuty
0318  2268  	CALL FCD_PWM0_S_00061



	}

}
0314  0008  	RETURN



void FCM_display_fail()

{

	//Loop
	//Loop: Loop 90 times
	for (FCLV_LOOP11=0; FCLV_LOOP11<90; FCLV_LOOP11++)
05EE  1283  	BCF STATUS, RP0
05EF  1303  	BCF STATUS, RP1
05F0  01F4  	CLRF gbl_FCLV_LOOP11
05F1        label75
05F1  305A  	MOVLW 0x5A
05F2  0274  	SUBWF gbl_FCLV_LOOP11, W
05F3  1803  	BTFSC STATUS,C
05FA  0AF4  	INCF gbl_FCLV_LOOP11, F
05FB  2DF1  	GOTO	label75

	{

		//Call Macro
		//Call Macro: display_temp()
		FCM_display_temp();
05F5  23EC  	CALL FCM_displa_00053


		//Call Macro
		//Call Macro: failed()
		FCM_failed();
05F6  2348  	CALL FCM_failed_00000


		//Call Component Macro
		//Call Component Macro: SetDutyCycle(160)
		FCD_PWM0_SetDutyCycle(160);
05F7  30A0  	MOVLW 0xA0
05F8  00FD  	MOVWF FCD_PWM0_S_00061_arg_nDuty
05F9  2268  	CALL FCD_PWM0_S_00061



	}

}
05F4  0008  	RETURN



void FCM_calibrate()

{

	//Call Macro
	//Call Macro: lights_off()
	FCM_lights_off();
05FC  2237  	CALL FCM_lights_0005F


	//Loop
	//Loop: While swg = 0 OR swr = 0
	while (FCV_SWG == 0 | FCV_SWR == 0)
05FD        label76
05FD  01F8  	CLRF CompTempVar2247
05FE  1DDC  	BTFSS gbl_FCV_SWG,3
05FF  0AF8  	INCF CompTempVar2247, F
0600  01F7  	CLRF CompTempVar2246
0601  0AF7  	INCF CompTempVar2246, F
0602  08E2  	MOVF gbl_FCV_SWR, F
0603  1D03  	BTFSS STATUS,Z
0604  1077  	BCF CompTempVar2246,0
0605  0877  	MOVF CompTempVar2246, W
0606  0478  	IORWF CompTempVar2247, W
0607  1903  	BTFSC STATUS,Z
0608  2E0C  	GOTO	label77
060B  2DFD  	GOTO	label76
060C        label77
064B  2E47  	GOTO	label80

	{

		//Call Macro
		//Call Macro: all_input()
		FCM_all_input();
0609  2591  	CALL FCM_all_in_00054


		//Call Macro
		//Call Macro: display_temp_calib()
		FCM_display_temp_calib();
060A  234B  	CALL FCM_displa_00066



	}

	//Calculation
	//Calculation:
	//  calib_count = 0
	FCV_CALIB_COUNT = 0;
060C  01E5  	CLRF gbl_FCV_CALIB_COUNT


	//Loop
	//Loop: While 1
	while (1)
060D        label78
06B0  2E0D  	GOTO	label78

	{

		//Connection Point
		//Connection Point: [A]: A
FCC_calibrate_A:
;

		//Calculation
		//Calculation:
		//  reset_counter = 0
		FCV_RESET_COUNTER = 0;
060D  01DA  	CLRF gbl_FCV_RESET_COUNTER


		//Call Macro
		//Call Macro: all_input()
		FCM_all_input();
060E  2591  	CALL FCM_all_in_00054


		//Decision
		//Decision: swg = 0 AND swr = 1?
		if (FCV_SWG == 0 & FCV_SWR == 1)
060F  01FA  	CLRF CompTempVar2249
0610  1DDC  	BTFSS gbl_FCV_SWG,3
0611  0AFA  	INCF CompTempVar2249, F
0612  01F9  	CLRF CompTempVar2248
0613  0362  	DECF gbl_FCV_SWR, W
0614  1903  	BTFSC STATUS,Z
0615  0AF9  	INCF CompTempVar2248, F
0616  0879  	MOVF CompTempVar2248, W
0617  057A  	ANDWF CompTempVar2249, W
0618  1903  	BTFSC STATUS,Z
0619  2E4C  	GOTO	label81
064C        label81

		{

			//Calculation
			//Calculation:
			//  calib_count = 0
			FCV_CALIB_COUNT = 0;
061A  01E5  	CLRF gbl_FCV_CALIB_COUNT


			//Calculation
			//Calculation:
			//  temp_cdp = temp_cdp + 1
			//  calib_offset = calib_offset + 1
			FCV_TEMP_CDP = FCV_TEMP_CDP + 1;
061B  08C1  	MOVF gbl_FCV_TEMP_CDP, F
061C  08C2  	MOVF gbl_FCV_TEMP_CDP+D'1', F
061D  0AC1  	INCF gbl_FCV_TEMP_CDP, F
061E  1903  	BTFSC STATUS,Z
061F  0AC2  	INCF gbl_FCV_TEMP_CDP+D'1', F

			FCV_CALIB_OFFSET = FCV_CALIB_OFFSET + 1;
0620  08C7  	MOVF gbl_FCV_CALIB_OFFSET, F
0621  08C8  	MOVF gbl_FCV_CALIB_OFFSET+D'1', F
0622  0AC7  	INCF gbl_FCV_CALIB_OFFSET, F
0623  1903  	BTFSC STATUS,Z
0624  0AC8  	INCF gbl_FCV_CALIB_OFFSET+D'1', F


			//Decision
			//Decision: calib_offset > 9?
			if (FCV_CALIB_OFFSET > 9)
0625  0847  	MOVF gbl_FCV_CALIB_OFFSET, W
0626  3C09  	SUBLW 0x09
0627  0848  	MOVF gbl_FCV_CALIB_OFFSET+D'1', W
0628  1803  	BTFSC STATUS,C
0629  1D03  	BTFSS STATUS,Z
062A  1BC8  	BTFSC gbl_FCV_CALIB_OFFSET+D'1',7
062B  2E2E  	GOTO	label79
062E        label79

			{

				//Calculation
				//Calculation:
				//  calib_offset = 0
				FCV_CALIB_OFFSET = 0;
062C  01C7  	CLRF gbl_FCV_CALIB_OFFSET
062D  01C8  	CLRF gbl_FCV_CALIB_OFFSET+D'1'


			// } else {

			}

			//Decision
			//Decision: temp_cdp > 9?
			if (FCV_TEMP_CDP > 9)
062E  0841  	MOVF gbl_FCV_TEMP_CDP, W
062F  3C09  	SUBLW 0x09
0630  0842  	MOVF gbl_FCV_TEMP_CDP+D'1', W
0631  1803  	BTFSC STATUS,C
0632  1D03  	BTFSS STATUS,Z
0633  1BC2  	BTFSC gbl_FCV_TEMP_CDP+D'1',7
0634  2E47  	GOTO	label80
0647        label80

			{

				//Calculation
				//Calculation:
				//  calib_subtractor = calib_subtractor - 1
				//  temp_c = temp_c + 1
				//  temp_cdp = 0
				FCV_CALIB_SUBTRACTOR = FCV_CALIB_SUBTRACTOR - 1;
0635  3001  	MOVLW 0x01
0636  02C3  	SUBWF gbl_FCV_CALIB_SUBTRACTOR, F
0637  08C4  	MOVF gbl_FCV_CALIB_SUBTRACTOR+D'1', F
0638  1C03  	BTFSS STATUS,C
0639  03C4  	DECF gbl_FCV_CALIB_SUBTRACTOR+D'1', F

				FCV_TEMP_C = FCV_TEMP_C + 1;
063A  08B8  	MOVF gbl_FCV_TEMP_C, F
063B  08B9  	MOVF gbl_FCV_TEMP_C+D'1', F
063C  08BA  	MOVF gbl_FCV_TEMP_C+D'2', F
063D  08BB  	MOVF gbl_FCV_TEMP_C+D'3', F
063E  0AB8  	INCF gbl_FCV_TEMP_C, F
063F  1903  	BTFSC STATUS,Z
0640  0AB9  	INCF gbl_FCV_TEMP_C+D'1', F
0641  1903  	BTFSC STATUS,Z
0642  0ABA  	INCF gbl_FCV_TEMP_C+D'2', F
0643  1903  	BTFSC STATUS,Z
0644  0ABB  	INCF gbl_FCV_TEMP_C+D'3', F

				FCV_TEMP_CDP = 0;
0645  01C1  	CLRF gbl_FCV_TEMP_CDP
0646  01C2  	CLRF gbl_FCV_TEMP_CDP+D'1'


			// } else {

			}

			//Loop
			//Loop: While swg = 0
			while (FCV_SWG == 0)
0647  19DC  	BTFSC gbl_FCV_SWG,3
0648  2EAA  	GOTO	label85

			{

				//Call Macro
				//Call Macro: all_input()
				FCM_all_input();
0649  2591  	CALL FCM_all_in_00054


				//Call Macro
				//Call Macro: display_temp_calib()
				FCM_display_temp_calib();
064A  234B  	CALL FCM_displa_00066



			}

		} else {

			//Decision
			//Decision: swg = 1 AND swr = 0?
			if (FCV_SWG == 1 & FCV_SWR == 0)
064C  01FC  	CLRF CompTempVar2261
064D  19DC  	BTFSC gbl_FCV_SWG,3
064E  0AFC  	INCF CompTempVar2261, F
064F  01FB  	CLRF CompTempVar2260
0650  0AFB  	INCF CompTempVar2260, F
0651  08E2  	MOVF gbl_FCV_SWR, F
0652  1D03  	BTFSS STATUS,Z
0653  107B  	BCF CompTempVar2260,0
0654  087B  	MOVF CompTempVar2260, W
0655  057C  	ANDWF CompTempVar2261, W
0656  1903  	BTFSC STATUS,Z
0657  2EAA  	GOTO	label85

			{

				//Calculation
				//Calculation:
				//  calib_count = 0
				FCV_CALIB_COUNT = 0;
0658  01E5  	CLRF gbl_FCV_CALIB_COUNT


				//Calculation
				//Calculation:
				//  temp_cdp = temp_cdp - 1
				//  calib_offset = calib_offset - 1
				FCV_TEMP_CDP = FCV_TEMP_CDP - 1;
0659  3001  	MOVLW 0x01
065A  02C1  	SUBWF gbl_FCV_TEMP_CDP, F
065B  08C2  	MOVF gbl_FCV_TEMP_CDP+D'1', F
065C  1C03  	BTFSS STATUS,C
065D  03C2  	DECF gbl_FCV_TEMP_CDP+D'1', F

				FCV_CALIB_OFFSET = FCV_CALIB_OFFSET - 1;
065E  3001  	MOVLW 0x01
065F  02C7  	SUBWF gbl_FCV_CALIB_OFFSET, F
0660  08C8  	MOVF gbl_FCV_CALIB_OFFSET+D'1', F
0661  1C03  	BTFSS STATUS,C
0662  03C8  	DECF gbl_FCV_CALIB_OFFSET+D'1', F


				//Decision
				//Decision: calib_offset < 0?
				if (FCV_CALIB_OFFSET < 0)
0663  1FC8  	BTFSS gbl_FCV_CALIB_OFFSET+D'1',7
0664  2E68  	GOTO	label82
0668        label82

				{

					//Calculation
					//Calculation:
					//  calib_offset = 9
					FCV_CALIB_OFFSET = 9;
0665  3009  	MOVLW 0x09
0666  00C7  	MOVWF gbl_FCV_CALIB_OFFSET
0667  01C8  	CLRF gbl_FCV_CALIB_OFFSET+D'1'


				// } else {

				}

				//Decision
				//Decision: temp_cdp < 0?
				if (FCV_TEMP_CDP < 0)
0668  1FC2  	BTFSS gbl_FCV_TEMP_CDP+D'1',7
0669  2E86  	GOTO	label83
0686        label83

				{

					//Calculation
					//Calculation:
					//  calib_subtractor = calib_subtractor + 1
					//  temp_c = temp_c - 1
					//  temp_cdp = 9
					FCV_CALIB_SUBTRACTOR = FCV_CALIB_SUBTRACTOR + 1;
066A  08C3  	MOVF gbl_FCV_CALIB_SUBTRACTOR, F
066B  08C4  	MOVF gbl_FCV_CALIB_SUBTRACTOR+D'1', F
066C  0AC3  	INCF gbl_FCV_CALIB_SUBTRACTOR, F
066D  1903  	BTFSC STATUS,Z
066E  0AC4  	INCF gbl_FCV_CALIB_SUBTRACTOR+D'1', F

					FCV_TEMP_C = FCV_TEMP_C - 1;
066F  3001  	MOVLW 0x01
0670  02B8  	SUBWF gbl_FCV_TEMP_C, F
0671  08B9  	MOVF gbl_FCV_TEMP_C+D'1', F
0672  08BA  	MOVF gbl_FCV_TEMP_C+D'2', F
0673  08BB  	MOVF gbl_FCV_TEMP_C+D'3', F
0674  3000  	MOVLW 0x00
0675  00FD  	MOVWF CompTempVar2272
0676  1C03  	BTFSS STATUS,C
0677  0F7D  	INCFSZ CompTempVar2272, W
0678  02B9  	SUBWF gbl_FCV_TEMP_C+D'1', F
0679  3000  	MOVLW 0x00
067A  00FD  	MOVWF CompTempVar2272
067B  1C03  	BTFSS STATUS,C
067C  0F7D  	INCFSZ CompTempVar2272, W
067D  02BA  	SUBWF gbl_FCV_TEMP_C+D'2', F
067E  3000  	MOVLW 0x00
067F  00FD  	MOVWF CompTempVar2272
0680  1C03  	BTFSS STATUS,C
0681  0F7D  	INCFSZ CompTempVar2272, W
0682  02BB  	SUBWF gbl_FCV_TEMP_C+D'3', F

					FCV_TEMP_CDP = 9;
0683  3009  	MOVLW 0x09
0684  00C1  	MOVWF gbl_FCV_TEMP_CDP
0685  01C2  	CLRF gbl_FCV_TEMP_CDP+D'1'


				// } else {

				}

				//Loop
				//Loop: While swr = 0
				while (FCV_SWR == 0)
0686  08E2  	MOVF gbl_FCV_SWR, F
0687  1D03  	BTFSS STATUS,Z
0688  2EAA  	GOTO	label85
06A9  2E86  	GOTO	label83
06AA        label85

				{

					//Call Macro
					//Call Macro: all_input()
					FCM_all_input();
0689  2591  	CALL FCM_all_in_00054


					//Call Macro
					//Call Macro: display_temp_calib()
					FCM_display_temp_calib();
068A  234B  	CALL FCM_displa_00066


					//Decision
					//Decision: reset_counter = 255?
					if (FCV_RESET_COUNTER == 255)
068B  0A5A  	INCF gbl_FCV_RESET_COUNTER, W
068C  1D03  	BTFSS STATUS,Z
068D  2EA7  	GOTO	label84
06A7        label84

					{

						//Call Macro
						//Call Macro: repeat()
						FCM_repeat();
068E  22C9  	CALL FCM_repeat_00000


						//Call Component Macro
						//Call Component Macro: Write(1, 21)
						FCD_EEPROM0_WriteEEPROM(1, 21);
068F  3001  	MOVLW 0x01
0690  00FD  	MOVWF FCD_EEPROM_00067_arg_addr
0691  01FE  	CLRF FCD_EEPROM_00067_arg_addr+D'1'
0692  3015  	MOVLW 0x15
0693  1683  	BSF STATUS, RP0
0694  00A0  	MOVWF FCD_EEPROM_00067_arg_data
0695  01A1  	CLRF FCD_EEPROM_00067_arg_data+D'1'
0696  25C7  	CALL FCD_EEPROM_00067


						//Call Component Macro
						//Call Component Macro: Write(2, 3)
						FCD_EEPROM0_WriteEEPROM(2, 3);
0697  3002  	MOVLW 0x02
0698  1283  	BCF STATUS, RP0
0699  1303  	BCF STATUS, RP1
069A  00FD  	MOVWF FCD_EEPROM_00067_arg_addr
069B  01FE  	CLRF FCD_EEPROM_00067_arg_addr+D'1'
069C  3003  	MOVLW 0x03
069D  1683  	BSF STATUS, RP0
069E  00A0  	MOVWF FCD_EEPROM_00067_arg_data
069F  01A1  	CLRF FCD_EEPROM_00067_arg_data+D'1'
06A0  25C7  	CALL FCD_EEPROM_00067


						//Delay
						//Delay: 100 ms
						delay_ms(100);
06A1  3064  	MOVLW 0x64
06A2  1283  	BCF STATUS, RP0
06A3  1303  	BCF STATUS, RP1
06A4  00FD  	MOVWF delay_ms_00000_arg_del
06A5  2010  	CALL delay_ms_00000


						//Goto Connection Point
						//Goto Connection Point: [C]: C
						goto FCC_calibrate_C;


					} else {

						//Calculation
						//Calculation:
						//  reset_counter = reset_counter + 1
						FCV_RESET_COUNTER = FCV_RESET_COUNTER + 1;
06A7  0A5A  	INCF gbl_FCV_RESET_COUNTER, W
06A8  00DA  	MOVWF gbl_FCV_RESET_COUNTER


					}


				}

			// } else {

			}

		}

		//Call Macro
		//Call Macro: display_temp_calib()
		FCM_display_temp_calib();
06AA  234B  	CALL FCM_displa_00066


		//Calculation
		//Calculation:
		//  calib_count = calib_count + 1
		FCV_CALIB_COUNT = FCV_CALIB_COUNT + 1;
06AB  0A65  	INCF gbl_FCV_CALIB_COUNT, W
06AC  00E5  	MOVWF gbl_FCV_CALIB_COUNT


		//Decision
		//Decision: calib_count = 150?
		if (FCV_CALIB_COUNT == 150)
06AD  0865  	MOVF gbl_FCV_CALIB_COUNT, W
06AE  3A96  	XORLW 0x96
06AF  1D03  	BTFSS STATUS,Z

		{

			//Goto Connection Point
			//Goto Connection Point: [B]: B
			goto FCC_calibrate_B;


		// } else {

		}


	}

	//Connection Point
	//Connection Point: [B]: B
FCC_calibrate_B:
;

	//Calculation
	//Calculation:
	//  save_calib0 = calib_subtractor - 250
	//  save_calib1 = calib_offset
	FCV_SAVE_CALIB0 = FCV_CALIB_SUBTRACTOR - 250;
06B1  30FA  	MOVLW 0xFA
06B2  0243  	SUBWF gbl_FCV_CALIB_SUBTRACTOR, W
06B3  00C5  	MOVWF gbl_FCV_SAVE_CALIB0
06B4  0844  	MOVF gbl_FCV_CALIB_SUBTRACTOR+D'1', W
06B5  00C6  	MOVWF gbl_FCV_SAVE_CALIB0+D'1'
06B6  1C03  	BTFSS STATUS,C
06B7  03C6  	DECF gbl_FCV_SAVE_CALIB0+D'1', F

	FCV_SAVE_CALIB1 = FCV_CALIB_OFFSET;
06B8  0847  	MOVF gbl_FCV_CALIB_OFFSET, W
06B9  00E8  	MOVWF gbl_FCV_SAVE_CALIB1


	//Call Component Macro
	//Call Component Macro: Write(1, save_calib0)
	FCD_EEPROM0_WriteEEPROM(1, FCV_SAVE_CALIB0);
06BA  3001  	MOVLW 0x01
06BB  00FD  	MOVWF FCD_EEPROM_00067_arg_addr
06BC  01FE  	CLRF FCD_EEPROM_00067_arg_addr+D'1'
06BD  0845  	MOVF gbl_FCV_SAVE_CALIB0, W
06BE  1683  	BSF STATUS, RP0
06BF  00A0  	MOVWF FCD_EEPROM_00067_arg_data
06C0  1283  	BCF STATUS, RP0
06C1  0846  	MOVF gbl_FCV_SAVE_CALIB0+D'1', W
06C2  1683  	BSF STATUS, RP0
06C3  00A1  	MOVWF FCD_EEPROM_00067_arg_data+D'1'
06C4  25C7  	CALL FCD_EEPROM_00067


	//Call Component Macro
	//Call Component Macro: Write(2, save_calib1)
	FCD_EEPROM0_WriteEEPROM(2, FCV_SAVE_CALIB1);
06C5  3002  	MOVLW 0x02
06C6  1283  	BCF STATUS, RP0
06C7  1303  	BCF STATUS, RP1
06C8  00FD  	MOVWF FCD_EEPROM_00067_arg_addr
06C9  01FE  	CLRF FCD_EEPROM_00067_arg_addr+D'1'
06CA  0868  	MOVF gbl_FCV_SAVE_CALIB1, W
06CB  1683  	BSF STATUS, RP0
06CC  00A0  	MOVWF FCD_EEPROM_00067_arg_data
06CD  01A1  	CLRF FCD_EEPROM_00067_arg_data+D'1'
06CE  25C7  	CALL FCD_EEPROM_00067


	//Delay
	//Delay: 100 ms
	delay_ms(100);
06CF  3064  	MOVLW 0x64
06D0  1283  	BCF STATUS, RP0
06D1  1303  	BCF STATUS, RP1
06D2  00FD  	MOVWF delay_ms_00000_arg_del
06D3  2010  	CALL delay_ms_00000


	//Connection Point
	//Connection Point: [C]: C
FCC_calibrate_C:
;

}
06A6  0008  	RETURN
06D4  0008  	RETURN



void FCM_display_temp_calib()

{

	//Calculation
	//Calculation:
	//  temp_tens = temp_c / 10
	//  temp_ones = temp_c MOD 10
	//  temp_dec = temp_cdp
	FCV_TEMP_TENS = FCV_TEMP_C / 10;
034B  1683  	BSF STATUS, RP0
034C  1303  	BCF STATUS, RP1
034D  01A8  	CLRF CompTempVar2276
034E  1283  	BCF STATUS, RP0
034F  0838  	MOVF gbl_FCV_TEMP_C, W
0350  1683  	BSF STATUS, RP0
0351  00A0  	MOVWF __div_32_3_00001_arg_a
0352  1283  	BCF STATUS, RP0
0353  0839  	MOVF gbl_FCV_TEMP_C+D'1', W
0354  1683  	BSF STATUS, RP0
0355  00A1  	MOVWF __div_32_3_00001_arg_a+D'1'
0356  1283  	BCF STATUS, RP0
0357  083A  	MOVF gbl_FCV_TEMP_C+D'2', W
0358  1683  	BSF STATUS, RP0
0359  00A2  	MOVWF __div_32_3_00001_arg_a+D'2'
035A  1283  	BCF STATUS, RP0
035B  083B  	MOVF gbl_FCV_TEMP_C+D'3', W
035C  1683  	BSF STATUS, RP0
035D  00A3  	MOVWF __div_32_3_00001_arg_a+D'3'
035E  1283  	BCF STATUS, RP0
035F  1FBB  	BTFSS gbl_FCV_TEMP_C+D'3',7
0360  2B6E  	GOTO	label50
0361  1683  	BSF STATUS, RP0
0362  09A0  	COMF __div_32_3_00001_arg_a, F
0363  09A1  	COMF __div_32_3_00001_arg_a+D'1', F
0364  09A2  	COMF __div_32_3_00001_arg_a+D'2', F
0365  09A3  	COMF __div_32_3_00001_arg_a+D'3', F
0366  0AA0  	INCF __div_32_3_00001_arg_a, F
0367  1903  	BTFSC STATUS,Z
0368  0AA1  	INCF __div_32_3_00001_arg_a+D'1', F
0369  1903  	BTFSC STATUS,Z
036A  0AA2  	INCF __div_32_3_00001_arg_a+D'2', F
036B  1903  	BTFSC STATUS,Z
036C  0AA3  	INCF __div_32_3_00001_arg_a+D'3', F
036D  0AA8  	INCF CompTempVar2276, F
036E        label50
036E  300A  	MOVLW 0x0A
036F  1683  	BSF STATUS, RP0
0370  00A4  	MOVWF __div_32_3_00001_arg_b
0371  01A5  	CLRF __div_32_3_00001_arg_b+D'1'
0372  01A6  	CLRF __div_32_3_00001_arg_b+D'2'
0373  01A7  	CLRF __div_32_3_00001_arg_b+D'3'
0374  217A  	CALL __div_32_3_00001
0375  0831  	MOVF CompTempVarRet210, W
0376  1283  	BCF STATUS, RP0
0377  00D3  	MOVWF gbl_FCV_TEMP_TENS
0378  1683  	BSF STATUS, RP0
0379  1C28  	BTFSS CompTempVar2276,0
037A  2B7E  	GOTO	label51
037B  1283  	BCF STATUS, RP0
037C  09D3  	COMF gbl_FCV_TEMP_TENS, F
037D  0AD3  	INCF gbl_FCV_TEMP_TENS, F
037E        label51

	FCV_TEMP_ONES = FCV_TEMP_C % 10;
037E  1283  	BCF STATUS, RP0
037F  0838  	MOVF gbl_FCV_TEMP_C, W
0380  1683  	BSF STATUS, RP0
0381  00A0  	MOVWF __rem_32_3_00002_arg_a
0382  1283  	BCF STATUS, RP0
0383  0839  	MOVF gbl_FCV_TEMP_C+D'1', W
0384  1683  	BSF STATUS, RP0
0385  00A1  	MOVWF __rem_32_3_00002_arg_a+D'1'
0386  1283  	BCF STATUS, RP0
0387  083A  	MOVF gbl_FCV_TEMP_C+D'2', W
0388  1683  	BSF STATUS, RP0
0389  00A2  	MOVWF __rem_32_3_00002_arg_a+D'2'
038A  1283  	BCF STATUS, RP0
038B  083B  	MOVF gbl_FCV_TEMP_C+D'3', W
038C  1683  	BSF STATUS, RP0
038D  00A3  	MOVWF __rem_32_3_00002_arg_a+D'3'
038E  1283  	BCF STATUS, RP0
038F  1FBB  	BTFSS gbl_FCV_TEMP_C+D'3',7
0390  2B9D  	GOTO	label52
0391  1683  	BSF STATUS, RP0
0392  09A0  	COMF __rem_32_3_00002_arg_a, F
0393  09A1  	COMF __rem_32_3_00002_arg_a+D'1', F
0394  09A2  	COMF __rem_32_3_00002_arg_a+D'2', F
0395  09A3  	COMF __rem_32_3_00002_arg_a+D'3', F
0396  0AA0  	INCF __rem_32_3_00002_arg_a, F
0397  1903  	BTFSC STATUS,Z
0398  0AA1  	INCF __rem_32_3_00002_arg_a+D'1', F
0399  1903  	BTFSC STATUS,Z
039A  0AA2  	INCF __rem_32_3_00002_arg_a+D'2', F
039B  1903  	BTFSC STATUS,Z
039C  0AA3  	INCF __rem_32_3_00002_arg_a+D'3', F
039D        label52
039D  300A  	MOVLW 0x0A
039E  1683  	BSF STATUS, RP0
039F  00A4  	MOVWF __rem_32_3_00002_arg_b
03A0  01A5  	CLRF __rem_32_3_00002_arg_b+D'1'
03A1  01A6  	CLRF __rem_32_3_00002_arg_b+D'2'
03A2  01A7  	CLRF __rem_32_3_00002_arg_b+D'3'
03A3  2130  	CALL __rem_32_3_00002
03A4  082D  	MOVF CompTempVarRet212, W
03A5  1283  	BCF STATUS, RP0
03A6  00DB  	MOVWF gbl_FCV_TEMP_ONES
03A7  1FBB  	BTFSS gbl_FCV_TEMP_C+D'3',7
03A8  2BAB  	GOTO	label53
03A9  09DB  	COMF gbl_FCV_TEMP_ONES, F
03AA  0ADB  	INCF gbl_FCV_TEMP_ONES, F
03AB        label53

	FCV_TEMP_DEC = FCV_TEMP_CDP;
03AB  0841  	MOVF gbl_FCV_TEMP_CDP, W
03AC  00D9  	MOVWF gbl_FCV_TEMP_DEC


	//Output
	//Output: 0b00000001 -> PORTB
	trisb = 0x00;
03AD  1683  	BSF STATUS, RP0
03AE  0186  	CLRF gbl_trisb

	portb = (1);
03AF  3001  	MOVLW 0x01
03B0  1283  	BCF STATUS, RP0
03B1  0086  	MOVWF gbl_portb


	//Call Macro
	//Call Macro: scan_off()
	FCM_scan_off();
03B2  206E  	CALL FCM_scan_o_00051


	//Call Macro
	//Call Macro: scan1()
	FCM_scan1();
03B3  20FF  	CALL FCM_scan1_00000


	//Calculation
	//Calculation:
	//  digit = temp_tens
	FCV_DIGIT = FCV_TEMP_TENS;
03B4  0853  	MOVF gbl_FCV_TEMP_TENS, W
03B5  00E0  	MOVWF gbl_FCV_DIGIT


	//Call Macro
	//Call Macro: seg_pattern()
	FCM_seg_pattern();
03B6  21D9  	CALL FCM_seg_pa_00052


	//Delay
	//Delay: 4 ms
	delay_ms(4);
03B7  3004  	MOVLW 0x04
03B8  00FD  	MOVWF delay_ms_00000_arg_del
03B9  2010  	CALL delay_ms_00000


	//Output
	//Output: 0b00000001 -> PORTB
	trisb = 0x00;
03BA  1683  	BSF STATUS, RP0
03BB  0186  	CLRF gbl_trisb

	portb = (1);
03BC  3001  	MOVLW 0x01
03BD  1283  	BCF STATUS, RP0
03BE  0086  	MOVWF gbl_portb


	//Call Macro
	//Call Macro: scan_off()
	FCM_scan_off();
03BF  206E  	CALL FCM_scan_o_00051


	//Call Macro
	//Call Macro: scan2()
	FCM_scan2();
03C0  20DA  	CALL FCM_scan2_00000


	//Calculation
	//Calculation:
	//  digit = temp_ones
	FCV_DIGIT = FCV_TEMP_ONES;
03C1  085B  	MOVF gbl_FCV_TEMP_ONES, W
03C2  00E0  	MOVWF gbl_FCV_DIGIT


	//Call Macro
	//Call Macro: seg_pattern()
	FCM_seg_pattern();
03C3  21D9  	CALL FCM_seg_pa_00052


	//Output
	//Output: 0 -> B0
	trisb = trisb & 0xFE;
03C4  30FE  	MOVLW 0xFE
03C5  1683  	BSF STATUS, RP0
03C6  0506  	ANDWF gbl_trisb, W
03C7  0086  	MOVWF gbl_trisb

	if ((0))
		portb = (portb & 0xFE) | 0x01;
	else
		portb = portb & 0xFE;
03C8  30FE  	MOVLW 0xFE
03C9  1283  	BCF STATUS, RP0
03CA  0506  	ANDWF gbl_portb, W
03CB  0086  	MOVWF gbl_portb


	//Delay
	//Delay: 4 ms
	delay_ms(4);
03CC  3004  	MOVLW 0x04
03CD  00FD  	MOVWF delay_ms_00000_arg_del
03CE  2010  	CALL delay_ms_00000


	//Output
	//Output: 0b00000001 -> PORTB
	trisb = 0x00;
03CF  1683  	BSF STATUS, RP0
03D0  0186  	CLRF gbl_trisb

	portb = (1);
03D1  3001  	MOVLW 0x01
03D2  1283  	BCF STATUS, RP0
03D3  0086  	MOVWF gbl_portb


	//Call Macro
	//Call Macro: scan_off()
	FCM_scan_off();
03D4  206E  	CALL FCM_scan_o_00051


	//Call Macro
	//Call Macro: scan3()
	FCM_scan3();
03D5  20B5  	CALL FCM_scan3_00000


	//Calculation
	//Calculation:
	//  digit = temp_dec
	FCV_DIGIT = FCV_TEMP_DEC;
03D6  0859  	MOVF gbl_FCV_TEMP_DEC, W
03D7  00E0  	MOVWF gbl_FCV_DIGIT


	//Call Macro
	//Call Macro: seg_pattern()
	FCM_seg_pattern();
03D8  21D9  	CALL FCM_seg_pa_00052


	//Delay
	//Delay: 4 ms
	delay_ms(4);
03D9  3004  	MOVLW 0x04
03DA  00FD  	MOVWF delay_ms_00000_arg_del
03DB  2010  	CALL delay_ms_00000


	//Output
	//Output: 0b00000001 -> PORTB
	trisb = 0x00;
03DC  1683  	BSF STATUS, RP0
03DD  0186  	CLRF gbl_trisb

	portb = (1);
03DE  3001  	MOVLW 0x01
03DF  1283  	BCF STATUS, RP0
03E0  0086  	MOVWF gbl_portb


	//Call Macro
	//Call Macro: scan_off()
	FCM_scan_off();
03E1  206E  	CALL FCM_scan_o_00051


	//Call Macro
	//Call Macro: scan4()
	FCM_scan4();
03E2  2090  	CALL FCM_scan4_00000


	//Output
	//Output: 0b11110000 -> PORTB
	trisb = 0x00;
03E3  1683  	BSF STATUS, RP0
03E4  0186  	CLRF gbl_trisb

	portb = (240);
03E5  30F0  	MOVLW 0xF0
03E6  1283  	BCF STATUS, RP0
03E7  0086  	MOVWF gbl_portb


	//Delay
	//Delay: 4 ms
	delay_ms(4);
03E8  3004  	MOVLW 0x04
03E9  00FD  	MOVWF delay_ms_00000_arg_del
03EA  2010  	CALL delay_ms_00000


}
03EB  0008  	RETURN



void FCM_calc_calib()
{

}



void main()

{
	//Initialization
	adcon1 = 0x07;
06F5  3007  	MOVLW 0x07
06F6  1683  	BSF STATUS, RP0
06F7  1303  	BCF STATUS, RP1
06F8  009F  	MOVWF gbl_adcon1



	//Interrupt initialization code
	option_reg = 0xC0;
06F9  30C0  	MOVLW 0xC0
06FA  0081  	MOVWF gbl_option_reg



	//Calculation
	//Calculation:
	//  data0 = 123
	//  data1 = 0xff
	//  data2 = 0xff
	//  lsb = 0x00
	//  msb = 0x00
	FCV_DATA0 = 123;
06FB  307B  	MOVLW 0x7B
06FC  1283  	BCF STATUS, RP0
06FD  00D4  	MOVWF gbl_FCV_DATA0

	FCV_DATA1 = 0xff;
06FE  30FF  	MOVLW 0xFF
06FF  00D5  	MOVWF gbl_FCV_DATA1

	FCV_DATA2 = 0xff;
0700  00D6  	MOVWF gbl_FCV_DATA2

	FCV_LSB = 0x00;
0701  01DF  	CLRF gbl_FCV_LSB

	FCV_MSB = 0x00;
0702  01E1  	CLRF gbl_FCV_MSB


	//Calculation
	//Calculation:
	//  temp_tens = 0
	//  temp_ones = 0
	//  temp_dec = 0
	FCV_TEMP_TENS = 0;
0703  01D3  	CLRF gbl_FCV_TEMP_TENS

	FCV_TEMP_ONES = 0;
0704  01DB  	CLRF gbl_FCV_TEMP_ONES

	FCV_TEMP_DEC = 0;
0705  01D9  	CLRF gbl_FCV_TEMP_DEC


	//Call Component Macro
	//Call Component Macro: MI2C_Init()
	FCD_I2C_Master0_MI2C_Init();
0706  26EA  	CALL FCD_I2C_Ma_0007A


	//Call Component Macro
	//Call Component Macro: Enable()
	FCD_PWM0_Enable();
0707  26E0  	CALL FCD_PWM0_E_0006E


	//Call Component Macro
	//Call Component Macro: LEDOff()
	FCD_LED0_LEDOff();
0708  212A  	CALL FCD_LED0_L_00055


	//Call Component Macro
	//Call Component Macro: LEDOff()
	FCD_LED1_LEDOff();
0709  2124  	CALL FCD_LED1_L_00058


	//Delay
	//Delay: 300 ms
	delay_ms(255);
070A  30FF  	MOVLW 0xFF
070B  00FD  	MOVWF delay_ms_00000_arg_del
070C  2010  	CALL delay_ms_00000

	delay_ms(45);
070D  302D  	MOVLW 0x2D
070E  00FD  	MOVWF delay_ms_00000_arg_del
070F  2010  	CALL delay_ms_00000


	//Loop
	//Loop: While 1
	while (1)
0710        label86
0843  2F10  	GOTO	label86

	{

		//Call Macro
		//Call Macro: lights_off()
		FCM_lights_off();
0710  2237  	CALL FCM_lights_0005F


		//Call Component Macro
		//Call Component Macro: calib_subtractor=Read(1)
		FCV_CALIB_SUBTRACTOR = FCD_EEPROM0_EEPROMRead(1);
0711  3001  	MOVLW 0x01
0712  00F5  	MOVWF FCD_EEPROM_00080_arg_addr
0713  01F6  	CLRF FCD_EEPROM_00080_arg_addr+D'1'
0714  26EC  	CALL FCD_EEPROM_00080
0715  0877  	MOVF CompTempVarRet2293, W
0716  00C3  	MOVWF gbl_FCV_CALIB_SUBTRACTOR
0717  0878  	MOVF CompTempVarRet2293+D'1', W
0718  00C4  	MOVWF gbl_FCV_CALIB_SUBTRACTOR+D'1'


		//Call Component Macro
		//Call Component Macro: calib_offset=Read(2)
		FCV_CALIB_OFFSET = FCD_EEPROM0_EEPROMRead(2);
0719  3002  	MOVLW 0x02
071A  00F5  	MOVWF FCD_EEPROM_00080_arg_addr
071B  01F6  	CLRF FCD_EEPROM_00080_arg_addr+D'1'
071C  26EC  	CALL FCD_EEPROM_00080
071D  0877  	MOVF CompTempVarRet2293, W
071E  00C7  	MOVWF gbl_FCV_CALIB_OFFSET
071F  0878  	MOVF CompTempVarRet2293+D'1', W
0720  00C8  	MOVWF gbl_FCV_CALIB_OFFSET+D'1'


		//Calculation
		//Calculation:
		//  calib_subtractor = calib_subtractor + 250
		FCV_CALIB_SUBTRACTOR = FCV_CALIB_SUBTRACTOR + 250;
0721  30FA  	MOVLW 0xFA
0722  07C3  	ADDWF gbl_FCV_CALIB_SUBTRACTOR, F
0723  08C4  	MOVF gbl_FCV_CALIB_SUBTRACTOR+D'1', F
0724  1803  	BTFSC STATUS,C
0725  0AC4  	INCF gbl_FCV_CALIB_SUBTRACTOR+D'1', F
0726        label87


		//Connection Point
		//Connection Point: [A]: A
FCC_Main_A:
;

		//Calculation
		//Calculation:
		//  prox_counter = 0
		//  sw_calib = 0
		FCV_PROX_COUNTER = 0;
0726  01DD  	CLRF gbl_FCV_PROX_COUNTER

		FCV_SW_CALIB = 0;
0727  01E7  	CLRF gbl_FCV_SW_CALIB


		//Connection Point
		//Connection Point: [B]: B
FCC_Main_B:
0728        label88

;

		//Call Macro
		//Call Macro: all_input()
		FCM_all_input();
0728  2591  	CALL FCM_all_in_00054


		//Decision
		//Decision: prox_bit = 0?
		if (FCV_PROX_BIT == 0)
0729  185C  	BTFSC gbl_FCV_PROX_BIT,0
072A  2FED  	GOTO	label104
07ED        label104

		{

			//Decision
			//Decision: prox_counter = 10?
			if (FCV_PROX_COUNTER == 10)
072B  085D  	MOVF gbl_FCV_PROX_COUNTER, W
072C  3A0A  	XORLW 0x0A
072D  1903  	BTFSC STATUS,Z

			{

			} else {
072E  2F35  	GOTO	label89
0735        label89


				//Delay
				//Delay: 30 ms
				delay_ms(30);
072F  301E  	MOVLW 0x1E
0730  00FD  	MOVWF delay_ms_00000_arg_del
0731  2010  	CALL delay_ms_00000


				//Calculation
				//Calculation:
				//  prox_counter = prox_counter + 1
				FCV_PROX_COUNTER = FCV_PROX_COUNTER + 1;
0732  0A5D  	INCF gbl_FCV_PROX_COUNTER, W
0733  00DD  	MOVWF gbl_FCV_PROX_COUNTER


				//Goto Connection Point
				//Goto Connection Point: [B]: B
				goto FCC_Main_B;
0734  2F28  	GOTO	label88
07EC  2FE9  	GOTO	label103


			}

			//Call Macro
			//Call Macro: beep_once()
			FCM_beep_once();
0735  26D5  	CALL FCM_beep_o_00060


			//Call Macro
			//Call Macro: get_temp()
			FCM_get_temp();
0736  25D6  	CALL FCM_get_te_00062


			//Calculation
			//Calculation:
			//  temp_tens = temp_c / 10
			//  temp_ones = temp_c MOD 10
			//  temp_dec = temp_cdp
			FCV_TEMP_TENS = FCV_TEMP_C / 10;
0737  01FD  	CLRF CompTempVar2298
0738  0838  	MOVF gbl_FCV_TEMP_C, W
0739  1683  	BSF STATUS, RP0
073A  00A0  	MOVWF __div_32_3_00001_arg_a
073B  1283  	BCF STATUS, RP0
073C  0839  	MOVF gbl_FCV_TEMP_C+D'1', W
073D  1683  	BSF STATUS, RP0
073E  00A1  	MOVWF __div_32_3_00001_arg_a+D'1'
073F  1283  	BCF STATUS, RP0
0740  083A  	MOVF gbl_FCV_TEMP_C+D'2', W
0741  1683  	BSF STATUS, RP0
0742  00A2  	MOVWF __div_32_3_00001_arg_a+D'2'
0743  1283  	BCF STATUS, RP0
0744  083B  	MOVF gbl_FCV_TEMP_C+D'3', W
0745  1683  	BSF STATUS, RP0
0746  00A3  	MOVWF __div_32_3_00001_arg_a+D'3'
0747  1283  	BCF STATUS, RP0
0748  1FBB  	BTFSS gbl_FCV_TEMP_C+D'3',7
0749  2F58  	GOTO	label90
074A  1683  	BSF STATUS, RP0
074B  09A0  	COMF __div_32_3_00001_arg_a, F
074C  09A1  	COMF __div_32_3_00001_arg_a+D'1', F
074D  09A2  	COMF __div_32_3_00001_arg_a+D'2', F
074E  09A3  	COMF __div_32_3_00001_arg_a+D'3', F
074F  0AA0  	INCF __div_32_3_00001_arg_a, F
0750  1903  	BTFSC STATUS,Z
0751  0AA1  	INCF __div_32_3_00001_arg_a+D'1', F
0752  1903  	BTFSC STATUS,Z
0753  0AA2  	INCF __div_32_3_00001_arg_a+D'2', F
0754  1903  	BTFSC STATUS,Z
0755  0AA3  	INCF __div_32_3_00001_arg_a+D'3', F
0756  1283  	BCF STATUS, RP0
0757  0AFD  	INCF CompTempVar2298, F
0758        label90
0758  300A  	MOVLW 0x0A
0759  1683  	BSF STATUS, RP0
075A  00A4  	MOVWF __div_32_3_00001_arg_b
075B  01A5  	CLRF __div_32_3_00001_arg_b+D'1'
075C  01A6  	CLRF __div_32_3_00001_arg_b+D'2'
075D  01A7  	CLRF __div_32_3_00001_arg_b+D'3'
075E  217A  	CALL __div_32_3_00001
075F  0831  	MOVF CompTempVarRet210, W
0760  1283  	BCF STATUS, RP0
0761  00D3  	MOVWF gbl_FCV_TEMP_TENS
0762  1C7D  	BTFSS CompTempVar2298,0
0763  2F66  	GOTO	label91
0764  09D3  	COMF gbl_FCV_TEMP_TENS, F
0765  0AD3  	INCF gbl_FCV_TEMP_TENS, F
0766        label91

			FCV_TEMP_ONES = FCV_TEMP_C % 10;
0766  0838  	MOVF gbl_FCV_TEMP_C, W
0767  1683  	BSF STATUS, RP0
0768  00A0  	MOVWF __rem_32_3_00002_arg_a
0769  1283  	BCF STATUS, RP0
076A  0839  	MOVF gbl_FCV_TEMP_C+D'1', W
076B  1683  	BSF STATUS, RP0
076C  00A1  	MOVWF __rem_32_3_00002_arg_a+D'1'
076D  1283  	BCF STATUS, RP0
076E  083A  	MOVF gbl_FCV_TEMP_C+D'2', W
076F  1683  	BSF STATUS, RP0
0770  00A2  	MOVWF __rem_32_3_00002_arg_a+D'2'
0771  1283  	BCF STATUS, RP0
0772  083B  	MOVF gbl_FCV_TEMP_C+D'3', W
0773  1683  	BSF STATUS, RP0
0774  00A3  	MOVWF __rem_32_3_00002_arg_a+D'3'
0775  1283  	BCF STATUS, RP0
0776  1FBB  	BTFSS gbl_FCV_TEMP_C+D'3',7
0777  2F84  	GOTO	label92
0778  1683  	BSF STATUS, RP0
0779  09A0  	COMF __rem_32_3_00002_arg_a, F
077A  09A1  	COMF __rem_32_3_00002_arg_a+D'1', F
077B  09A2  	COMF __rem_32_3_00002_arg_a+D'2', F
077C  09A3  	COMF __rem_32_3_00002_arg_a+D'3', F
077D  0AA0  	INCF __rem_32_3_00002_arg_a, F
077E  1903  	BTFSC STATUS,Z
077F  0AA1  	INCF __rem_32_3_00002_arg_a+D'1', F
0780  1903  	BTFSC STATUS,Z
0781  0AA2  	INCF __rem_32_3_00002_arg_a+D'2', F
0782  1903  	BTFSC STATUS,Z
0783  0AA3  	INCF __rem_32_3_00002_arg_a+D'3', F
0784        label92
0784  300A  	MOVLW 0x0A
0785  1683  	BSF STATUS, RP0
0786  00A4  	MOVWF __rem_32_3_00002_arg_b
0787  01A5  	CLRF __rem_32_3_00002_arg_b+D'1'
0788  01A6  	CLRF __rem_32_3_00002_arg_b+D'2'
0789  01A7  	CLRF __rem_32_3_00002_arg_b+D'3'
078A  2130  	CALL __rem_32_3_00002
078B  082D  	MOVF CompTempVarRet212, W
078C  1283  	BCF STATUS, RP0
078D  00DB  	MOVWF gbl_FCV_TEMP_ONES
078E  1FBB  	BTFSS gbl_FCV_TEMP_C+D'3',7
078F  2F92  	GOTO	label93
0790  09DB  	COMF gbl_FCV_TEMP_ONES, F
0791  0ADB  	INCF gbl_FCV_TEMP_ONES, F
0792        label93

			FCV_TEMP_DEC = FCV_TEMP_CDP;
0792  0841  	MOVF gbl_FCV_TEMP_CDP, W
0793  00D9  	MOVWF gbl_FCV_TEMP_DEC


			//Decision
			//Decision: temp_c < 34?
			if (FCV_TEMP_C < 34)
0794  3000  	MOVLW 0x00
0795  023B  	SUBWF gbl_FCV_TEMP_C+D'3', W
0796  1D03  	BTFSS STATUS,Z
0797  2FA2  	GOTO	label94
0798  3000  	MOVLW 0x00
0799  023A  	SUBWF gbl_FCV_TEMP_C+D'2', W
079A  1D03  	BTFSS STATUS,Z
079B  2FA2  	GOTO	label94
079C  3000  	MOVLW 0x00
079D  0239  	SUBWF gbl_FCV_TEMP_C+D'1', W
079E  1D03  	BTFSS STATUS,Z
079F  2FA2  	GOTO	label94
07A0  3022  	MOVLW 0x22
07A1  0238  	SUBWF gbl_FCV_TEMP_C, W
07A2        label94
07A2  1C03  	BTFSS STATUS,C
07A3  2FA6  	GOTO	label95
07A4  1FBB  	BTFSS gbl_FCV_TEMP_C+D'3',7
07A5  2FA8  	GOTO	label96
07A6        label95
07A8        label96

			{

				//Call Macro
				//Call Macro: repeat()
				FCM_repeat();
07A6  22C9  	CALL FCM_repeat_00000


			} else {
07A7  2FE8  	GOTO	label102


				//Decision
				//Decision: temp_c >= 38?
				if (FCV_TEMP_C >= 38)
07A8  3000  	MOVLW 0x00
07A9  023B  	SUBWF gbl_FCV_TEMP_C+D'3', W
07AA  1D03  	BTFSS STATUS,Z
07AB  2FB6  	GOTO	label97
07AC  3000  	MOVLW 0x00
07AD  023A  	SUBWF gbl_FCV_TEMP_C+D'2', W
07AE  1D03  	BTFSS STATUS,Z
07AF  2FB6  	GOTO	label97
07B0  3000  	MOVLW 0x00
07B1  0239  	SUBWF gbl_FCV_TEMP_C+D'1', W
07B2  1D03  	BTFSS STATUS,Z
07B3  2FB6  	GOTO	label97
07B4  3026  	MOVLW 0x26
07B5  0238  	SUBWF gbl_FCV_TEMP_C, W
07B6        label97
07B6  1103  	BCF STATUS,Z
07B7  1C03  	BTFSS STATUS,C
07B8  2FBD  	GOTO	label99
07B9  1BBB  	BTFSC gbl_FCV_TEMP_C+D'3',7
07BA  2FBD  	GOTO	label99
07BB        label98
07BD        label99

				{

					//Connection Point
					//Connection Point: [C]: C
FCC_Main_C:

;

					//Call Macro
					//Call Macro: display_fail()
					FCM_display_fail();
07BB  25EE  	CALL FCM_displa_00064


				} else {
07BC  2FE8  	GOTO	label102


					//Decision
					//Decision: temp_c = 37 AND temp_cdp >= 8?
					if (FCV_TEMP_C == 37 & FCV_TEMP_CDP >= 8)
07BD  01F6  	CLRF CompTempVar2301
07BE  0AF6  	INCF CompTempVar2301, F
07BF  0838  	MOVF gbl_FCV_TEMP_C, W
07C0  3C25  	SUBLW 0x25
07C1  1D03  	BTFSS STATUS,Z
07C2  01F6  	CLRF CompTempVar2301
07C3  0839  	MOVF gbl_FCV_TEMP_C+D'1', W
07C4  3C00  	SUBLW 0x00
07C5  1D03  	BTFSS STATUS,Z
07C6  01F6  	CLRF CompTempVar2301
07C7  083A  	MOVF gbl_FCV_TEMP_C+D'2', W
07C8  3C00  	SUBLW 0x00
07C9  1D03  	BTFSS STATUS,Z
07CA  01F6  	CLRF CompTempVar2301
07CB  083B  	MOVF gbl_FCV_TEMP_C+D'3', W
07CC  3C00  	SUBLW 0x00
07CD  1D03  	BTFSS STATUS,Z
07CE  01F6  	CLRF CompTempVar2301
07CF  01F5  	CLRF CompTempVar2300
07D0  0842  	MOVF gbl_FCV_TEMP_CDP+D'1', W
07D1  3A80  	XORLW 0x80
07D2  00F7  	MOVWF CompTempVar2302
07D3  3080  	MOVLW 0x80
07D4  0277  	SUBWF CompTempVar2302, W
07D5  1D03  	BTFSS STATUS,Z
07D6  2FD9  	GOTO	label100
07D7  3008  	MOVLW 0x08
07D8  0241  	SUBWF gbl_FCV_TEMP_CDP, W
07D9        label100
07D9  1803  	BTFSC STATUS,C
07DA  0AF5  	INCF CompTempVar2300, F
07DB  0875  	MOVF CompTempVar2300, W
07DC  0576  	ANDWF CompTempVar2301, W
07DD  1D03  	BTFSS STATUS,Z

					{

						//Goto Connection Point
						//Goto Connection Point: [C]: C
						goto FCC_Main_C;
07DE  2FBB  	GOTO	label98


					} else {

						//Loop
						//Loop: Loop 90 times
						for (FCLV_LOOP2=0; FCLV_LOOP2<90; FCLV_LOOP2++)
07DF  01EB  	CLRF gbl_FCLV_LOOP2
07E0        label101
07E0  305A  	MOVLW 0x5A
07E1  026B  	SUBWF gbl_FCLV_LOOP2, W
07E2  1803  	BTFSC STATUS,C
07E3  2FE8  	GOTO	label102
07E6  0AEB  	INCF gbl_FCLV_LOOP2, F
07E7  2FE0  	GOTO	label101
07E8        label102

						{

							//Call Macro
							//Call Macro: display_temp()
							FCM_display_temp();
07E4  23EC  	CALL FCM_displa_00053


							//Call Macro
							//Call Macro: pass()
							FCM_pass();
07E5  25D3  	CALL FCM_pass_00000



						}

					}

				}

			}

			//Call Macro
			//Call Macro: scan_off()
			FCM_scan_off();
07E8  206E  	CALL FCM_scan_o_00051


			//Loop
			//Loop: While prox_bit = 0
			while (FCV_PROX_BIT == 0)
07E9        label103
07E9  185C  	BTFSC gbl_FCV_PROX_BIT,0
07EA  2F10  	GOTO	label86

			{

				//Call Macro
				//Call Macro: all_input()
				FCM_all_input();
07EB  2591  	CALL FCM_all_in_00054



			}

		} else {

			//Delay
			//Delay: 100 ms
			delay_ms(100);
07ED  3064  	MOVLW 0x64
07EE  00FD  	MOVWF delay_ms_00000_arg_del
07EF  2010  	CALL delay_ms_00000


			//Decision
			//Decision: swg = 0 AND swr = 0?
			if (FCV_SWG == 0 & FCV_SWR == 0)
07F0  01F6  	CLRF CompTempVar2304
07F1  1DDC  	BTFSS gbl_FCV_SWG,3
07F2  0AF6  	INCF CompTempVar2304, F
07F3  01F5  	CLRF CompTempVar2303
07F4  0AF5  	INCF CompTempVar2303, F
07F5  08E2  	MOVF gbl_FCV_SWR, F
07F6  1D03  	BTFSS STATUS,Z
07F7  1075  	BCF CompTempVar2303,0
07F8  0875  	MOVF CompTempVar2303, W
07F9  0576  	ANDWF CompTempVar2304, W
07FA  158A  	BSF PCLATH,3
07FB  1903  	BTFSC STATUS,Z
07FC  280B  	GOTO	label106
080B        label106

			{

				//Decision
				//Decision: sw_calib = 10?
				if (FCV_SW_CALIB == 10)
07FD  0867  	MOVF gbl_FCV_SW_CALIB, W
07FE  3A0A  	XORLW 0x0A
07FF  1903  	BTFSC STATUS,Z

				{

				} else {
0800  2808  	GOTO	label105
0808        label105


					//Delay
					//Delay: 30 ms
					delay_ms(30);
0801  301E  	MOVLW 0x1E
0802  00FD  	MOVWF delay_ms_00000_arg_del
0803  118A  	BCF PCLATH,3
0804  2010  	CALL delay_ms_00000


					//Calculation
					//Calculation:
					//  sw_calib = sw_calib + 1
					FCV_SW_CALIB = FCV_SW_CALIB + 1;
0805  0A67  	INCF gbl_FCV_SW_CALIB, W
0806  00E7  	MOVWF gbl_FCV_SW_CALIB


					//Goto Connection Point
					//Goto Connection Point: [B]: B
					goto FCC_Main_B;
0807  2F28  	GOTO	label88


				}

				//Call Macro
				//Call Macro: calibrate()
				FCM_calibrate();
0808  118A  	BCF PCLATH,3
0809  25FC  	CALL FCM_calibr_00065


			} else {
080A  2F10  	GOTO	label86


				//Decision
				//Decision: swg = 1 AND swr = 0?
				if (FCV_SWG == 1 & FCV_SWR == 0)
080B  01F8  	CLRF CompTempVar2306
080C  19DC  	BTFSC gbl_FCV_SWG,3
080D  0AF8  	INCF CompTempVar2306, F
080E  01F7  	CLRF CompTempVar2305
080F  0AF7  	INCF CompTempVar2305, F
0810  08E2  	MOVF gbl_FCV_SWR, F
0811  1D03  	BTFSS STATUS,Z
0812  1077  	BCF CompTempVar2305,0
0813  0877  	MOVF CompTempVar2305, W
0814  0578  	ANDWF CompTempVar2306, W
0815  1903  	BTFSC STATUS,Z
0816  283F  	GOTO	label109
083F        label109

				{

					//Loop
					//Loop: Loop 30 times
					for (FCLV_LOOP1=0; FCLV_LOOP1<30; FCLV_LOOP1++)
0817  01EA  	CLRF gbl_FCLV_LOOP1
0818        label107
0818  301E  	MOVLW 0x1E
0819  026A  	SUBWF gbl_FCLV_LOOP1, W
081A  1803  	BTFSC STATUS,C
081B  2827  	GOTO	label108
0824  0AEA  	INCF gbl_FCLV_LOOP1, F
0825  158A  	BSF PCLATH,3
0826  2818  	GOTO	label107
0827        label108

					{

						//Call Macro
						//Call Macro: all_input()
						FCM_all_input();
081C  118A  	BCF PCLATH,3
081D  2591  	CALL FCM_all_in_00054


						//Delay
						//Delay: 100 ms
						delay_ms(100);
081E  3064  	MOVLW 0x64
081F  00FD  	MOVWF delay_ms_00000_arg_del
0820  2010  	CALL delay_ms_00000


						//Decision
						//Decision: swr = 1?
						if (FCV_SWR == 1)
0821  0362  	DECF gbl_FCV_SWR, W
0822  1903  	BTFSC STATUS,Z

						{

							//Goto Connection Point
							//Goto Connection Point: [A]: A
							goto FCC_Main_A;
0823  2F26  	GOTO	label87


						// } else {

						}


					}

					//Output
					//Output: 1 -> C5
					trisc = trisc & 0xDF;
0827  30DF  	MOVLW 0xDF
0828  1683  	BSF STATUS, RP0
0829  0507  	ANDWF gbl_trisc, W
082A  0087  	MOVWF gbl_trisc

					if ((1))
						portc = (portc & 0xDF) | 0x20;
082B  30DF  	MOVLW 0xDF
082C  1283  	BCF STATUS, RP0
082D  0507  	ANDWF gbl_portc, W
082E  00F9  	MOVWF CompTempVar2307
082F  3020  	MOVLW 0x20
0830  0479  	IORWF CompTempVar2307, W
0831  0087  	MOVWF gbl_portc

					else
						portc = portc & 0xDF;

					//Delay
					//Delay: 3 s
					delay_s(3);
0832  3003  	MOVLW 0x03
0833  00F9  	MOVWF delay_s_00000_arg_del
0834  118A  	BCF PCLATH,3
0835  201C  	CALL delay_s_00000


					//Output
					//Output: 0 -> C5
					trisc = trisc & 0xDF;
0836  30DF  	MOVLW 0xDF
0837  1683  	BSF STATUS, RP0
0838  0507  	ANDWF gbl_trisc, W
0839  0087  	MOVWF gbl_trisc

					if ((0))
						portc = (portc & 0xDF) | 0x20;
					else
						portc = portc & 0xDF;
083A  30DF  	MOVLW 0xDF
083B  1283  	BCF STATUS, RP0
083C  0507  	ANDWF gbl_portc, W
083D  0087  	MOVWF gbl_portc


				} else {
083E  2F10  	GOTO	label86


					//Call Macro
					//Call Macro: scan_off()
					FCM_scan_off();
083F  118A  	BCF PCLATH,3
0840  206E  	CALL FCM_scan_o_00051


					//Call Component Macro
					//Call Component Macro: SetDutyCycle(0)
					FCD_PWM0_SetDutyCycle(0);
0841  01FD  	CLRF FCD_PWM0_S_00061_arg_nDuty
0842  2268  	CALL FCD_PWM0_S_00061


				}

			}

		}


	}

	mainendloop: goto mainendloop;
}


void MX_INTERRUPT_MACRO(void)

{
}
0894  1283  	BCF STATUS, RP0
0895  1303  	BCF STATUS, RP1
0896  0E3E  	SWAPF Int1BContext+D'2', W
0897  0084  	MOVWF FSR
0898  0E3D  	SWAPF Int1BContext+D'1', W
0899  008A  	MOVWF PCLATH
089A  0E3C  	SWAPF Int1BContext, W
089B  0083  	MOVWF STATUS
089C  0EFF  	SWAPF Int1Context, F
089D  0E7F  	SWAPF Int1Context, W
089E  0009  	RETFIE





/*********************************************************************
 *                  Flowcode CAL EEPROM File
 *
 * File: PIC_CAL_EEPROM.c
 *
 * (c) 2011 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * Company) for its Flowcode graphical programming language is
 * intended and supplied to you, the Companys customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 210911 | BR | Created
 */



//EEPROM Function Prototypes
MX_UINT8 FC_CAL_EE_Read (MX_UINT16 Address);
void FC_CAL_EE_Write (MX_UINT16 Address, MX_UINT8 Data);



MX_UINT8 FC_CAL_EE_Read (MX_UINT16 Address)

{
	char data = 0;
02BB  01F9  	CLRF FC_CAL_EE__0007D_1_data

	#ifdef MX_EE
		#ifdef _BOOSTC

			#ifdef EEADR
			  #ifndef MX_EEADR
				#define MX_EEADR eeadr
			  #endif
			#endif
			#ifdef EEADRL
			  #ifndef MX_EEADR
				#define MX_EEADR eeadrl
			  #endif
			#endif

			#ifdef EEDATA
			  #ifndef MX_EEDATA
				#define MX_EEDATA eedata
			  #endif
			#endif
			#ifdef EEDATAL
			  #ifndef MX_EEDATA
				#define MX_EEDATA eedatal
			  #endif
			#endif
			#ifdef EEDATL
			  #ifndef MX_EEDATA
				#define MX_EEDATA eedatl
			  #endif
			#endif

			#ifndef MX_EEADR	//Catch Error
				#error "EEPROM error - MX_EEADR not set"
			#endif
			#ifndef MX_EEDATA
				#error "EEPROM error - MX_EEDATA not set"
			#endif

			MX_EEADR = Address & 0xff;
02BC  0877  	MOVF FC_CAL_EE__0007D_arg_Address, W
02BD  1703  	BSF STATUS, RP1
02BE  008D  	MOVWF gbl_eeadr

			#if (MX_EE_SIZE > 256)
				eeadrh = (Address & 0xff00) >> 8;
			#endif
			#ifdef MX_EE_TYPE2
				clear_bit(eecon1, EEPGD);
02BF  1683  	BSF STATUS, RP0
02C0  138C  	BCF gbl_eecon1,7

			#endif
			#ifdef MX_EE_TYPE3
				clear_bit(eecon1, EEPGD);
				clear_bit(eecon1, CFGS);
			#endif
			set_bit(eecon1, RD);
02C1  140C  	BSF gbl_eecon1,0

			data = MX_EEDATA;
02C2  1283  	BCF STATUS, RP0
02C3  080C  	MOVF gbl_eedata, W
02C4  1303  	BCF STATUS, RP1
02C5  00F9  	MOVWF FC_CAL_EE__0007D_1_data

		#endif
		#ifdef HI_TECH_C
			data = eeprom_read(Address);
		#endif
	#else
		#error "Chip does not have EEPROM memory"
	#endif
	return (data);
02C6  0879  	MOVF FC_CAL_EE__0007D_1_data, W
02C7  00FA  	MOVWF CompTempVarRet2292

}
02C8  0008  	RETURN


void FC_CAL_EE_Write (MX_UINT16 Address, MX_UINT8 Data)

{
	#ifdef MX_EE
		#ifdef _BOOSTC

			#ifdef EEADR
			  #ifndef MX_EEADR
				#define MX_EEADR eeadr
			  #endif
			#endif
			#ifdef EEADRL
			  #ifndef MX_EEADR
				#define MX_EEADR eeadrl
			  #endif
			#endif

			#ifdef EEDATA
			  #ifndef MX_EEDATA
				#define MX_EEDATA eedata
			  #endif
			#endif
			#ifdef EEDATAL
			  #ifndef MX_EEDATA
				#define MX_EEDATA eedatal
			  #endif
			#endif
			#ifdef EEDATL
			  #ifndef MX_EEDATA
				#define MX_EEDATA eedatl
			  #endif
			#endif

			#ifndef MX_EEADR	//Catch Error
				#error "EEPROM error - MX_EEADR not set"
			#endif
			#ifndef MX_EEDATA
				#error "EEPROM error - MX_EEDATA not set"
			#endif

			char bInterruptsEnabled;
			//wait for previous EE writes to complete...
			while (test_bit(eecon1, WR));
01B3        label21
01B3  1703  	BSF STATUS, RP1
01B4  188C  	BTFSC gbl_eecon1,1
01B5  29B3  	GOTO	label21

			MX_EEADR = Address & 0xff;
01B6  1303  	BCF STATUS, RP1
01B7  0822  	MOVF FC_CAL_EE__0007E_arg_Address, W
01B8  1283  	BCF STATUS, RP0
01B9  1703  	BSF STATUS, RP1
01BA  008D  	MOVWF gbl_eeadr

			#if (MX_EE_SIZE > 256)
				eeadrh = (Address & 0xff00) >> 8;
			#endif
			MX_EEDATA = Data;
01BB  1683  	BSF STATUS, RP0
01BC  1303  	BCF STATUS, RP1
01BD  0824  	MOVF FC_CAL_EE__0007E_arg_Data, W
01BE  1283  	BCF STATUS, RP0
01BF  1703  	BSF STATUS, RP1
01C0  008C  	MOVWF gbl_eedata

			#ifdef MX_EE_TYPE2
				clear_bit(eecon1, EEPGD);
01C1  1683  	BSF STATUS, RP0
01C2  138C  	BCF gbl_eecon1,7

			#endif
			#ifdef MX_EE_TYPE3
				clear_bit(eecon1, EEPGD);
				clear_bit(eecon1, CFGS);
			#endif
			set_bit(eecon1, WREN);
01C3  150C  	BSF gbl_eecon1,2

			bInterruptsEnabled = test_bit(intcon, GIE);
01C4  3080  	MOVLW 0x80
01C5  050B  	ANDWF gbl_intcon, W
01C6  1303  	BCF STATUS, RP1
01C7  00A5  	MOVWF FC_CAL_EE__0007E_1_bInterr_0007F

			clear_bit(intcon, GIE);			//Disable Interrupts
01C8  138B  	BCF gbl_intcon,7

			eecon2 = 0x55;
01C9  3055  	MOVLW 0x55
01CA  1703  	BSF STATUS, RP1
01CB  008D  	MOVWF gbl_eecon2

			eecon2 = 0xAA;
01CC  30AA  	MOVLW 0xAA
01CD  008D  	MOVWF gbl_eecon2

			set_bit(eecon1, WR);
01CE  148C  	BSF gbl_eecon1,1

			while (test_bit(eecon1, WR));	//wait for EE write to complete...
01CF        label22
01CF  188C  	BTFSC gbl_eecon1,1
01D0  29CF  	GOTO	label22

			if (bInterruptsEnabled)
01D1  1303  	BCF STATUS, RP1
01D2  08A5  	MOVF FC_CAL_EE__0007E_1_bInterr_0007F, F
01D3  1903  	BTFSC STATUS,Z
01D4  29D6  	GOTO	label23
01D6        label23

				set_bit(intcon, GIE);		//Re-enable Interrupts
01D5  178B  	BSF gbl_intcon,7

			clear_bit(eecon1, WREN);
01D6  1703  	BSF STATUS, RP1
01D7  110C  	BCF gbl_eecon1,2

		#endif
		#ifdef HI_TECH_C
			eeprom_write(Address, Data);
		#endif
	#else
		#error "Chip does not have EEPROM memory"
	#endif
}
01D8  0008  	RETURN



/*********************************************************************
 *                  Flowcode CAL I2C File
 *
 * File: PIC_CAL_I2C.c
 *
 * (c) 2011 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * Company) for its Flowcode graphical programming language is
 * intended and supplied to you, the Companys customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 210911 | BR | Created
 * 021211 | BR | Converted to new dynamic defines mechanism
 *
 */


//When using hardware I2C channels override port and pin conns with FCD conn definitions
#ifdef MX_I2C_REF1
	#if MX_I2C_CHANNEL_1 > 0
		#undef MX_I2C_SDA_PIN_1
		#undef MX_I2C_SDA_PORT_1
		#undef MX_I2C_SDA_TRIS_1
		#undef MX_I2C_SCL_PIN_1
		#undef MX_I2C_SCL_PORT_1
		#undef MX_I2C_SCL_TRIS_1
	#endif
	#if MX_I2C_CHANNEL_1 == 1
		#define MX_I2C_SDA_PIN_1		MX_I2C_1_SDA_PIN
		#define MX_I2C_SDA_PORT_1		MX_I2C_1_SDA_PORT
		#define MX_I2C_SDA_TRIS_1		MX_I2C_1_SDA_TRIS
		#define MX_I2C_SCL_PIN_1		MX_I2C_1_SCL_PIN
		#define MX_I2C_SCL_PORT_1		MX_I2C_1_SCL_PORT
		#define MX_I2C_SCL_TRIS_1		MX_I2C_1_SCL_TRIS
	#endif
	#if MX_I2C_CHANNEL_1 == 2
		#define MX_I2C_SDA_PIN_1		MX_I2C_2_SDA_PIN
		#define MX_I2C_SDA_PORT_1		MX_I2C_2_SDA_PORT
		#define MX_I2C_SDA_TRIS_1		MX_I2C_2_SDA_TRIS
		#define MX_I2C_SCL_PIN_1		MX_I2C_2_SCL_PIN
		#define MX_I2C_SCL_PORT_1		MX_I2C_2_SCL_PORT
		#define MX_I2C_SCL_TRIS_1		MX_I2C_2_SCL_TRIS
	#endif
	#if MX_I2C_CHANNEL_1 == 3
		#define MX_I2C_SDA_PIN_1		MX_I2C_3_SDA_PIN
		#define MX_I2C_SDA_PORT_1		MX_I2C_3_SDA_PORT
		#define MX_I2C_SDA_TRIS_1		MX_I2C_3_SDA_TRIS
		#define MX_I2C_SCL_PIN_1		MX_I2C_3_SCL_PIN
		#define MX_I2C_SCL_PORT_1		MX_I2C_3_SCL_PORT
		#define MX_I2C_SCL_TRIS_1		MX_I2C_3_SCL_TRIS
	#endif
	#if MX_I2C_CHANNEL_1 == 4
		#define MX_I2C_SDA_PIN_1		MX_I2C_4_SDA_PIN
		#define MX_I2C_SDA_PORT_1		MX_I2C_4_SDA_PORT
		#define MX_I2C_SDA_TRIS_1		MX_I2C_4_SDA_TRIS
		#define MX_I2C_SCL_PIN_1		MX_I2C_4_SCL_PIN
		#define MX_I2C_SCL_PORT_1		MX_I2C_4_SCL_PORT
		#define MX_I2C_SCL_TRIS_1		MX_I2C_4_SCL_TRIS
	#endif
#endif
#ifdef MX_I2C_REF2
	#if MX_I2C_CHANNEL_2 > 0
		#undef MX_I2C_SDA_PIN_2
		#undef MX_I2C_SDA_PORT_2
		#undef MX_I2C_SDA_TRIS_2
		#undef MX_I2C_SCL_PIN_2
		#undef MX_I2C_SCL_PORT_2
		#undef MX_I2C_SCL_TRIS_2
	#endif
	#if MX_I2C_CHANNEL_2 == 1
		#define MX_I2C_SDA_PIN_2		MX_I2C_1_SDA_PIN
		#define MX_I2C_SDA_PORT_2		MX_I2C_1_SDA_PORT
		#define MX_I2C_SDA_TRIS_2		MX_I2C_1_SDA_TRIS
		#define MX_I2C_SCL_PIN_2		MX_I2C_1_SCL_PIN
		#define MX_I2C_SCL_PORT_2		MX_I2C_1_SCL_PORT
		#define MX_I2C_SCL_TRIS_2		MX_I2C_1_SCL_TRIS
	#endif
	#if MX_I2C_CHANNEL_2 == 2
		#define MX_I2C_SDA_PIN_2		MX_I2C_2_SDA_PIN
		#define MX_I2C_SDA_PORT_2		MX_I2C_2_SDA_PORT
		#define MX_I2C_SDA_TRIS_2		MX_I2C_2_SDA_TRIS
		#define MX_I2C_SCL_PIN_2		MX_I2C_2_SCL_PIN
		#define MX_I2C_SCL_PORT_2		MX_I2C_2_SCL_PORT
		#define MX_I2C_SCL_TRIS_2		MX_I2C_2_SCL_TRIS
	#endif
	#if MX_I2C_CHANNEL_2 == 3
		#define MX_I2C_SDA_PIN_2		MX_I2C_3_SDA_PIN
		#define MX_I2C_SDA_PORT_2		MX_I2C_3_SDA_PORT
		#define MX_I2C_SDA_TRIS_2		MX_I2C_3_SDA_TRIS
		#define MX_I2C_SCL_PIN_2		MX_I2C_3_SCL_PIN
		#define MX_I2C_SCL_PORT_2		MX_I2C_3_SCL_PORT
		#define MX_I2C_SCL_TRIS_2		MX_I2C_3_SCL_TRIS
	#endif
	#if MX_I2C_CHANNEL_2 == 4
		#define MX_I2C_SDA_PIN_2		MX_I2C_4_SDA_PIN
		#define MX_I2C_SDA_PORT_2		MX_I2C_4_SDA_PORT
		#define MX_I2C_SDA_TRIS_2		MX_I2C_4_SDA_TRIS
		#define MX_I2C_SCL_PIN_2		MX_I2C_4_SCL_PIN
		#define MX_I2C_SCL_PORT_2		MX_I2C_4_SCL_PORT
		#define MX_I2C_SCL_TRIS_2		MX_I2C_4_SCL_TRIS
	#endif
#endif
#ifdef MX_I2C_REF3
	#if MX_I2C_CHANNEL_3 > 0
		#undef MX_I2C_SDA_PIN_3
		#undef MX_I2C_SDA_PORT_3
		#undef MX_I2C_SDA_TRIS_3
		#undef MX_I2C_SCL_PIN_3
		#undef MX_I2C_SCL_PORT_3
		#undef MX_I2C_SCL_TRIS_3
	#endif
	#if MX_I2C_CHANNEL_3 == 1
		#define MX_I2C_SDA_PIN_3		MX_I2C_1_SDA_PIN
		#define MX_I2C_SDA_PORT_3		MX_I2C_1_SDA_PORT
		#define MX_I2C_SDA_TRIS_3		MX_I2C_1_SDA_TRIS
		#define MX_I2C_SCL_PIN_3		MX_I2C_1_SCL_PIN
		#define MX_I2C_SCL_PORT_3		MX_I2C_1_SCL_PORT
		#define MX_I2C_SCL_TRIS_3		MX_I2C_1_SCL_TRIS
	#endif
	#if MX_I2C_CHANNEL_3 == 2
		#define MX_I2C_SDA_PIN_3		MX_I2C_2_SDA_PIN
		#define MX_I2C_SDA_PORT_3		MX_I2C_2_SDA_PORT
		#define MX_I2C_SDA_TRIS_3		MX_I2C_2_SDA_TRIS
		#define MX_I2C_SCL_PIN_3		MX_I2C_2_SCL_PIN
		#define MX_I2C_SCL_PORT_3		MX_I2C_2_SCL_PORT
		#define MX_I2C_SCL_TRIS_3		MX_I2C_2_SCL_TRIS
	#endif
	#if MX_I2C_CHANNEL_3 == 3
		#define MX_I2C_SDA_PIN_3		MX_I2C_3_SDA_PIN
		#define MX_I2C_SDA_PORT_3		MX_I2C_3_SDA_PORT
		#define MX_I2C_SDA_TRIS_3		MX_I2C_3_SDA_TRIS
		#define MX_I2C_SCL_PIN_3		MX_I2C_3_SCL_PIN
		#define MX_I2C_SCL_PORT_3		MX_I2C_3_SCL_PORT
		#define MX_I2C_SCL_TRIS_3		MX_I2C_3_SCL_TRIS
	#endif
	#if MX_I2C_CHANNEL_3 == 4
		#define MX_I2C_SDA_PIN_3		MX_I2C_4_SDA_PIN
		#define MX_I2C_SDA_PORT_3		MX_I2C_4_SDA_PORT
		#define MX_I2C_SDA_TRIS_3		MX_I2C_4_SDA_TRIS
		#define MX_I2C_SCL_PIN_3		MX_I2C_4_SCL_PIN
		#define MX_I2C_SCL_PORT_3		MX_I2C_4_SCL_PORT
		#define MX_I2C_SCL_TRIS_3		MX_I2C_4_SCL_TRIS
	#endif
#endif
#ifdef MX_I2C_REF4
	#if MX_I2C_CHANNEL_4 > 0
		#undef MX_I2C_SDA_PIN_4
		#undef MX_I2C_SDA_PORT_4
		#undef MX_I2C_SDA_TRIS_4
		#undef MX_I2C_SCL_PIN_4
		#undef MX_I2C_SCL_PORT_4
		#undef MX_I2C_SCL_TRIS_4
	#endif
	#if MX_I2C_CHANNEL_4 == 1
		#define MX_I2C_SDA_PIN_4		MX_I2C_1_SDA_PIN
		#define MX_I2C_SDA_PORT_4		MX_I2C_1_SDA_PORT
		#define MX_I2C_SDA_TRIS_4		MX_I2C_1_SDA_TRIS
		#define MX_I2C_SCL_PIN_4		MX_I2C_1_SCL_PIN
		#define MX_I2C_SCL_PORT_4		MX_I2C_1_SCL_PORT
		#define MX_I2C_SCL_TRIS_4		MX_I2C_1_SCL_TRIS
	#endif
	#if MX_I2C_CHANNEL_4 == 2
		#define MX_I2C_SDA_PIN_4		MX_I2C_2_SDA_PIN
		#define MX_I2C_SDA_PORT_4		MX_I2C_2_SDA_PORT
		#define MX_I2C_SDA_TRIS_4		MX_I2C_2_SDA_TRIS
		#define MX_I2C_SCL_PIN_4		MX_I2C_2_SCL_PIN
		#define MX_I2C_SCL_PORT_4		MX_I2C_2_SCL_PORT
		#define MX_I2C_SCL_TRIS_4		MX_I2C_2_SCL_TRIS
	#endif
	#if MX_I2C_CHANNEL_4 == 3
		#define MX_I2C_SDA_PIN_4		MX_I2C_3_SDA_PIN
		#define MX_I2C_SDA_PORT_4		MX_I2C_3_SDA_PORT
		#define MX_I2C_SDA_TRIS_4		MX_I2C_3_SDA_TRIS
		#define MX_I2C_SCL_PIN_4		MX_I2C_3_SCL_PIN
		#define MX_I2C_SCL_PORT_4		MX_I2C_3_SCL_PORT
		#define MX_I2C_SCL_TRIS_4		MX_I2C_3_SCL_TRIS
	#endif
	#if MX_I2C_CHANNEL_4 == 4
		#define MX_I2C_SDA_PIN_4		MX_I2C_4_SDA_PIN
		#define MX_I2C_SDA_PORT_4		MX_I2C_4_SDA_PORT
		#define MX_I2C_SDA_TRIS_4		MX_I2C_4_SDA_TRIS
		#define MX_I2C_SCL_PIN_4		MX_I2C_4_SCL_PIN
		#define MX_I2C_SCL_PORT_4		MX_I2C_4_SCL_PORT
		#define MX_I2C_SCL_TRIS_4		MX_I2C_4_SCL_TRIS
	#endif
#endif

#define MX_I2C_CHANNEL_X		CAL_APPEND(MX_I2C_CHANNEL_, MX_I2C_NUM)
#define MX_I2C_SDA_PIN_X		CAL_APPEND(MX_I2C_SDA_PIN_, MX_I2C_NUM)
#define MX_I2C_SDA_PORT_X		CAL_APPEND(MX_I2C_SDA_PORT_, MX_I2C_NUM)
#define MX_I2C_SDA_TRIS_X		CAL_APPEND(MX_I2C_SDA_TRIS_, MX_I2C_NUM)
#define MX_I2C_SCL_PIN_X		CAL_APPEND(MX_I2C_SCL_PIN_, MX_I2C_NUM)
#define MX_I2C_SCL_PORT_X		CAL_APPEND(MX_I2C_SCL_PORT_, MX_I2C_NUM)
#define MX_I2C_SCL_TRIS_X		CAL_APPEND(MX_I2C_SCL_TRIS_, MX_I2C_NUM)
#define MX_I2C_BMODE_X			CAL_APPEND(MX_I2C_BMODE_, MX_I2C_NUM)
#define MX_I2C_BAUD_X			CAL_APPEND(MX_I2C_BAUD_, MX_I2C_NUM)
#define MX_I2C_INT_X			CAL_APPEND(MX_I2C_INT_, MX_I2C_NUM)


//Function Prototypes
CALFUNCTION(void, FC_CAL_I2C_Master_Init_, (void));
CALFUNCTION(void, FC_CAL_I2C_Master_Uninit_, (void));
CALFUNCTION(void, FC_CAL_I2C_Master_Start_, (void));
CALFUNCTION(void, FC_CAL_I2C_Master_Restart_, (void));
CALFUNCTION(void, FC_CAL_I2C_Master_Stop_, (void));
CALFUNCTION(MX_UINT8, FC_CAL_I2C_Master_TX_Byte_, (MX_UINT8 Data));
CALFUNCTION(MX_UINT8, FC_CAL_I2C_Master_RX_Byte_, (MX_UINT8 Last));

CALFUNCTION(void, FC_CAL_I2C_Slave_Init_, (void));
CALFUNCTION(void, FC_CAL_I2C_Slave_Uninit_, (void));
CALFUNCTION(void, FC_CAL_I2C_Slave_SetTxData_, (MX_UINT8 Data));
CALFUNCTION(MX_UINT8, FC_CAL_I2C_Slave_GetRxData_, (MX_UINT8 Last));


//Ensure SSPCON register is defined correctly
#ifndef SSPCON
  #ifdef SSPCON1
	#define sspcon	sspcon1
  #else
	#ifdef SSP1CON1
		#define sspcon	ssp1con1
	#endif
  #endif
#endif

//Ensure SSPIF register is defined correctly
#ifndef SSPIF
  #ifdef SSP1IF
	#define SSPIF	SSP1IF
  #else
	#error "I2C does not have the SSPIF defined on this chip - does your chip support this feature?"
  #endif
#endif


//Ensure SSPCON2 register is defined correctly
#ifndef SSPCON2
  #ifdef SSP1CON2
	#define sspcon2	ssp1con2
  #endif
#endif


//Ensure SSPSTAT register is defined correctly
#ifndef SSPSTAT
  #ifdef SSP1STAT
	#define sspstat	ssp1stat
  #endif
#endif


//Ensure SSPADD register is defined correctly
#ifndef SSPADD
  #ifdef SSP1ADD
	#define sspadd	ssp1add
  #endif
#endif


//Ensure SSPBUFF register is defined correctly
#ifndef SSPBUFF
  #ifdef SSP1BUFF
	#define sspbuff	ssp1buff
  #endif
#endif


//If software channel is enabled then define bit delay.
#if (MX_I2C_CHANNEL_X == 0)
  #ifndef MX_I2C_SW_DEL
	#define MX_I2C_SW_DEL
	#define MX_I2C_DELAY	delay_us(20);
  #endif
#endif


CALFUNCTION(void, FC_CAL_I2C_Master_Init_, (void))

{

	#if (MX_I2C_CHANNEL_X == 0)															//Use Master I2C Software
		FC_CAL_Bit_In_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);		//Configure SDA as Input
		FC_CAL_Bit_In_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);		//Configure SCL as Input
	#endif

	#if (MX_I2C_CHANNEL_X == 1)												//Use Master I2C Hardware 1
		#ifndef MX_MI2C
			#error "This chip does not have Master I2C capability"
		#else

			#ifndef MX_I2C_1
				#error "This chip does not have Master I2C channel 1"
			#endif

			#if (MX_I2C_BMODE_X & 0x01)
				cr_bit (sspstat,SMP);										//Slew Rate Control Enabled
			#else
				st_bit (sspstat,SMP);										//Slew Rate Control Disabled
02AC  1683  	BSF STATUS, RP0
02AD  1303  	BCF STATUS, RP1
02AE  1794  	BSF gbl_sspstat,7

		    #endif

			#if (MX_I2C_BMODE_X & 0x02)
				st_bit (sspstat,CKE);										//Enable SMBus specific inputs
			#else
				cr_bit (sspstat,CKE);										//Disable SMBus specific inputs
02AF  1314  	BCF gbl_sspstat,6

			#endif

			sspcon = 0x28;													//Setup I2C into Master Mode
02B0  3028  	MOVLW 0x28
02B1  1283  	BCF STATUS, RP0
02B2  0094  	MOVWF gbl_sspcon

			sspadd = MX_I2C_BAUD_X;											//Set the Baud Rate
02B3  30A0  	MOVLW 0xA0
02B4  1683  	BSF STATUS, RP0
02B5  0093  	MOVWF gbl_sspadd

			sspcon2 = 0x00;													//Clear the control bits
02B6  0191  	CLRF gbl_sspcon2

			st_bit(intcon, GIE);
02B7  178B  	BSF gbl_intcon,7

			FC_CAL_Bit_In_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);		//Configure SDA as Input
02B8  1607  	BSF gbl_trisc,4

			FC_CAL_Bit_In_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);		//Configure SCL as Input
02B9  1587  	BSF gbl_trisc,3

		#endif
	#endif

	#if (MX_I2C_CHANNEL_X == 2)												//Use Master I2C Hardware 2
		#ifndef MX_MI2C
			#error "This chip does not have Master I2C capability"
		#else

			#ifndef MX_I2C_2
				#error "This chip does not have Master I2C channel 2"
			#endif

		  #ifdef MX_I2C_2_REMAPPABLE
			RPOR4 = 9;														//SDA2 - RB1 - RP4
			RPOR5 = 10;														//SCL2 - RB2 - RP5
		  #endif

			#if (MX_I2C_BMODE_X & 0x01)
				cr_bit (ssp2stat,SMP);										//Slew Rate Control Enabled
			#else
				st_bit (ssp2stat,SMP);										//Slew Rate Control Disabled
			#endif

			#if (MX_I2C_BMODE_X & 0x02)
				st_bit (ssp2stat,CKE);										//Enable SMBus specific inputs
			#else
				cr_bit (ssp2stat,CKE);										//Disable SMBus specific inputs
			#endif

			ssp2con = 0x28;													//Setup I2C into Master Mode
			ssp2add = MX_I2C_BAUD_X;										//Set the Baud Rate
			ssp2con2 = 0x00;												//Clear the control bits
			st_bit(intcon, GIE);
			FC_CAL_Bit_In_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);			//Configure SDA as Input
			FC_CAL_Bit_In_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);			//Configure SCL as Input
		#endif
	#endif
}
02BA  0008  	RETURN


CALFUNCTION(void, FC_CAL_I2C_Master_Uninit_, (void))
{
	#if (MX_I2C_CHANNEL_X == 0)																//Use Master I2C Software
		FC_CAL_Bit_In_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);			//Configure SDA as Input
		FC_CAL_Bit_In_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);			//Configure SCL as Input
	#endif

	#if (MX_I2C_CHANNEL_X == 1)												//Use Master I2C Hardware 1
		cr_bit(sspcon, SSPEN);												//Disable SSP
	#endif

	#if (MX_I2C_CHANNEL_X == 2)												//Use Master I2C Hardware 2
		cr_bit(ssp2con, SSPEN);												//Disable SSP
	#endif
}

CALFUNCTION(void, FC_CAL_I2C_Master_Start_, (void))

{
	#if (MX_I2C_CHANNEL_X == 0)															//Use Master I2C Software
		FC_CAL_Bit_In_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);		//Make Sure SCL is Set
		FC_CAL_Bit_In_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);		//Make Sure SDA is Set
		MX_I2C_DELAY;																	//Small Delay
		FC_CAL_Bit_Low_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);		//Clear SDA
		MX_I2C_DELAY;																	//Small Delay
		FC_CAL_Bit_Low_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);		//Clear SCL
		MX_I2C_DELAY;																	//Small Delay
	#endif

	#if (MX_I2C_CHANNEL_X == 1)												//Use Master I2C Hardware 1
		cr_bit(pir1, SSPIF);												//Clear SSP interrupt flag
0066  1283  	BCF STATUS, RP0
0067  1303  	BCF STATUS, RP1
0068  118C  	BCF gbl_pir1,3

		st_bit(sspcon2,SEN);												//Initiate start condition
0069  1683  	BSF STATUS, RP0
006A  1411  	BSF gbl_sspcon2,0

		while(ts_bit(sspcon2,SEN));											//Wait for start bit to be generated
006B        label12
006B  1811  	BTFSC gbl_sspcon2,0
006C  286B  	GOTO	label12

	#endif

	#if (MX_I2C_CHANNEL_X == 2)												//Use Master I2C Hardware 2
		cr_bit(pir3, SSP2IF);												//Clear SSP interrupt flag
		st_bit(ssp2con2,SEN);												//Initiate start condition
		while(ts_bit(ssp2con2,SEN));										//Wait for start bit to be generated
	#endif
}
006D  0008  	RETURN


CALFUNCTION(void, FC_CAL_I2C_Master_Restart_, (void))

{
	#if (MX_I2C_CHANNEL_X == 0)															//Use Master I2C Software
		FC_CAL_Bit_In_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);		//Set SDA High
		MX_I2C_DELAY;
		FC_CAL_Bit_In_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);		//Set SCL High
		MX_I2C_DELAY;
		FC_CAL_Bit_Low_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);		//Set SDA Low
		MX_I2C_DELAY;
		FC_CAL_Bit_Low_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);		//Set SCL Low
		MX_I2C_DELAY;
	#endif

	#if (MX_I2C_CHANNEL_X == 1)												//Use Master I2C Hardware 1
		cr_bit(pir1, SSPIF);												//Clear SSP interrupt flag
005E  1283  	BCF STATUS, RP0
005F  1303  	BCF STATUS, RP1
0060  118C  	BCF gbl_pir1,3

		st_bit(sspcon2,RSEN);												//Initiate restart condition
0061  1683  	BSF STATUS, RP0
0062  1491  	BSF gbl_sspcon2,1

		while(ts_bit(sspcon2,RSEN));										//Wait for restart bit to be generated
0063        label11
0063  1891  	BTFSC gbl_sspcon2,1
0064  2863  	GOTO	label11

	#endif

	#if (MX_I2C_CHANNEL_X == 2)												//Use Master I2C Hardware 2
		cr_bit(pir3, SSP2IF);												//Clear SSP interrupt flag
		st_bit(ssp2con2,RSEN);												//Initiate restart condition
		while(ts_bit(ssp2con2,RSEN));										//Wait for restart bit to be generated
	#endif
}
0065  0008  	RETURN


CALFUNCTION(void, FC_CAL_I2C_Master_Stop_, (void))

{
	#if (MX_I2C_CHANNEL_X == 0)															//Use Master I2C Software
		FC_CAL_Bit_Low_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);		//Set SCL Low
		FC_CAL_Bit_Low_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);		//Set SDA Low
		MX_I2C_DELAY;
		FC_CAL_Bit_In_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);		//Set SCL High
		MX_I2C_DELAY;
		FC_CAL_Bit_In_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);		//Set SDA High
	#endif

	#if (MX_I2C_CHANNEL_X == 1)												//Use Master I2C Hardware 1
		cr_bit(pir1,SSPIF);													//Clear SSP interrupt flag
0052  1283  	BCF STATUS, RP0
0053  1303  	BCF STATUS, RP1
0054  118C  	BCF gbl_pir1,3

		st_bit(sspcon2,PEN);												//Initiate stop condition
0055  1683  	BSF STATUS, RP0
0056  1511  	BSF gbl_sspcon2,2

		while(ts_bit(sspcon2,PEN));											//Wait for stop bit to be generated
0057        label10
0057  1911  	BTFSC gbl_sspcon2,2
0058  2857  	GOTO	label10

	#endif

	#if (MX_I2C_CHANNEL_X == 2)												//Use Master I2C Hardware 2
		cr_bit(pir3,SSP2IF);												//Clear SSP interrupt flag
		st_bit(ssp2con2,PEN);												//Initiate stop condition
		while(ts_bit(ssp2con2,PEN));										//Wait for stop bit to be generated
	#endif

  delay_ms(10);																//Wait before reusing the I2C BUS
0059  300A  	MOVLW 0x0A
005A  1283  	BCF STATUS, RP0
005B  00FD  	MOVWF delay_ms_00000_arg_del
005C  2010  	CALL delay_ms_00000

}
005D  0008  	RETURN


CALFUNCTION(MX_UINT8, FC_CAL_I2C_Master_TX_Byte_, (MX_UINT8 Data))

{
	#if (MX_I2C_CHANNEL_X == 0)												//Use Master I2C Software
		char bit_mask;
		char local_ack = 0;
		for(bit_mask=0x80;bit_mask;bit_mask=bit_mask>>1)
		{
			if(Data & bit_mask)
			{
				FC_CAL_Bit_In_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);	//Set SDA High
			}
			else
			{
				FC_CAL_Bit_Low_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);	//Set SDA Low
			}
			MX_I2C_DELAY;
			FC_CAL_Bit_In_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);		//Set SCL High
			MX_I2C_DELAY;
			FC_CAL_Bit_Low_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);		//Set SCL Low
			MX_I2C_DELAY;
		}
		FC_CAL_Bit_In_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);			//Set SDA High
		MX_I2C_DELAY;
		FC_CAL_Bit_In_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);			//Set SCL High
		MX_I2C_DELAY;
		FC_CAL_Bit_In_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);
		if (FC_CAL_Bit_In(MX_I2C_SDA_PORT_X, MX_I2C_SDA_PIN_X))		//Get the Status Bit
			local_ack = 1;
		MX_I2C_DELAY;
		FC_CAL_Bit_Low_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);			//Set SCL Low
		MX_I2C_DELAY;
		return (local_ack);													//0 = Ack received : 1 = Ack not received
	#endif

	#if (MX_I2C_CHANNEL_X == 1)												//Use Master I2C Hardware 1
		cr_bit(pir1,SSPIF);													//Clear SSP interrupt flag
0043  118C  	BCF gbl_pir1,3

		sspbuf=Data;														//Send byte
0044  0876  	MOVF FC_CAL_I2C_00078_arg_Data, W
0045  0093  	MOVWF gbl_sspbuf

		while(ts_bit(pir1,SSPIF) == 0);										//Wait for control bit to be sent
0046        label8
0046  1D8C  	BTFSS gbl_pir1,3
0047  2846  	GOTO	label8

		if(ts_bit(sspcon2,ACKSTAT))											//Check Acknowledgement
0048  1683  	BSF STATUS, RP0
0049  1F11  	BTFSS gbl_sspcon2,6
004A  284F  	GOTO	label9
004F        label9

			return (1);														//No Acknowledgement
004B  3001  	MOVLW 0x01
004C  1283  	BCF STATUS, RP0
004D  00F7  	MOVWF CompTempVarRet2287

		else return (0);													//Acknowledgement received
004F  1283  	BCF STATUS, RP0
0050  01F7  	CLRF CompTempVarRet2287

	#endif

	#if (MX_I2C_CHANNEL_X == 2)												//Use Master I2C Hardware 2
		cr_bit(pir3,SSP2IF);												//Clear SSP interrupt flag
		ssp2buf=Data;														//Send byte
		while(ts_bit(pir3,SSP2IF) == 0);									//Wait for control bit to be sent
		if(ts_bit(ssp2con2,ACKSTAT))										//Check Acknowledgement
			return (1);														//No Acknowledgement
		else return (0);													//Acknowledgement received
	#endif
}
004E  0008  	RETURN
0051  0008  	RETURN


CALFUNCTION(MX_UINT8, FC_CAL_I2C_Master_RX_Byte_, (MX_UINT8 Last))

{
	#if (MX_I2C_CHANNEL_X == 0)												//Use Master I2C Software
		char bit_mask;
		char Data = 0;
		char local_ack;
		FC_CAL_Bit_In_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);			//Set SDA High
		MX_I2C_DELAY;
		for(bit_mask=0x80;bit_mask;bit_mask=bit_mask>>1)
		{
			FC_CAL_Bit_In_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);		//Set SCL High
			MX_I2C_DELAY;
			FC_CAL_Bit_In_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);
			if(FC_CAL_Bit_In(MX_I2C_SDA_PORT_X, MX_I2C_SDA_PIN_X))	//Read Incoming Bit
				Data = Data | bit_mask;														//Add data to variable
			FC_CAL_Bit_Low_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);		//Set SCL Low
			MX_I2C_DELAY;
		}
		if (Last)																		//Acknowledge?
		{
			FC_CAL_Bit_In_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);	//Send Nack
		}
		else
		{
			FC_CAL_Bit_Low_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);	//Send Ack
		}
		MX_I2C_DELAY;
		FC_CAL_Bit_In_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);		//Set SCL High
		MX_I2C_DELAY;
		FC_CAL_Bit_Low_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);		//Set SCL Low
		MX_I2C_DELAY;
		return (Data);
	#endif

	#if (MX_I2C_CHANNEL_X == 1)						//Use Master I2C Hardware 1
		cr_bit(pir1,SSPIF);							//Clear SSP interrupt flag
002E  118C  	BCF gbl_pir1,3

		st_bit(sspcon2,RCEN);						//Initiate Read
002F  1683  	BSF STATUS, RP0
0030  1591  	BSF gbl_sspcon2,3

		while(ts_bit(pir1,3) == 0);					//Wait for data read
0031        label4
0031  1283  	BCF STATUS, RP0
0032  1D8C  	BTFSS gbl_pir1,3
0033  2831  	GOTO	label4

		if (Last)
0034  08F6  	MOVF FC_CAL_I2C_00079_arg_Last, F
0035  1903  	BTFSC STATUS,Z
0036  283A  	GOTO	label5
003A        label5

			st_bit(sspcon2,ACKDT);					//Send Nack
0037  1683  	BSF STATUS, RP0
0038  1691  	BSF gbl_sspcon2,5

		else cr_bit(sspcon2,ACKDT);					//Send Ack
0039  283C  	GOTO	label6
003A  1683  	BSF STATUS, RP0
003B  1291  	BCF gbl_sspcon2,5
003C        label6

		st_bit(sspcon2,ACKEN);						//Initiate Nack
003C  1611  	BSF gbl_sspcon2,4

		while(ts_bit(sspcon2,ACKEN));				//Wait for data read
003D        label7
003D  1A11  	BTFSC gbl_sspcon2,4
003E  283D  	GOTO	label7

		return(sspbuf);								//Store incoming data
003F  1283  	BCF STATUS, RP0
0040  0813  	MOVF gbl_sspbuf, W
0041  00F7  	MOVWF CompTempVarRet2288

	#endif

	#if (MX_I2C_CHANNEL_X == 2)						//Use Master I2C Hardware 2
		cr_bit(pir3,SSP2IF);						//Clear SSP interrupt flag
		st_bit(ssp2con2,RCEN);						//Initiate Read
		while(ts_bit(pir3,SSP2IF) == 0);			//Wait for data read
		if (Last)
			st_bit(ssp2con2,ACKDT);					//Send Nack
		else cr_bit(ssp2con2,ACKDT);				//Send Ack
		st_bit(ssp2con2,ACKEN);						//Initiate Nack
		while(ts_bit(ssp2con2,ACKEN));				//Wait for data read
		return(ssp2buf);							//Store incoming data
	#endif
}
0042  0008  	RETURN





//Slave functions currently not implemented
CALFUNCTION(void, FC_CAL_I2C_Slave_Init_, (void))
{

}

CALFUNCTION(void, FC_CAL_I2C_Slave_Uninit_, (void))
{

}

CALFUNCTION(void, FC_CAL_I2C_Slave_SetTxData_, (MX_UINT8 Data))
{

}

CALFUNCTION(MX_UINT8, FC_CAL_I2C_Slave_GetRxData_, (MX_UINT8 Last))
{

}


/*********************************************************************
 *                  Flowcode CAL PWM File
 *
 * File: PIC_CAL_PWM.c
 *
 * (c) 2011 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * Company) for its Flowcode graphical programming language is
 * intended and supplied to you, the Companys customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 270911 | BR | Created
 * 021211 | BR | Converted to new dynamic defines mechanism
 *
 */


#define MX_PWM_CHANNEL_X		CAL_APPEND(MX_PWM_CHANNEL_, MX_PWM_NUM)
#define MX_PWM_HWALT_X			CAL_APPEND(MX_PWM_HWALT_, MX_PWM_NUM)


//I2C Master Functions
CALFUNCTION(void, FC_CAL_PWM_Enable_Channel_, (void));
CALFUNCTION(void, FC_CAL_PWM_Disable_Channel_, (void));
CALFUNCTION(void, FC_CAL_PWM_Set_Duty_8Bit_, (MX_UINT8 duty));
CALFUNCTION(void, FC_CAL_PWM_Change_Period_, (MX_UINT8 period, MX_UINT16 prescaler));
CALFUNCTION(void, FC_CAL_PWM_Set_Duty_10Bit_, (MX_UINT16 duty));


CALFUNCTION(void, FC_CAL_PWM_Enable_Channel_, (void))

{

 #ifdef MX_PWM

	#if (MX_PWM_CHANNEL_X == 1)
	  #ifdef MX_PWM_REMAPPABLE
	  	RPOR3 = 14;														//PWM1 - 14 - RB0 - RP3
	  #endif

		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
		  #ifndef MX_PWM_1_PORT											//Error checking
			#error "This chip does not have PWM channel 1 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_1_PORT, MX_PWM_1_TRIS, MX_PWM_1_PIN);			//PWM pin is an output
		#else															//Alternate PWM Pin
		  #ifndef MX_PWM_1_PORT_A										//Error checking
			#error "This chip does not have PWM alt channel 1 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_1_PORT_A, MX_PWM_1_TRIS_A, MX_PWM_1_PIN_A);		//PWM pin is an output
		#endif

		ccp1con = 0x0C;													//Enable Capture Compare Channel 1
	#endif

	#if (MX_PWM_CHANNEL_X == 2)
	  #ifdef MX_PWM_REMAPPABLE
	  	RPOR4 = 18;														//PWM2 - 18 - RB1 - RP4
	  #endif

		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
		  #ifndef MX_PWM_2_PORT											//Error checking
			#error "This chip does not have PWM channel 2 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_2_PORT, MX_PWM_2_TRIS, MX_PWM_2_PIN);			//PWM pin is an output
02A4  1683  	BSF STATUS, RP0
02A5  1303  	BCF STATUS, RP1
02A6  1087  	BCF gbl_trisc,1
02A7  1283  	BCF STATUS, RP0
02A8  1087  	BCF gbl_portc,1

		#else															//Alternate PWM Pin
		  #ifndef MX_PWM_2_PORT_A										//Error checking
			#error "This chip does not have PWM alt channel 2 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_2_PORT_A, MX_PWM_2_TRIS_A, MX_PWM_2_PIN_A);		//PWM pin is an output
		#endif

		ccp2con = 0x0C;													//Enable Capture Compare Channel 2
02A9  300C  	MOVLW 0x0C
02AA  009D  	MOVWF gbl_ccp2con

	#endif

	#if (MX_PWM_CHANNEL_X == 3)
	  #ifdef MX_PWM_REMAPPABLE
	  	RPOR5 = 22;														//PWM3 - 22 - RB2 - RP5
	  #endif

		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
		  #ifndef MX_PWM_3_PORT											//Error checking
			#error "This chip does not have PWM channel 3 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_3_PORT, MX_PWM_3_TRIS, MX_PWM_3_PIN);			//PWM pin is an output
		#else															//Alternate PWM Pin
		  #ifndef MX_PWM_3_PORT_A										//Error checking
			#error "This chip does not have PWM alt channel 3 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_3_PORT_A, MX_PWM_3_TRIS_A, MX_PWM_3_PIN_A);		//PWM pin is an output
		#endif

		ccp3con = 0x0C;													//Enable Capture Compare Channel 3 *****************************************************************
	#endif

	#if (MX_PWM_CHANNEL_X == 4)
		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
		  #ifndef MX_PWM_4_PORT											//Error checking
			#error "This chip does not have PWM channel 4 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_4_PORT, MX_PWM_4_TRIS, MX_PWM_4_PIN);			//PWM pin is an output
		#else															//Alternate PWM Pin
		  #ifndef MX_PWM_4_PORT_A										//Error checking
			#error "This chip does not have PWM alt channel 4 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_4_PORT_A, MX_PWM_4_TRIS_A, MX_PWM_4_PIN_A);		//PWM pin is an output
		#endif

		ccp4con = 0x0C;													//Enable Capture Compare Channel 4 *****************************************************************
	#endif

	#if (MX_PWM_CHANNEL_X == 5)
		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
		  #ifndef MX_PWM_5_PORT											//Error checking
			#error "This chip does not have PWM channel 5 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_5_PORT, MX_PWM_5_TRIS, MX_PWM_5_PIN);			//PWM pin is an output
		#else															//Alternate PWM Pin
		  #ifndef MX_PWM_5_PORT_A										//Error checking
			#error "This chip does not have PWM alt channel 5 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_5_PORT_A, MX_PWM_5_TRIS_A, MX_PWM_5_PIN_A);		//PWM pin is an output
		#endif

		ccp5con = 0x0C;													//Enable Capture Compare Channel 5 *****************************************************************
	#endif

	#if (MX_PWM_CHANNEL_X == 6)
		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
		  #ifndef MX_PWM_6_PORT											//Error checking
			#error "This chip does not have PWM channel 6 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_6_PORT, MX_PWM_6_TRIS, MX_PWM_6_PIN);			//PWM pin is an output
		#else															//Alternate PWM Pin
		  #ifndef MX_PWM_6_PORT_A										//Error checking
			#error "This chip does not have PWM alt channel 6 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_6_PORT_A, MX_PWM_6_TRIS_A, MX_PWM_6_PIN_A);		//PWM pin is an output
		#endif

		ccp6con = 0x0C;													//Enable Capture Compare Channel 6 *****************************************************************
	#endif

	#if (MX_PWM_CHANNEL_X == 7)
		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
		  #ifndef MX_PWM_7_PORT											//Error checking
			#error "This chip does not have PWM channel 7 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_7_PORT, MX_PWM_7_TRIS, MX_PWM_7_PIN);			//PWM pin is an output
		#else															//Alternate PWM Pin
		  #ifndef MX_PWM_7_PORT_A										//Error checking
			#error "This chip does not have PWM alt channel 7 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_7_PORT_A, MX_PWM_7_TRIS_A, MX_PWM_7_PIN_A);		//PWM pin is an output
		#endif

		ccp7con = 0x0C;													//Enable Capture Compare Channel 5 *****************************************************************
	#endif

	#if (MX_PWM_CHANNEL_X == 8)
		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
		  #ifndef MX_PWM_8_PORT											//Error checking
			#error "This chip does not have PWM channel 8 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_8_PORT, MX_PWM_8_TRIS, MX_PWM_8_PIN);			//PWM pin is an output
		#else															//Alternate PWM Pin
		  #ifndef MX_PWM_8_PORT_A										//Error checking
			#error "This chip does not have PWM alt channel 8 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_8_PORT_A, MX_PWM_8_TRIS_A, MX_PWM_8_PIN_A);		//PWM pin is an output
		#endif

		ccp8con = 0x0C;													//Enable Capture Compare Channel 8 *****************************************************************
	#endif

	#if (MX_PWM_CHANNEL_X == 9)
		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
		  #ifndef MX_PWM_9_PORT											//Error checking
			#error "This chip does not have PWM channel 9 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_9_PORT, MX_PWM_9_TRIS, MX_PWM_9_PIN);			//PWM pin is an output
		#else															//Alternate PWM Pin
		  #ifndef MX_PWM_9_PORT_A										//Error checking
			#error "This chip does not have PWM alt channel 9 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_9_PORT_A, MX_PWM_9_TRIS_A, MX_PWM_9_PIN_A);		//PWM pin is an output
		#endif

		ccp9con = 0x0C;													//Enable Capture Compare Channel 9 *****************************************************************
	#endif

	#if (MX_PWM_CHANNEL_X == 10)
		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
		  #ifndef MX_PWM_10_PORT											//Error checking
			#error "This chip does not have PWM channel 10 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_10_PORT, MX_PWM_10_TRIS, MX_PWM_10_PIN);			//PWM pin is an output
		#else															//Alternate PWM Pin
		  #ifndef MX_PWM_10_PORT_A										//Error checking
			#error "This chip does not have PWM alt channel 10 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_10_PORT_A, MX_PWM_10_TRIS_A, MX_PWM_10_PIN_A);		//PWM pin is an output
		#endif

		ccp10con = 0x0C;												//Enable Capture Compare Channel 10 *****************************************************************
	#endif

 #else
 	#error "Hardware PWM not supported by Target microcontroller."
 #endif

}
02AB  0008  	RETURN



CALFUNCTION(void, FC_CAL_PWM_Disable_Channel_, (void))
{
	#if (MX_PWM_CHANNEL_X == 1)
		ccp1con = 0x00;													//Disable Capture Compare Channel 1
		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_1_PORT, MX_PWM_1_TRIS, MX_PWM_1_PIN);			//PWM pin is an input
		#else															//Alternate PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_1_PORT_A, MX_PWM_1_TRIS_A, MX_PWM_1_PIN_A);		//PWM pin is an input
		#endif
	#endif

	#if (MX_PWM_CHANNEL_X == 2)
		ccp2con = 0x00;													//Disable Capture Compare Channel 2
		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_2_PORT, MX_PWM_2_TRIS, MX_PWM_2_PIN);			//PWM pin is an input
		#else															//Alternate PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_2_PORT_A, MX_PWM_2_TRIS_A, MX_PWM_2_PIN_A);		//PWM pin is an input
		#endif
	#endif

	#if (MX_PWM_CHANNEL_X == 3)
		ccp3con = 0x00;													//Disable Capture Compare Channel 3
		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_3_PORT, MX_PWM_3_TRIS, MX_PWM_3_PIN);			//PWM pin is an input
		#else															//Alternate PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_3_PORT_A, MX_PWM_3_TRIS_A, MX_PWM_3_PIN_A);		//PWM pin is an input
		#endif
	#endif

	#if (MX_PWM_CHANNEL_X == 4)
		ccp4con = 0x00;													//Disable Capture Compare Channel 4
		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_4_PORT, MX_PWM_4_TRIS, MX_PWM_4_PIN);			//PWM pin is an input
		#else															//Alternate PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_4_PORT_A, MX_PWM_4_TRIS_A, MX_PWM_4_PIN_A);		//PWM pin is an input
		#endif
	#endif

	#if (MX_PWM_CHANNEL_X == 5)
		ccp5con = 0x00;													//Disable Capture Compare Channel 5
		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_5_PORT, MX_PWM_5_TRIS, MX_PWM_5_PIN);			//PWM pin is an input
		#else															//Alternate PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_5_PORT_A, MX_PWM_5_TRIS_A, MX_PWM_5_PIN_A);		//PWM pin is an input
		#endif
	#endif

	#if (MX_PWM_CHANNEL_X == 6)
		ccp6con = 0x00;													//Disable Capture Compare Channel 6
		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_6_PORT, MX_PWM_6_TRIS, MX_PWM_6_PIN);			//PWM pin is an input
		#else															//Alternate PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_6_PORT_A, MX_PWM_6_TRIS_A, MX_PWM_6_PIN_A);		//PWM pin is an input
		#endif
	#endif

	#if (MX_PWM_CHANNEL_X == 7)
		ccp7con = 0x00;													//Disable Capture Compare Channel 7
		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_7_PORT, MX_PWM_7_TRIS, MX_PWM_7_PIN);			//PWM pin is an input
		#else															//Alternate PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_7_PORT_A, MX_PWM_7_TRIS_A, MX_PWM_7_PIN_A);		//PWM pin is an input
		#endif
	#endif

	#if (MX_PWM_CHANNEL_X == 8)
		ccp8con = 0x00;													//Disable Capture Compare Channel 8
		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_8_PORT, MX_PWM_8_TRIS, MX_PWM_8_PIN);			//PWM pin is an input
		#else															//Alternate PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_8_PORT_A, MX_PWM_8_TRIS_A, MX_PWM_8_PIN_A);		//PWM pin is an input
		#endif
	#endif

	#if (MX_PWM_CHANNEL_X == 9)
		ccp9con = 0x00;													//Disable Capture Compare Channel 9
		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_9_PORT, MX_PWM_9_TRIS, MX_PWM_9_PIN);			//PWM pin is an input
		#else															//Alternate PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_9_PORT_A, MX_PWM_9_TRIS_A, MX_PWM_9_PIN_A);		//PWM pin is an input
		#endif
	#endif

	#if (MX_PWM_CHANNEL_X == 10)
		ccp10con = 0x00;												//Disable Capture Compare Channel 10
		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_10_PORT, MX_PWM_10_TRIS, MX_PWM_10_PIN);			//PWM pin is an input
		#else															//Alternate PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_10_PORT_A, MX_PWM_10_TRIS_A, MX_PWM_10_PIN_A);		//PWM pin is an input
		#endif
	#endif
}


CALFUNCTION(void, FC_CAL_PWM_Set_Duty_8Bit_, (MX_UINT8 duty))

{
	#if (MX_PWM_CHANNEL_X == 1)
		ccpr1l = duty;													//Update Capture Compare Count 1
	#endif

	#if (MX_PWM_CHANNEL_X == 2)
		ccpr2l = duty;													//Update Capture Compare Count 2
002B  087E  	MOVF FC_CAL_PWM_0006B_arg_duty, W
002C  009B  	MOVWF gbl_ccpr2l

	#endif

	#if (MX_PWM_CHANNEL_X == 3)
		ccpr3l = duty;													//Update Capture Compare Count 3
	#endif

	#if (MX_PWM_CHANNEL_X == 4)
		ccpr4l = duty;													//Update Capture Compare Count 4
	#endif

	#if (MX_PWM_CHANNEL_X == 5)
		ccpr5l = duty;													//Update Capture Compare Count 5
	#endif

	#if (MX_PWM_CHANNEL_X == 6)
		ccpr6l = duty;													//Update Capture Compare Count 6
	#endif

	#if (MX_PWM_CHANNEL_X == 7)
		ccpr7l = duty;													//Update Capture Compare Count 7
	#endif

	#if (MX_PWM_CHANNEL_X == 8)
		ccpr8l = duty;													//Update Capture Compare Count 8
	#endif

	#if (MX_PWM_CHANNEL_X == 9)
		ccpr9l = duty;													//Update Capture Compare Count 9
	#endif

	#if (MX_PWM_CHANNEL_X == 10)
		ccpr10l = duty;													//Update Capture Compare Count 10
	#endif
}
002D  0008  	RETURN



CALFUNCTION(void, FC_CAL_PWM_Change_Period_, (MX_UINT8 period, MX_UINT16 prescaler))

{
  #ifdef MX_PWM								//Hardware Mode
	pr2 = period;
0284  0875  	MOVF FC_CAL_PWM_0006C_arg_period, W
0285  1683  	BSF STATUS, RP0
0286  0092  	MOVWF gbl_pr2

	switch (prescaler)
	{
	  #ifdef MX_PWM_PSCA1
		case 1:
0287  3001  	MOVLW 0x01
0288  1283  	BCF STATUS, RP0
0289  0676  	XORWF FC_CAL_PWM_0006C_arg_prescaler, W
028A  1903  	BTFSC STATUS,Z
028B  0877  	MOVF FC_CAL_PWM_0006C_arg_prescaler+D'1', W
028C  1903  	BTFSC STATUS,Z
028D  2A9B  	GOTO	label34
029B        label34

			t2con = 0x04;
029B  3004  	MOVLW 0x04
029C  0092  	MOVWF gbl_t2con

			break;
	  #endif
	  #ifdef MX_PWM_PSCA4
		case 4:
028E  3004  	MOVLW 0x04
028F  0676  	XORWF FC_CAL_PWM_0006C_arg_prescaler, W
0290  1903  	BTFSC STATUS,Z
0291  0877  	MOVF FC_CAL_PWM_0006C_arg_prescaler+D'1', W
0292  1903  	BTFSC STATUS,Z
0293  2A9E  	GOTO	label35
029E        label35

			t2con = 0x05;
029E  3005  	MOVLW 0x05
029F  0092  	MOVWF gbl_t2con

			break;
	  #endif
	  #ifdef MX_PWM_PSCA16
		case 16:
0294  3010  	MOVLW 0x10
0295  0676  	XORWF FC_CAL_PWM_0006C_arg_prescaler, W
0296  1903  	BTFSC STATUS,Z
0297  0877  	MOVF FC_CAL_PWM_0006C_arg_prescaler+D'1', W
0298  1903  	BTFSC STATUS,Z
0299  2AA1  	GOTO	label36
02A1        label36

			t2con = 0x06;
02A1  3006  	MOVLW 0x06
02A2  0092  	MOVWF gbl_t2con

			break;
	  #endif
	  #ifdef MX_PWM_PSCA64
		case 64:
			t2con = 0x07;					//Note some earlier devices do not have the /64 option
			break;
	  #endif
	}
  #endif
}
029A  0008  	RETURN
029D  0008  	RETURN
02A0  0008  	RETURN
02A3  0008  	RETURN



CALFUNCTION(void, FC_CAL_PWM_Set_Duty_10Bit_, (MX_UINT16 duty))
{
	char nCCPxCONtemp;

	#if (MX_PWM_CHANNEL_X == 1)
		ccpr1l = (duty & 0x3FC) >> 2;									//Update Capture Compare Count 1
		duty = (duty & 0x03) << 4;
		nCCPxCONtemp = (ccp1con & 0xCF) | duty;
		ccp1con = nCCPxCONtemp;
	#endif

	#if (MX_PWM_CHANNEL_X == 2)
		ccpr2l = (duty & 0x3FC) >> 2;									//Update Capture Compare Count 2
		duty = (duty & 0x03) << 4;
		nCCPxCONtemp = (ccp2con & 0xCF) | duty;
		ccp2con = nCCPxCONtemp;
	#endif

	#if (MX_PWM_CHANNEL_X == 3)
		ccpr3l = (duty & 0x3FC) >> 2;									//Update Capture Compare Count 3
		duty = (duty & 0x03) << 4;
		nCCPxCONtemp = (ccp3con & 0xCF) | duty;
		ccp3con = nCCPxCONtemp;
	#endif

	#if (MX_PWM_CHANNEL_X == 4)
		ccpr4l = (duty & 0x3FC) >> 2;									//Update Capture Compare Count 4
		duty = (duty & 0x03) << 4;
		nCCPxCONtemp = (ccp4con & 0xCF) | duty;
		ccp4con = nCCPxCONtemp;
	#endif

	#if (MX_PWM_CHANNEL_X == 5)
		ccpr5l = (duty & 0x3FC) >> 2;									//Update Capture Compare Count 5
		duty = (duty & 0x03) << 4;
		nCCPxCONtemp = (ccp5con & 0xCF) | duty;
		ccp5con = nCCPxCONtemp;
	#endif

	#if (MX_PWM_CHANNEL_X == 6)
		ccpr6l = (duty & 0x3FC) >> 2;									//Update Capture Compare Count 6
		duty = (duty & 0x03) << 4;
		nCCPxCONtemp = (ccp6con & 0xCF) | duty;
		ccp6con = nCCPxCONtemp;
	#endif

	#if (MX_PWM_CHANNEL_X == 7)
		ccpr7l = (duty & 0x3FC) >> 2;									//Update Capture Compare Count 7
		duty = (duty & 0x03) << 4;
		nCCPxCONtemp = (ccp7con & 0xCF) | duty;
		ccp7con = nCCPxCONtemp;
	#endif

	#if (MX_PWM_CHANNEL_X == 8)
		ccpr8l = (duty & 0x3FC) >> 2;									//Update Capture Compare Count 8
		duty = (duty & 0x03) << 4;
		nCCPxCONtemp = (ccp8con & 0xCF) | duty;
		ccp8con = nCCPxCONtemp;
	#endif

	#if (MX_PWM_CHANNEL_X == 9)
		ccpr9l = (duty & 0x3FC) >> 2;									//Update Capture Compare Count 9
		duty = (duty & 0x03) << 4;
		nCCPxCONtemp = (ccp9con & 0xCF) | duty;
		ccp9con = nCCPxCONtemp;
	#endif

	#if (MX_PWM_CHANNEL_X == 10)
		ccpr10l = (duty & 0x3FC) >> 2;									//Update Capture Compare Count 10
		duty = (duty & 0x03) << 4;
		nCCPxCONtemp = (ccp10con & 0xCF) | duty;
		ccp10con = nCCPxCONtemp;
	#endif
}


////////////////////////////////////////
// Code with no source :-)
////////////////////////////////////////
0000  158A  	BSF PCLATH,3
0001  2844  	GOTO	_startup

0004  00FF  	MOVWF Int1Context
0005  0E03  	SWAPF STATUS, W
0006  1283  	BCF STATUS, RP0
0007  1303  	BCF STATUS, RP1
0008  00BC  	MOVWF Int1BContext
0009  0E0A  	SWAPF PCLATH, W
000A  00BD  	MOVWF Int1BContext+D'1'
000B  0E04  	SWAPF FSR, W
000C  00BE  	MOVWF Int1BContext+D'2'
000D  158A  	BSF PCLATH,3
000E  120A  	BCF PCLATH,4
000F  2894  	GOTO	interrupt
0010        delay_ms_00000
0010        ; { delay_ms ; function begin
0010  08FD  	MOVF delay_ms_00000_arg_del, F
0011  1D03  	BTFSS STATUS,Z
0012  2814  	GOTO	label1
0013  0008  	RETURN
0014        label1
0014  30CC  	MOVLW 0xCC
0015        label2
0015  3EFF  	ADDLW 0xFF
0016  1D03  	BTFSS STATUS,Z
0017  2815  	GOTO	label2
0018  0000  	NOP
0019  0BFD  	DECFSZ delay_ms_00000_arg_del, F
001A  2814  	GOTO	label1
001B  0008  	RETURN
001C        ; } delay_ms function end

001C        delay_s_00000
001C        ; { delay_s ; function begin
001C        label3
001C  30FA  	MOVLW 0xFA
001D  00FD  	MOVWF delay_ms_00000_arg_del
001E  2010  	CALL delay_ms_00000
001F  30FA  	MOVLW 0xFA
0020  00FD  	MOVWF delay_ms_00000_arg_del
0021  2010  	CALL delay_ms_00000
0022  30FA  	MOVLW 0xFA
0023  00FD  	MOVWF delay_ms_00000_arg_del
0024  2010  	CALL delay_ms_00000
0025  30FA  	MOVLW 0xFA
0026  00FD  	MOVWF delay_ms_00000_arg_del
0027  2010  	CALL delay_ms_00000
0028  0BF9  	DECFSZ delay_s_00000_arg_del, F
0029  281C  	GOTO	label3
002A  0008  	RETURN
002B        ; } delay_s function end


0130        __rem_32_3_00002
0130        ; { __rem_32_32 ; function begin
0130  01AD  	CLRF CompTempVarRet212
0131  01AE  	CLRF CompTempVarRet212+D'1'
0132  01AF  	CLRF CompTempVarRet212+D'2'
0133  01B0  	CLRF CompTempVarRet212+D'3'
0134  01A8  	CLRF __rem_32_3_00002_1_c
0135  01A9  	CLRF __rem_32_3_00002_1_c+D'1'
0136  01AA  	CLRF __rem_32_3_00002_1_c+D'2'
0137  01AB  	CLRF __rem_32_3_00002_1_c+D'3'
0138  01AC  	CLRF __rem_32_3_00002_1_i
0139        label13
0139  1AAC  	BTFSC __rem_32_3_00002_1_i,5
013A  0008  	RETURN
013B  1003  	BCF STATUS,C
013C  0DA8  	RLF __rem_32_3_00002_1_c, F
013D  0DA9  	RLF __rem_32_3_00002_1_c+D'1', F
013E  0DAA  	RLF __rem_32_3_00002_1_c+D'2', F
013F  0DAB  	RLF __rem_32_3_00002_1_c+D'3', F
0140  0DA0  	RLF __rem_32_3_00002_arg_a, F
0141  0DA1  	RLF __rem_32_3_00002_arg_a+D'1', F
0142  0DA2  	RLF __rem_32_3_00002_arg_a+D'2', F
0143  0DA3  	RLF __rem_32_3_00002_arg_a+D'3', F
0144  0DAD  	RLF CompTempVarRet212, F
0145  0DAE  	RLF CompTempVarRet212+D'1', F
0146  0DAF  	RLF CompTempVarRet212+D'2', F
0147  0DB0  	RLF CompTempVarRet212+D'3', F
0148  0827  	MOVF __rem_32_3_00002_arg_b+D'3', W
0149  0230  	SUBWF CompTempVarRet212+D'3', W
014A  1D03  	BTFSS STATUS,Z
014B  2956  	GOTO	label14
014C  0826  	MOVF __rem_32_3_00002_arg_b+D'2', W
014D  022F  	SUBWF CompTempVarRet212+D'2', W
014E  1D03  	BTFSS STATUS,Z
014F  2956  	GOTO	label14
0150  0825  	MOVF __rem_32_3_00002_arg_b+D'1', W
0151  022E  	SUBWF CompTempVarRet212+D'1', W
0152  1D03  	BTFSS STATUS,Z
0153  2956  	GOTO	label14
0154  0824  	MOVF __rem_32_3_00002_arg_b, W
0155  022D  	SUBWF CompTempVarRet212, W
0156        label14
0156  1C03  	BTFSS STATUS,C
0157  2967  	GOTO	label15
0158  0824  	MOVF __rem_32_3_00002_arg_b, W
0159  02AD  	SUBWF CompTempVarRet212, F
015A  0825  	MOVF __rem_32_3_00002_arg_b+D'1', W
015B  1C03  	BTFSS STATUS,C
015C  0F25  	INCFSZ __rem_32_3_00002_arg_b+D'1', W
015D  02AE  	SUBWF CompTempVarRet212+D'1', F
015E  0826  	MOVF __rem_32_3_00002_arg_b+D'2', W
015F  1C03  	BTFSS STATUS,C
0160  0F26  	INCFSZ __rem_32_3_00002_arg_b+D'2', W
0161  02AF  	SUBWF CompTempVarRet212+D'2', F
0162  0827  	MOVF __rem_32_3_00002_arg_b+D'3', W
0163  1C03  	BTFSS STATUS,C
0164  0F27  	INCFSZ __rem_32_3_00002_arg_b+D'3', W
0165  02B0  	SUBWF CompTempVarRet212+D'3', F
0166  1428  	BSF __rem_32_3_00002_1_c,0
0167        label15
0167  0AAC  	INCF __rem_32_3_00002_1_i, F
0168  2939  	GOTO	label13
0169        ; } __rem_32_32 function end

0169        __div_8_8_00000
0169        ; { __div_8_8 ; function begin
0169  01F9  	CLRF __div_8_8_00000_1_r
016A  01FB  	CLRF CompTempVarRet218
016B  01FA  	CLRF __div_8_8_00000_1_i
016C        label16
016C  19FA  	BTFSC __div_8_8_00000_1_i,3
016D  0008  	RETURN
016E  1003  	BCF STATUS,C
016F  0DFB  	RLF CompTempVarRet218, F
0170  0DF7  	RLF __div_8_8_00000_arg_a, F
0171  0DF9  	RLF __div_8_8_00000_1_r, F
0172  0878  	MOVF __div_8_8_00000_arg_b, W
0173  0279  	SUBWF __div_8_8_00000_1_r, W
0174  1C03  	BTFSS STATUS,C
0175  2978  	GOTO	label17
0176  00F9  	MOVWF __div_8_8_00000_1_r
0177  147B  	BSF CompTempVarRet218,0
0178        label17
0178  0AFA  	INCF __div_8_8_00000_1_i, F
0179  296C  	GOTO	label16
017A        ; } __div_8_8 function end

017A        __div_32_3_00001
017A        ; { __div_32_32 ; function begin
017A  01AC  	CLRF __div_32_3_00001_1_r
017B  01AD  	CLRF __div_32_3_00001_1_r+D'1'
017C  01AE  	CLRF __div_32_3_00001_1_r+D'2'
017D  01AF  	CLRF __div_32_3_00001_1_r+D'3'
017E  01B1  	CLRF CompTempVarRet210
017F  01B2  	CLRF CompTempVarRet210+D'1'
0180  01B3  	CLRF CompTempVarRet210+D'2'
0181  01B4  	CLRF CompTempVarRet210+D'3'
0182  01B0  	CLRF __div_32_3_00001_1_i
0183        label18
0183  1AB0  	BTFSC __div_32_3_00001_1_i,5
0184  0008  	RETURN
0185  1003  	BCF STATUS,C
0186  0DB1  	RLF CompTempVarRet210, F
0187  0DB2  	RLF CompTempVarRet210+D'1', F
0188  0DB3  	RLF CompTempVarRet210+D'2', F
0189  0DB4  	RLF CompTempVarRet210+D'3', F
018A  0DA0  	RLF __div_32_3_00001_arg_a, F
018B  0DA1  	RLF __div_32_3_00001_arg_a+D'1', F
018C  0DA2  	RLF __div_32_3_00001_arg_a+D'2', F
018D  0DA3  	RLF __div_32_3_00001_arg_a+D'3', F
018E  0DAC  	RLF __div_32_3_00001_1_r, F
018F  0DAD  	RLF __div_32_3_00001_1_r+D'1', F
0190  0DAE  	RLF __div_32_3_00001_1_r+D'2', F
0191  0DAF  	RLF __div_32_3_00001_1_r+D'3', F
0192  0827  	MOVF __div_32_3_00001_arg_b+D'3', W
0193  022F  	SUBWF __div_32_3_00001_1_r+D'3', W
0194  1D03  	BTFSS STATUS,Z
0195  29A0  	GOTO	label19
0196  0826  	MOVF __div_32_3_00001_arg_b+D'2', W
0197  022E  	SUBWF __div_32_3_00001_1_r+D'2', W
0198  1D03  	BTFSS STATUS,Z
0199  29A0  	GOTO	label19
019A  0825  	MOVF __div_32_3_00001_arg_b+D'1', W
019B  022D  	SUBWF __div_32_3_00001_1_r+D'1', W
019C  1D03  	BTFSS STATUS,Z
019D  29A0  	GOTO	label19
019E  0824  	MOVF __div_32_3_00001_arg_b, W
019F  022C  	SUBWF __div_32_3_00001_1_r, W
01A0        label19
01A0  1C03  	BTFSS STATUS,C
01A1  29B1  	GOTO	label20
01A2  0824  	MOVF __div_32_3_00001_arg_b, W
01A3  02AC  	SUBWF __div_32_3_00001_1_r, F
01A4  0825  	MOVF __div_32_3_00001_arg_b+D'1', W
01A5  1C03  	BTFSS STATUS,C
01A6  0F25  	INCFSZ __div_32_3_00001_arg_b+D'1', W
01A7  02AD  	SUBWF __div_32_3_00001_1_r+D'1', F
01A8  0826  	MOVF __div_32_3_00001_arg_b+D'2', W
01A9  1C03  	BTFSS STATUS,C
01AA  0F26  	INCFSZ __div_32_3_00001_arg_b+D'2', W
01AB  02AE  	SUBWF __div_32_3_00001_1_r+D'2', F
01AC  0827  	MOVF __div_32_3_00001_arg_b+D'3', W
01AD  1C03  	BTFSS STATUS,C
01AE  0F27  	INCFSZ __div_32_3_00001_arg_b+D'3', W
01AF  02AF  	SUBWF __div_32_3_00001_1_r+D'3', F
01B0  1431  	BSF CompTempVarRet210,0
01B1        label20
01B1  0AB0  	INCF __div_32_3_00001_1_i, F
01B2  2983  	GOTO	label18
01B3        ; } __div_32_32 function end


0844        _startup
0844  30D5  	MOVLW 0xD5
0845  1283  	BCF STATUS, RP0
0846  1303  	BCF STATUS, RP1
0847  00A0  	MOVWF gbl_14_LSR
0848  30C4  	MOVLW 0xC4
0849  00A1  	MOVWF gbl_14_LSR+D'1'
084A  30BB  	MOVLW 0xBB
084B  00A2  	MOVWF gbl_14_LSR+D'2'
084C  30DC  	MOVLW 0xDC
084D  00A3  	MOVWF gbl_14_LSR+D'3'
084E  01A4  	CLRF gbl_15_gbl_aSig
084F  01A5  	CLRF gbl_15_gbl_aSig+D'1'
0850  01A6  	CLRF gbl_15_gbl_aSig+D'2'
0851  01A7  	CLRF gbl_15_gbl_aSig+D'3'
0852  01A8  	CLRF gbl_15_gbl_bSig
0853  01A9  	CLRF gbl_15_gbl_bSig+D'1'
0854  01AA  	CLRF gbl_15_gbl_bSig+D'2'
0855  01AB  	CLRF gbl_15_gbl_bSig+D'3'
0856  01AC  	CLRF gbl_15_gbl_zSig
0857  01AD  	CLRF gbl_15_gbl_zSig+D'1'
0858  01AE  	CLRF gbl_15_gbl_zSig+D'2'
0859  01AF  	CLRF gbl_15_gbl_zSig+D'3'
085A  01CC  	CLRF gbl_15_gbl_aExp
085B  01CD  	CLRF gbl_15_gbl_bExp
085C  01BF  	CLRF gbl_15_gbl_zExp
085D  01C0  	CLRF gbl_15_gbl_zExp+D'1'
085E  01CE  	CLRF gbl_15_gbl_aSign
085F  01CF  	CLRF gbl_15_gbl_bSign
0860  01D0  	CLRF gbl_15_gbl_zSign
0861  01D1  	CLRF gbl_15_gbl_zSigZero
0862  01B0  	CLRF gbl_15_gbl_ret
0863  01B1  	CLRF gbl_15_gbl_ret+D'1'
0864  01B2  	CLRF gbl_15_gbl_ret+D'2'
0865  01B3  	CLRF gbl_15_gbl_ret+D'3'
0866  01CA  	CLRF gbl_float_rounding_mode
0867  01CB  	CLRF gbl_float_exception_flags
0868  01C9  	CLRF gbl_float_detect_tininess

0891  118A  	BCF PCLATH,3
0892  120A  	BCF PCLATH,4
0893  2EF5  	GOTO	main

2007  1F32  	DW 0x1F32
