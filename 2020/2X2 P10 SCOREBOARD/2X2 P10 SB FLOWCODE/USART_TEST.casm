;/////////////////////////////////////////////////////////////////////////////////
;// Code Generator: BoostC Compiler - http://www.sourceboost.com
;// Version       : 7.03
;// License Type  : Pro License
;// Limitations   : PIC12,PIC16 max code size:Unlimited, max RAM banks:Unlimited
;/////////////////////////////////////////////////////////////////////////////////

//************************************************************************************
//**  
//**  File name:     C:\Users\gerpe\OneDrive\GER-PER 2016\Documents\KennyNeutron\2020\2X2 P10 SCOREBOARD\2X2 P10 SB FLOWCODE\USART_TEST.c
//**  Title:         
//**  Description:   
//**  
//**  Generated by:  Flowcode v5.2.0.0
//**  Date:          Saturday, March 07, 2020 10:33:42
//**  Licence:       Professional
//**  Registered to: xyz
//**  Licence key:   WUK7B9
//**  
//**  
//**  http://www.matrixmultimedia.com
//**  
//************************************************************************************


#define MX_PIC

#define MX_USES_UINT8 1
#define MX_USES_SINT16 0
#define MX_USES_CHAR 0
#define MX_USES_FLOAT 0
#define MX_USES_SINT32 0
#define MX_USES_BOOL 1
#define MX_USES_UINT16 0
#define MX_USES_UINT32 0
//Defines for microcontroller
#define P16F690
#define FC_CAL_PIC
#define MX_ADC
#define MX_ADC_TYPE_3
#define MX_ADC_BITS_10
#define MX_EE
#define MX_EE_TYPE2
#define MX_EE_SIZE 256
#define MX_SPI_1
#define MX_SPI_1_MISO_PORT portb
#define MX_SPI_1_MISO_TRIS trisb
#define MX_SPI_1_MISO_PIN 4
#define MX_SPI_1_MOSI_PORT portc
#define MX_SPI_1_MOSI_TRIS trisc
#define MX_SPI_1_MOSI_PIN 7
#define MX_SPI_1_CLK_PORT portb
#define MX_SPI_1_CLK_TRIS trisb
#define MX_SPI_1_CLK_PIN 6
#define MX_SPI_1_SS_PORT portb
#define MX_SPI_1_SS_TRIS trisb
#define MX_UART_1
#define MX_UART_1_TX_PORT portb
#define MX_UART_1_TX_TRIS trisb
#define MX_UART_1_TX_PIN 7
#define MX_UART_1_RX_PORT portb
#define MX_UART_1_RX_TRIS trisb
#define MX_UART_1_RX_PIN 5
#define MX_I2C
#define MX_MI2C
#define MX_I2C_1
#define MX_I2C_1_SDA_PORT portb
#define MX_I2C_1_SDA_TRIS trisb
#define MX_I2C_1_SDA_PIN 4
#define MX_I2C_1_SCL_PORT portb
#define MX_I2C_1_SCL_TRIS trisb
#define MX_I2C_1_SCL_PIN 6
#define MX_PWM
#define MX_PWM_CNT 1
#define MX_PWM_PSCA1
#define MX_PWM_PSCA4
#define MX_PWM_PSCA16
#define MX_PWM_1_PORT portc
#define MX_PWM_1_TRIS trisc
#define MX_PWM_1_PIN 5

//Functions
#define MX_CLK_SPEED 3276800
#ifdef _BOOSTC
#include <system.h>
#endif
#ifdef HI_TECH_C
#include <pic.h>
#endif

//Configuration data
#ifdef _BOOSTC
#pragma DATA 0x2007, 0x30d2
#endif
#ifdef HI_TECH_C
__CONFIG(0x30d2);
#endif

//Internal functions
#include "C:\Program Files (x86)\Flowcode\v5\FCD\internals.c"

//Macro function declarations
void FCM_SENDDATA();


//Variable declarations
#define FCV_FALSE (0)
#define FCV_TRUE (1)
MX_UINT8 FCV_HS_T = (0x0);
00E4  01C2  	CLRF gbl_FCV_HS_T

MX_UINT8 FCV_GS_T = (0x0);
00E5  01C3  	CLRF gbl_FCV_GS_T

MX_UINT8 FCV_PERIOD = (0x0);
00E6  01C4  	CLRF gbl_FCV_PERIOD

MX_UINT8 FCV_TO_G = (0x0);
00E7  01C5  	CLRF gbl_FCV_TO_G

MX_UINT8 FCV_HS_H = (0x0);
00E8  01C6  	CLRF gbl_FCV_HS_H

MX_UINT8 FCV_SC_MSEC = (0x0);
00E9  01C7  	CLRF gbl_FCV_SC_MSEC

MX_UINT8 FCV_GTS_ONES = (0x0);
00EA  01C8  	CLRF gbl_FCV_GTS_ONES

MX_UINT8 FCV_GTM_TENS = (0x0);
00EB  01C9  	CLRF gbl_FCV_GTM_TENS

MX_UINT8 FCV_TO_H = (0x0);
00EC  01CA  	CLRF gbl_FCV_TO_H

MX_UINT8 FCV_GS_H = (0x0);
00ED  01CB  	CLRF gbl_FCV_GS_H

MX_UINT8 FCV_SC_TENS = (0x0);
00EE  01CC  	CLRF gbl_FCV_SC_TENS

MX_UINT8 FCV_FOOTER = (0x0);
00EF  01CD  	CLRF gbl_FCV_FOOTER

MX_UINT8 FCV_FOUL_G = (0x0);
00F0  01CE  	CLRF gbl_FCV_FOUL_G

MX_UINT8 FCV_FOUL_H = (0x0);
00F1  01CF  	CLRF gbl_FCV_FOUL_H

MX_UINT8 FCV_GTM_ONES = (0x0);
00F2  01D0  	CLRF gbl_FCV_GTM_ONES

MX_UINT8 FCV_HS_O;
MX_UINT8 FCV_GS_O = (0x0);
00F3  01D2  	CLRF gbl_FCV_GS_O

MX_UINT8 FCV_HEADER0 = (0x0);
00F4  01D3  	CLRF gbl_FCV_HEADER0

MX_UINT8 FCV_GT_MSEC = (0x0);
00F5  01D4  	CLRF gbl_FCV_GT_MSEC

MX_UINT8 FCV_SC_ONES = (0x0);
00F6  01D5  	CLRF gbl_FCV_SC_ONES

MX_UINT8 FCV_HEADER1 = (0x0);
00F7  01D6  	CLRF gbl_FCV_HEADER1

MX_UINT8 FCV_POS = (0x0);
00F8  01D7  	CLRF gbl_FCV_POS

MX_UINT8 FCV_GTS_TENS = (0x0);
00F9  01D8  	CLRF gbl_FCV_GTS_TENS





//RS232(0): //Defines:

/**** Macro Substitutions ****
a = Unique Reference
b = Uart Channel		(0-software / 1-4 hardware)
c = tx pin
d = tx port
e = rx pin
f = rx port
g = flow control		(0-Off / 1-On)
h = cts pin
i = cts port
j = rts pin
k = rts port
l = baud rate
m = data bits			(7/8/9) (7 only supported in software modes)
n = return type		(0-byte / 1-MX_UINT16)
o = echo enable		(0-Off / 1-On)
******************************/

//Definitions for RS232 UART slot allocation
#ifndef	MX_UART_REF1
	#define MX_UART_REF1
	#define RS232_1_MX_UART_UREF			1
	#define MX_UART_CHANNEL_1		1
	#define MX_UART_TX_PIN_1		0
	#define MX_UART_TX_PORT_1		porta
	#define MX_UART_TX_TRIS_1		trisa
	#define MX_UART_RX_PIN_1		0
	#define MX_UART_RX_PORT_1		porta
	#define MX_UART_RX_TRIS_1		trisa
	#define MX_UART_FLOWEN_1		0
	#define MX_UART_CTS_PIN_1		4
	#define MX_UART_CTS_PORT_1		portc
	#define MX_UART_CTS_TRIS_1		trisc
	#define MX_UART_RTS_PIN_1		0
	#define MX_UART_RTS_PORT_1		portc
	#define MX_UART_RTS_TRIS_1		trisc
	#define MX_UART_BAUD_1			9600
	#define MX_UART_DBITS_1			8
	#define MX_UART_RETURN_1		0
	#define MX_UART_ECHO_1			0
	#define MX_UART_INT_1			0
#else
 #ifndef	MX_UART_REF2
	#define MX_UART_REF2
	#define RS232_1_MX_UART_UREF			2
	#define MX_UART_CHANNEL_2		1
	#define MX_UART_TX_PIN_2		0
	#define MX_UART_TX_PORT_2		porta
	#define MX_UART_TX_TRIS_2		trisa
	#define MX_UART_RX_PIN_2		0
	#define MX_UART_RX_PORT_2		porta
	#define MX_UART_RX_TRIS_2		trisa
	#define MX_UART_FLOWEN_2		0
	#define MX_UART_CTS_PIN_2		4
	#define MX_UART_CTS_PORT_2		portc
	#define MX_UART_CTS_TRIS_2		trisc
	#define MX_UART_RTS_PIN_2		0
	#define MX_UART_RTS_PORT_2		portc
	#define MX_UART_RTS_TRIS_2		trisc
	#define MX_UART_BAUD_2			9600
	#define MX_UART_DBITS_2			8
	#define MX_UART_RETURN_2		0
	#define MX_UART_ECHO_2			0
	#define MX_UART_INT_2			0
 #else
  #ifndef	MX_UART_REF3
	#define MX_UART_REF3
	#define RS232_1_MX_UART_UREF			3
	#define MX_UART_CHANNEL_3		1
	#define MX_UART_TX_PIN_3		0
	#define MX_UART_TX_PORT_3		porta
	#define MX_UART_TX_TRIS_3		trisa
	#define MX_UART_RX_PIN_3		0
	#define MX_UART_RX_PORT_3		porta
	#define MX_UART_RX_TRIS_3		trisa
	#define MX_UART_FLOWEN_3		0
	#define MX_UART_CTS_PIN_3		4
	#define MX_UART_CTS_PORT_3		portc
	#define MX_UART_CTS_TRIS_3		trisc
	#define MX_UART_RTS_PIN_3		0
	#define MX_UART_RTS_PORT_3		portc
	#define MX_UART_RTS_TRIS_3		trisc
	#define MX_UART_BAUD_3			9600
	#define MX_UART_DBITS_3			8
	#define MX_UART_RETURN_3		0
	#define MX_UART_ECHO_3			0
	#define MX_UART_INT_3			0
  #else
   #ifndef	MX_UART_REF4
	#define MX_UART_REF4
	#define RS232_1_MX_UART_UREF			4
	#define MX_UART_CHANNEL_4		1
	#define MX_UART_TX_PIN_4		0
	#define MX_UART_TX_PORT_4		porta
	#define MX_UART_TX_TRIS_4		trisa
	#define MX_UART_RX_PIN_4		0
	#define MX_UART_RX_PORT_4		porta
	#define MX_UART_RX_TRIS_4		trisa
	#define MX_UART_FLOWEN_4		0
	#define MX_UART_CTS_PIN_4		4
	#define MX_UART_CTS_PORT_4		portc
	#define MX_UART_CTS_TRIS_4		trisc
	#define MX_UART_RTS_PIN_4		0
	#define MX_UART_RTS_PORT_4		portc
	#define MX_UART_RTS_TRIS_4		trisc
	#define MX_UART_BAUD_4			9600
	#define MX_UART_DBITS_4			8
	#define MX_UART_RETURN_4		0
	#define MX_UART_ECHO_4			0
	#define MX_UART_INT_4			0
   #endif
  #endif
 #endif
#endif

#define RS232_1_UART_Init		CAL_APPEND(FC_CAL_UART_Init_, RS232_1_MX_UART_UREF)
#define RS232_1_UART_Send		CAL_APPEND(FC_CAL_UART_Send_, RS232_1_MX_UART_UREF)
#define RS232_1_UART_Receive		CAL_APPEND(FC_CAL_UART_Receive_, RS232_1_MX_UART_UREF)
#define RS232_1_UART_Update_Baud CAL_APPEND(FC_CAL_UART_Update_Baud_, RS232_1_MX_UART_UREF)

extern void RS232_1_UART_Init();
extern void RS232_1_UART_Send(MX_UINT16 nChar);
extern MX_SINT16 RS232_1_UART_Receive(MX_UINT8 nTimeout);
extern void RS232_1_UART_Update_Baud(MX_UINT8 newbaud);




//RS232(0): //Macro function declarations

void FCD_RS2320_SendRS232Char(MX_SINT16 nChar);
void FCD_RS2320_SendRS232String(MX_STRING String, MX_UINT8 MSZ_String);
MX_SINT16 FCD_RS2320_ReceiveRS232Char(MX_UINT8 nTimeout);
void FCD_RS2320_ReceiveRS232String(MX_CHAR* FCR_RETVAL, MX_UINT8 FCR_RETVAL_SIZE, MX_UINT8 nTimeout, MX_UINT8 NumBytes);
void FCD_RS2320_ChangeHWBaud(MX_UINT8 newbaud);



//RS232(0): //Macro implementations


void FCD_RS2320_SendRS232Char(MX_SINT16 nChar)

{
	
		RS232_1_UART_Send ( nChar);
0015  0859  	MOVF FCD_RS2320_00052_arg_nChar, W
0016  00DB  	MOVWF FC_CAL_UAR_00054_arg_nChar
0017  085A  	MOVF FCD_RS2320_00052_arg_nChar+D'1', W
0018  00DC  	MOVWF FC_CAL_UAR_00054_arg_nChar+D'1'
0019  2010  	CALL FC_CAL_UAR_00054


}
001A  0008  	RETURN


void FCD_RS2320_SendRS232String(MX_STRING String, MX_UINT8 MSZ_String)
{
	
		MX_UINT8 idx;
		for(idx = 0; idx < MSZ_String; idx++)
		{
			if (String[idx] == 0)
				break;
			else RS232_1_UART_Send ( String[idx] );
		}

}

MX_SINT16 FCD_RS2320_ReceiveRS232Char(MX_UINT8 nTimeout)
{
	
		return ( RS232_1_UART_Receive ( nTimeout) );

}

void FCD_RS2320_ReceiveRS232String(MX_CHAR* FCR_RETVAL, MX_UINT8 FCR_RETVAL_SIZE, MX_UINT8 nTimeout, MX_UINT8 NumBytes)
{
	
		MX_UINT8 idx;
		MX_SINT16 RS232_TO = 255;
		MX_SINT16 in;

		if ( 0 != 0 )
			RS232_TO = 256;

		if (NumBytes > FCR_RETVAL_SIZE)
			NumBytes = FCR_RETVAL_SIZE;

		for (idx = 0; idx < NumBytes; idx++)
		{
			in = RS232_1_UART_Receive ( nTimeout);
			if(in < RS232_TO)
				FCR_RETVAL[idx] = in & 0xFF;
			else
				break;
		}

		if (idx < FCR_RETVAL_SIZE)
			FCR_RETVAL[idx] = 0;

}

void FCD_RS2320_ChangeHWBaud(MX_UINT8 newbaud)
{
	
		RS232_1_UART_Update_Baud (newbaud);

}

#include "C:\Program Files (x86)\Flowcode\v5\CAL\includes.c"

//Macro implementations


void FCM_SENDDATA()

{

	//Call Component Macro
	//Call Component Macro: SendRS232Char(HEADER0)
	FCD_RS2320_SendRS232Char(FCV_HEADER0);
002A  1283  	BCF STATUS, RP0
002B  1303  	BCF STATUS, RP1
002C  0853  	MOVF gbl_FCV_HEADER0, W
002D  00D9  	MOVWF FCD_RS2320_00052_arg_nChar
002E  01DA  	CLRF FCD_RS2320_00052_arg_nChar+D'1'
002F  2015  	CALL FCD_RS2320_00052


	//Call Component Macro
	//Call Component Macro: SendRS232Char(HEADER1)
	FCD_RS2320_SendRS232Char(FCV_HEADER1);
0030  0856  	MOVF gbl_FCV_HEADER1, W
0031  00D9  	MOVWF FCD_RS2320_00052_arg_nChar
0032  01DA  	CLRF FCD_RS2320_00052_arg_nChar+D'1'
0033  2015  	CALL FCD_RS2320_00052


	//Call Component Macro
	//Call Component Macro: SendRS232Char(SC_TENS)
	FCD_RS2320_SendRS232Char(FCV_SC_TENS);
0034  084C  	MOVF gbl_FCV_SC_TENS, W
0035  00D9  	MOVWF FCD_RS2320_00052_arg_nChar
0036  01DA  	CLRF FCD_RS2320_00052_arg_nChar+D'1'
0037  2015  	CALL FCD_RS2320_00052


	//Call Component Macro
	//Call Component Macro: SendRS232Char(SC_ONES)
	FCD_RS2320_SendRS232Char(FCV_SC_ONES);
0038  0855  	MOVF gbl_FCV_SC_ONES, W
0039  00D9  	MOVWF FCD_RS2320_00052_arg_nChar
003A  01DA  	CLRF FCD_RS2320_00052_arg_nChar+D'1'
003B  2015  	CALL FCD_RS2320_00052


	//Call Component Macro
	//Call Component Macro: SendRS232Char(SC_MSEC)
	FCD_RS2320_SendRS232Char(FCV_SC_MSEC);
003C  0847  	MOVF gbl_FCV_SC_MSEC, W
003D  00D9  	MOVWF FCD_RS2320_00052_arg_nChar
003E  01DA  	CLRF FCD_RS2320_00052_arg_nChar+D'1'
003F  2015  	CALL FCD_RS2320_00052


	//Call Component Macro
	//Call Component Macro: SendRS232Char(GTM_TENS)
	FCD_RS2320_SendRS232Char(FCV_GTM_TENS);
0040  0849  	MOVF gbl_FCV_GTM_TENS, W
0041  00D9  	MOVWF FCD_RS2320_00052_arg_nChar
0042  01DA  	CLRF FCD_RS2320_00052_arg_nChar+D'1'
0043  2015  	CALL FCD_RS2320_00052


	//Call Component Macro
	//Call Component Macro: SendRS232Char(GTM_ONES)
	FCD_RS2320_SendRS232Char(FCV_GTM_ONES);
0044  0850  	MOVF gbl_FCV_GTM_ONES, W
0045  00D9  	MOVWF FCD_RS2320_00052_arg_nChar
0046  01DA  	CLRF FCD_RS2320_00052_arg_nChar+D'1'
0047  2015  	CALL FCD_RS2320_00052


	//Call Component Macro
	//Call Component Macro: SendRS232Char(GTS_TENS)
	FCD_RS2320_SendRS232Char(FCV_GTS_TENS);
0048  0858  	MOVF gbl_FCV_GTS_TENS, W
0049  00D9  	MOVWF FCD_RS2320_00052_arg_nChar
004A  01DA  	CLRF FCD_RS2320_00052_arg_nChar+D'1'
004B  2015  	CALL FCD_RS2320_00052


	//Call Component Macro
	//Call Component Macro: SendRS232Char(GTS_ONES)
	FCD_RS2320_SendRS232Char(FCV_GTS_ONES);
004C  0848  	MOVF gbl_FCV_GTS_ONES, W
004D  00D9  	MOVWF FCD_RS2320_00052_arg_nChar
004E  01DA  	CLRF FCD_RS2320_00052_arg_nChar+D'1'
004F  2015  	CALL FCD_RS2320_00052


	//Call Component Macro
	//Call Component Macro: SendRS232Char(GT_MSEC)
	FCD_RS2320_SendRS232Char(FCV_GT_MSEC);
0050  0854  	MOVF gbl_FCV_GT_MSEC, W
0051  00D9  	MOVWF FCD_RS2320_00052_arg_nChar
0052  01DA  	CLRF FCD_RS2320_00052_arg_nChar+D'1'
0053  2015  	CALL FCD_RS2320_00052


	//Call Component Macro
	//Call Component Macro: SendRS232Char(POS)
	FCD_RS2320_SendRS232Char(FCV_POS);
0054  0857  	MOVF gbl_FCV_POS, W
0055  00D9  	MOVWF FCD_RS2320_00052_arg_nChar
0056  01DA  	CLRF FCD_RS2320_00052_arg_nChar+D'1'
0057  2015  	CALL FCD_RS2320_00052


	//Call Component Macro
	//Call Component Macro: SendRS232Char(PERIOD)
	FCD_RS2320_SendRS232Char(FCV_PERIOD);
0058  0844  	MOVF gbl_FCV_PERIOD, W
0059  00D9  	MOVWF FCD_RS2320_00052_arg_nChar
005A  01DA  	CLRF FCD_RS2320_00052_arg_nChar+D'1'
005B  2015  	CALL FCD_RS2320_00052


	//Call Component Macro
	//Call Component Macro: SendRS232Char(HS_H)
	FCD_RS2320_SendRS232Char(FCV_HS_H);
005C  0846  	MOVF gbl_FCV_HS_H, W
005D  00D9  	MOVWF FCD_RS2320_00052_arg_nChar
005E  01DA  	CLRF FCD_RS2320_00052_arg_nChar+D'1'
005F  2015  	CALL FCD_RS2320_00052


	//Call Component Macro
	//Call Component Macro: SendRS232Char(HS_T)
	FCD_RS2320_SendRS232Char(FCV_HS_T);
0060  0842  	MOVF gbl_FCV_HS_T, W
0061  00D9  	MOVWF FCD_RS2320_00052_arg_nChar
0062  01DA  	CLRF FCD_RS2320_00052_arg_nChar+D'1'
0063  2015  	CALL FCD_RS2320_00052


	//Call Component Macro
	//Call Component Macro: SendRS232Char(HS_O)
	FCD_RS2320_SendRS232Char(FCV_HS_O);
0064  0851  	MOVF gbl_FCV_HS_O, W
0065  00D9  	MOVWF FCD_RS2320_00052_arg_nChar
0066  01DA  	CLRF FCD_RS2320_00052_arg_nChar+D'1'
0067  2015  	CALL FCD_RS2320_00052


	//Call Component Macro
	//Call Component Macro: SendRS232Char(GS_H)
	FCD_RS2320_SendRS232Char(FCV_GS_H);
0068  084B  	MOVF gbl_FCV_GS_H, W
0069  00D9  	MOVWF FCD_RS2320_00052_arg_nChar
006A  01DA  	CLRF FCD_RS2320_00052_arg_nChar+D'1'
006B  2015  	CALL FCD_RS2320_00052


	//Call Component Macro
	//Call Component Macro: SendRS232Char(GS_T)
	FCD_RS2320_SendRS232Char(FCV_GS_T);
006C  0843  	MOVF gbl_FCV_GS_T, W
006D  00D9  	MOVWF FCD_RS2320_00052_arg_nChar
006E  01DA  	CLRF FCD_RS2320_00052_arg_nChar+D'1'
006F  2015  	CALL FCD_RS2320_00052


	//Call Component Macro
	//Call Component Macro: SendRS232Char(GS_O)
	FCD_RS2320_SendRS232Char(FCV_GS_O);
0070  0852  	MOVF gbl_FCV_GS_O, W
0071  00D9  	MOVWF FCD_RS2320_00052_arg_nChar
0072  01DA  	CLRF FCD_RS2320_00052_arg_nChar+D'1'
0073  2015  	CALL FCD_RS2320_00052


	//Call Component Macro
	//Call Component Macro: SendRS232Char(FOUL_H)
	FCD_RS2320_SendRS232Char(FCV_FOUL_H);
0074  084F  	MOVF gbl_FCV_FOUL_H, W
0075  00D9  	MOVWF FCD_RS2320_00052_arg_nChar
0076  01DA  	CLRF FCD_RS2320_00052_arg_nChar+D'1'
0077  2015  	CALL FCD_RS2320_00052


	//Call Component Macro
	//Call Component Macro: SendRS232Char(FOUL_G)
	FCD_RS2320_SendRS232Char(FCV_FOUL_G);
0078  084E  	MOVF gbl_FCV_FOUL_G, W
0079  00D9  	MOVWF FCD_RS2320_00052_arg_nChar
007A  01DA  	CLRF FCD_RS2320_00052_arg_nChar+D'1'
007B  2015  	CALL FCD_RS2320_00052


	//Call Component Macro
	//Call Component Macro: SendRS232Char(TO_H)
	FCD_RS2320_SendRS232Char(FCV_TO_H);
007C  084A  	MOVF gbl_FCV_TO_H, W
007D  00D9  	MOVWF FCD_RS2320_00052_arg_nChar
007E  01DA  	CLRF FCD_RS2320_00052_arg_nChar+D'1'
007F  2015  	CALL FCD_RS2320_00052


	//Call Component Macro
	//Call Component Macro: SendRS232Char(TO_G)
	FCD_RS2320_SendRS232Char(FCV_TO_G);
0080  0845  	MOVF gbl_FCV_TO_G, W
0081  00D9  	MOVWF FCD_RS2320_00052_arg_nChar
0082  01DA  	CLRF FCD_RS2320_00052_arg_nChar+D'1'
0083  2015  	CALL FCD_RS2320_00052


	//Call Component Macro
	//Call Component Macro: SendRS232Char(FOOTER)
	FCD_RS2320_SendRS232Char(FCV_FOOTER);
0084  084D  	MOVF gbl_FCV_FOOTER, W
0085  00D9  	MOVWF FCD_RS2320_00052_arg_nChar
0086  01DA  	CLRF FCD_RS2320_00052_arg_nChar+D'1'
0087  2015  	CALL FCD_RS2320_00052


}
0088  0008  	RETURN




void main()

{
	//Initialization
	ansel = 0;
0089  1283  	BCF STATUS, RP0
008A  1703  	BSF STATUS, RP1
008B  019E  	CLRF gbl_ansel

anselh = 0;
008C  019F  	CLRF gbl_anselh


	
		RS232_1_UART_Init( );		//Call initialise function
008D  201B  	CALL FC_CAL_UAR_00053



	//Interrupt initialization code
	option_reg = 0xC0;
008E  30C0  	MOVLW 0xC0
008F  0081  	MOVWF gbl_option_reg



	//Calculation
	//Calculation:
	//  HEADER0 = 0b10101010
	//  HEADER1 = 0b01010101
	//  SC_TENS = 2
	//  SC_ONES = 4
	//  SC_MSEC = 8
	//  GTM_TENS = 1
	//  GTM_ONES = 0
	//  GTS_TENS = 5
	//  GTS_ONES = 9
	//  GT_MSEC = 3
	//  POS = 5
	//  PERIOD = 4
	//  HS_H = 1
	//  HS_T = 2
	//  HS_O = 0
	//  GS_H = 1
	//  GS_T = 3
	//  GS_O = 4
	//  FOUL_H = 1
	//  FOUL_G = 2
	//  TO_H = 3
	//  TO_G = 1
	//  FOOTER = 0b10101011
	FCV_HEADER0 = 170;
0090  30AA  	MOVLW 0xAA
0091  1283  	BCF STATUS, RP0
0092  00D3  	MOVWF gbl_FCV_HEADER0

	FCV_HEADER1 = 85;
0093  3055  	MOVLW 0x55
0094  00D6  	MOVWF gbl_FCV_HEADER1

	FCV_SC_TENS = 2;
0095  3002  	MOVLW 0x02
0096  00CC  	MOVWF gbl_FCV_SC_TENS

	FCV_SC_ONES = 4;
0097  3004  	MOVLW 0x04
0098  00D5  	MOVWF gbl_FCV_SC_ONES

	FCV_SC_MSEC = 8;
0099  3008  	MOVLW 0x08
009A  00C7  	MOVWF gbl_FCV_SC_MSEC

	FCV_GTM_TENS = 1;
009B  3001  	MOVLW 0x01
009C  00C9  	MOVWF gbl_FCV_GTM_TENS

	FCV_GTM_ONES = 0;
009D  01D0  	CLRF gbl_FCV_GTM_ONES

	FCV_GTS_TENS = 5;
009E  3005  	MOVLW 0x05
009F  00D8  	MOVWF gbl_FCV_GTS_TENS

	FCV_GTS_ONES = 9;
00A0  3009  	MOVLW 0x09
00A1  00C8  	MOVWF gbl_FCV_GTS_ONES

	FCV_GT_MSEC = 3;
00A2  3003  	MOVLW 0x03
00A3  00D4  	MOVWF gbl_FCV_GT_MSEC

	FCV_POS = 5;
00A4  3005  	MOVLW 0x05
00A5  00D7  	MOVWF gbl_FCV_POS

	FCV_PERIOD = 4;
00A6  3004  	MOVLW 0x04
00A7  00C4  	MOVWF gbl_FCV_PERIOD

	FCV_HS_H = 1;
00A8  3001  	MOVLW 0x01
00A9  00C6  	MOVWF gbl_FCV_HS_H

	FCV_HS_T = 2;
00AA  3002  	MOVLW 0x02
00AB  00C2  	MOVWF gbl_FCV_HS_T

	FCV_HS_O = 0;
00AC  01D1  	CLRF gbl_FCV_HS_O

	FCV_GS_H = 1;
00AD  3001  	MOVLW 0x01
00AE  00CB  	MOVWF gbl_FCV_GS_H

	FCV_GS_T = 3;
00AF  3003  	MOVLW 0x03
00B0  00C3  	MOVWF gbl_FCV_GS_T

	FCV_GS_O = 4;
00B1  3004  	MOVLW 0x04
00B2  00D2  	MOVWF gbl_FCV_GS_O

	FCV_FOUL_H = 1;
00B3  3001  	MOVLW 0x01
00B4  00CF  	MOVWF gbl_FCV_FOUL_H

	FCV_FOUL_G = 2;
00B5  3002  	MOVLW 0x02
00B6  00CE  	MOVWF gbl_FCV_FOUL_G

	FCV_TO_H = 3;
00B7  3003  	MOVLW 0x03
00B8  00CA  	MOVWF gbl_FCV_TO_H

	FCV_TO_G = 1;
00B9  3001  	MOVLW 0x01
00BA  00C5  	MOVWF gbl_FCV_TO_G

	FCV_FOOTER = 171;
00BB  30AB  	MOVLW 0xAB
00BC  00CD  	MOVWF gbl_FCV_FOOTER


	//Loop
	//Loop: While 1
	while (1)
00BD        label2
00BE  28BD  	GOTO	label2

	{

		//Call Macro
		//Call Macro: SENDDATA()
		FCM_SENDDATA();
00BD  202A  	CALL FCM_SENDDA_00051



	}

	mainendloop: goto mainendloop;
}


void MX_INTERRUPT_MACRO(void)

{
}
00FD  1283  	BCF STATUS, RP0
00FE  1303  	BCF STATUS, RP1
00FF  0E36  	SWAPF Int1BContext+D'2', W
0100  0084  	MOVWF FSR
0101  0E35  	SWAPF Int1BContext+D'1', W
0102  008A  	MOVWF PCLATH
0103  0E34  	SWAPF Int1BContext, W
0104  0083  	MOVWF STATUS
0105  0EFF  	SWAPF Int1Context, F
0106  0E7F  	SWAPF Int1Context, W
0107  0009  	RETFIE





/*********************************************************************
 *                  Flowcode CAL UART File
 *
 * File: PIC_CAL_UART.c
 *
 * (c) 2011 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * “Company”) for its Flowcode graphical programming language is
 * intended and supplied to you, the Company’s customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 010911 | BR | Created
 * 020911 | BR | Updated variables with typedef alternatives
 * 011211 | BR | Converted to new dynamic defines mechanism
 * 160112 | BR | Fixed issues with rx return type and low bauds on fast devices
 * 020212 | ST | Added <MX_UART_2_PIE4> routing to account for differences in 16F and 18F devices with 2 UARTs
 * 270212 | BR | Fixed a bug in the receive functionality
 * 280212 | BR | Sorted out auto echo functionality
 * 160412 | BR | Addition of HW change baud function
 */



#ifndef MX_UART_SW_DEFS
	#define MX_UART_SW_DEFS

	#ifdef _BOOSTC
		#define INST_COUNT	45	//65 for lower speeds or 40 for higher speeds.
	#endif
	#ifdef HI_TECH_C
		#define INST_COUNT	315
	#endif

	//Work out number of nops for software baud rate
	#define MX_INSTRUCTION_SPEED 	(MX_CLK_SPEED / 4)
	#define MX_OVERHEAD				(MX_INSTRUCTION_SPEED / INST_COUNT)
	#define SW_OFFSET				(1000000 / MX_OVERHEAD)

	//Work out software baud rates if required
	#define SW_1200_BAUD	(832 - SW_OFFSET)
	#define SW_2400_BAUD	(416 - SW_OFFSET)
	#define SW_4800_BAUD	(208 - SW_OFFSET)
	#define SW_9600_BAUD	(104 - SW_OFFSET)
	#define SW_19200_BAUD	(52 - SW_OFFSET)
	#define SW_31250_BAUD	(32 - SW_OFFSET)
	#define SW_115200_BAUD	(8 - SW_OFFSET)
#endif

 #if defined(MX_UART_CHANNEL_1) && (MX_UART_NUM==1)
	#if (MX_UART_CHANNEL_1 == 0)
		#if (MX_UART_BAUD_1 == 1200)
			#define MX_SOFT_BAUD_1	SW_1200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 1200 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_1 == 2400)
			#define MX_SOFT_BAUD_1	SW_2400_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 2400 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_1 == 4800)
			#define MX_SOFT_BAUD_1	SW_4800_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 4800 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_1 == 9600)
			#define MX_SOFT_BAUD_1	SW_9600_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 9600 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_1 == 19200)
			#define MX_SOFT_BAUD_1	SW_19200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 19200 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_1 == 31250)
			#define MX_SOFT_BAUD_1	SW_31250_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 31250 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_1 == 115200)
			#define MX_SOFT_BAUD_1	SW_115200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 115200 Not Available At This Clock Speed"
			#endif
		#endif
		#ifndef MX_SOFT_BAUD_1
			#error "UART Baud Rate not supported in Software Mode"
		#endif
	#else
		#define MX_SOFT_BAUD_1	1
		#define MX_HARD_BAUD_1	(((MX_CLK_SPEED / MX_UART_BAUD_1) - 16) / 16)
		#define MX_HARD_SLOW_1	0

		#if (MX_HARD_BAUD_1 > 255)
			#undef MX_HARD_BAUD_1
			#undef MX_HARD_SLOW_1
			#define MX_HARD_BAUD_1	(((MX_CLK_SPEED / MX_UART_BAUD_1) - 16)	/ 64)
			#define MX_HARD_SLOW_1	1
		#endif

	#endif
 #endif
 #if defined(MX_UART_CHANNEL_2) && (MX_UART_NUM==2)
	#if (MX_UART_CHANNEL_2 == 0)
		#if (MX_UART_BAUD_2 == 1200)
			#define MX_SOFT_BAUD_2	SW_1200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 1200 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_2 == 2400)
			#define MX_SOFT_BAUD_2	SW_2400_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 2400 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_2 == 4800)
			#define MX_SOFT_BAUD_2	SW_4800_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 4800 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_2 == 9600)
			#define MX_SOFT_BAUD_2	SW_9600_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 9600 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_2 == 19200)
			#define MX_SOFT_BAUD_2	SW_19200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 19200 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_2 == 31250)
			#define MX_SOFT_BAUD_2	SW_31250_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 31250 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_2 == 115200)
			#define MX_SOFT_BAUD_2	SW_115200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 115200 Not Available At This Clock Speed"
			#endif
		#endif
		#ifndef MX_SOFT_BAUD_2
			#error "UART Baud Rate not supported in Software Mode"
		#endif
	#else
		#define MX_SOFT_BAUD_2	1
		#define MX_HARD_BAUD_2	(((MX_CLK_SPEED / MX_UART_BAUD_2) - 16) / 16)
		#define MX_HARD_SLOW_2	0

		#if (MX_HARD_BAUD_2 > 255)
			#undef MX_HARD_BAUD_2
			#undef MX_HARD_SLOW_2
			#define MX_HARD_BAUD_2	(((MX_CLK_SPEED / MX_UART_BAUD_2) - 16)	/ 64)
			#define MX_HARD_SLOW_2	1
		#endif
 	#endif
 #endif
 #if defined(MX_UART_CHANNEL_3) && (MX_UART_NUM==3)
	#if (MX_UART_CHANNEL_3 == 0)
		#if (MX_UART_BAUD_3 == 1200)
			#define MX_SOFT_BAUD_3	SW_1200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 1200 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_3 == 2400)
			#define MX_SOFT_BAUD_3	SW_2400_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 2400 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_3 == 4800)
			#define MX_SOFT_BAUD_3	SW_4800_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 4800 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_3 == 9600)
			#define MX_SOFT_BAUD_3	SW_9600_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 9600 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_3 == 19200)
			#define MX_SOFT_BAUD_3	SW_19200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 19200 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_3 == 31250)
			#define MX_SOFT_BAUD_3	SW_31250_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 31250 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_3 == 115200)
			#define MX_SOFT_BAUD_3	SW_115200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 115200 Not Available At This Clock Speed"
			#endif
		#endif
		#ifndef MX_SOFT_BAUD_3
			#error "UART Baud Rate not supported in Software Mode"
		#endif
	#else
		#define MX_SOFT_BAUD_3	1
		#define MX_HARD_BAUD_3	(((MX_CLK_SPEED / MX_UART_BAUD_3) - 16) / 16)
		#define MX_HARD_SLOW_3	0

		#if (MX_HARD_BAUD_3 > 255)
			#undef MX_HARD_BAUD_3
			#undef MX_HARD_SLOW_3
			#define MX_HARD_BAUD_3	(((MX_CLK_SPEED / MX_UART_BAUD_3) - 16)	/ 64)
			#define MX_HARD_SLOW_3	1
		#endif
	#endif
 #endif
 #if defined(MX_UART_CHANNEL_4) && (MX_UART_NUM==4)
	#if (MX_UART_CHANNEL_4 == 0)
		#if (MX_UART_BAUD_4 == 1200)
			#define MX_SOFT_BAUD_4	SW_1200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 1200 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_4 == 2400)
			#define MX_SOFT_BAUD_4	SW_2400_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 2400 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_4 == 4800)
			#define MX_SOFT_BAUD_4	SW_4800_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 4800 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_4 == 9600)
			#define MX_SOFT_BAUD_4	SW_9600_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 9600 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_4 == 19200)
			#define MX_SOFT_BAUD_4	SW_19200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 19200 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_4 == 31250)
			#define MX_SOFT_BAUD_4	SW_31250_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 31250 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_4 == 115200)
			#define MX_SOFT_BAUD_4	SW_115200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 115200 Not Available At This Clock Speed"
			#endif
		#endif
		#ifndef MX_SOFT_BAUD_4
			#error "UART Baud Rate not supported in Software Mode"
		#endif
	#else
		#define MX_SOFT_BAUD_4	1
		#define MX_HARD_BAUD_4	(((MX_CLK_SPEED / MX_UART_BAUD_4) - 16) / 16)
		#define MX_HARD_SLOW_4	0

		#if (MX_HARD_BAUD_4 > 255)
			#undef MX_HARD_BAUD_4
			#undef MX_HARD_SLOW_4
			#define MX_HARD_BAUD_4	(((MX_CLK_SPEED / MX_UART_BAUD_4) - 16)	/ 64)
			#define MX_HARD_SLOW_4	1
		#endif
	#endif
 #endif


//Hardware Baud update definitions
#ifndef MX_HARD_BAUD_CHANGE_DEFS
	#define MX_HARD_BAUD_CHANGE_DEFS

	#define MX_HARD_BAUD_1200	(((MX_CLK_SPEED / 1200) - 16) / 16)
	#if (MX_HARD_BAUD_1200 > 255)
		#undef MX_HARD_BAUD_1200
		#define MX_HARD_BAUD_1200	(((MX_CLK_SPEED / 1200) - 16) / 64)
		#define MX_HARD_SLOW_1200	1
	#else
		#define MX_HARD_SLOW_1200	0
	#endif

	#define MX_HARD_BAUD_2400	(((MX_CLK_SPEED / 2400) - 16) / 16)
	#if (MX_HARD_BAUD_2400 > 255)
		#undef MX_HARD_BAUD_2400
		#define MX_HARD_BAUD_2400	(((MX_CLK_SPEED / 2400) - 16) / 64)
		#define MX_HARD_SLOW_2400	1
	#else
		#define MX_HARD_SLOW_2400	0
	#endif

	#define MX_HARD_BAUD_4800	(((MX_CLK_SPEED / 4800) - 16) / 16)
	#if (MX_HARD_BAUD_4800 > 255)
		#undef MX_HARD_BAUD_4800
		#define MX_HARD_BAUD_4800	(((MX_CLK_SPEED / 4800) - 16) / 64)
		#define MX_HARD_SLOW_4800	1
	#else
		#define MX_HARD_SLOW_4800	0
	#endif

	#define MX_HARD_BAUD_9600	(((MX_CLK_SPEED / 9600) - 16) / 16)
	#if (MX_HARD_BAUD_9600 > 255)
		#undef MX_HARD_BAUD_9600
		#define MX_HARD_BAUD_9600	(((MX_CLK_SPEED / 9600) - 16) / 64)
		#define MX_HARD_SLOW_9600	1
	#else
		#define MX_HARD_SLOW_9600	0
	#endif

	#define MX_HARD_BAUD_19200	(((MX_CLK_SPEED / 19200) - 16) / 16)
	#if (MX_HARD_BAUD_19200 > 255)
		#undef MX_HARD_BAUD_19200
		#define MX_HARD_BAUD_19200	(((MX_CLK_SPEED / 19200) - 16) / 64)
		#define MX_HARD_SLOW_19200	1
	#else
		#define MX_HARD_SLOW_19200	0
	#endif

	#define MX_HARD_BAUD_38400	(((MX_CLK_SPEED / 38400) - 16) / 16)
	#if (MX_HARD_BAUD_38400 > 255)
		#undef MX_HARD_BAUD_38400
		#define MX_HARD_BAUD_38400	(((MX_CLK_SPEED / 38400) - 16) / 64)
		#define MX_HARD_SLOW_38400	1
	#else
		#define MX_HARD_SLOW_38400	0
	#endif

	#define MX_HARD_BAUD_57600	(((MX_CLK_SPEED / 57600) - 16) / 16)
	#if (MX_HARD_BAUD_57600 > 255)
		#undef MX_HARD_BAUD_57600
		#define MX_HARD_BAUD_57600	(((MX_CLK_SPEED / 57600) - 16) / 64)
		#define MX_HARD_SLOW_57600	1
	#else
		#define MX_HARD_SLOW_57600	0
	#endif

	#define MX_HARD_BAUD_115200	(((MX_CLK_SPEED / 115200) - 16) / 16)
	#if (MX_HARD_BAUD_115200 > 255)
		#undef MX_HARD_BAUD_115200
		#define MX_HARD_BAUD_115200	(((MX_CLK_SPEED / 115200) - 16) / 64)
		#define MX_HARD_SLOW_115200	1
	#else
		#define MX_HARD_SLOW_115200	0
	#endif
#endif


//Dynamic function naming based on defines and index number
#define MX_UART_CHANNEL_X	CAL_APPEND(MX_UART_CHANNEL_, MX_UART_NUM)
#define MX_UART_TX_PIN_X	CAL_APPEND(MX_UART_TX_PIN_, MX_UART_NUM)
#define MX_UART_TX_PORT_X	CAL_APPEND(MX_UART_TX_PORT_, MX_UART_NUM)
#define MX_UART_TX_TRIS_X	CAL_APPEND(MX_UART_TX_TRIS_, MX_UART_NUM)
#define MX_UART_RX_PIN_X	CAL_APPEND(MX_UART_RX_PIN_, MX_UART_NUM)
#define MX_UART_RX_PORT_X	CAL_APPEND(MX_UART_RX_PORT_, MX_UART_NUM)
#define MX_UART_RX_TRIS_X	CAL_APPEND(MX_UART_RX_TRIS_, MX_UART_NUM)
#define MX_UART_FLOWEN_X	CAL_APPEND(MX_UART_FLOWEN_, MX_UART_NUM)
#define MX_UART_CTS_PIN_X	CAL_APPEND(MX_UART_CTS_PIN_, MX_UART_NUM)
#define MX_UART_CTS_PORT_X	CAL_APPEND(MX_UART_CTS_PORT_, MX_UART_NUM)
#define MX_UART_CTS_TRIS_X	CAL_APPEND(MX_UART_CTS_TRIS_, MX_UART_NUM)
#define MX_UART_RTS_PIN_X	CAL_APPEND(MX_UART_RTS_PIN_, MX_UART_NUM)
#define MX_UART_RTS_PORT_X	CAL_APPEND(MX_UART_RTS_PORT_, MX_UART_NUM)
#define MX_UART_RTS_TRIS_X	CAL_APPEND(MX_UART_RTS_TRIS_, MX_UART_NUM)
#define MX_UART_DBITS_X		CAL_APPEND(MX_UART_DBITS_, MX_UART_NUM)
#define MX_UART_RETURN_X	CAL_APPEND(MX_UART_RETURN_, MX_UART_NUM)
#define MX_UART_ECHO_X		CAL_APPEND(MX_UART_ECHO_, MX_UART_NUM)
#define MX_UART_INT_X		CAL_APPEND(MX_UART_INT_, MX_UART_NUM)
#define MX_UART_BAUD_X		CAL_APPEND(MX_HARD_BAUD_, MX_UART_NUM)
#define MX_SOFT_BAUD_X		CAL_APPEND(MX_SOFT_BAUD_, MX_UART_NUM)
#define MX_HARD_SLOW_X		CAL_APPEND(MX_HARD_SLOW_, MX_UART_NUM)

#define UART_Delay_CAL		CAL_APPEND(FC_CAL_UART_Delay_, MX_UART_NUM)
#define UART_Send			CAL_APPEND(FC_CAL_UART_Send_, MX_UART_NUM)
#define UART_Uninit			CAL_APPEND(FC_CAL_UART_Uninit_, MX_UART_NUM)


//Component Definitions
#define UART_STATUS_LOOP	0
#define UART_STATUS_TIMEOUT	1
#define UART_STATUS_RXBYTE	2


//Interrupt Definitions
#ifdef MX_UART_2_PIE4
  #define MX_UART2_PIE pie4
  #define MX_UART2_PIR pir4
  #define MX_UART2_TXSTA tx2sta
  #define MX_UART2_RCSTA rc2sta
  #define MX_UART2_TXREG tx2reg
  #define MX_UART2_RCREG rc2reg
#else
  #define MX_UART2_PIE pie3
  #define MX_UART2_PIR pir3
  #define MX_UART2_TXSTA txsta2
  #define MX_UART2_RCSTA rcsta2
  #define MX_UART2_TXREG txreg2
  #define MX_UART2_RCREG rcreg2
#endif

#if (MX_UART_INT_X == 1)

	#ifndef MX_UART_INT_DEFS
	#define MX_UART_INT_DEFS

		#define MX_UART_INT_CH1_FUNC
		#define MX_UART_INT_CH2_FUNC
		#define MX_UART_INT_FUNC_END

		#define MX_UART_INT_CH1_DET		ts_bit(pir1, RCIF) && ts_bit(pie1, RCIE)
		#define MX_UART_INT_CH2_DET		ts_bit(MX_UART2_PIR, RC2IF) && ts_bit(MX_UART2_PIE, RC2IE)

		#define MX_UART_INT_CH1_EN		st_bit (pie1, RCIE)
		#define MX_UART_INT_CH2_EN		st_bit (MX_UART2_PIE, RC2IE)

		#define MX_UART_INT_CH1_DIS		cr_bit (pie1, RCIE)
		#define MX_UART_INT_CH2_DIS		cr_bit (MX_UART2_PIE, RC2IE)

		#define MX_UART_INT_CH1_CLR		cr_bit (pir1, RCIF)
		#define MX_UART_INT_CH2_CLR		cr_bit (MX_UART2_PIR, RC2IF)

	#endif
#endif


//Function Prototypes
CALFUNCTION(void, FC_CAL_UART_Init_, (void));
CALFUNCTION(void, FC_CAL_UART_Uninit_, (void));
CALFUNCTION(void, FC_CAL_UART_Send_, (MX_UINT16 nChar));
CALFUNCTION(MX_SINT16, FC_CAL_UART_Receive_, (MX_UINT8 nTimeout));
CALFUNCTION(void, FC_CAL_UART_Delay_, (void));


//Peripheral Functions
CALFUNCTION(void, FC_CAL_UART_Init_, (void))

{

	#if (MX_UART_CHANNEL_X == 0)
		FC_CAL_Bit_In_DDR 	(MX_UART_RX_PORT_X, MX_UART_RX_TRIS_X, MX_UART_RX_PIN_X);		// Receive pin is a input
		FC_CAL_Bit_High_DDR (MX_UART_TX_PORT_X, MX_UART_TX_TRIS_X, MX_UART_TX_PIN_X);		// Transmit pin is default high
	#endif

	#if (MX_UART_CHANNEL_X == 1)
	  #ifndef MX_UART_1
	  	  #error "UART channel 1 not available on this device"
	  #else
		  #if (MX_HARD_SLOW_X == 1)
			cr_bit(txsta, BRGH);						//Low Speed
		  #else
			st_bit(txsta, BRGH);						//High Speed
001B  1683  	BSF STATUS, RP0
001C  1303  	BCF STATUS, RP1
001D  1518  	BSF gbl_txsta,2

		  #endif
			spbrg = MX_UART_BAUD_X;   					// set the baud rate
001E  3014  	MOVLW 0x14
001F  0099  	MOVWF gbl_spbrg

			rcsta = 0;                    				// 8-bit, disabled
0020  1283  	BCF STATUS, RP0
0021  0198  	CLRF gbl_rcsta


			#if(MX_UART_DBITS_X == 9)
				st_bit(txsta, TX9);   					// 9-bit TX
				st_bit(rcsta, RX9);                    	// 9-bit RX
			#endif

			st_bit(rcsta, SPEN);         				// turn on serial interface
0022  1798  	BSF gbl_rcsta,7

			st_bit(txsta, TXEN);
0023  1683  	BSF STATUS, RP0
0024  1698  	BSF gbl_txsta,5

			st_bit(rcsta, CREN);
0025  1283  	BCF STATUS, RP0
0026  1618  	BSF gbl_rcsta,4


			#if (MX_UART_INT_X == 1)
				MX_UART_INT_CH1_EN;
				st_bit(intcon, PEIE);
				st_bit(intcon, GIE);
			#else
				cr_bit (pie1, RCIE);
0027  1683  	BSF STATUS, RP0
0028  128C  	BCF gbl_pie1,5

			#endif
	  #endif
	#endif


	#if (MX_UART_CHANNEL_X == 2)

	  #ifndef MX_UART_2
		  #error "UART channel 2 not available on this device"
	  #else
		  #ifdef MX_UART_2_REMAPPABLE
			RPOR9 = 5;									//TX2 - RP9 - RB6
			RPINR16	= 10;								//RX2 - RP10 - RB7
		  #endif
		  #if (MX_HARD_SLOW_X == 1)
			cr_bit(MX_UART2_TXSTA, BRGH);						//Low Speed
		  #else
			st_bit(MX_UART2_TXSTA, BRGH);						//High Speed
		  #endif
			spbrg2 = MX_UART_BAUD_X;   				// set the baud rate
			MX_UART2_RCSTA = 0;                    				// 8-bit, disabled

			#if(MX_UART_DBITS_X == 9)
				st_bit(MX_UART2_TXSTA, TX9);   					// 9-bit TX
				st_bit(MX_UART2_RCSTA, RX9);                    // 9-bit RX
			#endif

			st_bit(MX_UART2_RCSTA, SPEN);         				// turn on serial interface
			st_bit(MX_UART2_TXSTA, TXEN);
			st_bit(MX_UART2_RCSTA, CREN);

			#if (MX_UART_INT_X == 1)
				MX_UART_INT_CH2_EN;
				st_bit(intcon, PEIE);
				st_bit(intcon, GIE);
			#else
				cr_bit (MX_UART2_PIE, RC2IE);
			#endif
	  #endif
	#endif

	#if (MX_UART_FLOWEN_X == 1)						//Flowcontrol enabled?
		FC_CAL_Bit_In_DDR (MX_UART_CTS_PORT_X, MX_UART_CTS_TRIS_X, MX_UART_CTS_PIN_X);	// CTS pin is a input
		FC_CAL_Bit_High_DDR (MX_UART_RTS_PORT_X, MX_UART_RTS_TRIS_X, MX_UART_RTS_PIN_X);	// RTS not ready to accept data
	#endif

}
0029  0008  	RETURN




CALFUNCTION(void, FC_CAL_UART_Uninit_, (void))
{

	#if (MX_UART_CHANNEL_X == 0)
		FC_CAL_Bit_In_DDR (MX_UART_RX_PORT_X, MX_UART_RX_TRIS_X, MX_UART_RX_PIN_X);		// Receive pin is a input
		FC_CAL_Bit_In_DDR (MX_UART_TX_PORT_X, MX_UART_TX_TRIS_X, MX_UART_TX_PIN_X);		// Transmit pin is default high
	#endif

	#if (MX_UART_CHANNEL_X == 1)
			rcsta = 0;                    								// 8-bit, disabled
			txsta = 0;
		  #ifdef MX_UART_RXINT
			MX_UART_INT_CH1_DIS;
		  #endif
	#endif

	#if (MX_UART_CHANNEL_X == 2)
			MX_UART2_RCSTA = 0;                    								// 8-bit, disabled
			MX_UART2_TXSTA = 0;
		  #ifdef MX_UART_RXINT
			MX_UART_INT_CH2_DIS;
		  #endif
	#endif

	#if (MX_UART_FLOWEN_X == 1)										//Flowcontrol enabled?
		FC_CAL_Bit_In_DDR (MX_UART_CTS_PORT_X, MX_UART_CTS_TRIS_X, MX_UART_CTS_PIN_X);		// CTS pin is a input
		FC_CAL_Bit_In_DDR (MX_UART_RTS_PORT_X, MX_UART_RTS_TRIS_X, MX_UART_RTS_PIN_X);		// RTS not ready to accept data
	#endif
}



CALFUNCTION(void, FC_CAL_UART_Send_, (MX_UINT16 nChar))

{
	#if (MX_UART_FLOWEN_X == 1)
		while (FC_CAL_Bit_In(MX_UART_CTS_PORT_X, MX_UART_CTS_PIN_X) != 0);	// Wait until CTS is low
	#endif

	#if (MX_UART_CHANNEL_X == 0)													// Software UART TX
		MX_UINT8 idx;
		FC_CAL_Bit_Low(MX_UART_TX_PORT_X, MX_UART_TX_PIN_X);					// Send Start bit
		UART_Delay_CAL();
		for (idx = 0; idx < MX_UART_DBITS_X; idx++)
		{
			if (nChar & 0x01)														// Mask off data bit
				FC_CAL_Bit_High(MX_UART_TX_PORT_X, MX_UART_TX_PIN_X);
			else
				FC_CAL_Bit_Low(MX_UART_TX_PORT_X, MX_UART_TX_PIN_X);
			UART_Delay_CAL();
			nChar = nChar >> 1;														// Move to next data bit
		}
		FC_CAL_Bit_High(MX_UART_TX_PORT_X, MX_UART_TX_PIN_X);					// Send Stop bit
		UART_Delay_CAL();
	#endif

	#if (MX_UART_CHANNEL_X == 1)
		while (ts_bit(pir1, TXIF) == 0);
0010        label1
0010  1E0C  	BTFSS gbl_pir1,4
0011  2810  	GOTO	label1


		#if (MX_UART_DBITS_X == 9)
			if (test_bit(nChar, 8))
				st_bit(txsta, TX9D);
			else
				cr_bit(txsta, TX9D);
	  	#endif
		txreg = nChar;
0012  085B  	MOVF FC_CAL_UAR_00054_arg_nChar, W
0013  0099  	MOVWF gbl_txreg

	#endif

	#if (MX_UART_CHANNEL_X == 2)
		while (ts_bit(pir3, TX2IF) == 0);

		#if (MX_UART_DBITS_X == 9)
			if (test_bit(nChar, 8))
				st_bit(MX_UART2_TXSTA, TX9D);
			else
				cr_bit(MX_UART2_TXSTA, TX9D);
		#endif
		MX_UART2_TXREG = nChar;
	#endif
}
0014  0008  	RETURN



CALFUNCTION(MX_SINT16, FC_CAL_UART_Receive_, (MX_UINT8 nTimeout))
{
  #if (MX_UART_RETURN_X == 1)
	MX_UINT16 retVal = 512;
  #else
  	MX_UINT8 retVal = 255;
  #endif

	MX_UINT8 delay1 = 0;
	MX_UINT8 regcheck = 0;
	MX_UINT8 bWaitForever = 0;
	MX_UINT8 rxStatus = UART_STATUS_LOOP;

  #if (MX_UART_CHANNEL_X == 0)
  	MX_UINT8 idx;
  #else
  	MX_UINT8 dummy = 0;
  #endif

	if (nTimeout == 255)
		bWaitForever = 1;

	#if (MX_UART_FLOWEN_X == 1)
		FC_CAL_Bit_Low (MX_UART_RTS_PORT_X, MX_UART_RTS_PIN_X);			// Ready to accept data
	#endif

	while (rxStatus == UART_STATUS_LOOP)
	{
		if (bWaitForever == 0)
		{
			if (nTimeout == 0)							//don't wait forever, so do timeout thing...
			{
				rxStatus = UART_STATUS_TIMEOUT;
			}
			else
			{
				delay_us(10);
				delay1 = delay1 + 1;
				if(delay1 == 100)
				{
					nTimeout = nTimeout - 1;
					MX_CLEAR_WATCHDOG;
					delay1 = 0;
				}
			}
		}

		#if (MX_UART_CHANNEL_X == 0)
			regcheck = FC_CAL_Bit_In(MX_UART_RX_PORT_1, MX_UART_RX_PIN_1);	//Test for start bit
			if (regcheck == 0)
				rxStatus = UART_STATUS_RXBYTE;
		#endif

		#if (MX_UART_CHANNEL_X == 1)
			regcheck = ts_bit(pir1, RCIF);
			if (regcheck != 0)
				rxStatus = UART_STATUS_RXBYTE;
		#endif

		#if (MX_UART_CHANNEL_X == 2)
			regcheck = ts_bit(MX_UART2_PIR, RC2IF);
			if (regcheck != 0)
				rxStatus = UART_STATUS_RXBYTE;
		#endif

	}

	if (rxStatus == UART_STATUS_RXBYTE)
	{
		#if (MX_UART_CHANNEL_X == 0)

			retVal = 0;
			UART_Delay_CAL();

			for (idx = 0; idx < MX_UART_DBITS_X; idx++)
			{
				if (FC_CAL_Bit_In(MX_UART_RX_PORT_X, MX_UART_RX_PIN_X))
					retVal = retVal | (0x01 << idx);

				UART_Delay_CAL();
			}
		#endif

		#if (MX_UART_CHANNEL_X == 1)
			regcheck = ts_bit(rcsta, FERR);
			if (regcheck != 0)
			{
				dummy = rcreg;						//need to read the rcreg to clear FERR
				#if (MX_UART_RETURN_X == 1)
					retVal = 0x400;					//Framing Error Flag
				#endif
			}
			else
			{
				regcheck = ts_bit(rcsta, OERR);
				if (regcheck != 0)
				{
					cr_bit(rcsta, CREN);			//Reset receiver to clear error
					st_bit(rcsta, CREN);

					#if (MX_UART_RETURN_X == 1)
						retVal = 0x800;				//Overrun Error Flag
					#endif
				}
				else
				{
					retVal = 0;

					#if (MX_UART_DBITS_X == 9)
						if(ts_bit(rcsta, RX9D))
							retVal = 0x100;
					#endif

					retVal = retVal | rcreg; 			//no error, so rx byte is valid
				}
			}
		#endif

		#if (MX_UART_CHANNEL_X == 2)
			regcheck = ts_bit(MX_UART2_RCSTA, FERR);
			if (regcheck != 0)
			{
				dummy = MX_UART2_RCREG;			//need to read the rcreg to clear FERR
				#if (MX_UART_RETURN_X == 1)
					retVal = 0x400;					//Framing Error Flag
				#endif
			}
			else
			{
				regcheck = ts_bit(MX_UART2_RCSTA, OERR);
				if (regcheck != 0)
				{
					cr_bit(MX_UART2_RCSTA, CREN);	//Reset receiver to clear error
					st_bit(MX_UART2_RCSTA, CREN);
					#if (MX_UART_RETURN_X == 1)
						retVal = 0x800;				//Overrun Error Flag
					#endif
				}
				else
				{
					retVal = 0;

					#if (MX_UART_DBITS_X == 9)
						if(ts_bit(MX_UART2_RCSTA, RX9D))
							retVal = 0x100;
					#endif

					retVal = retVal | MX_UART2_RCREG; 			//no error, so rx byte is valid
				}
			}

		#endif

		#if (MX_UART_ECHO_X == 1)
			UART_Send(retVal);
		#endif
	}

	#if (MX_UART_FLOWEN_X == 1)
		FC_CAL_Bit_High(MX_UART_RTS_PORT_X, MX_UART_RTS_PIN_X);		//not ready to accept data
	#endif

	return (retVal);
}


CALFUNCTION(void, FC_CAL_UART_Delay_, (void))
{
  #if (MX_UART_CHANNEL_X == 0)

	MX_UINT16 delay = MX_SOFT_BAUD_X;

	while (delay > 255)
	{
		delay_us(255);
		delay = delay - 255;
		MX_CLEAR_WATCHDOG;
	}
	delay_us(delay);
	MX_CLEAR_WATCHDOG;

  #endif
}


CALFUNCTION(void, FC_CAL_UART_Update_Baud_, (MX_UINT8 new_baud))
{
	//Baud Rates - Function compatible with hardware mode only
	/*
	0 - 1200
	1 - 2400
	2 - 4800
	3 - 9600
	4 - 19200
	5 - 38400
	6 - 57600
	7 - 115200
	*/

	MX_UINT8 baudrate, baudmode;

	if (new_baud > 7)
		return;

	if (new_baud == 0)
	{
		baudrate = MX_HARD_BAUD_1200;
		baudmode = MX_HARD_SLOW_1200;
	}
	else if (new_baud == 1)
	{
		baudrate = MX_HARD_BAUD_2400;
		baudmode = MX_HARD_SLOW_2400;
	}
	else if (new_baud == 2)
	{
		baudrate = MX_HARD_BAUD_4800;
		baudmode = MX_HARD_SLOW_4800;
	}
	else if (new_baud == 3)
	{
		baudrate = MX_HARD_BAUD_9600;
		baudmode = MX_HARD_SLOW_9600;
	}
	else if (new_baud == 4)
	{
		baudrate = MX_HARD_BAUD_19200;
		baudmode = MX_HARD_SLOW_19200;
	}
	else if (new_baud == 5)
	{
		baudrate = MX_HARD_BAUD_38400;
		baudmode = MX_HARD_SLOW_38400;
	}
	else if (new_baud == 6)
	{
		baudrate = MX_HARD_BAUD_57600;
		baudmode = MX_HARD_SLOW_57600;
	}
	else if (new_baud == 7)
	{
		baudrate = MX_HARD_BAUD_115200;
		baudmode = MX_HARD_SLOW_115200;
	}

	UART_Uninit();

	#if (MX_UART_CHANNEL_X == 1)

	    if (baudmode == 1)
			cr_bit(txsta, BRGH);					//Low Speed
	    else
			st_bit(txsta, BRGH);					//High Speed

		spbrg = baudrate;   						// set the baud rate
		rcsta = 0;                    				// 8-bit, disabled

		#if(MX_UART_DBITS_X == 9)
			st_bit(txsta, TX9);   					// 9-bit TX
			st_bit(rcsta, RX9);                    	// 9-bit RX
		#endif

		st_bit(rcsta, SPEN);         				// turn on serial interface
		st_bit(txsta, TXEN);
		st_bit(rcsta, CREN);

		#if (MX_UART_INT_X == 1)
			MX_UART_INT_CH1_EN;
			st_bit(intcon, PEIE);
			st_bit(intcon, GIE);
		#else
			cr_bit (pie1, RCIE);
		#endif
	#endif

	#if (MX_UART_CHANNEL_X == 2)

	  	if (baudmode == 1)
			cr_bit(MX_UART2_TXSTA, BRGH);			//Low Speed
	  	else
			st_bit(MX_UART2_TXSTA, BRGH);			//High Speed

		spbrg2 = baudrate;   						// set the baud rate
		MX_UART2_RCSTA = 0;                    		// 8-bit, disabled

		#if(MX_UART_DBITS_X == 9)
			st_bit(MX_UART2_TXSTA, TX9);   			// 9-bit TX
			st_bit(MX_UART2_RCSTA, RX9);            // 9-bit RX
		#endif

		st_bit(MX_UART2_RCSTA, SPEN);         		// turn on serial interface
		st_bit(MX_UART2_TXSTA, TXEN);
		st_bit(MX_UART2_RCSTA, CREN);

		#if (MX_UART_INT_X == 1)
			MX_UART_INT_CH2_EN;
			st_bit(intcon, PEIE);
			st_bit(intcon, GIE);
		#else
			cr_bit (MX_UART2_PIE, RC2IE);
		#endif
	#endif

	#if (MX_UART_FLOWEN_X == 1)						//Flowcontrol enabled?
		FC_CAL_Bit_In_DDR (MX_UART_CTS_PORT_X, MX_UART_CTS_TRIS_X, MX_UART_CTS_PIN_X);	// CTS pin is a input
		FC_CAL_Bit_High_DDR (MX_UART_RTS_PORT_X, MX_UART_RTS_TRIS_X, MX_UART_RTS_PIN_X);	// RTS not ready to accept data
	#endif

}

////////////////////////////////////////
// Code with no source :-)
////////////////////////////////////////
0000  28BF  	GOTO	_startup

0004  00FF  	MOVWF Int1Context
0005  0E03  	SWAPF STATUS, W
0006  1283  	BCF STATUS, RP0
0007  1303  	BCF STATUS, RP1
0008  00B4  	MOVWF Int1BContext
0009  0E0A  	SWAPF PCLATH, W
000A  00B5  	MOVWF Int1BContext+D'1'
000B  0E04  	SWAPF FSR, W
000C  00B6  	MOVWF Int1BContext+D'2'
000D  118A  	BCF PCLATH,3
000E  120A  	BCF PCLATH,4
000F  28FD  	GOTO	interrupt

00BF        _startup
00BF  30D5  	MOVLW 0xD5
00C0  1283  	BCF STATUS, RP0
00C1  1303  	BCF STATUS, RP1
00C2  00A0  	MOVWF gbl_14_LSR
00C3  30C4  	MOVLW 0xC4
00C4  00A1  	MOVWF gbl_14_LSR+D'1'
00C5  30BB  	MOVLW 0xBB
00C6  00A2  	MOVWF gbl_14_LSR+D'2'
00C7  30DC  	MOVLW 0xDC
00C8  00A3  	MOVWF gbl_14_LSR+D'3'
00C9  01A4  	CLRF gbl_15_gbl_aSig
00CA  01A5  	CLRF gbl_15_gbl_aSig+D'1'
00CB  01A6  	CLRF gbl_15_gbl_aSig+D'2'
00CC  01A7  	CLRF gbl_15_gbl_aSig+D'3'
00CD  01A8  	CLRF gbl_15_gbl_bSig
00CE  01A9  	CLRF gbl_15_gbl_bSig+D'1'
00CF  01AA  	CLRF gbl_15_gbl_bSig+D'2'
00D0  01AB  	CLRF gbl_15_gbl_bSig+D'3'
00D1  01AC  	CLRF gbl_15_gbl_zSig
00D2  01AD  	CLRF gbl_15_gbl_zSig+D'1'
00D3  01AE  	CLRF gbl_15_gbl_zSig+D'2'
00D4  01AF  	CLRF gbl_15_gbl_zSig+D'3'
00D5  01BC  	CLRF gbl_15_gbl_aExp
00D6  01BD  	CLRF gbl_15_gbl_bExp
00D7  01B7  	CLRF gbl_15_gbl_zExp
00D8  01B8  	CLRF gbl_15_gbl_zExp+D'1'
00D9  01BE  	CLRF gbl_15_gbl_aSign
00DA  01BF  	CLRF gbl_15_gbl_bSign
00DB  01C0  	CLRF gbl_15_gbl_zSign
00DC  01C1  	CLRF gbl_15_gbl_zSigZero
00DD  01B0  	CLRF gbl_15_gbl_ret
00DE  01B1  	CLRF gbl_15_gbl_ret+D'1'
00DF  01B2  	CLRF gbl_15_gbl_ret+D'2'
00E0  01B3  	CLRF gbl_15_gbl_ret+D'3'
00E1  01BA  	CLRF gbl_float_rounding_mode
00E2  01BB  	CLRF gbl_float_exception_flags
00E3  01B9  	CLRF gbl_float_detect_tininess

00FA  118A  	BCF PCLATH,3
00FB  120A  	BCF PCLATH,4
00FC  2889  	GOTO	main

2007  30D2  	DW 0x30D2
