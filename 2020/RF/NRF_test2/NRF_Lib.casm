;/////////////////////////////////////////////////////////////////////////////////
;// Code Generator: BoostC Compiler - http://www.sourceboost.com
;// Version       : 7.03
;// License Type  : Pro License
;// Limitations   : PIC12,PIC16 max code size:Unlimited, max RAM banks:Unlimited
;/////////////////////////////////////////////////////////////////////////////////

/*********************************************************************
 *                  Flowcode CAL Delays File
 *
 * File: PIC_CAL_Delay.c
 *
 * (c) 2011 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * “Company”) for its Flowcode graphical programming language is
 * intended and supplied to you, the Company’s customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 010911 | BR | Created
 *
 *
 *
 */

//Original Byte Delays
void Wdt_Delay_S(char delay);
void Wdt_Delay_Ms(char delay);

//New Int Delays
void FCI_DELAYINT_US(MX_UINT16 Delay);

void FCI_DELAYINT_MS(MX_UINT16 Delay);
void FCI_DELAYINTWDT_MS(MX_UINT16 Delay);

void FCI_DELAYINT_S(MX_UINT16 Delay);
void FCI_DELAYINTWDT_S(MX_UINT16 Delay);


#ifdef HI_TECH_C

	#define nop()	asm("NOP")

	void delay_10us(char del);
	void delay_us(char del);
	void delay_ms(char del);
	void delay_s(char del);

	void delay_10us(char del)
	{
		char count;
		for(count=0; count<10; count++)
		{
			delay_us(del);
		}
	}

	void delay_us(char del)
	{
		while (del > 1)
		{
			__delay_us(1);
			del = del - 1;
		}
	}

	void delay_ms(char del)
	{
		while (del > 1)
		{
			__delay_ms(1);
			del = del - 1;
		}
	}

	void delay_s(char del)
	{
		char i;
		for(i=0; i<del; i++)
		{
			delay_ms(250);
			delay_ms(250);
			delay_ms(250);
			delay_ms(250);
		}
	}

#endif

void Wdt_Delay_S(char delay)
{
    char i;
    short j;
    for (i=0; i<delay; i++)
    {
        for (j=0; j<999; j++)
        {
            Wdt_Delay_Ms(1);
        }
    }
}

void Wdt_Delay_Ms(char delay)

{
    char i;
    for (i=0; i<delay; i++)
007C  01D5  	CLRF Wdt_Delay__0003E_1_i
007D        label10
007D  0854  	MOVF Wdt_Delay__0003E_arg_delay, W
007E  0255  	SUBWF Wdt_Delay__0003E_1_i, W
007F  1803  	BTFSC STATUS,C
0085  0AD5  	INCF Wdt_Delay__0003E_1_i, F
0086  287D  	GOTO	label10

    {
        MX_CLEAR_WATCHDOG;        //Clear Watchdog Timer
0081  0064  	CLRWDT

        delay_ms(1);
0082  3001  	MOVLW 0x01
0083  00D6  	MOVWF delay_ms_00000_arg_del
0084  2010  	CALL delay_ms_00000

    }
}
0080  0008  	RETURN



void FCI_DELAYINT_US(MX_UINT16 Delay)
{
  	while (Delay > 255)
  	{
	  	delay_us(255);
	  	Delay = Delay - 255;
  	}
  	if (Delay > 0)
  		delay_us(Delay & 0xFF);
}

void FCI_DELAYINT_MS(MX_UINT16 Delay)
{
  	while (Delay > 255)
  	{
	  	delay_ms(255);
	  	Delay = Delay - 255;
  	}
  	if (Delay > 0)
  		delay_ms(Delay & 0xFF);
}

void FCI_DELAYINTWDT_MS(MX_UINT16 Delay)
{
  	while (Delay > 255)
  	{
	  	Wdt_Delay_Ms(255);
	  	Delay = Delay - 255;
  	}
  	if (Delay > 0)
  		Wdt_Delay_Ms(Delay & 0xFF);
}

void FCI_DELAYINT_S(MX_UINT16 Delay)
{
  	while (Delay > 255)
  	{
	  	delay_s(255);
	  	Delay = Delay - 255;
  	}
  	if (Delay > 0)
  		delay_s(Delay & 0xFF);
}

void FCI_DELAYINTWDT_S(MX_UINT16 Delay)
{
  	while (Delay > 255)
  	{
	  	Wdt_Delay_S(255);
	  	Delay = Delay - 255;
  	}
  	if (Delay > 0)
  		Wdt_Delay_S(Delay & 0xFF);
}



/*********************************************************************
 *                  Flowcode CAL String File
 *
 * File: PIC_CAL_String.c
 *
 * (c) 2011 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * “Company”) for its Flowcode graphical programming language is
 * intended and supplied to you, the Company’s customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 010911 | BR | Created
 * 150911 | JW | Added v5 string functions
 * 270212 | BR | Fixed an issue with ToUpper where the 1st character was being returned as null
 * 120312 | BR | Fixed an issue with some of the float functions not using CAL functions
 */


// Useful call for finding the length of an (uncorrupted) string
#define FCI_GETLENGTH__x(str, max, idx)         for (idx = 0; idx < max; idx++) if (str[idx] == 0) break
#define FCI_STRMOV__x(str, max, dst, dlen, ix)  for (ix = 0; ix < (max) && ix < (dlen) && str[ix] != '\0'; ix++) dst[ix] = str[ix]
#define FCI_CONCATENATE(s0, l0, s1, l1, sd, ld) FCI_SHEAD(s0, l0, s1, l1, sd, ld)


#ifndef MX_USES_UINT32
	#define MX_USES_UINT32 0
#endif
#ifndef MX_USES_SINT32
	#define MX_USES_SINT32 0
#endif


#if (MX_USES_UINT32 || MX_USES_SINT32)
	#define MX_STRF_LONG
	#define MX_ULONG MX_UINT32
	#define MX_SLONG MX_SINT32
#else
	#define MX_ULONG MX_UINT16
	#define MX_SLONG MX_SINT16
#endif


//String function definitions
MX_UINT8 FCI_GETCHAR(MX_STRING sStr1, MX_UINT8 iStr1_len, MX_UINT8 iPos);
MX_UINT8 FCI_GETLENGTH(MX_STRING sStr1, MX_UINT8 iStr1_len);
MX_UINT8 FCI_MIDSTRING(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_UINT8 iStart, MX_UINT8 iCount, MX_STRING sDst, MX_UINT8 iDst_len);
MX_UINT8 FCI_LEFTSTRING(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_UINT8 iCount, MX_STRING sDst, MX_UINT8 iDst_len);
MX_UINT8 FCI_RIGHTSTRING(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_UINT8 iCount, MX_STRING sDst, MX_UINT8 iDst_len);
MX_UINT8 FCI_TOSTRING(MX_SLONG iSrc1, MX_STRING sDst, MX_UINT8 iDst_len);
void FCI_TOLOWER(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len);
void FCI_TOUPPER(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len);
MX_UINT8 FCI_COMPARE(MX_STRING sSrc1, MX_UINT8 iSrc1_len, MX_STRING sSrc2, MX_UINT8 iSrc2_len, MX_UINT8 iNoCase);
MX_UINT8 FCI_FLOAT_TO_STRING(MX_FLOAT Number, MX_UINT8 Precision, MX_STRING String, MX_UINT8 MSZ_String);
MX_UINT8 FCI_NUMBER_TO_HEX(MX_ULONG Number, MX_STRING String, MX_UINT8 MSZ_String);
MX_SINT32 FCI_STRING_TO_INT(MX_STRING String, MX_UINT8 MSZ_String);
MX_FLOAT FCI_STRING_TO_FLOAT(MX_STRING String, MX_UINT8 MSZ_String);

// Functions for contatenation
MX_UINT8 FCI_STRREV(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len);
MX_UINT8 FCI_STRMOV(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len);
void FCI_SHEAD(MX_STRING sSrc1, MX_UINT8 iSrc1_len, MX_STRING sSrc2, MX_UINT8 iSrc2_len, MX_STRING sDst, MX_UINT8 iDst_len);
void FCI_SCOPY(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len);



MX_UINT8 FCI_GETCHAR(MX_STRING sStr1, MX_UINT8 iStr1_len, MX_UINT8 iPos)
{
	MX_UINT8 tmp;
	FCI_GETLENGTH__x(sStr1, iStr1_len, tmp);

	if(iPos < tmp)
		return sStr1[iPos];
	return '\0';
}

MX_UINT8 FCI_GETLENGTH(MX_STRING sStr1, MX_UINT8 iStr1_len)
{
	MX_UINT8 tmp;
	FCI_GETLENGTH__x(sStr1, iStr1_len, tmp);
	return (tmp);
}

MX_UINT8 FCI_MIDSTRING(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_UINT8 iStart, MX_UINT8 iCount, MX_STRING sDst, MX_UINT8 iDst_len)
{
	if (iDst_len == 0) return 0;
	MX_UINT8 idx;
	FCI_GETLENGTH__x(sSrc, iSrc_len, idx);	//find the length of the source string

	if (iStart >= idx)
	{
		*sDst = '\0';						//starting position is beyond string length, so return a null string
	}
	else
	{
		if ((iStart + iCount) >= idx)		//Make sure the required length is not too big
			iCount = idx - iStart;
		if (iCount > (iDst_len))			//make sure the required length is not too big
			iCount = (iDst_len);

		sSrc += iStart;						//Move to the correct place in the source string

		for (idx = 0; idx < iCount; idx++)	//Copy the contents of the source string
		{
			*sDst = *sSrc;
			sDst++;
			sSrc++;
		}
		if (idx < iDst_len)						//add terminating null (if we can)
			*sDst = '\0';
	}
	return (idx);
}

MX_UINT8 FCI_LEFTSTRING(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_UINT8 iCount, MX_STRING sDst, MX_UINT8 iDst_len)
{
	if (iDst_len == 0) return 0;
	MX_UINT8 idx;
	FCI_GETLENGTH__x(sSrc, iSrc_len, idx);	//find the length of the source string

	if (iCount > idx)						//make sure the required length is not too big
		iCount = idx;
	if (iCount > (iDst_len))			//make sure the required length is not too big
		iCount = (iDst_len);

	for (idx = 0; idx < iCount; idx++)		//copy the required MX_UINT8acters
	{
		*sDst = *sSrc;
		sDst++;
		sSrc++;
	}
	if (idx < iDst_len)						//add terminating null (if we can)
		*sDst = '\0';
	return (idx);
}

MX_UINT8 FCI_RIGHTSTRING(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_UINT8 iCount, MX_STRING sDst, MX_UINT8 iDst_len)
{
	if (iDst_len == 0) return 0;
	MX_UINT8 idx;
	MX_UINT8 delta;

	FCI_GETLENGTH__x(sSrc, iSrc_len, idx);	//find the length of the source string

	if (iCount > idx)						//make sure the required length is not too big
		iCount = idx;
	delta = idx - iCount;					//get the offset
	if (iCount > (iDst_len))				//make sure the required length is not too big
		iCount = (iDst_len);
	sSrc += delta;							//Move to the correct place in the source string

	for(idx = 0; idx < iCount; idx++)		//copy the required MX_UINT8acters
	{
		*sDst = *sSrc;
		sDst++;
		sSrc++;
	}
	if (idx < iDst_len)						//add terminating null (if we can)
		*sDst = '\0';
	return (idx);
}

MX_UINT8 FCI_TOSTRING(MX_SLONG iSrc1, MX_STRING sDst, MX_UINT8 iDst_len)
{
	if (iDst_len == 0) return 0;
	MX_UINT8 tmp1;

	#ifdef MX_STRF_LONG
		unsigned long top = 1000000000; 	// Maximum power of 10 less than 4294967296
	#else
		unsigned short top = 10000; 		// Maximum power of 10 less than 65536
	#endif

	MX_UINT8 idx = 0;

	//copy source 1 into destination:
	//minus sign
	if (iSrc1 < 0)
	{
		sDst[0] = '-';
		idx++;
		iSrc1 = -iSrc1;
	}

	tmp1 = 0;    // Nothing added yet
	if (iSrc1 == 0) // Force showing zero
	{
		tmp1 = 1;
		top = 1;
	}
	while (( idx < iDst_len) && (top > 0))
	{
		#ifdef MX_STRF_LONG
		if (((unsigned long)iSrc1 >= top) || (tmp1))
		#else
		if (((unsigned)iSrc1 >= top) || (tmp1))
		#endif
		{
			#ifdef MX_STRF_LONG
			tmp1 = (unsigned long)iSrc1 / top;	// Top digit
			#else
			tmp1 = (unsigned)iSrc1 / top;	// Top digit
			#endif
			sDst[idx] = '0' + tmp1;			// Add digit to buffer
			idx++;
			iSrc1 -= tmp1 * top;			// Remove digit
			tmp1 = 1;						// Add zeros now
		}
		top /= 10;							// Go to next digit
	}

	if (idx < iDst_len)						//add terminating null (if we can)
		sDst[idx] = '\0';
	return (idx);
}



void FCI_TOLOWER(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len)
{
	if (iDst_len == 0) return;
	MX_UINT8 idx;
	MX_UINT8 ch;

	if (iSrc_len < iDst_len) iSrc_len = iDst_len; // Bound so cant overflow dest
	//copy source into destination and change to lower case
	for (idx=0; idx<iSrc_len; idx++)
	{
		ch = sSrc[idx];
		if ((ch >= 'A') && (ch <= 'Z'))
		{
			ch ^= 0x20;
		}
		sDst[idx] = ch;
		if (ch == 0)
		{
			break;
		}
	}
	if (idx < iDst_len)						//add terminating null (if we can)
		sDst[idx] = '\0';
}

void FCI_TOUPPER(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len)
{
	if (iDst_len == 0) return;
	MX_UINT8 idx;
	MX_UINT8 ch;

	if (iSrc_len < iDst_len) iSrc_len = iDst_len; // Bound so cant overflow dest
	//copy source into destination and change to upper case
	for (idx=0; idx<iSrc_len; idx++)
	{
		ch = sSrc[idx];
		if ((ch >= 'a') && (ch <= 'z'))
		{
			ch ^= 0x20;
		}
		sDst[idx] = ch;
		if (ch == 0)
		{
			break;
		}
	}
	if (idx < iDst_len)						//add terminating null (if we can)
		sDst[idx] = '\0';
}

MX_UINT8 FCI_COMPARE(MX_STRING sSrc1, MX_UINT8 iSrc1_len, MX_STRING sSrc2, MX_UINT8 iSrc2_len, MX_UINT8 iNoCase)
{
	MX_UINT8 iRetVal = 0;
	MX_UINT8 idx;
	MX_UINT8 ch1, ch2;

	for (idx=0; idx < iSrc1_len; idx++)	//compare a byte from the strings
	{
		if (idx < iSrc2_len)
		{
			ch1 = *sSrc1;
			ch2 = *sSrc2;

			if (iNoCase)
			{
				if ((ch1 >= 'a') && (ch1 <= 'z'))
					ch1 = (ch1 & 0xDF);

				if ((ch2 >= 'a') && (ch2 <= 'z'))
					ch2 = (ch2 & 0xDF);

			}

			if (ch1 < ch2)
			{
				return(255);
			}
			else if (ch1 > ch2)
			{
				return(1);
			}

			sSrc1++;
			sSrc2++;
		}
		else
		{
			if (*sSrc1 == 0)
				return (0);				//end of source1 as well, so ok
			else
				return (1);				//reached the end of iSrc2, but still more of iSrc1
		}
	}

	if (iSrc1_len == iSrc2_len)			//reached the end of iSrc1.  If we're also at the end of iSrc2, then return 0
		return (0);
	else
	{
		if (*sSrc2 == 0)
			return (0);					//end of source1 as well, so ok
		else
			return (255);				//not at end of source2, so return -1
	}
}


MX_UINT8 FCI_FLOAT_TO_STRING(MX_FLOAT Number, MX_UINT8 Precision, MX_STRING String, MX_UINT8 MSZ_String)
{
	MX_SINT16 whole;
	MX_UINT8 str_length;
	MX_UINT8 idx;
	MX_UINT8 stringidx = 0;
	MX_FLOAT real, temp;
	MX_UINT8 old;
	MX_UINT8 temp_string[10];

	#ifdef _BOOSTC									//BoostC Floating Point

		float_rounding_mode = 3;					//Always round to zero
		whole = float32_to_int32(Number);			//Convert to whole integer
		temp = float32_from_int32(whole);			//Convert whole number back to floating point

		if (float32_ge(Number,0))
		{
			real = float32_sub(Number, temp);		//Subtract whole number from floating point number
		}
		else
		{
			if (whole == 0)							//Fix -0 bug
			{
				String[stringidx] = '-';
				stringidx = stringidx + 1;
			}

			real = float32_sub(temp, Number);		//Subtract floating point number from whole number
		}
	#endif

	#ifdef HI_TECH_C								//HiTECH Floating Point

		whole = (int)Number;						//Convert to whole integer
		temp = whole;								//Convert whole number back to floating point

		if (Number >= 0)
		{
			real = Number - temp;					//Subtract whole number from floating point number
		}
		else
		{
			if (whole == 0)							//Fix -0 bug
			{
				String[stringidx] = '-';
				stringidx = stringidx + 1;
			}

			real = temp - Number;					//Subtract floating point number from whole number
		}
	#endif

	str_length = FCI_TOSTRING(whole, temp_string, 5);		//Convert integer numbers to strings

	for (idx=0; idx<str_length; idx++)						//Copy whole part of number to string
	{
		if(stringidx < MSZ_String)
		{
			String[stringidx] = temp_string[idx];
			stringidx = stringidx + 1;
		}
	}

	if(stringidx < MSZ_String)						//Add decimal point to string
	{
		String[stringidx] = '.';
		stringidx = stringidx + 1;
	}

	for (idx = 0; idx < Precision; idx++)			//Output Real Part Of Number
	{
		if (stringidx >= MSZ_String)
			break;

		#ifdef _BOOSTC								//BoostC Floating Point
			real = float32_mul(real, 10);
			whole = float32_to_int32(real);			//Convert to whole integer
			temp = float32_from_int32(whole);		//Convert whole number back to floating point
			real = float32_sub(real, temp);			//Subtract whole number from floating point number
		#endif
		#ifdef HI_TECH_C							//HiTECH Floating Point
			real = real * 10;
			whole = (int)real;						//Convert to whole integer
			temp = whole;							//Convert whole number back to floating point
			real = real - temp;						//Subtract whole number from floating point number
		#endif

		String[stringidx] = '0' + whole;
		stringidx = stringidx + 1;
	}

	if(stringidx < MSZ_String)									//Add null termination to string
	{
		String[stringidx] = 0;
	}

	return stringidx;
}











MX_UINT8 FCI_NUMBER_TO_HEX(MX_ULONG Number, MX_STRING String, MX_UINT8 MSZ_String)
{
	MX_UINT8 stringidx;
	MX_UINT8 idx = 0;
	MX_UINT8 temp;
	MX_UINT8 digit[8] = {0,0,0,0,0,0,0,0};

	#ifdef MX_STRF_LONG
		MX_UINT32 num = Number;
	#else
		MX_UINT16 num = Number;
	#endif

	//Check that output string is long enough to store result
	if((Number > 0xFFFF) && (MSZ_String < 10))
		return 0;

	if((Number > 0xFF) && (MSZ_String < 6))
		return 0;

	if((Number <= 0xFF) && (MSZ_String < 4))
		return 0;

	//Initialise start of string with hexadecimal indicator
	String[0] = '0';
	String[1] = 'x';

	//Calculate hex values
	do
	{
		temp = num % 16;
		num = num >> 4;

		if(temp > 9)
		{
			temp = temp - 10;
			digit[idx] = temp + 'A';
		}
		else
			digit[idx] = temp + '0';

		idx = idx + 1;
	} while (num > 0);

	//Copy Hex values over to output string
	for (stringidx = 2; stringidx < (idx + 2); stringidx++)
		String[stringidx] = digit[idx - (stringidx - 1)];

	//Add null termination to string
	if(stringidx < MSZ_String)
	{
		String[stringidx] = 0;
	}

	return stringidx;
}


MX_SINT32 FCI_STRING_TO_INT(MX_STRING String, MX_UINT8 MSZ_String)
{
	MX_UINT8 bNegative = 0;
	MX_UINT8 idx = 0;
	MX_SINT32 RetVal = 0;

	//Is number negative
	if(String[0] == '-')
	{
		bNegative = 1;
		idx = 1;
	}

	//While string contains a valid number
	while (idx < MSZ_String && String[idx] >= '0' && String[idx] <= '9')
	{
		//Pull MX_UINT8acter from string and add to running total
		RetVal = (long) RetVal * 10;
		RetVal = (long) RetVal + (String[idx] - '0');
		idx = idx + 1;
	}

	if (bNegative)
		RetVal = (long) 0 - RetVal;

	return RetVal;
}


MX_FLOAT FCI_STRING_TO_FLOAT(MX_STRING String, MX_UINT8 MSZ_String)
{
	MX_FLOAT RetVal = 0;
	MX_FLOAT real_divider = 1;
	MX_UINT32 whole, real;			//Changed from INT 23/07/10
	MX_UINT8 idx = 0;
	MX_UINT8 idx2 = 0;
	MX_UINT8 offset = 0;
	MX_UINT8 bNegative = 0;
	MX_UINT8 Comp_String[8];

	//Is number negative
	if(String[0] == '-')
	{
		bNegative = 1;
		offset = 1;
	}

	//Scan for decimal point
	for(idx=offset; idx<MSZ_String; idx++)
	{
		if(String[idx] == '.')
			break;
	}

	//Convert whole portion of number from string
	whole = FCI_STRING_TO_INT (String, idx);

	//No decimal point found
	if(idx == MSZ_String)
	{
		#ifdef _BOOSTC
			RetVal = float32_from_int32(whole);
		#endif
		#ifdef HI_TECH_C
			RetVal = (int)whole;
		#endif
		return RetVal;
	}

	//Collect real portion of number into new string
	offset = idx + 1;
	for(idx=offset; idx<MSZ_String; idx++)
	{
		if(String[idx] >= '0' && String[idx] <= '9')
		{
			Comp_String[idx - offset] = String[idx];
			#ifdef _BOOSTC
				real_divider = float32_mul(real_divider, 0.1);
			#endif
			#ifdef HI_TECH_C
				real_divider = real_divider * 0.1;
			#endif
		}
		else
			break;
	}

	//Convert real portion of number from string
	real = FCI_STRING_TO_INT (Comp_String, (idx - offset));

	//Adjust weighting of values and combine into one float variable
	#ifdef _BOOSTC

		RetVal = float32_from_int32(real);
		RetVal = float32_mul(RetVal, real_divider);
		real_divider = float32_from_int32(whole);
		RetVal = float32_add(RetVal, real_divider);

		if (bNegative)
			RetVal = float32_sub(0, RetVal);

	#endif
	#ifdef HI_TECH_C

		RetVal = (MX_FLOAT)real;
		RetVal = RetVal * real_divider;
		real_divider = (MX_FLOAT)whole;
		RetVal = RetVal + real_divider;

		if (bNegative)
			RetVal = 0 - RetVal;
	#endif

	return RetVal;
}



/*=----------------------------------------------------------------------=*\
   Use :Move but do not null-terminate sSrc to sDst, max len iSrc_len
       :This differs from FCI_STRMOV() in that the bytes are copied from the
       :end of the string to the start
       :Returns length of copy
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCI_STRREV(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len)
{
  MX_UINT8 ix, len;
  FCI_GETLENGTH__x(sSrc, iSrc_len, len);
  if (len > iDst_len)
  {
    len = iDst_len;
  }
  ix = len;
  while (ix > 0)
  {
    ix--;
    sDst[ix] = sSrc[ix];
  }
  // No null terminate
  // Return length of string
  return len;
}


/*=----------------------------------------------------------------------=*\
   Use :Move but do not null-terminate sSrc to sDst, max len iSrc_len
       :Returns length of copy
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCI_STRMOV(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len)
{
  MX_UINT8 ix;
  ix = 0;
  while (ix < iSrc_len && ix < iDst_len && sSrc[ix] != '\0')
  {
    sDst[ix] = sSrc[ix];
    ix++;
  }
  // No null terminate
  // Return length of string
  return ix;
}

/*=----------------------------------------------------------------------=*\
   Use :Concatenate sDst = (sSrc1 + sSrc2)
       :sDst is only null terminated if the concat doesnt overflow
       :
\*=----------------------------------------------------------------------=*/
void FCI_SHEAD(MX_STRING sSrc1, MX_UINT8 iSrc1_len, MX_STRING sSrc2, MX_UINT8 iSrc2_len, MX_STRING sDst, MX_UINT8 iDst_len)

{
  MX_UINT8 len, strt;

  len = 0;
0125  01DB  	CLRF FCI_SHEAD_00000_1_len

  if (sSrc2 == sDst)
0126  0858  	MOVF FCI_SHEAD_00000_arg_sDst, W
0127  0655  	XORWF FCI_SHEAD_00000_arg_sSrc2, W
0128  1D03  	BTFSS STATUS,Z
0129  29CC  	GOTO	label32
012A  0859  	MOVF FCI_SHEAD_00000_arg_sDst+D'1', W
012B  0656  	XORWF FCI_SHEAD_00000_arg_sSrc2+D'1', W
012C  1D03  	BTFSS STATUS,Z
012D  29CC  	GOTO	label32
01CC        label32

  {
    FCI_GETLENGTH__x(sSrc1, iSrc1_len, strt);
012E  01DC  	CLRF FCI_SHEAD_00000_1_strt
012F        label21
012F  0854  	MOVF FCI_SHEAD_00000_arg_iSrc1_len, W
0130  025C  	SUBWF FCI_SHEAD_00000_1_strt, W
0131  1803  	BTFSC STATUS,C
0132  293E  	GOTO	label22
0133  1383  	BCF STATUS,IRP
0134  1853  	BTFSC FCI_SHEAD_00000_arg_sSrc1+D'1',0
0135  1783  	BSF STATUS,IRP
0136  0852  	MOVF FCI_SHEAD_00000_arg_sSrc1, W
0137  075C  	ADDWF FCI_SHEAD_00000_1_strt, W
0138  0084  	MOVWF FSR
0139  0880  	MOVF INDF, F
013A  1903  	BTFSC STATUS,Z
013B  293E  	GOTO	label22
013C  0ADC  	INCF FCI_SHEAD_00000_1_strt, F
013D  292F  	GOTO	label21
013E        label22
01CB  29A6  	GOTO	label31

    if (strt < iDst_len)
013E  085A  	MOVF FCI_SHEAD_00000_arg_iDst_len, W
013F  025C  	SUBWF FCI_SHEAD_00000_1_strt, W
0140  1803  	BTFSC STATUS,C
0141  29A5  	GOTO	label30
01A5        label30

    {
      // Copy second, in reverse
      // len = FCI_STRREV(sSrc2, iSrc2_len, sDst + strt, iDst_len - strt);
      FCI_GETLENGTH__x(sSrc2, iSrc2_len, len);
0142  01DB  	CLRF FCI_SHEAD_00000_1_len
0143        label23
0143  0857  	MOVF FCI_SHEAD_00000_arg_iSrc2_len, W
0144  025B  	SUBWF FCI_SHEAD_00000_1_len, W
0145  1803  	BTFSC STATUS,C
0146  2952  	GOTO	label24
0147  1383  	BCF STATUS,IRP
0148  1856  	BTFSC FCI_SHEAD_00000_arg_sSrc2+D'1',0
0149  1783  	BSF STATUS,IRP
014A  0855  	MOVF FCI_SHEAD_00000_arg_sSrc2, W
014B  075B  	ADDWF FCI_SHEAD_00000_1_len, W
014C  0084  	MOVWF FSR
014D  0880  	MOVF INDF, F
014E  1903  	BTFSC STATUS,Z
014F  2952  	GOTO	label24
0150  0ADB  	INCF FCI_SHEAD_00000_1_len, F
0151  2943  	GOTO	label23
0152        label24

      if (len > (iDst_len - strt))
0152  085C  	MOVF FCI_SHEAD_00000_1_strt, W
0153  025A  	SUBWF FCI_SHEAD_00000_arg_iDst_len, W
0154  00DD  	MOVWF CompTempVar2110
0155  085B  	MOVF FCI_SHEAD_00000_1_len, W
0156  025D  	SUBWF CompTempVar2110, W
0157  1803  	BTFSC STATUS,C
0158  295C  	GOTO	label25
015C        label25

      {
        len = (iDst_len - strt); // Length of string to copy to
0159  085C  	MOVF FCI_SHEAD_00000_1_strt, W
015A  025A  	SUBWF FCI_SHEAD_00000_arg_iDst_len, W
015B  00DB  	MOVWF FCI_SHEAD_00000_1_len

      }
      iSrc2_len = strt + len; // Use no longer needed var as an offset
015C  085B  	MOVF FCI_SHEAD_00000_1_len, W
015D  075C  	ADDWF FCI_SHEAD_00000_1_strt, W
015E  00D7  	MOVWF FCI_SHEAD_00000_arg_iSrc2_len

      strt = len;
015F  085B  	MOVF FCI_SHEAD_00000_1_len, W
0160  00DC  	MOVWF FCI_SHEAD_00000_1_strt

      while (strt > 0)
0161        label26
0161  085C  	MOVF FCI_SHEAD_00000_1_strt, W
0162  3C00  	SUBLW 0x00
0163  1803  	BTFSC STATUS,C
0164  297B  	GOTO	label27
017A  2961  	GOTO	label26
017B        label27

      {
        strt--;
0165  03DC  	DECF FCI_SHEAD_00000_1_strt, F

        iSrc2_len--;
0166  03D7  	DECF FCI_SHEAD_00000_arg_iSrc2_len, F

        sDst[iSrc2_len] = sSrc2[strt];
0167  1383  	BCF STATUS,IRP
0168  1856  	BTFSC FCI_SHEAD_00000_arg_sSrc2+D'1',0
0169  1783  	BSF STATUS,IRP
016A  0855  	MOVF FCI_SHEAD_00000_arg_sSrc2, W
016B  0084  	MOVWF FSR
016C  085C  	MOVF FCI_SHEAD_00000_1_strt, W
016D  00DE  	MOVWF CompTempVar2117
016E  085E  	MOVF CompTempVar2117, W
016F  0784  	ADDWF FSR, F
0170  0800  	MOVF INDF, W
0171  00DF  	MOVWF CompTempVar2118
0172  1383  	BCF STATUS,IRP
0173  1859  	BTFSC FCI_SHEAD_00000_arg_sDst+D'1',0
0174  1783  	BSF STATUS,IRP
0175  0858  	MOVF FCI_SHEAD_00000_arg_sDst, W
0176  0757  	ADDWF FCI_SHEAD_00000_arg_iSrc2_len, W
0177  0084  	MOVWF FSR
0178  085F  	MOVF CompTempVar2118, W
0179  0080  	MOVWF INDF

      }
      // Move first
      FCI_STRMOV__x(sSrc1, iSrc1_len, sDst, iDst_len, strt);
017B  01DC  	CLRF FCI_SHEAD_00000_1_strt
017C        label28
017C  0854  	MOVF FCI_SHEAD_00000_arg_iSrc1_len, W
017D  025C  	SUBWF FCI_SHEAD_00000_1_strt, W
017E  1803  	BTFSC STATUS,C
017F  29A2  	GOTO	label29
0180  085A  	MOVF FCI_SHEAD_00000_arg_iDst_len, W
0181  025C  	SUBWF FCI_SHEAD_00000_1_strt, W
0182  1803  	BTFSC STATUS,C
0183  29A2  	GOTO	label29
0184  1383  	BCF STATUS,IRP
0185  1853  	BTFSC FCI_SHEAD_00000_arg_sSrc1+D'1',0
0186  1783  	BSF STATUS,IRP
0187  0852  	MOVF FCI_SHEAD_00000_arg_sSrc1, W
0188  075C  	ADDWF FCI_SHEAD_00000_1_strt, W
0189  0084  	MOVWF FSR
018A  0880  	MOVF INDF, F
018B  1903  	BTFSC STATUS,Z
018C  29A2  	GOTO	label29
018D  1383  	BCF STATUS,IRP
018E  1853  	BTFSC FCI_SHEAD_00000_arg_sSrc1+D'1',0
018F  1783  	BSF STATUS,IRP
0190  0852  	MOVF FCI_SHEAD_00000_arg_sSrc1, W
0191  0084  	MOVWF FSR
0192  085C  	MOVF FCI_SHEAD_00000_1_strt, W
0193  00DE  	MOVWF CompTempVar2121
0194  085E  	MOVF CompTempVar2121, W
0195  0784  	ADDWF FSR, F
0196  0800  	MOVF INDF, W
0197  00DF  	MOVWF CompTempVar2122
0198  1383  	BCF STATUS,IRP
0199  1859  	BTFSC FCI_SHEAD_00000_arg_sDst+D'1',0
019A  1783  	BSF STATUS,IRP
019B  0858  	MOVF FCI_SHEAD_00000_arg_sDst, W
019C  075C  	ADDWF FCI_SHEAD_00000_1_strt, W
019D  0084  	MOVWF FSR
019E  085F  	MOVF CompTempVar2122, W
019F  0080  	MOVWF INDF
01A0  0ADC  	INCF FCI_SHEAD_00000_1_strt, F
01A1  297C  	GOTO	label28
01A2        label29

      len += strt;
01A2  085C  	MOVF FCI_SHEAD_00000_1_strt, W
01A3  07DB  	ADDWF FCI_SHEAD_00000_1_len, F

    }
    else
01A4  2A2E  	GOTO	label37

    {
      // Copy first
      FCI_STRMOV__x(sSrc1, iSrc1_len, sDst, iDst_len, len);
01A5  01DB  	CLRF FCI_SHEAD_00000_1_len
01A6        label31
01A6  0854  	MOVF FCI_SHEAD_00000_arg_iSrc1_len, W
01A7  025B  	SUBWF FCI_SHEAD_00000_1_len, W
01A8  1803  	BTFSC STATUS,C
01A9  2A2E  	GOTO	label37
01AA  085A  	MOVF FCI_SHEAD_00000_arg_iDst_len, W
01AB  025B  	SUBWF FCI_SHEAD_00000_1_len, W
01AC  1803  	BTFSC STATUS,C
01AD  2A2E  	GOTO	label37
01AE  1383  	BCF STATUS,IRP
01AF  1853  	BTFSC FCI_SHEAD_00000_arg_sSrc1+D'1',0
01B0  1783  	BSF STATUS,IRP
01B1  0852  	MOVF FCI_SHEAD_00000_arg_sSrc1, W
01B2  075B  	ADDWF FCI_SHEAD_00000_1_len, W
01B3  0084  	MOVWF FSR
01B4  0880  	MOVF INDF, F
01B5  1903  	BTFSC STATUS,Z
01B6  2A2E  	GOTO	label37
01B7  1383  	BCF STATUS,IRP
01B8  1853  	BTFSC FCI_SHEAD_00000_arg_sSrc1+D'1',0
01B9  1783  	BSF STATUS,IRP
01BA  0852  	MOVF FCI_SHEAD_00000_arg_sSrc1, W
01BB  0084  	MOVWF FSR
01BC  085B  	MOVF FCI_SHEAD_00000_1_len, W
01BD  00DD  	MOVWF CompTempVar2129
01BE  085D  	MOVF CompTempVar2129, W
01BF  0784  	ADDWF FSR, F
01C0  0800  	MOVF INDF, W
01C1  00DE  	MOVWF CompTempVar2130
01C2  1383  	BCF STATUS,IRP
01C3  1859  	BTFSC FCI_SHEAD_00000_arg_sDst+D'1',0
01C4  1783  	BSF STATUS,IRP
01C5  0858  	MOVF FCI_SHEAD_00000_arg_sDst, W
01C6  075B  	ADDWF FCI_SHEAD_00000_1_len, W
01C7  0084  	MOVWF FSR
01C8  085E  	MOVF CompTempVar2130, W
01C9  0080  	MOVWF INDF
01CA  0ADB  	INCF FCI_SHEAD_00000_1_len, F

    }
  }
  else
  {
    // Copy first
    FCI_STRMOV__x(sSrc1, iSrc1_len, sDst, iDst_len, len);
01CC  01DB  	CLRF FCI_SHEAD_00000_1_len
01CD        label33
01CD  0854  	MOVF FCI_SHEAD_00000_arg_iSrc1_len, W
01CE  025B  	SUBWF FCI_SHEAD_00000_1_len, W
01CF  1803  	BTFSC STATUS,C
01D0  29F3  	GOTO	label34
01D1  085A  	MOVF FCI_SHEAD_00000_arg_iDst_len, W
01D2  025B  	SUBWF FCI_SHEAD_00000_1_len, W
01D3  1803  	BTFSC STATUS,C
01D4  29F3  	GOTO	label34
01D5  1383  	BCF STATUS,IRP
01D6  1853  	BTFSC FCI_SHEAD_00000_arg_sSrc1+D'1',0
01D7  1783  	BSF STATUS,IRP
01D8  0852  	MOVF FCI_SHEAD_00000_arg_sSrc1, W
01D9  075B  	ADDWF FCI_SHEAD_00000_1_len, W
01DA  0084  	MOVWF FSR
01DB  0880  	MOVF INDF, F
01DC  1903  	BTFSC STATUS,Z
01DD  29F3  	GOTO	label34
01DE  1383  	BCF STATUS,IRP
01DF  1853  	BTFSC FCI_SHEAD_00000_arg_sSrc1+D'1',0
01E0  1783  	BSF STATUS,IRP
01E1  0852  	MOVF FCI_SHEAD_00000_arg_sSrc1, W
01E2  0084  	MOVWF FSR
01E3  085B  	MOVF FCI_SHEAD_00000_1_len, W
01E4  00DD  	MOVWF CompTempVar2137
01E5  085D  	MOVF CompTempVar2137, W
01E6  0784  	ADDWF FSR, F
01E7  0800  	MOVF INDF, W
01E8  00DE  	MOVWF CompTempVar2138
01E9  1383  	BCF STATUS,IRP
01EA  1859  	BTFSC FCI_SHEAD_00000_arg_sDst+D'1',0
01EB  1783  	BSF STATUS,IRP
01EC  0858  	MOVF FCI_SHEAD_00000_arg_sDst, W
01ED  075B  	ADDWF FCI_SHEAD_00000_1_len, W
01EE  0084  	MOVWF FSR
01EF  085E  	MOVF CompTempVar2138, W
01F0  0080  	MOVWF INDF
01F1  0ADB  	INCF FCI_SHEAD_00000_1_len, F
01F2  29CD  	GOTO	label33
01F3        label34

    // Copy second
    if (len < iDst_len)
01F3  085A  	MOVF FCI_SHEAD_00000_arg_iDst_len, W
01F4  025B  	SUBWF FCI_SHEAD_00000_1_len, W
01F5  1803  	BTFSC STATUS,C
01F6  2A2E  	GOTO	label37
022E        label37

    {
      sSrc1 = sDst + len; // make temp copies in no longer used variables
01F7  085B  	MOVF FCI_SHEAD_00000_1_len, W
01F8  0758  	ADDWF FCI_SHEAD_00000_arg_sDst, W
01F9  00DD  	MOVWF CompTempVar2143
01FA  0859  	MOVF FCI_SHEAD_00000_arg_sDst+D'1', W
01FB  00DE  	MOVWF CompTempVar2144
01FC  1803  	BTFSC STATUS,C
01FD  0ADE  	INCF CompTempVar2144, F
01FE  085D  	MOVF CompTempVar2143, W
01FF  00D2  	MOVWF FCI_SHEAD_00000_arg_sSrc1
0200  085E  	MOVF CompTempVar2144, W
0201  00D3  	MOVWF FCI_SHEAD_00000_arg_sSrc1+D'1'

      iSrc1_len = iDst_len - len;
0202  085B  	MOVF FCI_SHEAD_00000_1_len, W
0203  025A  	SUBWF FCI_SHEAD_00000_arg_iDst_len, W
0204  00D4  	MOVWF FCI_SHEAD_00000_arg_iSrc1_len

      FCI_STRMOV__x(sSrc2, iSrc2_len, sSrc1, iSrc1_len, strt);
0205  01DC  	CLRF FCI_SHEAD_00000_1_strt
0206        label35
0206  0857  	MOVF FCI_SHEAD_00000_arg_iSrc2_len, W
0207  025C  	SUBWF FCI_SHEAD_00000_1_strt, W
0208  1803  	BTFSC STATUS,C
0209  2A2C  	GOTO	label36
020A  0854  	MOVF FCI_SHEAD_00000_arg_iSrc1_len, W
020B  025C  	SUBWF FCI_SHEAD_00000_1_strt, W
020C  1803  	BTFSC STATUS,C
020D  2A2C  	GOTO	label36
020E  1383  	BCF STATUS,IRP
020F  1856  	BTFSC FCI_SHEAD_00000_arg_sSrc2+D'1',0
0210  1783  	BSF STATUS,IRP
0211  0855  	MOVF FCI_SHEAD_00000_arg_sSrc2, W
0212  075C  	ADDWF FCI_SHEAD_00000_1_strt, W
0213  0084  	MOVWF FSR
0214  0880  	MOVF INDF, F
0215  1903  	BTFSC STATUS,Z
0216  2A2C  	GOTO	label36
0217  1383  	BCF STATUS,IRP
0218  1856  	BTFSC FCI_SHEAD_00000_arg_sSrc2+D'1',0
0219  1783  	BSF STATUS,IRP
021A  0855  	MOVF FCI_SHEAD_00000_arg_sSrc2, W
021B  0084  	MOVWF FSR
021C  085C  	MOVF FCI_SHEAD_00000_1_strt, W
021D  00DD  	MOVWF CompTempVar2147
021E  085D  	MOVF CompTempVar2147, W
021F  0784  	ADDWF FSR, F
0220  0800  	MOVF INDF, W
0221  00DE  	MOVWF CompTempVar2148
0222  1383  	BCF STATUS,IRP
0223  1853  	BTFSC FCI_SHEAD_00000_arg_sSrc1+D'1',0
0224  1783  	BSF STATUS,IRP
0225  0852  	MOVF FCI_SHEAD_00000_arg_sSrc1, W
0226  075C  	ADDWF FCI_SHEAD_00000_1_strt, W
0227  0084  	MOVWF FSR
0228  085E  	MOVF CompTempVar2148, W
0229  0080  	MOVWF INDF
022A  0ADC  	INCF FCI_SHEAD_00000_1_strt, F
022B  2A06  	GOTO	label35
022C        label36

      len += strt;
022C  085C  	MOVF FCI_SHEAD_00000_1_strt, W
022D  07DB  	ADDWF FCI_SHEAD_00000_1_len, F

    }
  }
  // Terminate (only if can)
  if (len < iDst_len)
022E  085A  	MOVF FCI_SHEAD_00000_arg_iDst_len, W
022F  025B  	SUBWF FCI_SHEAD_00000_1_len, W
0230  1803  	BTFSC STATUS,C

  {
    sDst[len] = '\0';
0232  1383  	BCF STATUS,IRP
0233  1859  	BTFSC FCI_SHEAD_00000_arg_sDst+D'1',0
0234  1783  	BSF STATUS,IRP
0235  0858  	MOVF FCI_SHEAD_00000_arg_sDst, W
0236  075B  	ADDWF FCI_SHEAD_00000_1_len, W
0237  0084  	MOVWF FSR
0238  3000  	MOVLW 0x00
0239  0080  	MOVWF INDF

  }
}
0231  0008  	RETURN
023A  0008  	RETURN



/*=----------------------------------------------------------------------=*\
   Use :Copy and null-terminate sSrc to sDst, max len iSrc_len
       :sDst is only null terminated if the concat doesnt overflow
       :
\*=----------------------------------------------------------------------=*/
void FCI_SCOPY(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len)

{
  MX_UINT8 len;

  // Move first
  FCI_STRMOV__x(sSrc, iSrc_len, sDst, iDst_len, len);
023B  01E9  	CLRF FCI_SCOPY_00000_1_len
023C        label38
023C  0865  	MOVF FCI_SCOPY_00000_arg_iSrc_len, W
023D  0269  	SUBWF FCI_SCOPY_00000_1_len, W
023E  1803  	BTFSC STATUS,C
023F  2A62  	GOTO	label39
0240  0868  	MOVF FCI_SCOPY_00000_arg_iDst_len, W
0241  0269  	SUBWF FCI_SCOPY_00000_1_len, W
0242  1803  	BTFSC STATUS,C
0243  2A62  	GOTO	label39
0244  1383  	BCF STATUS,IRP
0245  1853  	BTFSC FCI_SCOPY_00000_arg_sSrc+D'1',0
0246  1783  	BSF STATUS,IRP
0247  0852  	MOVF FCI_SCOPY_00000_arg_sSrc, W
0248  0769  	ADDWF FCI_SCOPY_00000_1_len, W
0249  0084  	MOVWF FSR
024A  0880  	MOVF INDF, F
024B  1903  	BTFSC STATUS,Z
024C  2A62  	GOTO	label39
024D  1383  	BCF STATUS,IRP
024E  1853  	BTFSC FCI_SCOPY_00000_arg_sSrc+D'1',0
024F  1783  	BSF STATUS,IRP
0250  0852  	MOVF FCI_SCOPY_00000_arg_sSrc, W
0251  0084  	MOVWF FSR
0252  0869  	MOVF FCI_SCOPY_00000_1_len, W
0253  00EA  	MOVWF CompTempVar2156
0254  086A  	MOVF CompTempVar2156, W
0255  0784  	ADDWF FSR, F
0256  0800  	MOVF INDF, W
0257  00EB  	MOVWF CompTempVar2157
0258  1383  	BCF STATUS,IRP
0259  1867  	BTFSC FCI_SCOPY_00000_arg_sDst+D'1',0
025A  1783  	BSF STATUS,IRP
025B  0866  	MOVF FCI_SCOPY_00000_arg_sDst, W
025C  0769  	ADDWF FCI_SCOPY_00000_1_len, W
025D  0084  	MOVWF FSR
025E  086B  	MOVF CompTempVar2157, W
025F  0080  	MOVWF INDF
0260  0AE9  	INCF FCI_SCOPY_00000_1_len, F
0261  2A3C  	GOTO	label38
0262        label39

  // Terminate (only if can)
  if (len < iDst_len)
0262  0868  	MOVF FCI_SCOPY_00000_arg_iDst_len, W
0263  0269  	SUBWF FCI_SCOPY_00000_1_len, W
0264  1803  	BTFSC STATUS,C

  {
    sDst[len] = '\0';
0266  1383  	BCF STATUS,IRP
0267  1867  	BTFSC FCI_SCOPY_00000_arg_sDst+D'1',0
0268  1783  	BSF STATUS,IRP
0269  0866  	MOVF FCI_SCOPY_00000_arg_sDst, W
026A  0769  	ADDWF FCI_SCOPY_00000_1_len, W
026B  0084  	MOVWF FSR
026C  3000  	MOVLW 0x00
026D  0080  	MOVWF INDF

  }
}
0265  0008  	RETURN
026E  0008  	RETURN





//************************************************************************************
//**  
//**  File name:     C:\Users\gerpe\OneDrive\GER-PER 2016\Documents\KennyNeutron\2020\RF\NRF_test2\NRF_Lib.c
//**  Title:         
//**  Description:   
//**  
//**  Generated by:  Flowcode v5.2.0.0
//**  Date:          Friday, August 07, 2020 20:49:14
//**  Licence:       Professional
//**  Registered to: xyz
//**  Licence key:   WUK7B9
//**  
//**  
//**  http://www.matrixmultimedia.com
//**  
//************************************************************************************


#define MX_PIC

#define MX_USES_UINT8 1
#define MX_USES_SINT16 0
#define MX_USES_CHAR 2
#define MX_USES_FLOAT 0
#define MX_USES_SINT32 0
#define MX_USES_BOOL 1
#define MX_USES_UINT16 0
#define MX_USES_UINT32 0
//Defines for microcontroller
#define P16F873A
#define FC_CAL_PIC
#define MX_ADC
#define MX_ADC_TYPE_1
#define MX_ADC_BITS_10
#define MX_EE
#define MX_EE_TYPE2
#define MX_EE_SIZE 128
#define MX_SPI_1
#define MX_SPI_1_MISO_PORT portc
#define MX_SPI_1_MISO_TRIS trisc
#define MX_SPI_1_MISO_PIN 4
#define MX_SPI_1_MOSI_PORT portc
#define MX_SPI_1_MOSI_TRIS trisc
#define MX_SPI_1_MOSI_PIN 5
#define MX_SPI_1_CLK_PORT portc
#define MX_SPI_1_CLK_TRIS trisc
#define MX_SPI_1_CLK_PIN 3
#define MX_SPI_1_SS_PORT portc
#define MX_SPI_1_SS_TRIS trisc
#define MX_UART_1
#define MX_UART_1_TX_PORT portc
#define MX_UART_1_TX_TRIS trisc
#define MX_UART_1_TX_PIN 6
#define MX_UART_1_RX_PORT portc
#define MX_UART_1_RX_TRIS trisc
#define MX_UART_1_RX_PIN 7
#define MX_I2C
#define MX_MI2C
#define MX_I2C_1
#define MX_I2C_1_SDA_PORT portc
#define MX_I2C_1_SDA_TRIS trisc
#define MX_I2C_1_SDA_PIN 4
#define MX_I2C_1_SCL_PORT portc
#define MX_I2C_1_SCL_TRIS trisc
#define MX_I2C_1_SCL_PIN 3
#define MX_PWM
#define MX_PWM_CNT 2
#define MX_PWM_PSCA1
#define MX_PWM_PSCA4
#define MX_PWM_PSCA16
#define MX_PWM_1_PORT portc
#define MX_PWM_1_TRIS trisc
#define MX_PWM_1_PIN 2
#define MX_PWM_2_PORT portc
#define MX_PWM_2_TRIS trisc
#define MX_PWM_2_PIN 1

//Functions
#define MX_CLK_SPEED 20000000
#ifdef _BOOSTC
#include <system.h>
#endif
#ifdef HI_TECH_C
#include <pic.h>
#endif

//Configuration data
#ifdef _BOOSTC
#pragma DATA 0x2007, 0x3f32
#endif
#ifdef HI_TECH_C
__CONFIG(0x3f32);
#endif

//Internal functions
#include "C:\Program Files (x86)\Flowcode\v5\FCD\internals.c"

//Macro function declarations
void FCM_spi_nrf_reg_read();
void FCM_cmd_read_reg();
void FCM_lcd_line0();
void FCM_lcd_line1();
void FCM_lcd_line2();
void FCM_cmd_read_rx_addr();
void FCM_cmd_read_tx_addr();
void FCM_lcd_line3();
void FCM_nrf_tx_init();
void FCM_cmd_write_reg();
void FCM_set_tx_addr();
void FCM_set_rx_addr();
void FCM_radio_send_data();
void FCM_flush_fifo_txrx();
void FCM_nrf_rx_init();
void FCM_show_status();
void FCM_radio_recieve_data();
void FCM_tx_addr_to_string();
void FCM_rx_addr_to_string();
void FCM_disp_datarx();
void FCM_check_status();
void FCM_print_display();
void FCM_read_recieved_data();
void FCM_disp_datatx();


//Variable declarations
#define FCSZ_PAYLOAD_RECIEVE 16
#define FCSZ_PAYLOAD_TRANSMIT 16
#define FCSZ_RX_ADDR 16
#define FCSZ_TX_ADDR 16
#define FCV_TRUE (1)
#define FCV_FALSE (0)
MX_UINT8 FCV_DATA_TO_WRITE = (0xff);
085E  30FF  	MOVLW 0xFF
085F  1683  	BSF STATUS, RP0
0860  00A3  	MOVWF gbl_FCV_DATA_TO_WRITE

MX_UINT8 FCV_REG10_TX_ADDR_BYTE1 = (0x0);
0861  01A4  	CLRF gbl_FCV_REG10_TX_ADDR_BYTE1

MX_UINT8 FCV_REG00_CONFIG = (0x0);
0862  01A5  	CLRF gbl_FCV_REG00_CONFIG

MX_UINT8 FCV_REG12_RX_PW_P1 = (0x0);
0863  01A6  	CLRF gbl_FCV_REG12_RX_PW_P1

MX_UINT8 FCV_REG10_TX_ADDR_BYTE2 = (0x0);
0864  01A7  	CLRF gbl_FCV_REG10_TX_ADDR_BYTE2

MX_UINT8 FCV_REG09_CD = (0x0);
0865  01A8  	CLRF gbl_FCV_REG09_CD

MX_UINT8 FCV_REG15_RX_PW_P4 = (0x0);
0866  01A9  	CLRF gbl_FCV_REG15_RX_PW_P4

MX_UINT8 FCV_REG10_TX_ADDR_BYTE3 = (0x0);
0867  01AA  	CLRF gbl_FCV_REG10_TX_ADDR_BYTE3

MX_CHAR FCV_PAYLOAD_RECIEVE[FCSZ_PAYLOAD_RECIEVE];
MX_UINT8 FCV_REG10_TX_ADDR_BYTE4 = (0x0);
0868  01AB  	CLRF gbl_FCV_REG10_TX_ADDR_BYTE4

MX_UINT8 FCV_REG0C_RX_ADDR_P2 = (0x0);
0869  01AC  	CLRF gbl_FCV_REG0C_RX_ADDR_P2

MX_UINT8 FCV_REG0F_RX_ADDR_P5 = (0x0);
086A  01AD  	CLRF gbl_FCV_REG0F_RX_ADDR_P5

MX_UINT8 FCV_STATUS_MAX_RT = (0x0);
086B  01AE  	CLRF gbl_FCV_STATUS_MAX_RT

MX_UINT8 FCV_REG17_FIFO_STATUS = (0x0);
086C  01AF  	CLRF gbl_FCV_REG17_FIFO_STATUS

MX_UINT8 FCV_SPI_DATA0 = (0xff);
086D  30FF  	MOVLW 0xFF
086E  00B0  	MOVWF gbl_FCV_SPI_DATA0

MX_UINT8 FCV_SPI_DATA1 = (0xff);
086F  30FF  	MOVLW 0xFF
0870  00B1  	MOVWF gbl_FCV_SPI_DATA1

MX_UINT8 FCV_DATA_TO_READ = (0x0);
0871  01B2  	CLRF gbl_FCV_DATA_TO_READ

MX_UINT8 FCV_REG1D_FEATURE = (0x0);
0872  01B3  	CLRF gbl_FCV_REG1D_FEATURE

MX_UINT8 FCV_REG13_RX_PW_P2 = (0x0);
0873  01B4  	CLRF gbl_FCV_REG13_RX_PW_P2

MX_CHAR FCV_PAYLOAD_TRANSMIT[FCSZ_PAYLOAD_TRANSMIT];
MX_UINT8 FCV_REG0A_RX_ADDR_P0_BYTE0 = (0x0);
0874  01B5  	CLRF gbl_FCV_REG0A_RX_ADDR_P0_BYTE0

MX_UINT8 FCV_REG16_RX_PW_P5 = (0x0);
0875  01B6  	CLRF gbl_FCV_REG16_RX_PW_P5

MX_UINT8 FCV_STATUS_RX_DR;
MX_UINT8 FCV_REG1C_DYNPD = (0x0);
0876  01B7  	CLRF gbl_FCV_REG1C_DYNPD

MX_UINT8 FCV_REG0A_RX_ADDR_P0_BYTE1 = (0x0);
0877  01B8  	CLRF gbl_FCV_REG0A_RX_ADDR_P0_BYTE1

MX_UINT8 FCV_REG05_RF_CH = (0x0);
0878  01B9  	CLRF gbl_FCV_REG05_RF_CH

MX_UINT8 FCV_REG07_STATUS = (0x0);
0879  01BA  	CLRF gbl_FCV_REG07_STATUS

MX_UINT8 FCV_REG0A_RX_ADDR_P0_BYTE2 = (0x0);
087A  01BB  	CLRF gbl_FCV_REG0A_RX_ADDR_P0_BYTE2

MX_UINT8 FCV_REG02_EN_RXADDR = (0x0);
087B  01BC  	CLRF gbl_FCV_REG02_EN_RXADDR

MX_UINT8 FCV_REG0D_RX_ADDR_P3 = (0x0);
087C  01BD  	CLRF gbl_FCV_REG0D_RX_ADDR_P3

MX_UINT8 FCV_STATUS_TX_DS = (0x0);
087D  01BE  	CLRF gbl_FCV_STATUS_TX_DS

MX_BOOL FCV_SW0 = (1);
087E  143F  	BSF gbl_FCV_SW0,0

MX_UINT8 FCV_REG0A_RX_ADDR_P0_BYTE3 = (0x0);
087F  01C0  	CLRF gbl_FCV_REG0A_RX_ADDR_P0_BYTE3

MX_UINT8 FCV_REG01_ENAA = (0x0);
0880  01C1  	CLRF gbl_FCV_REG01_ENAA

MX_UINT8 FCV_REG08_OBSERVE = (0x0);
0881  01C2  	CLRF gbl_FCV_REG08_OBSERVE

MX_UINT8 FCV_REG_TO_WRITE = (0x0);
0882  01C3  	CLRF gbl_FCV_REG_TO_WRITE

MX_UINT8 FCV_REG0A_RX_ADDR_P0_BYTE4 = (0x0);
0883  01C4  	CLRF gbl_FCV_REG0A_RX_ADDR_P0_BYTE4

MX_UINT8 FCV_REG03_SETUP_AW = (0x0);
0884  01C5  	CLRF gbl_FCV_REG03_SETUP_AW

MX_UINT8 FCV_REG11_RX_PW_P0 = (0x0);
0885  01C6  	CLRF gbl_FCV_REG11_RX_PW_P0

MX_UINT8 FCV_REG14_RX_PW_P3 = (0x0);
0886  01C7  	CLRF gbl_FCV_REG14_RX_PW_P3

MX_UINT8 FCV_CURSORX = (0x0);
0887  01C8  	CLRF gbl_FCV_CURSORX

MX_UINT8 FCV_PAYLOADSIZE = (0x20);
0888  3020  	MOVLW 0x20
0889  00C9  	MOVWF gbl_FCV_PAYLOADSIZE

MX_UINT8 FCV_DIP_SWITCH = (0x0);
088A  01CA  	CLRF gbl_FCV_DIP_SWITCH

MX_CHAR FCV_RX_ADDR[FCSZ_RX_ADDR] = ("KENNY");
088B  304B  	MOVLW 0x4B
088C  1283  	BCF STATUS, RP0
088D  00C0  	MOVWF gbl_FCV_RX_ADDR
088E  3045  	MOVLW 0x45
088F  00C1  	MOVWF gbl_FCV_RX_ADDR+D'1'
0890  304E  	MOVLW 0x4E
0891  00C2  	MOVWF gbl_FCV_RX_ADDR+D'2'
0892  304E  	MOVLW 0x4E
0893  00C3  	MOVWF gbl_FCV_RX_ADDR+D'3'
0894  3059  	MOVLW 0x59
0895  00C4  	MOVWF gbl_FCV_RX_ADDR+D'4'
0896  01C5  	CLRF gbl_FCV_RX_ADDR+D'5'

MX_UINT8 FCV_LOOP_COUNT = (0x0);
0897  1683  	BSF STATUS, RP0
0898  01CB  	CLRF gbl_FCV_LOOP_COUNT

MX_UINT8 FCV_REG0B_RX_ADDR_P1 = (0x0);
0899  01CC  	CLRF gbl_FCV_REG0B_RX_ADDR_P1

MX_UINT8 FCV_REG0E_RX_ADDR_P4 = (0x0);
089A  01CD  	CLRF gbl_FCV_REG0E_RX_ADDR_P4

MX_CHAR FCV_TX_ADDR[FCSZ_TX_ADDR] = ("");
089B  1283  	BCF STATUS, RP0
089C  01D0  	CLRF gbl_FCV_TX_ADDR

MX_UINT8 FCV_REG06_RF_SETUP = (0x0);
089D  1683  	BSF STATUS, RP0
089E  01CE  	CLRF gbl_FCV_REG06_RF_SETUP

MX_UINT8 FCV_T_OUT = (0xa);
089F  300A  	MOVLW 0x0A
08A0  00CF  	MOVWF gbl_FCV_T_OUT

MX_UINT8 FCV_REG10_TX_ADDR_BYTE0 = (0x0);
08A1  01D0  	CLRF gbl_FCV_REG10_TX_ADDR_BYTE0

MX_UINT8 FCV_REG04_SETUP_RETR = (0x0);
08A2  01D1  	CLRF gbl_FCV_REG04_SETUP_RETR





//LCDDisplay(0): //Defines:

/**** Macro Substitutions ****
a = Unique Component Reference Number
b = D1 Port Letter
c = D2 Port Letter
d = D3 Port Letter
e = D4 Port Letter
f = RS Port Letter
g = E Port Letter
h = Data 1_Pin
i = Data 2 Pin
j = Data 3 Pin
k = Data 4 Pin
l = RS Pin
m = Enable Pin
n = Row Count
o = Column Count
******************************/

	//component connections
	#define LCD_1__PORT0    portb
	#define LCD_1__PORT1    portb
	#define LCD_1__PORT2    portb
	#define LCD_1__PORT3    portb
	#define LCD_1__PORT4    portb
	#define LCD_1__PORT5    portb
	#define LCD_1__TRIS0    trisb
	#define LCD_1__TRIS1    trisb
	#define LCD_1__TRIS2    trisb
	#define LCD_1__TRIS3    trisb
	#define LCD_1__TRIS4    trisb
	#define LCD_1__TRIS5    trisb
	#define LCD_1__BIT0    	2
	#define LCD_1__BIT1    	3
	#define LCD_1__BIT2    	4
	#define LCD_1__BIT3    	5
	#define LCD_1__RS      	0
	#define LCD_1__E       	1
	#define LCD_1__ROWCNT	4
	#define LCD_1__COLCNT	16

	#ifdef _BOOSTC
	  #define LCD_1__DELAY   delay_10us(10)
	#endif
	#ifdef _C2C_
	  #define LCD_1__DELAY   delay_us(100)
	#endif
	#ifdef HI_TECH_C
	  #define LCD_1__DELAY   __delay_us(120)
	#endif
	#ifndef LCD_1__DELAY
	  #define LCD_1__DELAY   delay_us(100)
	#endif




//LCDDisplay(0): //Macro function declarations

void FCD_LCDDisplay0_RawSend(MX_UINT8 in, MX_UINT8 mask);
void FCD_LCDDisplay0_Start();
void FCD_LCDDisplay0_Clear();
void FCD_LCDDisplay0_PrintASCII(MX_UINT8 Character);
void FCD_LCDDisplay0_Command(MX_UINT8 in);
void FCD_LCDDisplay0_Cursor(MX_UINT8 x, MX_UINT8 y);
void FCD_LCDDisplay0_PrintNumber(MX_SINT16 Number);
void FCD_LCDDisplay0_PrintString(MX_STRING String, MX_UINT8 MSZ_String);
void FCD_LCDDisplay0_ScrollDisplay(MX_UINT8 Direction, MX_UINT8 Num_Positions);
void FCD_LCDDisplay0_ClearLine(MX_UINT8 Line);
void FCD_LCDDisplay0_RAM_Write(MX_UINT8 nIdx, MX_UINT8 d0, MX_UINT8 d1, MX_UINT8 d2, MX_UINT8 d3, MX_UINT8 d4, MX_UINT8 d5, MX_UINT8 d6, MX_UINT8 d7);


//SPI_Legacy(0): //Defines:

/**** Macro Substitutions ****
a = Unique Ref
b = SPI Channel
c = MOSI Pin
d = MOSI Port
e = MISO Pin
f = MISO Port
g = SCK Pin
h = SCK Port
i = Clock Polarity + Clock Phase + Data Sample Phase
j = SPI Prescaler
k = SPI Postscaler
l = DAC Enable Pin
m = DAC Enable Port
n = FRAM Enable Pin
o = FRAM Enable Port
******************************/

//MX_SPI_BMODE - Bus Mode - Bit0=CPOL, Bit1=CPHA, Bit2=CSMP
//CPOL - Clock Polarity - Idle State of the clock 0=0, 1=1
//CPHA - Clock Phase - Clock Edge 0=leading edge, 1=trailing edge
//CSMP - Input Data Bit Sample Phase


//Definitions for CS control lines
#define SPI_2_MX_SPI_LEGACY_DAC_PIN		0
#define SPI_2_MX_SPI_LEGACY_DAC_PORT		porta
#define SPI_2_MX_SPI_LEGACY_DAC_TRIS		trisa
#define SPI_2_MX_SPI_LEGACY_FRAM_PIN		0
#define SPI_2_MX_SPI_LEGACY_FRAM_PORT		porta
#define SPI_2_MX_SPI_LEGACY_FRAM_TRIS		trisa


//Definitions for SPI slot allocation
#ifndef	MX_SPI_REF1
	#define MX_SPI_REF1
	#define SPI_2_MX_SPI_UREF			1
	#define MX_SPI_CHANNEL_1		1
	#define MX_SPI_MOSI_PIN_1		-1
	#define MX_SPI_MOSI_PORT_1		port0
	#define MX_SPI_MOSI_TRIS_1		tris0
	#define MX_SPI_MISO_PIN_1		-1
	#define MX_SPI_MISO_PORT_1		port0
	#define MX_SPI_MISO_TRIS_1		tris0
	#define MX_SPI_SCK_PIN_1		-1
	#define MX_SPI_SCK_PORT_1		port0
	#define MX_SPI_SCK_TRIS_1		tris0
	#define MX_SPI_CS_PIN_1			0
	#define MX_SPI_CS_PORT_1		0
	#define MX_SPI_BMODE_1			6
	#define MX_SPI_PR_SCALE_1		64
	#define MX_SPI_PO_SCALE_1		0
	#define MX_SPI_INT_1			0
#else
 #ifndef	MX_SPI_REF2
	#define MX_SPI_REF2
	#define SPI_2_MX_SPI_UREF			2
	#define MX_SPI_CHANNEL_2		1
	#define MX_SPI_MOSI_PIN_2		-1
	#define MX_SPI_MOSI_PORT_2		port0
	#define MX_SPI_MOSI_TRIS_2		tris0
	#define MX_SPI_MISO_PIN_2		-1
	#define MX_SPI_MISO_PORT_2		port0
	#define MX_SPI_MISO_TRIS_2		tris0
	#define MX_SPI_SCK_PIN_2		-1
	#define MX_SPI_SCK_PORT_2		port0
	#define MX_SPI_SCK_TRIS_2		tris0
	#define MX_SPI_CS_PIN_2			0
	#define MX_SPI_CS_PORT_2		0
	#define MX_SPI_BMODE_2			6
	#define MX_SPI_PR_SCALE_2		64
	#define MX_SPI_PO_SCALE_2		0
	#define MX_SPI_INT_2			0
 #else
  #ifndef	MX_SPI_REF3
	#define MX_SPI_REF3
	#define SPI_2_MX_SPI_UREF			3
	#define MX_SPI_CHANNEL_3		1
	#define MX_SPI_MOSI_PIN_3		-1
	#define MX_SPI_MOSI_PORT_3		port0
	#define MX_SPI_MOSI_TRIS_3		tris0
	#define MX_SPI_MISO_PIN_3		-1
	#define MX_SPI_MISO_PORT_3		port0
	#define MX_SPI_MISO_TRIS_3		tris0
	#define MX_SPI_SCK_PIN_3		-1
	#define MX_SPI_SCK_PORT_3		port0
	#define MX_SPI_SCK_TRIS_3		tris0
	#define MX_SPI_CS_PIN_3			0
	#define MX_SPI_CS_PORT_3		0
	#define MX_SPI_BMODE_3			6
	#define MX_SPI_PR_SCALE_3		64
	#define MX_SPI_PO_SCALE_3		0
	#define MX_SPI_INT_3			0
  #else
   #ifndef	MX_SPI_REF4
	#define MX_SPI_REF4
	#define SPI_2_MX_SPI_UREF			4
	#define MX_SPI_CHANNEL_4		1
	#define MX_SPI_MOSI_PIN_4		-1
	#define MX_SPI_MOSI_PORT_4		port0
	#define MX_SPI_MOSI_TRIS_4		tris0
	#define MX_SPI_MISO_PIN_4		-1
	#define MX_SPI_MISO_PORT_4		port0
	#define MX_SPI_MISO_TRIS_4		tris0
	#define MX_SPI_SCK_PIN_4		-1
	#define MX_SPI_SCK_PORT_4		port0
	#define MX_SPI_SCK_TRIS_4		tris0
	#define MX_SPI_CS_PIN_4			0
	#define MX_SPI_CS_PORT_4		0
	#define MX_SPI_BMODE_4			6
	#define MX_SPI_PR_SCALE_4		64
	#define MX_SPI_PO_SCALE_4		0
	#define MX_SPI_INT_4			0
   #endif
  #endif
 #endif
#endif

#define SPI_2_SPI_Master_Init		CAL_APPEND(FC_CAL_SPI_Master_Init_, SPI_2_MX_SPI_UREF)
#define SPI_2_SPI_Master_Uninit	CAL_APPEND(FC_CAL_SPI_Master_Uninit_, SPI_2_MX_SPI_UREF)
#define SPI_2_SPI_Master_Byte		CAL_APPEND(FC_CAL_SPI_Master_Byte_, SPI_2_MX_SPI_UREF)

extern void SPI_2_SPI_Master_Init ();
extern void SPI_2_SPI_Master_Uninit ();
extern MX_UINT8 SPI_2_SPI_Master_Byte (MX_UINT8 DataOut);

//FRAM commands
#define FRAM_WREN  	6
#define FRAM_WRDI  	4
#define FRAM_RDSR  	5
#define FRAM_WRSR  	1
#define FRAM_READ  	3
#define FRAM_WRITE 	2




//SPI_Legacy(0): //Macro function declarations

void FCD_SPI_Legacy0_SPI_Init();
void FCD_SPI_Legacy0_SPI_Uninit();
void FCD_SPI_Legacy0_SPI_Send_Char(MX_UINT8 Char);
void FCD_SPI_Legacy0_SPI_Send_String(MX_STRING String, MX_UINT8 MSZ_String);
MX_UINT8 FCD_SPI_Legacy0_SPI_Get_Char();
void FCD_SPI_Legacy0_SPI_Get_String(MX_CHAR* FCR_RETVAL, MX_UINT8 FCR_RETVAL_SIZE, MX_UINT8 NumBytes);
void FCD_SPI_Legacy0_DAC_Send_Char(MX_UINT8 Char);
void FCD_SPI_Legacy0_NVM_Send_Char(MX_UINT8 hi_addr, MX_UINT8 lo_addr, MX_UINT8 Char);
MX_UINT8 FCD_SPI_Legacy0_NVM_Get_Char(MX_UINT8 hi_addr, MX_UINT8 lo_addr);
MX_UINT8 FCD_SPI_Legacy0_FramOutput(MX_UINT8 Char);
void FCD_SPI_Legacy0_EnableFRAM();
void FCD_SPI_Legacy0_DisableFRAM();


//RS232(0): //Defines:

/**** Macro Substitutions ****
a = Unique Reference
b = Uart Channel		(0-software / 1-4 hardware)
c = tx pin
d = tx port
e = rx pin
f = rx port
g = flow control		(0-Off / 1-On)
h = cts pin
i = cts port
j = rts pin
k = rts port
l = baud rate
m = data bits			(7/8/9) (7 only supported in software modes)
n = return type		(0-byte / 1-MX_UINT16)
o = echo enable		(0-Off / 1-On)
******************************/

//Definitions for RS232 UART slot allocation
#ifndef	MX_UART_REF1
	#define MX_UART_REF1
	#define RS232_3_MX_UART_UREF			1
	#define MX_UART_CHANNEL_1		1
	#define MX_UART_TX_PIN_1		0
	#define MX_UART_TX_PORT_1		porta
	#define MX_UART_TX_TRIS_1		trisa
	#define MX_UART_RX_PIN_1		0
	#define MX_UART_RX_PORT_1		porta
	#define MX_UART_RX_TRIS_1		trisa
	#define MX_UART_FLOWEN_1		0
	#define MX_UART_CTS_PIN_1		4
	#define MX_UART_CTS_PORT_1		portc
	#define MX_UART_CTS_TRIS_1		trisc
	#define MX_UART_RTS_PIN_1		0
	#define MX_UART_RTS_PORT_1		portc
	#define MX_UART_RTS_TRIS_1		trisc
	#define MX_UART_BAUD_1			9600
	#define MX_UART_DBITS_1			8
	#define MX_UART_RETURN_1		0
	#define MX_UART_ECHO_1			0
	#define MX_UART_INT_1			0
#else
 #ifndef	MX_UART_REF2
	#define MX_UART_REF2
	#define RS232_3_MX_UART_UREF			2
	#define MX_UART_CHANNEL_2		1
	#define MX_UART_TX_PIN_2		0
	#define MX_UART_TX_PORT_2		porta
	#define MX_UART_TX_TRIS_2		trisa
	#define MX_UART_RX_PIN_2		0
	#define MX_UART_RX_PORT_2		porta
	#define MX_UART_RX_TRIS_2		trisa
	#define MX_UART_FLOWEN_2		0
	#define MX_UART_CTS_PIN_2		4
	#define MX_UART_CTS_PORT_2		portc
	#define MX_UART_CTS_TRIS_2		trisc
	#define MX_UART_RTS_PIN_2		0
	#define MX_UART_RTS_PORT_2		portc
	#define MX_UART_RTS_TRIS_2		trisc
	#define MX_UART_BAUD_2			9600
	#define MX_UART_DBITS_2			8
	#define MX_UART_RETURN_2		0
	#define MX_UART_ECHO_2			0
	#define MX_UART_INT_2			0
 #else
  #ifndef	MX_UART_REF3
	#define MX_UART_REF3
	#define RS232_3_MX_UART_UREF			3
	#define MX_UART_CHANNEL_3		1
	#define MX_UART_TX_PIN_3		0
	#define MX_UART_TX_PORT_3		porta
	#define MX_UART_TX_TRIS_3		trisa
	#define MX_UART_RX_PIN_3		0
	#define MX_UART_RX_PORT_3		porta
	#define MX_UART_RX_TRIS_3		trisa
	#define MX_UART_FLOWEN_3		0
	#define MX_UART_CTS_PIN_3		4
	#define MX_UART_CTS_PORT_3		portc
	#define MX_UART_CTS_TRIS_3		trisc
	#define MX_UART_RTS_PIN_3		0
	#define MX_UART_RTS_PORT_3		portc
	#define MX_UART_RTS_TRIS_3		trisc
	#define MX_UART_BAUD_3			9600
	#define MX_UART_DBITS_3			8
	#define MX_UART_RETURN_3		0
	#define MX_UART_ECHO_3			0
	#define MX_UART_INT_3			0
  #else
   #ifndef	MX_UART_REF4
	#define MX_UART_REF4
	#define RS232_3_MX_UART_UREF			4
	#define MX_UART_CHANNEL_4		1
	#define MX_UART_TX_PIN_4		0
	#define MX_UART_TX_PORT_4		porta
	#define MX_UART_TX_TRIS_4		trisa
	#define MX_UART_RX_PIN_4		0
	#define MX_UART_RX_PORT_4		porta
	#define MX_UART_RX_TRIS_4		trisa
	#define MX_UART_FLOWEN_4		0
	#define MX_UART_CTS_PIN_4		4
	#define MX_UART_CTS_PORT_4		portc
	#define MX_UART_CTS_TRIS_4		trisc
	#define MX_UART_RTS_PIN_4		0
	#define MX_UART_RTS_PORT_4		portc
	#define MX_UART_RTS_TRIS_4		trisc
	#define MX_UART_BAUD_4			9600
	#define MX_UART_DBITS_4			8
	#define MX_UART_RETURN_4		0
	#define MX_UART_ECHO_4			0
	#define MX_UART_INT_4			0
   #endif
  #endif
 #endif
#endif

#define RS232_3_UART_Init		CAL_APPEND(FC_CAL_UART_Init_, RS232_3_MX_UART_UREF)
#define RS232_3_UART_Send		CAL_APPEND(FC_CAL_UART_Send_, RS232_3_MX_UART_UREF)
#define RS232_3_UART_Receive		CAL_APPEND(FC_CAL_UART_Receive_, RS232_3_MX_UART_UREF)
#define RS232_3_UART_Update_Baud CAL_APPEND(FC_CAL_UART_Update_Baud_, RS232_3_MX_UART_UREF)

extern void RS232_3_UART_Init();
extern void RS232_3_UART_Send(MX_UINT16 nChar);
extern MX_SINT16 RS232_3_UART_Receive(MX_UINT8 nTimeout);
extern void RS232_3_UART_Update_Baud(MX_UINT8 newbaud);




//RS232(0): //Macro function declarations

void FCD_RS2320_SendRS232Char(MX_SINT16 nChar);
void FCD_RS2320_SendRS232String(MX_STRING String, MX_UINT8 MSZ_String);
MX_SINT16 FCD_RS2320_ReceiveRS232Char(MX_UINT8 nTimeout);
void FCD_RS2320_ReceiveRS232String(MX_CHAR* FCR_RETVAL, MX_UINT8 FCR_RETVAL_SIZE, MX_UINT8 nTimeout, MX_UINT8 NumBytes);
void FCD_RS2320_ChangeHWBaud(MX_UINT8 newbaud);



//LCDDisplay(0): //Macro implementations


void FCD_LCDDisplay0_RawSend(MX_UINT8 in, MX_UINT8 mask)

{
	
		MX_UINT8 pt;

		FC_CAL_Bit_Low(LCD_1__PORT0, LCD_1__BIT0);
0096  1283  	BCF STATUS, RP0
0097  1106  	BCF gbl_portb,2

		FC_CAL_Bit_Low(LCD_1__PORT1, LCD_1__BIT1);
0098  1186  	BCF gbl_portb,3

		FC_CAL_Bit_Low(LCD_1__PORT2, LCD_1__BIT2);
0099  1206  	BCF gbl_portb,4

		FC_CAL_Bit_Low(LCD_1__PORT3, LCD_1__BIT3);
009A  1286  	BCF gbl_portb,5

		FC_CAL_Bit_Low(LCD_1__PORT4, LCD_1__RS);
009B  1006  	BCF gbl_portb,0

		FC_CAL_Bit_Low(LCD_1__PORT5, LCD_1__E);
009C  1086  	BCF gbl_portb,1

		pt = ((in >> 4) & 0x0f);
009D  1683  	BSF STATUS, RP0
009E  0E66  	SWAPF FCD_LCDDis_0006E_arg_in, W
009F  390F  	ANDLW 0x0F
00A0  00E8  	MOVWF FCD_LCDDis_0006E_1_pt
00A1  300F  	MOVLW 0x0F
00A2  05E8  	ANDWF FCD_LCDDis_0006E_1_pt, F

		if (pt & 0x01)
00A3  1C68  	BTFSS FCD_LCDDis_0006E_1_pt,0
00A4  28A7  	GOTO	label11

		    FC_CAL_Bit_High(LCD_1__PORT0, LCD_1__BIT0);
00A5  1283  	BCF STATUS, RP0
00A6  1506  	BSF gbl_portb,2

		if (pt & 0x02)
00A7  1683  	BSF STATUS, RP0
00A8  1CE8  	BTFSS FCD_LCDDis_0006E_1_pt,1
00A9  28AC  	GOTO	label12

		    FC_CAL_Bit_High(LCD_1__PORT1, LCD_1__BIT1);
00AA  1283  	BCF STATUS, RP0
00AB  1586  	BSF gbl_portb,3

		if (pt & 0x04)
00AC  1683  	BSF STATUS, RP0
00AD  1D68  	BTFSS FCD_LCDDis_0006E_1_pt,2
00AE  28B1  	GOTO	label13

		    FC_CAL_Bit_High(LCD_1__PORT2, LCD_1__BIT2);
00AF  1283  	BCF STATUS, RP0
00B0  1606  	BSF gbl_portb,4

		if (pt & 0x08)
00B1  1683  	BSF STATUS, RP0
00B2  1DE8  	BTFSS FCD_LCDDis_0006E_1_pt,3
00B3  28B6  	GOTO	label14

		    FC_CAL_Bit_High(LCD_1__PORT3, LCD_1__BIT3);
00B4  1283  	BCF STATUS, RP0
00B5  1686  	BSF gbl_portb,5

		if (mask)
00B6  1683  	BSF STATUS, RP0
00B7  08E7  	MOVF FCD_LCDDis_0006E_arg_mask, F
00B8  1903  	BTFSC STATUS,Z
00B9  28BC  	GOTO	label15

		    FC_CAL_Bit_High(LCD_1__PORT4, LCD_1__RS);
00BA  1283  	BCF STATUS, RP0
00BB  1406  	BSF gbl_portb,0

		LCD_1__DELAY;
00BC  300A  	MOVLW 0x0A
00BD  1683  	BSF STATUS, RP0
00BE  00E9  	MOVWF delay_10us_00000_arg_del
00BF  203C  	CALL delay_10us_00000

		FC_CAL_Bit_High (LCD_1__PORT5, LCD_1__E);
00C0  1283  	BCF STATUS, RP0
00C1  1486  	BSF gbl_portb,1

		LCD_1__DELAY;
00C2  300A  	MOVLW 0x0A
00C3  1683  	BSF STATUS, RP0
00C4  00E9  	MOVWF delay_10us_00000_arg_del
00C5  203C  	CALL delay_10us_00000

		FC_CAL_Bit_Low (LCD_1__PORT5, LCD_1__E);
00C6  1283  	BCF STATUS, RP0
00C7  1086  	BCF gbl_portb,1

		pt = (in & 0x0f);
00C8  300F  	MOVLW 0x0F
00C9  1683  	BSF STATUS, RP0
00CA  0566  	ANDWF FCD_LCDDis_0006E_arg_in, W
00CB  00E8  	MOVWF FCD_LCDDis_0006E_1_pt

		LCD_1__DELAY;
00CC  300A  	MOVLW 0x0A
00CD  00E9  	MOVWF delay_10us_00000_arg_del
00CE  203C  	CALL delay_10us_00000

		FC_CAL_Bit_Low(LCD_1__PORT0, LCD_1__BIT0);
00CF  1283  	BCF STATUS, RP0
00D0  1106  	BCF gbl_portb,2

		FC_CAL_Bit_Low(LCD_1__PORT1, LCD_1__BIT1);
00D1  1186  	BCF gbl_portb,3

		FC_CAL_Bit_Low(LCD_1__PORT2, LCD_1__BIT2);
00D2  1206  	BCF gbl_portb,4

		FC_CAL_Bit_Low(LCD_1__PORT3, LCD_1__BIT3);
00D3  1286  	BCF gbl_portb,5

		FC_CAL_Bit_Low(LCD_1__PORT4, LCD_1__RS);
00D4  1006  	BCF gbl_portb,0

		FC_CAL_Bit_Low(LCD_1__PORT5, LCD_1__E);
00D5  1086  	BCF gbl_portb,1

		if (pt & 0x01)
00D6  1683  	BSF STATUS, RP0
00D7  1C68  	BTFSS FCD_LCDDis_0006E_1_pt,0
00D8  28DB  	GOTO	label16

		    FC_CAL_Bit_High(LCD_1__PORT0, LCD_1__BIT0);
00D9  1283  	BCF STATUS, RP0
00DA  1506  	BSF gbl_portb,2

		if (pt & 0x02)
00DB  1683  	BSF STATUS, RP0
00DC  1CE8  	BTFSS FCD_LCDDis_0006E_1_pt,1
00DD  28E0  	GOTO	label17

		    FC_CAL_Bit_High(LCD_1__PORT1, LCD_1__BIT1);
00DE  1283  	BCF STATUS, RP0
00DF  1586  	BSF gbl_portb,3

		if (pt & 0x04)
00E0  1683  	BSF STATUS, RP0
00E1  1D68  	BTFSS FCD_LCDDis_0006E_1_pt,2
00E2  28E5  	GOTO	label18

		    FC_CAL_Bit_High(LCD_1__PORT2, LCD_1__BIT2);
00E3  1283  	BCF STATUS, RP0
00E4  1606  	BSF gbl_portb,4

		if (pt & 0x08)
00E5  1683  	BSF STATUS, RP0
00E6  1DE8  	BTFSS FCD_LCDDis_0006E_1_pt,3
00E7  28EA  	GOTO	label19

		    FC_CAL_Bit_High(LCD_1__PORT3, LCD_1__BIT3);
00E8  1283  	BCF STATUS, RP0
00E9  1686  	BSF gbl_portb,5

		if (mask)
00EA  1683  	BSF STATUS, RP0
00EB  08E7  	MOVF FCD_LCDDis_0006E_arg_mask, F
00EC  1903  	BTFSC STATUS,Z
00ED  28F0  	GOTO	label20

		    FC_CAL_Bit_High(LCD_1__PORT4, LCD_1__RS);
00EE  1283  	BCF STATUS, RP0
00EF  1406  	BSF gbl_portb,0

		LCD_1__DELAY;
00F0  300A  	MOVLW 0x0A
00F1  1683  	BSF STATUS, RP0
00F2  00E9  	MOVWF delay_10us_00000_arg_del
00F3  203C  	CALL delay_10us_00000

		FC_CAL_Bit_High (LCD_1__PORT5, LCD_1__E);
00F4  1283  	BCF STATUS, RP0
00F5  1486  	BSF gbl_portb,1

		LCD_1__DELAY;
00F6  300A  	MOVLW 0x0A
00F7  1683  	BSF STATUS, RP0
00F8  00E9  	MOVWF delay_10us_00000_arg_del
00F9  203C  	CALL delay_10us_00000

		FC_CAL_Bit_Low (LCD_1__PORT5, LCD_1__E);
00FA  1283  	BCF STATUS, RP0
00FB  1086  	BCF gbl_portb,1

		LCD_1__DELAY;
00FC  300A  	MOVLW 0x0A
00FD  1683  	BSF STATUS, RP0
00FE  00E9  	MOVWF delay_10us_00000_arg_del
00FF  203C  	CALL delay_10us_00000


}
0100  0008  	RETURN


void FCD_LCDDisplay0_Start()

{
	
		FC_CAL_Bit_Low_DDR(LCD_1__PORT0, LCD_1__TRIS0, LCD_1__BIT0);
0713  1683  	BSF STATUS, RP0
0714  1303  	BCF STATUS, RP1
0715  1106  	BCF gbl_trisb,2
0716  1283  	BCF STATUS, RP0
0717  1106  	BCF gbl_portb,2

		FC_CAL_Bit_Low_DDR(LCD_1__PORT1, LCD_1__TRIS1, LCD_1__BIT1);
0718  1683  	BSF STATUS, RP0
0719  1186  	BCF gbl_trisb,3
071A  1283  	BCF STATUS, RP0
071B  1186  	BCF gbl_portb,3

		FC_CAL_Bit_Low_DDR(LCD_1__PORT2, LCD_1__TRIS2, LCD_1__BIT2);
071C  1683  	BSF STATUS, RP0
071D  1206  	BCF gbl_trisb,4
071E  1283  	BCF STATUS, RP0
071F  1206  	BCF gbl_portb,4

		FC_CAL_Bit_Low_DDR(LCD_1__PORT3, LCD_1__TRIS3, LCD_1__BIT3);
0720  1683  	BSF STATUS, RP0
0721  1286  	BCF gbl_trisb,5
0722  1283  	BCF STATUS, RP0
0723  1286  	BCF gbl_portb,5

		FC_CAL_Bit_Low_DDR(LCD_1__PORT4, LCD_1__TRIS4, LCD_1__RS);
0724  1683  	BSF STATUS, RP0
0725  1006  	BCF gbl_trisb,0
0726  1283  	BCF STATUS, RP0
0727  1006  	BCF gbl_portb,0

		FC_CAL_Bit_Low_DDR(LCD_1__PORT5, LCD_1__TRIS5, LCD_1__E);
0728  1683  	BSF STATUS, RP0
0729  1086  	BCF gbl_trisb,1
072A  1283  	BCF STATUS, RP0
072B  1086  	BCF gbl_portb,1


		Wdt_Delay_Ms(12);
072C  300C  	MOVLW 0x0C
072D  1683  	BSF STATUS, RP0
072E  00D4  	MOVWF Wdt_Delay__0003E_arg_delay
072F  207C  	CALL Wdt_Delay__0003E


		FCD_LCDDisplay0_RawSend(0x33, 0);
0730  3033  	MOVLW 0x33
0731  00E6  	MOVWF FCD_LCDDis_0006E_arg_in
0732  01E7  	CLRF FCD_LCDDis_0006E_arg_mask
0733  2096  	CALL FCD_LCDDis_0006E

		Wdt_Delay_Ms(2);
0734  3002  	MOVLW 0x02
0735  00D4  	MOVWF Wdt_Delay__0003E_arg_delay
0736  207C  	CALL Wdt_Delay__0003E

		FCD_LCDDisplay0_RawSend(0x33, 0);
0737  3033  	MOVLW 0x33
0738  00E6  	MOVWF FCD_LCDDis_0006E_arg_in
0739  01E7  	CLRF FCD_LCDDis_0006E_arg_mask
073A  2096  	CALL FCD_LCDDis_0006E

		Wdt_Delay_Ms(2);
073B  3002  	MOVLW 0x02
073C  00D4  	MOVWF Wdt_Delay__0003E_arg_delay
073D  207C  	CALL Wdt_Delay__0003E

		FCD_LCDDisplay0_RawSend(0x32, 0);
073E  3032  	MOVLW 0x32
073F  00E6  	MOVWF FCD_LCDDis_0006E_arg_in
0740  01E7  	CLRF FCD_LCDDis_0006E_arg_mask
0741  2096  	CALL FCD_LCDDis_0006E

		Wdt_Delay_Ms(2);
0742  3002  	MOVLW 0x02
0743  00D4  	MOVWF Wdt_Delay__0003E_arg_delay
0744  207C  	CALL Wdt_Delay__0003E

		FCD_LCDDisplay0_RawSend(0x2c, 0);
0745  302C  	MOVLW 0x2C
0746  00E6  	MOVWF FCD_LCDDis_0006E_arg_in
0747  01E7  	CLRF FCD_LCDDis_0006E_arg_mask
0748  2096  	CALL FCD_LCDDis_0006E

		Wdt_Delay_Ms(2);
0749  3002  	MOVLW 0x02
074A  00D4  	MOVWF Wdt_Delay__0003E_arg_delay
074B  207C  	CALL Wdt_Delay__0003E

		FCD_LCDDisplay0_RawSend(0x06, 0);
074C  3006  	MOVLW 0x06
074D  00E6  	MOVWF FCD_LCDDis_0006E_arg_in
074E  01E7  	CLRF FCD_LCDDis_0006E_arg_mask
074F  2096  	CALL FCD_LCDDis_0006E

		Wdt_Delay_Ms(2);
0750  3002  	MOVLW 0x02
0751  00D4  	MOVWF Wdt_Delay__0003E_arg_delay
0752  207C  	CALL Wdt_Delay__0003E

		FCD_LCDDisplay0_RawSend(0x0c, 0);
0753  300C  	MOVLW 0x0C
0754  00E6  	MOVWF FCD_LCDDis_0006E_arg_in
0755  01E7  	CLRF FCD_LCDDis_0006E_arg_mask
0756  2096  	CALL FCD_LCDDis_0006E

		Wdt_Delay_Ms(2);
0757  3002  	MOVLW 0x02
0758  00D4  	MOVWF Wdt_Delay__0003E_arg_delay
0759  207C  	CALL Wdt_Delay__0003E


		//clear the display
		FCD_LCDDisplay0_RawSend(0x01, 0);
075A  3001  	MOVLW 0x01
075B  00E6  	MOVWF FCD_LCDDis_0006E_arg_in
075C  01E7  	CLRF FCD_LCDDis_0006E_arg_mask
075D  2096  	CALL FCD_LCDDis_0006E

		Wdt_Delay_Ms(2);
075E  3002  	MOVLW 0x02
075F  00D4  	MOVWF Wdt_Delay__0003E_arg_delay
0760  207C  	CALL Wdt_Delay__0003E

		FCD_LCDDisplay0_RawSend(0x02, 0);
0761  3002  	MOVLW 0x02
0762  00E6  	MOVWF FCD_LCDDis_0006E_arg_in
0763  01E7  	CLRF FCD_LCDDis_0006E_arg_mask
0764  2096  	CALL FCD_LCDDis_0006E

		Wdt_Delay_Ms(2);
0765  3002  	MOVLW 0x02
0766  00D4  	MOVWF Wdt_Delay__0003E_arg_delay
0767  207C  	CALL Wdt_Delay__0003E


}
0768  0008  	RETURN


void FCD_LCDDisplay0_Clear()

{
	
		FCD_LCDDisplay0_RawSend(0x01, 0);
0702  3001  	MOVLW 0x01
0703  1683  	BSF STATUS, RP0
0704  1303  	BCF STATUS, RP1
0705  00E6  	MOVWF FCD_LCDDis_0006E_arg_in
0706  01E7  	CLRF FCD_LCDDis_0006E_arg_mask
0707  2096  	CALL FCD_LCDDis_0006E

		Wdt_Delay_Ms(2);
0708  3002  	MOVLW 0x02
0709  00D4  	MOVWF Wdt_Delay__0003E_arg_delay
070A  207C  	CALL Wdt_Delay__0003E

		FCD_LCDDisplay0_RawSend(0x02, 0);
070B  3002  	MOVLW 0x02
070C  00E6  	MOVWF FCD_LCDDis_0006E_arg_in
070D  01E7  	CLRF FCD_LCDDis_0006E_arg_mask
070E  2096  	CALL FCD_LCDDis_0006E

		Wdt_Delay_Ms(2);
070F  3002  	MOVLW 0x02
0710  00D4  	MOVWF Wdt_Delay__0003E_arg_delay
0711  207C  	CALL Wdt_Delay__0003E


}
0712  0008  	RETURN


void FCD_LCDDisplay0_PrintASCII(MX_UINT8 Character)
{
	
		FCD_LCDDisplay0_RawSend(Character, 0x10);

}

void FCD_LCDDisplay0_Command(MX_UINT8 in)
{
	
		FCD_LCDDisplay0_RawSend(in, 0);
		Wdt_Delay_Ms(2);

}

void FCD_LCDDisplay0_Cursor(MX_UINT8 x, MX_UINT8 y)

{
	
	  #if (LCD_1__ROWCNT == 1)
	    y=0x80;
	  #endif

	  #if (LCD_1__ROWCNT == 2)
		if (y==0)
			y=0x80;
		else
			y=0xc0;
	  #endif

	  #if (LCD_1__ROWCNT == 4)
		if (y==0)
035D  08D3  	MOVF FCD_LCDDis_00056_arg_y, F
035E  1D03  	BTFSS STATUS,Z
035F  2B63  	GOTO	label61
0363        label61

			y=0x80;
0360  3080  	MOVLW 0x80
0361  00D3  	MOVWF FCD_LCDDis_00056_arg_y

		else if (y==1)
0362  2B72  	GOTO	label64
0363  0353  	DECF FCD_LCDDis_00056_arg_y, W
0364  1D03  	BTFSS STATUS,Z
0365  2B69  	GOTO	label62
0369        label62

			y=0xc0;
0366  30C0  	MOVLW 0xC0
0367  00D3  	MOVWF FCD_LCDDis_00056_arg_y


		#if (LCD_1__COLCNT == 16)
			else if (y==2)
0368  2B72  	GOTO	label64
0369  0853  	MOVF FCD_LCDDis_00056_arg_y, W
036A  3A02  	XORLW 0x02
036B  1D03  	BTFSS STATUS,Z
036C  2B70  	GOTO	label63
0370        label63

				y=0x90;
036D  3090  	MOVLW 0x90
036E  00D3  	MOVWF FCD_LCDDis_00056_arg_y

			else
036F  2B72  	GOTO	label64
0372        label64

				y=0xd0;
0370  30D0  	MOVLW 0xD0
0371  00D3  	MOVWF FCD_LCDDis_00056_arg_y

		#endif

		#if (LCD_1__COLCNT == 20)
			else if (y==2)
				y=0x94;
			else
				y=0xd4;
		#endif
	  #endif

		FCD_LCDDisplay0_RawSend(y+x, 0);
0372  0852  	MOVF FCD_LCDDis_00056_arg_x, W
0373  0753  	ADDWF FCD_LCDDis_00056_arg_y, W
0374  00E6  	MOVWF FCD_LCDDis_0006E_arg_in
0375  01E7  	CLRF FCD_LCDDis_0006E_arg_mask
0376  2096  	CALL FCD_LCDDis_0006E

		Wdt_Delay_Ms(2);
0377  3002  	MOVLW 0x02
0378  00D4  	MOVWF Wdt_Delay__0003E_arg_delay
0379  207C  	CALL Wdt_Delay__0003E


}
037A  0008  	RETURN


void FCD_LCDDisplay0_PrintNumber(MX_SINT16 Number)

{
	
		MX_SINT16 tmp_int;
		MX_UINT8 tmp_byte;

		if (Number < 0)
026F  1FD3  	BTFSS FCD_LCDDis_00057_arg_Number+D'1',7
0270  2A7E  	GOTO	label40
027E        label40

		{
			FCD_LCDDisplay0_RawSend('-', 0x10);
0271  302D  	MOVLW 0x2D
0272  00E6  	MOVWF FCD_LCDDis_0006E_arg_in
0273  3010  	MOVLW 0x10
0274  00E7  	MOVWF FCD_LCDDis_0006E_arg_mask
0275  2096  	CALL FCD_LCDDis_0006E

			Number = 0 - Number;
0276  0852  	MOVF FCD_LCDDis_00057_arg_Number, W
0277  3C00  	SUBLW 0x00
0278  00D7  	MOVWF CompTempVar2190
0279  09D3  	COMF FCD_LCDDis_00057_arg_Number+D'1', F
027A  1803  	BTFSC STATUS,C
027B  0AD3  	INCF FCD_LCDDis_00057_arg_Number+D'1', F
027C  0857  	MOVF CompTempVar2190, W
027D  00D2  	MOVWF FCD_LCDDis_00057_arg_Number

		}

		tmp_int = Number;
027E  0852  	MOVF FCD_LCDDis_00057_arg_Number, W
027F  00D4  	MOVWF FCD_LCDDis_00057_1_tmp_int
0280  0853  	MOVF FCD_LCDDis_00057_arg_Number+D'1', W
0281  00D5  	MOVWF FCD_LCDDis_00057_1_tmp_int+D'1'

		if (Number >= 10000)
0282  3027  	MOVLW 0x27
0283  0253  	SUBWF FCD_LCDDis_00057_arg_Number+D'1', W
0284  1D03  	BTFSS STATUS,Z
0285  2A88  	GOTO	label41
0286  3010  	MOVLW 0x10
0287  0252  	SUBWF FCD_LCDDis_00057_arg_Number, W
0288        label41
0288  1C03  	BTFSS STATUS,C
0289  2AB6  	GOTO	label45
028A  1BD3  	BTFSC FCD_LCDDis_00057_arg_Number+D'1',7
028B  2AB6  	GOTO	label45

		{
			tmp_byte = tmp_int / 10000;
028C  01DB  	CLRF CompTempVar2193
028D  0854  	MOVF FCD_LCDDis_00057_1_tmp_int, W
028E  00D7  	MOVWF __div_16_1_00003_arg_a
028F  0855  	MOVF FCD_LCDDis_00057_1_tmp_int+D'1', W
0290  00D8  	MOVWF __div_16_1_00003_arg_a+D'1'
0291  1FD5  	BTFSS FCD_LCDDis_00057_1_tmp_int+D'1',7
0292  2A99  	GOTO	label42
0293  09D7  	COMF __div_16_1_00003_arg_a, F
0294  09D8  	COMF __div_16_1_00003_arg_a+D'1', F
0295  0AD7  	INCF __div_16_1_00003_arg_a, F
0296  1903  	BTFSC STATUS,Z
0297  0AD8  	INCF __div_16_1_00003_arg_a+D'1', F
0298  0ADB  	INCF CompTempVar2193, F
0299        label42
0299  3010  	MOVLW 0x10
029A  00D9  	MOVWF __div_16_1_00003_arg_b
029B  3027  	MOVLW 0x27
029C  00DA  	MOVWF __div_16_1_00003_arg_b+D'1'
029D  205D  	CALL __div_16_1_00003
029E  0860  	MOVF CompTempVarRet214, W
029F  00D6  	MOVWF FCD_LCDDis_00057_1_tmp_byte
02A0  1C5B  	BTFSS CompTempVar2193,0
02A1  2AA4  	GOTO	label43
02A2  09D6  	COMF FCD_LCDDis_00057_1_tmp_byte, F
02A3  0AD6  	INCF FCD_LCDDis_00057_1_tmp_byte, F
02A4        label43

			FCD_LCDDisplay0_RawSend('0' + tmp_byte, 0x10);
02A4  0856  	MOVF FCD_LCDDis_00057_1_tmp_byte, W
02A5  3E30  	ADDLW 0x30
02A6  00E6  	MOVWF FCD_LCDDis_0006E_arg_in
02A7  3010  	MOVLW 0x10
02A8  00E7  	MOVWF FCD_LCDDis_0006E_arg_mask
02A9  2096  	CALL FCD_LCDDis_0006E


			while (tmp_byte > 0)
02AA        label44
02AA  0856  	MOVF FCD_LCDDis_00057_1_tmp_byte, W
02AB  3C00  	SUBLW 0x00
02AC  1803  	BTFSC STATUS,C
02AD  2AB6  	GOTO	label45
02B5  2AAA  	GOTO	label44
02B6        label45

			{
				tmp_int = tmp_int - 10000;
02AE  3010  	MOVLW 0x10
02AF  02D4  	SUBWF FCD_LCDDis_00057_1_tmp_int, F
02B0  3027  	MOVLW 0x27
02B1  1C03  	BTFSS STATUS,C
02B2  3028  	MOVLW 0x28
02B3  02D5  	SUBWF FCD_LCDDis_00057_1_tmp_int+D'1', F

				tmp_byte--;
02B4  03D6  	DECF FCD_LCDDis_00057_1_tmp_byte, F

			}
		}
		if (Number >= 1000)
02B6  3003  	MOVLW 0x03
02B7  0253  	SUBWF FCD_LCDDis_00057_arg_Number+D'1', W
02B8  1D03  	BTFSS STATUS,Z
02B9  2ABC  	GOTO	label46
02BA  30E8  	MOVLW 0xE8
02BB  0252  	SUBWF FCD_LCDDis_00057_arg_Number, W
02BC        label46
02BC  1C03  	BTFSS STATUS,C
02BD  2AEC  	GOTO	label50
02BE  1BD3  	BTFSC FCD_LCDDis_00057_arg_Number+D'1',7
02BF  2AEC  	GOTO	label50

		{
			tmp_byte = tmp_int / 1000;
02C0  01DC  	CLRF CompTempVar2197
02C1  0854  	MOVF FCD_LCDDis_00057_1_tmp_int, W
02C2  00D7  	MOVWF __div_16_1_00003_arg_a
02C3  0855  	MOVF FCD_LCDDis_00057_1_tmp_int+D'1', W
02C4  00D8  	MOVWF __div_16_1_00003_arg_a+D'1'
02C5  1FD5  	BTFSS FCD_LCDDis_00057_1_tmp_int+D'1',7
02C6  2ACD  	GOTO	label47
02C7  09D7  	COMF __div_16_1_00003_arg_a, F
02C8  09D8  	COMF __div_16_1_00003_arg_a+D'1', F
02C9  0AD7  	INCF __div_16_1_00003_arg_a, F
02CA  1903  	BTFSC STATUS,Z
02CB  0AD8  	INCF __div_16_1_00003_arg_a+D'1', F
02CC  0ADC  	INCF CompTempVar2197, F
02CD        label47
02CD  30E8  	MOVLW 0xE8
02CE  00D9  	MOVWF __div_16_1_00003_arg_b
02CF  3003  	MOVLW 0x03
02D0  00DA  	MOVWF __div_16_1_00003_arg_b+D'1'
02D1  205D  	CALL __div_16_1_00003
02D2  0860  	MOVF CompTempVarRet214, W
02D3  00DB  	MOVWF CompTempVar2196
02D4  1C5C  	BTFSS CompTempVar2197,0
02D5  2AD8  	GOTO	label48
02D6  09DB  	COMF CompTempVar2196, F
02D7  0ADB  	INCF CompTempVar2196, F
02D8        label48
02D8  085B  	MOVF CompTempVar2196, W
02D9  00D6  	MOVWF FCD_LCDDis_00057_1_tmp_byte

			FCD_LCDDisplay0_RawSend('0' + tmp_byte, 0x10);
02DA  0856  	MOVF FCD_LCDDis_00057_1_tmp_byte, W
02DB  3E30  	ADDLW 0x30
02DC  00E6  	MOVWF FCD_LCDDis_0006E_arg_in
02DD  3010  	MOVLW 0x10
02DE  00E7  	MOVWF FCD_LCDDis_0006E_arg_mask
02DF  2096  	CALL FCD_LCDDis_0006E


			while (tmp_byte > 0)
02E0        label49
02E0  0856  	MOVF FCD_LCDDis_00057_1_tmp_byte, W
02E1  3C00  	SUBLW 0x00
02E2  1803  	BTFSC STATUS,C
02E3  2AEC  	GOTO	label50
02EB  2AE0  	GOTO	label49
02EC        label50

			{
				tmp_int = tmp_int - 1000;
02E4  30E8  	MOVLW 0xE8
02E5  02D4  	SUBWF FCD_LCDDis_00057_1_tmp_int, F
02E6  3003  	MOVLW 0x03
02E7  1C03  	BTFSS STATUS,C
02E8  3004  	MOVLW 0x04
02E9  02D5  	SUBWF FCD_LCDDis_00057_1_tmp_int+D'1', F

				tmp_byte--;
02EA  03D6  	DECF FCD_LCDDis_00057_1_tmp_byte, F

			}
		}
		if (Number >= 100)
02EC  0853  	MOVF FCD_LCDDis_00057_arg_Number+D'1', W
02ED  3A80  	XORLW 0x80
02EE  00D7  	MOVWF CompTempVar2200
02EF  3080  	MOVLW 0x80
02F0  0257  	SUBWF CompTempVar2200, W
02F1  1D03  	BTFSS STATUS,Z
02F2  2AF5  	GOTO	label51
02F3  3064  	MOVLW 0x64
02F4  0252  	SUBWF FCD_LCDDis_00057_arg_Number, W
02F5        label51
02F5  1C03  	BTFSS STATUS,C
02F6  2B21  	GOTO	label55

		{
			tmp_byte = tmp_int / 100;
02F7  01DC  	CLRF CompTempVar2202
02F8  0854  	MOVF FCD_LCDDis_00057_1_tmp_int, W
02F9  00D7  	MOVWF __div_16_1_00003_arg_a
02FA  0855  	MOVF FCD_LCDDis_00057_1_tmp_int+D'1', W
02FB  00D8  	MOVWF __div_16_1_00003_arg_a+D'1'
02FC  1FD5  	BTFSS FCD_LCDDis_00057_1_tmp_int+D'1',7
02FD  2B04  	GOTO	label52
02FE  09D7  	COMF __div_16_1_00003_arg_a, F
02FF  09D8  	COMF __div_16_1_00003_arg_a+D'1', F
0300  0AD7  	INCF __div_16_1_00003_arg_a, F
0301  1903  	BTFSC STATUS,Z
0302  0AD8  	INCF __div_16_1_00003_arg_a+D'1', F
0303  0ADC  	INCF CompTempVar2202, F
0304        label52
0304  3064  	MOVLW 0x64
0305  00D9  	MOVWF __div_16_1_00003_arg_b
0306  01DA  	CLRF __div_16_1_00003_arg_b+D'1'
0307  205D  	CALL __div_16_1_00003
0308  0860  	MOVF CompTempVarRet214, W
0309  00DB  	MOVWF CompTempVar2201
030A  1C5C  	BTFSS CompTempVar2202,0
030B  2B0E  	GOTO	label53
030C  09DB  	COMF CompTempVar2201, F
030D  0ADB  	INCF CompTempVar2201, F
030E        label53
030E  085B  	MOVF CompTempVar2201, W
030F  00D6  	MOVWF FCD_LCDDis_00057_1_tmp_byte

			FCD_LCDDisplay0_RawSend('0' + tmp_byte, 0x10);
0310  0856  	MOVF FCD_LCDDis_00057_1_tmp_byte, W
0311  3E30  	ADDLW 0x30
0312  00E6  	MOVWF FCD_LCDDis_0006E_arg_in
0313  3010  	MOVLW 0x10
0314  00E7  	MOVWF FCD_LCDDis_0006E_arg_mask
0315  2096  	CALL FCD_LCDDis_0006E


			while (tmp_byte > 0)
0316        label54
0316  0856  	MOVF FCD_LCDDis_00057_1_tmp_byte, W
0317  3C00  	SUBLW 0x00
0318  1803  	BTFSC STATUS,C
0319  2B21  	GOTO	label55
0320  2B16  	GOTO	label54
0321        label55

			{
				tmp_int = tmp_int - 100;
031A  3064  	MOVLW 0x64
031B  02D4  	SUBWF FCD_LCDDis_00057_1_tmp_int, F
031C  08D5  	MOVF FCD_LCDDis_00057_1_tmp_int+D'1', F
031D  1C03  	BTFSS STATUS,C
031E  03D5  	DECF FCD_LCDDis_00057_1_tmp_int+D'1', F

				tmp_byte--;
031F  03D6  	DECF FCD_LCDDis_00057_1_tmp_byte, F

			}
		}
		if (Number >= 10)
0321  0853  	MOVF FCD_LCDDis_00057_arg_Number+D'1', W
0322  3A80  	XORLW 0x80
0323  00D7  	MOVWF CompTempVar2205
0324  3080  	MOVLW 0x80
0325  0257  	SUBWF CompTempVar2205, W
0326  1D03  	BTFSS STATUS,Z
0327  2B2A  	GOTO	label56
0328  300A  	MOVLW 0x0A
0329  0252  	SUBWF FCD_LCDDis_00057_arg_Number, W
032A        label56
032A  1C03  	BTFSS STATUS,C
032B  2B56  	GOTO	label60

		{
			tmp_byte = tmp_int / 10;
032C  01DC  	CLRF CompTempVar2207
032D  0854  	MOVF FCD_LCDDis_00057_1_tmp_int, W
032E  00D7  	MOVWF __div_16_1_00003_arg_a
032F  0855  	MOVF FCD_LCDDis_00057_1_tmp_int+D'1', W
0330  00D8  	MOVWF __div_16_1_00003_arg_a+D'1'
0331  1FD5  	BTFSS FCD_LCDDis_00057_1_tmp_int+D'1',7
0332  2B39  	GOTO	label57
0333  09D7  	COMF __div_16_1_00003_arg_a, F
0334  09D8  	COMF __div_16_1_00003_arg_a+D'1', F
0335  0AD7  	INCF __div_16_1_00003_arg_a, F
0336  1903  	BTFSC STATUS,Z
0337  0AD8  	INCF __div_16_1_00003_arg_a+D'1', F
0338  0ADC  	INCF CompTempVar2207, F
0339        label57
0339  300A  	MOVLW 0x0A
033A  00D9  	MOVWF __div_16_1_00003_arg_b
033B  01DA  	CLRF __div_16_1_00003_arg_b+D'1'
033C  205D  	CALL __div_16_1_00003
033D  0860  	MOVF CompTempVarRet214, W
033E  00DB  	MOVWF CompTempVar2206
033F  1C5C  	BTFSS CompTempVar2207,0
0340  2B43  	GOTO	label58
0341  09DB  	COMF CompTempVar2206, F
0342  0ADB  	INCF CompTempVar2206, F
0343        label58
0343  085B  	MOVF CompTempVar2206, W
0344  00D6  	MOVWF FCD_LCDDis_00057_1_tmp_byte

			FCD_LCDDisplay0_RawSend('0' + tmp_byte, 0x10);
0345  0856  	MOVF FCD_LCDDis_00057_1_tmp_byte, W
0346  3E30  	ADDLW 0x30
0347  00E6  	MOVWF FCD_LCDDis_0006E_arg_in
0348  3010  	MOVLW 0x10
0349  00E7  	MOVWF FCD_LCDDis_0006E_arg_mask
034A  2096  	CALL FCD_LCDDis_0006E


			while (tmp_byte > 0)
034B        label59
034B  0856  	MOVF FCD_LCDDis_00057_1_tmp_byte, W
034C  3C00  	SUBLW 0x00
034D  1803  	BTFSC STATUS,C
034E  2B56  	GOTO	label60
0355  2B4B  	GOTO	label59
0356        label60

			{
				tmp_int = tmp_int - 10;
034F  300A  	MOVLW 0x0A
0350  02D4  	SUBWF FCD_LCDDis_00057_1_tmp_int, F
0351  08D5  	MOVF FCD_LCDDis_00057_1_tmp_int+D'1', F
0352  1C03  	BTFSS STATUS,C
0353  03D5  	DECF FCD_LCDDis_00057_1_tmp_int+D'1', F

				tmp_byte--;
0354  03D6  	DECF FCD_LCDDis_00057_1_tmp_byte, F

			}
		}
		FCD_LCDDisplay0_RawSend('0' + tmp_int, 0x10);
0356  0854  	MOVF FCD_LCDDis_00057_1_tmp_int, W
0357  3E30  	ADDLW 0x30
0358  00E6  	MOVWF FCD_LCDDis_0006E_arg_in
0359  3010  	MOVLW 0x10
035A  00E7  	MOVWF FCD_LCDDis_0006E_arg_mask
035B  2096  	CALL FCD_LCDDis_0006E


}
035C  0008  	RETURN


void FCD_LCDDisplay0_PrintString(MX_STRING String, MX_UINT8 MSZ_String)

{
	
		MX_UINT8 idx = 0;
04C4  01E5  	CLRF FCD_LCDDis_0005C_1_idx


		for (idx=0; idx<MSZ_String; idx++)
04C5  01E5  	CLRF FCD_LCDDis_0005C_1_idx
04C6        label66
04C6  0864  	MOVF FCD_LCDDis_0005C_arg_MSZ_String, W
04C7  0265  	SUBWF FCD_LCDDis_0005C_1_idx, W
04C8  1803  	BTFSC STATUS,C
04DE  0AE5  	INCF FCD_LCDDis_0005C_1_idx, F
04DF  2CC6  	GOTO	label66

		{
			if (String[idx] == 0)
04CA  1383  	BCF STATUS,IRP
04CB  1853  	BTFSC FCD_LCDDis_0005C_arg_String+D'1',0
04CC  1783  	BSF STATUS,IRP
04CD  0852  	MOVF FCD_LCDDis_0005C_arg_String, W
04CE  0765  	ADDWF FCD_LCDDis_0005C_1_idx, W
04CF  0084  	MOVWF FSR
04D0  0880  	MOVF INDF, F
04D1  1903  	BTFSC STATUS,Z

			{
				break;

			}
			FCD_LCDDisplay0_RawSend(String[idx], 0x10);
04D3  1383  	BCF STATUS,IRP
04D4  1853  	BTFSC FCD_LCDDis_0005C_arg_String+D'1',0
04D5  1783  	BSF STATUS,IRP
04D6  0852  	MOVF FCD_LCDDis_0005C_arg_String, W
04D7  0765  	ADDWF FCD_LCDDis_0005C_1_idx, W
04D8  0084  	MOVWF FSR
04D9  0800  	MOVF INDF, W
04DA  00E6  	MOVWF FCD_LCDDis_0006E_arg_in
04DB  3010  	MOVLW 0x10
04DC  00E7  	MOVWF FCD_LCDDis_0006E_arg_mask
04DD  2096  	CALL FCD_LCDDis_0006E

		}

}
04C9  0008  	RETURN
04D2  0008  	RETURN


void FCD_LCDDisplay0_ScrollDisplay(MX_UINT8 Direction, MX_UINT8 Num_Positions)
{
	
		MX_UINT8 cmd = 0;
		MX_UINT8 count;

		//Choose the direction
		switch (Direction)
		{
			case 0:
			case 'l':
			case 'L':

				cmd = 0x18;
				break;

			case 1:
			case 'r':
			case 'R':

				cmd = 0x1C;
				break;

			default:
				break;
		}

		//If direction accepted then scroll the specified amount
		if (cmd)
		{
			for (count = 0; count < Num_Positions; count++)
				FCD_LCDDisplay0_Command(cmd);
		}

}

void FCD_LCDDisplay0_ClearLine(MX_UINT8 Line)
{
	
		MX_UINT8 count;
		MX_UINT8 rowcount;

		//Define number of columns per line
		#if (LCD_1__ROWCNT == 1)
			rowcount=80;
		#endif

		#if (LCD_1__ROWCNT == 2)
			rowcount=40;
		#endif

		#if (LCD_1__ROWCNT == 4)
			#if (LCD_1__COLCNT == 16)
				rowcount=16;
			#endif
			#if (LCD_1__COLCNT == 20)
				rowcount=20;
			#endif
		#endif

		//Start at beginning of the line
		FCD_LCDDisplay0_Cursor (0, Line);

		//Send out spaces to clear line
		for (count = 0; count < rowcount; count++)
			FCD_LCDDisplay0_RawSend(' ', 0x10);

		//Move back to the beginning of the line.
		FCD_LCDDisplay0_Cursor (0, Line);

}

void FCD_LCDDisplay0_RAM_Write(MX_UINT8 nIdx, MX_UINT8 d0, MX_UINT8 d1, MX_UINT8 d2, MX_UINT8 d3, MX_UINT8 d4, MX_UINT8 d5, MX_UINT8 d6, MX_UINT8 d7)
{
	   //set CGRAM address

	   FCD_LCDDisplay0_RawSend(64 + (nIdx << 3), 0);
	   delay_ms(2);

	   //write CGRAM data
	   FCD_LCDDisplay0_RawSend(d0, 0x10);
	   FCD_LCDDisplay0_RawSend(d1, 0x10);
	   FCD_LCDDisplay0_RawSend(d2, 0x10);
	   FCD_LCDDisplay0_RawSend(d3, 0x10);
	   FCD_LCDDisplay0_RawSend(d4, 0x10);
	   FCD_LCDDisplay0_RawSend(d5, 0x10);
	   FCD_LCDDisplay0_RawSend(d6, 0x10);
	   FCD_LCDDisplay0_RawSend(d7, 0x10);

	   //Clear the display
	   FCD_LCDDisplay0_RawSend(0x01, 0);
	   delay_ms(2);
	   FCD_LCDDisplay0_RawSend(0x02, 0);
	   delay_ms(2);

}



//SPI_Legacy(0): //Macro implementations


void FCD_SPI_Legacy0_SPI_Init()

{
	
		//Disable SPI Devices
		FC_CAL_Bit_High_DDR(SPI_2_MX_SPI_LEGACY_DAC_PORT, SPI_2_MX_SPI_LEGACY_DAC_TRIS, SPI_2_MX_SPI_LEGACY_DAC_PIN);
06F7  1683  	BSF STATUS, RP0
06F8  1303  	BCF STATUS, RP1
06F9  1005  	BCF gbl_trisa,0
06FA  1283  	BCF STATUS, RP0
06FB  1405  	BSF gbl_porta,0

		FC_CAL_Bit_High_DDR(SPI_2_MX_SPI_LEGACY_FRAM_PORT, SPI_2_MX_SPI_LEGACY_FRAM_TRIS, SPI_2_MX_SPI_LEGACY_FRAM_PIN);
06FC  1683  	BSF STATUS, RP0
06FD  1005  	BCF gbl_trisa,0
06FE  1283  	BCF STATUS, RP0
06FF  1405  	BSF gbl_porta,0


		//Init SPI
		SPI_2_SPI_Master_Init();		//Call initialise function
0700  237B  	CALL FC_CAL_SPI_00077


}
0701  0008  	RETURN


void FCD_SPI_Legacy0_SPI_Uninit()
{
	
		//Convert SPI Device Control Lines To Inputs
		FC_CAL_Bit_In_DDR(SPI_2_MX_SPI_LEGACY_DAC_PORT, SPI_2_MX_SPI_LEGACY_DAC_TRIS, SPI_2_MX_SPI_LEGACY_DAC_PIN);
		FC_CAL_Bit_In_DDR(SPI_2_MX_SPI_LEGACY_FRAM_PORT, SPI_2_MX_SPI_LEGACY_FRAM_TRIS, SPI_2_MX_SPI_LEGACY_FRAM_PIN);

		//Uninit SPI
		SPI_2_SPI_Master_Uninit();		//Call uninitialise function

}

void FCD_SPI_Legacy0_SPI_Send_Char(MX_UINT8 Char)

{
	
		SPI_2_SPI_Master_Byte(Char);
0092  0852  	MOVF FCD_SPI_Le_00053_arg_Char, W
0093  00D3  	MOVWF FC_CAL_SPI_00079_arg_DataOut
0094  204F  	CALL FC_CAL_SPI_00079


}
0095  0008  	RETURN


void FCD_SPI_Legacy0_SPI_Send_String(MX_STRING String, MX_UINT8 MSZ_String)
{
	
		MX_UINT8 idx;
		for(idx = 0; idx < MSZ_String; idx++)
		{
			if (String[idx] == 0)				//End of string data?
				break;

			SPI_2_SPI_Master_Byte(String[idx]);
		}

}

MX_UINT8 FCD_SPI_Legacy0_SPI_Get_Char()

{
	
		MX_UINT8 retVal = 0;
0087  1683  	BSF STATUS, RP0
0088  1303  	BCF STATUS, RP1
0089  01D2  	CLRF FCD_SPI_Le_00054_1_retVal


		retVal = SPI_2_SPI_Master_Byte(0xFF);
008A  30FF  	MOVLW 0xFF
008B  00D3  	MOVWF FC_CAL_SPI_00079_arg_DataOut
008C  204F  	CALL FC_CAL_SPI_00079
008D  0855  	MOVF CompTempVarRet2290, W
008E  00D2  	MOVWF FCD_SPI_Le_00054_1_retVal


		return (retVal);
008F  0852  	MOVF FCD_SPI_Le_00054_1_retVal, W
0090  00D3  	MOVWF CompTempVarRet2189


}
0091  0008  	RETURN


void FCD_SPI_Legacy0_SPI_Get_String(MX_CHAR* FCR_RETVAL, MX_UINT8 FCR_RETVAL_SIZE, MX_UINT8 NumBytes)
{
		MX_UINT8 idx;

		if (NumBytes > FCR_RETVAL_SIZE)
			NumBytes = FCR_RETVAL_SIZE;

		for (idx = 0; idx < NumBytes; idx++)
		{
			FCR_RETVAL[idx] = SPI_2_SPI_Master_Byte(0xFF);		//Collect incoming data byte
		}

		if (idx < FCR_RETVAL_SIZE)
			FCR_RETVAL[idx] = 0;					//Terminate string if string variable is longer then expected data

}

void FCD_SPI_Legacy0_DAC_Send_Char(MX_UINT8 Char)
{
	
		MX_UINT8 dac_val;

		FC_CAL_Bit_Low(SPI_2_MX_SPI_LEGACY_DAC_PORT, SPI_2_MX_SPI_LEGACY_DAC_PIN);		//enable dac

		dac_val = (Char & 0xF0) >> 4;
		SPI_2_SPI_Master_Byte(dac_val);

		dac_val = (Char & 0x0F) << 4;
		SPI_2_SPI_Master_Byte(dac_val);

		FC_CAL_Bit_High(SPI_2_MX_SPI_LEGACY_DAC_PORT, SPI_2_MX_SPI_LEGACY_DAC_PIN);		//disable dac

}

void FCD_SPI_Legacy0_NVM_Send_Char(MX_UINT8 hi_addr, MX_UINT8 lo_addr, MX_UINT8 Char)
{
	
		//enable writes
		FCD_SPI_Legacy0_EnableFRAM();
		FCD_SPI_Legacy0_FramOutput(FRAM_WREN);
		FCD_SPI_Legacy0_DisableFRAM();

		//send write-fram command, address and data
		FCD_SPI_Legacy0_EnableFRAM();
		FCD_SPI_Legacy0_FramOutput(FRAM_WRITE);
		FCD_SPI_Legacy0_FramOutput(hi_addr);
		FCD_SPI_Legacy0_FramOutput(lo_addr);
		FCD_SPI_Legacy0_FramOutput(Char);
		FCD_SPI_Legacy0_DisableFRAM();

}

MX_UINT8 FCD_SPI_Legacy0_NVM_Get_Char(MX_UINT8 hi_addr, MX_UINT8 lo_addr)
{
	
		MX_UINT8 retVal;

		FCD_SPI_Legacy0_EnableFRAM();

		//send read-fram command and address
		FCD_SPI_Legacy0_FramOutput(FRAM_READ);
		FCD_SPI_Legacy0_FramOutput(hi_addr);
		FCD_SPI_Legacy0_FramOutput(lo_addr);

		//read the data
		retVal = FCD_SPI_Legacy0_FramOutput(0x5A);  	//don't care byte of 0x5A

		FCD_SPI_Legacy0_DisableFRAM();

		return(retVal);

}

MX_UINT8 FCD_SPI_Legacy0_FramOutput(MX_UINT8 Char)
{
	
		MX_UINT8 retVal = 0;
		retVal = SPI_2_SPI_Master_Byte(Char);
		return (retVal);

}

void FCD_SPI_Legacy0_EnableFRAM()
{
	
		FC_CAL_Bit_Low(SPI_2_MX_SPI_LEGACY_FRAM_PORT, SPI_2_MX_SPI_LEGACY_FRAM_PIN);

}

void FCD_SPI_Legacy0_DisableFRAM()
{
	
		FC_CAL_Bit_High(SPI_2_MX_SPI_LEGACY_FRAM_PORT, SPI_2_MX_SPI_LEGACY_FRAM_PIN);

}



//RS232(0): //Macro implementations


void FCD_RS2320_SendRS232Char(MX_SINT16 nChar)
{
	
		RS232_3_UART_Send ( nChar);

}

void FCD_RS2320_SendRS232String(MX_STRING String, MX_UINT8 MSZ_String)
{
	
		MX_UINT8 idx;
		for(idx = 0; idx < MSZ_String; idx++)
		{
			if (String[idx] == 0)
				break;
			else RS232_3_UART_Send ( String[idx] );
		}

}

MX_SINT16 FCD_RS2320_ReceiveRS232Char(MX_UINT8 nTimeout)
{
	
		return ( RS232_3_UART_Receive ( nTimeout) );

}

void FCD_RS2320_ReceiveRS232String(MX_CHAR* FCR_RETVAL, MX_UINT8 FCR_RETVAL_SIZE, MX_UINT8 nTimeout, MX_UINT8 NumBytes)
{
	
		MX_UINT8 idx;
		MX_SINT16 RS232_TO = 255;
		MX_SINT16 in;

		if ( 0 != 0 )
			RS232_TO = 256;

		if (NumBytes > FCR_RETVAL_SIZE)
			NumBytes = FCR_RETVAL_SIZE;

		for (idx = 0; idx < NumBytes; idx++)
		{
			in = RS232_3_UART_Receive ( nTimeout);
			if(in < RS232_TO)
				FCR_RETVAL[idx] = in & 0xFF;
			else
				break;
		}

		if (idx < FCR_RETVAL_SIZE)
			FCR_RETVAL[idx] = 0;

}

void FCD_RS2320_ChangeHWBaud(MX_UINT8 newbaud)
{
	
		RS232_3_UART_Update_Baud (newbaud);

}

#include "C:\Program Files (x86)\Flowcode\v5\CAL\includes.c"

//Macro implementations


void FCM_spi_nrf_reg_read()
{

	//Comment:
	//read reg00

	//Calculation
	//Calculation:
	//  spi_data0 = 0x00
	FCV_SPI_DATA0 = 0x00;

	//Call Macro
	//Call Macro: cmd_read_reg()
	FCM_cmd_read_reg();

	//Calculation
	//Calculation:
	//  reg00_config = spi_data1
	FCV_REG00_CONFIG = FCV_SPI_DATA1;

	//Comment:
	//read reg01

	//Calculation
	//Calculation:
	//  spi_data0 = 0x01
	FCV_SPI_DATA0 = 0x01;

	//Call Macro
	//Call Macro: cmd_read_reg()
	FCM_cmd_read_reg();

	//Calculation
	//Calculation:
	//  reg01_enaa = spi_data1
	FCV_REG01_ENAA = FCV_SPI_DATA1;

	//Comment:
	//read reg02

	//Calculation
	//Calculation:
	//  spi_data0 = 0x02
	FCV_SPI_DATA0 = 0x02;

	//Call Macro
	//Call Macro: cmd_read_reg()
	FCM_cmd_read_reg();

	//Calculation
	//Calculation:
	//  reg02_en_rxaddr = spi_data1
	FCV_REG02_EN_RXADDR = FCV_SPI_DATA1;

	//Comment:
	//read reg03

	//Calculation
	//Calculation:
	//  spi_data0 = 0x03
	FCV_SPI_DATA0 = 0x03;

	//Call Macro
	//Call Macro: cmd_read_reg()
	FCM_cmd_read_reg();

	//Calculation
	//Calculation:
	//  reg03_setup_aw = spi_data1
	FCV_REG03_SETUP_AW = FCV_SPI_DATA1;

	//Comment:
	//read reg04

	//Calculation
	//Calculation:
	//  spi_data0 = 0x04
	FCV_SPI_DATA0 = 0x04;

	//Call Macro
	//Call Macro: cmd_read_reg()
	FCM_cmd_read_reg();

	//Calculation
	//Calculation:
	//  reg04_setup_retr = spi_data1
	FCV_REG04_SETUP_RETR = FCV_SPI_DATA1;

	//Comment:
	//read reg05

	//Calculation
	//Calculation:
	//  spi_data0 = 0x05
	FCV_SPI_DATA0 = 0x05;

	//Call Macro
	//Call Macro: cmd_read_reg()
	FCM_cmd_read_reg();

	//Calculation
	//Calculation:
	//  reg05_rf_ch = spi_data1
	FCV_REG05_RF_CH = FCV_SPI_DATA1;

	//Comment:
	//read reg06

	//Calculation
	//Calculation:
	//  spi_data0 = 0x06
	FCV_SPI_DATA0 = 0x06;

	//Call Macro
	//Call Macro: cmd_read_reg()
	FCM_cmd_read_reg();

	//Calculation
	//Calculation:
	//  reg06_rf_setup = spi_data1
	FCV_REG06_RF_SETUP = FCV_SPI_DATA1;

	//Comment:
	//read reg07

	//Calculation
	//Calculation:
	//  spi_data0 = 0x07
	FCV_SPI_DATA0 = 0x07;

	//Call Macro
	//Call Macro: cmd_read_reg()
	FCM_cmd_read_reg();

	//Calculation
	//Calculation:
	//  reg07_status = spi_data1
	FCV_REG07_STATUS = FCV_SPI_DATA1;

	//Comment:
	//read reg11

	//Calculation
	//Calculation:
	//  spi_data0 = 0x11
	FCV_SPI_DATA0 = 0x11;

	//Call Macro
	//Call Macro: cmd_read_reg()
	FCM_cmd_read_reg();

	//Calculation
	//Calculation:
	//  reg11_rx_pw_p0 = spi_data1
	FCV_REG11_RX_PW_P0 = FCV_SPI_DATA1;

	//Comment:
	//read reg17

	//Calculation
	//Calculation:
	//  spi_data0 = 0x17
	FCV_SPI_DATA0 = 0x17;

	//Call Macro
	//Call Macro: cmd_read_reg()
	FCM_cmd_read_reg();

	//Calculation
	//Calculation:
	//  reg17_fifo_status = spi_data1
	FCV_REG17_FIFO_STATUS = FCV_SPI_DATA1;

	//Comment:
	//read reg1C

	//Calculation
	//Calculation:
	//  spi_data0 = 0x1C
	FCV_SPI_DATA0 = 0x1C;

	//Call Macro
	//Call Macro: cmd_read_reg()
	FCM_cmd_read_reg();

	//Calculation
	//Calculation:
	//  reg1C_dynpd = spi_data1
	FCV_REG1C_DYNPD = FCV_SPI_DATA1;

	//Comment:
	//read reg1D

	//Calculation
	//Calculation:
	//  spi_data0 = 0x1D
	FCV_SPI_DATA0 = 0x1D;

	//Call Macro
	//Call Macro: cmd_read_reg()
	FCM_cmd_read_reg();

	//Calculation
	//Calculation:
	//  reg1D_feature = spi_data1
	FCV_REG1D_FEATURE = FCV_SPI_DATA1;

}


void FCM_cmd_read_reg()

{

	//CSN
	//Output: 0 -> C2
	trisc = trisc & 0xFB;
0101  30FB  	MOVLW 0xFB
0102  1683  	BSF STATUS, RP0
0103  1303  	BCF STATUS, RP1
0104  0507  	ANDWF gbl_trisc, W
0105  0087  	MOVWF gbl_trisc

	if ((0))
		portc = (portc & 0xFB) | 0x04;
	else
		portc = portc & 0xFB;
0106  30FB  	MOVLW 0xFB
0107  1283  	BCF STATUS, RP0
0108  0507  	ANDWF gbl_portc, W
0109  0087  	MOVWF gbl_portc


	//Delay
	//Delay: 5 us
	delay_us(5);
010A  3005  	MOVLW 0x05
010B  1683  	BSF STATUS, RP0
010C  00D2  	MOVWF delay_us_00000_arg_del
010D  204A  	CALL delay_us_00000


	//Call Component Macro
	//Call Component Macro: SPI_Send_Char(spi_data0)
	FCD_SPI_Legacy0_SPI_Send_Char(FCV_SPI_DATA0);
010E  0830  	MOVF gbl_FCV_SPI_DATA0, W
010F  00D2  	MOVWF FCD_SPI_Le_00053_arg_Char
0110  2092  	CALL FCD_SPI_Le_00053


	//Call Component Macro
	//Call Component Macro: spi_data1=SPI_Get_Char()
	FCV_SPI_DATA1 = FCD_SPI_Legacy0_SPI_Get_Char();
0111  2087  	CALL FCD_SPI_Le_00054
0112  0853  	MOVF CompTempVarRet2189, W
0113  00B1  	MOVWF gbl_FCV_SPI_DATA1


	//CSN
	//Output: 1 -> C2
	trisc = trisc & 0xFB;
0114  30FB  	MOVLW 0xFB
0115  0507  	ANDWF gbl_trisc, W
0116  0087  	MOVWF gbl_trisc

	if ((1))
		portc = (portc & 0xFB) | 0x04;
0117  30FB  	MOVLW 0xFB
0118  1283  	BCF STATUS, RP0
0119  0507  	ANDWF gbl_portc, W
011A  1683  	BSF STATUS, RP0
011B  00D2  	MOVWF CompTempVar2188
011C  3004  	MOVLW 0x04
011D  0452  	IORWF CompTempVar2188, W
011E  1283  	BCF STATUS, RP0
011F  0087  	MOVWF gbl_portc

	else
		portc = portc & 0xFB;

	//Delay
	//Delay: 5 us
	delay_us(5);
0120  3005  	MOVLW 0x05
0121  1683  	BSF STATUS, RP0
0122  00D2  	MOVWF delay_us_00000_arg_del
0123  204A  	CALL delay_us_00000


}
0124  0008  	RETURN



void FCM_lcd_line0()
{

	//Calculation
	//Calculation:
	//  cursorx = 0
	FCV_CURSORX = 0;

	//Call Component Macro
	//Call Component Macro: Cursor(cursorx, 0)
	FCD_LCDDisplay0_Cursor(FCV_CURSORX, 0);

	//Call Component Macro
	//Call Component Macro: PrintNumber(reg00_config)
	FCD_LCDDisplay0_PrintNumber(FCV_REG00_CONFIG);

	//Calculation
	//Calculation:
	//  cursorx = cursorx + 4
	FCV_CURSORX = FCV_CURSORX + 4;

	//Call Component Macro
	//Call Component Macro: Cursor(cursorx, 0)
	FCD_LCDDisplay0_Cursor(FCV_CURSORX, 0);

	//Call Component Macro
	//Call Component Macro: PrintNumber(reg01_enaa)
	FCD_LCDDisplay0_PrintNumber(FCV_REG01_ENAA);

	//Calculation
	//Calculation:
	//  cursorx = cursorx + 4
	FCV_CURSORX = FCV_CURSORX + 4;

	//Call Component Macro
	//Call Component Macro: Cursor(cursorx, 0)
	FCD_LCDDisplay0_Cursor(FCV_CURSORX, 0);

	//Call Component Macro
	//Call Component Macro: PrintNumber(reg02_en_rxaddr)
	FCD_LCDDisplay0_PrintNumber(FCV_REG02_EN_RXADDR);

	//Calculation
	//Calculation:
	//  cursorx = cursorx + 4
	FCV_CURSORX = FCV_CURSORX + 4;

	//Call Component Macro
	//Call Component Macro: Cursor(cursorx, 0)
	FCD_LCDDisplay0_Cursor(FCV_CURSORX, 0);

	//Call Component Macro
	//Call Component Macro: PrintNumber(reg03_setup_aw)
	FCD_LCDDisplay0_PrintNumber(FCV_REG03_SETUP_AW);

}


void FCM_lcd_line1()
{

	//Calculation
	//Calculation:
	//  cursorx = 0
	FCV_CURSORX = 0;

	//Call Component Macro
	//Call Component Macro: Cursor(cursorx, 1)
	FCD_LCDDisplay0_Cursor(FCV_CURSORX, 1);

	//Call Component Macro
	//Call Component Macro: PrintNumber(reg04_setup_retr)
	FCD_LCDDisplay0_PrintNumber(FCV_REG04_SETUP_RETR);

	//Calculation
	//Calculation:
	//  cursorx = cursorx + 4
	FCV_CURSORX = FCV_CURSORX + 4;

	//Call Component Macro
	//Call Component Macro: Cursor(cursorx, 1)
	FCD_LCDDisplay0_Cursor(FCV_CURSORX, 1);

	//Call Component Macro
	//Call Component Macro: PrintNumber(reg05_rf_ch)
	FCD_LCDDisplay0_PrintNumber(FCV_REG05_RF_CH);

	//Calculation
	//Calculation:
	//  cursorx = cursorx + 4
	FCV_CURSORX = FCV_CURSORX + 4;

	//Call Component Macro
	//Call Component Macro: Cursor(cursorx, 1)
	FCD_LCDDisplay0_Cursor(FCV_CURSORX, 1);

	//Call Component Macro
	//Call Component Macro: PrintNumber(reg11_rx_pw_p0)
	FCD_LCDDisplay0_PrintNumber(FCV_REG11_RX_PW_P0);

	//Calculation
	//Calculation:
	//  cursorx = cursorx + 4
	FCV_CURSORX = FCV_CURSORX + 4;

	//Call Component Macro
	//Call Component Macro: Cursor(cursorx, 1)
	FCD_LCDDisplay0_Cursor(FCV_CURSORX, 1);

	//Call Component Macro
	//Call Component Macro: PrintNumber(reg1D_feature)
	FCD_LCDDisplay0_PrintNumber(FCV_REG1D_FEATURE);

	//Calculation
	//Calculation:
	//  cursorx = cursorx + 4
	FCV_CURSORX = FCV_CURSORX + 4;

}


void FCM_lcd_line2()
{

	//Call Macro
	//Call Macro: cmd_read_tx_addr()
	FCM_cmd_read_tx_addr();

	//Call Macro
	//Call Macro: cmd_read_rx_addr()
	FCM_cmd_read_rx_addr();

	//Call Component Macro
	//Call Component Macro: Cursor(0, 2)
	FCD_LCDDisplay0_Cursor(0, 2);

	//Call Component Macro
	//Call Component Macro: PrintString("t:")
	FCD_LCDDisplay0_PrintString("t:", 2);

	//Call Component Macro
	//Call Component Macro: Cursor(2, 2)
	FCD_LCDDisplay0_Cursor(2, 2);

	//Call Component Macro
	//Call Component Macro: PrintString(tx_addr)
	FCD_LCDDisplay0_PrintString(FCV_TX_ADDR, FCSZ_TX_ADDR);

	//Call Component Macro
	//Call Component Macro: Cursor(7, 2)
	FCD_LCDDisplay0_Cursor(7, 2);

	//Call Component Macro
	//Call Component Macro: PrintString(" r:")
	FCD_LCDDisplay0_PrintString(" r:", 3);

	//Call Component Macro
	//Call Component Macro: Cursor(10, 2)
	FCD_LCDDisplay0_Cursor(10, 2);

	//Call Component Macro
	//Call Component Macro: PrintString(rx_addr)
	FCD_LCDDisplay0_PrintString(FCV_RX_ADDR, FCSZ_RX_ADDR);

}


void FCM_cmd_read_rx_addr()

{

	//Comment:
	//read rx addr

	//Calculation
	//Calculation:
	//  spi_data0 = 0x0A
	FCV_SPI_DATA0 = 0x0A;
067F  300A  	MOVLW 0x0A
0680  1683  	BSF STATUS, RP0
0681  1303  	BCF STATUS, RP1
0682  00B0  	MOVWF gbl_FCV_SPI_DATA0


	//CSN
	//Output: 0 -> C2
	trisc = trisc & 0xFB;
0683  30FB  	MOVLW 0xFB
0684  0507  	ANDWF gbl_trisc, W
0685  0087  	MOVWF gbl_trisc

	if ((0))
		portc = (portc & 0xFB) | 0x04;
	else
		portc = portc & 0xFB;
0686  30FB  	MOVLW 0xFB
0687  1283  	BCF STATUS, RP0
0688  0507  	ANDWF gbl_portc, W
0689  0087  	MOVWF gbl_portc


	//Delay
	//Delay: 5 us
	delay_us(5);
068A  3005  	MOVLW 0x05
068B  1683  	BSF STATUS, RP0
068C  00D2  	MOVWF delay_us_00000_arg_del
068D  204A  	CALL delay_us_00000


	//Call Component Macro
	//Call Component Macro: SPI_Send_Char(spi_data0)
	FCD_SPI_Legacy0_SPI_Send_Char(FCV_SPI_DATA0);
068E  0830  	MOVF gbl_FCV_SPI_DATA0, W
068F  00D2  	MOVWF FCD_SPI_Le_00053_arg_Char
0690  2092  	CALL FCD_SPI_Le_00053


	//Call Component Macro
	//Call Component Macro: spi_data1=SPI_Get_Char()
	FCV_SPI_DATA1 = FCD_SPI_Legacy0_SPI_Get_Char();
0691  2087  	CALL FCD_SPI_Le_00054
0692  0853  	MOVF CompTempVarRet2189, W
0693  00B1  	MOVWF gbl_FCV_SPI_DATA1


	//Calculation
	//Calculation:
	//  reg0A_rx_addr_p0_byte0 = spi_data1
	FCV_REG0A_RX_ADDR_P0_BYTE0 = FCV_SPI_DATA1;
0694  0831  	MOVF gbl_FCV_SPI_DATA1, W
0695  00B5  	MOVWF gbl_FCV_REG0A_RX_ADDR_P0_BYTE0


	//Call Component Macro
	//Call Component Macro: spi_data1=SPI_Get_Char()
	FCV_SPI_DATA1 = FCD_SPI_Legacy0_SPI_Get_Char();
0696  2087  	CALL FCD_SPI_Le_00054
0697  0853  	MOVF CompTempVarRet2189, W
0698  00B1  	MOVWF gbl_FCV_SPI_DATA1


	//Calculation
	//Calculation:
	//  reg0A_rx_addr_p0_byte1 = spi_data1
	FCV_REG0A_RX_ADDR_P0_BYTE1 = FCV_SPI_DATA1;
0699  0831  	MOVF gbl_FCV_SPI_DATA1, W
069A  00B8  	MOVWF gbl_FCV_REG0A_RX_ADDR_P0_BYTE1


	//Call Component Macro
	//Call Component Macro: spi_data1=SPI_Get_Char()
	FCV_SPI_DATA1 = FCD_SPI_Legacy0_SPI_Get_Char();
069B  2087  	CALL FCD_SPI_Le_00054
069C  0853  	MOVF CompTempVarRet2189, W
069D  00B1  	MOVWF gbl_FCV_SPI_DATA1


	//Calculation
	//Calculation:
	//  reg0A_rx_addr_p0_byte2 = spi_data1
	FCV_REG0A_RX_ADDR_P0_BYTE2 = FCV_SPI_DATA1;
069E  0831  	MOVF gbl_FCV_SPI_DATA1, W
069F  00BB  	MOVWF gbl_FCV_REG0A_RX_ADDR_P0_BYTE2


	//Call Component Macro
	//Call Component Macro: spi_data1=SPI_Get_Char()
	FCV_SPI_DATA1 = FCD_SPI_Legacy0_SPI_Get_Char();
06A0  2087  	CALL FCD_SPI_Le_00054
06A1  0853  	MOVF CompTempVarRet2189, W
06A2  00B1  	MOVWF gbl_FCV_SPI_DATA1


	//Calculation
	//Calculation:
	//  reg0A_rx_addr_p0_byte3 = spi_data1
	FCV_REG0A_RX_ADDR_P0_BYTE3 = FCV_SPI_DATA1;
06A3  0831  	MOVF gbl_FCV_SPI_DATA1, W
06A4  00C0  	MOVWF gbl_FCV_REG0A_RX_ADDR_P0_BYTE3


	//Call Component Macro
	//Call Component Macro: spi_data1=SPI_Get_Char()
	FCV_SPI_DATA1 = FCD_SPI_Legacy0_SPI_Get_Char();
06A5  2087  	CALL FCD_SPI_Le_00054
06A6  0853  	MOVF CompTempVarRet2189, W
06A7  00B1  	MOVWF gbl_FCV_SPI_DATA1


	//Calculation
	//Calculation:
	//  reg0A_rx_addr_p0_byte4 = spi_data1
	FCV_REG0A_RX_ADDR_P0_BYTE4 = FCV_SPI_DATA1;
06A8  0831  	MOVF gbl_FCV_SPI_DATA1, W
06A9  00C4  	MOVWF gbl_FCV_REG0A_RX_ADDR_P0_BYTE4


	//CSN
	//Output: 1 -> C2
	trisc = trisc & 0xFB;
06AA  30FB  	MOVLW 0xFB
06AB  0507  	ANDWF gbl_trisc, W
06AC  0087  	MOVWF gbl_trisc

	if ((1))
		portc = (portc & 0xFB) | 0x04;
06AD  30FB  	MOVLW 0xFB
06AE  1283  	BCF STATUS, RP0
06AF  0507  	ANDWF gbl_portc, W
06B0  1683  	BSF STATUS, RP0
06B1  00D2  	MOVWF CompTempVar2217
06B2  3004  	MOVLW 0x04
06B3  0452  	IORWF CompTempVar2217, W
06B4  1283  	BCF STATUS, RP0
06B5  0087  	MOVWF gbl_portc

	else
		portc = portc & 0xFB;

	//Delay
	//Delay: 5 us
	delay_us(5);
06B6  3005  	MOVLW 0x05
06B7  1683  	BSF STATUS, RP0
06B8  00D2  	MOVWF delay_us_00000_arg_del
06B9  204A  	CALL delay_us_00000


}
06BA  0008  	RETURN



void FCM_cmd_read_tx_addr()

{

	//Comment:
	//read rx addr

	//Calculation
	//Calculation:
	//  spi_data0 = 0x10
	FCV_SPI_DATA0 = 0x10;
06BB  3010  	MOVLW 0x10
06BC  1683  	BSF STATUS, RP0
06BD  1303  	BCF STATUS, RP1
06BE  00B0  	MOVWF gbl_FCV_SPI_DATA0


	//CSN
	//Output: 0 -> C2
	trisc = trisc & 0xFB;
06BF  30FB  	MOVLW 0xFB
06C0  0507  	ANDWF gbl_trisc, W
06C1  0087  	MOVWF gbl_trisc

	if ((0))
		portc = (portc & 0xFB) | 0x04;
	else
		portc = portc & 0xFB;
06C2  30FB  	MOVLW 0xFB
06C3  1283  	BCF STATUS, RP0
06C4  0507  	ANDWF gbl_portc, W
06C5  0087  	MOVWF gbl_portc


	//Delay
	//Delay: 5 us
	delay_us(5);
06C6  3005  	MOVLW 0x05
06C7  1683  	BSF STATUS, RP0
06C8  00D2  	MOVWF delay_us_00000_arg_del
06C9  204A  	CALL delay_us_00000


	//Call Component Macro
	//Call Component Macro: SPI_Send_Char(spi_data0)
	FCD_SPI_Legacy0_SPI_Send_Char(FCV_SPI_DATA0);
06CA  0830  	MOVF gbl_FCV_SPI_DATA0, W
06CB  00D2  	MOVWF FCD_SPI_Le_00053_arg_Char
06CC  2092  	CALL FCD_SPI_Le_00053


	//Call Component Macro
	//Call Component Macro: spi_data1=SPI_Get_Char()
	FCV_SPI_DATA1 = FCD_SPI_Legacy0_SPI_Get_Char();
06CD  2087  	CALL FCD_SPI_Le_00054
06CE  0853  	MOVF CompTempVarRet2189, W
06CF  00B1  	MOVWF gbl_FCV_SPI_DATA1


	//Calculation
	//Calculation:
	//  reg10_tx_addr_byte0 = spi_data1
	FCV_REG10_TX_ADDR_BYTE0 = FCV_SPI_DATA1;
06D0  0831  	MOVF gbl_FCV_SPI_DATA1, W
06D1  00D0  	MOVWF gbl_FCV_REG10_TX_ADDR_BYTE0


	//Call Component Macro
	//Call Component Macro: spi_data1=SPI_Get_Char()
	FCV_SPI_DATA1 = FCD_SPI_Legacy0_SPI_Get_Char();
06D2  2087  	CALL FCD_SPI_Le_00054
06D3  0853  	MOVF CompTempVarRet2189, W
06D4  00B1  	MOVWF gbl_FCV_SPI_DATA1


	//Calculation
	//Calculation:
	//  reg10_tx_addr_byte1 = spi_data1
	FCV_REG10_TX_ADDR_BYTE1 = FCV_SPI_DATA1;
06D5  0831  	MOVF gbl_FCV_SPI_DATA1, W
06D6  00A4  	MOVWF gbl_FCV_REG10_TX_ADDR_BYTE1


	//Call Component Macro
	//Call Component Macro: spi_data1=SPI_Get_Char()
	FCV_SPI_DATA1 = FCD_SPI_Legacy0_SPI_Get_Char();
06D7  2087  	CALL FCD_SPI_Le_00054
06D8  0853  	MOVF CompTempVarRet2189, W
06D9  00B1  	MOVWF gbl_FCV_SPI_DATA1


	//Calculation
	//Calculation:
	//  reg10_tx_addr_byte2 = spi_data1
	FCV_REG10_TX_ADDR_BYTE2 = FCV_SPI_DATA1;
06DA  0831  	MOVF gbl_FCV_SPI_DATA1, W
06DB  00A7  	MOVWF gbl_FCV_REG10_TX_ADDR_BYTE2


	//Call Component Macro
	//Call Component Macro: spi_data1=SPI_Get_Char()
	FCV_SPI_DATA1 = FCD_SPI_Legacy0_SPI_Get_Char();
06DC  2087  	CALL FCD_SPI_Le_00054
06DD  0853  	MOVF CompTempVarRet2189, W
06DE  00B1  	MOVWF gbl_FCV_SPI_DATA1


	//Calculation
	//Calculation:
	//  reg10_tx_addr_byte3 = spi_data1
	FCV_REG10_TX_ADDR_BYTE3 = FCV_SPI_DATA1;
06DF  0831  	MOVF gbl_FCV_SPI_DATA1, W
06E0  00AA  	MOVWF gbl_FCV_REG10_TX_ADDR_BYTE3


	//Call Component Macro
	//Call Component Macro: spi_data1=SPI_Get_Char()
	FCV_SPI_DATA1 = FCD_SPI_Legacy0_SPI_Get_Char();
06E1  2087  	CALL FCD_SPI_Le_00054
06E2  0853  	MOVF CompTempVarRet2189, W
06E3  00B1  	MOVWF gbl_FCV_SPI_DATA1


	//Calculation
	//Calculation:
	//  reg10_tx_addr_byte4 = spi_data1
	FCV_REG10_TX_ADDR_BYTE4 = FCV_SPI_DATA1;
06E4  0831  	MOVF gbl_FCV_SPI_DATA1, W
06E5  00AB  	MOVWF gbl_FCV_REG10_TX_ADDR_BYTE4


	//CSN
	//Output: 1 -> C2
	trisc = trisc & 0xFB;
06E6  30FB  	MOVLW 0xFB
06E7  0507  	ANDWF gbl_trisc, W
06E8  0087  	MOVWF gbl_trisc

	if ((1))
		portc = (portc & 0xFB) | 0x04;
06E9  30FB  	MOVLW 0xFB
06EA  1283  	BCF STATUS, RP0
06EB  0507  	ANDWF gbl_portc, W
06EC  1683  	BSF STATUS, RP0
06ED  00D2  	MOVWF CompTempVar2216
06EE  3004  	MOVLW 0x04
06EF  0452  	IORWF CompTempVar2216, W
06F0  1283  	BCF STATUS, RP0
06F1  0087  	MOVWF gbl_portc

	else
		portc = portc & 0xFB;

	//Delay
	//Delay: 5 us
	delay_us(5);
06F2  3005  	MOVLW 0x05
06F3  1683  	BSF STATUS, RP0
06F4  00D2  	MOVWF delay_us_00000_arg_del
06F5  204A  	CALL delay_us_00000


}
06F6  0008  	RETURN



void FCM_lcd_line3()
{

	//Call Macro
	//Call Macro: cmd_read_tx_addr()
	FCM_cmd_read_tx_addr();

	//Calculation
	//Calculation:
	//  cursorx = 0
	FCV_CURSORX = 0;

	//Call Component Macro
	//Call Component Macro: Cursor(cursorx, 3)
	FCD_LCDDisplay0_Cursor(FCV_CURSORX, 3);

	//Call Component Macro
	//Call Component Macro: PrintNumber(reg10_tx_addr_byte0)
	FCD_LCDDisplay0_PrintNumber(FCV_REG10_TX_ADDR_BYTE0);

	//Calculation
	//Calculation:
	//  cursorx = cursorx + 3
	FCV_CURSORX = FCV_CURSORX + 3;

	//Call Component Macro
	//Call Component Macro: Cursor(cursorx, 3)
	FCD_LCDDisplay0_Cursor(FCV_CURSORX, 3);

	//Call Component Macro
	//Call Component Macro: PrintNumber(reg10_tx_addr_byte1)
	FCD_LCDDisplay0_PrintNumber(FCV_REG10_TX_ADDR_BYTE1);

	//Calculation
	//Calculation:
	//  cursorx = cursorx + 3
	FCV_CURSORX = FCV_CURSORX + 3;

	//Call Component Macro
	//Call Component Macro: Cursor(cursorx, 3)
	FCD_LCDDisplay0_Cursor(FCV_CURSORX, 3);

	//Call Component Macro
	//Call Component Macro: PrintNumber(reg10_tx_addr_byte2)
	FCD_LCDDisplay0_PrintNumber(FCV_REG10_TX_ADDR_BYTE2);

	//Calculation
	//Calculation:
	//  cursorx = cursorx + 3
	FCV_CURSORX = FCV_CURSORX + 3;

	//Call Component Macro
	//Call Component Macro: Cursor(cursorx, 3)
	FCD_LCDDisplay0_Cursor(FCV_CURSORX, 3);

	//Call Component Macro
	//Call Component Macro: PrintNumber(reg10_tx_addr_byte3)
	FCD_LCDDisplay0_PrintNumber(FCV_REG10_TX_ADDR_BYTE3);

	//Calculation
	//Calculation:
	//  cursorx = cursorx + 3
	FCV_CURSORX = FCV_CURSORX + 3;

	//Call Component Macro
	//Call Component Macro: Cursor(cursorx, 3)
	FCD_LCDDisplay0_Cursor(FCV_CURSORX, 3);

	//Call Component Macro
	//Call Component Macro: PrintNumber(reg10_tx_addr_byte4)
	FCD_LCDDisplay0_PrintNumber(FCV_REG10_TX_ADDR_BYTE4);

	//Calculation
	//Calculation:
	//  cursorx = cursorx + 3
	FCV_CURSORX = FCV_CURSORX + 3;

}


void FCM_nrf_tx_init()
{

	//Calculation
	//Calculation:
	//  reg_to_write = 0x00
	//  data_to_write = 0x0E
	FCV_REG_TO_WRITE = 0x00;
	FCV_DATA_TO_WRITE = 0x0E;

	//Call Macro
	//Call Macro: cmd_write_reg()
	FCM_cmd_write_reg();

	//Calculation
	//Calculation:
	//  reg_to_write = 01
	//  data_to_write = 0x3F
	FCV_REG_TO_WRITE = 01;
	FCV_DATA_TO_WRITE = 0x3F;

	//Call Macro
	//Call Macro: cmd_write_reg()
	FCM_cmd_write_reg();

	//Calculation
	//Calculation:
	//  reg_to_write = 02
	//  data_to_write = 0x03
	FCV_REG_TO_WRITE = 02;
	FCV_DATA_TO_WRITE = 0x03;

	//Call Macro
	//Call Macro: cmd_write_reg()
	FCM_cmd_write_reg();

	//Calculation
	//Calculation:
	//  reg_to_write = 03
	//  data_to_write = 0x03
	FCV_REG_TO_WRITE = 03;
	FCV_DATA_TO_WRITE = 0x03;

	//Call Macro
	//Call Macro: cmd_write_reg()
	FCM_cmd_write_reg();

	//Calculation
	//Calculation:
	//  reg_to_write = 0x04
	//  data_to_write = 0x5F
	FCV_REG_TO_WRITE = 0x04;
	FCV_DATA_TO_WRITE = 0x5F;

	//Call Macro
	//Call Macro: cmd_write_reg()
	FCM_cmd_write_reg();

	//Calculation
	//Calculation:
	//  reg_to_write = 0x05
	//  data_to_write = 0x4C
	FCV_REG_TO_WRITE = 0x05;
	FCV_DATA_TO_WRITE = 0x4C;

	//Call Macro
	//Call Macro: cmd_write_reg()
	FCM_cmd_write_reg();

	//Calculation
	//Calculation:
	//  reg_to_write = 0x06
	//  data_to_write = 0x27
	FCV_REG_TO_WRITE = 0x06;
	FCV_DATA_TO_WRITE = 0x27;

	//Call Macro
	//Call Macro: cmd_write_reg()
	FCM_cmd_write_reg();

	//Calculation
	//Calculation:
	//  reg_to_write = 0x11
	//  data_to_write = payloadsize
	FCV_REG_TO_WRITE = 0x11;
	FCV_DATA_TO_WRITE = FCV_PAYLOADSIZE;

	//Call Macro
	//Call Macro: cmd_write_reg()
	FCM_cmd_write_reg();

	//Call Macro
	//Call Macro: set_tx_addr()
	FCM_set_tx_addr();

	//Call Macro
	//Call Macro: set_rx_addr()
	FCM_set_rx_addr();

	//Call Macro
	//Call Macro: flush_fifo_txrx()
	FCM_flush_fifo_txrx();

}


void FCM_cmd_write_reg()

{

	//CSN
	//Output: 0 -> C2
	trisc = trisc & 0xFB;
048E  30FB  	MOVLW 0xFB
048F  1683  	BSF STATUS, RP0
0490  1303  	BCF STATUS, RP1
0491  0507  	ANDWF gbl_trisc, W
0492  0087  	MOVWF gbl_trisc

	if ((0))
		portc = (portc & 0xFB) | 0x04;
	else
		portc = portc & 0xFB;
0493  30FB  	MOVLW 0xFB
0494  1283  	BCF STATUS, RP0
0495  0507  	ANDWF gbl_portc, W
0496  0087  	MOVWF gbl_portc


	//Delay
	//Delay: 5 us
	delay_us(5);
0497  3005  	MOVLW 0x05
0498  1683  	BSF STATUS, RP0
0499  00D2  	MOVWF delay_us_00000_arg_del
049A  204A  	CALL delay_us_00000


	//Calculation
	//Calculation:
	//  spi_data0 = reg_to_write + 0x20
	FCV_SPI_DATA0 = FCV_REG_TO_WRITE + 0x20;
049B  3020  	MOVLW 0x20
049C  0743  	ADDWF gbl_FCV_REG_TO_WRITE, W
049D  00B0  	MOVWF gbl_FCV_SPI_DATA0


	//Call Component Macro
	//Call Component Macro: SPI_Send_Char(spi_data0)
	FCD_SPI_Legacy0_SPI_Send_Char(FCV_SPI_DATA0);
049E  0830  	MOVF gbl_FCV_SPI_DATA0, W
049F  00D2  	MOVWF FCD_SPI_Le_00053_arg_Char
04A0  2092  	CALL FCD_SPI_Le_00053


	//Calculation
	//Calculation:
	//  spi_data0 = data_to_write
	FCV_SPI_DATA0 = FCV_DATA_TO_WRITE;
04A1  0823  	MOVF gbl_FCV_DATA_TO_WRITE, W
04A2  00B0  	MOVWF gbl_FCV_SPI_DATA0


	//Call Component Macro
	//Call Component Macro: SPI_Send_Char(spi_data0)
	FCD_SPI_Legacy0_SPI_Send_Char(FCV_SPI_DATA0);
04A3  0830  	MOVF gbl_FCV_SPI_DATA0, W
04A4  00D2  	MOVWF FCD_SPI_Le_00053_arg_Char
04A5  2092  	CALL FCD_SPI_Le_00053


	//CSN
	//Output: 1 -> C2
	trisc = trisc & 0xFB;
04A6  30FB  	MOVLW 0xFB
04A7  0507  	ANDWF gbl_trisc, W
04A8  0087  	MOVWF gbl_trisc

	if ((1))
		portc = (portc & 0xFB) | 0x04;
04A9  30FB  	MOVLW 0xFB
04AA  1283  	BCF STATUS, RP0
04AB  0507  	ANDWF gbl_portc, W
04AC  1683  	BSF STATUS, RP0
04AD  00D2  	MOVWF CompTempVar2222
04AE  3004  	MOVLW 0x04
04AF  0452  	IORWF CompTempVar2222, W
04B0  1283  	BCF STATUS, RP0
04B1  0087  	MOVWF gbl_portc

	else
		portc = portc & 0xFB;

	//Delay
	//Delay: 5 us
	delay_us(5);
04B2  3005  	MOVLW 0x05
04B3  1683  	BSF STATUS, RP0
04B4  00D2  	MOVWF delay_us_00000_arg_del
04B5  204A  	CALL delay_us_00000


}
04B6  0008  	RETURN



void FCM_set_tx_addr()

{

	//CSN
	//Output: 0 -> C2
	trisc = trisc & 0xFB;
03A1  30FB  	MOVLW 0xFB
03A2  1683  	BSF STATUS, RP0
03A3  1303  	BCF STATUS, RP1
03A4  0507  	ANDWF gbl_trisc, W
03A5  0087  	MOVWF gbl_trisc

	if ((0))
		portc = (portc & 0xFB) | 0x04;
	else
		portc = portc & 0xFB;
03A6  30FB  	MOVLW 0xFB
03A7  1283  	BCF STATUS, RP0
03A8  0507  	ANDWF gbl_portc, W
03A9  0087  	MOVWF gbl_portc


	//Delay
	//Delay: 5 us
	delay_us(5);
03AA  3005  	MOVLW 0x05
03AB  1683  	BSF STATUS, RP0
03AC  00D2  	MOVWF delay_us_00000_arg_del
03AD  204A  	CALL delay_us_00000


	//Calculation
	//Calculation:
	//  spi_data0 = 0b00110000
	FCV_SPI_DATA0 = 48;
03AE  3030  	MOVLW 0x30
03AF  00B0  	MOVWF gbl_FCV_SPI_DATA0


	//Call Component Macro
	//Call Component Macro: SPI_Send_Char(spi_data0)
	FCD_SPI_Legacy0_SPI_Send_Char(FCV_SPI_DATA0);
03B0  0830  	MOVF gbl_FCV_SPI_DATA0, W
03B1  00D2  	MOVWF FCD_SPI_Le_00053_arg_Char
03B2  2092  	CALL FCD_SPI_Le_00053


	//Calculation
	//Calculation:
	//  spi_data0 = reg10_tx_addr_byte0
	FCV_SPI_DATA0 = FCV_REG10_TX_ADDR_BYTE0;
03B3  0850  	MOVF gbl_FCV_REG10_TX_ADDR_BYTE0, W
03B4  00B0  	MOVWF gbl_FCV_SPI_DATA0


	//Call Component Macro
	//Call Component Macro: SPI_Send_Char(spi_data0)
	FCD_SPI_Legacy0_SPI_Send_Char(FCV_SPI_DATA0);
03B5  0830  	MOVF gbl_FCV_SPI_DATA0, W
03B6  00D2  	MOVWF FCD_SPI_Le_00053_arg_Char
03B7  2092  	CALL FCD_SPI_Le_00053


	//Calculation
	//Calculation:
	//  spi_data0 = reg10_tx_addr_byte1
	FCV_SPI_DATA0 = FCV_REG10_TX_ADDR_BYTE1;
03B8  0824  	MOVF gbl_FCV_REG10_TX_ADDR_BYTE1, W
03B9  00B0  	MOVWF gbl_FCV_SPI_DATA0


	//Call Component Macro
	//Call Component Macro: SPI_Send_Char(spi_data0)
	FCD_SPI_Legacy0_SPI_Send_Char(FCV_SPI_DATA0);
03BA  0830  	MOVF gbl_FCV_SPI_DATA0, W
03BB  00D2  	MOVWF FCD_SPI_Le_00053_arg_Char
03BC  2092  	CALL FCD_SPI_Le_00053


	//Calculation
	//Calculation:
	//  spi_data0 = reg10_tx_addr_byte2
	FCV_SPI_DATA0 = FCV_REG10_TX_ADDR_BYTE2;
03BD  0827  	MOVF gbl_FCV_REG10_TX_ADDR_BYTE2, W
03BE  00B0  	MOVWF gbl_FCV_SPI_DATA0


	//Call Component Macro
	//Call Component Macro: SPI_Send_Char(spi_data0)
	FCD_SPI_Legacy0_SPI_Send_Char(FCV_SPI_DATA0);
03BF  0830  	MOVF gbl_FCV_SPI_DATA0, W
03C0  00D2  	MOVWF FCD_SPI_Le_00053_arg_Char
03C1  2092  	CALL FCD_SPI_Le_00053


	//Calculation
	//Calculation:
	//  spi_data0 = reg10_tx_addr_byte3
	FCV_SPI_DATA0 = FCV_REG10_TX_ADDR_BYTE3;
03C2  082A  	MOVF gbl_FCV_REG10_TX_ADDR_BYTE3, W
03C3  00B0  	MOVWF gbl_FCV_SPI_DATA0


	//Call Component Macro
	//Call Component Macro: SPI_Send_Char(spi_data0)
	FCD_SPI_Legacy0_SPI_Send_Char(FCV_SPI_DATA0);
03C4  0830  	MOVF gbl_FCV_SPI_DATA0, W
03C5  00D2  	MOVWF FCD_SPI_Le_00053_arg_Char
03C6  2092  	CALL FCD_SPI_Le_00053


	//Calculation
	//Calculation:
	//  spi_data0 = reg10_tx_addr_byte4
	FCV_SPI_DATA0 = FCV_REG10_TX_ADDR_BYTE4;
03C7  082B  	MOVF gbl_FCV_REG10_TX_ADDR_BYTE4, W
03C8  00B0  	MOVWF gbl_FCV_SPI_DATA0


	//Call Component Macro
	//Call Component Macro: SPI_Send_Char(spi_data0)
	FCD_SPI_Legacy0_SPI_Send_Char(FCV_SPI_DATA0);
03C9  0830  	MOVF gbl_FCV_SPI_DATA0, W
03CA  00D2  	MOVWF FCD_SPI_Le_00053_arg_Char
03CB  2092  	CALL FCD_SPI_Le_00053


	//CSN
	//Output: 1 -> C2
	trisc = trisc & 0xFB;
03CC  30FB  	MOVLW 0xFB
03CD  0507  	ANDWF gbl_trisc, W
03CE  0087  	MOVWF gbl_trisc

	if ((1))
		portc = (portc & 0xFB) | 0x04;
03CF  30FB  	MOVLW 0xFB
03D0  1283  	BCF STATUS, RP0
03D1  0507  	ANDWF gbl_portc, W
03D2  1683  	BSF STATUS, RP0
03D3  00D2  	MOVWF CompTempVar2223
03D4  3004  	MOVLW 0x04
03D5  0452  	IORWF CompTempVar2223, W
03D6  1283  	BCF STATUS, RP0
03D7  0087  	MOVWF gbl_portc

	else
		portc = portc & 0xFB;

	//Delay
	//Delay: 5 us
	delay_us(5);
03D8  3005  	MOVLW 0x05
03D9  1683  	BSF STATUS, RP0
03DA  00D2  	MOVWF delay_us_00000_arg_del
03DB  204A  	CALL delay_us_00000


}
03DC  0008  	RETURN



void FCM_set_rx_addr()

{

	//CSN
	//Output: 0 -> C2
	trisc = trisc & 0xFB;
03DD  30FB  	MOVLW 0xFB
03DE  1683  	BSF STATUS, RP0
03DF  1303  	BCF STATUS, RP1
03E0  0507  	ANDWF gbl_trisc, W
03E1  0087  	MOVWF gbl_trisc

	if ((0))
		portc = (portc & 0xFB) | 0x04;
	else
		portc = portc & 0xFB;
03E2  30FB  	MOVLW 0xFB
03E3  1283  	BCF STATUS, RP0
03E4  0507  	ANDWF gbl_portc, W
03E5  0087  	MOVWF gbl_portc


	//Delay
	//Delay: 5 us
	delay_us(5);
03E6  3005  	MOVLW 0x05
03E7  1683  	BSF STATUS, RP0
03E8  00D2  	MOVWF delay_us_00000_arg_del
03E9  204A  	CALL delay_us_00000


	//Calculation
	//Calculation:
	//  spi_data0 = 0b00101010
	FCV_SPI_DATA0 = 42;
03EA  302A  	MOVLW 0x2A
03EB  00B0  	MOVWF gbl_FCV_SPI_DATA0


	//Call Component Macro
	//Call Component Macro: SPI_Send_Char(spi_data0)
	FCD_SPI_Legacy0_SPI_Send_Char(FCV_SPI_DATA0);
03EC  0830  	MOVF gbl_FCV_SPI_DATA0, W
03ED  00D2  	MOVWF FCD_SPI_Le_00053_arg_Char
03EE  2092  	CALL FCD_SPI_Le_00053


	//Calculation
	//Calculation:
	//  spi_data0 = reg0A_rx_addr_p0_byte0
	FCV_SPI_DATA0 = FCV_REG0A_RX_ADDR_P0_BYTE0;
03EF  0835  	MOVF gbl_FCV_REG0A_RX_ADDR_P0_BYTE0, W
03F0  00B0  	MOVWF gbl_FCV_SPI_DATA0


	//Call Component Macro
	//Call Component Macro: SPI_Send_Char(spi_data0)
	FCD_SPI_Legacy0_SPI_Send_Char(FCV_SPI_DATA0);
03F1  0830  	MOVF gbl_FCV_SPI_DATA0, W
03F2  00D2  	MOVWF FCD_SPI_Le_00053_arg_Char
03F3  2092  	CALL FCD_SPI_Le_00053


	//Calculation
	//Calculation:
	//  spi_data0 = reg0A_rx_addr_p0_byte1
	FCV_SPI_DATA0 = FCV_REG0A_RX_ADDR_P0_BYTE1;
03F4  0838  	MOVF gbl_FCV_REG0A_RX_ADDR_P0_BYTE1, W
03F5  00B0  	MOVWF gbl_FCV_SPI_DATA0


	//Call Component Macro
	//Call Component Macro: SPI_Send_Char(spi_data0)
	FCD_SPI_Legacy0_SPI_Send_Char(FCV_SPI_DATA0);
03F6  0830  	MOVF gbl_FCV_SPI_DATA0, W
03F7  00D2  	MOVWF FCD_SPI_Le_00053_arg_Char
03F8  2092  	CALL FCD_SPI_Le_00053


	//Calculation
	//Calculation:
	//  spi_data0 = reg0A_rx_addr_p0_byte2
	FCV_SPI_DATA0 = FCV_REG0A_RX_ADDR_P0_BYTE2;
03F9  083B  	MOVF gbl_FCV_REG0A_RX_ADDR_P0_BYTE2, W
03FA  00B0  	MOVWF gbl_FCV_SPI_DATA0


	//Call Component Macro
	//Call Component Macro: SPI_Send_Char(spi_data0)
	FCD_SPI_Legacy0_SPI_Send_Char(FCV_SPI_DATA0);
03FB  0830  	MOVF gbl_FCV_SPI_DATA0, W
03FC  00D2  	MOVWF FCD_SPI_Le_00053_arg_Char
03FD  2092  	CALL FCD_SPI_Le_00053


	//Calculation
	//Calculation:
	//  spi_data0 = reg0A_rx_addr_p0_byte3
	FCV_SPI_DATA0 = FCV_REG0A_RX_ADDR_P0_BYTE3;
03FE  0840  	MOVF gbl_FCV_REG0A_RX_ADDR_P0_BYTE3, W
03FF  00B0  	MOVWF gbl_FCV_SPI_DATA0


	//Call Component Macro
	//Call Component Macro: SPI_Send_Char(spi_data0)
	FCD_SPI_Legacy0_SPI_Send_Char(FCV_SPI_DATA0);
0400  0830  	MOVF gbl_FCV_SPI_DATA0, W
0401  00D2  	MOVWF FCD_SPI_Le_00053_arg_Char
0402  2092  	CALL FCD_SPI_Le_00053


	//Calculation
	//Calculation:
	//  spi_data0 = reg0A_rx_addr_p0_byte4
	FCV_SPI_DATA0 = FCV_REG0A_RX_ADDR_P0_BYTE4;
0403  0844  	MOVF gbl_FCV_REG0A_RX_ADDR_P0_BYTE4, W
0404  00B0  	MOVWF gbl_FCV_SPI_DATA0


	//Call Component Macro
	//Call Component Macro: SPI_Send_Char(spi_data0)
	FCD_SPI_Legacy0_SPI_Send_Char(FCV_SPI_DATA0);
0405  0830  	MOVF gbl_FCV_SPI_DATA0, W
0406  00D2  	MOVWF FCD_SPI_Le_00053_arg_Char
0407  2092  	CALL FCD_SPI_Le_00053


	//CSN
	//Output: 1 -> C2
	trisc = trisc & 0xFB;
0408  30FB  	MOVLW 0xFB
0409  0507  	ANDWF gbl_trisc, W
040A  0087  	MOVWF gbl_trisc

	if ((1))
		portc = (portc & 0xFB) | 0x04;
040B  30FB  	MOVLW 0xFB
040C  1283  	BCF STATUS, RP0
040D  0507  	ANDWF gbl_portc, W
040E  1683  	BSF STATUS, RP0
040F  00D2  	MOVWF CompTempVar2224
0410  3004  	MOVLW 0x04
0411  0452  	IORWF CompTempVar2224, W
0412  1283  	BCF STATUS, RP0
0413  0087  	MOVWF gbl_portc

	else
		portc = portc & 0xFB;

	//Delay
	//Delay: 5 us
	delay_us(5);
0414  3005  	MOVLW 0x05
0415  1683  	BSF STATUS, RP0
0416  00D2  	MOVWF delay_us_00000_arg_del
0417  204A  	CALL delay_us_00000


}
0418  0008  	RETURN



void FCM_radio_send_data()
{

	//Call Macro
	//Call Macro: flush_fifo_txrx()
	FCM_flush_fifo_txrx();

	//CSN
	//Output: 0 -> C2
	trisc = trisc & 0xFB;
	if ((0))
		portc = (portc & 0xFB) | 0x04;
	else
		portc = portc & 0xFB;

	//Delay
	//Delay: 5 us
	delay_us(5);

	//Calculation
	//Calculation:
	//  spi_data0 = 0xA0
	FCV_SPI_DATA0 = 0xA0;

	//Call Component Macro
	//Call Component Macro: SPI_Send_Char(spi_data0)
	FCD_SPI_Legacy0_SPI_Send_Char(FCV_SPI_DATA0);

	//Calculation
	//Calculation:
	//  loop_count = 0
	FCV_LOOP_COUNT = 0;

	//Connection Point
	//Connection Point: [A]: A
FCC_radio_send_data_A:
;

	//Calculation
	//Calculation:
	//  spi_data0 = payload_transmit[loop_count]
	FCV_SPI_DATA0 = FCV_PAYLOAD_TRANSMIT[FCV_LOOP_COUNT];

	//Call Component Macro
	//Call Component Macro: SPI_Send_Char(spi_data0)
	FCD_SPI_Legacy0_SPI_Send_Char(FCV_SPI_DATA0);

	//Calculation
	//Calculation:
	//  loop_count = loop_count + 1
	FCV_LOOP_COUNT = FCV_LOOP_COUNT + 1;

	//Decision
	//Decision: loop_count = payloadsize?
	if (FCV_LOOP_COUNT == FCV_PAYLOADSIZE)
	{

	} else {

		//Goto Connection Point
		//Goto Connection Point: [A]: A
		goto FCC_radio_send_data_A;

	}

	//CSN
	//Output: 1 -> C2
	trisc = trisc & 0xFB;
	if ((1))
		portc = (portc & 0xFB) | 0x04;
	else
		portc = portc & 0xFB;

	//Delay
	//Delay: 5 us
	delay_us(5);

	//CE
	//Output: 1 -> C1
	trisc = trisc & 0xFD;
	if ((1))
		portc = (portc & 0xFD) | 0x02;
	else
		portc = portc & 0xFD;

	//Delay
	//Delay: 6 ms
	delay_ms(6);

	//CE
	//Output: 0 -> C1
	trisc = trisc & 0xFD;
	if ((0))
		portc = (portc & 0xFD) | 0x02;
	else
		portc = portc & 0xFD;

	//Call Macro
	//Call Macro: check_status()
	FCM_check_status();

	//Call Macro
	//Call Macro: show_status()
	FCM_show_status();

	//Calculation
	//Calculation:
	//  status_tx_ds = reg07_status AND 0b00100000
	FCV_STATUS_TX_DS = FCV_REG07_STATUS & 32;

	//Decision
	//Decision: status_tx_ds = 0x20?
	if (FCV_STATUS_TX_DS == 0x20)
	{

		//tx_ack
		//Output: 1 -> C0
		trisc = trisc & 0xFE;
		if ((1))
			portc = (portc & 0xFE) | 0x01;
		else
			portc = portc & 0xFE;

		//Call Component Macro
		//Call Component Macro: Cursor(0, 0)
		FCD_LCDDisplay0_Cursor(0, 0);

		//Call Component Macro
		//Call Component Macro: PrintString("TX SUCCESS!")
		FCD_LCDDisplay0_PrintString("TX SUCCESS!", 11);

		//Calculation
		//Calculation:
		//  reg_to_write = 0x07
		//  data_to_write = 0x2E
		FCV_REG_TO_WRITE = 0x07;
		FCV_DATA_TO_WRITE = 0x2E;

		//Call Macro
		//Call Macro: cmd_write_reg()
		FCM_cmd_write_reg();

	// } else {

	}

	//Calculation
	//Calculation:
	//  status_max_rt = reg07_status AND 0b00010000
	FCV_STATUS_MAX_RT = FCV_REG07_STATUS & 16;

	//Decision
	//Decision: status_max_rt = 0x10?
	if (FCV_STATUS_MAX_RT == 0x10)
	{

		//Call Component Macro
		//Call Component Macro: Cursor(0, 0)
		FCD_LCDDisplay0_Cursor(0, 0);

		//Call Component Macro
		//Call Component Macro: PrintString("TX FAIL")
		FCD_LCDDisplay0_PrintString("TX FAIL", 7);

		//Calculation
		//Calculation:
		//  reg_to_write = 0x07
		//  data_to_write = 0x3E
		FCV_REG_TO_WRITE = 0x07;
		FCV_DATA_TO_WRITE = 0x3E;

		//Call Macro
		//Call Macro: cmd_write_reg()
		FCM_cmd_write_reg();

	// } else {

	}

	//Call Macro
	//Call Macro: disp_datatx()
	FCM_disp_datatx();

}


void FCM_flush_fifo_txrx()

{

	//CSN
	//Output: 0 -> C2
	trisc = trisc & 0xFB;
0466  30FB  	MOVLW 0xFB
0467  1683  	BSF STATUS, RP0
0468  1303  	BCF STATUS, RP1
0469  0507  	ANDWF gbl_trisc, W
046A  0087  	MOVWF gbl_trisc

	if ((0))
		portc = (portc & 0xFB) | 0x04;
	else
		portc = portc & 0xFB;
046B  30FB  	MOVLW 0xFB
046C  1283  	BCF STATUS, RP0
046D  0507  	ANDWF gbl_portc, W
046E  0087  	MOVWF gbl_portc


	//Delay
	//Delay: 5 us
	delay_us(5);
046F  3005  	MOVLW 0x05
0470  1683  	BSF STATUS, RP0
0471  00D2  	MOVWF delay_us_00000_arg_del
0472  204A  	CALL delay_us_00000


	//Calculation
	//Calculation:
	//  spi_data0 = 0xE1
	FCV_SPI_DATA0 = 0xE1;
0473  30E1  	MOVLW 0xE1
0474  00B0  	MOVWF gbl_FCV_SPI_DATA0


	//Call Component Macro
	//Call Component Macro: SPI_Send_Char(spi_data0)
	FCD_SPI_Legacy0_SPI_Send_Char(FCV_SPI_DATA0);
0475  0830  	MOVF gbl_FCV_SPI_DATA0, W
0476  00D2  	MOVWF FCD_SPI_Le_00053_arg_Char
0477  2092  	CALL FCD_SPI_Le_00053


	//Calculation
	//Calculation:
	//  spi_data0 = 0xE2
	FCV_SPI_DATA0 = 0xE2;
0478  30E2  	MOVLW 0xE2
0479  00B0  	MOVWF gbl_FCV_SPI_DATA0


	//Call Component Macro
	//Call Component Macro: SPI_Send_Char(spi_data0)
	FCD_SPI_Legacy0_SPI_Send_Char(FCV_SPI_DATA0);
047A  0830  	MOVF gbl_FCV_SPI_DATA0, W
047B  00D2  	MOVWF FCD_SPI_Le_00053_arg_Char
047C  2092  	CALL FCD_SPI_Le_00053


	//CSN
	//Output: 1 -> C2
	trisc = trisc & 0xFB;
047D  30FB  	MOVLW 0xFB
047E  0507  	ANDWF gbl_trisc, W
047F  0087  	MOVWF gbl_trisc

	if ((1))
		portc = (portc & 0xFB) | 0x04;
0480  30FB  	MOVLW 0xFB
0481  1283  	BCF STATUS, RP0
0482  0507  	ANDWF gbl_portc, W
0483  1683  	BSF STATUS, RP0
0484  00D2  	MOVWF CompTempVar2225
0485  3004  	MOVLW 0x04
0486  0452  	IORWF CompTempVar2225, W
0487  1283  	BCF STATUS, RP0
0488  0087  	MOVWF gbl_portc

	else
		portc = portc & 0xFB;

	//Delay
	//Delay: 5 us
	delay_us(5);
0489  3005  	MOVLW 0x05
048A  1683  	BSF STATUS, RP0
048B  00D2  	MOVWF delay_us_00000_arg_del
048C  204A  	CALL delay_us_00000


}
048D  0008  	RETURN



void FCM_nrf_rx_init()

{

	//Input
	//Input: PORTA -> reg0A_rx_addr_p0_byte4
	trisa = trisa | 0x0F;
062F  300F  	MOVLW 0x0F
0630  1683  	BSF STATUS, RP0
0631  1303  	BCF STATUS, RP1
0632  0405  	IORWF gbl_trisa, W
0633  0085  	MOVWF gbl_trisa

	FCV_REG0A_RX_ADDR_P0_BYTE4 = porta & 0x0F;
0634  300F  	MOVLW 0x0F
0635  1283  	BCF STATUS, RP0
0636  0505  	ANDWF gbl_porta, W
0637  1683  	BSF STATUS, RP0
0638  00C4  	MOVWF gbl_FCV_REG0A_RX_ADDR_P0_BYTE4


	//Calculation
	//Calculation:
	//  reg0A_rx_addr_p0_byte4 = reg0A_rx_addr_p0_byte4 + 48
	FCV_REG0A_RX_ADDR_P0_BYTE4 = FCV_REG0A_RX_ADDR_P0_BYTE4 + 48;
0639  3030  	MOVLW 0x30
063A  0744  	ADDWF gbl_FCV_REG0A_RX_ADDR_P0_BYTE4, W
063B  00C4  	MOVWF gbl_FCV_REG0A_RX_ADDR_P0_BYTE4


	//Calculation
	//Calculation:
	//  reg10_tx_addr_byte4 = reg0A_rx_addr_p0_byte4
	FCV_REG10_TX_ADDR_BYTE4 = FCV_REG0A_RX_ADDR_P0_BYTE4;
063C  0844  	MOVF gbl_FCV_REG0A_RX_ADDR_P0_BYTE4, W
063D  00AB  	MOVWF gbl_FCV_REG10_TX_ADDR_BYTE4


	//declare tx addr
	//Calculation:
	//  reg10_tx_addr_byte0 = '0'
	//  reg10_tx_addr_byte1 = '0'
	//  reg10_tx_addr_byte2 = '0'
	//  reg10_tx_addr_byte3 = '0'
	FCV_REG10_TX_ADDR_BYTE0 = '0';
063E  3030  	MOVLW 0x30
063F  00D0  	MOVWF gbl_FCV_REG10_TX_ADDR_BYTE0

	FCV_REG10_TX_ADDR_BYTE1 = '0';
0640  00A4  	MOVWF gbl_FCV_REG10_TX_ADDR_BYTE1

	FCV_REG10_TX_ADDR_BYTE2 = '0';
0641  00A7  	MOVWF gbl_FCV_REG10_TX_ADDR_BYTE2

	FCV_REG10_TX_ADDR_BYTE3 = '0';
0642  00AA  	MOVWF gbl_FCV_REG10_TX_ADDR_BYTE3


	//declare rx addr
	//Calculation:
	//  reg0A_rx_addr_p0_byte0 = '0'
	//  reg0A_rx_addr_p0_byte1 = '0'
	//  reg0A_rx_addr_p0_byte2 = '0'
	//  reg0A_rx_addr_p0_byte3 = '0'
	FCV_REG0A_RX_ADDR_P0_BYTE0 = '0';
0643  00B5  	MOVWF gbl_FCV_REG0A_RX_ADDR_P0_BYTE0

	FCV_REG0A_RX_ADDR_P0_BYTE1 = '0';
0644  00B8  	MOVWF gbl_FCV_REG0A_RX_ADDR_P0_BYTE1

	FCV_REG0A_RX_ADDR_P0_BYTE2 = '0';
0645  00BB  	MOVWF gbl_FCV_REG0A_RX_ADDR_P0_BYTE2

	FCV_REG0A_RX_ADDR_P0_BYTE3 = '0';
0646  00C0  	MOVWF gbl_FCV_REG0A_RX_ADDR_P0_BYTE3


	//Calculation
	//Calculation:
	//  reg_to_write = 0x00
	//  data_to_write = 0x0F
	FCV_REG_TO_WRITE = 0x00;
0647  01C3  	CLRF gbl_FCV_REG_TO_WRITE

	FCV_DATA_TO_WRITE = 0x0F;
0648  300F  	MOVLW 0x0F
0649  00A3  	MOVWF gbl_FCV_DATA_TO_WRITE


	//Call Macro
	//Call Macro: cmd_write_reg()
	FCM_cmd_write_reg();
064A  248E  	CALL FCM_cmd_wr_0005F


	//Calculation
	//Calculation:
	//  reg_to_write = 01
	//  data_to_write = 0x3F
	FCV_REG_TO_WRITE = 01;
064B  3001  	MOVLW 0x01
064C  00C3  	MOVWF gbl_FCV_REG_TO_WRITE

	FCV_DATA_TO_WRITE = 0x3F;
064D  303F  	MOVLW 0x3F
064E  00A3  	MOVWF gbl_FCV_DATA_TO_WRITE


	//Call Macro
	//Call Macro: cmd_write_reg()
	FCM_cmd_write_reg();
064F  248E  	CALL FCM_cmd_wr_0005F


	//Calculation
	//Calculation:
	//  reg_to_write = 02
	//  data_to_write = 0x03
	FCV_REG_TO_WRITE = 02;
0650  3002  	MOVLW 0x02
0651  00C3  	MOVWF gbl_FCV_REG_TO_WRITE

	FCV_DATA_TO_WRITE = 0x03;
0652  3003  	MOVLW 0x03
0653  00A3  	MOVWF gbl_FCV_DATA_TO_WRITE


	//Call Macro
	//Call Macro: cmd_write_reg()
	FCM_cmd_write_reg();
0654  248E  	CALL FCM_cmd_wr_0005F


	//Calculation
	//Calculation:
	//  reg_to_write = 03
	//  data_to_write = 0x03
	FCV_REG_TO_WRITE = 03;
0655  3003  	MOVLW 0x03
0656  00C3  	MOVWF gbl_FCV_REG_TO_WRITE

	FCV_DATA_TO_WRITE = 0x03;
0657  00A3  	MOVWF gbl_FCV_DATA_TO_WRITE


	//Call Macro
	//Call Macro: cmd_write_reg()
	FCM_cmd_write_reg();
0658  248E  	CALL FCM_cmd_wr_0005F


	//Calculation
	//Calculation:
	//  reg_to_write = 0x04
	//  data_to_write = 0x5F
	FCV_REG_TO_WRITE = 0x04;
0659  3004  	MOVLW 0x04
065A  00C3  	MOVWF gbl_FCV_REG_TO_WRITE

	FCV_DATA_TO_WRITE = 0x5F;
065B  305F  	MOVLW 0x5F
065C  00A3  	MOVWF gbl_FCV_DATA_TO_WRITE


	//Call Macro
	//Call Macro: cmd_write_reg()
	FCM_cmd_write_reg();
065D  248E  	CALL FCM_cmd_wr_0005F


	//Calculation
	//Calculation:
	//  reg_to_write = 0x05
	//  data_to_write = 0x4C
	FCV_REG_TO_WRITE = 0x05;
065E  3005  	MOVLW 0x05
065F  00C3  	MOVWF gbl_FCV_REG_TO_WRITE

	FCV_DATA_TO_WRITE = 0x4C;
0660  304C  	MOVLW 0x4C
0661  00A3  	MOVWF gbl_FCV_DATA_TO_WRITE


	//Call Macro
	//Call Macro: cmd_write_reg()
	FCM_cmd_write_reg();
0662  248E  	CALL FCM_cmd_wr_0005F


	//Calculation
	//Calculation:
	//  reg_to_write = 0x06
	//  data_to_write = 0x27
	FCV_REG_TO_WRITE = 0x06;
0663  3006  	MOVLW 0x06
0664  00C3  	MOVWF gbl_FCV_REG_TO_WRITE

	FCV_DATA_TO_WRITE = 0x27;
0665  3027  	MOVLW 0x27
0666  00A3  	MOVWF gbl_FCV_DATA_TO_WRITE


	//Call Macro
	//Call Macro: cmd_write_reg()
	FCM_cmd_write_reg();
0667  248E  	CALL FCM_cmd_wr_0005F


	//Calculation
	//Calculation:
	//  reg_to_write = 0x11
	//  data_to_write = payloadsize
	FCV_REG_TO_WRITE = 0x11;
0668  3011  	MOVLW 0x11
0669  00C3  	MOVWF gbl_FCV_REG_TO_WRITE

	FCV_DATA_TO_WRITE = FCV_PAYLOADSIZE;
066A  0849  	MOVF gbl_FCV_PAYLOADSIZE, W
066B  00A3  	MOVWF gbl_FCV_DATA_TO_WRITE


	//Call Macro
	//Call Macro: cmd_write_reg()
	FCM_cmd_write_reg();
066C  248E  	CALL FCM_cmd_wr_0005F


	//Call Macro
	//Call Macro: set_tx_addr()
	FCM_set_tx_addr();
066D  23A1  	CALL FCM_set_tx_00060


	//Call Macro
	//Call Macro: set_rx_addr()
	FCM_set_rx_addr();
066E  23DD  	CALL FCM_set_rx_00061


	//Call Macro
	//Call Macro: flush_fifo_txrx()
	FCM_flush_fifo_txrx();
066F  2466  	CALL FCM_flush__00062


}
0670  0008  	RETURN



void FCM_show_status()

{

	//Call Component Macro
	//Call Component Macro: Cursor(0, 3)
	FCD_LCDDisplay0_Cursor(0, 3);
038E  1683  	BSF STATUS, RP0
038F  1303  	BCF STATUS, RP1
0390  01D2  	CLRF FCD_LCDDis_00056_arg_x
0391  3003  	MOVLW 0x03
0392  00D3  	MOVWF FCD_LCDDis_00056_arg_y
0393  235D  	CALL FCD_LCDDis_00056


	//Call Component Macro
	//Call Component Macro: PrintNumber(reg07_status)
	FCD_LCDDisplay0_PrintNumber(FCV_REG07_STATUS);
0394  083A  	MOVF gbl_FCV_REG07_STATUS, W
0395  00D2  	MOVWF FCD_LCDDis_00057_arg_Number
0396  01D3  	CLRF FCD_LCDDis_00057_arg_Number+D'1'
0397  226F  	CALL FCD_LCDDis_00057


	//Call Component Macro
	//Call Component Macro: Cursor(3, 3)
	FCD_LCDDisplay0_Cursor(3, 3);
0398  3003  	MOVLW 0x03
0399  00D2  	MOVWF FCD_LCDDis_00056_arg_x
039A  00D3  	MOVWF FCD_LCDDis_00056_arg_y
039B  235D  	CALL FCD_LCDDis_00056


	//Call Component Macro
	//Call Component Macro: PrintNumber(reg17_fifo_status)
	FCD_LCDDisplay0_PrintNumber(FCV_REG17_FIFO_STATUS);
039C  082F  	MOVF gbl_FCV_REG17_FIFO_STATUS, W
039D  00D2  	MOVWF FCD_LCDDis_00057_arg_Number
039E  01D3  	CLRF FCD_LCDDis_00057_arg_Number+D'1'
039F  226F  	CALL FCD_LCDDis_00057


}
03A0  0008  	RETURN



void FCM_radio_recieve_data()

{

	//Delay
	//Delay: 4 ms
	delay_ms(4);
05B3  3004  	MOVLW 0x04
05B4  1683  	BSF STATUS, RP0
05B5  1303  	BCF STATUS, RP1
05B6  00D6  	MOVWF delay_ms_00000_arg_del
05B7  2010  	CALL delay_ms_00000


	//Call Macro
	//Call Macro: check_status()
	FCM_check_status();
05B8  24B7  	CALL FCM_check__00064


	//Call Macro
	//Call Macro: show_status()
	FCM_show_status();
05B9  238E  	CALL FCM_show_s_00065


	//Decision
	//Decision: reg07_status = 64?
	if (FCV_REG07_STATUS == 64)
05BA  083A  	MOVF gbl_FCV_REG07_STATUS, W
05BB  3A40  	XORLW 0x40
05BC  1D03  	BTFSS STATUS,Z
05BD  2DF5  	GOTO	label67
05F5        label67

	{

		//rx_ack
		//Output: 1 -> A5
		trisa = trisa & 0xDF;
05BE  30DF  	MOVLW 0xDF
05BF  0505  	ANDWF gbl_trisa, W
05C0  0085  	MOVWF gbl_trisa

		if ((1))
			porta = (porta & 0xDF) | 0x20;
05C1  30DF  	MOVLW 0xDF
05C2  1283  	BCF STATUS, RP0
05C3  0505  	ANDWF gbl_porta, W
05C4  1683  	BSF STATUS, RP0
05C5  00D2  	MOVWF CompTempVar2235
05C6  3020  	MOVLW 0x20
05C7  0452  	IORWF CompTempVar2235, W
05C8  1283  	BCF STATUS, RP0
05C9  0085  	MOVWF gbl_porta

		else
			porta = porta & 0xDF;

		//Call Component Macro
		//Call Component Macro: Cursor(0, 0)
		FCD_LCDDisplay0_Cursor(0, 0);
05CA  1683  	BSF STATUS, RP0
05CB  01D2  	CLRF FCD_LCDDis_00056_arg_x
05CC  01D3  	CLRF FCD_LCDDis_00056_arg_y
05CD  235D  	CALL FCD_LCDDis_00056


		//Call Component Macro
		//Call Component Macro: PrintString("DATA RECIEVED!")
		FCD_LCDDisplay0_PrintString("DATA RECIEVED!", 14);
05CE  3020  	MOVLW 0x20
05CF  00D8  	MOVWF CompTempVar2236+D'4'
05D0  3021  	MOVLW 0x21
05D1  00E1  	MOVWF CompTempVar2236+D'13'
05D2  3041  	MOVLW 0x41
05D3  00D5  	MOVWF CompTempVar2236+D'1'
05D4  00D7  	MOVWF CompTempVar2236+D'3'
05D5  3043  	MOVLW 0x43
05D6  00DB  	MOVWF CompTempVar2236+D'7'
05D7  3044  	MOVLW 0x44
05D8  00D4  	MOVWF CompTempVar2236
05D9  00E0  	MOVWF CompTempVar2236+D'12'
05DA  3045  	MOVLW 0x45
05DB  00DA  	MOVWF CompTempVar2236+D'6'
05DC  00DD  	MOVWF CompTempVar2236+D'9'
05DD  00DF  	MOVWF CompTempVar2236+D'11'
05DE  3049  	MOVLW 0x49
05DF  00DC  	MOVWF CompTempVar2236+D'8'
05E0  3052  	MOVLW 0x52
05E1  00D9  	MOVWF CompTempVar2236+D'5'
05E2  3054  	MOVLW 0x54
05E3  00D6  	MOVWF CompTempVar2236+D'2'
05E4  3056  	MOVLW 0x56
05E5  00DE  	MOVWF CompTempVar2236+D'10'
05E6  01E2  	CLRF CompTempVar2236+D'14'
05E7  3000  	MOVLW HIGH(CompTempVar2236+D'0')
05E8  00D3  	MOVWF FCD_LCDDis_0005C_arg_String+D'1'
05E9  30D4  	MOVLW LOW(CompTempVar2236+D'0')
05EA  00D2  	MOVWF FCD_LCDDis_0005C_arg_String
05EB  300E  	MOVLW 0x0E
05EC  00E4  	MOVWF FCD_LCDDis_0005C_arg_MSZ_String
05ED  24C4  	CALL FCD_LCDDis_0005C


		//Call Macro
		//Call Macro: read_recieved_data()
		FCM_read_recieved_data();
05EE  2419  	CALL FCM_read_r_00069


		//Calculation
		//Calculation:
		//  reg_to_write = 0x07
		//  data_to_write = 0x4E
		FCV_REG_TO_WRITE = 0x07;
05EF  3007  	MOVLW 0x07
05F0  00C3  	MOVWF gbl_FCV_REG_TO_WRITE

		FCV_DATA_TO_WRITE = 0x4E;
05F1  304E  	MOVLW 0x4E
05F2  00A3  	MOVWF gbl_FCV_DATA_TO_WRITE


		//Call Macro
		//Call Macro: cmd_write_reg()
		FCM_cmd_write_reg();
05F3  248E  	CALL FCM_cmd_wr_0005F


	} else {
05F4  2E2D  	GOTO	label68
062D        label68


		//rx_ack
		//Output: 0 -> A5
		trisa = trisa & 0xDF;
05F5  30DF  	MOVLW 0xDF
05F6  0505  	ANDWF gbl_trisa, W
05F7  0085  	MOVWF gbl_trisa

		if ((0))
			porta = (porta & 0xDF) | 0x20;
		else
			porta = porta & 0xDF;
05F8  30DF  	MOVLW 0xDF
05F9  1283  	BCF STATUS, RP0
05FA  0505  	ANDWF gbl_porta, W
05FB  0085  	MOVWF gbl_porta


		//Call Component Macro
		//Call Component Macro: Cursor(0, 0)
		FCD_LCDDisplay0_Cursor(0, 0);
05FC  1683  	BSF STATUS, RP0
05FD  01D2  	CLRF FCD_LCDDis_00056_arg_x
05FE  01D3  	CLRF FCD_LCDDis_00056_arg_y
05FF  235D  	CALL FCD_LCDDis_00056


		//Call Component Macro
		//Call Component Macro: PrintString("NO TX DETECTED!")
		FCD_LCDDisplay0_PrintString("NO TX DETECTED!", 15);
0600  3020  	MOVLW 0x20
0601  00D6  	MOVWF CompTempVar2238+D'2'
0602  00D9  	MOVWF CompTempVar2238+D'5'
0603  3021  	MOVLW 0x21
0604  00E2  	MOVWF CompTempVar2238+D'14'
0605  3043  	MOVLW 0x43
0606  00DE  	MOVWF CompTempVar2238+D'10'
0607  3044  	MOVLW 0x44
0608  00DA  	MOVWF CompTempVar2238+D'6'
0609  00E1  	MOVWF CompTempVar2238+D'13'
060A  3045  	MOVLW 0x45
060B  00DB  	MOVWF CompTempVar2238+D'7'
060C  00DD  	MOVWF CompTempVar2238+D'9'
060D  00E0  	MOVWF CompTempVar2238+D'12'
060E  304E  	MOVLW 0x4E
060F  00D4  	MOVWF CompTempVar2238
0610  304F  	MOVLW 0x4F
0611  00D5  	MOVWF CompTempVar2238+D'1'
0612  3054  	MOVLW 0x54
0613  00D7  	MOVWF CompTempVar2238+D'3'
0614  00DC  	MOVWF CompTempVar2238+D'8'
0615  00DF  	MOVWF CompTempVar2238+D'11'
0616  3058  	MOVLW 0x58
0617  00D8  	MOVWF CompTempVar2238+D'4'
0618  01E3  	CLRF CompTempVar2238+D'15'
0619  3000  	MOVLW HIGH(CompTempVar2238+D'0')
061A  00D3  	MOVWF FCD_LCDDis_0005C_arg_String+D'1'
061B  30D4  	MOVLW LOW(CompTempVar2238+D'0')
061C  00D2  	MOVWF FCD_LCDDis_0005C_arg_String
061D  300F  	MOVLW 0x0F
061E  00E4  	MOVWF FCD_LCDDis_0005C_arg_MSZ_String
061F  24C4  	CALL FCD_LCDDis_0005C


		//Calculation
		//Calculation:
		//  payload_recieve = ""
		FCI_SCOPY("",0, FCV_PAYLOAD_RECIEVE,FCSZ_PAYLOAD_RECIEVE);
0620  01D4  	CLRF CompTempVar2240
0621  3000  	MOVLW HIGH(CompTempVar2240+D'0')
0622  00D3  	MOVWF FCI_SCOPY_00000_arg_sSrc+D'1'
0623  30D4  	MOVLW LOW(CompTempVar2240+D'0')
0624  00D2  	MOVWF FCI_SCOPY_00000_arg_sSrc
0625  01E5  	CLRF FCI_SCOPY_00000_arg_iSrc_len
0626  3000  	MOVLW HIGH(gbl_FCV_PAYLOAD_RECIEVE+D'0')
0627  00E7  	MOVWF FCI_SCOPY_00000_arg_sDst+D'1'
0628  3020  	MOVLW LOW(gbl_FCV_PAYLOAD_RECIEVE+D'0')
0629  00E6  	MOVWF FCI_SCOPY_00000_arg_sDst
062A  3010  	MOVLW 0x10
062B  00E8  	MOVWF FCI_SCOPY_00000_arg_iDst_len
062C  223B  	CALL FCI_SCOPY_00000


	}

	//Call Macro
	//Call Macro: flush_fifo_txrx()
	FCM_flush_fifo_txrx();
062D  2466  	CALL FCM_flush__00062


}
062E  0008  	RETURN



void FCM_tx_addr_to_string()

{

	//Calculation
	//Calculation:
	//  tx_addr = tx_addr + reg10_tx_addr_byte0
	FCI_SHEAD(FCV_TX_ADDR,FCSZ_TX_ADDR, &FCV_REG10_TX_ADDR_BYTE0,1, FCV_TX_ADDR,FCSZ_TX_ADDR);
04EF  3000  	MOVLW HIGH(gbl_FCV_TX_ADDR+D'0')
04F0  1683  	BSF STATUS, RP0
04F1  1303  	BCF STATUS, RP1
04F2  00D3  	MOVWF FCI_SHEAD_00000_arg_sSrc1+D'1'
04F3  3050  	MOVLW LOW(gbl_FCV_TX_ADDR+D'0')
04F4  00D2  	MOVWF FCI_SHEAD_00000_arg_sSrc1
04F5  3010  	MOVLW 0x10
04F6  00D4  	MOVWF FCI_SHEAD_00000_arg_iSrc1_len
04F7  3000  	MOVLW HIGH(gbl_FCV_REG10_TX_ADDR_BYTE0+D'0')
04F8  00D6  	MOVWF FCI_SHEAD_00000_arg_sSrc2+D'1'
04F9  30D0  	MOVLW LOW(gbl_FCV_REG10_TX_ADDR_BYTE0+D'0')
04FA  00D5  	MOVWF FCI_SHEAD_00000_arg_sSrc2
04FB  3001  	MOVLW 0x01
04FC  00D7  	MOVWF FCI_SHEAD_00000_arg_iSrc2_len
04FD  3000  	MOVLW HIGH(gbl_FCV_TX_ADDR+D'0')
04FE  00D9  	MOVWF FCI_SHEAD_00000_arg_sDst+D'1'
04FF  3050  	MOVLW LOW(gbl_FCV_TX_ADDR+D'0')
0500  00D8  	MOVWF FCI_SHEAD_00000_arg_sDst
0501  3010  	MOVLW 0x10
0502  00DA  	MOVWF FCI_SHEAD_00000_arg_iDst_len
0503  2125  	CALL FCI_SHEAD_00000


	//Calculation
	//Calculation:
	//  tx_addr = tx_addr + reg10_tx_addr_byte1
	FCI_SHEAD(FCV_TX_ADDR,FCSZ_TX_ADDR, &FCV_REG10_TX_ADDR_BYTE1,1, FCV_TX_ADDR,FCSZ_TX_ADDR);
0504  3000  	MOVLW HIGH(gbl_FCV_TX_ADDR+D'0')
0505  00D3  	MOVWF FCI_SHEAD_00000_arg_sSrc1+D'1'
0506  3050  	MOVLW LOW(gbl_FCV_TX_ADDR+D'0')
0507  00D2  	MOVWF FCI_SHEAD_00000_arg_sSrc1
0508  3010  	MOVLW 0x10
0509  00D4  	MOVWF FCI_SHEAD_00000_arg_iSrc1_len
050A  3000  	MOVLW HIGH(gbl_FCV_REG10_TX_ADDR_BYTE1+D'0')
050B  00D6  	MOVWF FCI_SHEAD_00000_arg_sSrc2+D'1'
050C  30A4  	MOVLW LOW(gbl_FCV_REG10_TX_ADDR_BYTE1+D'0')
050D  00D5  	MOVWF FCI_SHEAD_00000_arg_sSrc2
050E  3001  	MOVLW 0x01
050F  00D7  	MOVWF FCI_SHEAD_00000_arg_iSrc2_len
0510  3000  	MOVLW HIGH(gbl_FCV_TX_ADDR+D'0')
0511  00D9  	MOVWF FCI_SHEAD_00000_arg_sDst+D'1'
0512  3050  	MOVLW LOW(gbl_FCV_TX_ADDR+D'0')
0513  00D8  	MOVWF FCI_SHEAD_00000_arg_sDst
0514  3010  	MOVLW 0x10
0515  00DA  	MOVWF FCI_SHEAD_00000_arg_iDst_len
0516  2125  	CALL FCI_SHEAD_00000


	//Calculation
	//Calculation:
	//  tx_addr = tx_addr + reg10_tx_addr_byte2
	FCI_SHEAD(FCV_TX_ADDR,FCSZ_TX_ADDR, &FCV_REG10_TX_ADDR_BYTE2,1, FCV_TX_ADDR,FCSZ_TX_ADDR);
0517  3000  	MOVLW HIGH(gbl_FCV_TX_ADDR+D'0')
0518  00D3  	MOVWF FCI_SHEAD_00000_arg_sSrc1+D'1'
0519  3050  	MOVLW LOW(gbl_FCV_TX_ADDR+D'0')
051A  00D2  	MOVWF FCI_SHEAD_00000_arg_sSrc1
051B  3010  	MOVLW 0x10
051C  00D4  	MOVWF FCI_SHEAD_00000_arg_iSrc1_len
051D  3000  	MOVLW HIGH(gbl_FCV_REG10_TX_ADDR_BYTE2+D'0')
051E  00D6  	MOVWF FCI_SHEAD_00000_arg_sSrc2+D'1'
051F  30A7  	MOVLW LOW(gbl_FCV_REG10_TX_ADDR_BYTE2+D'0')
0520  00D5  	MOVWF FCI_SHEAD_00000_arg_sSrc2
0521  3001  	MOVLW 0x01
0522  00D7  	MOVWF FCI_SHEAD_00000_arg_iSrc2_len
0523  3000  	MOVLW HIGH(gbl_FCV_TX_ADDR+D'0')
0524  00D9  	MOVWF FCI_SHEAD_00000_arg_sDst+D'1'
0525  3050  	MOVLW LOW(gbl_FCV_TX_ADDR+D'0')
0526  00D8  	MOVWF FCI_SHEAD_00000_arg_sDst
0527  3010  	MOVLW 0x10
0528  00DA  	MOVWF FCI_SHEAD_00000_arg_iDst_len
0529  2125  	CALL FCI_SHEAD_00000


	//Calculation
	//Calculation:
	//  tx_addr = tx_addr + reg10_tx_addr_byte3
	FCI_SHEAD(FCV_TX_ADDR,FCSZ_TX_ADDR, &FCV_REG10_TX_ADDR_BYTE3,1, FCV_TX_ADDR,FCSZ_TX_ADDR);
052A  3000  	MOVLW HIGH(gbl_FCV_TX_ADDR+D'0')
052B  00D3  	MOVWF FCI_SHEAD_00000_arg_sSrc1+D'1'
052C  3050  	MOVLW LOW(gbl_FCV_TX_ADDR+D'0')
052D  00D2  	MOVWF FCI_SHEAD_00000_arg_sSrc1
052E  3010  	MOVLW 0x10
052F  00D4  	MOVWF FCI_SHEAD_00000_arg_iSrc1_len
0530  3000  	MOVLW HIGH(gbl_FCV_REG10_TX_ADDR_BYTE3+D'0')
0531  00D6  	MOVWF FCI_SHEAD_00000_arg_sSrc2+D'1'
0532  30AA  	MOVLW LOW(gbl_FCV_REG10_TX_ADDR_BYTE3+D'0')
0533  00D5  	MOVWF FCI_SHEAD_00000_arg_sSrc2
0534  3001  	MOVLW 0x01
0535  00D7  	MOVWF FCI_SHEAD_00000_arg_iSrc2_len
0536  3000  	MOVLW HIGH(gbl_FCV_TX_ADDR+D'0')
0537  00D9  	MOVWF FCI_SHEAD_00000_arg_sDst+D'1'
0538  3050  	MOVLW LOW(gbl_FCV_TX_ADDR+D'0')
0539  00D8  	MOVWF FCI_SHEAD_00000_arg_sDst
053A  3010  	MOVLW 0x10
053B  00DA  	MOVWF FCI_SHEAD_00000_arg_iDst_len
053C  2125  	CALL FCI_SHEAD_00000


	//Calculation
	//Calculation:
	//  tx_addr = tx_addr + reg10_tx_addr_byte4
	FCI_SHEAD(FCV_TX_ADDR,FCSZ_TX_ADDR, &FCV_REG10_TX_ADDR_BYTE4,1, FCV_TX_ADDR,FCSZ_TX_ADDR);
053D  3000  	MOVLW HIGH(gbl_FCV_TX_ADDR+D'0')
053E  00D3  	MOVWF FCI_SHEAD_00000_arg_sSrc1+D'1'
053F  3050  	MOVLW LOW(gbl_FCV_TX_ADDR+D'0')
0540  00D2  	MOVWF FCI_SHEAD_00000_arg_sSrc1
0541  3010  	MOVLW 0x10
0542  00D4  	MOVWF FCI_SHEAD_00000_arg_iSrc1_len
0543  3000  	MOVLW HIGH(gbl_FCV_REG10_TX_ADDR_BYTE4+D'0')
0544  00D6  	MOVWF FCI_SHEAD_00000_arg_sSrc2+D'1'
0545  30AB  	MOVLW LOW(gbl_FCV_REG10_TX_ADDR_BYTE4+D'0')
0546  00D5  	MOVWF FCI_SHEAD_00000_arg_sSrc2
0547  3001  	MOVLW 0x01
0548  00D7  	MOVWF FCI_SHEAD_00000_arg_iSrc2_len
0549  3000  	MOVLW HIGH(gbl_FCV_TX_ADDR+D'0')
054A  00D9  	MOVWF FCI_SHEAD_00000_arg_sDst+D'1'
054B  3050  	MOVLW LOW(gbl_FCV_TX_ADDR+D'0')
054C  00D8  	MOVWF FCI_SHEAD_00000_arg_sDst
054D  3010  	MOVLW 0x10
054E  00DA  	MOVWF FCI_SHEAD_00000_arg_iDst_len
054F  2125  	CALL FCI_SHEAD_00000


}
0550  0008  	RETURN



void FCM_rx_addr_to_string()

{

	//Calculation
	//Calculation:
	//  rx_addr = rx_addr + reg0A_rx_addr_p0_byte0
	FCI_SHEAD(FCV_RX_ADDR,FCSZ_RX_ADDR, &FCV_REG0A_RX_ADDR_P0_BYTE0,1, FCV_RX_ADDR,FCSZ_RX_ADDR);
0551  3000  	MOVLW HIGH(gbl_FCV_RX_ADDR+D'0')
0552  1683  	BSF STATUS, RP0
0553  1303  	BCF STATUS, RP1
0554  00D3  	MOVWF FCI_SHEAD_00000_arg_sSrc1+D'1'
0555  3040  	MOVLW LOW(gbl_FCV_RX_ADDR+D'0')
0556  00D2  	MOVWF FCI_SHEAD_00000_arg_sSrc1
0557  3010  	MOVLW 0x10
0558  00D4  	MOVWF FCI_SHEAD_00000_arg_iSrc1_len
0559  3000  	MOVLW HIGH(gbl_FCV_REG0A_RX_ADDR_P0_BYTE0+D'0')
055A  00D6  	MOVWF FCI_SHEAD_00000_arg_sSrc2+D'1'
055B  30B5  	MOVLW LOW(gbl_FCV_REG0A_RX_ADDR_P0_BYTE0+D'0')
055C  00D5  	MOVWF FCI_SHEAD_00000_arg_sSrc2
055D  3001  	MOVLW 0x01
055E  00D7  	MOVWF FCI_SHEAD_00000_arg_iSrc2_len
055F  3000  	MOVLW HIGH(gbl_FCV_RX_ADDR+D'0')
0560  00D9  	MOVWF FCI_SHEAD_00000_arg_sDst+D'1'
0561  3040  	MOVLW LOW(gbl_FCV_RX_ADDR+D'0')
0562  00D8  	MOVWF FCI_SHEAD_00000_arg_sDst
0563  3010  	MOVLW 0x10
0564  00DA  	MOVWF FCI_SHEAD_00000_arg_iDst_len
0565  2125  	CALL FCI_SHEAD_00000


	//Calculation
	//Calculation:
	//  rx_addr = rx_addr + reg0A_rx_addr_p0_byte1
	FCI_SHEAD(FCV_RX_ADDR,FCSZ_RX_ADDR, &FCV_REG0A_RX_ADDR_P0_BYTE1,1, FCV_RX_ADDR,FCSZ_RX_ADDR);
0566  3000  	MOVLW HIGH(gbl_FCV_RX_ADDR+D'0')
0567  00D3  	MOVWF FCI_SHEAD_00000_arg_sSrc1+D'1'
0568  3040  	MOVLW LOW(gbl_FCV_RX_ADDR+D'0')
0569  00D2  	MOVWF FCI_SHEAD_00000_arg_sSrc1
056A  3010  	MOVLW 0x10
056B  00D4  	MOVWF FCI_SHEAD_00000_arg_iSrc1_len
056C  3000  	MOVLW HIGH(gbl_FCV_REG0A_RX_ADDR_P0_BYTE1+D'0')
056D  00D6  	MOVWF FCI_SHEAD_00000_arg_sSrc2+D'1'
056E  30B8  	MOVLW LOW(gbl_FCV_REG0A_RX_ADDR_P0_BYTE1+D'0')
056F  00D5  	MOVWF FCI_SHEAD_00000_arg_sSrc2
0570  3001  	MOVLW 0x01
0571  00D7  	MOVWF FCI_SHEAD_00000_arg_iSrc2_len
0572  3000  	MOVLW HIGH(gbl_FCV_RX_ADDR+D'0')
0573  00D9  	MOVWF FCI_SHEAD_00000_arg_sDst+D'1'
0574  3040  	MOVLW LOW(gbl_FCV_RX_ADDR+D'0')
0575  00D8  	MOVWF FCI_SHEAD_00000_arg_sDst
0576  3010  	MOVLW 0x10
0577  00DA  	MOVWF FCI_SHEAD_00000_arg_iDst_len
0578  2125  	CALL FCI_SHEAD_00000


	//Calculation
	//Calculation:
	//  rx_addr = rx_addr + reg0A_rx_addr_p0_byte2
	FCI_SHEAD(FCV_RX_ADDR,FCSZ_RX_ADDR, &FCV_REG0A_RX_ADDR_P0_BYTE2,1, FCV_RX_ADDR,FCSZ_RX_ADDR);
0579  3000  	MOVLW HIGH(gbl_FCV_RX_ADDR+D'0')
057A  00D3  	MOVWF FCI_SHEAD_00000_arg_sSrc1+D'1'
057B  3040  	MOVLW LOW(gbl_FCV_RX_ADDR+D'0')
057C  00D2  	MOVWF FCI_SHEAD_00000_arg_sSrc1
057D  3010  	MOVLW 0x10
057E  00D4  	MOVWF FCI_SHEAD_00000_arg_iSrc1_len
057F  3000  	MOVLW HIGH(gbl_FCV_REG0A_RX_ADDR_P0_BYTE2+D'0')
0580  00D6  	MOVWF FCI_SHEAD_00000_arg_sSrc2+D'1'
0581  30BB  	MOVLW LOW(gbl_FCV_REG0A_RX_ADDR_P0_BYTE2+D'0')
0582  00D5  	MOVWF FCI_SHEAD_00000_arg_sSrc2
0583  3001  	MOVLW 0x01
0584  00D7  	MOVWF FCI_SHEAD_00000_arg_iSrc2_len
0585  3000  	MOVLW HIGH(gbl_FCV_RX_ADDR+D'0')
0586  00D9  	MOVWF FCI_SHEAD_00000_arg_sDst+D'1'
0587  3040  	MOVLW LOW(gbl_FCV_RX_ADDR+D'0')
0588  00D8  	MOVWF FCI_SHEAD_00000_arg_sDst
0589  3010  	MOVLW 0x10
058A  00DA  	MOVWF FCI_SHEAD_00000_arg_iDst_len
058B  2125  	CALL FCI_SHEAD_00000


	//Calculation
	//Calculation:
	//  rx_addr = rx_addr + reg0A_rx_addr_p0_byte3
	FCI_SHEAD(FCV_RX_ADDR,FCSZ_RX_ADDR, &FCV_REG0A_RX_ADDR_P0_BYTE3,1, FCV_RX_ADDR,FCSZ_RX_ADDR);
058C  3000  	MOVLW HIGH(gbl_FCV_RX_ADDR+D'0')
058D  00D3  	MOVWF FCI_SHEAD_00000_arg_sSrc1+D'1'
058E  3040  	MOVLW LOW(gbl_FCV_RX_ADDR+D'0')
058F  00D2  	MOVWF FCI_SHEAD_00000_arg_sSrc1
0590  3010  	MOVLW 0x10
0591  00D4  	MOVWF FCI_SHEAD_00000_arg_iSrc1_len
0592  3000  	MOVLW HIGH(gbl_FCV_REG0A_RX_ADDR_P0_BYTE3+D'0')
0593  00D6  	MOVWF FCI_SHEAD_00000_arg_sSrc2+D'1'
0594  30C0  	MOVLW LOW(gbl_FCV_REG0A_RX_ADDR_P0_BYTE3+D'0')
0595  00D5  	MOVWF FCI_SHEAD_00000_arg_sSrc2
0596  3001  	MOVLW 0x01
0597  00D7  	MOVWF FCI_SHEAD_00000_arg_iSrc2_len
0598  3000  	MOVLW HIGH(gbl_FCV_RX_ADDR+D'0')
0599  00D9  	MOVWF FCI_SHEAD_00000_arg_sDst+D'1'
059A  3040  	MOVLW LOW(gbl_FCV_RX_ADDR+D'0')
059B  00D8  	MOVWF FCI_SHEAD_00000_arg_sDst
059C  3010  	MOVLW 0x10
059D  00DA  	MOVWF FCI_SHEAD_00000_arg_iDst_len
059E  2125  	CALL FCI_SHEAD_00000


	//Calculation
	//Calculation:
	//  rx_addr = rx_addr + reg0A_rx_addr_p0_byte4
	FCI_SHEAD(FCV_RX_ADDR,FCSZ_RX_ADDR, &FCV_REG0A_RX_ADDR_P0_BYTE4,1, FCV_RX_ADDR,FCSZ_RX_ADDR);
059F  3000  	MOVLW HIGH(gbl_FCV_RX_ADDR+D'0')
05A0  00D3  	MOVWF FCI_SHEAD_00000_arg_sSrc1+D'1'
05A1  3040  	MOVLW LOW(gbl_FCV_RX_ADDR+D'0')
05A2  00D2  	MOVWF FCI_SHEAD_00000_arg_sSrc1
05A3  3010  	MOVLW 0x10
05A4  00D4  	MOVWF FCI_SHEAD_00000_arg_iSrc1_len
05A5  3000  	MOVLW HIGH(gbl_FCV_REG0A_RX_ADDR_P0_BYTE4+D'0')
05A6  00D6  	MOVWF FCI_SHEAD_00000_arg_sSrc2+D'1'
05A7  30C4  	MOVLW LOW(gbl_FCV_REG0A_RX_ADDR_P0_BYTE4+D'0')
05A8  00D5  	MOVWF FCI_SHEAD_00000_arg_sSrc2
05A9  3001  	MOVLW 0x01
05AA  00D7  	MOVWF FCI_SHEAD_00000_arg_iSrc2_len
05AB  3000  	MOVLW HIGH(gbl_FCV_RX_ADDR+D'0')
05AC  00D9  	MOVWF FCI_SHEAD_00000_arg_sDst+D'1'
05AD  3040  	MOVLW LOW(gbl_FCV_RX_ADDR+D'0')
05AE  00D8  	MOVWF FCI_SHEAD_00000_arg_sDst
05AF  3010  	MOVLW 0x10
05B0  00DA  	MOVWF FCI_SHEAD_00000_arg_iDst_len
05B1  2125  	CALL FCI_SHEAD_00000


}
05B2  0008  	RETURN



void FCM_disp_datarx()

{

	//Call Component Macro
	//Call Component Macro: Cursor(0, 2)
	FCD_LCDDisplay0_Cursor(0, 2);
0671  1683  	BSF STATUS, RP0
0672  1303  	BCF STATUS, RP1
0673  01D2  	CLRF FCD_LCDDis_00056_arg_x
0674  3002  	MOVLW 0x02
0675  00D3  	MOVWF FCD_LCDDis_00056_arg_y
0676  235D  	CALL FCD_LCDDis_00056


	//Call Component Macro
	//Call Component Macro: PrintString(payload_recieve)
	FCD_LCDDisplay0_PrintString(FCV_PAYLOAD_RECIEVE, FCSZ_PAYLOAD_RECIEVE);
0677  3000  	MOVLW HIGH(gbl_FCV_PAYLOAD_RECIEVE+D'0')
0678  00D3  	MOVWF FCD_LCDDis_0005C_arg_String+D'1'
0679  3020  	MOVLW LOW(gbl_FCV_PAYLOAD_RECIEVE+D'0')
067A  00D2  	MOVWF FCD_LCDDis_0005C_arg_String
067B  3010  	MOVLW 0x10
067C  00E4  	MOVWF FCD_LCDDis_0005C_arg_MSZ_String
067D  24C4  	CALL FCD_LCDDis_0005C


}
067E  0008  	RETURN



void FCM_check_status()

{

	//Comment:
	//read reg07

	//Calculation
	//Calculation:
	//  spi_data0 = 0x07
	FCV_SPI_DATA0 = 0x07;
04B7  3007  	MOVLW 0x07
04B8  1683  	BSF STATUS, RP0
04B9  1303  	BCF STATUS, RP1
04BA  00B0  	MOVWF gbl_FCV_SPI_DATA0


	//Call Macro
	//Call Macro: cmd_read_reg()
	FCM_cmd_read_reg();
04BB  2101  	CALL FCM_cmd_re_00052


	//Calculation
	//Calculation:
	//  reg07_status = spi_data1
	FCV_REG07_STATUS = FCV_SPI_DATA1;
04BC  0831  	MOVF gbl_FCV_SPI_DATA1, W
04BD  00BA  	MOVWF gbl_FCV_REG07_STATUS


	//Comment:
	//read reg17

	//Calculation
	//Calculation:
	//  spi_data0 = 0x17
	FCV_SPI_DATA0 = 0x17;
04BE  3017  	MOVLW 0x17
04BF  00B0  	MOVWF gbl_FCV_SPI_DATA0


	//Call Macro
	//Call Macro: cmd_read_reg()
	FCM_cmd_read_reg();
04C0  2101  	CALL FCM_cmd_re_00052


	//Calculation
	//Calculation:
	//  reg17_fifo_status = spi_data1
	FCV_REG17_FIFO_STATUS = FCV_SPI_DATA1;
04C1  0831  	MOVF gbl_FCV_SPI_DATA1, W
04C2  00AF  	MOVWF gbl_FCV_REG17_FIFO_STATUS


}
04C3  0008  	RETURN



void FCM_print_display()
{

	//Call Macro
	//Call Macro: check_status()
	FCM_check_status();

	//Calculation
	//Calculation:
	//  status_tx_ds = reg07_status AND 0b00100000
	FCV_STATUS_TX_DS = FCV_REG07_STATUS & 32;

	//Decision
	//Decision: status_tx_ds = 32?
	if (FCV_STATUS_TX_DS == 32)
	{

		//Call Component Macro
		//Call Component Macro: Cursor(0, 0)
		FCD_LCDDisplay0_Cursor(0, 0);

		//Call Component Macro
		//Call Component Macro: PrintString("TX SUCCESS!")
		FCD_LCDDisplay0_PrintString("TX SUCCESS!", 11);

		//Calculation
		//Calculation:
		//  reg_to_write = 0x07
		//  data_to_write = 0x00
		FCV_REG_TO_WRITE = 0x07;
		FCV_DATA_TO_WRITE = 0x00;

		//Call Macro
		//Call Macro: cmd_write_reg()
		FCM_cmd_write_reg();

	} else {

		//Decision
		//Decision: status_tx_ds = 0?
		if (FCV_STATUS_TX_DS == 0)
		{

			//Call Component Macro
			//Call Component Macro: Cursor(0, 0)
			FCD_LCDDisplay0_Cursor(0, 0);

			//Call Component Macro
			//Call Component Macro: PrintString("TX FAIL")
			FCD_LCDDisplay0_PrintString("TX FAIL", 7);

		// } else {

		}

	}

}


void FCM_read_recieved_data()

{

	//Calculation
	//Calculation:
	//  loop_count = 0
	//  payload_recieve = ""
	FCV_LOOP_COUNT = 0;
0419  1683  	BSF STATUS, RP0
041A  1303  	BCF STATUS, RP1
041B  01CB  	CLRF gbl_FCV_LOOP_COUNT

	FCI_SCOPY("",0, FCV_PAYLOAD_RECIEVE,FCSZ_PAYLOAD_RECIEVE);
041C  01D4  	CLRF CompTempVar2243
041D  3000  	MOVLW HIGH(CompTempVar2243+D'0')
041E  00D3  	MOVWF FCI_SCOPY_00000_arg_sSrc+D'1'
041F  30D4  	MOVLW LOW(CompTempVar2243+D'0')
0420  00D2  	MOVWF FCI_SCOPY_00000_arg_sSrc
0421  01E5  	CLRF FCI_SCOPY_00000_arg_iSrc_len
0422  3000  	MOVLW HIGH(gbl_FCV_PAYLOAD_RECIEVE+D'0')
0423  00E7  	MOVWF FCI_SCOPY_00000_arg_sDst+D'1'
0424  3020  	MOVLW LOW(gbl_FCV_PAYLOAD_RECIEVE+D'0')
0425  00E6  	MOVWF FCI_SCOPY_00000_arg_sDst
0426  3010  	MOVLW 0x10
0427  00E8  	MOVWF FCI_SCOPY_00000_arg_iDst_len
0428  223B  	CALL FCI_SCOPY_00000


	//CSN
	//Output: 0 -> C2
	trisc = trisc & 0xFB;
0429  30FB  	MOVLW 0xFB
042A  0507  	ANDWF gbl_trisc, W
042B  0087  	MOVWF gbl_trisc

	if ((0))
		portc = (portc & 0xFB) | 0x04;
	else
		portc = portc & 0xFB;
042C  30FB  	MOVLW 0xFB
042D  1283  	BCF STATUS, RP0
042E  0507  	ANDWF gbl_portc, W
042F  0087  	MOVWF gbl_portc


	//Delay
	//Delay: 5 us
	delay_us(5);
0430  3005  	MOVLW 0x05
0431  1683  	BSF STATUS, RP0
0432  00D2  	MOVWF delay_us_00000_arg_del
0433  204A  	CALL delay_us_00000


	//Calculation
	//Calculation:
	//  spi_data0 = 0x61
	FCV_SPI_DATA0 = 0x61;
0434  3061  	MOVLW 0x61
0435  00B0  	MOVWF gbl_FCV_SPI_DATA0


	//Call Component Macro
	//Call Component Macro: SPI_Send_Char(spi_data0)
	FCD_SPI_Legacy0_SPI_Send_Char(FCV_SPI_DATA0);
0436  0830  	MOVF gbl_FCV_SPI_DATA0, W
0437  00D2  	MOVWF FCD_SPI_Le_00053_arg_Char
0438  2092  	CALL FCD_SPI_Le_00053


	//Connection Point
	//Connection Point: [A]: A
FCC_read_recieved_data_A:
0439        label65

;

	//Call Component Macro
	//Call Component Macro: data_to_read=SPI_Get_Char()
	FCV_DATA_TO_READ = FCD_SPI_Legacy0_SPI_Get_Char();
0439  2087  	CALL FCD_SPI_Le_00054
043A  0853  	MOVF CompTempVarRet2189, W
043B  00B2  	MOVWF gbl_FCV_DATA_TO_READ


	//Calculation
	//Calculation:
	//  payload_recieve = payload_recieve + data_to_read
	FCI_SHEAD(FCV_PAYLOAD_RECIEVE,FCSZ_PAYLOAD_RECIEVE, &FCV_DATA_TO_READ,1, FCV_PAYLOAD_RECIEVE,FCSZ_PAYLOAD_RECIEVE);
043C  3000  	MOVLW HIGH(gbl_FCV_PAYLOAD_RECIEVE+D'0')
043D  00D3  	MOVWF FCI_SHEAD_00000_arg_sSrc1+D'1'
043E  3020  	MOVLW LOW(gbl_FCV_PAYLOAD_RECIEVE+D'0')
043F  00D2  	MOVWF FCI_SHEAD_00000_arg_sSrc1
0440  3010  	MOVLW 0x10
0441  00D4  	MOVWF FCI_SHEAD_00000_arg_iSrc1_len
0442  3000  	MOVLW HIGH(gbl_FCV_DATA_TO_READ+D'0')
0443  00D6  	MOVWF FCI_SHEAD_00000_arg_sSrc2+D'1'
0444  30B2  	MOVLW LOW(gbl_FCV_DATA_TO_READ+D'0')
0445  00D5  	MOVWF FCI_SHEAD_00000_arg_sSrc2
0446  3001  	MOVLW 0x01
0447  00D7  	MOVWF FCI_SHEAD_00000_arg_iSrc2_len
0448  3000  	MOVLW HIGH(gbl_FCV_PAYLOAD_RECIEVE+D'0')
0449  00D9  	MOVWF FCI_SHEAD_00000_arg_sDst+D'1'
044A  3020  	MOVLW LOW(gbl_FCV_PAYLOAD_RECIEVE+D'0')
044B  00D8  	MOVWF FCI_SHEAD_00000_arg_sDst
044C  3010  	MOVLW 0x10
044D  00DA  	MOVWF FCI_SHEAD_00000_arg_iDst_len
044E  2125  	CALL FCI_SHEAD_00000


	//Calculation
	//Calculation:
	//  loop_count = loop_count + 1
	FCV_LOOP_COUNT = FCV_LOOP_COUNT + 1;
044F  0A4B  	INCF gbl_FCV_LOOP_COUNT, W
0450  00CB  	MOVWF gbl_FCV_LOOP_COUNT


	//Decision
	//Decision: loop_count = payloadsize?
	if (FCV_LOOP_COUNT == FCV_PAYLOADSIZE)
0451  0849  	MOVF gbl_FCV_PAYLOADSIZE, W
0452  064B  	XORWF gbl_FCV_LOOP_COUNT, W
0453  1D03  	BTFSS STATUS,Z

	{

	} else {

		//Goto Connection Point
		//Goto Connection Point: [A]: A
		goto FCC_read_recieved_data_A;
0454  2C39  	GOTO	label65


	}

	//CSN
	//Output: 1 -> C2
	trisc = trisc & 0xFB;
0455  30FB  	MOVLW 0xFB
0456  0507  	ANDWF gbl_trisc, W
0457  0087  	MOVWF gbl_trisc

	if ((1))
		portc = (portc & 0xFB) | 0x04;
0458  30FB  	MOVLW 0xFB
0459  1283  	BCF STATUS, RP0
045A  0507  	ANDWF gbl_portc, W
045B  1683  	BSF STATUS, RP0
045C  00D2  	MOVWF CompTempVar2249
045D  3004  	MOVLW 0x04
045E  0452  	IORWF CompTempVar2249, W
045F  1283  	BCF STATUS, RP0
0460  0087  	MOVWF gbl_portc

	else
		portc = portc & 0xFB;

	//Delay
	//Delay: 5 us
	delay_us(5);
0461  3005  	MOVLW 0x05
0462  1683  	BSF STATUS, RP0
0463  00D2  	MOVWF delay_us_00000_arg_del
0464  204A  	CALL delay_us_00000


}
0465  0008  	RETURN



void FCM_disp_datatx()
{

	//Call Component Macro
	//Call Component Macro: Cursor(0, 1)
	FCD_LCDDisplay0_Cursor(0, 1);

	//Call Component Macro
	//Call Component Macro: PrintString(payload_transmit)
	FCD_LCDDisplay0_PrintString(FCV_PAYLOAD_TRANSMIT, FCSZ_PAYLOAD_TRANSMIT);

}



void main()

{
	//Initialization
	adcon1 = 0x07;
0769  3007  	MOVLW 0x07
076A  1683  	BSF STATUS, RP0
076B  1303  	BCF STATUS, RP1
076C  009F  	MOVWF gbl_adcon1


	
		RS232_3_UART_Init( );		//Call initialise function
076D  24E0  	CALL FC_CAL_UAR_00085



	//Interrupt initialization code
	option_reg = 0xC0;
076E  30C0  	MOVLW 0xC0
076F  0081  	MOVWF gbl_option_reg



	//Call Component Macro
	//Call Component Macro: Start()
	FCD_LCDDisplay0_Start();
0770  2713  	CALL FCD_LCDDis_0006F


	//Call Component Macro
	//Call Component Macro: Clear()
	FCD_LCDDisplay0_Clear();
0771  2702  	CALL FCD_LCDDis_00070


	//Call Component Macro
	//Call Component Macro: SPI_Init()
	FCD_SPI_Legacy0_SPI_Init();
0772  26F7  	CALL FCD_SPI_Le_0007A


	//Delay
	//Delay: 1 ms
	delay_ms(1);
0773  3001  	MOVLW 0x01
0774  1683  	BSF STATUS, RP0
0775  00D6  	MOVWF delay_ms_00000_arg_del
0776  2010  	CALL delay_ms_00000


	//CE
	//Output: 1 -> C1
	trisc = trisc & 0xFD;
0777  30FD  	MOVLW 0xFD
0778  0507  	ANDWF gbl_trisc, W
0779  0087  	MOVWF gbl_trisc

	if ((1))
		portc = (portc & 0xFD) | 0x02;
077A  30FD  	MOVLW 0xFD
077B  1283  	BCF STATUS, RP0
077C  0507  	ANDWF gbl_portc, W
077D  1683  	BSF STATUS, RP0
077E  00D2  	MOVWF CompTempVar2312
077F  3002  	MOVLW 0x02
0780  0452  	IORWF CompTempVar2312, W
0781  1283  	BCF STATUS, RP0
0782  0087  	MOVWF gbl_portc

	else
		portc = portc & 0xFD;

	//CSN
	//Output: 1 -> C2
	trisc = trisc & 0xFB;
0783  30FB  	MOVLW 0xFB
0784  1683  	BSF STATUS, RP0
0785  0507  	ANDWF gbl_trisc, W
0786  0087  	MOVWF gbl_trisc

	if ((1))
		portc = (portc & 0xFB) | 0x04;
0787  30FB  	MOVLW 0xFB
0788  1283  	BCF STATUS, RP0
0789  0507  	ANDWF gbl_portc, W
078A  1683  	BSF STATUS, RP0
078B  00D2  	MOVWF CompTempVar2313
078C  3004  	MOVLW 0x04
078D  0452  	IORWF CompTempVar2313, W
078E  1283  	BCF STATUS, RP0
078F  0087  	MOVWF gbl_portc

	else
		portc = portc & 0xFB;

	//Input
	//Input: PORTA -> reg0A_rx_addr_p0_byte4
	trisa = trisa | 0x0F;
0790  300F  	MOVLW 0x0F
0791  1683  	BSF STATUS, RP0
0792  0405  	IORWF gbl_trisa, W
0793  0085  	MOVWF gbl_trisa

	FCV_REG0A_RX_ADDR_P0_BYTE4 = porta & 0x0F;
0794  300F  	MOVLW 0x0F
0795  1283  	BCF STATUS, RP0
0796  0505  	ANDWF gbl_porta, W
0797  1683  	BSF STATUS, RP0
0798  00C4  	MOVWF gbl_FCV_REG0A_RX_ADDR_P0_BYTE4


	//Calculation
	//Calculation:
	//  reg0A_rx_addr_p0_byte4 = reg0A_rx_addr_p0_byte4 + 48
	FCV_REG0A_RX_ADDR_P0_BYTE4 = FCV_REG0A_RX_ADDR_P0_BYTE4 + 48;
0799  3030  	MOVLW 0x30
079A  0744  	ADDWF gbl_FCV_REG0A_RX_ADDR_P0_BYTE4, W
079B  00C4  	MOVWF gbl_FCV_REG0A_RX_ADDR_P0_BYTE4


	//Calculation
	//Calculation:
	//  reg10_tx_addr_byte4 = reg0A_rx_addr_p0_byte4
	FCV_REG10_TX_ADDR_BYTE4 = FCV_REG0A_RX_ADDR_P0_BYTE4;
079C  0844  	MOVF gbl_FCV_REG0A_RX_ADDR_P0_BYTE4, W
079D  00AB  	MOVWF gbl_FCV_REG10_TX_ADDR_BYTE4


	//declare tx addr
	//Calculation:
	//  reg10_tx_addr_byte0 = '0'
	//  reg10_tx_addr_byte1 = '0'
	//  reg10_tx_addr_byte2 = '0'
	//  reg10_tx_addr_byte3 = '0'
	FCV_REG10_TX_ADDR_BYTE0 = '0';
079E  3030  	MOVLW 0x30
079F  00D0  	MOVWF gbl_FCV_REG10_TX_ADDR_BYTE0

	FCV_REG10_TX_ADDR_BYTE1 = '0';
07A0  00A4  	MOVWF gbl_FCV_REG10_TX_ADDR_BYTE1

	FCV_REG10_TX_ADDR_BYTE2 = '0';
07A1  00A7  	MOVWF gbl_FCV_REG10_TX_ADDR_BYTE2

	FCV_REG10_TX_ADDR_BYTE3 = '0';
07A2  00AA  	MOVWF gbl_FCV_REG10_TX_ADDR_BYTE3


	//declare rx addr
	//Calculation:
	//  reg0A_rx_addr_p0_byte0 = '0'
	//  reg0A_rx_addr_p0_byte1 = '0'
	//  reg0A_rx_addr_p0_byte2 = '0'
	//  reg0A_rx_addr_p0_byte3 = '0'
	FCV_REG0A_RX_ADDR_P0_BYTE0 = '0';
07A3  00B5  	MOVWF gbl_FCV_REG0A_RX_ADDR_P0_BYTE0

	FCV_REG0A_RX_ADDR_P0_BYTE1 = '0';
07A4  00B8  	MOVWF gbl_FCV_REG0A_RX_ADDR_P0_BYTE1

	FCV_REG0A_RX_ADDR_P0_BYTE2 = '0';
07A5  00BB  	MOVWF gbl_FCV_REG0A_RX_ADDR_P0_BYTE2

	FCV_REG0A_RX_ADDR_P0_BYTE3 = '0';
07A6  00C0  	MOVWF gbl_FCV_REG0A_RX_ADDR_P0_BYTE3


	//Calculation
	//Calculation:
	//  payloadsize = 16
	FCV_PAYLOADSIZE = 16;
07A7  3010  	MOVLW 0x10
07A8  00C9  	MOVWF gbl_FCV_PAYLOADSIZE


	//Call Macro
	//Call Macro: nrf_rx_init()
	FCM_nrf_rx_init();
07A9  262F  	CALL FCM_nrf_rx_00067


	//Calculation
	//Calculation:
	//  payload_transmit = "TESTING MESSAGE!"
	FCI_SCOPY("TESTING MESSAGE!",16, FCV_PAYLOAD_TRANSMIT,FCSZ_PAYLOAD_TRANSMIT);
07AA  3020  	MOVLW 0x20
07AB  00DB  	MOVWF CompTempVar2314+D'7'
07AC  3021  	MOVLW 0x21
07AD  00E3  	MOVWF CompTempVar2314+D'15'
07AE  3041  	MOVLW 0x41
07AF  00E0  	MOVWF CompTempVar2314+D'12'
07B0  3045  	MOVLW 0x45
07B1  00D5  	MOVWF CompTempVar2314+D'1'
07B2  00DD  	MOVWF CompTempVar2314+D'9'
07B3  00E2  	MOVWF CompTempVar2314+D'14'
07B4  3047  	MOVLW 0x47
07B5  00DA  	MOVWF CompTempVar2314+D'6'
07B6  00E1  	MOVWF CompTempVar2314+D'13'
07B7  3049  	MOVLW 0x49
07B8  00D8  	MOVWF CompTempVar2314+D'4'
07B9  304D  	MOVLW 0x4D
07BA  00DC  	MOVWF CompTempVar2314+D'8'
07BB  304E  	MOVLW 0x4E
07BC  00D9  	MOVWF CompTempVar2314+D'5'
07BD  3053  	MOVLW 0x53
07BE  00D6  	MOVWF CompTempVar2314+D'2'
07BF  00DE  	MOVWF CompTempVar2314+D'10'
07C0  00DF  	MOVWF CompTempVar2314+D'11'
07C1  3054  	MOVLW 0x54
07C2  00D4  	MOVWF CompTempVar2314
07C3  00D7  	MOVWF CompTempVar2314+D'3'
07C4  01E4  	CLRF CompTempVar2314+D'16'
07C5  3000  	MOVLW HIGH(CompTempVar2314+D'0')
07C6  00D3  	MOVWF FCI_SCOPY_00000_arg_sSrc+D'1'
07C7  30D4  	MOVLW LOW(CompTempVar2314+D'0')
07C8  00D2  	MOVWF FCI_SCOPY_00000_arg_sSrc
07C9  3010  	MOVLW 0x10
07CA  00E5  	MOVWF FCI_SCOPY_00000_arg_iSrc_len
07CB  3000  	MOVLW HIGH(gbl_FCV_PAYLOAD_TRANSMIT+D'0')
07CC  00E7  	MOVWF FCI_SCOPY_00000_arg_sDst+D'1'
07CD  3030  	MOVLW LOW(gbl_FCV_PAYLOAD_TRANSMIT+D'0')
07CE  00E6  	MOVWF FCI_SCOPY_00000_arg_sDst
07CF  3010  	MOVLW 0x10
07D0  00E8  	MOVWF FCI_SCOPY_00000_arg_iDst_len
07D1  223B  	CALL FCI_SCOPY_00000


	//tx_ack
	//Output: 0 -> A4
	trisa = trisa & 0xEF;
07D2  30EF  	MOVLW 0xEF
07D3  0505  	ANDWF gbl_trisa, W
07D4  0085  	MOVWF gbl_trisa

	if ((0))
		porta = (porta & 0xEF) | 0x10;
	else
		porta = porta & 0xEF;
07D5  30EF  	MOVLW 0xEF
07D6  1283  	BCF STATUS, RP0
07D7  0505  	ANDWF gbl_porta, W
07D8  0085  	MOVWF gbl_porta


	//rx_ack
	//Output: 0 -> A5
	trisa = trisa & 0xDF;
07D9  30DF  	MOVLW 0xDF
07DA  1683  	BSF STATUS, RP0
07DB  0505  	ANDWF gbl_trisa, W
07DC  0085  	MOVWF gbl_trisa

	if ((0))
		porta = (porta & 0xDF) | 0x20;
	else
		porta = porta & 0xDF;
07DD  30DF  	MOVLW 0xDF
07DE  1283  	BCF STATUS, RP0
07DF  0505  	ANDWF gbl_porta, W
07E0  0085  	MOVWF gbl_porta


	//Call Macro
	//Call Macro: cmd_read_rx_addr()
	FCM_cmd_read_rx_addr();
07E1  267F  	CALL FCM_cmd_re_0005B


	//Call Macro
	//Call Macro: cmd_read_tx_addr()
	FCM_cmd_read_tx_addr();
07E2  26BB  	CALL FCM_cmd_re_0005A


	//Call Macro
	//Call Macro: rx_addr_to_string()
	FCM_rx_addr_to_string();
07E3  2551  	CALL FCM_rx_add_0006B


	//Call Macro
	//Call Macro: tx_addr_to_string()
	FCM_tx_addr_to_string();
07E4  24EF  	CALL FCM_tx_add_0006A


	//Loop
	//Loop: While 1
	while (1)
07E5        label69
0836  2FE5  	GOTO	label69

	{

		//CE
		//Output: 1 -> C1
		trisc = trisc & 0xFD;
07E5  30FD  	MOVLW 0xFD
07E6  0507  	ANDWF gbl_trisc, W
07E7  0087  	MOVWF gbl_trisc

		if ((1))
			portc = (portc & 0xFD) | 0x02;
07E8  30FD  	MOVLW 0xFD
07E9  1283  	BCF STATUS, RP0
07EA  0507  	ANDWF gbl_portc, W
07EB  1683  	BSF STATUS, RP0
07EC  00D2  	MOVWF CompTempVar2317
07ED  3002  	MOVLW 0x02
07EE  0452  	IORWF CompTempVar2317, W
07EF  1283  	BCF STATUS, RP0
07F0  0087  	MOVWF gbl_portc

		else
			portc = portc & 0xFD;

		//rx_ack
		//Output: 0 -> A5
		trisa = trisa & 0xDF;
07F1  30DF  	MOVLW 0xDF
07F2  1683  	BSF STATUS, RP0
07F3  0505  	ANDWF gbl_trisa, W
07F4  0085  	MOVWF gbl_trisa

		if ((0))
			porta = (porta & 0xDF) | 0x20;
		else
			porta = porta & 0xDF;
07F5  30DF  	MOVLW 0xDF
07F6  1283  	BCF STATUS, RP0
07F7  0505  	ANDWF gbl_porta, W
07F8  0085  	MOVWF gbl_porta


		//tx_ack
		//Output: 0 -> C0
		trisc = trisc & 0xFE;
07F9  30FE  	MOVLW 0xFE
07FA  1683  	BSF STATUS, RP0
07FB  0507  	ANDWF gbl_trisc, W
07FC  0087  	MOVWF gbl_trisc

		if ((0))
			portc = (portc & 0xFE) | 0x01;
		else
			portc = portc & 0xFE;
07FD  30FE  	MOVLW 0xFE
07FE  1283  	BCF STATUS, RP0
07FF  0507  	ANDWF gbl_portc, W
0800  0087  	MOVWF gbl_portc


		//Call Component Macro
		//Call Component Macro: Clear()
		FCD_LCDDisplay0_Clear();
0801  2702  	CALL FCD_LCDDis_00070


		//Call Macro
		//Call Macro: radio_recieve_data()
		FCM_radio_recieve_data();
0802  25B3  	CALL FCM_radio__00068


		//Call Macro
		//Call Macro: disp_datarx()
		FCM_disp_datarx();
0803  2671  	CALL FCM_disp_d_0006C


		//Call Component Macro
		//Call Component Macro: Cursor(0, 1)
		FCD_LCDDisplay0_Cursor(0, 1);
0804  01D2  	CLRF FCD_LCDDis_00056_arg_x
0805  3001  	MOVLW 0x01
0806  00D3  	MOVWF FCD_LCDDis_00056_arg_y
0807  235D  	CALL FCD_LCDDis_00056


		//Call Component Macro
		//Call Component Macro: PrintString("t:")
		FCD_LCDDisplay0_PrintString("t:", 2);
0808  3074  	MOVLW 0x74
0809  00D4  	MOVWF CompTempVar2318
080A  303A  	MOVLW 0x3A
080B  00D5  	MOVWF CompTempVar2318+D'1'
080C  01D6  	CLRF CompTempVar2318+D'2'
080D  3000  	MOVLW HIGH(CompTempVar2318+D'0')
080E  00D3  	MOVWF FCD_LCDDis_0005C_arg_String+D'1'
080F  30D4  	MOVLW LOW(CompTempVar2318+D'0')
0810  00D2  	MOVWF FCD_LCDDis_0005C_arg_String
0811  3002  	MOVLW 0x02
0812  00E4  	MOVWF FCD_LCDDis_0005C_arg_MSZ_String
0813  24C4  	CALL FCD_LCDDis_0005C


		//Call Component Macro
		//Call Component Macro: PrintString(tx_addr)
		FCD_LCDDisplay0_PrintString(FCV_TX_ADDR, FCSZ_TX_ADDR);
0814  3000  	MOVLW HIGH(gbl_FCV_TX_ADDR+D'0')
0815  00D3  	MOVWF FCD_LCDDis_0005C_arg_String+D'1'
0816  3050  	MOVLW LOW(gbl_FCV_TX_ADDR+D'0')
0817  00D2  	MOVWF FCD_LCDDis_0005C_arg_String
0818  3010  	MOVLW 0x10
0819  00E4  	MOVWF FCD_LCDDis_0005C_arg_MSZ_String
081A  24C4  	CALL FCD_LCDDis_0005C


		//Call Component Macro
		//Call Component Macro: PrintString(" r:")
		FCD_LCDDisplay0_PrintString(" r:", 3);
081B  3020  	MOVLW 0x20
081C  00D4  	MOVWF CompTempVar2321
081D  3072  	MOVLW 0x72
081E  00D5  	MOVWF CompTempVar2321+D'1'
081F  303A  	MOVLW 0x3A
0820  00D6  	MOVWF CompTempVar2321+D'2'
0821  01D7  	CLRF CompTempVar2321+D'3'
0822  3000  	MOVLW HIGH(CompTempVar2321+D'0')
0823  00D3  	MOVWF FCD_LCDDis_0005C_arg_String+D'1'
0824  30D4  	MOVLW LOW(CompTempVar2321+D'0')
0825  00D2  	MOVWF FCD_LCDDis_0005C_arg_String
0826  3003  	MOVLW 0x03
0827  00E4  	MOVWF FCD_LCDDis_0005C_arg_MSZ_String
0828  24C4  	CALL FCD_LCDDis_0005C


		//Call Component Macro
		//Call Component Macro: PrintString(rx_addr)
		FCD_LCDDisplay0_PrintString(FCV_RX_ADDR, FCSZ_RX_ADDR);
0829  3000  	MOVLW HIGH(gbl_FCV_RX_ADDR+D'0')
082A  00D3  	MOVWF FCD_LCDDis_0005C_arg_String+D'1'
082B  3040  	MOVLW LOW(gbl_FCV_RX_ADDR+D'0')
082C  00D2  	MOVWF FCD_LCDDis_0005C_arg_String
082D  3010  	MOVLW 0x10
082E  00E4  	MOVWF FCD_LCDDis_0005C_arg_MSZ_String
082F  24C4  	CALL FCD_LCDDis_0005C


		//Delay
		//Delay: 500 ms
		delay_ms(255);
0830  30FF  	MOVLW 0xFF
0831  00D6  	MOVWF delay_ms_00000_arg_del
0832  2010  	CALL delay_ms_00000

		delay_ms(245);
0833  30F5  	MOVLW 0xF5
0834  00D6  	MOVWF delay_ms_00000_arg_del
0835  2010  	CALL delay_ms_00000



	}

	//Loop
	//Loop: While 1
	while (1)
	{

		//Call Component Macro
		//Call Component Macro: Clear()
		FCD_LCDDisplay0_Clear();


		//Call Component Macro
		//Call Component Macro: data_to_read=ReceiveRS232Char(10)
		FCV_DATA_TO_READ = FCD_RS2320_ReceiveRS232Char(10);


		//Decision
		//Decision: data_to_read = 255?
		if (FCV_DATA_TO_READ == 255)
		{

		} else {

			//Call Component Macro
			//Call Component Macro: PrintNumber(data_to_read)
			FCD_LCDDisplay0_PrintNumber(FCV_DATA_TO_READ);


		}

		//Call Component Macro
		//Call Component Macro: SendRS232Char(0x55)
		FCD_RS2320_SendRS232Char(0x55);


		//CE
		//Output: 1 -> C1
		trisc = trisc & 0xFD;

		if ((1))
			portc = (portc & 0xFD) | 0x02;

		else
			portc = portc & 0xFD;

		//rx_ack
		//Output: 0 -> A5
		trisa = trisa & 0xDF;

		if ((0))
			porta = (porta & 0xDF) | 0x20;
		else
			porta = porta & 0xDF;


		//tx_ack
		//Output: 0 -> C0
		trisc = trisc & 0xFE;

		if ((0))
			portc = (portc & 0xFE) | 0x01;
		else
			portc = portc & 0xFE;



	}

	//Comment:
	//Comment

	mainendloop: goto mainendloop;
}


void MX_INTERRUPT_MACRO(void)

{
}
08A6  1283  	BCF STATUS, RP0
08A7  1303  	BCF STATUS, RP1
08A8  0E76  	SWAPF Int1BContext+D'2', W
08A9  0084  	MOVWF FSR
08AA  0E75  	SWAPF Int1BContext+D'1', W
08AB  008A  	MOVWF PCLATH
08AC  0E74  	SWAPF Int1BContext, W
08AD  0083  	MOVWF STATUS
08AE  0EFF  	SWAPF Int1Context, F
08AF  0E7F  	SWAPF Int1Context, W
08B0  0009  	RETFIE





/*********************************************************************
 *                  Flowcode CAL SPI File
 *
 * File: PIC_CAL_SPI.c
 *
 * (c) 2011 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * “Company”) for its Flowcode graphical programming language is
 * intended and supplied to you, the Company’s customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 010911 | BR | Created
 * 150911 | BR | Updated variables with typedef alternatives
 * 011211 | BR | Converted to new dynamic defines mechanism
 *
 */


//When using hardware SPI channels override port and pin conns with FCD conn definitions
//Only overwrite CS pin defines when using SPI in slave mode on a hardware channel
//Also sort out postscale and prescale options for hardware channels
#ifdef MX_SPI_REF1
	#if MX_SPI_CHANNEL_1 > 0
		#undef MX_SPI_MOSI_PIN_1
		#undef MX_SPI_MOSI_PORT_1
		#undef MX_SPI_MOSI_TRIS_1
		#undef MX_SPI_MISO_PIN_1
		#undef MX_SPI_MISO_PORT_1
		#undef MX_SPI_MISO_TRIS_1
		#undef MX_SPI_SCK_PIN_1
		#undef MX_SPI_SCK_PORT_1
		#undef MX_SPI_SCK_TRIS_1
		#undef MX_SPI_CS_PIN_1
		#undef MX_SPI_CS_PORT_1
		#undef MX_SPI_CS_TRIS_1

		#if MX_SPI_PR_SCALE_1 == 4
			#undef MX_SPI_PR_SCALE_1
			#define MX_SPI_PR_SCALE_1	0
		#endif
		#if MX_SPI_PR_SCALE_1 == 16
			#undef MX_SPI_PR_SCALE_1
			#define MX_SPI_PR_SCALE_1	1
		#endif
		#if MX_SPI_PR_SCALE_1 == 64
			#undef MX_SPI_PR_SCALE_1
			#define MX_SPI_PR_SCALE_1	2
		#endif
	#endif
	#if MX_SPI_CHANNEL_1 == 1
		#define MX_SPI_MOSI_PIN_1		MX_SPI_1_MOSI_PIN
		#define MX_SPI_MOSI_PORT_1		MX_SPI_1_MOSI_PORT
		#define MX_SPI_MOSI_TRIS_1		MX_SPI_1_MOSI_TRIS
		#define MX_SPI_MISO_PIN_1		MX_SPI_1_MISO_PIN
		#define MX_SPI_MISO_PORT_1		MX_SPI_1_MISO_PORT
		#define MX_SPI_MISO_TRIS_1		MX_SPI_1_MISO_TRIS
		#define MX_SPI_SCK_PIN_1		MX_SPI_1_CLK_PIN
		#define MX_SPI_SCK_PORT_1		MX_SPI_1_CLK_PORT
		#define MX_SPI_SCK_TRIS_1		MX_SPI_1_CLK_TRIS
		#define MX_SPI_CS_PIN_1			MX_SPI_1_SS_PIN
		#define MX_SPI_CS_PORT_1		MX_SPI_1_SS_PORT
		#define MX_SPI_CS_TRIS_1		MX_SPI_1_SS_TRIS
	#endif
	#if MX_SPI_CHANNEL_1 == 2
		#define MX_SPI_MOSI_PIN_1		MX_SPI_2_MOSI_PIN
		#define MX_SPI_MOSI_PORT_1		MX_SPI_2_MOSI_PORT
		#define MX_SPI_MOSI_TRIS_1		MX_SPI_2_MOSI_TRIS
		#define MX_SPI_MISO_PIN_1		MX_SPI_2_MISO_PIN
		#define MX_SPI_MISO_PORT_1		MX_SPI_2_MISO_PORT
		#define MX_SPI_MISO_TRIS_1		MX_SPI_2_MISO_TRIS
		#define MX_SPI_SCK_PIN_1		MX_SPI_2_CLK_PIN
		#define MX_SPI_SCK_PORT_1		MX_SPI_2_CLK_PORT
		#define MX_SPI_SCK_TRIS_1		MX_SPI_2_CLK_TRIS
		#define MX_SPI_CS_PIN_1			MX_SPI_2_SS_PIN
		#define MX_SPI_CS_PORT_1		MX_SPI_2_SS_PORT
		#define MX_SPI_CS_TRIS_1		MX_SPI_2_SS_TRIS
	#endif
	#if MX_SPI_CHANNEL_1 == 3
		#define MX_SPI_MOSI_PIN_1		MX_SPI_3_MOSI_PIN
		#define MX_SPI_MOSI_PORT_1		MX_SPI_3_MOSI_PORT
		#define MX_SPI_MOSI_TRIS_1		MX_SPI_3_MOSI_TRIS
		#define MX_SPI_MISO_PIN_1		MX_SPI_3_MISO_PIN
		#define MX_SPI_MISO_PORT_1		MX_SPI_3_MISO_PORT
		#define MX_SPI_MISO_TRIS_1		MX_SPI_3_MISO_TRIS
		#define MX_SPI_SCK_PIN_1		MX_SPI_3_CLK_PIN
		#define MX_SPI_SCK_PORT_1		MX_SPI_3_CLK_PORT
		#define MX_SPI_SCK_TRIS_1		MX_SPI_3_CLK_TRIS
		#define MX_SPI_CS_PIN_1			MX_SPI_3_SS_PIN
		#define MX_SPI_CS_PORT_1		MX_SPI_3_SS_PORT
		#define MX_SPI_CS_TRIS_1		MX_SPI_3_SS_TRIS
	#endif
	#if MX_SPI_CHANNEL_1 == 4
		#define MX_SPI_MOSI_PIN_1		MX_SPI_4_MOSI_PIN
		#define MX_SPI_MOSI_PORT_1		MX_SPI_4_MOSI_PORT
		#define MX_SPI_MOSI_TRIS_1		MX_SPI_4_MOSI_TRIS
		#define MX_SPI_MISO_PIN_1		MX_SPI_4_MISO_PIN
		#define MX_SPI_MISO_PORT_1		MX_SPI_4_MISO_PORT
		#define MX_SPI_MISO_TRIS_1		MX_SPI_4_MISO_TRIS
		#define MX_SPI_SCK_PIN_1		MX_SPI_4_CLK_PIN
		#define MX_SPI_SCK_PORT_1		MX_SPI_4_CLK_PORT
		#define MX_SPI_SCK_TRIS_1		MX_SPI_4_CLK_TRIS
		#define MX_SPI_CS_PIN_1			MX_SPI_4_SS_PIN
		#define MX_SPI_CS_PORT_1		MX_SPI_4_SS_PORT
		#define MX_SPI_CS_TRIS_1		MX_SPI_4_SS_TRIS
	#endif
#endif
#ifdef MX_SPI_REF2
	#if MX_SPI_CHANNEL_2 > 0
		#undef MX_SPI_MOSI_PIN_2
		#undef MX_SPI_MOSI_PORT_2
		#undef MX_SPI_MOSI_TRIS_2
		#undef MX_SPI_MISO_PIN_2
		#undef MX_SPI_MISO_PORT_2
		#undef MX_SPI_MISO_TRIS_2
		#undef MX_SPI_SCK_PIN_2
		#undef MX_SPI_SCK_PORT_2
		#undef MX_SPI_SCK_TRIS_2
		#undef MX_SPI_CS_PIN_2
		#undef MX_SPI_CS_PORT_2
		#undef MX_SPI_CS_TRIS_2

		#if MX_SPI_PR_SCALE_2 == 4
			#undef MX_SPI_PR_SCALE_2
			#define MX_SPI_PR_SCALE_2	0
		#endif
		#if MX_SPI_PR_SCALE_2 == 16
			#undef MX_SPI_PR_SCALE_2
			#define MX_SPI_PR_SCALE_2	1
		#endif
		#if MX_SPI_PR_SCALE_2 == 64
			#undef MX_SPI_PR_SCALE_2
			#define MX_SPI_PR_SCALE_2	2
		#endif
	#endif
	#if MX_SPI_CHANNEL_2 == 1
		#define MX_SPI_MOSI_PIN_2		MX_SPI_1_MOSI_PIN
		#define MX_SPI_MOSI_PORT_2		MX_SPI_1_MOSI_PORT
		#define MX_SPI_MOSI_TRIS_2		MX_SPI_1_MOSI_TRIS
		#define MX_SPI_MISO_PIN_2		MX_SPI_1_MISO_PIN
		#define MX_SPI_MISO_PORT_2		MX_SPI_1_MISO_PORT
		#define MX_SPI_MISO_TRIS_2		MX_SPI_1_MISO_TRIS
		#define MX_SPI_SCK_PIN_2		MX_SPI_1_CLK_PIN
		#define MX_SPI_SCK_PORT_2		MX_SPI_1_CLK_PORT
		#define MX_SPI_SCK_TRIS_2		MX_SPI_1_CLK_TRIS
		#define MX_SPI_CS_PIN_2			MX_SPI_1_SS_PIN
		#define MX_SPI_CS_PORT_2		MX_SPI_1_SS_PORT
		#define MX_SPI_CS_TRIS_2		MX_SPI_1_SS_TRIS
	#endif
	#if MX_SPI_CHANNEL_2 == 2
		#define MX_SPI_MOSI_PIN_2		MX_SPI_2_MOSI_PIN
		#define MX_SPI_MOSI_PORT_2		MX_SPI_2_MOSI_PORT
		#define MX_SPI_MOSI_TRIS_2		MX_SPI_2_MOSI_TRIS
		#define MX_SPI_MISO_PIN_2		MX_SPI_2_MISO_PIN
		#define MX_SPI_MISO_PORT_2		MX_SPI_2_MISO_PORT
		#define MX_SPI_MISO_TRIS_2		MX_SPI_2_MISO_TRIS
		#define MX_SPI_SCK_PIN_2		MX_SPI_2_CLK_PIN
		#define MX_SPI_SCK_PORT_2		MX_SPI_2_CLK_PORT
		#define MX_SPI_SCK_TRIS_2		MX_SPI_2_CLK_TRIS
		#define MX_SPI_CS_PIN_2			MX_SPI_2_SS_PIN
		#define MX_SPI_CS_PORT_2		MX_SPI_2_SS_PORT
		#define MX_SPI_CS_TRIS_2		MX_SPI_2_SS_TRIS
	#endif
	#if MX_SPI_CHANNEL_2 == 3
		#define MX_SPI_MOSI_PIN_2		MX_SPI_3_MOSI_PIN
		#define MX_SPI_MOSI_PORT_2		MX_SPI_3_MOSI_PORT
		#define MX_SPI_MOSI_TRIS_2		MX_SPI_3_MOSI_TRIS
		#define MX_SPI_MISO_PIN_2		MX_SPI_3_MISO_PIN
		#define MX_SPI_MISO_PORT_2		MX_SPI_3_MISO_PORT
		#define MX_SPI_MISO_TRIS_2		MX_SPI_3_MISO_TRIS
		#define MX_SPI_SCK_PIN_2		MX_SPI_3_CLK_PIN
		#define MX_SPI_SCK_PORT_2		MX_SPI_3_CLK_PORT
		#define MX_SPI_SCK_TRIS_2		MX_SPI_3_CLK_TRIS
		#define MX_SPI_CS_PIN_2			MX_SPI_3_SS_PIN
		#define MX_SPI_CS_PORT_2		MX_SPI_3_SS_PORT
		#define MX_SPI_CS_TRIS_2		MX_SPI_3_SS_TRIS
	#endif
	#if MX_SPI_CHANNEL_2 == 4
		#define MX_SPI_MOSI_PIN_2		MX_SPI_4_MOSI_PIN
		#define MX_SPI_MOSI_PORT_2		MX_SPI_4_MOSI_PORT
		#define MX_SPI_MOSI_TRIS_2		MX_SPI_4_MOSI_TRIS
		#define MX_SPI_MISO_PIN_2		MX_SPI_4_MISO_PIN
		#define MX_SPI_MISO_PORT_2		MX_SPI_4_MISO_PORT
		#define MX_SPI_MISO_TRIS_2		MX_SPI_4_MISO_TRIS
		#define MX_SPI_SCK_PIN_2		MX_SPI_4_CLK_PIN
		#define MX_SPI_SCK_PORT_2		MX_SPI_4_CLK_PORT
		#define MX_SPI_SCK_TRIS_2		MX_SPI_4_CLK_TRIS
		#define MX_SPI_CS_PIN_2			MX_SPI_4_SS_PIN
		#define MX_SPI_CS_PORT_2		MX_SPI_4_SS_PORT
		#define MX_SPI_CS_TRIS_2		MX_SPI_4_SS_TRIS
	#endif
#endif
#ifdef MX_SPI_REF3
	#if MX_SPI_CHANNEL_3 > 0
		#undef MX_SPI_MOSI_PIN_3
		#undef MX_SPI_MOSI_PORT_3
		#undef MX_SPI_MOSI_TRIS_3
		#undef MX_SPI_MISO_PIN_3
		#undef MX_SPI_MISO_PORT_3
		#undef MX_SPI_MISO_TRIS_3
		#undef MX_SPI_SCK_PIN_3
		#undef MX_SPI_SCK_PORT_3
		#undef MX_SPI_SCK_TRIS_3
		#undef MX_SPI_CS_PIN_3
		#undef MX_SPI_CS_PORT_3
		#undef MX_SPI_CS_TRIS_3

		#if MX_SPI_PR_SCALE_3 == 4
			#undef MX_SPI_PR_SCALE_3
			#define MX_SPI_PR_SCALE_3	0
		#endif
		#if MX_SPI_PR_SCALE_3 == 16
			#undef MX_SPI_PR_SCALE_3
			#define MX_SPI_PR_SCALE_3	1
		#endif
		#if MX_SPI_PR_SCALE_3 == 64
			#undef MX_SPI_PR_SCALE_3
			#define MX_SPI_PR_SCALE_3	2
		#endif
	#endif
	#if MX_SPI_CHANNEL_3 == 1
		#define MX_SPI_MOSI_PIN_3		MX_SPI_1_MOSI_PIN
		#define MX_SPI_MOSI_PORT_3		MX_SPI_1_MOSI_PORT
		#define MX_SPI_MOSI_TRIS_3		MX_SPI_1_MOSI_TRIS
		#define MX_SPI_MISO_PIN_3		MX_SPI_1_MISO_PIN
		#define MX_SPI_MISO_PORT_3		MX_SPI_1_MISO_PORT
		#define MX_SPI_MISO_TRIS_3		MX_SPI_1_MISO_TRIS
		#define MX_SPI_SCK_PIN_3		MX_SPI_1_CLK_PIN
		#define MX_SPI_SCK_PORT_3		MX_SPI_1_CLK_PORT
		#define MX_SPI_SCK_TRIS_3		MX_SPI_1_CLK_TRIS
		#define MX_SPI_CS_PIN_3			MX_SPI_1_SS_PIN
		#define MX_SPI_CS_PORT_3		MX_SPI_1_SS_PORT
		#define MX_SPI_CS_TRIS_3		MX_SPI_1_SS_TRIS
	#endif
	#if MX_SPI_CHANNEL_3 == 2
		#define MX_SPI_MOSI_PIN_3		MX_SPI_2_MOSI_PIN
		#define MX_SPI_MOSI_PORT_3		MX_SPI_2_MOSI_PORT
		#define MX_SPI_MOSI_TRIS_3		MX_SPI_2_MOSI_TRIS
		#define MX_SPI_MISO_PIN_3		MX_SPI_2_MISO_PIN
		#define MX_SPI_MISO_PORT_3		MX_SPI_2_MISO_PORT
		#define MX_SPI_MISO_TRIS_3		MX_SPI_2_MISO_TRIS
		#define MX_SPI_SCK_PIN_3		MX_SPI_2_CLK_PIN
		#define MX_SPI_SCK_PORT_3		MX_SPI_2_CLK_PORT
		#define MX_SPI_SCK_TRIS_3		MX_SPI_2_CLK_TRIS
		#define MX_SPI_CS_PIN_3			MX_SPI_2_SS_PIN
		#define MX_SPI_CS_PORT_3		MX_SPI_2_SS_PORT
		#define MX_SPI_CS_TRIS_3		MX_SPI_2_SS_TRIS
	#endif
	#if MX_SPI_CHANNEL_3 == 3
		#define MX_SPI_MOSI_PIN_3		MX_SPI_3_MOSI_PIN
		#define MX_SPI_MOSI_PORT_3		MX_SPI_3_MOSI_PORT
		#define MX_SPI_MOSI_TRIS_3		MX_SPI_3_MOSI_TRIS
		#define MX_SPI_MISO_PIN_3		MX_SPI_3_MISO_PIN
		#define MX_SPI_MISO_PORT_3		MX_SPI_3_MISO_PORT
		#define MX_SPI_MISO_TRIS_3		MX_SPI_3_MISO_TRIS
		#define MX_SPI_SCK_PIN_3		MX_SPI_3_CLK_PIN
		#define MX_SPI_SCK_PORT_3		MX_SPI_3_CLK_PORT
		#define MX_SPI_SCK_TRIS_3		MX_SPI_3_CLK_TRIS
		#define MX_SPI_CS_PIN_3			MX_SPI_3_SS_PIN
		#define MX_SPI_CS_PORT_3		MX_SPI_3_SS_PORT
		#define MX_SPI_CS_TRIS_3		MX_SPI_3_SS_TRIS
	#endif
	#if MX_SPI_CHANNEL_3 == 4
		#define MX_SPI_MOSI_PIN_3		MX_SPI_4_MOSI_PIN
		#define MX_SPI_MOSI_PORT_3		MX_SPI_4_MOSI_PORT
		#define MX_SPI_MOSI_TRIS_3		MX_SPI_4_MOSI_TRIS
		#define MX_SPI_MISO_PIN_3		MX_SPI_4_MISO_PIN
		#define MX_SPI_MISO_PORT_3		MX_SPI_4_MISO_PORT
		#define MX_SPI_MISO_TRIS_3		MX_SPI_4_MISO_TRIS
		#define MX_SPI_SCK_PIN_3		MX_SPI_4_CLK_PIN
		#define MX_SPI_SCK_PORT_3		MX_SPI_4_CLK_PORT
		#define MX_SPI_SCK_TRIS_3		MX_SPI_4_CLK_TRIS
		#define MX_SPI_CS_PIN_3			MX_SPI_4_SS_PIN
		#define MX_SPI_CS_PORT_3		MX_SPI_4_SS_PORT
		#define MX_SPI_CS_TRIS_3		MX_SPI_4_SS_TRIS
	#endif
#endif
#ifdef MX_SPI_REF4
	#if MX_SPI_CHANNEL_4 > 0
		#undef MX_SPI_MOSI_PIN_4
		#undef MX_SPI_MOSI_PORT_4
		#undef MX_SPI_MOSI_TRIS_4
		#undef MX_SPI_MISO_PIN_4
		#undef MX_SPI_MISO_PORT_4
		#undef MX_SPI_MISO_TRIS_4
		#undef MX_SPI_SCK_PIN_4
		#undef MX_SPI_SCK_PORT_4
		#undef MX_SPI_SCK_TRIS_4
		#undef MX_SPI_CS_PIN_4
		#undef MX_SPI_CS_PORT_4
		#undef MX_SPI_CS_TRIS_4

		#if MX_SPI_PR_SCALE_4 == 4
			#undef MX_SPI_PR_SCALE_4
			#define MX_SPI_PR_SCALE_4	0
		#endif
		#if MX_SPI_PR_SCALE_4 == 16
			#undef MX_SPI_PR_SCALE_4
			#define MX_SPI_PR_SCALE_4	1
		#endif
		#if MX_SPI_PR_SCALE_4 == 64
			#undef MX_SPI_PR_SCALE_4
			#define MX_SPI_PR_SCALE_4	2
		#endif
	#endif
	#if MX_SPI_CHANNEL_4 == 1
		#define MX_SPI_MOSI_PIN_4		MX_SPI_1_MOSI_PIN
		#define MX_SPI_MOSI_PORT_4		MX_SPI_1_MOSI_PORT
		#define MX_SPI_MOSI_TRIS_4		MX_SPI_1_MOSI_TRIS
		#define MX_SPI_MISO_PIN_4		MX_SPI_1_MISO_PIN
		#define MX_SPI_MISO_PORT_4		MX_SPI_1_MISO_PORT
		#define MX_SPI_MISO_TRIS_4		MX_SPI_1_MISO_TRIS
		#define MX_SPI_SCK_PIN_4		MX_SPI_1_CLK_PIN
		#define MX_SPI_SCK_PORT_4		MX_SPI_1_CLK_PORT
		#define MX_SPI_SCK_TRIS_4		MX_SPI_1_CLK_TRIS
		#define MX_SPI_CS_PIN_4			MX_SPI_1_SS_PIN
		#define MX_SPI_CS_PORT_4		MX_SPI_1_SS_PORT
		#define MX_SPI_CS_TRIS_4		MX_SPI_1_SS_TRIS
	#endif
	#if MX_SPI_CHANNEL_4 == 2
		#define MX_SPI_MOSI_PIN_4		MX_SPI_2_MOSI_PIN
		#define MX_SPI_MOSI_PORT_4		MX_SPI_2_MOSI_PORT
		#define MX_SPI_MOSI_TRIS_4		MX_SPI_2_MOSI_TRIS
		#define MX_SPI_MISO_PIN_4		MX_SPI_2_MISO_PIN
		#define MX_SPI_MISO_PORT_4		MX_SPI_2_MISO_PORT
		#define MX_SPI_MISO_TRIS_4		MX_SPI_2_MISO_TRIS
		#define MX_SPI_SCK_PIN_4		MX_SPI_2_CLK_PIN
		#define MX_SPI_SCK_PORT_4		MX_SPI_2_CLK_PORT
		#define MX_SPI_SCK_TRIS_4		MX_SPI_2_CLK_TRIS
		#define MX_SPI_CS_PIN_4			MX_SPI_2_SS_PIN
		#define MX_SPI_CS_PORT_4		MX_SPI_2_SS_PORT
		#define MX_SPI_CS_TRIS_4		MX_SPI_2_SS_TRIS
	#endif
	#if MX_SPI_CHANNEL_4 == 3
		#define MX_SPI_MOSI_PIN_4		MX_SPI_3_MOSI_PIN
		#define MX_SPI_MOSI_PORT_4		MX_SPI_3_MOSI_PORT
		#define MX_SPI_MOSI_TRIS_4		MX_SPI_3_MOSI_TRIS
		#define MX_SPI_MISO_PIN_4		MX_SPI_3_MISO_PIN
		#define MX_SPI_MISO_PORT_4		MX_SPI_3_MISO_PORT
		#define MX_SPI_MISO_TRIS_4		MX_SPI_3_MISO_TRIS
		#define MX_SPI_SCK_PIN_4		MX_SPI_3_CLK_PIN
		#define MX_SPI_SCK_PORT_4		MX_SPI_3_CLK_PORT
		#define MX_SPI_SCK_TRIS_4		MX_SPI_3_CLK_TRIS
		#define MX_SPI_CS_PIN_4			MX_SPI_3_SS_PIN
		#define MX_SPI_CS_PORT_4		MX_SPI_3_SS_PORT
		#define MX_SPI_CS_TRIS_4		MX_SPI_3_SS_TRIS
	#endif
	#if MX_SPI_CHANNEL_4 == 4
		#define MX_SPI_MOSI_PIN_4		MX_SPI_4_MOSI_PIN
		#define MX_SPI_MOSI_PORT_4		MX_SPI_4_MOSI_PORT
		#define MX_SPI_MOSI_TRIS_4		MX_SPI_4_MOSI_TRIS
		#define MX_SPI_MISO_PIN_4		MX_SPI_4_MISO_PIN
		#define MX_SPI_MISO_PORT_4		MX_SPI_4_MISO_PORT
		#define MX_SPI_MISO_TRIS_4		MX_SPI_4_MISO_TRIS
		#define MX_SPI_SCK_PIN_4		MX_SPI_4_CLK_PIN
		#define MX_SPI_SCK_PORT_4		MX_SPI_4_CLK_PORT
		#define MX_SPI_SCK_TRIS_4		MX_SPI_4_CLK_TRIS
		#define MX_SPI_CS_PIN_4			MX_SPI_4_SS_PIN
		#define MX_SPI_CS_PORT_4		MX_SPI_4_SS_PORT
		#define MX_SPI_CS_TRIS_4		MX_SPI_4_SS_TRIS
	#endif
#endif

#define MX_SPI_CHANNEL_X		CAL_APPEND(MX_SPI_CHANNEL_, MX_SPI_NUM)
#define MX_SPI_MOSI_PIN_X		CAL_APPEND(MX_SPI_MOSI_PIN_, MX_SPI_NUM)
#define MX_SPI_MOSI_PORT_X		CAL_APPEND(MX_SPI_MOSI_PORT_, MX_SPI_NUM)
#define MX_SPI_MOSI_TRIS_X		CAL_APPEND(MX_SPI_MOSI_TRIS_, MX_SPI_NUM)
#define MX_SPI_MISO_PIN_X		CAL_APPEND(MX_SPI_MISO_PIN_, MX_SPI_NUM)
#define MX_SPI_MISO_PORT_X		CAL_APPEND(MX_SPI_MISO_PORT_, MX_SPI_NUM)
#define MX_SPI_MISO_TRIS_X		CAL_APPEND(MX_SPI_MISO_TRIS_, MX_SPI_NUM)
#define MX_SPI_SCK_PIN_X		CAL_APPEND(MX_SPI_SCK_PIN_, MX_SPI_NUM)
#define MX_SPI_SCK_PORT_X		CAL_APPEND(MX_SPI_SCK_PORT_, MX_SPI_NUM)
#define MX_SPI_SCK_TRIS_X		CAL_APPEND(MX_SPI_SCK_TRIS_, MX_SPI_NUM)
#define MX_SPI_CS_PIN_X			CAL_APPEND(MX_SPI_CS_PIN_, MX_SPI_NUM)
#define MX_SPI_CS_PORT_X		CAL_APPEND(MX_SPI_CS_PORT_, MX_SPI_NUM)
#define MX_SPI_CS_TRIS_X		CAL_APPEND(MX_SPI_CS_TRIS_, MX_SPI_NUM)
#define MX_SPI_BMODE_X			CAL_APPEND(MX_SPI_BMODE_, MX_SPI_NUM)
#define MX_SPI_PR_SCALE_X		CAL_APPEND(MX_SPI_PR_SCALE_, MX_SPI_NUM)
#define MX_SPI_PO_SCALE_X		CAL_APPEND(MX_SPI_PO_SCALE_, MX_SPI_NUM)
#define MX_SPI_INT_X			CAL_APPEND(MX_SPI_INT_, MX_SPI_NUM)


//Function Prototypes
CALFUNCTION(void, FC_CAL_SPI_Master_Init_, (void));
CALFUNCTION(void, FC_CAL_SPI_Master_Uninit_, (void));
CALFUNCTION(MX_UINT8, FC_CAL_SPI_Master_Byte_, (MX_UINT8 DataOut));

CALFUNCTION(void, FC_CAL_SPI_Slave_Init_, (void));
CALFUNCTION(void, FC_CAL_SPI_Slave_Uninit_, (void));
CALFUNCTION(void, FC_CAL_SPI_Slave_SetTxData_, (MX_UINT8 Data));
CALFUNCTION(MX_UINT8, FC_CAL_SPI_Slave_GetRxData_, (void));


#if (MX_SPI_CHANNEL_X == 0)
  #ifndef MX_SPI_SW_DEL
    #define MX_SPI_SW_DEL
	MX_UINT8 SPI_SW_DELAY = 1;
  #endif
#endif


//Bus Mode - Bit0=CPOL, Bit1=CPHA, Bit2=CSMP
//CPOL - Clock Polarity - Idle State of the clock 0=0, 1=1
//CPHA - Clock Phase - Clock Edge 0=leading edge, 1=trailing edge
//CSMP - Input Data Bit Sample Phase
//CRAT - SPI Clock Rate 0=1/4, 1=1/16, 2=1/64


//Ensure SSPCON register is defined correctly
#ifndef SSPCON
  #ifdef SSPCON1
	#define sspcon	sspcon1
  #else
	#ifdef SSP1CON1
		#define sspcon	ssp1con1
	#endif
  #endif
#endif
#ifndef SSPBUF
  #ifdef SSP1BUF
	#define sspbuf	ssp1buf
  #endif
#endif

#ifndef SSP2CON
	#ifdef SSP2CON1
		#define ssp2con	ssp2con1
	#endif
#endif




CALFUNCTION(void, FC_CAL_SPI_Master_Init_, (void))

{
	FC_CAL_Bit_High_DDR (MX_SPI_MOSI_PORT_X, MX_SPI_MOSI_TRIS_X, MX_SPI_MOSI_PIN_X);		// MOSI pin is default high
037B  1683  	BSF STATUS, RP0
037C  1303  	BCF STATUS, RP1
037D  1287  	BCF gbl_trisc,5
037E  1283  	BCF STATUS, RP0
037F  1687  	BSF gbl_portc,5

	FC_CAL_Bit_In_DDR   (MX_SPI_MISO_PORT_X, MX_SPI_MISO_TRIS_X, MX_SPI_MISO_PIN_X);		// MISO pin is a input
0380  1683  	BSF STATUS, RP0
0381  1607  	BSF gbl_trisc,4


	#if (MX_SPI_BMODE_X & 0x02)
		FC_CAL_Bit_Low_DDR  (MX_SPI_SCK_PORT_X, MX_SPI_SCK_TRIS_X, MX_SPI_SCK_PIN_X);		// Clock pin is default low
0382  1187  	BCF gbl_trisc,3
0383  1283  	BCF STATUS, RP0
0384  1187  	BCF gbl_portc,3

	#else
		FC_CAL_Bit_High_DDR (MX_SPI_SCK_PORT_X, MX_SPI_SCK_TRIS_X, MX_SPI_SCK_PIN_X);		// Clock pin is default high
	#endif

	#if (MX_SPI_CHANNEL_X == 1)
	 #ifndef MX_SPI_1
	 	#error "SPI channel 1 not available on this device"
	 #else
		sspcon 		 = MX_SPI_PR_SCALE_X & 0x03;			//Assign Clock Prescaler
0385  3002  	MOVLW 0x02
0386  0094  	MOVWF gbl_sspcon

		sspcon.CKP 	 = MX_SPI_BMODE_X & 0x01;				//Assign Clock Polarity
0387  1214  	BCF gbl_sspcon,4

		sspstat.CKE  = (MX_SPI_BMODE_X & 0x02) >> 1;		//Assign Clock Phase
0388  1683  	BSF STATUS, RP0
0389  1714  	BSF gbl_sspstat,6

		sspstat.SMP  = (MX_SPI_BMODE_X & 0x04) >> 2;		//Assign Input Data Phase
038A  1794  	BSF gbl_sspstat,7

		sspcon.SSPEN = 1;									//Activate SPI Peripheral
038B  1283  	BCF STATUS, RP0
038C  1694  	BSF gbl_sspcon,5

	 #endif
	#endif

	#if (MX_SPI_CHANNEL_X == 2)
	 #ifndef MX_SPI_2
	 	#error "SPI channel 2 not available on this device"
	 #else

	  #ifdef MX_SPI_2_REMAPPABLE
		RPINR21 = 3; 										//MISO - RB0 - RP3
		RPOR4 = 9;											//MOSI - RB1 - RP4
		RPOR5 = 10;											//SCK  - RB2 - RP5
	  #endif

		ssp2con 	  = MX_SPI_PR_SCALE_X & 0x03;		//Assign Clock Prescaler
		ssp2con.CKP   = MX_SPI_BMODE_X & 0x01;			//Assign Clock Polarity
		ssp2stat.CKE  = (MX_SPI_BMODE_X & 0x02) >> 1;	//Assign Clock Phase
		ssp2stat.SMP  = (MX_SPI_BMODE_X & 0x04) >> 2;	//Assign Input Data Phase
		ssp2con.SSPEN = 1;									//Activate SPI Peripheral
	 #endif
	#endif
}
038D  0008  	RETURN



CALFUNCTION(void, FC_CAL_SPI_Master_Uninit_, (void))
{
	#if (MX_SPI_CHANNEL_X == 1)
		sspcon = 0;
	#endif

	#if (MX_SPI_CHANNEL_X == 2)
		ssp2con = 0;
    #endif

	//Reset Pins to Inputs
	FC_CAL_Bit_In_DDR (MX_SPI_MOSI_PORT_X, MX_SPI_MOSI_TRIS_X, MX_SPI_MOSI_PIN_X);
	FC_CAL_Bit_In_DDR (MX_SPI_MISO_PORT_X, MX_SPI_MISO_TRIS_X, MX_SPI_MISO_PIN_X);
	FC_CAL_Bit_In_DDR (MX_SPI_SCK_PORT_X, MX_SPI_SCK_TRIS_X, MX_SPI_SCK_PIN_X);
}


CALFUNCTION(MX_UINT8, FC_CAL_SPI_Master_Byte_, (MX_UINT8 DataOut))

{
	MX_UINT8 retVal = 0;
004F  01D4  	CLRF FC_CAL_SPI_00079_1_retVal


	#if (MX_SPI_CHANNEL_X == 0)
		SPI_SW_DELAY = MX_SPI_PR_SCALE_X;

		MX_UINT8 idx;
		for (idx = 0; idx < 8; idx++)
		{
			retVal = retVal << 1;

			#if ((MX_SPI_BMODE_X & 0x02) == 0x00)									//CKE = 0; Set SCK active before data
				#if ((MX_SPI_BMODE_X & 0x01) == 0x00)								//CKP = 0
					FC_CAL_Bit_High(MX_SPI_SCK_PORT_X, MX_SPI_SCK_PIN_X);
				#else
					FC_CAL_Bit_Low(MX_SPI_SCK_PORT_X, MX_SPI_SCK_PIN_X);
				#endif
			#endif

			if (DataOut & 0x80)														//Test Data bit
				FC_CAL_Bit_High(MX_SPI_MOSI_PORT_X, MX_SPI_MOSI_PIN_X);				//Set SDO bit
			else
				FC_CAL_Bit_Low (MX_SPI_MOSI_PORT_X, MX_SPI_MOSI_PIN_X);				//Clear SDO bit

			delay_us(SPI_SW_DELAY);

			#if ((MX_SPI_BMODE_X & 0x02) == 0x02)									//CKE = 1; Set SCK active after data
				#if ((MX_SPI_BMODE_X & 0x01) == 0x00)								//CKP = 0
					FC_CAL_Bit_High(MX_SPI_SCK_PORT_X, MX_SPI_SCK_PIN_X);
				#else
					FC_CAL_Bit_Low(MX_SPI_SCK_PORT_X, MX_SPI_SCK_PIN_X);
				#endif
			#else																	//CKE = 0; Set SCK idle after data
				#if ((MX_SPI_BMODE_X & 0x01) == 0x00)								//CKP = 0
					FC_CAL_Bit_Low(MX_SPI_SCK_PORT_X, MX_SPI_SCK_PIN_X);
				#else
					FC_CAL_Bit_High(MX_SPI_SCK_PORT_X, MX_SPI_SCK_PIN_X);
				#endif
			#endif

			#if ((MX_SPI_BMODE_X & 0x04) == 0)										//Sample at the middle of period
				if(FC_CAL_Bit_In(MX_SPI_MISO_PORT_X, MX_SPI_MISO_PIN_X))
					retVal = retVal | 0x01;
				else
					retVal = retVal & 0xFE;
			#endif

			delay_us(SPI_SW_DELAY);

			#if ((MX_SPI_BMODE_X & 0x02) == 0x02)									//CKE = 1; Set SCK idle to complete cycle																	//CKE = 0; Set SCK idle after data
				#if ((MX_SPI_BMODE_X & 0x01) == 0x00)								//CKP = 0
					FC_CAL_Bit_Low(MX_SPI_SCK_PORT_X, MX_SPI_SCK_PIN_X);
				#else
					FC_CAL_Bit_High(MX_SPI_SCK_PORT_X, MX_SPI_SCK_PIN_X);
				#endif
			#endif

			#if ((MX_SPI_BMODE_X & 0x04) == 0x04)									//Sample at the end of period
				if(FC_CAL_Bit_In(MX_SPI_MISO_PORT_X, MX_SPI_MISO_PIN_X))
					retVal = retVal | 0x01;
				else
					retVal = retVal & 0xFE;
			#endif

			DataOut = DataOut << 1;							//Move to next data bit
		}
    #endif

	#if (MX_SPI_CHANNEL_X == 1)
		sspbuf = DataOut;					//Send outgoing byte
0050  0853  	MOVF FC_CAL_SPI_00079_arg_DataOut, W
0051  1283  	BCF STATUS, RP0
0052  0093  	MOVWF gbl_sspbuf

		while ((sspstat & 0x01) == 0);		//Wait until sspbuf is empty
0053        label6
0053  1683  	BSF STATUS, RP0
0054  1C14  	BTFSS gbl_sspstat,0
0055  2853  	GOTO	label6

		retVal = sspbuf;					//Collect incoming byte
0056  1283  	BCF STATUS, RP0
0057  0813  	MOVF gbl_sspbuf, W
0058  1683  	BSF STATUS, RP0
0059  00D4  	MOVWF FC_CAL_SPI_00079_1_retVal

	#endif

	#if (MX_SPI_CHANNEL_X == 2)
		ssp2buf = DataOut;					//Send outgoing byte
		while ((ssp2stat & 0x01) == 0);		//Wait until sspbuf is empty
		retVal = ssp2buf;					//Collect incoming byte
	#endif

	return (retVal);
005A  0854  	MOVF FC_CAL_SPI_00079_1_retVal, W
005B  00D5  	MOVWF CompTempVarRet2290

}
005C  0008  	RETURN






CALFUNCTION(void, FC_CAL_SPI_Slave_Init_, (void))
{

}

CALFUNCTION(void, FC_CAL_SPI_Slave_Uninit_, (void))
{

}

CALFUNCTION(void, FC_CAL_SPI_Slave_SetTxData_, (MX_UINT8 Data))
{

}

CALFUNCTION(MX_UINT8, FC_CAL_SPI_Slave_GetRxData_, (void))
{

}



/*********************************************************************
 *                  Flowcode CAL UART File
 *
 * File: PIC_CAL_UART.c
 *
 * (c) 2011 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * “Company”) for its Flowcode graphical programming language is
 * intended and supplied to you, the Company’s customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 010911 | BR | Created
 * 020911 | BR | Updated variables with typedef alternatives
 * 011211 | BR | Converted to new dynamic defines mechanism
 * 160112 | BR | Fixed issues with rx return type and low bauds on fast devices
 * 020212 | ST | Added <MX_UART_2_PIE4> routing to account for differences in 16F and 18F devices with 2 UARTs
 * 270212 | BR | Fixed a bug in the receive functionality
 * 280212 | BR | Sorted out auto echo functionality
 * 160412 | BR | Addition of HW change baud function
 */



#ifndef MX_UART_SW_DEFS
	#define MX_UART_SW_DEFS

	#ifdef _BOOSTC
		#define INST_COUNT	45	//65 for lower speeds or 40 for higher speeds.
	#endif
	#ifdef HI_TECH_C
		#define INST_COUNT	315
	#endif

	//Work out number of nops for software baud rate
	#define MX_INSTRUCTION_SPEED 	(MX_CLK_SPEED / 4)
	#define MX_OVERHEAD				(MX_INSTRUCTION_SPEED / INST_COUNT)
	#define SW_OFFSET				(1000000 / MX_OVERHEAD)

	//Work out software baud rates if required
	#define SW_1200_BAUD	(832 - SW_OFFSET)
	#define SW_2400_BAUD	(416 - SW_OFFSET)
	#define SW_4800_BAUD	(208 - SW_OFFSET)
	#define SW_9600_BAUD	(104 - SW_OFFSET)
	#define SW_19200_BAUD	(52 - SW_OFFSET)
	#define SW_31250_BAUD	(32 - SW_OFFSET)
	#define SW_115200_BAUD	(8 - SW_OFFSET)
#endif

 #if defined(MX_UART_CHANNEL_1) && (MX_UART_NUM==1)
	#if (MX_UART_CHANNEL_1 == 0)
		#if (MX_UART_BAUD_1 == 1200)
			#define MX_SOFT_BAUD_1	SW_1200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 1200 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_1 == 2400)
			#define MX_SOFT_BAUD_1	SW_2400_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 2400 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_1 == 4800)
			#define MX_SOFT_BAUD_1	SW_4800_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 4800 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_1 == 9600)
			#define MX_SOFT_BAUD_1	SW_9600_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 9600 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_1 == 19200)
			#define MX_SOFT_BAUD_1	SW_19200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 19200 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_1 == 31250)
			#define MX_SOFT_BAUD_1	SW_31250_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 31250 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_1 == 115200)
			#define MX_SOFT_BAUD_1	SW_115200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 115200 Not Available At This Clock Speed"
			#endif
		#endif
		#ifndef MX_SOFT_BAUD_1
			#error "UART Baud Rate not supported in Software Mode"
		#endif
	#else
		#define MX_SOFT_BAUD_1	1
		#define MX_HARD_BAUD_1	(((MX_CLK_SPEED / MX_UART_BAUD_1) - 16) / 16)
		#define MX_HARD_SLOW_1	0

		#if (MX_HARD_BAUD_1 > 255)
			#undef MX_HARD_BAUD_1
			#undef MX_HARD_SLOW_1
			#define MX_HARD_BAUD_1	(((MX_CLK_SPEED / MX_UART_BAUD_1) - 16)	/ 64)
			#define MX_HARD_SLOW_1	1
		#endif

	#endif
 #endif
 #if defined(MX_UART_CHANNEL_2) && (MX_UART_NUM==2)
	#if (MX_UART_CHANNEL_2 == 0)
		#if (MX_UART_BAUD_2 == 1200)
			#define MX_SOFT_BAUD_2	SW_1200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 1200 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_2 == 2400)
			#define MX_SOFT_BAUD_2	SW_2400_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 2400 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_2 == 4800)
			#define MX_SOFT_BAUD_2	SW_4800_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 4800 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_2 == 9600)
			#define MX_SOFT_BAUD_2	SW_9600_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 9600 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_2 == 19200)
			#define MX_SOFT_BAUD_2	SW_19200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 19200 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_2 == 31250)
			#define MX_SOFT_BAUD_2	SW_31250_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 31250 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_2 == 115200)
			#define MX_SOFT_BAUD_2	SW_115200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 115200 Not Available At This Clock Speed"
			#endif
		#endif
		#ifndef MX_SOFT_BAUD_2
			#error "UART Baud Rate not supported in Software Mode"
		#endif
	#else
		#define MX_SOFT_BAUD_2	1
		#define MX_HARD_BAUD_2	(((MX_CLK_SPEED / MX_UART_BAUD_2) - 16) / 16)
		#define MX_HARD_SLOW_2	0

		#if (MX_HARD_BAUD_2 > 255)
			#undef MX_HARD_BAUD_2
			#undef MX_HARD_SLOW_2
			#define MX_HARD_BAUD_2	(((MX_CLK_SPEED / MX_UART_BAUD_2) - 16)	/ 64)
			#define MX_HARD_SLOW_2	1
		#endif
 	#endif
 #endif
 #if defined(MX_UART_CHANNEL_3) && (MX_UART_NUM==3)
	#if (MX_UART_CHANNEL_3 == 0)
		#if (MX_UART_BAUD_3 == 1200)
			#define MX_SOFT_BAUD_3	SW_1200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 1200 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_3 == 2400)
			#define MX_SOFT_BAUD_3	SW_2400_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 2400 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_3 == 4800)
			#define MX_SOFT_BAUD_3	SW_4800_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 4800 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_3 == 9600)
			#define MX_SOFT_BAUD_3	SW_9600_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 9600 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_3 == 19200)
			#define MX_SOFT_BAUD_3	SW_19200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 19200 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_3 == 31250)
			#define MX_SOFT_BAUD_3	SW_31250_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 31250 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_3 == 115200)
			#define MX_SOFT_BAUD_3	SW_115200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 115200 Not Available At This Clock Speed"
			#endif
		#endif
		#ifndef MX_SOFT_BAUD_3
			#error "UART Baud Rate not supported in Software Mode"
		#endif
	#else
		#define MX_SOFT_BAUD_3	1
		#define MX_HARD_BAUD_3	(((MX_CLK_SPEED / MX_UART_BAUD_3) - 16) / 16)
		#define MX_HARD_SLOW_3	0

		#if (MX_HARD_BAUD_3 > 255)
			#undef MX_HARD_BAUD_3
			#undef MX_HARD_SLOW_3
			#define MX_HARD_BAUD_3	(((MX_CLK_SPEED / MX_UART_BAUD_3) - 16)	/ 64)
			#define MX_HARD_SLOW_3	1
		#endif
	#endif
 #endif
 #if defined(MX_UART_CHANNEL_4) && (MX_UART_NUM==4)
	#if (MX_UART_CHANNEL_4 == 0)
		#if (MX_UART_BAUD_4 == 1200)
			#define MX_SOFT_BAUD_4	SW_1200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 1200 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_4 == 2400)
			#define MX_SOFT_BAUD_4	SW_2400_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 2400 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_4 == 4800)
			#define MX_SOFT_BAUD_4	SW_4800_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 4800 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_4 == 9600)
			#define MX_SOFT_BAUD_4	SW_9600_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 9600 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_4 == 19200)
			#define MX_SOFT_BAUD_4	SW_19200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 19200 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_4 == 31250)
			#define MX_SOFT_BAUD_4	SW_31250_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 31250 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_4 == 115200)
			#define MX_SOFT_BAUD_4	SW_115200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 115200 Not Available At This Clock Speed"
			#endif
		#endif
		#ifndef MX_SOFT_BAUD_4
			#error "UART Baud Rate not supported in Software Mode"
		#endif
	#else
		#define MX_SOFT_BAUD_4	1
		#define MX_HARD_BAUD_4	(((MX_CLK_SPEED / MX_UART_BAUD_4) - 16) / 16)
		#define MX_HARD_SLOW_4	0

		#if (MX_HARD_BAUD_4 > 255)
			#undef MX_HARD_BAUD_4
			#undef MX_HARD_SLOW_4
			#define MX_HARD_BAUD_4	(((MX_CLK_SPEED / MX_UART_BAUD_4) - 16)	/ 64)
			#define MX_HARD_SLOW_4	1
		#endif
	#endif
 #endif


//Hardware Baud update definitions
#ifndef MX_HARD_BAUD_CHANGE_DEFS
	#define MX_HARD_BAUD_CHANGE_DEFS

	#define MX_HARD_BAUD_1200	(((MX_CLK_SPEED / 1200) - 16) / 16)
	#if (MX_HARD_BAUD_1200 > 255)
		#undef MX_HARD_BAUD_1200
		#define MX_HARD_BAUD_1200	(((MX_CLK_SPEED / 1200) - 16) / 64)
		#define MX_HARD_SLOW_1200	1
	#else
		#define MX_HARD_SLOW_1200	0
	#endif

	#define MX_HARD_BAUD_2400	(((MX_CLK_SPEED / 2400) - 16) / 16)
	#if (MX_HARD_BAUD_2400 > 255)
		#undef MX_HARD_BAUD_2400
		#define MX_HARD_BAUD_2400	(((MX_CLK_SPEED / 2400) - 16) / 64)
		#define MX_HARD_SLOW_2400	1
	#else
		#define MX_HARD_SLOW_2400	0
	#endif

	#define MX_HARD_BAUD_4800	(((MX_CLK_SPEED / 4800) - 16) / 16)
	#if (MX_HARD_BAUD_4800 > 255)
		#undef MX_HARD_BAUD_4800
		#define MX_HARD_BAUD_4800	(((MX_CLK_SPEED / 4800) - 16) / 64)
		#define MX_HARD_SLOW_4800	1
	#else
		#define MX_HARD_SLOW_4800	0
	#endif

	#define MX_HARD_BAUD_9600	(((MX_CLK_SPEED / 9600) - 16) / 16)
	#if (MX_HARD_BAUD_9600 > 255)
		#undef MX_HARD_BAUD_9600
		#define MX_HARD_BAUD_9600	(((MX_CLK_SPEED / 9600) - 16) / 64)
		#define MX_HARD_SLOW_9600	1
	#else
		#define MX_HARD_SLOW_9600	0
	#endif

	#define MX_HARD_BAUD_19200	(((MX_CLK_SPEED / 19200) - 16) / 16)
	#if (MX_HARD_BAUD_19200 > 255)
		#undef MX_HARD_BAUD_19200
		#define MX_HARD_BAUD_19200	(((MX_CLK_SPEED / 19200) - 16) / 64)
		#define MX_HARD_SLOW_19200	1
	#else
		#define MX_HARD_SLOW_19200	0
	#endif

	#define MX_HARD_BAUD_38400	(((MX_CLK_SPEED / 38400) - 16) / 16)
	#if (MX_HARD_BAUD_38400 > 255)
		#undef MX_HARD_BAUD_38400
		#define MX_HARD_BAUD_38400	(((MX_CLK_SPEED / 38400) - 16) / 64)
		#define MX_HARD_SLOW_38400	1
	#else
		#define MX_HARD_SLOW_38400	0
	#endif

	#define MX_HARD_BAUD_57600	(((MX_CLK_SPEED / 57600) - 16) / 16)
	#if (MX_HARD_BAUD_57600 > 255)
		#undef MX_HARD_BAUD_57600
		#define MX_HARD_BAUD_57600	(((MX_CLK_SPEED / 57600) - 16) / 64)
		#define MX_HARD_SLOW_57600	1
	#else
		#define MX_HARD_SLOW_57600	0
	#endif

	#define MX_HARD_BAUD_115200	(((MX_CLK_SPEED / 115200) - 16) / 16)
	#if (MX_HARD_BAUD_115200 > 255)
		#undef MX_HARD_BAUD_115200
		#define MX_HARD_BAUD_115200	(((MX_CLK_SPEED / 115200) - 16) / 64)
		#define MX_HARD_SLOW_115200	1
	#else
		#define MX_HARD_SLOW_115200	0
	#endif
#endif


//Dynamic function naming based on defines and index number
#define MX_UART_CHANNEL_X	CAL_APPEND(MX_UART_CHANNEL_, MX_UART_NUM)
#define MX_UART_TX_PIN_X	CAL_APPEND(MX_UART_TX_PIN_, MX_UART_NUM)
#define MX_UART_TX_PORT_X	CAL_APPEND(MX_UART_TX_PORT_, MX_UART_NUM)
#define MX_UART_TX_TRIS_X	CAL_APPEND(MX_UART_TX_TRIS_, MX_UART_NUM)
#define MX_UART_RX_PIN_X	CAL_APPEND(MX_UART_RX_PIN_, MX_UART_NUM)
#define MX_UART_RX_PORT_X	CAL_APPEND(MX_UART_RX_PORT_, MX_UART_NUM)
#define MX_UART_RX_TRIS_X	CAL_APPEND(MX_UART_RX_TRIS_, MX_UART_NUM)
#define MX_UART_FLOWEN_X	CAL_APPEND(MX_UART_FLOWEN_, MX_UART_NUM)
#define MX_UART_CTS_PIN_X	CAL_APPEND(MX_UART_CTS_PIN_, MX_UART_NUM)
#define MX_UART_CTS_PORT_X	CAL_APPEND(MX_UART_CTS_PORT_, MX_UART_NUM)
#define MX_UART_CTS_TRIS_X	CAL_APPEND(MX_UART_CTS_TRIS_, MX_UART_NUM)
#define MX_UART_RTS_PIN_X	CAL_APPEND(MX_UART_RTS_PIN_, MX_UART_NUM)
#define MX_UART_RTS_PORT_X	CAL_APPEND(MX_UART_RTS_PORT_, MX_UART_NUM)
#define MX_UART_RTS_TRIS_X	CAL_APPEND(MX_UART_RTS_TRIS_, MX_UART_NUM)
#define MX_UART_DBITS_X		CAL_APPEND(MX_UART_DBITS_, MX_UART_NUM)
#define MX_UART_RETURN_X	CAL_APPEND(MX_UART_RETURN_, MX_UART_NUM)
#define MX_UART_ECHO_X		CAL_APPEND(MX_UART_ECHO_, MX_UART_NUM)
#define MX_UART_INT_X		CAL_APPEND(MX_UART_INT_, MX_UART_NUM)
#define MX_UART_BAUD_X		CAL_APPEND(MX_HARD_BAUD_, MX_UART_NUM)
#define MX_SOFT_BAUD_X		CAL_APPEND(MX_SOFT_BAUD_, MX_UART_NUM)
#define MX_HARD_SLOW_X		CAL_APPEND(MX_HARD_SLOW_, MX_UART_NUM)

#define UART_Delay_CAL		CAL_APPEND(FC_CAL_UART_Delay_, MX_UART_NUM)
#define UART_Send			CAL_APPEND(FC_CAL_UART_Send_, MX_UART_NUM)
#define UART_Uninit			CAL_APPEND(FC_CAL_UART_Uninit_, MX_UART_NUM)


//Component Definitions
#define UART_STATUS_LOOP	0
#define UART_STATUS_TIMEOUT	1
#define UART_STATUS_RXBYTE	2


//Interrupt Definitions
#ifdef MX_UART_2_PIE4
  #define MX_UART2_PIE pie4
  #define MX_UART2_PIR pir4
  #define MX_UART2_TXSTA tx2sta
  #define MX_UART2_RCSTA rc2sta
  #define MX_UART2_TXREG tx2reg
  #define MX_UART2_RCREG rc2reg
#else
  #define MX_UART2_PIE pie3
  #define MX_UART2_PIR pir3
  #define MX_UART2_TXSTA txsta2
  #define MX_UART2_RCSTA rcsta2
  #define MX_UART2_TXREG txreg2
  #define MX_UART2_RCREG rcreg2
#endif

#if (MX_UART_INT_X == 1)

	#ifndef MX_UART_INT_DEFS
	#define MX_UART_INT_DEFS

		#define MX_UART_INT_CH1_FUNC
		#define MX_UART_INT_CH2_FUNC
		#define MX_UART_INT_FUNC_END

		#define MX_UART_INT_CH1_DET		ts_bit(pir1, RCIF) && ts_bit(pie1, RCIE)
		#define MX_UART_INT_CH2_DET		ts_bit(MX_UART2_PIR, RC2IF) && ts_bit(MX_UART2_PIE, RC2IE)

		#define MX_UART_INT_CH1_EN		st_bit (pie1, RCIE)
		#define MX_UART_INT_CH2_EN		st_bit (MX_UART2_PIE, RC2IE)

		#define MX_UART_INT_CH1_DIS		cr_bit (pie1, RCIE)
		#define MX_UART_INT_CH2_DIS		cr_bit (MX_UART2_PIE, RC2IE)

		#define MX_UART_INT_CH1_CLR		cr_bit (pir1, RCIF)
		#define MX_UART_INT_CH2_CLR		cr_bit (MX_UART2_PIR, RC2IF)

	#endif
#endif


//Function Prototypes
CALFUNCTION(void, FC_CAL_UART_Init_, (void));
CALFUNCTION(void, FC_CAL_UART_Uninit_, (void));
CALFUNCTION(void, FC_CAL_UART_Send_, (MX_UINT16 nChar));
CALFUNCTION(MX_SINT16, FC_CAL_UART_Receive_, (MX_UINT8 nTimeout));
CALFUNCTION(void, FC_CAL_UART_Delay_, (void));


//Peripheral Functions
CALFUNCTION(void, FC_CAL_UART_Init_, (void))

{

	#if (MX_UART_CHANNEL_X == 0)
		FC_CAL_Bit_In_DDR 	(MX_UART_RX_PORT_X, MX_UART_RX_TRIS_X, MX_UART_RX_PIN_X);		// Receive pin is a input
		FC_CAL_Bit_High_DDR (MX_UART_TX_PORT_X, MX_UART_TX_TRIS_X, MX_UART_TX_PIN_X);		// Transmit pin is default high
	#endif

	#if (MX_UART_CHANNEL_X == 1)
	  #ifndef MX_UART_1
	  	  #error "UART channel 1 not available on this device"
	  #else
		  #if (MX_HARD_SLOW_X == 1)
			cr_bit(txsta, BRGH);						//Low Speed
		  #else
			st_bit(txsta, BRGH);						//High Speed
04E0  1683  	BSF STATUS, RP0
04E1  1303  	BCF STATUS, RP1
04E2  1518  	BSF gbl_txsta,2

		  #endif
			spbrg = MX_UART_BAUD_X;   					// set the baud rate
04E3  3081  	MOVLW 0x81
04E4  0099  	MOVWF gbl_spbrg

			rcsta = 0;                    				// 8-bit, disabled
04E5  1283  	BCF STATUS, RP0
04E6  0198  	CLRF gbl_rcsta


			#if(MX_UART_DBITS_X == 9)
				st_bit(txsta, TX9);   					// 9-bit TX
				st_bit(rcsta, RX9);                    	// 9-bit RX
			#endif

			st_bit(rcsta, SPEN);         				// turn on serial interface
04E7  1798  	BSF gbl_rcsta,7

			st_bit(txsta, TXEN);
04E8  1683  	BSF STATUS, RP0
04E9  1698  	BSF gbl_txsta,5

			st_bit(rcsta, CREN);
04EA  1283  	BCF STATUS, RP0
04EB  1618  	BSF gbl_rcsta,4


			#if (MX_UART_INT_X == 1)
				MX_UART_INT_CH1_EN;
				st_bit(intcon, PEIE);
				st_bit(intcon, GIE);
			#else
				cr_bit (pie1, RCIE);
04EC  1683  	BSF STATUS, RP0
04ED  128C  	BCF gbl_pie1,5

			#endif
	  #endif
	#endif


	#if (MX_UART_CHANNEL_X == 2)

	  #ifndef MX_UART_2
		  #error "UART channel 2 not available on this device"
	  #else
		  #ifdef MX_UART_2_REMAPPABLE
			RPOR9 = 5;									//TX2 - RP9 - RB6
			RPINR16	= 10;								//RX2 - RP10 - RB7
		  #endif
		  #if (MX_HARD_SLOW_X == 1)
			cr_bit(MX_UART2_TXSTA, BRGH);						//Low Speed
		  #else
			st_bit(MX_UART2_TXSTA, BRGH);						//High Speed
		  #endif
			spbrg2 = MX_UART_BAUD_X;   				// set the baud rate
			MX_UART2_RCSTA = 0;                    				// 8-bit, disabled

			#if(MX_UART_DBITS_X == 9)
				st_bit(MX_UART2_TXSTA, TX9);   					// 9-bit TX
				st_bit(MX_UART2_RCSTA, RX9);                    // 9-bit RX
			#endif

			st_bit(MX_UART2_RCSTA, SPEN);         				// turn on serial interface
			st_bit(MX_UART2_TXSTA, TXEN);
			st_bit(MX_UART2_RCSTA, CREN);

			#if (MX_UART_INT_X == 1)
				MX_UART_INT_CH2_EN;
				st_bit(intcon, PEIE);
				st_bit(intcon, GIE);
			#else
				cr_bit (MX_UART2_PIE, RC2IE);
			#endif
	  #endif
	#endif

	#if (MX_UART_FLOWEN_X == 1)						//Flowcontrol enabled?
		FC_CAL_Bit_In_DDR (MX_UART_CTS_PORT_X, MX_UART_CTS_TRIS_X, MX_UART_CTS_PIN_X);	// CTS pin is a input
		FC_CAL_Bit_High_DDR (MX_UART_RTS_PORT_X, MX_UART_RTS_TRIS_X, MX_UART_RTS_PIN_X);	// RTS not ready to accept data
	#endif

}
04EE  0008  	RETURN




CALFUNCTION(void, FC_CAL_UART_Uninit_, (void))
{

	#if (MX_UART_CHANNEL_X == 0)
		FC_CAL_Bit_In_DDR (MX_UART_RX_PORT_X, MX_UART_RX_TRIS_X, MX_UART_RX_PIN_X);		// Receive pin is a input
		FC_CAL_Bit_In_DDR (MX_UART_TX_PORT_X, MX_UART_TX_TRIS_X, MX_UART_TX_PIN_X);		// Transmit pin is default high
	#endif

	#if (MX_UART_CHANNEL_X == 1)
			rcsta = 0;                    								// 8-bit, disabled
			txsta = 0;
		  #ifdef MX_UART_RXINT
			MX_UART_INT_CH1_DIS;
		  #endif
	#endif

	#if (MX_UART_CHANNEL_X == 2)
			MX_UART2_RCSTA = 0;                    								// 8-bit, disabled
			MX_UART2_TXSTA = 0;
		  #ifdef MX_UART_RXINT
			MX_UART_INT_CH2_DIS;
		  #endif
	#endif

	#if (MX_UART_FLOWEN_X == 1)										//Flowcontrol enabled?
		FC_CAL_Bit_In_DDR (MX_UART_CTS_PORT_X, MX_UART_CTS_TRIS_X, MX_UART_CTS_PIN_X);		// CTS pin is a input
		FC_CAL_Bit_In_DDR (MX_UART_RTS_PORT_X, MX_UART_RTS_TRIS_X, MX_UART_RTS_PIN_X);		// RTS not ready to accept data
	#endif
}



CALFUNCTION(void, FC_CAL_UART_Send_, (MX_UINT16 nChar))
{
	#if (MX_UART_FLOWEN_X == 1)
		while (FC_CAL_Bit_In(MX_UART_CTS_PORT_X, MX_UART_CTS_PIN_X) != 0);	// Wait until CTS is low
	#endif

	#if (MX_UART_CHANNEL_X == 0)													// Software UART TX
		MX_UINT8 idx;
		FC_CAL_Bit_Low(MX_UART_TX_PORT_X, MX_UART_TX_PIN_X);					// Send Start bit
		UART_Delay_CAL();
		for (idx = 0; idx < MX_UART_DBITS_X; idx++)
		{
			if (nChar & 0x01)														// Mask off data bit
				FC_CAL_Bit_High(MX_UART_TX_PORT_X, MX_UART_TX_PIN_X);
			else
				FC_CAL_Bit_Low(MX_UART_TX_PORT_X, MX_UART_TX_PIN_X);
			UART_Delay_CAL();
			nChar = nChar >> 1;														// Move to next data bit
		}
		FC_CAL_Bit_High(MX_UART_TX_PORT_X, MX_UART_TX_PIN_X);					// Send Stop bit
		UART_Delay_CAL();
	#endif

	#if (MX_UART_CHANNEL_X == 1)
		while (ts_bit(pir1, TXIF) == 0);

		#if (MX_UART_DBITS_X == 9)
			if (test_bit(nChar, 8))
				st_bit(txsta, TX9D);
			else
				cr_bit(txsta, TX9D);
	  	#endif
		txreg = nChar;
	#endif

	#if (MX_UART_CHANNEL_X == 2)
		while (ts_bit(pir3, TX2IF) == 0);

		#if (MX_UART_DBITS_X == 9)
			if (test_bit(nChar, 8))
				st_bit(MX_UART2_TXSTA, TX9D);
			else
				cr_bit(MX_UART2_TXSTA, TX9D);
		#endif
		MX_UART2_TXREG = nChar;
	#endif
}


CALFUNCTION(MX_SINT16, FC_CAL_UART_Receive_, (MX_UINT8 nTimeout))
{
  #if (MX_UART_RETURN_X == 1)
	MX_UINT16 retVal = 512;
  #else
  	MX_UINT8 retVal = 255;
  #endif

	MX_UINT8 delay1 = 0;
	MX_UINT8 regcheck = 0;
	MX_UINT8 bWaitForever = 0;
	MX_UINT8 rxStatus = UART_STATUS_LOOP;

  #if (MX_UART_CHANNEL_X == 0)
  	MX_UINT8 idx;
  #else
  	MX_UINT8 dummy = 0;
  #endif

	if (nTimeout == 255)
		bWaitForever = 1;

	#if (MX_UART_FLOWEN_X == 1)
		FC_CAL_Bit_Low (MX_UART_RTS_PORT_X, MX_UART_RTS_PIN_X);			// Ready to accept data
	#endif

	while (rxStatus == UART_STATUS_LOOP)
	{
		if (bWaitForever == 0)
		{
			if (nTimeout == 0)							//don't wait forever, so do timeout thing...
			{
				rxStatus = UART_STATUS_TIMEOUT;
			}
			else
			{
				delay_us(10);
				delay1 = delay1 + 1;
				if(delay1 == 100)
				{
					nTimeout = nTimeout - 1;
					MX_CLEAR_WATCHDOG;
					delay1 = 0;
				}
			}
		}

		#if (MX_UART_CHANNEL_X == 0)
			regcheck = FC_CAL_Bit_In(MX_UART_RX_PORT_1, MX_UART_RX_PIN_1);	//Test for start bit
			if (regcheck == 0)
				rxStatus = UART_STATUS_RXBYTE;
		#endif

		#if (MX_UART_CHANNEL_X == 1)
			regcheck = ts_bit(pir1, RCIF);
			if (regcheck != 0)
				rxStatus = UART_STATUS_RXBYTE;
		#endif

		#if (MX_UART_CHANNEL_X == 2)
			regcheck = ts_bit(MX_UART2_PIR, RC2IF);
			if (regcheck != 0)
				rxStatus = UART_STATUS_RXBYTE;
		#endif

	}

	if (rxStatus == UART_STATUS_RXBYTE)
	{
		#if (MX_UART_CHANNEL_X == 0)

			retVal = 0;
			UART_Delay_CAL();

			for (idx = 0; idx < MX_UART_DBITS_X; idx++)
			{
				if (FC_CAL_Bit_In(MX_UART_RX_PORT_X, MX_UART_RX_PIN_X))
					retVal = retVal | (0x01 << idx);

				UART_Delay_CAL();
			}
		#endif

		#if (MX_UART_CHANNEL_X == 1)
			regcheck = ts_bit(rcsta, FERR);
			if (regcheck != 0)
			{
				dummy = rcreg;						//need to read the rcreg to clear FERR
				#if (MX_UART_RETURN_X == 1)
					retVal = 0x400;					//Framing Error Flag
				#endif
			}
			else
			{
				regcheck = ts_bit(rcsta, OERR);
				if (regcheck != 0)
				{
					cr_bit(rcsta, CREN);			//Reset receiver to clear error
					st_bit(rcsta, CREN);

					#if (MX_UART_RETURN_X == 1)
						retVal = 0x800;				//Overrun Error Flag
					#endif
				}
				else
				{
					retVal = 0;

					#if (MX_UART_DBITS_X == 9)
						if(ts_bit(rcsta, RX9D))
							retVal = 0x100;
					#endif

					retVal = retVal | rcreg; 			//no error, so rx byte is valid
				}
			}
		#endif

		#if (MX_UART_CHANNEL_X == 2)
			regcheck = ts_bit(MX_UART2_RCSTA, FERR);
			if (regcheck != 0)
			{
				dummy = MX_UART2_RCREG;			//need to read the rcreg to clear FERR
				#if (MX_UART_RETURN_X == 1)
					retVal = 0x400;					//Framing Error Flag
				#endif
			}
			else
			{
				regcheck = ts_bit(MX_UART2_RCSTA, OERR);
				if (regcheck != 0)
				{
					cr_bit(MX_UART2_RCSTA, CREN);	//Reset receiver to clear error
					st_bit(MX_UART2_RCSTA, CREN);
					#if (MX_UART_RETURN_X == 1)
						retVal = 0x800;				//Overrun Error Flag
					#endif
				}
				else
				{
					retVal = 0;

					#if (MX_UART_DBITS_X == 9)
						if(ts_bit(MX_UART2_RCSTA, RX9D))
							retVal = 0x100;
					#endif

					retVal = retVal | MX_UART2_RCREG; 			//no error, so rx byte is valid
				}
			}

		#endif

		#if (MX_UART_ECHO_X == 1)
			UART_Send(retVal);
		#endif
	}

	#if (MX_UART_FLOWEN_X == 1)
		FC_CAL_Bit_High(MX_UART_RTS_PORT_X, MX_UART_RTS_PIN_X);		//not ready to accept data
	#endif

	return (retVal);
}


CALFUNCTION(void, FC_CAL_UART_Delay_, (void))
{
  #if (MX_UART_CHANNEL_X == 0)

	MX_UINT16 delay = MX_SOFT_BAUD_X;

	while (delay > 255)
	{
		delay_us(255);
		delay = delay - 255;
		MX_CLEAR_WATCHDOG;
	}
	delay_us(delay);
	MX_CLEAR_WATCHDOG;

  #endif
}


CALFUNCTION(void, FC_CAL_UART_Update_Baud_, (MX_UINT8 new_baud))
{
	//Baud Rates - Function compatible with hardware mode only
	/*
	0 - 1200
	1 - 2400
	2 - 4800
	3 - 9600
	4 - 19200
	5 - 38400
	6 - 57600
	7 - 115200
	*/

	MX_UINT8 baudrate, baudmode;

	if (new_baud > 7)
		return;

	if (new_baud == 0)
	{
		baudrate = MX_HARD_BAUD_1200;
		baudmode = MX_HARD_SLOW_1200;
	}
	else if (new_baud == 1)
	{
		baudrate = MX_HARD_BAUD_2400;
		baudmode = MX_HARD_SLOW_2400;
	}
	else if (new_baud == 2)
	{
		baudrate = MX_HARD_BAUD_4800;
		baudmode = MX_HARD_SLOW_4800;
	}
	else if (new_baud == 3)
	{
		baudrate = MX_HARD_BAUD_9600;
		baudmode = MX_HARD_SLOW_9600;
	}
	else if (new_baud == 4)
	{
		baudrate = MX_HARD_BAUD_19200;
		baudmode = MX_HARD_SLOW_19200;
	}
	else if (new_baud == 5)
	{
		baudrate = MX_HARD_BAUD_38400;
		baudmode = MX_HARD_SLOW_38400;
	}
	else if (new_baud == 6)
	{
		baudrate = MX_HARD_BAUD_57600;
		baudmode = MX_HARD_SLOW_57600;
	}
	else if (new_baud == 7)
	{
		baudrate = MX_HARD_BAUD_115200;
		baudmode = MX_HARD_SLOW_115200;
	}

	UART_Uninit();

	#if (MX_UART_CHANNEL_X == 1)

	    if (baudmode == 1)
			cr_bit(txsta, BRGH);					//Low Speed
	    else
			st_bit(txsta, BRGH);					//High Speed

		spbrg = baudrate;   						// set the baud rate
		rcsta = 0;                    				// 8-bit, disabled

		#if(MX_UART_DBITS_X == 9)
			st_bit(txsta, TX9);   					// 9-bit TX
			st_bit(rcsta, RX9);                    	// 9-bit RX
		#endif

		st_bit(rcsta, SPEN);         				// turn on serial interface
		st_bit(txsta, TXEN);
		st_bit(rcsta, CREN);

		#if (MX_UART_INT_X == 1)
			MX_UART_INT_CH1_EN;
			st_bit(intcon, PEIE);
			st_bit(intcon, GIE);
		#else
			cr_bit (pie1, RCIE);
		#endif
	#endif

	#if (MX_UART_CHANNEL_X == 2)

	  	if (baudmode == 1)
			cr_bit(MX_UART2_TXSTA, BRGH);			//Low Speed
	  	else
			st_bit(MX_UART2_TXSTA, BRGH);			//High Speed

		spbrg2 = baudrate;   						// set the baud rate
		MX_UART2_RCSTA = 0;                    		// 8-bit, disabled

		#if(MX_UART_DBITS_X == 9)
			st_bit(MX_UART2_TXSTA, TX9);   			// 9-bit TX
			st_bit(MX_UART2_RCSTA, RX9);            // 9-bit RX
		#endif

		st_bit(MX_UART2_RCSTA, SPEN);         		// turn on serial interface
		st_bit(MX_UART2_TXSTA, TXEN);
		st_bit(MX_UART2_RCSTA, CREN);

		#if (MX_UART_INT_X == 1)
			MX_UART_INT_CH2_EN;
			st_bit(intcon, PEIE);
			st_bit(intcon, GIE);
		#else
			cr_bit (MX_UART2_PIE, RC2IE);
		#endif
	#endif

	#if (MX_UART_FLOWEN_X == 1)						//Flowcontrol enabled?
		FC_CAL_Bit_In_DDR (MX_UART_CTS_PORT_X, MX_UART_CTS_TRIS_X, MX_UART_CTS_PIN_X);	// CTS pin is a input
		FC_CAL_Bit_High_DDR (MX_UART_RTS_PORT_X, MX_UART_RTS_TRIS_X, MX_UART_RTS_PIN_X);	// RTS not ready to accept data
	#endif

}

////////////////////////////////////////
// Code with no source :-)
////////////////////////////////////////
0000  158A  	BSF PCLATH,3
0001  2837  	GOTO	_startup

0004  00FF  	MOVWF Int1Context
0005  0E03  	SWAPF STATUS, W
0006  1283  	BCF STATUS, RP0
0007  1303  	BCF STATUS, RP1
0008  00F4  	MOVWF Int1BContext
0009  0E0A  	SWAPF PCLATH, W
000A  00F5  	MOVWF Int1BContext+D'1'
000B  0E04  	SWAPF FSR, W
000C  00F6  	MOVWF Int1BContext+D'2'
000D  158A  	BSF PCLATH,3
000E  120A  	BCF PCLATH,4
000F  28A6  	GOTO	interrupt
0010        delay_ms_00000
0010        ; { delay_ms ; function begin
0010  08D6  	MOVF delay_ms_00000_arg_del, F
0011  1D03  	BTFSS STATUS,Z
0012  2814  	GOTO	label1
0013  0008  	RETURN
0014        label1
0014  30F9  	MOVLW 0xF9
0015        label2
0015  0000  	NOP
0016  0000  	NOP
0017  0000  	NOP
0018  0000  	NOP
0019  0000  	NOP
001A  0000  	NOP
001B  0000  	NOP
001C  0000  	NOP
001D  0000  	NOP
001E  0000  	NOP
001F  0000  	NOP
0020  0000  	NOP
0021  0000  	NOP
0022  0000  	NOP
0023  0000  	NOP
0024  0000  	NOP
0025  3EFF  	ADDLW 0xFF
0026  1D03  	BTFSS STATUS,Z
0027  2815  	GOTO	label2
0028  0000  	NOP
0029  0000  	NOP
002A  0000  	NOP
002B  0000  	NOP
002C  0000  	NOP
002D  0000  	NOP
002E  0000  	NOP
002F  0000  	NOP
0030  0000  	NOP
0031  0000  	NOP
0032  0000  	NOP
0033  0000  	NOP
0034  0000  	NOP
0035  0000  	NOP
0036  0000  	NOP
0037  0000  	NOP
0038  0000  	NOP
0039  0BD6  	DECFSZ delay_ms_00000_arg_del, F
003A  2814  	GOTO	label1
003B  0008  	RETURN
003C        ; } delay_ms function end

003C        delay_10us_00000
003C        ; { delay_10us ; function begin
003C  08E9  	MOVF delay_10us_00000_arg_del, F
003D  1D03  	BTFSS STATUS,Z
003E  2840  	GOTO	label3
003F  0008  	RETURN
0040        label3
0040  3009  	MOVLW 0x09
0041        label4
0041  0000  	NOP
0042  3EFF  	ADDLW 0xFF
0043  1D03  	BTFSS STATUS,Z
0044  2841  	GOTO	label4
0045  0000  	NOP
0046  0000  	NOP
0047  0BE9  	DECFSZ delay_10us_00000_arg_del, F
0048  2840  	GOTO	label3
0049  0008  	RETURN
004A        ; } delay_10us function end

004A        delay_us_00000
004A        ; { delay_us ; function begin
004A        label5
004A  0000  	NOP
004B  0000  	NOP
004C  0BD2  	DECFSZ delay_us_00000_arg_del, F
004D  284A  	GOTO	label5
004E  0008  	RETURN
004F        ; } delay_us function end


005D        __div_16_1_00003
005D        ; { __div_16_16 ; function begin
005D  01DD  	CLRF __div_16_1_00003_1_r
005E  01DE  	CLRF __div_16_1_00003_1_r+D'1'
005F  01E0  	CLRF CompTempVarRet214
0060  01E1  	CLRF CompTempVarRet214+D'1'
0061  01DF  	CLRF __div_16_1_00003_1_i
0062        label7
0062  1A5F  	BTFSC __div_16_1_00003_1_i,4
0063  0008  	RETURN
0064  1003  	BCF STATUS,C
0065  0DE0  	RLF CompTempVarRet214, F
0066  0DE1  	RLF CompTempVarRet214+D'1', F
0067  0DD7  	RLF __div_16_1_00003_arg_a, F
0068  0DD8  	RLF __div_16_1_00003_arg_a+D'1', F
0069  0DDD  	RLF __div_16_1_00003_1_r, F
006A  0DDE  	RLF __div_16_1_00003_1_r+D'1', F
006B  085A  	MOVF __div_16_1_00003_arg_b+D'1', W
006C  025E  	SUBWF __div_16_1_00003_1_r+D'1', W
006D  1D03  	BTFSS STATUS,Z
006E  2871  	GOTO	label8
006F  0859  	MOVF __div_16_1_00003_arg_b, W
0070  025D  	SUBWF __div_16_1_00003_1_r, W
0071        label8
0071  1C03  	BTFSS STATUS,C
0072  287A  	GOTO	label9
0073  0859  	MOVF __div_16_1_00003_arg_b, W
0074  02DD  	SUBWF __div_16_1_00003_1_r, F
0075  085A  	MOVF __div_16_1_00003_arg_b+D'1', W
0076  1C03  	BTFSS STATUS,C
0077  03DE  	DECF __div_16_1_00003_1_r+D'1', F
0078  02DE  	SUBWF __div_16_1_00003_1_r+D'1', F
0079  1460  	BSF CompTempVarRet214,0
007A        label9
007A  0ADF  	INCF __div_16_1_00003_1_i, F
007B  2862  	GOTO	label7
007C        ; } __div_16_16 function end


0837        _startup
0837  30D5  	MOVLW 0xD5
0838  1283  	BCF STATUS, RP0
0839  1303  	BCF STATUS, RP1
083A  00E0  	MOVWF gbl_14_LSR
083B  30C4  	MOVLW 0xC4
083C  00E1  	MOVWF gbl_14_LSR+D'1'
083D  30BB  	MOVLW 0xBB
083E  00E2  	MOVWF gbl_14_LSR+D'2'
083F  30DC  	MOVLW 0xDC
0840  00E3  	MOVWF gbl_14_LSR+D'3'
0841  01E4  	CLRF gbl_15_gbl_aSig
0842  01E5  	CLRF gbl_15_gbl_aSig+D'1'
0843  01E6  	CLRF gbl_15_gbl_aSig+D'2'
0844  01E7  	CLRF gbl_15_gbl_aSig+D'3'
0845  01E8  	CLRF gbl_15_gbl_bSig
0846  01E9  	CLRF gbl_15_gbl_bSig+D'1'
0847  01EA  	CLRF gbl_15_gbl_bSig+D'2'
0848  01EB  	CLRF gbl_15_gbl_bSig+D'3'
0849  01EC  	CLRF gbl_15_gbl_zSig
084A  01ED  	CLRF gbl_15_gbl_zSig+D'1'
084B  01EE  	CLRF gbl_15_gbl_zSig+D'2'
084C  01EF  	CLRF gbl_15_gbl_zSig+D'3'
084D  01FC  	CLRF gbl_15_gbl_aExp
084E  01FD  	CLRF gbl_15_gbl_bExp
084F  01F7  	CLRF gbl_15_gbl_zExp
0850  01F8  	CLRF gbl_15_gbl_zExp+D'1'
0851  01FE  	CLRF gbl_15_gbl_aSign
0852  1683  	BSF STATUS, RP0
0853  01A0  	CLRF gbl_15_gbl_bSign
0854  01A1  	CLRF gbl_15_gbl_zSign
0855  01A2  	CLRF gbl_15_gbl_zSigZero
0856  1283  	BCF STATUS, RP0
0857  01F0  	CLRF gbl_15_gbl_ret
0858  01F1  	CLRF gbl_15_gbl_ret+D'1'
0859  01F2  	CLRF gbl_15_gbl_ret+D'2'
085A  01F3  	CLRF gbl_15_gbl_ret+D'3'
085B  01FA  	CLRF gbl_float_rounding_mode
085C  01FB  	CLRF gbl_float_exception_flags
085D  01F9  	CLRF gbl_float_detect_tininess

08A3  118A  	BCF PCLATH,3
08A4  120A  	BCF PCLATH,4
08A5  2F69  	GOTO	main

2007  3F32  	DW 0x3F32
