;/////////////////////////////////////////////////////////////////////////////////
;// Code Generator: BoostC Compiler - http://www.sourceboost.com
;// Version       : 7.03
;// License Type  : Pro License
;// Limitations   : PIC12,PIC16 max code size:Unlimited, max RAM banks:Unlimited
;/////////////////////////////////////////////////////////////////////////////////

/*********************************************************************
 *                  Flowcode CAL Delays File
 *
 * File: PIC_CAL_Delay.c
 *
 * (c) 2011 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * “Company”) for its Flowcode graphical programming language is
 * intended and supplied to you, the Company’s customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 010911 | BR | Created
 *
 *
 *
 */

//Original Byte Delays
void Wdt_Delay_S(char delay);
void Wdt_Delay_Ms(char delay);

//New Int Delays
void FCI_DELAYINT_US(MX_UINT16 Delay);

void FCI_DELAYINT_MS(MX_UINT16 Delay);
void FCI_DELAYINTWDT_MS(MX_UINT16 Delay);

void FCI_DELAYINT_S(MX_UINT16 Delay);
void FCI_DELAYINTWDT_S(MX_UINT16 Delay);


#ifdef HI_TECH_C

	#define nop()	asm("NOP")

	void delay_10us(char del);
	void delay_us(char del);
	void delay_ms(char del);
	void delay_s(char del);

	void delay_10us(char del)
	{
		char count;
		for(count=0; count<10; count++)
		{
			delay_us(del);
		}
	}

	void delay_us(char del)
	{
		while (del > 1)
		{
			__delay_us(1);
			del = del - 1;
		}
	}

	void delay_ms(char del)
	{
		while (del > 1)
		{
			__delay_ms(1);
			del = del - 1;
		}
	}

	void delay_s(char del)
	{
		char i;
		for(i=0; i<del; i++)
		{
			delay_ms(250);
			delay_ms(250);
			delay_ms(250);
			delay_ms(250);
		}
	}

#endif

void Wdt_Delay_S(char delay)
{
    char i;
    short j;
    for (i=0; i<delay; i++)
    {
        for (j=0; j<999; j++)
        {
            Wdt_Delay_Ms(1);
        }
    }
}

void Wdt_Delay_Ms(char delay)

{
    char i;
    for (i=0; i<delay; i++)
01F4  01B4  	CLRF Wdt_Delay__0003E_1_i
01F5        label29
01F5  0833  	MOVF Wdt_Delay__0003E_arg_delay, W
01F6  0234  	SUBWF Wdt_Delay__0003E_1_i, W
01F7  1803  	BTFSC STATUS,C
01FD  0AB4  	INCF Wdt_Delay__0003E_1_i, F
01FE  29F5  	GOTO	label29

    {
        MX_CLEAR_WATCHDOG;        //Clear Watchdog Timer
01F9  0064  	CLRWDT

        delay_ms(1);
01FA  3001  	MOVLW 0x01
01FB  00B5  	MOVWF delay_ms_00000_arg_del
01FC  2015  	CALL delay_ms_00000

    }
}
01F8  0008  	RETURN



void FCI_DELAYINT_US(MX_UINT16 Delay)
{
  	while (Delay > 255)
  	{
	  	delay_us(255);
	  	Delay = Delay - 255;
  	}
  	if (Delay > 0)
  		delay_us(Delay & 0xFF);
}

void FCI_DELAYINT_MS(MX_UINT16 Delay)
{
  	while (Delay > 255)
  	{
	  	delay_ms(255);
	  	Delay = Delay - 255;
  	}
  	if (Delay > 0)
  		delay_ms(Delay & 0xFF);
}

void FCI_DELAYINTWDT_MS(MX_UINT16 Delay)
{
  	while (Delay > 255)
  	{
	  	Wdt_Delay_Ms(255);
	  	Delay = Delay - 255;
  	}
  	if (Delay > 0)
  		Wdt_Delay_Ms(Delay & 0xFF);
}

void FCI_DELAYINT_S(MX_UINT16 Delay)
{
  	while (Delay > 255)
  	{
	  	delay_s(255);
	  	Delay = Delay - 255;
  	}
  	if (Delay > 0)
  		delay_s(Delay & 0xFF);
}

void FCI_DELAYINTWDT_S(MX_UINT16 Delay)
{
  	while (Delay > 255)
  	{
	  	Wdt_Delay_S(255);
	  	Delay = Delay - 255;
  	}
  	if (Delay > 0)
  		Wdt_Delay_S(Delay & 0xFF);
}



/*********************************************************************
 *                  Flowcode CAL String File
 *
 * File: PIC_CAL_String.c
 *
 * (c) 2011 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * “Company”) for its Flowcode graphical programming language is
 * intended and supplied to you, the Company’s customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 010911 | BR | Created
 * 150911 | JW | Added v5 string functions
 * 270212 | BR | Fixed an issue with ToUpper where the 1st character was being returned as null
 * 120312 | BR | Fixed an issue with some of the float functions not using CAL functions
 */


// Useful call for finding the length of an (uncorrupted) string
#define FCI_GETLENGTH__x(str, max, idx)         for (idx = 0; idx < max; idx++) if (str[idx] == 0) break
#define FCI_STRMOV__x(str, max, dst, dlen, ix)  for (ix = 0; ix < (max) && ix < (dlen) && str[ix] != '\0'; ix++) dst[ix] = str[ix]
#define FCI_CONCATENATE(s0, l0, s1, l1, sd, ld) FCI_SHEAD(s0, l0, s1, l1, sd, ld)


#ifndef MX_USES_UINT32
	#define MX_USES_UINT32 0
#endif
#ifndef MX_USES_SINT32
	#define MX_USES_SINT32 0
#endif


#if (MX_USES_UINT32 || MX_USES_SINT32)
	#define MX_STRF_LONG
	#define MX_ULONG MX_UINT32
	#define MX_SLONG MX_SINT32
#else
	#define MX_ULONG MX_UINT16
	#define MX_SLONG MX_SINT16
#endif


//String function definitions
MX_UINT8 FCI_GETCHAR(MX_STRING sStr1, MX_UINT8 iStr1_len, MX_UINT8 iPos);
MX_UINT8 FCI_GETLENGTH(MX_STRING sStr1, MX_UINT8 iStr1_len);
MX_UINT8 FCI_MIDSTRING(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_UINT8 iStart, MX_UINT8 iCount, MX_STRING sDst, MX_UINT8 iDst_len);
MX_UINT8 FCI_LEFTSTRING(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_UINT8 iCount, MX_STRING sDst, MX_UINT8 iDst_len);
MX_UINT8 FCI_RIGHTSTRING(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_UINT8 iCount, MX_STRING sDst, MX_UINT8 iDst_len);
MX_UINT8 FCI_TOSTRING(MX_SLONG iSrc1, MX_STRING sDst, MX_UINT8 iDst_len);
void FCI_TOLOWER(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len);
void FCI_TOUPPER(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len);
MX_UINT8 FCI_COMPARE(MX_STRING sSrc1, MX_UINT8 iSrc1_len, MX_STRING sSrc2, MX_UINT8 iSrc2_len, MX_UINT8 iNoCase);
MX_UINT8 FCI_FLOAT_TO_STRING(MX_FLOAT Number, MX_UINT8 Precision, MX_STRING String, MX_UINT8 MSZ_String);
MX_UINT8 FCI_NUMBER_TO_HEX(MX_ULONG Number, MX_STRING String, MX_UINT8 MSZ_String);
MX_SINT32 FCI_STRING_TO_INT(MX_STRING String, MX_UINT8 MSZ_String);
MX_FLOAT FCI_STRING_TO_FLOAT(MX_STRING String, MX_UINT8 MSZ_String);

// Functions for contatenation
MX_UINT8 FCI_STRREV(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len);
MX_UINT8 FCI_STRMOV(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len);
void FCI_SHEAD(MX_STRING sSrc1, MX_UINT8 iSrc1_len, MX_STRING sSrc2, MX_UINT8 iSrc2_len, MX_STRING sDst, MX_UINT8 iDst_len);
void FCI_SCOPY(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len);



MX_UINT8 FCI_GETCHAR(MX_STRING sStr1, MX_UINT8 iStr1_len, MX_UINT8 iPos)
{
	MX_UINT8 tmp;
	FCI_GETLENGTH__x(sStr1, iStr1_len, tmp);

	if(iPos < tmp)
		return sStr1[iPos];
	return '\0';
}

MX_UINT8 FCI_GETLENGTH(MX_STRING sStr1, MX_UINT8 iStr1_len)
{
	MX_UINT8 tmp;
	FCI_GETLENGTH__x(sStr1, iStr1_len, tmp);
	return (tmp);
}

MX_UINT8 FCI_MIDSTRING(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_UINT8 iStart, MX_UINT8 iCount, MX_STRING sDst, MX_UINT8 iDst_len)
{
	if (iDst_len == 0) return 0;
	MX_UINT8 idx;
	FCI_GETLENGTH__x(sSrc, iSrc_len, idx);	//find the length of the source string

	if (iStart >= idx)
	{
		*sDst = '\0';						//starting position is beyond string length, so return a null string
	}
	else
	{
		if ((iStart + iCount) >= idx)		//Make sure the required length is not too big
			iCount = idx - iStart;
		if (iCount > (iDst_len))			//make sure the required length is not too big
			iCount = (iDst_len);

		sSrc += iStart;						//Move to the correct place in the source string

		for (idx = 0; idx < iCount; idx++)	//Copy the contents of the source string
		{
			*sDst = *sSrc;
			sDst++;
			sSrc++;
		}
		if (idx < iDst_len)						//add terminating null (if we can)
			*sDst = '\0';
	}
	return (idx);
}

MX_UINT8 FCI_LEFTSTRING(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_UINT8 iCount, MX_STRING sDst, MX_UINT8 iDst_len)
{
	if (iDst_len == 0) return 0;
	MX_UINT8 idx;
	FCI_GETLENGTH__x(sSrc, iSrc_len, idx);	//find the length of the source string

	if (iCount > idx)						//make sure the required length is not too big
		iCount = idx;
	if (iCount > (iDst_len))			//make sure the required length is not too big
		iCount = (iDst_len);

	for (idx = 0; idx < iCount; idx++)		//copy the required MX_UINT8acters
	{
		*sDst = *sSrc;
		sDst++;
		sSrc++;
	}
	if (idx < iDst_len)						//add terminating null (if we can)
		*sDst = '\0';
	return (idx);
}

MX_UINT8 FCI_RIGHTSTRING(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_UINT8 iCount, MX_STRING sDst, MX_UINT8 iDst_len)
{
	if (iDst_len == 0) return 0;
	MX_UINT8 idx;
	MX_UINT8 delta;

	FCI_GETLENGTH__x(sSrc, iSrc_len, idx);	//find the length of the source string

	if (iCount > idx)						//make sure the required length is not too big
		iCount = idx;
	delta = idx - iCount;					//get the offset
	if (iCount > (iDst_len))				//make sure the required length is not too big
		iCount = (iDst_len);
	sSrc += delta;							//Move to the correct place in the source string

	for(idx = 0; idx < iCount; idx++)		//copy the required MX_UINT8acters
	{
		*sDst = *sSrc;
		sDst++;
		sSrc++;
	}
	if (idx < iDst_len)						//add terminating null (if we can)
		*sDst = '\0';
	return (idx);
}

MX_UINT8 FCI_TOSTRING(MX_SLONG iSrc1, MX_STRING sDst, MX_UINT8 iDst_len)
{
	if (iDst_len == 0) return 0;
	MX_UINT8 tmp1;

	#ifdef MX_STRF_LONG
		unsigned long top = 1000000000; 	// Maximum power of 10 less than 4294967296
	#else
		unsigned short top = 10000; 		// Maximum power of 10 less than 65536
	#endif

	MX_UINT8 idx = 0;

	//copy source 1 into destination:
	//minus sign
	if (iSrc1 < 0)
	{
		sDst[0] = '-';
		idx++;
		iSrc1 = -iSrc1;
	}

	tmp1 = 0;    // Nothing added yet
	if (iSrc1 == 0) // Force showing zero
	{
		tmp1 = 1;
		top = 1;
	}
	while (( idx < iDst_len) && (top > 0))
	{
		#ifdef MX_STRF_LONG
		if (((unsigned long)iSrc1 >= top) || (tmp1))
		#else
		if (((unsigned)iSrc1 >= top) || (tmp1))
		#endif
		{
			#ifdef MX_STRF_LONG
			tmp1 = (unsigned long)iSrc1 / top;	// Top digit
			#else
			tmp1 = (unsigned)iSrc1 / top;	// Top digit
			#endif
			sDst[idx] = '0' + tmp1;			// Add digit to buffer
			idx++;
			iSrc1 -= tmp1 * top;			// Remove digit
			tmp1 = 1;						// Add zeros now
		}
		top /= 10;							// Go to next digit
	}

	if (idx < iDst_len)						//add terminating null (if we can)
		sDst[idx] = '\0';
	return (idx);
}



void FCI_TOLOWER(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len)
{
	if (iDst_len == 0) return;
	MX_UINT8 idx;
	MX_UINT8 ch;

	if (iSrc_len < iDst_len) iSrc_len = iDst_len; // Bound so cant overflow dest
	//copy source into destination and change to lower case
	for (idx=0; idx<iSrc_len; idx++)
	{
		ch = sSrc[idx];
		if ((ch >= 'A') && (ch <= 'Z'))
		{
			ch ^= 0x20;
		}
		sDst[idx] = ch;
		if (ch == 0)
		{
			break;
		}
	}
	if (idx < iDst_len)						//add terminating null (if we can)
		sDst[idx] = '\0';
}

void FCI_TOUPPER(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len)
{
	if (iDst_len == 0) return;
	MX_UINT8 idx;
	MX_UINT8 ch;

	if (iSrc_len < iDst_len) iSrc_len = iDst_len; // Bound so cant overflow dest
	//copy source into destination and change to upper case
	for (idx=0; idx<iSrc_len; idx++)
	{
		ch = sSrc[idx];
		if ((ch >= 'a') && (ch <= 'z'))
		{
			ch ^= 0x20;
		}
		sDst[idx] = ch;
		if (ch == 0)
		{
			break;
		}
	}
	if (idx < iDst_len)						//add terminating null (if we can)
		sDst[idx] = '\0';
}

MX_UINT8 FCI_COMPARE(MX_STRING sSrc1, MX_UINT8 iSrc1_len, MX_STRING sSrc2, MX_UINT8 iSrc2_len, MX_UINT8 iNoCase)
{
	MX_UINT8 iRetVal = 0;
	MX_UINT8 idx;
	MX_UINT8 ch1, ch2;

	for (idx=0; idx < iSrc1_len; idx++)	//compare a byte from the strings
	{
		if (idx < iSrc2_len)
		{
			ch1 = *sSrc1;
			ch2 = *sSrc2;

			if (iNoCase)
			{
				if ((ch1 >= 'a') && (ch1 <= 'z'))
					ch1 = (ch1 & 0xDF);

				if ((ch2 >= 'a') && (ch2 <= 'z'))
					ch2 = (ch2 & 0xDF);

			}

			if (ch1 < ch2)
			{
				return(255);
			}
			else if (ch1 > ch2)
			{
				return(1);
			}

			sSrc1++;
			sSrc2++;
		}
		else
		{
			if (*sSrc1 == 0)
				return (0);				//end of source1 as well, so ok
			else
				return (1);				//reached the end of iSrc2, but still more of iSrc1
		}
	}

	if (iSrc1_len == iSrc2_len)			//reached the end of iSrc1.  If we're also at the end of iSrc2, then return 0
		return (0);
	else
	{
		if (*sSrc2 == 0)
			return (0);					//end of source1 as well, so ok
		else
			return (255);				//not at end of source2, so return -1
	}
}


MX_UINT8 FCI_FLOAT_TO_STRING(MX_FLOAT Number, MX_UINT8 Precision, MX_STRING String, MX_UINT8 MSZ_String)
{
	MX_SINT16 whole;
	MX_UINT8 str_length;
	MX_UINT8 idx;
	MX_UINT8 stringidx = 0;
	MX_FLOAT real, temp;
	MX_UINT8 old;
	MX_UINT8 temp_string[10];

	#ifdef _BOOSTC									//BoostC Floating Point

		float_rounding_mode = 3;					//Always round to zero
		whole = float32_to_int32(Number);			//Convert to whole integer
		temp = float32_from_int32(whole);			//Convert whole number back to floating point

		if (float32_ge(Number,0))
		{
			real = float32_sub(Number, temp);		//Subtract whole number from floating point number
		}
		else
		{
			if (whole == 0)							//Fix -0 bug
			{
				String[stringidx] = '-';
				stringidx = stringidx + 1;
			}

			real = float32_sub(temp, Number);		//Subtract floating point number from whole number
		}
	#endif

	#ifdef HI_TECH_C								//HiTECH Floating Point

		whole = (int)Number;						//Convert to whole integer
		temp = whole;								//Convert whole number back to floating point

		if (Number >= 0)
		{
			real = Number - temp;					//Subtract whole number from floating point number
		}
		else
		{
			if (whole == 0)							//Fix -0 bug
			{
				String[stringidx] = '-';
				stringidx = stringidx + 1;
			}

			real = temp - Number;					//Subtract floating point number from whole number
		}
	#endif

	str_length = FCI_TOSTRING(whole, temp_string, 5);		//Convert integer numbers to strings

	for (idx=0; idx<str_length; idx++)						//Copy whole part of number to string
	{
		if(stringidx < MSZ_String)
		{
			String[stringidx] = temp_string[idx];
			stringidx = stringidx + 1;
		}
	}

	if(stringidx < MSZ_String)						//Add decimal point to string
	{
		String[stringidx] = '.';
		stringidx = stringidx + 1;
	}

	for (idx = 0; idx < Precision; idx++)			//Output Real Part Of Number
	{
		if (stringidx >= MSZ_String)
			break;

		#ifdef _BOOSTC								//BoostC Floating Point
			real = float32_mul(real, 10);
			whole = float32_to_int32(real);			//Convert to whole integer
			temp = float32_from_int32(whole);		//Convert whole number back to floating point
			real = float32_sub(real, temp);			//Subtract whole number from floating point number
		#endif
		#ifdef HI_TECH_C							//HiTECH Floating Point
			real = real * 10;
			whole = (int)real;						//Convert to whole integer
			temp = whole;							//Convert whole number back to floating point
			real = real - temp;						//Subtract whole number from floating point number
		#endif

		String[stringidx] = '0' + whole;
		stringidx = stringidx + 1;
	}

	if(stringidx < MSZ_String)									//Add null termination to string
	{
		String[stringidx] = 0;
	}

	return stringidx;
}











MX_UINT8 FCI_NUMBER_TO_HEX(MX_ULONG Number, MX_STRING String, MX_UINT8 MSZ_String)
{
	MX_UINT8 stringidx;
	MX_UINT8 idx = 0;
	MX_UINT8 temp;
	MX_UINT8 digit[8] = {0,0,0,0,0,0,0,0};

	#ifdef MX_STRF_LONG
		MX_UINT32 num = Number;
	#else
		MX_UINT16 num = Number;
	#endif

	//Check that output string is long enough to store result
	if((Number > 0xFFFF) && (MSZ_String < 10))
		return 0;

	if((Number > 0xFF) && (MSZ_String < 6))
		return 0;

	if((Number <= 0xFF) && (MSZ_String < 4))
		return 0;

	//Initialise start of string with hexadecimal indicator
	String[0] = '0';
	String[1] = 'x';

	//Calculate hex values
	do
	{
		temp = num % 16;
		num = num >> 4;

		if(temp > 9)
		{
			temp = temp - 10;
			digit[idx] = temp + 'A';
		}
		else
			digit[idx] = temp + '0';

		idx = idx + 1;
	} while (num > 0);

	//Copy Hex values over to output string
	for (stringidx = 2; stringidx < (idx + 2); stringidx++)
		String[stringidx] = digit[idx - (stringidx - 1)];

	//Add null termination to string
	if(stringidx < MSZ_String)
	{
		String[stringidx] = 0;
	}

	return stringidx;
}


MX_SINT32 FCI_STRING_TO_INT(MX_STRING String, MX_UINT8 MSZ_String)
{
	MX_UINT8 bNegative = 0;
	MX_UINT8 idx = 0;
	MX_SINT32 RetVal = 0;

	//Is number negative
	if(String[0] == '-')
	{
		bNegative = 1;
		idx = 1;
	}

	//While string contains a valid number
	while (idx < MSZ_String && String[idx] >= '0' && String[idx] <= '9')
	{
		//Pull MX_UINT8acter from string and add to running total
		RetVal = (long) RetVal * 10;
		RetVal = (long) RetVal + (String[idx] - '0');
		idx = idx + 1;
	}

	if (bNegative)
		RetVal = (long) 0 - RetVal;

	return RetVal;
}


MX_FLOAT FCI_STRING_TO_FLOAT(MX_STRING String, MX_UINT8 MSZ_String)
{
	MX_FLOAT RetVal = 0;
	MX_FLOAT real_divider = 1;
	MX_UINT32 whole, real;			//Changed from INT 23/07/10
	MX_UINT8 idx = 0;
	MX_UINT8 idx2 = 0;
	MX_UINT8 offset = 0;
	MX_UINT8 bNegative = 0;
	MX_UINT8 Comp_String[8];

	//Is number negative
	if(String[0] == '-')
	{
		bNegative = 1;
		offset = 1;
	}

	//Scan for decimal point
	for(idx=offset; idx<MSZ_String; idx++)
	{
		if(String[idx] == '.')
			break;
	}

	//Convert whole portion of number from string
	whole = FCI_STRING_TO_INT (String, idx);

	//No decimal point found
	if(idx == MSZ_String)
	{
		#ifdef _BOOSTC
			RetVal = float32_from_int32(whole);
		#endif
		#ifdef HI_TECH_C
			RetVal = (int)whole;
		#endif
		return RetVal;
	}

	//Collect real portion of number into new string
	offset = idx + 1;
	for(idx=offset; idx<MSZ_String; idx++)
	{
		if(String[idx] >= '0' && String[idx] <= '9')
		{
			Comp_String[idx - offset] = String[idx];
			#ifdef _BOOSTC
				real_divider = float32_mul(real_divider, 0.1);
			#endif
			#ifdef HI_TECH_C
				real_divider = real_divider * 0.1;
			#endif
		}
		else
			break;
	}

	//Convert real portion of number from string
	real = FCI_STRING_TO_INT (Comp_String, (idx - offset));

	//Adjust weighting of values and combine into one float variable
	#ifdef _BOOSTC

		RetVal = float32_from_int32(real);
		RetVal = float32_mul(RetVal, real_divider);
		real_divider = float32_from_int32(whole);
		RetVal = float32_add(RetVal, real_divider);

		if (bNegative)
			RetVal = float32_sub(0, RetVal);

	#endif
	#ifdef HI_TECH_C

		RetVal = (MX_FLOAT)real;
		RetVal = RetVal * real_divider;
		real_divider = (MX_FLOAT)whole;
		RetVal = RetVal + real_divider;

		if (bNegative)
			RetVal = 0 - RetVal;
	#endif

	return RetVal;
}



/*=----------------------------------------------------------------------=*\
   Use :Move but do not null-terminate sSrc to sDst, max len iSrc_len
       :This differs from FCI_STRMOV() in that the bytes are copied from the
       :end of the string to the start
       :Returns length of copy
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCI_STRREV(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len)
{
  MX_UINT8 ix, len;
  FCI_GETLENGTH__x(sSrc, iSrc_len, len);
  if (len > iDst_len)
  {
    len = iDst_len;
  }
  ix = len;
  while (ix > 0)
  {
    ix--;
    sDst[ix] = sSrc[ix];
  }
  // No null terminate
  // Return length of string
  return len;
}


/*=----------------------------------------------------------------------=*\
   Use :Move but do not null-terminate sSrc to sDst, max len iSrc_len
       :Returns length of copy
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCI_STRMOV(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len)
{
  MX_UINT8 ix;
  ix = 0;
  while (ix < iSrc_len && ix < iDst_len && sSrc[ix] != '\0')
  {
    sDst[ix] = sSrc[ix];
    ix++;
  }
  // No null terminate
  // Return length of string
  return ix;
}

/*=----------------------------------------------------------------------=*\
   Use :Concatenate sDst = (sSrc1 + sSrc2)
       :sDst is only null terminated if the concat doesnt overflow
       :
\*=----------------------------------------------------------------------=*/
void FCI_SHEAD(MX_STRING sSrc1, MX_UINT8 iSrc1_len, MX_STRING sSrc2, MX_UINT8 iSrc2_len, MX_STRING sDst, MX_UINT8 iDst_len)

{
  MX_UINT8 len, strt;

  len = 0;
008B  01BA  	CLRF FCI_SHEAD_00000_1_len

  if (sSrc2 == sDst)
008C  0837  	MOVF FCI_SHEAD_00000_arg_sDst, W
008D  0634  	XORWF FCI_SHEAD_00000_arg_sSrc2, W
008E  1D03  	BTFSS STATUS,Z
008F  2932  	GOTO	label18
0090  0838  	MOVF FCI_SHEAD_00000_arg_sDst+D'1', W
0091  0635  	XORWF FCI_SHEAD_00000_arg_sSrc2+D'1', W
0092  1D03  	BTFSS STATUS,Z
0093  2932  	GOTO	label18
0132        label18

  {
    FCI_GETLENGTH__x(sSrc1, iSrc1_len, strt);
0094  01BB  	CLRF FCI_SHEAD_00000_1_strt
0095        label7
0095  0833  	MOVF FCI_SHEAD_00000_arg_iSrc1_len, W
0096  023B  	SUBWF FCI_SHEAD_00000_1_strt, W
0097  1803  	BTFSC STATUS,C
0098  28A4  	GOTO	label8
0099  1383  	BCF STATUS,IRP
009A  1832  	BTFSC FCI_SHEAD_00000_arg_sSrc1+D'1',0
009B  1783  	BSF STATUS,IRP
009C  0831  	MOVF FCI_SHEAD_00000_arg_sSrc1, W
009D  073B  	ADDWF FCI_SHEAD_00000_1_strt, W
009E  0084  	MOVWF FSR
009F  0880  	MOVF INDF, F
00A0  1903  	BTFSC STATUS,Z
00A1  28A4  	GOTO	label8
00A2  0ABB  	INCF FCI_SHEAD_00000_1_strt, F
00A3  2895  	GOTO	label7
00A4        label8
0131  290C  	GOTO	label17

    if (strt < iDst_len)
00A4  0839  	MOVF FCI_SHEAD_00000_arg_iDst_len, W
00A5  023B  	SUBWF FCI_SHEAD_00000_1_strt, W
00A6  1803  	BTFSC STATUS,C
00A7  290B  	GOTO	label16
010B        label16

    {
      // Copy second, in reverse
      // len = FCI_STRREV(sSrc2, iSrc2_len, sDst + strt, iDst_len - strt);
      FCI_GETLENGTH__x(sSrc2, iSrc2_len, len);
00A8  01BA  	CLRF FCI_SHEAD_00000_1_len
00A9        label9
00A9  0836  	MOVF FCI_SHEAD_00000_arg_iSrc2_len, W
00AA  023A  	SUBWF FCI_SHEAD_00000_1_len, W
00AB  1803  	BTFSC STATUS,C
00AC  28B8  	GOTO	label10
00AD  1383  	BCF STATUS,IRP
00AE  1835  	BTFSC FCI_SHEAD_00000_arg_sSrc2+D'1',0
00AF  1783  	BSF STATUS,IRP
00B0  0834  	MOVF FCI_SHEAD_00000_arg_sSrc2, W
00B1  073A  	ADDWF FCI_SHEAD_00000_1_len, W
00B2  0084  	MOVWF FSR
00B3  0880  	MOVF INDF, F
00B4  1903  	BTFSC STATUS,Z
00B5  28B8  	GOTO	label10
00B6  0ABA  	INCF FCI_SHEAD_00000_1_len, F
00B7  28A9  	GOTO	label9
00B8        label10

      if (len > (iDst_len - strt))
00B8  083B  	MOVF FCI_SHEAD_00000_1_strt, W
00B9  0239  	SUBWF FCI_SHEAD_00000_arg_iDst_len, W
00BA  00BC  	MOVWF CompTempVar2110
00BB  083A  	MOVF FCI_SHEAD_00000_1_len, W
00BC  023C  	SUBWF CompTempVar2110, W
00BD  1803  	BTFSC STATUS,C
00BE  28C2  	GOTO	label11
00C2        label11

      {
        len = (iDst_len - strt); // Length of string to copy to
00BF  083B  	MOVF FCI_SHEAD_00000_1_strt, W
00C0  0239  	SUBWF FCI_SHEAD_00000_arg_iDst_len, W
00C1  00BA  	MOVWF FCI_SHEAD_00000_1_len

      }
      iSrc2_len = strt + len; // Use no longer needed var as an offset
00C2  083A  	MOVF FCI_SHEAD_00000_1_len, W
00C3  073B  	ADDWF FCI_SHEAD_00000_1_strt, W
00C4  00B6  	MOVWF FCI_SHEAD_00000_arg_iSrc2_len

      strt = len;
00C5  083A  	MOVF FCI_SHEAD_00000_1_len, W
00C6  00BB  	MOVWF FCI_SHEAD_00000_1_strt

      while (strt > 0)
00C7        label12
00C7  083B  	MOVF FCI_SHEAD_00000_1_strt, W
00C8  3C00  	SUBLW 0x00
00C9  1803  	BTFSC STATUS,C
00CA  28E1  	GOTO	label13
00E0  28C7  	GOTO	label12
00E1        label13

      {
        strt--;
00CB  03BB  	DECF FCI_SHEAD_00000_1_strt, F

        iSrc2_len--;
00CC  03B6  	DECF FCI_SHEAD_00000_arg_iSrc2_len, F

        sDst[iSrc2_len] = sSrc2[strt];
00CD  1383  	BCF STATUS,IRP
00CE  1835  	BTFSC FCI_SHEAD_00000_arg_sSrc2+D'1',0
00CF  1783  	BSF STATUS,IRP
00D0  0834  	MOVF FCI_SHEAD_00000_arg_sSrc2, W
00D1  0084  	MOVWF FSR
00D2  083B  	MOVF FCI_SHEAD_00000_1_strt, W
00D3  00BD  	MOVWF CompTempVar2117
00D4  083D  	MOVF CompTempVar2117, W
00D5  0784  	ADDWF FSR, F
00D6  0800  	MOVF INDF, W
00D7  00BE  	MOVWF CompTempVar2118
00D8  1383  	BCF STATUS,IRP
00D9  1838  	BTFSC FCI_SHEAD_00000_arg_sDst+D'1',0
00DA  1783  	BSF STATUS,IRP
00DB  0837  	MOVF FCI_SHEAD_00000_arg_sDst, W
00DC  0736  	ADDWF FCI_SHEAD_00000_arg_iSrc2_len, W
00DD  0084  	MOVWF FSR
00DE  083E  	MOVF CompTempVar2118, W
00DF  0080  	MOVWF INDF

      }
      // Move first
      FCI_STRMOV__x(sSrc1, iSrc1_len, sDst, iDst_len, strt);
00E1  01BB  	CLRF FCI_SHEAD_00000_1_strt
00E2        label14
00E2  0833  	MOVF FCI_SHEAD_00000_arg_iSrc1_len, W
00E3  023B  	SUBWF FCI_SHEAD_00000_1_strt, W
00E4  1803  	BTFSC STATUS,C
00E5  2908  	GOTO	label15
00E6  0839  	MOVF FCI_SHEAD_00000_arg_iDst_len, W
00E7  023B  	SUBWF FCI_SHEAD_00000_1_strt, W
00E8  1803  	BTFSC STATUS,C
00E9  2908  	GOTO	label15
00EA  1383  	BCF STATUS,IRP
00EB  1832  	BTFSC FCI_SHEAD_00000_arg_sSrc1+D'1',0
00EC  1783  	BSF STATUS,IRP
00ED  0831  	MOVF FCI_SHEAD_00000_arg_sSrc1, W
00EE  073B  	ADDWF FCI_SHEAD_00000_1_strt, W
00EF  0084  	MOVWF FSR
00F0  0880  	MOVF INDF, F
00F1  1903  	BTFSC STATUS,Z
00F2  2908  	GOTO	label15
00F3  1383  	BCF STATUS,IRP
00F4  1832  	BTFSC FCI_SHEAD_00000_arg_sSrc1+D'1',0
00F5  1783  	BSF STATUS,IRP
00F6  0831  	MOVF FCI_SHEAD_00000_arg_sSrc1, W
00F7  0084  	MOVWF FSR
00F8  083B  	MOVF FCI_SHEAD_00000_1_strt, W
00F9  00BD  	MOVWF CompTempVar2121
00FA  083D  	MOVF CompTempVar2121, W
00FB  0784  	ADDWF FSR, F
00FC  0800  	MOVF INDF, W
00FD  00BE  	MOVWF CompTempVar2122
00FE  1383  	BCF STATUS,IRP
00FF  1838  	BTFSC FCI_SHEAD_00000_arg_sDst+D'1',0
0100  1783  	BSF STATUS,IRP
0101  0837  	MOVF FCI_SHEAD_00000_arg_sDst, W
0102  073B  	ADDWF FCI_SHEAD_00000_1_strt, W
0103  0084  	MOVWF FSR
0104  083E  	MOVF CompTempVar2122, W
0105  0080  	MOVWF INDF
0106  0ABB  	INCF FCI_SHEAD_00000_1_strt, F
0107  28E2  	GOTO	label14
0108        label15

      len += strt;
0108  083B  	MOVF FCI_SHEAD_00000_1_strt, W
0109  07BA  	ADDWF FCI_SHEAD_00000_1_len, F

    }
    else
010A  2994  	GOTO	label23

    {
      // Copy first
      FCI_STRMOV__x(sSrc1, iSrc1_len, sDst, iDst_len, len);
010B  01BA  	CLRF FCI_SHEAD_00000_1_len
010C        label17
010C  0833  	MOVF FCI_SHEAD_00000_arg_iSrc1_len, W
010D  023A  	SUBWF FCI_SHEAD_00000_1_len, W
010E  1803  	BTFSC STATUS,C
010F  2994  	GOTO	label23
0110  0839  	MOVF FCI_SHEAD_00000_arg_iDst_len, W
0111  023A  	SUBWF FCI_SHEAD_00000_1_len, W
0112  1803  	BTFSC STATUS,C
0113  2994  	GOTO	label23
0114  1383  	BCF STATUS,IRP
0115  1832  	BTFSC FCI_SHEAD_00000_arg_sSrc1+D'1',0
0116  1783  	BSF STATUS,IRP
0117  0831  	MOVF FCI_SHEAD_00000_arg_sSrc1, W
0118  073A  	ADDWF FCI_SHEAD_00000_1_len, W
0119  0084  	MOVWF FSR
011A  0880  	MOVF INDF, F
011B  1903  	BTFSC STATUS,Z
011C  2994  	GOTO	label23
011D  1383  	BCF STATUS,IRP
011E  1832  	BTFSC FCI_SHEAD_00000_arg_sSrc1+D'1',0
011F  1783  	BSF STATUS,IRP
0120  0831  	MOVF FCI_SHEAD_00000_arg_sSrc1, W
0121  0084  	MOVWF FSR
0122  083A  	MOVF FCI_SHEAD_00000_1_len, W
0123  00BC  	MOVWF CompTempVar2129
0124  083C  	MOVF CompTempVar2129, W
0125  0784  	ADDWF FSR, F
0126  0800  	MOVF INDF, W
0127  00BD  	MOVWF CompTempVar2130
0128  1383  	BCF STATUS,IRP
0129  1838  	BTFSC FCI_SHEAD_00000_arg_sDst+D'1',0
012A  1783  	BSF STATUS,IRP
012B  0837  	MOVF FCI_SHEAD_00000_arg_sDst, W
012C  073A  	ADDWF FCI_SHEAD_00000_1_len, W
012D  0084  	MOVWF FSR
012E  083D  	MOVF CompTempVar2130, W
012F  0080  	MOVWF INDF
0130  0ABA  	INCF FCI_SHEAD_00000_1_len, F

    }
  }
  else
  {
    // Copy first
    FCI_STRMOV__x(sSrc1, iSrc1_len, sDst, iDst_len, len);
0132  01BA  	CLRF FCI_SHEAD_00000_1_len
0133        label19
0133  0833  	MOVF FCI_SHEAD_00000_arg_iSrc1_len, W
0134  023A  	SUBWF FCI_SHEAD_00000_1_len, W
0135  1803  	BTFSC STATUS,C
0136  2959  	GOTO	label20
0137  0839  	MOVF FCI_SHEAD_00000_arg_iDst_len, W
0138  023A  	SUBWF FCI_SHEAD_00000_1_len, W
0139  1803  	BTFSC STATUS,C
013A  2959  	GOTO	label20
013B  1383  	BCF STATUS,IRP
013C  1832  	BTFSC FCI_SHEAD_00000_arg_sSrc1+D'1',0
013D  1783  	BSF STATUS,IRP
013E  0831  	MOVF FCI_SHEAD_00000_arg_sSrc1, W
013F  073A  	ADDWF FCI_SHEAD_00000_1_len, W
0140  0084  	MOVWF FSR
0141  0880  	MOVF INDF, F
0142  1903  	BTFSC STATUS,Z
0143  2959  	GOTO	label20
0144  1383  	BCF STATUS,IRP
0145  1832  	BTFSC FCI_SHEAD_00000_arg_sSrc1+D'1',0
0146  1783  	BSF STATUS,IRP
0147  0831  	MOVF FCI_SHEAD_00000_arg_sSrc1, W
0148  0084  	MOVWF FSR
0149  083A  	MOVF FCI_SHEAD_00000_1_len, W
014A  00BC  	MOVWF CompTempVar2137
014B  083C  	MOVF CompTempVar2137, W
014C  0784  	ADDWF FSR, F
014D  0800  	MOVF INDF, W
014E  00BD  	MOVWF CompTempVar2138
014F  1383  	BCF STATUS,IRP
0150  1838  	BTFSC FCI_SHEAD_00000_arg_sDst+D'1',0
0151  1783  	BSF STATUS,IRP
0152  0837  	MOVF FCI_SHEAD_00000_arg_sDst, W
0153  073A  	ADDWF FCI_SHEAD_00000_1_len, W
0154  0084  	MOVWF FSR
0155  083D  	MOVF CompTempVar2138, W
0156  0080  	MOVWF INDF
0157  0ABA  	INCF FCI_SHEAD_00000_1_len, F
0158  2933  	GOTO	label19
0159        label20

    // Copy second
    if (len < iDst_len)
0159  0839  	MOVF FCI_SHEAD_00000_arg_iDst_len, W
015A  023A  	SUBWF FCI_SHEAD_00000_1_len, W
015B  1803  	BTFSC STATUS,C
015C  2994  	GOTO	label23
0194        label23

    {
      sSrc1 = sDst + len; // make temp copies in no longer used variables
015D  083A  	MOVF FCI_SHEAD_00000_1_len, W
015E  0737  	ADDWF FCI_SHEAD_00000_arg_sDst, W
015F  00BC  	MOVWF CompTempVar2143
0160  0838  	MOVF FCI_SHEAD_00000_arg_sDst+D'1', W
0161  00BD  	MOVWF CompTempVar2144
0162  1803  	BTFSC STATUS,C
0163  0ABD  	INCF CompTempVar2144, F
0164  083C  	MOVF CompTempVar2143, W
0165  00B1  	MOVWF FCI_SHEAD_00000_arg_sSrc1
0166  083D  	MOVF CompTempVar2144, W
0167  00B2  	MOVWF FCI_SHEAD_00000_arg_sSrc1+D'1'

      iSrc1_len = iDst_len - len;
0168  083A  	MOVF FCI_SHEAD_00000_1_len, W
0169  0239  	SUBWF FCI_SHEAD_00000_arg_iDst_len, W
016A  00B3  	MOVWF FCI_SHEAD_00000_arg_iSrc1_len

      FCI_STRMOV__x(sSrc2, iSrc2_len, sSrc1, iSrc1_len, strt);
016B  01BB  	CLRF FCI_SHEAD_00000_1_strt
016C        label21
016C  0836  	MOVF FCI_SHEAD_00000_arg_iSrc2_len, W
016D  023B  	SUBWF FCI_SHEAD_00000_1_strt, W
016E  1803  	BTFSC STATUS,C
016F  2992  	GOTO	label22
0170  0833  	MOVF FCI_SHEAD_00000_arg_iSrc1_len, W
0171  023B  	SUBWF FCI_SHEAD_00000_1_strt, W
0172  1803  	BTFSC STATUS,C
0173  2992  	GOTO	label22
0174  1383  	BCF STATUS,IRP
0175  1835  	BTFSC FCI_SHEAD_00000_arg_sSrc2+D'1',0
0176  1783  	BSF STATUS,IRP
0177  0834  	MOVF FCI_SHEAD_00000_arg_sSrc2, W
0178  073B  	ADDWF FCI_SHEAD_00000_1_strt, W
0179  0084  	MOVWF FSR
017A  0880  	MOVF INDF, F
017B  1903  	BTFSC STATUS,Z
017C  2992  	GOTO	label22
017D  1383  	BCF STATUS,IRP
017E  1835  	BTFSC FCI_SHEAD_00000_arg_sSrc2+D'1',0
017F  1783  	BSF STATUS,IRP
0180  0834  	MOVF FCI_SHEAD_00000_arg_sSrc2, W
0181  0084  	MOVWF FSR
0182  083B  	MOVF FCI_SHEAD_00000_1_strt, W
0183  00BC  	MOVWF CompTempVar2147
0184  083C  	MOVF CompTempVar2147, W
0185  0784  	ADDWF FSR, F
0186  0800  	MOVF INDF, W
0187  00BD  	MOVWF CompTempVar2148
0188  1383  	BCF STATUS,IRP
0189  1832  	BTFSC FCI_SHEAD_00000_arg_sSrc1+D'1',0
018A  1783  	BSF STATUS,IRP
018B  0831  	MOVF FCI_SHEAD_00000_arg_sSrc1, W
018C  073B  	ADDWF FCI_SHEAD_00000_1_strt, W
018D  0084  	MOVWF FSR
018E  083D  	MOVF CompTempVar2148, W
018F  0080  	MOVWF INDF
0190  0ABB  	INCF FCI_SHEAD_00000_1_strt, F
0191  296C  	GOTO	label21
0192        label22

      len += strt;
0192  083B  	MOVF FCI_SHEAD_00000_1_strt, W
0193  07BA  	ADDWF FCI_SHEAD_00000_1_len, F

    }
  }
  // Terminate (only if can)
  if (len < iDst_len)
0194  0839  	MOVF FCI_SHEAD_00000_arg_iDst_len, W
0195  023A  	SUBWF FCI_SHEAD_00000_1_len, W
0196  1803  	BTFSC STATUS,C

  {
    sDst[len] = '\0';
0198  1383  	BCF STATUS,IRP
0199  1838  	BTFSC FCI_SHEAD_00000_arg_sDst+D'1',0
019A  1783  	BSF STATUS,IRP
019B  0837  	MOVF FCI_SHEAD_00000_arg_sDst, W
019C  073A  	ADDWF FCI_SHEAD_00000_1_len, W
019D  0084  	MOVWF FSR
019E  3000  	MOVLW 0x00
019F  0080  	MOVWF INDF

  }
}
0197  0008  	RETURN
01A0  0008  	RETURN



/*=----------------------------------------------------------------------=*\
   Use :Copy and null-terminate sSrc to sDst, max len iSrc_len
       :sDst is only null terminated if the concat doesnt overflow
       :
\*=----------------------------------------------------------------------=*/
void FCI_SCOPY(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len)

{
  MX_UINT8 len;

  // Move first
  FCI_STRMOV__x(sSrc, iSrc_len, sDst, iDst_len, len);
01A1  01C8  	CLRF FCI_SCOPY_00000_1_len
01A2        label24
01A2  0844  	MOVF FCI_SCOPY_00000_arg_iSrc_len, W
01A3  0248  	SUBWF FCI_SCOPY_00000_1_len, W
01A4  1803  	BTFSC STATUS,C
01A5  29C8  	GOTO	label25
01A6  0847  	MOVF FCI_SCOPY_00000_arg_iDst_len, W
01A7  0248  	SUBWF FCI_SCOPY_00000_1_len, W
01A8  1803  	BTFSC STATUS,C
01A9  29C8  	GOTO	label25
01AA  1383  	BCF STATUS,IRP
01AB  1832  	BTFSC FCI_SCOPY_00000_arg_sSrc+D'1',0
01AC  1783  	BSF STATUS,IRP
01AD  0831  	MOVF FCI_SCOPY_00000_arg_sSrc, W
01AE  0748  	ADDWF FCI_SCOPY_00000_1_len, W
01AF  0084  	MOVWF FSR
01B0  0880  	MOVF INDF, F
01B1  1903  	BTFSC STATUS,Z
01B2  29C8  	GOTO	label25
01B3  1383  	BCF STATUS,IRP
01B4  1832  	BTFSC FCI_SCOPY_00000_arg_sSrc+D'1',0
01B5  1783  	BSF STATUS,IRP
01B6  0831  	MOVF FCI_SCOPY_00000_arg_sSrc, W
01B7  0084  	MOVWF FSR
01B8  0848  	MOVF FCI_SCOPY_00000_1_len, W
01B9  00C9  	MOVWF CompTempVar2156
01BA  0849  	MOVF CompTempVar2156, W
01BB  0784  	ADDWF FSR, F
01BC  0800  	MOVF INDF, W
01BD  00CA  	MOVWF CompTempVar2157
01BE  1383  	BCF STATUS,IRP
01BF  1846  	BTFSC FCI_SCOPY_00000_arg_sDst+D'1',0
01C0  1783  	BSF STATUS,IRP
01C1  0845  	MOVF FCI_SCOPY_00000_arg_sDst, W
01C2  0748  	ADDWF FCI_SCOPY_00000_1_len, W
01C3  0084  	MOVWF FSR
01C4  084A  	MOVF CompTempVar2157, W
01C5  0080  	MOVWF INDF
01C6  0AC8  	INCF FCI_SCOPY_00000_1_len, F
01C7  29A2  	GOTO	label24
01C8        label25

  // Terminate (only if can)
  if (len < iDst_len)
01C8  0847  	MOVF FCI_SCOPY_00000_arg_iDst_len, W
01C9  0248  	SUBWF FCI_SCOPY_00000_1_len, W
01CA  1803  	BTFSC STATUS,C

  {
    sDst[len] = '\0';
01CC  1383  	BCF STATUS,IRP
01CD  1846  	BTFSC FCI_SCOPY_00000_arg_sDst+D'1',0
01CE  1783  	BSF STATUS,IRP
01CF  0845  	MOVF FCI_SCOPY_00000_arg_sDst, W
01D0  0748  	ADDWF FCI_SCOPY_00000_1_len, W
01D1  0084  	MOVWF FSR
01D2  3000  	MOVLW 0x00
01D3  0080  	MOVWF INDF

  }
}
01CB  0008  	RETURN
01D4  0008  	RETURN





//************************************************************************************
//**  
//**  File name:     C:\Users\gerpe\OneDrive\GER-PER 2016\Documents\KennyNeutron\2020\RF\NRF_test2\NRF_lib_v2_asmtest.c
//**  Title:         
//**  Description:   
//**  
//**  Generated by:  Flowcode v5.2.0.0
//**  Date:          Friday, April 16, 2021 13:46:57
//**  Licence:       Professional
//**  Registered to: xyz
//**  Licence key:   WUK7B9
//**  
//**  
//**  http://www.matrixmultimedia.com
//**  
//************************************************************************************


#define MX_PIC

#define MX_USES_UINT8 1
#define MX_USES_SINT16 0
#define MX_USES_CHAR 2
#define MX_USES_FLOAT 0
#define MX_USES_SINT32 0
#define MX_USES_BOOL 1
#define MX_USES_UINT16 0
#define MX_USES_UINT32 0
//Defines for microcontroller
#define P16F873A
#define FC_CAL_PIC
#define MX_ADC
#define MX_ADC_TYPE_1
#define MX_ADC_BITS_10
#define MX_EE
#define MX_EE_TYPE2
#define MX_EE_SIZE 128
#define MX_SPI_1
#define MX_SPI_1_MISO_PORT portc
#define MX_SPI_1_MISO_TRIS trisc
#define MX_SPI_1_MISO_PIN 4
#define MX_SPI_1_MOSI_PORT portc
#define MX_SPI_1_MOSI_TRIS trisc
#define MX_SPI_1_MOSI_PIN 5
#define MX_SPI_1_CLK_PORT portc
#define MX_SPI_1_CLK_TRIS trisc
#define MX_SPI_1_CLK_PIN 3
#define MX_SPI_1_SS_PORT portc
#define MX_SPI_1_SS_TRIS trisc
#define MX_UART_1
#define MX_UART_1_TX_PORT portc
#define MX_UART_1_TX_TRIS trisc
#define MX_UART_1_TX_PIN 6
#define MX_UART_1_RX_PORT portc
#define MX_UART_1_RX_TRIS trisc
#define MX_UART_1_RX_PIN 7
#define MX_I2C
#define MX_MI2C
#define MX_I2C_1
#define MX_I2C_1_SDA_PORT portc
#define MX_I2C_1_SDA_TRIS trisc
#define MX_I2C_1_SDA_PIN 4
#define MX_I2C_1_SCL_PORT portc
#define MX_I2C_1_SCL_TRIS trisc
#define MX_I2C_1_SCL_PIN 3
#define MX_PWM
#define MX_PWM_CNT 2
#define MX_PWM_PSCA1
#define MX_PWM_PSCA4
#define MX_PWM_PSCA16
#define MX_PWM_1_PORT portc
#define MX_PWM_1_TRIS trisc
#define MX_PWM_1_PIN 2
#define MX_PWM_2_PORT portc
#define MX_PWM_2_TRIS trisc
#define MX_PWM_2_PIN 1

//Functions
#define MX_CLK_SPEED 20000000
#ifdef _BOOSTC
#include <system.h>
#endif
#ifdef HI_TECH_C
#include <pic.h>
#endif

//Configuration data
#ifdef _BOOSTC
#pragma DATA 0x2007, 0x3f3a
#endif
#ifdef HI_TECH_C
__CONFIG(0x3f3a);
#endif

//Internal functions
#include "C:\Program Files (x86)\Flowcode\v5\FCD\internals.c"

//Macro function declarations
void FCM_cmd_write_reg();
void FCM_cmd_read_reg();
void FCM_radio_init_rx();
void FCM_set_rx_addr();
void FCM_set_tx_addr();
void FCM_cmd_read_rx_addr();
void FCM_cmd_read_tx_addr();
void FCM_radio_init_tx();
void FCM_flush_fifo_txrx();
void FCM_radio_send_data();
void FCM_radio_recieve_data();
void FCM_check_status();
void FCM_read_recieved_data();
void FCM_uart_int();


//Variable declarations
#define FCSZ_PAYLOAD_RECIEVE 18
#define FCSZ_PAYLOAD_TRANSMIT 16
#define FCSZ_RX_ADDR 5
#define FCSZ_TX_ADDR 5
#define FCV_TRUE (1)
#define FCV_FALSE (0)
MX_BOOL FCV_TRANCIEVER_BIT = (0);
080A  106E  	BCF gbl_FCV_TRANCIEVER_BIT,0

MX_UINT8 FCV_REG01 = (0x0); // en_aa
080B  01EF  	CLRF gbl_FCV_REG01

MX_UINT8 FCV_REG10_TX_ADDR_BYTE1 = (0x0);
080C  01F0  	CLRF gbl_FCV_REG10_TX_ADDR_BYTE1

MX_UINT8 FCV_DATA_TO_WRITE = (0xff);
080D  30FF  	MOVLW 0xFF
080E  00F1  	MOVWF gbl_FCV_DATA_TO_WRITE

MX_UINT8 FCV_REG02 = (0x0); // en_rxaddr
080F  01F2  	CLRF gbl_FCV_REG02

MX_UINT8 FCV_REG10_TX_ADDR_BYTE2 = (0x0);
0810  01F3  	CLRF gbl_FCV_REG10_TX_ADDR_BYTE2

MX_UINT8 FCV_REG03 = (0x0); // setup
0811  01F4  	CLRF gbl_FCV_REG03

MX_UINT8 FCV_REG10_TX_ADDR_BYTE3 = (0x0);
0812  01F5  	CLRF gbl_FCV_REG10_TX_ADDR_BYTE3

MX_CHAR FCV_PAYLOAD_RECIEVE[FCSZ_PAYLOAD_RECIEVE] = ("");
0813  01A0  	CLRF gbl_FCV_PAYLOAD_RECIEVE

MX_UINT8 FCV_STATUS_MAX_RT = (0x0);
0814  01F6  	CLRF gbl_FCV_STATUS_MAX_RT

MX_UINT8 FCV_REG04 = (0x0); // setup_retr
0815  01F7  	CLRF gbl_FCV_REG04

MX_UINT8 FCV_REG10_TX_ADDR_BYTE4 = (0x0);
0816  01F8  	CLRF gbl_FCV_REG10_TX_ADDR_BYTE4

MX_UINT8 FCV_SPI_DATA0 = (0xff);
0817  30FF  	MOVLW 0xFF
0818  00F9  	MOVWF gbl_FCV_SPI_DATA0

MX_UINT8 FCV_REG05 = (0x0); // rf_ch
0819  01FA  	CLRF gbl_FCV_REG05

MX_UINT8 FCV_DATA_TO_READ = (0xff);
081A  30FF  	MOVLW 0xFF
081B  00FB  	MOVWF gbl_FCV_DATA_TO_READ

MX_UINT8 FCV_SPI_DATA1 = (0xff);
081C  30FF  	MOVLW 0xFF
081D  00FC  	MOVWF gbl_FCV_SPI_DATA1

MX_UINT8 FCV_REG06 = (0x0); // rf_setup
081E  01FD  	CLRF gbl_FCV_REG06

MX_UINT8 FCV_REG17 = (0x0); // fifo_status
081F  01FE  	CLRF gbl_FCV_REG17

MX_CHAR FCV_PAYLOAD_TRANSMIT[FCSZ_PAYLOAD_TRANSMIT] = ("");
0820  01B2  	CLRF gbl_FCV_PAYLOAD_TRANSMIT

MX_UINT8 FCV_REG07 = (0x0); // status
0821  1683  	BSF STATUS, RP0
0822  01A0  	CLRF gbl_FCV_REG07

MX_UINT8 FCV_REG08 = (0x0); // observe_tx
0823  01A1  	CLRF gbl_FCV_REG08

MX_UINT8 FCV_REG0A_RX_ADDR_P0_BYTE0 = (0x0);
0824  01A2  	CLRF gbl_FCV_REG0A_RX_ADDR_P0_BYTE0

MX_UINT8 FCV_FLAG_PROT = (0x0);
0825  01A3  	CLRF gbl_FCV_FLAG_PROT

MX_UINT8 FCV_UART_RX = (0xff);
0826  30FF  	MOVLW 0xFF
0827  00A4  	MOVWF gbl_FCV_UART_RX

MX_UINT8 FCV_REG09 = (0x0); // cd
0828  01A5  	CLRF gbl_FCV_REG09

MX_UINT8 FCV_REG0A_RX_ADDR_P0_BYTE1 = (0x0);
0829  01A6  	CLRF gbl_FCV_REG0A_RX_ADDR_P0_BYTE1

MX_UINT8 FCV_REG0A_RX_ADDR_P0_BYTE2 = (0x0);
082A  01A7  	CLRF gbl_FCV_REG0A_RX_ADDR_P0_BYTE2

MX_BOOL FCV_FLAGBIT = (0);
082B  1283  	BCF STATUS, RP0
082C  10EE  	BCF gbl_FCV_FLAGBIT,1

MX_UINT8 FCV_STATUS_TX_DS = (0x0);
082D  1683  	BSF STATUS, RP0
082E  01A8  	CLRF gbl_FCV_STATUS_TX_DS

MX_UINT8 FCV_REG0A_RX_ADDR_P0_BYTE3 = (0x0);
082F  01A9  	CLRF gbl_FCV_REG0A_RX_ADDR_P0_BYTE3

MX_UINT8 FCV_REG_TO_WRITE = (0x0);
0830  01AA  	CLRF gbl_FCV_REG_TO_WRITE

MX_UINT8 FCV_REG0A_RX_ADDR_P0_BYTE4 = (0x0);
0831  01AB  	CLRF gbl_FCV_REG0A_RX_ADDR_P0_BYTE4

MX_BOOL FCV_UART_FLAG = (0);
0832  1283  	BCF STATUS, RP0
0833  116E  	BCF gbl_FCV_UART_FLAG,2

MX_CHAR FCV_RX_ADDR[FCSZ_RX_ADDR] = ("");
0834  01C2  	CLRF gbl_FCV_RX_ADDR

MX_UINT8 FCV_PAYLOADSIZE = (0x20);
0835  3020  	MOVLW 0x20
0836  1683  	BSF STATUS, RP0
0837  00AC  	MOVWF gbl_FCV_PAYLOADSIZE

MX_UINT8 FCV_LOOP_COUNT = (0x0);
0838  01AD  	CLRF gbl_FCV_LOOP_COUNT

MX_CHAR FCV_TX_ADDR[FCSZ_TX_ADDR] = ("");
0839  1283  	BCF STATUS, RP0
083A  01C7  	CLRF gbl_FCV_TX_ADDR

MX_BOOL FCV_FLAG_RADIO_RX = (0);
083B  11EE  	BCF gbl_FCV_FLAG_RADIO_RX,3

MX_UINT8 FCV_REG00 = (0x0); // config
083C  1683  	BSF STATUS, RP0
083D  01AE  	CLRF gbl_FCV_REG00

MX_UINT8 FCV_REG10_TX_ADDR_BYTE0 = (0x0);
083E  01AF  	CLRF gbl_FCV_REG10_TX_ADDR_BYTE0

MX_UINT8 FCV_REG11 = (0x0); // rx payload width @pipe0
083F  01B0  	CLRF gbl_FCV_REG11





//SPI_Legacy(0): //Defines:

/**** Macro Substitutions ****
a = Unique Ref
b = SPI Channel
c = MOSI Pin
d = MOSI Port
e = MISO Pin
f = MISO Port
g = SCK Pin
h = SCK Port
i = Clock Polarity + Clock Phase + Data Sample Phase
j = SPI Prescaler
k = SPI Postscaler
l = DAC Enable Pin
m = DAC Enable Port
n = FRAM Enable Pin
o = FRAM Enable Port
******************************/

//MX_SPI_BMODE - Bus Mode - Bit0=CPOL, Bit1=CPHA, Bit2=CSMP
//CPOL - Clock Polarity - Idle State of the clock 0=0, 1=1
//CPHA - Clock Phase - Clock Edge 0=leading edge, 1=trailing edge
//CSMP - Input Data Bit Sample Phase


//Definitions for CS control lines
#define SPI_1_MX_SPI_LEGACY_DAC_PIN		0
#define SPI_1_MX_SPI_LEGACY_DAC_PORT		porta
#define SPI_1_MX_SPI_LEGACY_DAC_TRIS		trisa
#define SPI_1_MX_SPI_LEGACY_FRAM_PIN		0
#define SPI_1_MX_SPI_LEGACY_FRAM_PORT		porta
#define SPI_1_MX_SPI_LEGACY_FRAM_TRIS		trisa


//Definitions for SPI slot allocation
#ifndef	MX_SPI_REF1
	#define MX_SPI_REF1
	#define SPI_1_MX_SPI_UREF			1
	#define MX_SPI_CHANNEL_1		1
	#define MX_SPI_MOSI_PIN_1		-1
	#define MX_SPI_MOSI_PORT_1		port0
	#define MX_SPI_MOSI_TRIS_1		tris0
	#define MX_SPI_MISO_PIN_1		-1
	#define MX_SPI_MISO_PORT_1		port0
	#define MX_SPI_MISO_TRIS_1		tris0
	#define MX_SPI_SCK_PIN_1		-1
	#define MX_SPI_SCK_PORT_1		port0
	#define MX_SPI_SCK_TRIS_1		tris0
	#define MX_SPI_CS_PIN_1			0
	#define MX_SPI_CS_PORT_1		0
	#define MX_SPI_BMODE_1			6
	#define MX_SPI_PR_SCALE_1		4
	#define MX_SPI_PO_SCALE_1		0
	#define MX_SPI_INT_1			0
#else
 #ifndef	MX_SPI_REF2
	#define MX_SPI_REF2
	#define SPI_1_MX_SPI_UREF			2
	#define MX_SPI_CHANNEL_2		1
	#define MX_SPI_MOSI_PIN_2		-1
	#define MX_SPI_MOSI_PORT_2		port0
	#define MX_SPI_MOSI_TRIS_2		tris0
	#define MX_SPI_MISO_PIN_2		-1
	#define MX_SPI_MISO_PORT_2		port0
	#define MX_SPI_MISO_TRIS_2		tris0
	#define MX_SPI_SCK_PIN_2		-1
	#define MX_SPI_SCK_PORT_2		port0
	#define MX_SPI_SCK_TRIS_2		tris0
	#define MX_SPI_CS_PIN_2			0
	#define MX_SPI_CS_PORT_2		0
	#define MX_SPI_BMODE_2			6
	#define MX_SPI_PR_SCALE_2		4
	#define MX_SPI_PO_SCALE_2		0
	#define MX_SPI_INT_2			0
 #else
  #ifndef	MX_SPI_REF3
	#define MX_SPI_REF3
	#define SPI_1_MX_SPI_UREF			3
	#define MX_SPI_CHANNEL_3		1
	#define MX_SPI_MOSI_PIN_3		-1
	#define MX_SPI_MOSI_PORT_3		port0
	#define MX_SPI_MOSI_TRIS_3		tris0
	#define MX_SPI_MISO_PIN_3		-1
	#define MX_SPI_MISO_PORT_3		port0
	#define MX_SPI_MISO_TRIS_3		tris0
	#define MX_SPI_SCK_PIN_3		-1
	#define MX_SPI_SCK_PORT_3		port0
	#define MX_SPI_SCK_TRIS_3		tris0
	#define MX_SPI_CS_PIN_3			0
	#define MX_SPI_CS_PORT_3		0
	#define MX_SPI_BMODE_3			6
	#define MX_SPI_PR_SCALE_3		4
	#define MX_SPI_PO_SCALE_3		0
	#define MX_SPI_INT_3			0
  #else
   #ifndef	MX_SPI_REF4
	#define MX_SPI_REF4
	#define SPI_1_MX_SPI_UREF			4
	#define MX_SPI_CHANNEL_4		1
	#define MX_SPI_MOSI_PIN_4		-1
	#define MX_SPI_MOSI_PORT_4		port0
	#define MX_SPI_MOSI_TRIS_4		tris0
	#define MX_SPI_MISO_PIN_4		-1
	#define MX_SPI_MISO_PORT_4		port0
	#define MX_SPI_MISO_TRIS_4		tris0
	#define MX_SPI_SCK_PIN_4		-1
	#define MX_SPI_SCK_PORT_4		port0
	#define MX_SPI_SCK_TRIS_4		tris0
	#define MX_SPI_CS_PIN_4			0
	#define MX_SPI_CS_PORT_4		0
	#define MX_SPI_BMODE_4			6
	#define MX_SPI_PR_SCALE_4		4
	#define MX_SPI_PO_SCALE_4		0
	#define MX_SPI_INT_4			0
   #endif
  #endif
 #endif
#endif

#define SPI_1_SPI_Master_Init		CAL_APPEND(FC_CAL_SPI_Master_Init_, SPI_1_MX_SPI_UREF)
#define SPI_1_SPI_Master_Uninit	CAL_APPEND(FC_CAL_SPI_Master_Uninit_, SPI_1_MX_SPI_UREF)
#define SPI_1_SPI_Master_Byte		CAL_APPEND(FC_CAL_SPI_Master_Byte_, SPI_1_MX_SPI_UREF)

extern void SPI_1_SPI_Master_Init ();
extern void SPI_1_SPI_Master_Uninit ();
extern MX_UINT8 SPI_1_SPI_Master_Byte (MX_UINT8 DataOut);

//FRAM commands
#define FRAM_WREN  	6
#define FRAM_WRDI  	4
#define FRAM_RDSR  	5
#define FRAM_WRSR  	1
#define FRAM_READ  	3
#define FRAM_WRITE 	2




//SPI_Legacy(0): //Macro function declarations

void FCD_SPI_Legacy0_SPI_Init();
void FCD_SPI_Legacy0_SPI_Uninit();
void FCD_SPI_Legacy0_SPI_Send_Char(MX_UINT8 Char);
void FCD_SPI_Legacy0_SPI_Send_String(MX_STRING String, MX_UINT8 MSZ_String);
MX_UINT8 FCD_SPI_Legacy0_SPI_Get_Char();
void FCD_SPI_Legacy0_SPI_Get_String(MX_CHAR* FCR_RETVAL, MX_UINT8 FCR_RETVAL_SIZE, MX_UINT8 NumBytes);
void FCD_SPI_Legacy0_DAC_Send_Char(MX_UINT8 Char);
void FCD_SPI_Legacy0_NVM_Send_Char(MX_UINT8 hi_addr, MX_UINT8 lo_addr, MX_UINT8 Char);
MX_UINT8 FCD_SPI_Legacy0_NVM_Get_Char(MX_UINT8 hi_addr, MX_UINT8 lo_addr);
MX_UINT8 FCD_SPI_Legacy0_FramOutput(MX_UINT8 Char);
void FCD_SPI_Legacy0_EnableFRAM();
void FCD_SPI_Legacy0_DisableFRAM();


//RS232(0): //Defines:

/**** Macro Substitutions ****
a = Unique Reference
b = Uart Channel		(0-software / 1-4 hardware)
c = tx pin
d = tx port
e = rx pin
f = rx port
g = flow control		(0-Off / 1-On)
h = cts pin
i = cts port
j = rts pin
k = rts port
l = baud rate
m = data bits			(7/8/9) (7 only supported in software modes)
n = return type		(0-byte / 1-MX_UINT16)
o = echo enable		(0-Off / 1-On)
******************************/

//Definitions for RS232 UART slot allocation
#ifndef	MX_UART_REF1
	#define MX_UART_REF1
	#define RS232_2_MX_UART_UREF			1
	#define MX_UART_CHANNEL_1		1
	#define MX_UART_TX_PIN_1		0
	#define MX_UART_TX_PORT_1		porta
	#define MX_UART_TX_TRIS_1		trisa
	#define MX_UART_RX_PIN_1		0
	#define MX_UART_RX_PORT_1		porta
	#define MX_UART_RX_TRIS_1		trisa
	#define MX_UART_FLOWEN_1		0
	#define MX_UART_CTS_PIN_1		4
	#define MX_UART_CTS_PORT_1		portc
	#define MX_UART_CTS_TRIS_1		trisc
	#define MX_UART_RTS_PIN_1		0
	#define MX_UART_RTS_PORT_1		portc
	#define MX_UART_RTS_TRIS_1		trisc
	#define MX_UART_BAUD_1			9600
	#define MX_UART_DBITS_1			8
	#define MX_UART_RETURN_1		0
	#define MX_UART_ECHO_1			0
	#define MX_UART_INT_1			0
#else
 #ifndef	MX_UART_REF2
	#define MX_UART_REF2
	#define RS232_2_MX_UART_UREF			2
	#define MX_UART_CHANNEL_2		1
	#define MX_UART_TX_PIN_2		0
	#define MX_UART_TX_PORT_2		porta
	#define MX_UART_TX_TRIS_2		trisa
	#define MX_UART_RX_PIN_2		0
	#define MX_UART_RX_PORT_2		porta
	#define MX_UART_RX_TRIS_2		trisa
	#define MX_UART_FLOWEN_2		0
	#define MX_UART_CTS_PIN_2		4
	#define MX_UART_CTS_PORT_2		portc
	#define MX_UART_CTS_TRIS_2		trisc
	#define MX_UART_RTS_PIN_2		0
	#define MX_UART_RTS_PORT_2		portc
	#define MX_UART_RTS_TRIS_2		trisc
	#define MX_UART_BAUD_2			9600
	#define MX_UART_DBITS_2			8
	#define MX_UART_RETURN_2		0
	#define MX_UART_ECHO_2			0
	#define MX_UART_INT_2			0
 #else
  #ifndef	MX_UART_REF3
	#define MX_UART_REF3
	#define RS232_2_MX_UART_UREF			3
	#define MX_UART_CHANNEL_3		1
	#define MX_UART_TX_PIN_3		0
	#define MX_UART_TX_PORT_3		porta
	#define MX_UART_TX_TRIS_3		trisa
	#define MX_UART_RX_PIN_3		0
	#define MX_UART_RX_PORT_3		porta
	#define MX_UART_RX_TRIS_3		trisa
	#define MX_UART_FLOWEN_3		0
	#define MX_UART_CTS_PIN_3		4
	#define MX_UART_CTS_PORT_3		portc
	#define MX_UART_CTS_TRIS_3		trisc
	#define MX_UART_RTS_PIN_3		0
	#define MX_UART_RTS_PORT_3		portc
	#define MX_UART_RTS_TRIS_3		trisc
	#define MX_UART_BAUD_3			9600
	#define MX_UART_DBITS_3			8
	#define MX_UART_RETURN_3		0
	#define MX_UART_ECHO_3			0
	#define MX_UART_INT_3			0
  #else
   #ifndef	MX_UART_REF4
	#define MX_UART_REF4
	#define RS232_2_MX_UART_UREF			4
	#define MX_UART_CHANNEL_4		1
	#define MX_UART_TX_PIN_4		0
	#define MX_UART_TX_PORT_4		porta
	#define MX_UART_TX_TRIS_4		trisa
	#define MX_UART_RX_PIN_4		0
	#define MX_UART_RX_PORT_4		porta
	#define MX_UART_RX_TRIS_4		trisa
	#define MX_UART_FLOWEN_4		0
	#define MX_UART_CTS_PIN_4		4
	#define MX_UART_CTS_PORT_4		portc
	#define MX_UART_CTS_TRIS_4		trisc
	#define MX_UART_RTS_PIN_4		0
	#define MX_UART_RTS_PORT_4		portc
	#define MX_UART_RTS_TRIS_4		trisc
	#define MX_UART_BAUD_4			9600
	#define MX_UART_DBITS_4			8
	#define MX_UART_RETURN_4		0
	#define MX_UART_ECHO_4			0
	#define MX_UART_INT_4			0
   #endif
  #endif
 #endif
#endif

#define RS232_2_UART_Init		CAL_APPEND(FC_CAL_UART_Init_, RS232_2_MX_UART_UREF)
#define RS232_2_UART_Send		CAL_APPEND(FC_CAL_UART_Send_, RS232_2_MX_UART_UREF)
#define RS232_2_UART_Receive		CAL_APPEND(FC_CAL_UART_Receive_, RS232_2_MX_UART_UREF)
#define RS232_2_UART_Update_Baud CAL_APPEND(FC_CAL_UART_Update_Baud_, RS232_2_MX_UART_UREF)

extern void RS232_2_UART_Init();
extern void RS232_2_UART_Send(MX_UINT16 nChar);
extern MX_SINT16 RS232_2_UART_Receive(MX_UINT8 nTimeout);
extern void RS232_2_UART_Update_Baud(MX_UINT8 newbaud);




//RS232(0): //Macro function declarations

void FCD_RS2320_SendRS232Char(MX_SINT16 nChar);
void FCD_RS2320_SendRS232String(MX_STRING String, MX_UINT8 MSZ_String);
MX_SINT16 FCD_RS2320_ReceiveRS232Char(MX_UINT8 nTimeout);
void FCD_RS2320_ReceiveRS232String(MX_CHAR* FCR_RETVAL, MX_UINT8 FCR_RETVAL_SIZE, MX_UINT8 nTimeout, MX_UINT8 NumBytes);
void FCD_RS2320_ChangeHWBaud(MX_UINT8 newbaud);


//LCDDisplay(0): //Defines:

/**** Macro Substitutions ****
a = Unique Component Reference Number
b = D1 Port Letter
c = D2 Port Letter
d = D3 Port Letter
e = D4 Port Letter
f = RS Port Letter
g = E Port Letter
h = Data 1_Pin
i = Data 2 Pin
j = Data 3 Pin
k = Data 4 Pin
l = RS Pin
m = Enable Pin
n = Row Count
o = Column Count
******************************/

	//component connections
	#define LCD_3__PORT0    portb
	#define LCD_3__PORT1    portb
	#define LCD_3__PORT2    portb
	#define LCD_3__PORT3    portb
	#define LCD_3__PORT4    portb
	#define LCD_3__PORT5    portb
	#define LCD_3__TRIS0    trisb
	#define LCD_3__TRIS1    trisb
	#define LCD_3__TRIS2    trisb
	#define LCD_3__TRIS3    trisb
	#define LCD_3__TRIS4    trisb
	#define LCD_3__TRIS5    trisb
	#define LCD_3__BIT0    	2
	#define LCD_3__BIT1    	3
	#define LCD_3__BIT2    	4
	#define LCD_3__BIT3    	5
	#define LCD_3__RS      	0
	#define LCD_3__E       	1
	#define LCD_3__ROWCNT	4
	#define LCD_3__COLCNT	16

	#ifdef _BOOSTC
	  #define LCD_3__DELAY   delay_10us(10)
	#endif
	#ifdef _C2C_
	  #define LCD_3__DELAY   delay_us(100)
	#endif
	#ifdef HI_TECH_C
	  #define LCD_3__DELAY   __delay_us(120)
	#endif
	#ifndef LCD_3__DELAY
	  #define LCD_3__DELAY   delay_us(100)
	#endif




//LCDDisplay(0): //Macro function declarations

void FCD_LCDDisplay0_RawSend(MX_UINT8 in, MX_UINT8 mask);
void FCD_LCDDisplay0_Start();
void FCD_LCDDisplay0_Clear();
void FCD_LCDDisplay0_PrintASCII(MX_UINT8 Character);
void FCD_LCDDisplay0_Command(MX_UINT8 in);
void FCD_LCDDisplay0_Cursor(MX_UINT8 x, MX_UINT8 y);
void FCD_LCDDisplay0_PrintNumber(MX_SINT16 Number);
void FCD_LCDDisplay0_PrintString(MX_STRING String, MX_UINT8 MSZ_String);
void FCD_LCDDisplay0_ScrollDisplay(MX_UINT8 Direction, MX_UINT8 Num_Positions);
void FCD_LCDDisplay0_ClearLine(MX_UINT8 Line);
void FCD_LCDDisplay0_RAM_Write(MX_UINT8 nIdx, MX_UINT8 d0, MX_UINT8 d1, MX_UINT8 d2, MX_UINT8 d3, MX_UINT8 d4, MX_UINT8 d5, MX_UINT8 d6, MX_UINT8 d7);



//SPI_Legacy(0): //Macro implementations


void FCD_SPI_Legacy0_SPI_Init()

{
	
		//Disable SPI Devices
		FC_CAL_Bit_High_DDR(SPI_1_MX_SPI_LEGACY_DAC_PORT, SPI_1_MX_SPI_LEGACY_DAC_TRIS, SPI_1_MX_SPI_LEGACY_DAC_PIN);
0502  1683  	BSF STATUS, RP0
0503  1303  	BCF STATUS, RP1
0504  1005  	BCF gbl_trisa,0
0505  1283  	BCF STATUS, RP0
0506  1405  	BSF gbl_porta,0

		FC_CAL_Bit_High_DDR(SPI_1_MX_SPI_LEGACY_FRAM_PORT, SPI_1_MX_SPI_LEGACY_FRAM_TRIS, SPI_1_MX_SPI_LEGACY_FRAM_PIN);
0507  1683  	BSF STATUS, RP0
0508  1005  	BCF gbl_trisa,0
0509  1283  	BCF STATUS, RP0
050A  1405  	BSF gbl_porta,0


		//Init SPI
		SPI_1_SPI_Master_Init();		//Call initialise function
050B  21FF  	CALL FC_CAL_SPI_00064


}
050C  0008  	RETURN


void FCD_SPI_Legacy0_SPI_Uninit()
{
	
		//Convert SPI Device Control Lines To Inputs
		FC_CAL_Bit_In_DDR(SPI_1_MX_SPI_LEGACY_DAC_PORT, SPI_1_MX_SPI_LEGACY_DAC_TRIS, SPI_1_MX_SPI_LEGACY_DAC_PIN);
		FC_CAL_Bit_In_DDR(SPI_1_MX_SPI_LEGACY_FRAM_PORT, SPI_1_MX_SPI_LEGACY_FRAM_TRIS, SPI_1_MX_SPI_LEGACY_FRAM_PIN);

		//Uninit SPI
		SPI_1_SPI_Master_Uninit();		//Call uninitialise function

}

void FCD_SPI_Legacy0_SPI_Send_Char(MX_UINT8 Char)

{
	
		SPI_1_SPI_Master_Byte(Char);
0068  0831  	MOVF FCD_SPI_Le_00052_arg_Char, W
0069  00B2  	MOVWF FC_CAL_SPI_00066_arg_DataOut
006A  204F  	CALL FC_CAL_SPI_00066


}
006B  0008  	RETURN


void FCD_SPI_Legacy0_SPI_Send_String(MX_STRING String, MX_UINT8 MSZ_String)
{
	
		MX_UINT8 idx;
		for(idx = 0; idx < MSZ_String; idx++)
		{
			if (String[idx] == 0)				//End of string data?
				break;

			SPI_1_SPI_Master_Byte(String[idx]);
		}

}

MX_UINT8 FCD_SPI_Legacy0_SPI_Get_Char()

{
	
		MX_UINT8 retVal = 0;
005D  1683  	BSF STATUS, RP0
005E  1303  	BCF STATUS, RP1
005F  01B1  	CLRF FCD_SPI_Le_00054_1_retVal


		retVal = SPI_1_SPI_Master_Byte(0xFF);
0060  30FF  	MOVLW 0xFF
0061  00B2  	MOVWF FC_CAL_SPI_00066_arg_DataOut
0062  204F  	CALL FC_CAL_SPI_00066
0063  0834  	MOVF CompTempVarRet2251, W
0064  00B1  	MOVWF FCD_SPI_Le_00054_1_retVal


		return (retVal);
0065  0831  	MOVF FCD_SPI_Le_00054_1_retVal, W
0066  00B2  	MOVWF CompTempVarRet2190


}
0067  0008  	RETURN


void FCD_SPI_Legacy0_SPI_Get_String(MX_CHAR* FCR_RETVAL, MX_UINT8 FCR_RETVAL_SIZE, MX_UINT8 NumBytes)
{
		MX_UINT8 idx;

		if (NumBytes > FCR_RETVAL_SIZE)
			NumBytes = FCR_RETVAL_SIZE;

		for (idx = 0; idx < NumBytes; idx++)
		{
			FCR_RETVAL[idx] = SPI_1_SPI_Master_Byte(0xFF);		//Collect incoming data byte
		}

		if (idx < FCR_RETVAL_SIZE)
			FCR_RETVAL[idx] = 0;					//Terminate string if string variable is longer then expected data

}

void FCD_SPI_Legacy0_DAC_Send_Char(MX_UINT8 Char)
{
	
		MX_UINT8 dac_val;

		FC_CAL_Bit_Low(SPI_1_MX_SPI_LEGACY_DAC_PORT, SPI_1_MX_SPI_LEGACY_DAC_PIN);		//enable dac

		dac_val = (Char & 0xF0) >> 4;
		SPI_1_SPI_Master_Byte(dac_val);

		dac_val = (Char & 0x0F) << 4;
		SPI_1_SPI_Master_Byte(dac_val);

		FC_CAL_Bit_High(SPI_1_MX_SPI_LEGACY_DAC_PORT, SPI_1_MX_SPI_LEGACY_DAC_PIN);		//disable dac

}

void FCD_SPI_Legacy0_NVM_Send_Char(MX_UINT8 hi_addr, MX_UINT8 lo_addr, MX_UINT8 Char)
{
	
		//enable writes
		FCD_SPI_Legacy0_EnableFRAM();
		FCD_SPI_Legacy0_FramOutput(FRAM_WREN);
		FCD_SPI_Legacy0_DisableFRAM();

		//send write-fram command, address and data
		FCD_SPI_Legacy0_EnableFRAM();
		FCD_SPI_Legacy0_FramOutput(FRAM_WRITE);
		FCD_SPI_Legacy0_FramOutput(hi_addr);
		FCD_SPI_Legacy0_FramOutput(lo_addr);
		FCD_SPI_Legacy0_FramOutput(Char);
		FCD_SPI_Legacy0_DisableFRAM();

}

MX_UINT8 FCD_SPI_Legacy0_NVM_Get_Char(MX_UINT8 hi_addr, MX_UINT8 lo_addr)
{
	
		MX_UINT8 retVal;

		FCD_SPI_Legacy0_EnableFRAM();

		//send read-fram command and address
		FCD_SPI_Legacy0_FramOutput(FRAM_READ);
		FCD_SPI_Legacy0_FramOutput(hi_addr);
		FCD_SPI_Legacy0_FramOutput(lo_addr);

		//read the data
		retVal = FCD_SPI_Legacy0_FramOutput(0x5A);  	//don't care byte of 0x5A

		FCD_SPI_Legacy0_DisableFRAM();

		return(retVal);

}

MX_UINT8 FCD_SPI_Legacy0_FramOutput(MX_UINT8 Char)
{
	
		MX_UINT8 retVal = 0;
		retVal = SPI_1_SPI_Master_Byte(Char);
		return (retVal);

}

void FCD_SPI_Legacy0_EnableFRAM()
{
	
		FC_CAL_Bit_Low(SPI_1_MX_SPI_LEGACY_FRAM_PORT, SPI_1_MX_SPI_LEGACY_FRAM_PIN);

}

void FCD_SPI_Legacy0_DisableFRAM()
{
	
		FC_CAL_Bit_High(SPI_1_MX_SPI_LEGACY_FRAM_PORT, SPI_1_MX_SPI_LEGACY_FRAM_PIN);

}



//RS232(0): //Macro implementations


void FCD_RS2320_SendRS232Char(MX_SINT16 nChar)
{
	
		RS232_2_UART_Send ( nChar);

}

void FCD_RS2320_SendRS232String(MX_STRING String, MX_UINT8 MSZ_String)
{
	
		MX_UINT8 idx;
		for(idx = 0; idx < MSZ_String; idx++)
		{
			if (String[idx] == 0)
				break;
			else RS232_2_UART_Send ( String[idx] );
		}

}

MX_SINT16 FCD_RS2320_ReceiveRS232Char(MX_UINT8 nTimeout)
{
	
		return ( RS232_2_UART_Receive ( nTimeout) );

}

void FCD_RS2320_ReceiveRS232String(MX_CHAR* FCR_RETVAL, MX_UINT8 FCR_RETVAL_SIZE, MX_UINT8 nTimeout, MX_UINT8 NumBytes)
{
	
		MX_UINT8 idx;
		MX_SINT16 RS232_TO = 255;
		MX_SINT16 in;

		if ( 0 != 0 )
			RS232_TO = 256;

		if (NumBytes > FCR_RETVAL_SIZE)
			NumBytes = FCR_RETVAL_SIZE;

		for (idx = 0; idx < NumBytes; idx++)
		{
			in = RS232_2_UART_Receive ( nTimeout);
			if(in < RS232_TO)
				FCR_RETVAL[idx] = in & 0xFF;
			else
				break;
		}

		if (idx < FCR_RETVAL_SIZE)
			FCR_RETVAL[idx] = 0;

}

void FCD_RS2320_ChangeHWBaud(MX_UINT8 newbaud)
{
	
		RS232_2_UART_Update_Baud (newbaud);

}



//LCDDisplay(0): //Macro implementations


void FCD_LCDDisplay0_RawSend(MX_UINT8 in, MX_UINT8 mask)

{
	
		MX_UINT8 pt;

		FC_CAL_Bit_Low(LCD_3__PORT0, LCD_3__BIT0);
0353  1283  	BCF STATUS, RP0
0354  1106  	BCF gbl_portb,2

		FC_CAL_Bit_Low(LCD_3__PORT1, LCD_3__BIT1);
0355  1186  	BCF gbl_portb,3

		FC_CAL_Bit_Low(LCD_3__PORT2, LCD_3__BIT2);
0356  1206  	BCF gbl_portb,4

		FC_CAL_Bit_Low(LCD_3__PORT3, LCD_3__BIT3);
0357  1286  	BCF gbl_portb,5

		FC_CAL_Bit_Low(LCD_3__PORT4, LCD_3__RS);
0358  1006  	BCF gbl_portb,0

		FC_CAL_Bit_Low(LCD_3__PORT5, LCD_3__E);
0359  1086  	BCF gbl_portb,1

		pt = ((in >> 4) & 0x0f);
035A  1683  	BSF STATUS, RP0
035B  0E42  	SWAPF FCD_LCDDis_0007A_arg_in, W
035C  390F  	ANDLW 0x0F
035D  00C4  	MOVWF FCD_LCDDis_0007A_1_pt
035E  300F  	MOVLW 0x0F
035F  05C4  	ANDWF FCD_LCDDis_0007A_1_pt, F

		if (pt & 0x01)
0360  1C44  	BTFSS FCD_LCDDis_0007A_1_pt,0
0361  2B64  	GOTO	label31

		    FC_CAL_Bit_High(LCD_3__PORT0, LCD_3__BIT0);
0362  1283  	BCF STATUS, RP0
0363  1506  	BSF gbl_portb,2

		if (pt & 0x02)
0364  1683  	BSF STATUS, RP0
0365  1CC4  	BTFSS FCD_LCDDis_0007A_1_pt,1
0366  2B69  	GOTO	label32

		    FC_CAL_Bit_High(LCD_3__PORT1, LCD_3__BIT1);
0367  1283  	BCF STATUS, RP0
0368  1586  	BSF gbl_portb,3

		if (pt & 0x04)
0369  1683  	BSF STATUS, RP0
036A  1D44  	BTFSS FCD_LCDDis_0007A_1_pt,2
036B  2B6E  	GOTO	label33

		    FC_CAL_Bit_High(LCD_3__PORT2, LCD_3__BIT2);
036C  1283  	BCF STATUS, RP0
036D  1606  	BSF gbl_portb,4

		if (pt & 0x08)
036E  1683  	BSF STATUS, RP0
036F  1DC4  	BTFSS FCD_LCDDis_0007A_1_pt,3
0370  2B73  	GOTO	label34

		    FC_CAL_Bit_High(LCD_3__PORT3, LCD_3__BIT3);
0371  1283  	BCF STATUS, RP0
0372  1686  	BSF gbl_portb,5

		if (mask)
0373  1683  	BSF STATUS, RP0
0374  08C3  	MOVF FCD_LCDDis_0007A_arg_mask, F
0375  1903  	BTFSC STATUS,Z
0376  2B79  	GOTO	label35

		    FC_CAL_Bit_High(LCD_3__PORT4, LCD_3__RS);
0377  1283  	BCF STATUS, RP0
0378  1406  	BSF gbl_portb,0

		LCD_3__DELAY;
0379  300A  	MOVLW 0x0A
037A  1683  	BSF STATUS, RP0
037B  00C5  	MOVWF delay_10us_00000_arg_del
037C  2041  	CALL delay_10us_00000

		FC_CAL_Bit_High (LCD_3__PORT5, LCD_3__E);
037D  1283  	BCF STATUS, RP0
037E  1486  	BSF gbl_portb,1

		LCD_3__DELAY;
037F  300A  	MOVLW 0x0A
0380  1683  	BSF STATUS, RP0
0381  00C5  	MOVWF delay_10us_00000_arg_del
0382  2041  	CALL delay_10us_00000

		FC_CAL_Bit_Low (LCD_3__PORT5, LCD_3__E);
0383  1283  	BCF STATUS, RP0
0384  1086  	BCF gbl_portb,1

		pt = (in & 0x0f);
0385  300F  	MOVLW 0x0F
0386  1683  	BSF STATUS, RP0
0387  0542  	ANDWF FCD_LCDDis_0007A_arg_in, W
0388  00C4  	MOVWF FCD_LCDDis_0007A_1_pt

		LCD_3__DELAY;
0389  300A  	MOVLW 0x0A
038A  00C5  	MOVWF delay_10us_00000_arg_del
038B  2041  	CALL delay_10us_00000

		FC_CAL_Bit_Low(LCD_3__PORT0, LCD_3__BIT0);
038C  1283  	BCF STATUS, RP0
038D  1106  	BCF gbl_portb,2

		FC_CAL_Bit_Low(LCD_3__PORT1, LCD_3__BIT1);
038E  1186  	BCF gbl_portb,3

		FC_CAL_Bit_Low(LCD_3__PORT2, LCD_3__BIT2);
038F  1206  	BCF gbl_portb,4

		FC_CAL_Bit_Low(LCD_3__PORT3, LCD_3__BIT3);
0390  1286  	BCF gbl_portb,5

		FC_CAL_Bit_Low(LCD_3__PORT4, LCD_3__RS);
0391  1006  	BCF gbl_portb,0

		FC_CAL_Bit_Low(LCD_3__PORT5, LCD_3__E);
0392  1086  	BCF gbl_portb,1

		if (pt & 0x01)
0393  1683  	BSF STATUS, RP0
0394  1C44  	BTFSS FCD_LCDDis_0007A_1_pt,0
0395  2B98  	GOTO	label36

		    FC_CAL_Bit_High(LCD_3__PORT0, LCD_3__BIT0);
0396  1283  	BCF STATUS, RP0
0397  1506  	BSF gbl_portb,2

		if (pt & 0x02)
0398  1683  	BSF STATUS, RP0
0399  1CC4  	BTFSS FCD_LCDDis_0007A_1_pt,1
039A  2B9D  	GOTO	label37

		    FC_CAL_Bit_High(LCD_3__PORT1, LCD_3__BIT1);
039B  1283  	BCF STATUS, RP0
039C  1586  	BSF gbl_portb,3

		if (pt & 0x04)
039D  1683  	BSF STATUS, RP0
039E  1D44  	BTFSS FCD_LCDDis_0007A_1_pt,2
039F  2BA2  	GOTO	label38

		    FC_CAL_Bit_High(LCD_3__PORT2, LCD_3__BIT2);
03A0  1283  	BCF STATUS, RP0
03A1  1606  	BSF gbl_portb,4

		if (pt & 0x08)
03A2  1683  	BSF STATUS, RP0
03A3  1DC4  	BTFSS FCD_LCDDis_0007A_1_pt,3
03A4  2BA7  	GOTO	label39

		    FC_CAL_Bit_High(LCD_3__PORT3, LCD_3__BIT3);
03A5  1283  	BCF STATUS, RP0
03A6  1686  	BSF gbl_portb,5

		if (mask)
03A7  1683  	BSF STATUS, RP0
03A8  08C3  	MOVF FCD_LCDDis_0007A_arg_mask, F
03A9  1903  	BTFSC STATUS,Z
03AA  2BAD  	GOTO	label40

		    FC_CAL_Bit_High(LCD_3__PORT4, LCD_3__RS);
03AB  1283  	BCF STATUS, RP0
03AC  1406  	BSF gbl_portb,0

		LCD_3__DELAY;
03AD  300A  	MOVLW 0x0A
03AE  1683  	BSF STATUS, RP0
03AF  00C5  	MOVWF delay_10us_00000_arg_del
03B0  2041  	CALL delay_10us_00000

		FC_CAL_Bit_High (LCD_3__PORT5, LCD_3__E);
03B1  1283  	BCF STATUS, RP0
03B2  1486  	BSF gbl_portb,1

		LCD_3__DELAY;
03B3  300A  	MOVLW 0x0A
03B4  1683  	BSF STATUS, RP0
03B5  00C5  	MOVWF delay_10us_00000_arg_del
03B6  2041  	CALL delay_10us_00000

		FC_CAL_Bit_Low (LCD_3__PORT5, LCD_3__E);
03B7  1283  	BCF STATUS, RP0
03B8  1086  	BCF gbl_portb,1

		LCD_3__DELAY;
03B9  300A  	MOVLW 0x0A
03BA  1683  	BSF STATUS, RP0
03BB  00C5  	MOVWF delay_10us_00000_arg_del
03BC  2041  	CALL delay_10us_00000


}
03BD  0008  	RETURN


void FCD_LCDDisplay0_Start()

{
	
		FC_CAL_Bit_Low_DDR(LCD_3__PORT0, LCD_3__TRIS0, LCD_3__BIT0);
0646  1683  	BSF STATUS, RP0
0647  1303  	BCF STATUS, RP1
0648  1106  	BCF gbl_trisb,2
0649  1283  	BCF STATUS, RP0
064A  1106  	BCF gbl_portb,2

		FC_CAL_Bit_Low_DDR(LCD_3__PORT1, LCD_3__TRIS1, LCD_3__BIT1);
064B  1683  	BSF STATUS, RP0
064C  1186  	BCF gbl_trisb,3
064D  1283  	BCF STATUS, RP0
064E  1186  	BCF gbl_portb,3

		FC_CAL_Bit_Low_DDR(LCD_3__PORT2, LCD_3__TRIS2, LCD_3__BIT2);
064F  1683  	BSF STATUS, RP0
0650  1206  	BCF gbl_trisb,4
0651  1283  	BCF STATUS, RP0
0652  1206  	BCF gbl_portb,4

		FC_CAL_Bit_Low_DDR(LCD_3__PORT3, LCD_3__TRIS3, LCD_3__BIT3);
0653  1683  	BSF STATUS, RP0
0654  1286  	BCF gbl_trisb,5
0655  1283  	BCF STATUS, RP0
0656  1286  	BCF gbl_portb,5

		FC_CAL_Bit_Low_DDR(LCD_3__PORT4, LCD_3__TRIS4, LCD_3__RS);
0657  1683  	BSF STATUS, RP0
0658  1006  	BCF gbl_trisb,0
0659  1283  	BCF STATUS, RP0
065A  1006  	BCF gbl_portb,0

		FC_CAL_Bit_Low_DDR(LCD_3__PORT5, LCD_3__TRIS5, LCD_3__E);
065B  1683  	BSF STATUS, RP0
065C  1086  	BCF gbl_trisb,1
065D  1283  	BCF STATUS, RP0
065E  1086  	BCF gbl_portb,1


		Wdt_Delay_Ms(12);
065F  300C  	MOVLW 0x0C
0660  1683  	BSF STATUS, RP0
0661  00B3  	MOVWF Wdt_Delay__0003E_arg_delay
0662  21F4  	CALL Wdt_Delay__0003E


		FCD_LCDDisplay0_RawSend(0x33, 0);
0663  3033  	MOVLW 0x33
0664  00C2  	MOVWF FCD_LCDDis_0007A_arg_in
0665  01C3  	CLRF FCD_LCDDis_0007A_arg_mask
0666  2353  	CALL FCD_LCDDis_0007A

		Wdt_Delay_Ms(2);
0667  3002  	MOVLW 0x02
0668  00B3  	MOVWF Wdt_Delay__0003E_arg_delay
0669  21F4  	CALL Wdt_Delay__0003E

		FCD_LCDDisplay0_RawSend(0x33, 0);
066A  3033  	MOVLW 0x33
066B  00C2  	MOVWF FCD_LCDDis_0007A_arg_in
066C  01C3  	CLRF FCD_LCDDis_0007A_arg_mask
066D  2353  	CALL FCD_LCDDis_0007A

		Wdt_Delay_Ms(2);
066E  3002  	MOVLW 0x02
066F  00B3  	MOVWF Wdt_Delay__0003E_arg_delay
0670  21F4  	CALL Wdt_Delay__0003E

		FCD_LCDDisplay0_RawSend(0x32, 0);
0671  3032  	MOVLW 0x32
0672  00C2  	MOVWF FCD_LCDDis_0007A_arg_in
0673  01C3  	CLRF FCD_LCDDis_0007A_arg_mask
0674  2353  	CALL FCD_LCDDis_0007A

		Wdt_Delay_Ms(2);
0675  3002  	MOVLW 0x02
0676  00B3  	MOVWF Wdt_Delay__0003E_arg_delay
0677  21F4  	CALL Wdt_Delay__0003E

		FCD_LCDDisplay0_RawSend(0x2c, 0);
0678  302C  	MOVLW 0x2C
0679  00C2  	MOVWF FCD_LCDDis_0007A_arg_in
067A  01C3  	CLRF FCD_LCDDis_0007A_arg_mask
067B  2353  	CALL FCD_LCDDis_0007A

		Wdt_Delay_Ms(2);
067C  3002  	MOVLW 0x02
067D  00B3  	MOVWF Wdt_Delay__0003E_arg_delay
067E  21F4  	CALL Wdt_Delay__0003E

		FCD_LCDDisplay0_RawSend(0x06, 0);
067F  3006  	MOVLW 0x06
0680  00C2  	MOVWF FCD_LCDDis_0007A_arg_in
0681  01C3  	CLRF FCD_LCDDis_0007A_arg_mask
0682  2353  	CALL FCD_LCDDis_0007A

		Wdt_Delay_Ms(2);
0683  3002  	MOVLW 0x02
0684  00B3  	MOVWF Wdt_Delay__0003E_arg_delay
0685  21F4  	CALL Wdt_Delay__0003E

		FCD_LCDDisplay0_RawSend(0x0c, 0);
0686  300C  	MOVLW 0x0C
0687  00C2  	MOVWF FCD_LCDDis_0007A_arg_in
0688  01C3  	CLRF FCD_LCDDis_0007A_arg_mask
0689  2353  	CALL FCD_LCDDis_0007A

		Wdt_Delay_Ms(2);
068A  3002  	MOVLW 0x02
068B  00B3  	MOVWF Wdt_Delay__0003E_arg_delay
068C  21F4  	CALL Wdt_Delay__0003E


		//clear the display
		FCD_LCDDisplay0_RawSend(0x01, 0);
068D  3001  	MOVLW 0x01
068E  00C2  	MOVWF FCD_LCDDis_0007A_arg_in
068F  01C3  	CLRF FCD_LCDDis_0007A_arg_mask
0690  2353  	CALL FCD_LCDDis_0007A

		Wdt_Delay_Ms(2);
0691  3002  	MOVLW 0x02
0692  00B3  	MOVWF Wdt_Delay__0003E_arg_delay
0693  21F4  	CALL Wdt_Delay__0003E

		FCD_LCDDisplay0_RawSend(0x02, 0);
0694  3002  	MOVLW 0x02
0695  00C2  	MOVWF FCD_LCDDis_0007A_arg_in
0696  01C3  	CLRF FCD_LCDDis_0007A_arg_mask
0697  2353  	CALL FCD_LCDDis_0007A

		Wdt_Delay_Ms(2);
0698  3002  	MOVLW 0x02
0699  00B3  	MOVWF Wdt_Delay__0003E_arg_delay
069A  21F4  	CALL Wdt_Delay__0003E


}
069B  0008  	RETURN


void FCD_LCDDisplay0_Clear()

{
	
		FCD_LCDDisplay0_RawSend(0x01, 0);
0635  3001  	MOVLW 0x01
0636  1683  	BSF STATUS, RP0
0637  1303  	BCF STATUS, RP1
0638  00C2  	MOVWF FCD_LCDDis_0007A_arg_in
0639  01C3  	CLRF FCD_LCDDis_0007A_arg_mask
063A  2353  	CALL FCD_LCDDis_0007A

		Wdt_Delay_Ms(2);
063B  3002  	MOVLW 0x02
063C  00B3  	MOVWF Wdt_Delay__0003E_arg_delay
063D  21F4  	CALL Wdt_Delay__0003E

		FCD_LCDDisplay0_RawSend(0x02, 0);
063E  3002  	MOVLW 0x02
063F  00C2  	MOVWF FCD_LCDDis_0007A_arg_in
0640  01C3  	CLRF FCD_LCDDis_0007A_arg_mask
0641  2353  	CALL FCD_LCDDis_0007A

		Wdt_Delay_Ms(2);
0642  3002  	MOVLW 0x02
0643  00B3  	MOVWF Wdt_Delay__0003E_arg_delay
0644  21F4  	CALL Wdt_Delay__0003E


}
0645  0008  	RETURN


void FCD_LCDDisplay0_PrintASCII(MX_UINT8 Character)
{
	
		FCD_LCDDisplay0_RawSend(Character, 0x10);

}

void FCD_LCDDisplay0_Command(MX_UINT8 in)
{
	
		FCD_LCDDisplay0_RawSend(in, 0);
		Wdt_Delay_Ms(2);

}

void FCD_LCDDisplay0_Cursor(MX_UINT8 x, MX_UINT8 y)

{
	
	  #if (LCD_3__ROWCNT == 1)
	    y=0x80;
	  #endif

	  #if (LCD_3__ROWCNT == 2)
		if (y==0)
			y=0x80;
		else
			y=0xc0;
	  #endif

	  #if (LCD_3__ROWCNT == 4)
		if (y==0)
0617  08B2  	MOVF FCD_LCDDis_0007F_arg_y, F
0618  1D03  	BTFSS STATUS,Z
0619  2E1D  	GOTO	label68
061D        label68

			y=0x80;
061A  3080  	MOVLW 0x80
061B  00B2  	MOVWF FCD_LCDDis_0007F_arg_y

		else if (y==1)
061C  2E2C  	GOTO	label71
061D  0332  	DECF FCD_LCDDis_0007F_arg_y, W
061E  1D03  	BTFSS STATUS,Z
061F  2E23  	GOTO	label69
0623        label69

			y=0xc0;
0620  30C0  	MOVLW 0xC0
0621  00B2  	MOVWF FCD_LCDDis_0007F_arg_y


		#if (LCD_3__COLCNT == 16)
			else if (y==2)
0622  2E2C  	GOTO	label71
0623  0832  	MOVF FCD_LCDDis_0007F_arg_y, W
0624  3A02  	XORLW 0x02
0625  1D03  	BTFSS STATUS,Z
0626  2E2A  	GOTO	label70
062A        label70

				y=0x90;
0627  3090  	MOVLW 0x90
0628  00B2  	MOVWF FCD_LCDDis_0007F_arg_y

			else
0629  2E2C  	GOTO	label71
062C        label71

				y=0xd0;
062A  30D0  	MOVLW 0xD0
062B  00B2  	MOVWF FCD_LCDDis_0007F_arg_y

		#endif

		#if (LCD_3__COLCNT == 20)
			else if (y==2)
				y=0x94;
			else
				y=0xd4;
		#endif
	  #endif

		FCD_LCDDisplay0_RawSend(y+x, 0);
062C  0831  	MOVF FCD_LCDDis_0007F_arg_x, W
062D  0732  	ADDWF FCD_LCDDis_0007F_arg_y, W
062E  00C2  	MOVWF FCD_LCDDis_0007A_arg_in
062F  01C3  	CLRF FCD_LCDDis_0007A_arg_mask
0630  2353  	CALL FCD_LCDDis_0007A

		Wdt_Delay_Ms(2);
0631  3002  	MOVLW 0x02
0632  00B3  	MOVWF Wdt_Delay__0003E_arg_delay
0633  21F4  	CALL Wdt_Delay__0003E


}
0634  0008  	RETURN


void FCD_LCDDisplay0_PrintNumber(MX_SINT16 Number)

{
	
		MX_SINT16 tmp_int;
		MX_UINT8 tmp_byte;

		if (Number < 0)
0529  1FB2  	BTFSS FCD_LCDDis_00080_arg_Number+D'1',7
052A  2D38  	GOTO	label47
0538        label47

		{
			FCD_LCDDisplay0_RawSend('-', 0x10);
052B  302D  	MOVLW 0x2D
052C  00C2  	MOVWF FCD_LCDDis_0007A_arg_in
052D  3010  	MOVLW 0x10
052E  00C3  	MOVWF FCD_LCDDis_0007A_arg_mask
052F  2353  	CALL FCD_LCDDis_0007A

			Number = 0 - Number;
0530  0831  	MOVF FCD_LCDDis_00080_arg_Number, W
0531  3C00  	SUBLW 0x00
0532  00B6  	MOVWF CompTempVar2268
0533  09B2  	COMF FCD_LCDDis_00080_arg_Number+D'1', F
0534  1803  	BTFSC STATUS,C
0535  0AB2  	INCF FCD_LCDDis_00080_arg_Number+D'1', F
0536  0836  	MOVF CompTempVar2268, W
0537  00B1  	MOVWF FCD_LCDDis_00080_arg_Number

		}

		tmp_int = Number;
0538  0831  	MOVF FCD_LCDDis_00080_arg_Number, W
0539  00B3  	MOVWF FCD_LCDDis_00080_1_tmp_int
053A  0832  	MOVF FCD_LCDDis_00080_arg_Number+D'1', W
053B  00B4  	MOVWF FCD_LCDDis_00080_1_tmp_int+D'1'

		if (Number >= 10000)
053C  3027  	MOVLW 0x27
053D  0232  	SUBWF FCD_LCDDis_00080_arg_Number+D'1', W
053E  1D03  	BTFSS STATUS,Z
053F  2D42  	GOTO	label48
0540  3010  	MOVLW 0x10
0541  0231  	SUBWF FCD_LCDDis_00080_arg_Number, W
0542        label48
0542  1C03  	BTFSS STATUS,C
0543  2D70  	GOTO	label52
0544  1BB2  	BTFSC FCD_LCDDis_00080_arg_Number+D'1',7
0545  2D70  	GOTO	label52

		{
			tmp_byte = tmp_int / 10000;
0546  01BA  	CLRF CompTempVar2271
0547  0833  	MOVF FCD_LCDDis_00080_1_tmp_int, W
0548  00B6  	MOVWF __div_16_1_00003_arg_a
0549  0834  	MOVF FCD_LCDDis_00080_1_tmp_int+D'1', W
054A  00B7  	MOVWF __div_16_1_00003_arg_a+D'1'
054B  1FB4  	BTFSS FCD_LCDDis_00080_1_tmp_int+D'1',7
054C  2D53  	GOTO	label49
054D  09B6  	COMF __div_16_1_00003_arg_a, F
054E  09B7  	COMF __div_16_1_00003_arg_a+D'1', F
054F  0AB6  	INCF __div_16_1_00003_arg_a, F
0550  1903  	BTFSC STATUS,Z
0551  0AB7  	INCF __div_16_1_00003_arg_a+D'1', F
0552  0ABA  	INCF CompTempVar2271, F
0553        label49
0553  3010  	MOVLW 0x10
0554  00B8  	MOVWF __div_16_1_00003_arg_b
0555  3027  	MOVLW 0x27
0556  00B9  	MOVWF __div_16_1_00003_arg_b+D'1'
0557  21D5  	CALL __div_16_1_00003
0558  083F  	MOVF CompTempVarRet214, W
0559  00B5  	MOVWF FCD_LCDDis_00080_1_tmp_byte
055A  1C3A  	BTFSS CompTempVar2271,0
055B  2D5E  	GOTO	label50
055C  09B5  	COMF FCD_LCDDis_00080_1_tmp_byte, F
055D  0AB5  	INCF FCD_LCDDis_00080_1_tmp_byte, F
055E        label50

			FCD_LCDDisplay0_RawSend('0' + tmp_byte, 0x10);
055E  0835  	MOVF FCD_LCDDis_00080_1_tmp_byte, W
055F  3E30  	ADDLW 0x30
0560  00C2  	MOVWF FCD_LCDDis_0007A_arg_in
0561  3010  	MOVLW 0x10
0562  00C3  	MOVWF FCD_LCDDis_0007A_arg_mask
0563  2353  	CALL FCD_LCDDis_0007A


			while (tmp_byte > 0)
0564        label51
0564  0835  	MOVF FCD_LCDDis_00080_1_tmp_byte, W
0565  3C00  	SUBLW 0x00
0566  1803  	BTFSC STATUS,C
0567  2D70  	GOTO	label52
056F  2D64  	GOTO	label51
0570        label52

			{
				tmp_int = tmp_int - 10000;
0568  3010  	MOVLW 0x10
0569  02B3  	SUBWF FCD_LCDDis_00080_1_tmp_int, F
056A  3027  	MOVLW 0x27
056B  1C03  	BTFSS STATUS,C
056C  3028  	MOVLW 0x28
056D  02B4  	SUBWF FCD_LCDDis_00080_1_tmp_int+D'1', F

				tmp_byte--;
056E  03B5  	DECF FCD_LCDDis_00080_1_tmp_byte, F

			}
		}
		if (Number >= 1000)
0570  3003  	MOVLW 0x03
0571  0232  	SUBWF FCD_LCDDis_00080_arg_Number+D'1', W
0572  1D03  	BTFSS STATUS,Z
0573  2D76  	GOTO	label53
0574  30E8  	MOVLW 0xE8
0575  0231  	SUBWF FCD_LCDDis_00080_arg_Number, W
0576        label53
0576  1C03  	BTFSS STATUS,C
0577  2DA6  	GOTO	label57
0578  1BB2  	BTFSC FCD_LCDDis_00080_arg_Number+D'1',7
0579  2DA6  	GOTO	label57

		{
			tmp_byte = tmp_int / 1000;
057A  01BB  	CLRF CompTempVar2275
057B  0833  	MOVF FCD_LCDDis_00080_1_tmp_int, W
057C  00B6  	MOVWF __div_16_1_00003_arg_a
057D  0834  	MOVF FCD_LCDDis_00080_1_tmp_int+D'1', W
057E  00B7  	MOVWF __div_16_1_00003_arg_a+D'1'
057F  1FB4  	BTFSS FCD_LCDDis_00080_1_tmp_int+D'1',7
0580  2D87  	GOTO	label54
0581  09B6  	COMF __div_16_1_00003_arg_a, F
0582  09B7  	COMF __div_16_1_00003_arg_a+D'1', F
0583  0AB6  	INCF __div_16_1_00003_arg_a, F
0584  1903  	BTFSC STATUS,Z
0585  0AB7  	INCF __div_16_1_00003_arg_a+D'1', F
0586  0ABB  	INCF CompTempVar2275, F
0587        label54
0587  30E8  	MOVLW 0xE8
0588  00B8  	MOVWF __div_16_1_00003_arg_b
0589  3003  	MOVLW 0x03
058A  00B9  	MOVWF __div_16_1_00003_arg_b+D'1'
058B  21D5  	CALL __div_16_1_00003
058C  083F  	MOVF CompTempVarRet214, W
058D  00BA  	MOVWF CompTempVar2274
058E  1C3B  	BTFSS CompTempVar2275,0
058F  2D92  	GOTO	label55
0590  09BA  	COMF CompTempVar2274, F
0591  0ABA  	INCF CompTempVar2274, F
0592        label55
0592  083A  	MOVF CompTempVar2274, W
0593  00B5  	MOVWF FCD_LCDDis_00080_1_tmp_byte

			FCD_LCDDisplay0_RawSend('0' + tmp_byte, 0x10);
0594  0835  	MOVF FCD_LCDDis_00080_1_tmp_byte, W
0595  3E30  	ADDLW 0x30
0596  00C2  	MOVWF FCD_LCDDis_0007A_arg_in
0597  3010  	MOVLW 0x10
0598  00C3  	MOVWF FCD_LCDDis_0007A_arg_mask
0599  2353  	CALL FCD_LCDDis_0007A


			while (tmp_byte > 0)
059A        label56
059A  0835  	MOVF FCD_LCDDis_00080_1_tmp_byte, W
059B  3C00  	SUBLW 0x00
059C  1803  	BTFSC STATUS,C
059D  2DA6  	GOTO	label57
05A5  2D9A  	GOTO	label56
05A6        label57

			{
				tmp_int = tmp_int - 1000;
059E  30E8  	MOVLW 0xE8
059F  02B3  	SUBWF FCD_LCDDis_00080_1_tmp_int, F
05A0  3003  	MOVLW 0x03
05A1  1C03  	BTFSS STATUS,C
05A2  3004  	MOVLW 0x04
05A3  02B4  	SUBWF FCD_LCDDis_00080_1_tmp_int+D'1', F

				tmp_byte--;
05A4  03B5  	DECF FCD_LCDDis_00080_1_tmp_byte, F

			}
		}
		if (Number >= 100)
05A6  0832  	MOVF FCD_LCDDis_00080_arg_Number+D'1', W
05A7  3A80  	XORLW 0x80
05A8  00B6  	MOVWF CompTempVar2278
05A9  3080  	MOVLW 0x80
05AA  0236  	SUBWF CompTempVar2278, W
05AB  1D03  	BTFSS STATUS,Z
05AC  2DAF  	GOTO	label58
05AD  3064  	MOVLW 0x64
05AE  0231  	SUBWF FCD_LCDDis_00080_arg_Number, W
05AF        label58
05AF  1C03  	BTFSS STATUS,C
05B0  2DDB  	GOTO	label62

		{
			tmp_byte = tmp_int / 100;
05B1  01BB  	CLRF CompTempVar2280
05B2  0833  	MOVF FCD_LCDDis_00080_1_tmp_int, W
05B3  00B6  	MOVWF __div_16_1_00003_arg_a
05B4  0834  	MOVF FCD_LCDDis_00080_1_tmp_int+D'1', W
05B5  00B7  	MOVWF __div_16_1_00003_arg_a+D'1'
05B6  1FB4  	BTFSS FCD_LCDDis_00080_1_tmp_int+D'1',7
05B7  2DBE  	GOTO	label59
05B8  09B6  	COMF __div_16_1_00003_arg_a, F
05B9  09B7  	COMF __div_16_1_00003_arg_a+D'1', F
05BA  0AB6  	INCF __div_16_1_00003_arg_a, F
05BB  1903  	BTFSC STATUS,Z
05BC  0AB7  	INCF __div_16_1_00003_arg_a+D'1', F
05BD  0ABB  	INCF CompTempVar2280, F
05BE        label59
05BE  3064  	MOVLW 0x64
05BF  00B8  	MOVWF __div_16_1_00003_arg_b
05C0  01B9  	CLRF __div_16_1_00003_arg_b+D'1'
05C1  21D5  	CALL __div_16_1_00003
05C2  083F  	MOVF CompTempVarRet214, W
05C3  00BA  	MOVWF CompTempVar2279
05C4  1C3B  	BTFSS CompTempVar2280,0
05C5  2DC8  	GOTO	label60
05C6  09BA  	COMF CompTempVar2279, F
05C7  0ABA  	INCF CompTempVar2279, F
05C8        label60
05C8  083A  	MOVF CompTempVar2279, W
05C9  00B5  	MOVWF FCD_LCDDis_00080_1_tmp_byte

			FCD_LCDDisplay0_RawSend('0' + tmp_byte, 0x10);
05CA  0835  	MOVF FCD_LCDDis_00080_1_tmp_byte, W
05CB  3E30  	ADDLW 0x30
05CC  00C2  	MOVWF FCD_LCDDis_0007A_arg_in
05CD  3010  	MOVLW 0x10
05CE  00C3  	MOVWF FCD_LCDDis_0007A_arg_mask
05CF  2353  	CALL FCD_LCDDis_0007A


			while (tmp_byte > 0)
05D0        label61
05D0  0835  	MOVF FCD_LCDDis_00080_1_tmp_byte, W
05D1  3C00  	SUBLW 0x00
05D2  1803  	BTFSC STATUS,C
05D3  2DDB  	GOTO	label62
05DA  2DD0  	GOTO	label61
05DB        label62

			{
				tmp_int = tmp_int - 100;
05D4  3064  	MOVLW 0x64
05D5  02B3  	SUBWF FCD_LCDDis_00080_1_tmp_int, F
05D6  08B4  	MOVF FCD_LCDDis_00080_1_tmp_int+D'1', F
05D7  1C03  	BTFSS STATUS,C
05D8  03B4  	DECF FCD_LCDDis_00080_1_tmp_int+D'1', F

				tmp_byte--;
05D9  03B5  	DECF FCD_LCDDis_00080_1_tmp_byte, F

			}
		}
		if (Number >= 10)
05DB  0832  	MOVF FCD_LCDDis_00080_arg_Number+D'1', W
05DC  3A80  	XORLW 0x80
05DD  00B6  	MOVWF CompTempVar2283
05DE  3080  	MOVLW 0x80
05DF  0236  	SUBWF CompTempVar2283, W
05E0  1D03  	BTFSS STATUS,Z
05E1  2DE4  	GOTO	label63
05E2  300A  	MOVLW 0x0A
05E3  0231  	SUBWF FCD_LCDDis_00080_arg_Number, W
05E4        label63
05E4  1C03  	BTFSS STATUS,C
05E5  2E10  	GOTO	label67

		{
			tmp_byte = tmp_int / 10;
05E6  01BB  	CLRF CompTempVar2285
05E7  0833  	MOVF FCD_LCDDis_00080_1_tmp_int, W
05E8  00B6  	MOVWF __div_16_1_00003_arg_a
05E9  0834  	MOVF FCD_LCDDis_00080_1_tmp_int+D'1', W
05EA  00B7  	MOVWF __div_16_1_00003_arg_a+D'1'
05EB  1FB4  	BTFSS FCD_LCDDis_00080_1_tmp_int+D'1',7
05EC  2DF3  	GOTO	label64
05ED  09B6  	COMF __div_16_1_00003_arg_a, F
05EE  09B7  	COMF __div_16_1_00003_arg_a+D'1', F
05EF  0AB6  	INCF __div_16_1_00003_arg_a, F
05F0  1903  	BTFSC STATUS,Z
05F1  0AB7  	INCF __div_16_1_00003_arg_a+D'1', F
05F2  0ABB  	INCF CompTempVar2285, F
05F3        label64
05F3  300A  	MOVLW 0x0A
05F4  00B8  	MOVWF __div_16_1_00003_arg_b
05F5  01B9  	CLRF __div_16_1_00003_arg_b+D'1'
05F6  21D5  	CALL __div_16_1_00003
05F7  083F  	MOVF CompTempVarRet214, W
05F8  00BA  	MOVWF CompTempVar2284
05F9  1C3B  	BTFSS CompTempVar2285,0
05FA  2DFD  	GOTO	label65
05FB  09BA  	COMF CompTempVar2284, F
05FC  0ABA  	INCF CompTempVar2284, F
05FD        label65
05FD  083A  	MOVF CompTempVar2284, W
05FE  00B5  	MOVWF FCD_LCDDis_00080_1_tmp_byte

			FCD_LCDDisplay0_RawSend('0' + tmp_byte, 0x10);
05FF  0835  	MOVF FCD_LCDDis_00080_1_tmp_byte, W
0600  3E30  	ADDLW 0x30
0601  00C2  	MOVWF FCD_LCDDis_0007A_arg_in
0602  3010  	MOVLW 0x10
0603  00C3  	MOVWF FCD_LCDDis_0007A_arg_mask
0604  2353  	CALL FCD_LCDDis_0007A


			while (tmp_byte > 0)
0605        label66
0605  0835  	MOVF FCD_LCDDis_00080_1_tmp_byte, W
0606  3C00  	SUBLW 0x00
0607  1803  	BTFSC STATUS,C
0608  2E10  	GOTO	label67
060F  2E05  	GOTO	label66
0610        label67

			{
				tmp_int = tmp_int - 10;
0609  300A  	MOVLW 0x0A
060A  02B3  	SUBWF FCD_LCDDis_00080_1_tmp_int, F
060B  08B4  	MOVF FCD_LCDDis_00080_1_tmp_int+D'1', F
060C  1C03  	BTFSS STATUS,C
060D  03B4  	DECF FCD_LCDDis_00080_1_tmp_int+D'1', F

				tmp_byte--;
060E  03B5  	DECF FCD_LCDDis_00080_1_tmp_byte, F

			}
		}
		FCD_LCDDisplay0_RawSend('0' + tmp_int, 0x10);
0610  0833  	MOVF FCD_LCDDis_00080_1_tmp_int, W
0611  3E30  	ADDLW 0x30
0612  00C2  	MOVWF FCD_LCDDis_0007A_arg_in
0613  3010  	MOVLW 0x10
0614  00C3  	MOVWF FCD_LCDDis_0007A_arg_mask
0615  2353  	CALL FCD_LCDDis_0007A


}
0616  0008  	RETURN


void FCD_LCDDisplay0_PrintString(MX_STRING String, MX_UINT8 MSZ_String)

{
	
		MX_UINT8 idx = 0;
050D  01C1  	CLRF FCD_LCDDis_00081_1_idx


		for (idx=0; idx<MSZ_String; idx++)
050E  01C1  	CLRF FCD_LCDDis_00081_1_idx
050F        label46
050F  0840  	MOVF FCD_LCDDis_00081_arg_MSZ_String, W
0510  0241  	SUBWF FCD_LCDDis_00081_1_idx, W
0511  1803  	BTFSC STATUS,C
0527  0AC1  	INCF FCD_LCDDis_00081_1_idx, F
0528  2D0F  	GOTO	label46

		{
			if (String[idx] == 0)
0513  1383  	BCF STATUS,IRP
0514  1832  	BTFSC FCD_LCDDis_00081_arg_String+D'1',0
0515  1783  	BSF STATUS,IRP
0516  0831  	MOVF FCD_LCDDis_00081_arg_String, W
0517  0741  	ADDWF FCD_LCDDis_00081_1_idx, W
0518  0084  	MOVWF FSR
0519  0880  	MOVF INDF, F
051A  1903  	BTFSC STATUS,Z

			{
				break;

			}
			FCD_LCDDisplay0_RawSend(String[idx], 0x10);
051C  1383  	BCF STATUS,IRP
051D  1832  	BTFSC FCD_LCDDis_00081_arg_String+D'1',0
051E  1783  	BSF STATUS,IRP
051F  0831  	MOVF FCD_LCDDis_00081_arg_String, W
0520  0741  	ADDWF FCD_LCDDis_00081_1_idx, W
0521  0084  	MOVWF FSR
0522  0800  	MOVF INDF, W
0523  00C2  	MOVWF FCD_LCDDis_0007A_arg_in
0524  3010  	MOVLW 0x10
0525  00C3  	MOVWF FCD_LCDDis_0007A_arg_mask
0526  2353  	CALL FCD_LCDDis_0007A

		}

}
0512  0008  	RETURN
051B  0008  	RETURN


void FCD_LCDDisplay0_ScrollDisplay(MX_UINT8 Direction, MX_UINT8 Num_Positions)
{
	
		MX_UINT8 cmd = 0;
		MX_UINT8 count;

		//Choose the direction
		switch (Direction)
		{
			case 0:
			case 'l':
			case 'L':

				cmd = 0x18;
				break;

			case 1:
			case 'r':
			case 'R':

				cmd = 0x1C;
				break;

			default:
				break;
		}

		//If direction accepted then scroll the specified amount
		if (cmd)
		{
			for (count = 0; count < Num_Positions; count++)
				FCD_LCDDisplay0_Command(cmd);
		}

}

void FCD_LCDDisplay0_ClearLine(MX_UINT8 Line)
{
	
		MX_UINT8 count;
		MX_UINT8 rowcount;

		//Define number of columns per line
		#if (LCD_3__ROWCNT == 1)
			rowcount=80;
		#endif

		#if (LCD_3__ROWCNT == 2)
			rowcount=40;
		#endif

		#if (LCD_3__ROWCNT == 4)
			#if (LCD_3__COLCNT == 16)
				rowcount=16;
			#endif
			#if (LCD_3__COLCNT == 20)
				rowcount=20;
			#endif
		#endif

		//Start at beginning of the line
		FCD_LCDDisplay0_Cursor (0, Line);

		//Send out spaces to clear line
		for (count = 0; count < rowcount; count++)
			FCD_LCDDisplay0_RawSend(' ', 0x10);

		//Move back to the beginning of the line.
		FCD_LCDDisplay0_Cursor (0, Line);

}

void FCD_LCDDisplay0_RAM_Write(MX_UINT8 nIdx, MX_UINT8 d0, MX_UINT8 d1, MX_UINT8 d2, MX_UINT8 d3, MX_UINT8 d4, MX_UINT8 d5, MX_UINT8 d6, MX_UINT8 d7)
{
	   //set CGRAM address

	   FCD_LCDDisplay0_RawSend(64 + (nIdx << 3), 0);
	   delay_ms(2);

	   //write CGRAM data
	   FCD_LCDDisplay0_RawSend(d0, 0x10);
	   FCD_LCDDisplay0_RawSend(d1, 0x10);
	   FCD_LCDDisplay0_RawSend(d2, 0x10);
	   FCD_LCDDisplay0_RawSend(d3, 0x10);
	   FCD_LCDDisplay0_RawSend(d4, 0x10);
	   FCD_LCDDisplay0_RawSend(d5, 0x10);
	   FCD_LCDDisplay0_RawSend(d6, 0x10);
	   FCD_LCDDisplay0_RawSend(d7, 0x10);

	   //Clear the display
	   FCD_LCDDisplay0_RawSend(0x01, 0);
	   delay_ms(2);
	   FCD_LCDDisplay0_RawSend(0x02, 0);
	   delay_ms(2);

}

#include "C:\Program Files (x86)\Flowcode\v5\CAL\includes.c"

//Macro implementations


void FCM_cmd_write_reg()

{

	//CSN
	//Output: 0 -> C2
	trisc = trisc & 0xFB;
031E  30FB  	MOVLW 0xFB
031F  1683  	BSF STATUS, RP0
0320  1303  	BCF STATUS, RP1
0321  0507  	ANDWF gbl_trisc, W
0322  0087  	MOVWF gbl_trisc

	if ((0))
		portc = (portc & 0xFB) | 0x04;
	else
		portc = portc & 0xFB;
0323  30FB  	MOVLW 0xFB
0324  1283  	BCF STATUS, RP0
0325  0507  	ANDWF gbl_portc, W
0326  0087  	MOVWF gbl_portc


	//Calculation
	//Calculation:
	//  spi_data0 = reg_to_write + 0x20
	FCV_SPI_DATA0 = FCV_REG_TO_WRITE + 0x20;
0327  3020  	MOVLW 0x20
0328  1683  	BSF STATUS, RP0
0329  072A  	ADDWF gbl_FCV_REG_TO_WRITE, W
032A  1283  	BCF STATUS, RP0
032B  00F9  	MOVWF gbl_FCV_SPI_DATA0


	//Call Component Macro
	//Call Component Macro: SPI_Send_Char(spi_data0)
	FCD_SPI_Legacy0_SPI_Send_Char(FCV_SPI_DATA0);
032C  0879  	MOVF gbl_FCV_SPI_DATA0, W
032D  1683  	BSF STATUS, RP0
032E  00B1  	MOVWF FCD_SPI_Le_00052_arg_Char
032F  2068  	CALL FCD_SPI_Le_00052


	//Calculation
	//Calculation:
	//  spi_data0 = data_to_write
	FCV_SPI_DATA0 = FCV_DATA_TO_WRITE;
0330  1283  	BCF STATUS, RP0
0331  0871  	MOVF gbl_FCV_DATA_TO_WRITE, W
0332  00F9  	MOVWF gbl_FCV_SPI_DATA0


	//Call Component Macro
	//Call Component Macro: SPI_Send_Char(spi_data0)
	FCD_SPI_Legacy0_SPI_Send_Char(FCV_SPI_DATA0);
0333  0879  	MOVF gbl_FCV_SPI_DATA0, W
0334  1683  	BSF STATUS, RP0
0335  00B1  	MOVWF FCD_SPI_Le_00052_arg_Char
0336  2068  	CALL FCD_SPI_Le_00052


	//CSN
	//Output: 1 -> C2
	trisc = trisc & 0xFB;
0337  30FB  	MOVLW 0xFB
0338  0507  	ANDWF gbl_trisc, W
0339  0087  	MOVWF gbl_trisc

	if ((1))
		portc = (portc & 0xFB) | 0x04;
033A  30FB  	MOVLW 0xFB
033B  1283  	BCF STATUS, RP0
033C  0507  	ANDWF gbl_portc, W
033D  1683  	BSF STATUS, RP0
033E  00B1  	MOVWF CompTempVar2188
033F  3004  	MOVLW 0x04
0340  0431  	IORWF CompTempVar2188, W
0341  1283  	BCF STATUS, RP0
0342  0087  	MOVWF gbl_portc

	else
		portc = portc & 0xFB;

}
0343  0008  	RETURN



void FCM_cmd_read_reg()

{

	//CSN
	//Output: 0 -> C2
	trisc = trisc & 0xFB;
006C  30FB  	MOVLW 0xFB
006D  1683  	BSF STATUS, RP0
006E  1303  	BCF STATUS, RP1
006F  0507  	ANDWF gbl_trisc, W
0070  0087  	MOVWF gbl_trisc

	if ((0))
		portc = (portc & 0xFB) | 0x04;
	else
		portc = portc & 0xFB;
0071  30FB  	MOVLW 0xFB
0072  1283  	BCF STATUS, RP0
0073  0507  	ANDWF gbl_portc, W
0074  0087  	MOVWF gbl_portc


	//Call Component Macro
	//Call Component Macro: SPI_Send_Char(spi_data0)
	FCD_SPI_Legacy0_SPI_Send_Char(FCV_SPI_DATA0);
0075  0879  	MOVF gbl_FCV_SPI_DATA0, W
0076  1683  	BSF STATUS, RP0
0077  00B1  	MOVWF FCD_SPI_Le_00052_arg_Char
0078  2068  	CALL FCD_SPI_Le_00052


	//Call Component Macro
	//Call Component Macro: spi_data1=SPI_Get_Char()
	FCV_SPI_DATA1 = FCD_SPI_Legacy0_SPI_Get_Char();
0079  205D  	CALL FCD_SPI_Le_00054
007A  0832  	MOVF CompTempVarRet2190, W
007B  1283  	BCF STATUS, RP0
007C  00FC  	MOVWF gbl_FCV_SPI_DATA1


	//CSN
	//Output: 1 -> C2
	trisc = trisc & 0xFB;
007D  30FB  	MOVLW 0xFB
007E  1683  	BSF STATUS, RP0
007F  0507  	ANDWF gbl_trisc, W
0080  0087  	MOVWF gbl_trisc

	if ((1))
		portc = (portc & 0xFB) | 0x04;
0081  30FB  	MOVLW 0xFB
0082  1283  	BCF STATUS, RP0
0083  0507  	ANDWF gbl_portc, W
0084  1683  	BSF STATUS, RP0
0085  00B1  	MOVWF CompTempVar2189
0086  3004  	MOVLW 0x04
0087  0431  	IORWF CompTempVar2189, W
0088  1283  	BCF STATUS, RP0
0089  0087  	MOVWF gbl_portc

	else
		portc = portc & 0xFB;

}
008A  0008  	RETURN



void FCM_radio_init_rx()

{

	//Calculation
	//Calculation:
	//  reg_to_write = 0x00
	//  data_to_write = 0x0F
	FCV_REG_TO_WRITE = 0x00;
04C7  1683  	BSF STATUS, RP0
04C8  1303  	BCF STATUS, RP1
04C9  01AA  	CLRF gbl_FCV_REG_TO_WRITE

	FCV_DATA_TO_WRITE = 0x0F;
04CA  300F  	MOVLW 0x0F
04CB  1283  	BCF STATUS, RP0
04CC  00F1  	MOVWF gbl_FCV_DATA_TO_WRITE


	//Call Macro
	//Call Macro: cmd_write_reg()
	FCM_cmd_write_reg();
04CD  231E  	CALL FCM_cmd_wr_00051


	//Calculation
	//Calculation:
	//  reg_to_write = 01
	//  data_to_write = 0x3F
	FCV_REG_TO_WRITE = 01;
04CE  3001  	MOVLW 0x01
04CF  1683  	BSF STATUS, RP0
04D0  00AA  	MOVWF gbl_FCV_REG_TO_WRITE

	FCV_DATA_TO_WRITE = 0x3F;
04D1  303F  	MOVLW 0x3F
04D2  1283  	BCF STATUS, RP0
04D3  00F1  	MOVWF gbl_FCV_DATA_TO_WRITE


	//Call Macro
	//Call Macro: cmd_write_reg()
	FCM_cmd_write_reg();
04D4  231E  	CALL FCM_cmd_wr_00051


	//Calculation
	//Calculation:
	//  reg_to_write = 02
	//  data_to_write = 0x03
	FCV_REG_TO_WRITE = 02;
04D5  3002  	MOVLW 0x02
04D6  1683  	BSF STATUS, RP0
04D7  00AA  	MOVWF gbl_FCV_REG_TO_WRITE

	FCV_DATA_TO_WRITE = 0x03;
04D8  3003  	MOVLW 0x03
04D9  1283  	BCF STATUS, RP0
04DA  00F1  	MOVWF gbl_FCV_DATA_TO_WRITE


	//Call Macro
	//Call Macro: cmd_write_reg()
	FCM_cmd_write_reg();
04DB  231E  	CALL FCM_cmd_wr_00051


	//Calculation
	//Calculation:
	//  reg_to_write = 03
	//  data_to_write = 0x03
	FCV_REG_TO_WRITE = 03;
04DC  3003  	MOVLW 0x03
04DD  1683  	BSF STATUS, RP0
04DE  00AA  	MOVWF gbl_FCV_REG_TO_WRITE

	FCV_DATA_TO_WRITE = 0x03;
04DF  1283  	BCF STATUS, RP0
04E0  00F1  	MOVWF gbl_FCV_DATA_TO_WRITE


	//Call Macro
	//Call Macro: cmd_write_reg()
	FCM_cmd_write_reg();
04E1  231E  	CALL FCM_cmd_wr_00051


	//Calculation
	//Calculation:
	//  reg_to_write = 0x04
	//  data_to_write = 0x5F
	FCV_REG_TO_WRITE = 0x04;
04E2  3004  	MOVLW 0x04
04E3  1683  	BSF STATUS, RP0
04E4  00AA  	MOVWF gbl_FCV_REG_TO_WRITE

	FCV_DATA_TO_WRITE = 0x5F;
04E5  305F  	MOVLW 0x5F
04E6  1283  	BCF STATUS, RP0
04E7  00F1  	MOVWF gbl_FCV_DATA_TO_WRITE


	//Call Macro
	//Call Macro: cmd_write_reg()
	FCM_cmd_write_reg();
04E8  231E  	CALL FCM_cmd_wr_00051


	//Calculation
	//Calculation:
	//  reg_to_write = 0x05
	//  data_to_write = 0x4C
	FCV_REG_TO_WRITE = 0x05;
04E9  3005  	MOVLW 0x05
04EA  1683  	BSF STATUS, RP0
04EB  00AA  	MOVWF gbl_FCV_REG_TO_WRITE

	FCV_DATA_TO_WRITE = 0x4C;
04EC  304C  	MOVLW 0x4C
04ED  1283  	BCF STATUS, RP0
04EE  00F1  	MOVWF gbl_FCV_DATA_TO_WRITE


	//Call Macro
	//Call Macro: cmd_write_reg()
	FCM_cmd_write_reg();
04EF  231E  	CALL FCM_cmd_wr_00051


	//Calculation
	//Calculation:
	//  reg_to_write = 0x06
	//  data_to_write = 0x27
	FCV_REG_TO_WRITE = 0x06;
04F0  3006  	MOVLW 0x06
04F1  1683  	BSF STATUS, RP0
04F2  00AA  	MOVWF gbl_FCV_REG_TO_WRITE

	FCV_DATA_TO_WRITE = 0x27;
04F3  3027  	MOVLW 0x27
04F4  1283  	BCF STATUS, RP0
04F5  00F1  	MOVWF gbl_FCV_DATA_TO_WRITE


	//Call Macro
	//Call Macro: cmd_write_reg()
	FCM_cmd_write_reg();
04F6  231E  	CALL FCM_cmd_wr_00051


	//Calculation
	//Calculation:
	//  reg_to_write = 0x11
	//  data_to_write = payloadsize
	FCV_REG_TO_WRITE = 0x11;
04F7  3011  	MOVLW 0x11
04F8  1683  	BSF STATUS, RP0
04F9  00AA  	MOVWF gbl_FCV_REG_TO_WRITE

	FCV_DATA_TO_WRITE = FCV_PAYLOADSIZE;
04FA  082C  	MOVF gbl_FCV_PAYLOADSIZE, W
04FB  1283  	BCF STATUS, RP0
04FC  00F1  	MOVWF gbl_FCV_DATA_TO_WRITE


	//Call Macro
	//Call Macro: cmd_write_reg()
	FCM_cmd_write_reg();
04FD  231E  	CALL FCM_cmd_wr_00051


	//Call Macro
	//Call Macro: set_tx_addr()
	FCM_set_tx_addr();
04FE  2211  	CALL FCM_set_tx_00056


	//Call Macro
	//Call Macro: set_rx_addr()
	FCM_set_rx_addr();
04FF  2259  	CALL FCM_set_rx_00057


	//Call Macro
	//Call Macro: flush_fifo_txrx()
	FCM_flush_fifo_txrx();
0500  22F2  	CALL FCM_flush__00058


}
0501  0008  	RETURN



void FCM_set_rx_addr()

{

	//CSN
	//Output: 0 -> C2
	trisc = trisc & 0xFB;
0259  30FB  	MOVLW 0xFB
025A  1683  	BSF STATUS, RP0
025B  1303  	BCF STATUS, RP1
025C  0507  	ANDWF gbl_trisc, W
025D  0087  	MOVWF gbl_trisc

	if ((0))
		portc = (portc & 0xFB) | 0x04;
	else
		portc = portc & 0xFB;
025E  30FB  	MOVLW 0xFB
025F  1283  	BCF STATUS, RP0
0260  0507  	ANDWF gbl_portc, W
0261  0087  	MOVWF gbl_portc


	//Delay
	//Delay: 5 us
	delay_us(5);
0262  3005  	MOVLW 0x05
0263  1683  	BSF STATUS, RP0
0264  00B1  	MOVWF delay_us_00000_arg_del
0265  2010  	CALL delay_us_00000


	//Calculation
	//Calculation:
	//  spi_data0 = 0b00101010
	FCV_SPI_DATA0 = 42;
0266  302A  	MOVLW 0x2A
0267  1283  	BCF STATUS, RP0
0268  00F9  	MOVWF gbl_FCV_SPI_DATA0


	//Call Component Macro
	//Call Component Macro: SPI_Send_Char(spi_data0)
	FCD_SPI_Legacy0_SPI_Send_Char(FCV_SPI_DATA0);
0269  0879  	MOVF gbl_FCV_SPI_DATA0, W
026A  1683  	BSF STATUS, RP0
026B  00B1  	MOVWF FCD_SPI_Le_00052_arg_Char
026C  2068  	CALL FCD_SPI_Le_00052


	//Calculation
	//Calculation:
	//  spi_data0 = reg0A_rx_addr_p0_byte0
	FCV_SPI_DATA0 = FCV_REG0A_RX_ADDR_P0_BYTE0;
026D  0822  	MOVF gbl_FCV_REG0A_RX_ADDR_P0_BYTE0, W
026E  1283  	BCF STATUS, RP0
026F  00F9  	MOVWF gbl_FCV_SPI_DATA0


	//Call Component Macro
	//Call Component Macro: SPI_Send_Char(spi_data0)
	FCD_SPI_Legacy0_SPI_Send_Char(FCV_SPI_DATA0);
0270  0879  	MOVF gbl_FCV_SPI_DATA0, W
0271  1683  	BSF STATUS, RP0
0272  00B1  	MOVWF FCD_SPI_Le_00052_arg_Char
0273  2068  	CALL FCD_SPI_Le_00052


	//Calculation
	//Calculation:
	//  spi_data0 = reg0A_rx_addr_p0_byte1
	FCV_SPI_DATA0 = FCV_REG0A_RX_ADDR_P0_BYTE1;
0274  0826  	MOVF gbl_FCV_REG0A_RX_ADDR_P0_BYTE1, W
0275  1283  	BCF STATUS, RP0
0276  00F9  	MOVWF gbl_FCV_SPI_DATA0


	//Call Component Macro
	//Call Component Macro: SPI_Send_Char(spi_data0)
	FCD_SPI_Legacy0_SPI_Send_Char(FCV_SPI_DATA0);
0277  0879  	MOVF gbl_FCV_SPI_DATA0, W
0278  1683  	BSF STATUS, RP0
0279  00B1  	MOVWF FCD_SPI_Le_00052_arg_Char
027A  2068  	CALL FCD_SPI_Le_00052


	//Calculation
	//Calculation:
	//  spi_data0 = reg0A_rx_addr_p0_byte2
	FCV_SPI_DATA0 = FCV_REG0A_RX_ADDR_P0_BYTE2;
027B  0827  	MOVF gbl_FCV_REG0A_RX_ADDR_P0_BYTE2, W
027C  1283  	BCF STATUS, RP0
027D  00F9  	MOVWF gbl_FCV_SPI_DATA0


	//Call Component Macro
	//Call Component Macro: SPI_Send_Char(spi_data0)
	FCD_SPI_Legacy0_SPI_Send_Char(FCV_SPI_DATA0);
027E  0879  	MOVF gbl_FCV_SPI_DATA0, W
027F  1683  	BSF STATUS, RP0
0280  00B1  	MOVWF FCD_SPI_Le_00052_arg_Char
0281  2068  	CALL FCD_SPI_Le_00052


	//Calculation
	//Calculation:
	//  spi_data0 = reg0A_rx_addr_p0_byte3
	FCV_SPI_DATA0 = FCV_REG0A_RX_ADDR_P0_BYTE3;
0282  0829  	MOVF gbl_FCV_REG0A_RX_ADDR_P0_BYTE3, W
0283  1283  	BCF STATUS, RP0
0284  00F9  	MOVWF gbl_FCV_SPI_DATA0


	//Call Component Macro
	//Call Component Macro: SPI_Send_Char(spi_data0)
	FCD_SPI_Legacy0_SPI_Send_Char(FCV_SPI_DATA0);
0285  0879  	MOVF gbl_FCV_SPI_DATA0, W
0286  1683  	BSF STATUS, RP0
0287  00B1  	MOVWF FCD_SPI_Le_00052_arg_Char
0288  2068  	CALL FCD_SPI_Le_00052


	//Calculation
	//Calculation:
	//  spi_data0 = reg0A_rx_addr_p0_byte4
	FCV_SPI_DATA0 = FCV_REG0A_RX_ADDR_P0_BYTE4;
0289  082B  	MOVF gbl_FCV_REG0A_RX_ADDR_P0_BYTE4, W
028A  1283  	BCF STATUS, RP0
028B  00F9  	MOVWF gbl_FCV_SPI_DATA0


	//Call Component Macro
	//Call Component Macro: SPI_Send_Char(spi_data0)
	FCD_SPI_Legacy0_SPI_Send_Char(FCV_SPI_DATA0);
028C  0879  	MOVF gbl_FCV_SPI_DATA0, W
028D  1683  	BSF STATUS, RP0
028E  00B1  	MOVWF FCD_SPI_Le_00052_arg_Char
028F  2068  	CALL FCD_SPI_Le_00052


	//CSN
	//Output: 1 -> C2
	trisc = trisc & 0xFB;
0290  30FB  	MOVLW 0xFB
0291  0507  	ANDWF gbl_trisc, W
0292  0087  	MOVWF gbl_trisc

	if ((1))
		portc = (portc & 0xFB) | 0x04;
0293  30FB  	MOVLW 0xFB
0294  1283  	BCF STATUS, RP0
0295  0507  	ANDWF gbl_portc, W
0296  1683  	BSF STATUS, RP0
0297  00B1  	MOVWF CompTempVar2192
0298  3004  	MOVLW 0x04
0299  0431  	IORWF CompTempVar2192, W
029A  1283  	BCF STATUS, RP0
029B  0087  	MOVWF gbl_portc

	else
		portc = portc & 0xFB;

	//Delay
	//Delay: 5 us
	delay_us(5);
029C  3005  	MOVLW 0x05
029D  1683  	BSF STATUS, RP0
029E  00B1  	MOVWF delay_us_00000_arg_del
029F  2010  	CALL delay_us_00000


}
02A0  0008  	RETURN



void FCM_set_tx_addr()

{

	//CSN
	//Output: 0 -> C2
	trisc = trisc & 0xFB;
0211  30FB  	MOVLW 0xFB
0212  1683  	BSF STATUS, RP0
0213  1303  	BCF STATUS, RP1
0214  0507  	ANDWF gbl_trisc, W
0215  0087  	MOVWF gbl_trisc

	if ((0))
		portc = (portc & 0xFB) | 0x04;
	else
		portc = portc & 0xFB;
0216  30FB  	MOVLW 0xFB
0217  1283  	BCF STATUS, RP0
0218  0507  	ANDWF gbl_portc, W
0219  0087  	MOVWF gbl_portc


	//Delay
	//Delay: 5 us
	delay_us(5);
021A  3005  	MOVLW 0x05
021B  1683  	BSF STATUS, RP0
021C  00B1  	MOVWF delay_us_00000_arg_del
021D  2010  	CALL delay_us_00000


	//Calculation
	//Calculation:
	//  spi_data0 = 0b00110000
	FCV_SPI_DATA0 = 48;
021E  3030  	MOVLW 0x30
021F  1283  	BCF STATUS, RP0
0220  00F9  	MOVWF gbl_FCV_SPI_DATA0


	//Call Component Macro
	//Call Component Macro: SPI_Send_Char(spi_data0)
	FCD_SPI_Legacy0_SPI_Send_Char(FCV_SPI_DATA0);
0221  0879  	MOVF gbl_FCV_SPI_DATA0, W
0222  1683  	BSF STATUS, RP0
0223  00B1  	MOVWF FCD_SPI_Le_00052_arg_Char
0224  2068  	CALL FCD_SPI_Le_00052


	//Calculation
	//Calculation:
	//  spi_data0 = reg10_tx_addr_byte0
	FCV_SPI_DATA0 = FCV_REG10_TX_ADDR_BYTE0;
0225  082F  	MOVF gbl_FCV_REG10_TX_ADDR_BYTE0, W
0226  1283  	BCF STATUS, RP0
0227  00F9  	MOVWF gbl_FCV_SPI_DATA0


	//Call Component Macro
	//Call Component Macro: SPI_Send_Char(spi_data0)
	FCD_SPI_Legacy0_SPI_Send_Char(FCV_SPI_DATA0);
0228  0879  	MOVF gbl_FCV_SPI_DATA0, W
0229  1683  	BSF STATUS, RP0
022A  00B1  	MOVWF FCD_SPI_Le_00052_arg_Char
022B  2068  	CALL FCD_SPI_Le_00052


	//Calculation
	//Calculation:
	//  spi_data0 = reg10_tx_addr_byte1
	FCV_SPI_DATA0 = FCV_REG10_TX_ADDR_BYTE1;
022C  1283  	BCF STATUS, RP0
022D  0870  	MOVF gbl_FCV_REG10_TX_ADDR_BYTE1, W
022E  00F9  	MOVWF gbl_FCV_SPI_DATA0


	//Call Component Macro
	//Call Component Macro: SPI_Send_Char(spi_data0)
	FCD_SPI_Legacy0_SPI_Send_Char(FCV_SPI_DATA0);
022F  0879  	MOVF gbl_FCV_SPI_DATA0, W
0230  1683  	BSF STATUS, RP0
0231  00B1  	MOVWF FCD_SPI_Le_00052_arg_Char
0232  2068  	CALL FCD_SPI_Le_00052


	//Calculation
	//Calculation:
	//  spi_data0 = reg10_tx_addr_byte2
	FCV_SPI_DATA0 = FCV_REG10_TX_ADDR_BYTE2;
0233  1283  	BCF STATUS, RP0
0234  0873  	MOVF gbl_FCV_REG10_TX_ADDR_BYTE2, W
0235  00F9  	MOVWF gbl_FCV_SPI_DATA0


	//Call Component Macro
	//Call Component Macro: SPI_Send_Char(spi_data0)
	FCD_SPI_Legacy0_SPI_Send_Char(FCV_SPI_DATA0);
0236  0879  	MOVF gbl_FCV_SPI_DATA0, W
0237  1683  	BSF STATUS, RP0
0238  00B1  	MOVWF FCD_SPI_Le_00052_arg_Char
0239  2068  	CALL FCD_SPI_Le_00052


	//Calculation
	//Calculation:
	//  spi_data0 = reg10_tx_addr_byte3
	FCV_SPI_DATA0 = FCV_REG10_TX_ADDR_BYTE3;
023A  1283  	BCF STATUS, RP0
023B  0875  	MOVF gbl_FCV_REG10_TX_ADDR_BYTE3, W
023C  00F9  	MOVWF gbl_FCV_SPI_DATA0


	//Call Component Macro
	//Call Component Macro: SPI_Send_Char(spi_data0)
	FCD_SPI_Legacy0_SPI_Send_Char(FCV_SPI_DATA0);
023D  0879  	MOVF gbl_FCV_SPI_DATA0, W
023E  1683  	BSF STATUS, RP0
023F  00B1  	MOVWF FCD_SPI_Le_00052_arg_Char
0240  2068  	CALL FCD_SPI_Le_00052


	//Calculation
	//Calculation:
	//  spi_data0 = reg10_tx_addr_byte4
	FCV_SPI_DATA0 = FCV_REG10_TX_ADDR_BYTE4;
0241  1283  	BCF STATUS, RP0
0242  0878  	MOVF gbl_FCV_REG10_TX_ADDR_BYTE4, W
0243  00F9  	MOVWF gbl_FCV_SPI_DATA0


	//Call Component Macro
	//Call Component Macro: SPI_Send_Char(spi_data0)
	FCD_SPI_Legacy0_SPI_Send_Char(FCV_SPI_DATA0);
0244  0879  	MOVF gbl_FCV_SPI_DATA0, W
0245  1683  	BSF STATUS, RP0
0246  00B1  	MOVWF FCD_SPI_Le_00052_arg_Char
0247  2068  	CALL FCD_SPI_Le_00052


	//CSN
	//Output: 1 -> C2
	trisc = trisc & 0xFB;
0248  30FB  	MOVLW 0xFB
0249  0507  	ANDWF gbl_trisc, W
024A  0087  	MOVWF gbl_trisc

	if ((1))
		portc = (portc & 0xFB) | 0x04;
024B  30FB  	MOVLW 0xFB
024C  1283  	BCF STATUS, RP0
024D  0507  	ANDWF gbl_portc, W
024E  1683  	BSF STATUS, RP0
024F  00B1  	MOVWF CompTempVar2191
0250  3004  	MOVLW 0x04
0251  0431  	IORWF CompTempVar2191, W
0252  1283  	BCF STATUS, RP0
0253  0087  	MOVWF gbl_portc

	else
		portc = portc & 0xFB;

	//Delay
	//Delay: 5 us
	delay_us(5);
0254  3005  	MOVLW 0x05
0255  1683  	BSF STATUS, RP0
0256  00B1  	MOVWF delay_us_00000_arg_del
0257  2010  	CALL delay_us_00000


}
0258  0008  	RETURN



void FCM_cmd_read_rx_addr()
{

	//Comment:
	//read rx addr

	//Calculation
	//Calculation:
	//  spi_data0 = 0x0A
	FCV_SPI_DATA0 = 0x0A;

	//CSN
	//Output: 0 -> C2
	trisc = trisc & 0xFB;
	if ((0))
		portc = (portc & 0xFB) | 0x04;
	else
		portc = portc & 0xFB;

	//Delay
	//Delay: 5 us
	delay_us(5);

	//Call Component Macro
	//Call Component Macro: SPI_Send_Char(spi_data0)
	FCD_SPI_Legacy0_SPI_Send_Char(FCV_SPI_DATA0);

	//Call Component Macro
	//Call Component Macro: spi_data1=SPI_Get_Char()
	FCV_SPI_DATA1 = FCD_SPI_Legacy0_SPI_Get_Char();

	//Calculation
	//Calculation:
	//  reg0A_rx_addr_p0_byte0 = spi_data1
	FCV_REG0A_RX_ADDR_P0_BYTE0 = FCV_SPI_DATA1;

	//Call Component Macro
	//Call Component Macro: spi_data1=SPI_Get_Char()
	FCV_SPI_DATA1 = FCD_SPI_Legacy0_SPI_Get_Char();

	//Calculation
	//Calculation:
	//  reg0A_rx_addr_p0_byte1 = spi_data1
	FCV_REG0A_RX_ADDR_P0_BYTE1 = FCV_SPI_DATA1;

	//Call Component Macro
	//Call Component Macro: spi_data1=SPI_Get_Char()
	FCV_SPI_DATA1 = FCD_SPI_Legacy0_SPI_Get_Char();

	//Calculation
	//Calculation:
	//  reg0A_rx_addr_p0_byte2 = spi_data1
	FCV_REG0A_RX_ADDR_P0_BYTE2 = FCV_SPI_DATA1;

	//Call Component Macro
	//Call Component Macro: spi_data1=SPI_Get_Char()
	FCV_SPI_DATA1 = FCD_SPI_Legacy0_SPI_Get_Char();

	//Calculation
	//Calculation:
	//  reg0A_rx_addr_p0_byte3 = spi_data1
	FCV_REG0A_RX_ADDR_P0_BYTE3 = FCV_SPI_DATA1;

	//Call Component Macro
	//Call Component Macro: spi_data1=SPI_Get_Char()
	FCV_SPI_DATA1 = FCD_SPI_Legacy0_SPI_Get_Char();

	//Calculation
	//Calculation:
	//  reg0A_rx_addr_p0_byte4 = spi_data1
	FCV_REG0A_RX_ADDR_P0_BYTE4 = FCV_SPI_DATA1;

	//CSN
	//Output: 1 -> C2
	trisc = trisc & 0xFB;
	if ((1))
		portc = (portc & 0xFB) | 0x04;
	else
		portc = portc & 0xFB;

	//Delay
	//Delay: 5 us
	delay_us(5);

	//Calculation
	//Calculation:
	//  rx_addr = rx_addr + reg0A_rx_addr_p0_byte0
	FCI_SHEAD(FCV_RX_ADDR,FCSZ_RX_ADDR, &FCV_REG0A_RX_ADDR_P0_BYTE0,1, FCV_RX_ADDR,FCSZ_RX_ADDR);

	//Calculation
	//Calculation:
	//  rx_addr = rx_addr + reg0A_rx_addr_p0_byte1
	FCI_SHEAD(FCV_RX_ADDR,FCSZ_RX_ADDR, &FCV_REG0A_RX_ADDR_P0_BYTE1,1, FCV_RX_ADDR,FCSZ_RX_ADDR);

	//Calculation
	//Calculation:
	//  rx_addr = rx_addr + reg0A_rx_addr_p0_byte2
	FCI_SHEAD(FCV_RX_ADDR,FCSZ_RX_ADDR, &FCV_REG0A_RX_ADDR_P0_BYTE2,1, FCV_RX_ADDR,FCSZ_RX_ADDR);

	//Calculation
	//Calculation:
	//  rx_addr = rx_addr + reg0A_rx_addr_p0_byte3
	FCI_SHEAD(FCV_RX_ADDR,FCSZ_RX_ADDR, &FCV_REG0A_RX_ADDR_P0_BYTE3,1, FCV_RX_ADDR,FCSZ_RX_ADDR);

	//Calculation
	//Calculation:
	//  rx_addr = rx_addr + reg0A_rx_addr_p0_byte4
	FCI_SHEAD(FCV_RX_ADDR,FCSZ_RX_ADDR, &FCV_REG0A_RX_ADDR_P0_BYTE4,1, FCV_RX_ADDR,FCSZ_RX_ADDR);

}


void FCM_cmd_read_tx_addr()
{

	//Comment:
	//read tx addr

	//Calculation
	//Calculation:
	//  spi_data0 = 0x10
	FCV_SPI_DATA0 = 0x10;

	//CSN
	//Output: 0 -> C2
	trisc = trisc & 0xFB;
	if ((0))
		portc = (portc & 0xFB) | 0x04;
	else
		portc = portc & 0xFB;

	//Delay
	//Delay: 5 us
	delay_us(5);

	//Call Component Macro
	//Call Component Macro: SPI_Send_Char(spi_data0)
	FCD_SPI_Legacy0_SPI_Send_Char(FCV_SPI_DATA0);

	//Call Component Macro
	//Call Component Macro: spi_data1=SPI_Get_Char()
	FCV_SPI_DATA1 = FCD_SPI_Legacy0_SPI_Get_Char();

	//Calculation
	//Calculation:
	//  reg10_tx_addr_byte0 = spi_data1
	FCV_REG10_TX_ADDR_BYTE0 = FCV_SPI_DATA1;

	//Call Component Macro
	//Call Component Macro: spi_data1=SPI_Get_Char()
	FCV_SPI_DATA1 = FCD_SPI_Legacy0_SPI_Get_Char();

	//Calculation
	//Calculation:
	//  reg10_tx_addr_byte1 = spi_data1
	FCV_REG10_TX_ADDR_BYTE1 = FCV_SPI_DATA1;

	//Call Component Macro
	//Call Component Macro: spi_data1=SPI_Get_Char()
	FCV_SPI_DATA1 = FCD_SPI_Legacy0_SPI_Get_Char();

	//Calculation
	//Calculation:
	//  reg10_tx_addr_byte2 = spi_data1
	FCV_REG10_TX_ADDR_BYTE2 = FCV_SPI_DATA1;

	//Call Component Macro
	//Call Component Macro: spi_data1=SPI_Get_Char()
	FCV_SPI_DATA1 = FCD_SPI_Legacy0_SPI_Get_Char();

	//Calculation
	//Calculation:
	//  reg10_tx_addr_byte3 = spi_data1
	FCV_REG10_TX_ADDR_BYTE3 = FCV_SPI_DATA1;

	//Call Component Macro
	//Call Component Macro: spi_data1=SPI_Get_Char()
	FCV_SPI_DATA1 = FCD_SPI_Legacy0_SPI_Get_Char();

	//Calculation
	//Calculation:
	//  reg10_tx_addr_byte4 = spi_data1
	FCV_REG10_TX_ADDR_BYTE4 = FCV_SPI_DATA1;

	//CSN
	//Output: 1 -> C2
	trisc = trisc & 0xFB;
	if ((1))
		portc = (portc & 0xFB) | 0x04;
	else
		portc = portc & 0xFB;

	//Delay
	//Delay: 5 us
	delay_us(5);

	//Calculation
	//Calculation:
	//  tx_addr = tx_addr + reg10_tx_addr_byte0
	FCI_SHEAD(FCV_TX_ADDR,FCSZ_TX_ADDR, &FCV_REG10_TX_ADDR_BYTE0,1, FCV_TX_ADDR,FCSZ_TX_ADDR);

	//Calculation
	//Calculation:
	//  tx_addr = tx_addr + reg10_tx_addr_byte1
	FCI_SHEAD(FCV_TX_ADDR,FCSZ_TX_ADDR, &FCV_REG10_TX_ADDR_BYTE1,1, FCV_TX_ADDR,FCSZ_TX_ADDR);

	//Calculation
	//Calculation:
	//  tx_addr = tx_addr + reg10_tx_addr_byte2
	FCI_SHEAD(FCV_TX_ADDR,FCSZ_TX_ADDR, &FCV_REG10_TX_ADDR_BYTE2,1, FCV_TX_ADDR,FCSZ_TX_ADDR);

	//Calculation
	//Calculation:
	//  tx_addr = tx_addr + reg10_tx_addr_byte3
	FCI_SHEAD(FCV_TX_ADDR,FCSZ_TX_ADDR, &FCV_REG10_TX_ADDR_BYTE3,1, FCV_TX_ADDR,FCSZ_TX_ADDR);

	//Calculation
	//Calculation:
	//  tx_addr = tx_addr + reg10_tx_addr_byte4
	FCI_SHEAD(FCV_TX_ADDR,FCSZ_TX_ADDR, &FCV_REG10_TX_ADDR_BYTE4,1, FCV_TX_ADDR,FCSZ_TX_ADDR);

}


void FCM_radio_init_tx()

{

	//Calculation
	//Calculation:
	//  reg_to_write = 0x00
	//  data_to_write = 0x0E
	FCV_REG_TO_WRITE = 0x00;
048C  1683  	BSF STATUS, RP0
048D  1303  	BCF STATUS, RP1
048E  01AA  	CLRF gbl_FCV_REG_TO_WRITE

	FCV_DATA_TO_WRITE = 0x0E;
048F  300E  	MOVLW 0x0E
0490  1283  	BCF STATUS, RP0
0491  00F1  	MOVWF gbl_FCV_DATA_TO_WRITE


	//Call Macro
	//Call Macro: cmd_write_reg()
	FCM_cmd_write_reg();
0492  231E  	CALL FCM_cmd_wr_00051


	//Calculation
	//Calculation:
	//  reg_to_write = 01
	//  data_to_write = 0x3F
	FCV_REG_TO_WRITE = 01;
0493  3001  	MOVLW 0x01
0494  1683  	BSF STATUS, RP0
0495  00AA  	MOVWF gbl_FCV_REG_TO_WRITE

	FCV_DATA_TO_WRITE = 0x3F;
0496  303F  	MOVLW 0x3F
0497  1283  	BCF STATUS, RP0
0498  00F1  	MOVWF gbl_FCV_DATA_TO_WRITE


	//Call Macro
	//Call Macro: cmd_write_reg()
	FCM_cmd_write_reg();
0499  231E  	CALL FCM_cmd_wr_00051


	//Calculation
	//Calculation:
	//  reg_to_write = 02
	//  data_to_write = 0x03
	FCV_REG_TO_WRITE = 02;
049A  3002  	MOVLW 0x02
049B  1683  	BSF STATUS, RP0
049C  00AA  	MOVWF gbl_FCV_REG_TO_WRITE

	FCV_DATA_TO_WRITE = 0x03;
049D  3003  	MOVLW 0x03
049E  1283  	BCF STATUS, RP0
049F  00F1  	MOVWF gbl_FCV_DATA_TO_WRITE


	//Call Macro
	//Call Macro: cmd_write_reg()
	FCM_cmd_write_reg();
04A0  231E  	CALL FCM_cmd_wr_00051


	//Calculation
	//Calculation:
	//  reg_to_write = 03
	//  data_to_write = 0x03
	FCV_REG_TO_WRITE = 03;
04A1  3003  	MOVLW 0x03
04A2  1683  	BSF STATUS, RP0
04A3  00AA  	MOVWF gbl_FCV_REG_TO_WRITE

	FCV_DATA_TO_WRITE = 0x03;
04A4  1283  	BCF STATUS, RP0
04A5  00F1  	MOVWF gbl_FCV_DATA_TO_WRITE


	//Call Macro
	//Call Macro: cmd_write_reg()
	FCM_cmd_write_reg();
04A6  231E  	CALL FCM_cmd_wr_00051


	//Calculation
	//Calculation:
	//  reg_to_write = 0x04
	//  data_to_write = 0x5F
	FCV_REG_TO_WRITE = 0x04;
04A7  3004  	MOVLW 0x04
04A8  1683  	BSF STATUS, RP0
04A9  00AA  	MOVWF gbl_FCV_REG_TO_WRITE

	FCV_DATA_TO_WRITE = 0x5F;
04AA  305F  	MOVLW 0x5F
04AB  1283  	BCF STATUS, RP0
04AC  00F1  	MOVWF gbl_FCV_DATA_TO_WRITE


	//Call Macro
	//Call Macro: cmd_write_reg()
	FCM_cmd_write_reg();
04AD  231E  	CALL FCM_cmd_wr_00051


	//Calculation
	//Calculation:
	//  reg_to_write = 0x05
	//  data_to_write = 0x4C
	FCV_REG_TO_WRITE = 0x05;
04AE  3005  	MOVLW 0x05
04AF  1683  	BSF STATUS, RP0
04B0  00AA  	MOVWF gbl_FCV_REG_TO_WRITE

	FCV_DATA_TO_WRITE = 0x4C;
04B1  304C  	MOVLW 0x4C
04B2  1283  	BCF STATUS, RP0
04B3  00F1  	MOVWF gbl_FCV_DATA_TO_WRITE


	//Call Macro
	//Call Macro: cmd_write_reg()
	FCM_cmd_write_reg();
04B4  231E  	CALL FCM_cmd_wr_00051


	//Calculation
	//Calculation:
	//  reg_to_write = 0x06
	//  data_to_write = 0x27
	FCV_REG_TO_WRITE = 0x06;
04B5  3006  	MOVLW 0x06
04B6  1683  	BSF STATUS, RP0
04B7  00AA  	MOVWF gbl_FCV_REG_TO_WRITE

	FCV_DATA_TO_WRITE = 0x27;
04B8  3027  	MOVLW 0x27
04B9  1283  	BCF STATUS, RP0
04BA  00F1  	MOVWF gbl_FCV_DATA_TO_WRITE


	//Call Macro
	//Call Macro: cmd_write_reg()
	FCM_cmd_write_reg();
04BB  231E  	CALL FCM_cmd_wr_00051


	//Calculation
	//Calculation:
	//  reg_to_write = 0x11
	//  data_to_write = payloadsize
	FCV_REG_TO_WRITE = 0x11;
04BC  3011  	MOVLW 0x11
04BD  1683  	BSF STATUS, RP0
04BE  00AA  	MOVWF gbl_FCV_REG_TO_WRITE

	FCV_DATA_TO_WRITE = FCV_PAYLOADSIZE;
04BF  082C  	MOVF gbl_FCV_PAYLOADSIZE, W
04C0  1283  	BCF STATUS, RP0
04C1  00F1  	MOVWF gbl_FCV_DATA_TO_WRITE


	//Call Macro
	//Call Macro: cmd_write_reg()
	FCM_cmd_write_reg();
04C2  231E  	CALL FCM_cmd_wr_00051


	//Call Macro
	//Call Macro: set_tx_addr()
	FCM_set_tx_addr();
04C3  2211  	CALL FCM_set_tx_00056


	//Call Macro
	//Call Macro: set_rx_addr()
	FCM_set_rx_addr();
04C4  2259  	CALL FCM_set_rx_00057


	//Call Macro
	//Call Macro: flush_fifo_txrx()
	FCM_flush_fifo_txrx();
04C5  22F2  	CALL FCM_flush__00058


}
04C6  0008  	RETURN



void FCM_flush_fifo_txrx()

{

	//CSN
	//Output: 0 -> C2
	trisc = trisc & 0xFB;
02F2  30FB  	MOVLW 0xFB
02F3  1683  	BSF STATUS, RP0
02F4  1303  	BCF STATUS, RP1
02F5  0507  	ANDWF gbl_trisc, W
02F6  0087  	MOVWF gbl_trisc

	if ((0))
		portc = (portc & 0xFB) | 0x04;
	else
		portc = portc & 0xFB;
02F7  30FB  	MOVLW 0xFB
02F8  1283  	BCF STATUS, RP0
02F9  0507  	ANDWF gbl_portc, W
02FA  0087  	MOVWF gbl_portc


	//Delay
	//Delay: 5 us
	delay_us(5);
02FB  3005  	MOVLW 0x05
02FC  1683  	BSF STATUS, RP0
02FD  00B1  	MOVWF delay_us_00000_arg_del
02FE  2010  	CALL delay_us_00000


	//Calculation
	//Calculation:
	//  spi_data0 = 0xE1
	FCV_SPI_DATA0 = 0xE1;
02FF  30E1  	MOVLW 0xE1
0300  1283  	BCF STATUS, RP0
0301  00F9  	MOVWF gbl_FCV_SPI_DATA0


	//Call Component Macro
	//Call Component Macro: SPI_Send_Char(spi_data0)
	FCD_SPI_Legacy0_SPI_Send_Char(FCV_SPI_DATA0);
0302  0879  	MOVF gbl_FCV_SPI_DATA0, W
0303  1683  	BSF STATUS, RP0
0304  00B1  	MOVWF FCD_SPI_Le_00052_arg_Char
0305  2068  	CALL FCD_SPI_Le_00052


	//Calculation
	//Calculation:
	//  spi_data0 = 0xE2
	FCV_SPI_DATA0 = 0xE2;
0306  30E2  	MOVLW 0xE2
0307  1283  	BCF STATUS, RP0
0308  00F9  	MOVWF gbl_FCV_SPI_DATA0


	//Call Component Macro
	//Call Component Macro: SPI_Send_Char(spi_data0)
	FCD_SPI_Legacy0_SPI_Send_Char(FCV_SPI_DATA0);
0309  0879  	MOVF gbl_FCV_SPI_DATA0, W
030A  1683  	BSF STATUS, RP0
030B  00B1  	MOVWF FCD_SPI_Le_00052_arg_Char
030C  2068  	CALL FCD_SPI_Le_00052


	//CSN
	//Output: 1 -> C2
	trisc = trisc & 0xFB;
030D  30FB  	MOVLW 0xFB
030E  0507  	ANDWF gbl_trisc, W
030F  0087  	MOVWF gbl_trisc

	if ((1))
		portc = (portc & 0xFB) | 0x04;
0310  30FB  	MOVLW 0xFB
0311  1283  	BCF STATUS, RP0
0312  0507  	ANDWF gbl_portc, W
0313  1683  	BSF STATUS, RP0
0314  00B1  	MOVWF CompTempVar2193
0315  3004  	MOVLW 0x04
0316  0431  	IORWF CompTempVar2193, W
0317  1283  	BCF STATUS, RP0
0318  0087  	MOVWF gbl_portc

	else
		portc = portc & 0xFB;

	//Delay
	//Delay: 5 us
	delay_us(5);
0319  3005  	MOVLW 0x05
031A  1683  	BSF STATUS, RP0
031B  00B1  	MOVWF delay_us_00000_arg_del
031C  2010  	CALL delay_us_00000


}
031D  0008  	RETURN



void FCM_radio_send_data()

{

	//CSN
	//Output: 0 -> C2
	trisc = trisc & 0xFB;
040B  30FB  	MOVLW 0xFB
040C  1683  	BSF STATUS, RP0
040D  1303  	BCF STATUS, RP1
040E  0507  	ANDWF gbl_trisc, W
040F  0087  	MOVWF gbl_trisc

	if ((0))
		portc = (portc & 0xFB) | 0x04;
	else
		portc = portc & 0xFB;
0410  30FB  	MOVLW 0xFB
0411  1283  	BCF STATUS, RP0
0412  0507  	ANDWF gbl_portc, W
0413  0087  	MOVWF gbl_portc


	//Delay
	//Delay: 5 us
	delay_us(5);
0414  3005  	MOVLW 0x05
0415  1683  	BSF STATUS, RP0
0416  00B1  	MOVWF delay_us_00000_arg_del
0417  2010  	CALL delay_us_00000


	//Calculation
	//Calculation:
	//  spi_data0 = 0xA0
	FCV_SPI_DATA0 = 0xA0;
0418  30A0  	MOVLW 0xA0
0419  1283  	BCF STATUS, RP0
041A  00F9  	MOVWF gbl_FCV_SPI_DATA0


	//Call Component Macro
	//Call Component Macro: SPI_Send_Char(spi_data0)
	FCD_SPI_Legacy0_SPI_Send_Char(FCV_SPI_DATA0);
041B  0879  	MOVF gbl_FCV_SPI_DATA0, W
041C  1683  	BSF STATUS, RP0
041D  00B1  	MOVWF FCD_SPI_Le_00052_arg_Char
041E  2068  	CALL FCD_SPI_Le_00052


	//Calculation
	//Calculation:
	//  loop_count = 0
	FCV_LOOP_COUNT = 0;
041F  01AD  	CLRF gbl_FCV_LOOP_COUNT


	//Connection Point
	//Connection Point: [A]: A
FCC_radio_send_data_A:
0420        label43

;

	//Calculation
	//Calculation:
	//  spi_data0 = payload_transmit[loop_count]
	FCV_SPI_DATA0 = FCV_PAYLOAD_TRANSMIT[FCV_LOOP_COUNT];
0420  1283  	BCF STATUS, RP0
0421  1383  	BCF	STATUS,IRP
0422  3032  	MOVLW LOW(gbl_FCV_PAYLOAD_TRANSMIT+D'0')
0423  0084  	MOVWF FSR
0424  1683  	BSF STATUS, RP0
0425  082D  	MOVF gbl_FCV_LOOP_COUNT, W
0426  0784  	ADDWF FSR, F
0427  0800  	MOVF INDF, W
0428  1283  	BCF STATUS, RP0
0429  00F9  	MOVWF gbl_FCV_SPI_DATA0


	//Call Component Macro
	//Call Component Macro: SPI_Send_Char(spi_data0)
	FCD_SPI_Legacy0_SPI_Send_Char(FCV_SPI_DATA0);
042A  0879  	MOVF gbl_FCV_SPI_DATA0, W
042B  1683  	BSF STATUS, RP0
042C  00B1  	MOVWF FCD_SPI_Le_00052_arg_Char
042D  2068  	CALL FCD_SPI_Le_00052


	//Calculation
	//Calculation:
	//  loop_count = loop_count + 1
	FCV_LOOP_COUNT = FCV_LOOP_COUNT + 1;
042E  0A2D  	INCF gbl_FCV_LOOP_COUNT, W
042F  00AD  	MOVWF gbl_FCV_LOOP_COUNT


	//Decision
	//Decision: loop_count = payloadsize?
	if (FCV_LOOP_COUNT == FCV_PAYLOADSIZE)
0430  082C  	MOVF gbl_FCV_PAYLOADSIZE, W
0431  062D  	XORWF gbl_FCV_LOOP_COUNT, W
0432  1D03  	BTFSS STATUS,Z

	{

	} else {

		//Goto Connection Point
		//Goto Connection Point: [A]: A
		goto FCC_radio_send_data_A;
0433  2C20  	GOTO	label43


	}

	//CSN
	//Output: 1 -> C2
	trisc = trisc & 0xFB;
0434  30FB  	MOVLW 0xFB
0435  0507  	ANDWF gbl_trisc, W
0436  0087  	MOVWF gbl_trisc

	if ((1))
		portc = (portc & 0xFB) | 0x04;
0437  30FB  	MOVLW 0xFB
0438  1283  	BCF STATUS, RP0
0439  0507  	ANDWF gbl_portc, W
043A  1683  	BSF STATUS, RP0
043B  00B1  	MOVWF CompTempVar2227
043C  3004  	MOVLW 0x04
043D  0431  	IORWF CompTempVar2227, W
043E  1283  	BCF STATUS, RP0
043F  0087  	MOVWF gbl_portc

	else
		portc = portc & 0xFB;

	//Delay
	//Delay: 5 us
	delay_us(5);
0440  3005  	MOVLW 0x05
0441  1683  	BSF STATUS, RP0
0442  00B1  	MOVWF delay_us_00000_arg_del
0443  2010  	CALL delay_us_00000


	//CE
	//Output: 1 -> C1
	trisc = trisc & 0xFD;
0444  30FD  	MOVLW 0xFD
0445  0507  	ANDWF gbl_trisc, W
0446  0087  	MOVWF gbl_trisc

	if ((1))
		portc = (portc & 0xFD) | 0x02;
0447  30FD  	MOVLW 0xFD
0448  1283  	BCF STATUS, RP0
0449  0507  	ANDWF gbl_portc, W
044A  1683  	BSF STATUS, RP0
044B  00B1  	MOVWF CompTempVar2228
044C  3002  	MOVLW 0x02
044D  0431  	IORWF CompTempVar2228, W
044E  1283  	BCF STATUS, RP0
044F  0087  	MOVWF gbl_portc

	else
		portc = portc & 0xFD;

	//Delay
	//Delay: 6 ms
	delay_ms(6);
0450  3006  	MOVLW 0x06
0451  1683  	BSF STATUS, RP0
0452  00B5  	MOVWF delay_ms_00000_arg_del
0453  2015  	CALL delay_ms_00000


	//CE
	//Output: 0 -> C1
	trisc = trisc & 0xFD;
0454  30FD  	MOVLW 0xFD
0455  0507  	ANDWF gbl_trisc, W
0456  0087  	MOVWF gbl_trisc

	if ((0))
		portc = (portc & 0xFD) | 0x02;
	else
		portc = portc & 0xFD;
0457  30FD  	MOVLW 0xFD
0458  1283  	BCF STATUS, RP0
0459  0507  	ANDWF gbl_portc, W
045A  0087  	MOVWF gbl_portc


	//Call Macro
	//Call Macro: check_status()
	FCM_check_status();
045B  2344  	CALL FCM_check__0005D


	//Decision
	//Decision: reg07 = 0x2E?
	if (FCV_REG07 == 0x2E)
045C  1683  	BSF STATUS, RP0
045D  0820  	MOVF gbl_FCV_REG07, W
045E  3A2E  	XORLW 0x2E
045F  1D03  	BTFSS STATUS,Z
0460  2C7D  	GOTO	label44
047D        label44

	{

		//tx_ack
		//Output: 1 -> C0
		trisc = trisc & 0xFE;
0461  30FE  	MOVLW 0xFE
0462  0507  	ANDWF gbl_trisc, W
0463  0087  	MOVWF gbl_trisc

		if ((1))
			portc = (portc & 0xFE) | 0x01;
0464  30FE  	MOVLW 0xFE
0465  1283  	BCF STATUS, RP0
0466  0507  	ANDWF gbl_portc, W
0467  1683  	BSF STATUS, RP0
0468  00B1  	MOVWF CompTempVar2229
0469  3001  	MOVLW 0x01
046A  0431  	IORWF CompTempVar2229, W
046B  1283  	BCF STATUS, RP0
046C  0087  	MOVWF gbl_portc

		else
			portc = portc & 0xFE;

		//Calculation
		//Calculation:
		//  reg_to_write = 0x07
		//  data_to_write = 0x2E
		FCV_REG_TO_WRITE = 0x07;
046D  3007  	MOVLW 0x07
046E  1683  	BSF STATUS, RP0
046F  00AA  	MOVWF gbl_FCV_REG_TO_WRITE

		FCV_DATA_TO_WRITE = 0x2E;
0470  302E  	MOVLW 0x2E
0471  1283  	BCF STATUS, RP0
0472  00F1  	MOVWF gbl_FCV_DATA_TO_WRITE


		//Call Macro
		//Call Macro: cmd_write_reg()
		FCM_cmd_write_reg();
0473  231E  	CALL FCM_cmd_wr_00051


		//Call Macro
		//Call Macro: flush_fifo_txrx()
		FCM_flush_fifo_txrx();
0474  22F2  	CALL FCM_flush__00058


		//tx_ack
		//Output: 0 -> C0
		trisc = trisc & 0xFE;
0475  30FE  	MOVLW 0xFE
0476  0507  	ANDWF gbl_trisc, W
0477  0087  	MOVWF gbl_trisc

		if ((0))
			portc = (portc & 0xFE) | 0x01;
		else
			portc = portc & 0xFE;
0478  30FE  	MOVLW 0xFE
0479  1283  	BCF STATUS, RP0
047A  0507  	ANDWF gbl_portc, W
047B  0087  	MOVWF gbl_portc


	} else {

		//Decision
		//Decision: reg07 = 0x1E?
		if (FCV_REG07 == 0x1E)
047D  0820  	MOVF gbl_FCV_REG07, W
047E  3A1E  	XORLW 0x1E
047F  1D03  	BTFSS STATUS,Z
0480  2C8A  	GOTO	label45
048A        label45

		{

			//Call Macro
			//Call Macro: flush_fifo_txrx()
			FCM_flush_fifo_txrx();
0481  22F2  	CALL FCM_flush__00058


			//Calculation
			//Calculation:
			//  reg_to_write = 0x07
			//  data_to_write = 0x1E
			FCV_REG_TO_WRITE = 0x07;
0482  3007  	MOVLW 0x07
0483  00AA  	MOVWF gbl_FCV_REG_TO_WRITE

			FCV_DATA_TO_WRITE = 0x1E;
0484  301E  	MOVLW 0x1E
0485  1283  	BCF STATUS, RP0
0486  00F1  	MOVWF gbl_FCV_DATA_TO_WRITE


			//Call Macro
			//Call Macro: cmd_write_reg()
			FCM_cmd_write_reg();
0487  231E  	CALL FCM_cmd_wr_00051


			//Call Macro
			//Call Macro: flush_fifo_txrx()
			FCM_flush_fifo_txrx();
0488  22F2  	CALL FCM_flush__00058


		} else {

			//Call Macro
			//Call Macro: flush_fifo_txrx()
			FCM_flush_fifo_txrx();
048A  22F2  	CALL FCM_flush__00058


		}

	}

}
047C  0008  	RETURN
0489  0008  	RETURN
048B  0008  	RETURN



void FCM_radio_recieve_data()

{

	//Calculation
	//Calculation:
	//  payload_recieve = ""
	FCI_SCOPY("",0, FCV_PAYLOAD_RECIEVE,FCSZ_PAYLOAD_RECIEVE);
03CD  1683  	BSF STATUS, RP0
03CE  1303  	BCF STATUS, RP1
03CF  01B3  	CLRF CompTempVar2230
03D0  3000  	MOVLW HIGH(CompTempVar2230+D'0')
03D1  00B2  	MOVWF FCI_SCOPY_00000_arg_sSrc+D'1'
03D2  30B3  	MOVLW LOW(CompTempVar2230+D'0')
03D3  00B1  	MOVWF FCI_SCOPY_00000_arg_sSrc
03D4  01C4  	CLRF FCI_SCOPY_00000_arg_iSrc_len
03D5  3000  	MOVLW HIGH(gbl_FCV_PAYLOAD_RECIEVE+D'0')
03D6  00C6  	MOVWF FCI_SCOPY_00000_arg_sDst+D'1'
03D7  3020  	MOVLW LOW(gbl_FCV_PAYLOAD_RECIEVE+D'0')
03D8  00C5  	MOVWF FCI_SCOPY_00000_arg_sDst
03D9  3012  	MOVLW 0x12
03DA  00C7  	MOVWF FCI_SCOPY_00000_arg_iDst_len
03DB  21A1  	CALL FCI_SCOPY_00000


	//Delay
	//Delay: 4 ms
	delay_ms(4);
03DC  3004  	MOVLW 0x04
03DD  00B5  	MOVWF delay_ms_00000_arg_del
03DE  2015  	CALL delay_ms_00000


	//Call Macro
	//Call Macro: check_status()
	FCM_check_status();
03DF  2344  	CALL FCM_check__0005D


	//Decision
	//Decision: reg07 = 64?
	if (FCV_REG07 == 64)
03E0  1683  	BSF STATUS, RP0
03E1  0820  	MOVF gbl_FCV_REG07, W
03E2  3A40  	XORLW 0x40
03E3  1D03  	BTFSS STATUS,Z
03E4  2C02  	GOTO	label41
0402        label41

	{

		//rx_ack
		//Output: 1 -> A5
		trisa = trisa & 0xDF;
03E5  30DF  	MOVLW 0xDF
03E6  0505  	ANDWF gbl_trisa, W
03E7  0085  	MOVWF gbl_trisa

		if ((1))
			porta = (porta & 0xDF) | 0x20;
03E8  30DF  	MOVLW 0xDF
03E9  1283  	BCF STATUS, RP0
03EA  0505  	ANDWF gbl_porta, W
03EB  1683  	BSF STATUS, RP0
03EC  00B1  	MOVWF CompTempVar2233
03ED  3020  	MOVLW 0x20
03EE  0431  	IORWF CompTempVar2233, W
03EF  1283  	BCF STATUS, RP0
03F0  0085  	MOVWF gbl_porta

		else
			porta = porta & 0xDF;

		//Call Macro
		//Call Macro: read_recieved_data()
		FCM_read_recieved_data();
03F1  22A1  	CALL FCM_read_r_0005F


		//Calculation
		//Calculation:
		//  reg_to_write = 0x07
		//  data_to_write = 0x4E
		FCV_REG_TO_WRITE = 0x07;
03F2  3007  	MOVLW 0x07
03F3  00AA  	MOVWF gbl_FCV_REG_TO_WRITE

		FCV_DATA_TO_WRITE = 0x4E;
03F4  304E  	MOVLW 0x4E
03F5  1283  	BCF STATUS, RP0
03F6  00F1  	MOVWF gbl_FCV_DATA_TO_WRITE


		//Call Macro
		//Call Macro: cmd_write_reg()
		FCM_cmd_write_reg();
03F7  231E  	CALL FCM_cmd_wr_00051


		//rx_ack
		//Output: 0 -> A5
		trisa = trisa & 0xDF;
03F8  30DF  	MOVLW 0xDF
03F9  1683  	BSF STATUS, RP0
03FA  0505  	ANDWF gbl_trisa, W
03FB  0085  	MOVWF gbl_trisa

		if ((0))
			porta = (porta & 0xDF) | 0x20;
		else
			porta = porta & 0xDF;
03FC  30DF  	MOVLW 0xDF
03FD  1283  	BCF STATUS, RP0
03FE  0505  	ANDWF gbl_porta, W
03FF  0085  	MOVWF gbl_porta


		//Calculation
		//Calculation:
		//  flag_radio_rx = 1
		FCV_FLAG_RADIO_RX = 1;
0400  15EE  	BSF gbl_FCV_FLAG_RADIO_RX,3


	} else {
0401  2C09  	GOTO	label42
0409        label42


		//rx_ack
		//Output: 0 -> A5
		trisa = trisa & 0xDF;
0402  30DF  	MOVLW 0xDF
0403  0505  	ANDWF gbl_trisa, W
0404  0085  	MOVWF gbl_trisa

		if ((0))
			porta = (porta & 0xDF) | 0x20;
		else
			porta = porta & 0xDF;
0405  30DF  	MOVLW 0xDF
0406  1283  	BCF STATUS, RP0
0407  0505  	ANDWF gbl_porta, W
0408  0085  	MOVWF gbl_porta


	}

	//Call Macro
	//Call Macro: flush_fifo_txrx()
	FCM_flush_fifo_txrx();
0409  22F2  	CALL FCM_flush__00058


}
040A  0008  	RETURN



void FCM_check_status()

{

	//Comment:
	//read reg07

	//Calculation
	//Calculation:
	//  spi_data0 = 0x07
	FCV_SPI_DATA0 = 0x07;
0344  3007  	MOVLW 0x07
0345  1283  	BCF STATUS, RP0
0346  1303  	BCF STATUS, RP1
0347  00F9  	MOVWF gbl_FCV_SPI_DATA0


	//Call Macro
	//Call Macro: cmd_read_reg()
	FCM_cmd_read_reg();
0348  206C  	CALL FCM_cmd_re_00053


	//Calculation
	//Calculation:
	//  reg07 = spi_data1
	FCV_REG07 = FCV_SPI_DATA1;
0349  087C  	MOVF gbl_FCV_SPI_DATA1, W
034A  1683  	BSF STATUS, RP0
034B  00A0  	MOVWF gbl_FCV_REG07


	//Comment:
	//read reg17

	//Calculation
	//Calculation:
	//  spi_data0 = 0x17
	FCV_SPI_DATA0 = 0x17;
034C  3017  	MOVLW 0x17
034D  1283  	BCF STATUS, RP0
034E  00F9  	MOVWF gbl_FCV_SPI_DATA0


	//Call Macro
	//Call Macro: cmd_read_reg()
	FCM_cmd_read_reg();
034F  206C  	CALL FCM_cmd_re_00053


	//Calculation
	//Calculation:
	//  reg17 = spi_data1
	FCV_REG17 = FCV_SPI_DATA1;
0350  087C  	MOVF gbl_FCV_SPI_DATA1, W
0351  00FE  	MOVWF gbl_FCV_REG17


}
0352  0008  	RETURN



void FCM_read_recieved_data()

{

	//Calculation
	//Calculation:
	//  loop_count = 0
	//  payload_recieve = ""
	FCV_LOOP_COUNT = 0;
02A1  1683  	BSF STATUS, RP0
02A2  1303  	BCF STATUS, RP1
02A3  01AD  	CLRF gbl_FCV_LOOP_COUNT

	FCI_SCOPY("",0, FCV_PAYLOAD_RECIEVE,FCSZ_PAYLOAD_RECIEVE);
02A4  01B3  	CLRF CompTempVar2234
02A5  3000  	MOVLW HIGH(CompTempVar2234+D'0')
02A6  00B2  	MOVWF FCI_SCOPY_00000_arg_sSrc+D'1'
02A7  30B3  	MOVLW LOW(CompTempVar2234+D'0')
02A8  00B1  	MOVWF FCI_SCOPY_00000_arg_sSrc
02A9  01C4  	CLRF FCI_SCOPY_00000_arg_iSrc_len
02AA  3000  	MOVLW HIGH(gbl_FCV_PAYLOAD_RECIEVE+D'0')
02AB  00C6  	MOVWF FCI_SCOPY_00000_arg_sDst+D'1'
02AC  3020  	MOVLW LOW(gbl_FCV_PAYLOAD_RECIEVE+D'0')
02AD  00C5  	MOVWF FCI_SCOPY_00000_arg_sDst
02AE  3012  	MOVLW 0x12
02AF  00C7  	MOVWF FCI_SCOPY_00000_arg_iDst_len
02B0  21A1  	CALL FCI_SCOPY_00000


	//CSN
	//Output: 0 -> C2
	trisc = trisc & 0xFB;
02B1  30FB  	MOVLW 0xFB
02B2  0507  	ANDWF gbl_trisc, W
02B3  0087  	MOVWF gbl_trisc

	if ((0))
		portc = (portc & 0xFB) | 0x04;
	else
		portc = portc & 0xFB;
02B4  30FB  	MOVLW 0xFB
02B5  1283  	BCF STATUS, RP0
02B6  0507  	ANDWF gbl_portc, W
02B7  0087  	MOVWF gbl_portc


	//Delay
	//Delay: 5 us
	delay_us(5);
02B8  3005  	MOVLW 0x05
02B9  1683  	BSF STATUS, RP0
02BA  00B1  	MOVWF delay_us_00000_arg_del
02BB  2010  	CALL delay_us_00000


	//Calculation
	//Calculation:
	//  spi_data0 = 0x61
	FCV_SPI_DATA0 = 0x61;
02BC  3061  	MOVLW 0x61
02BD  1283  	BCF STATUS, RP0
02BE  00F9  	MOVWF gbl_FCV_SPI_DATA0


	//Call Component Macro
	//Call Component Macro: SPI_Send_Char(spi_data0)
	FCD_SPI_Legacy0_SPI_Send_Char(FCV_SPI_DATA0);
02BF  0879  	MOVF gbl_FCV_SPI_DATA0, W
02C0  1683  	BSF STATUS, RP0
02C1  00B1  	MOVWF FCD_SPI_Le_00052_arg_Char
02C2  2068  	CALL FCD_SPI_Le_00052


	//Connection Point
	//Connection Point: [A]: A
FCC_read_recieved_data_A:
02C3        label30

;

	//Call Component Macro
	//Call Component Macro: data_to_read=SPI_Get_Char()
	FCV_DATA_TO_READ = FCD_SPI_Legacy0_SPI_Get_Char();
02C3  205D  	CALL FCD_SPI_Le_00054
02C4  0832  	MOVF CompTempVarRet2190, W
02C5  1283  	BCF STATUS, RP0
02C6  00FB  	MOVWF gbl_FCV_DATA_TO_READ


	//Calculation
	//Calculation:
	//  payload_recieve = payload_recieve + data_to_read
	FCI_SHEAD(FCV_PAYLOAD_RECIEVE,FCSZ_PAYLOAD_RECIEVE, &FCV_DATA_TO_READ,1, FCV_PAYLOAD_RECIEVE,FCSZ_PAYLOAD_RECIEVE);
02C7  3000  	MOVLW HIGH(gbl_FCV_PAYLOAD_RECIEVE+D'0')
02C8  1683  	BSF STATUS, RP0
02C9  00B2  	MOVWF FCI_SHEAD_00000_arg_sSrc1+D'1'
02CA  3020  	MOVLW LOW(gbl_FCV_PAYLOAD_RECIEVE+D'0')
02CB  00B1  	MOVWF FCI_SHEAD_00000_arg_sSrc1
02CC  3012  	MOVLW 0x12
02CD  00B3  	MOVWF FCI_SHEAD_00000_arg_iSrc1_len
02CE  3000  	MOVLW HIGH(gbl_FCV_DATA_TO_READ+D'0')
02CF  00B5  	MOVWF FCI_SHEAD_00000_arg_sSrc2+D'1'
02D0  307B  	MOVLW LOW(gbl_FCV_DATA_TO_READ+D'0')
02D1  00B4  	MOVWF FCI_SHEAD_00000_arg_sSrc2
02D2  3001  	MOVLW 0x01
02D3  00B6  	MOVWF FCI_SHEAD_00000_arg_iSrc2_len
02D4  3000  	MOVLW HIGH(gbl_FCV_PAYLOAD_RECIEVE+D'0')
02D5  00B8  	MOVWF FCI_SHEAD_00000_arg_sDst+D'1'
02D6  3020  	MOVLW LOW(gbl_FCV_PAYLOAD_RECIEVE+D'0')
02D7  00B7  	MOVWF FCI_SHEAD_00000_arg_sDst
02D8  3012  	MOVLW 0x12
02D9  00B9  	MOVWF FCI_SHEAD_00000_arg_iDst_len
02DA  208B  	CALL FCI_SHEAD_00000


	//Calculation
	//Calculation:
	//  loop_count = loop_count + 1
	FCV_LOOP_COUNT = FCV_LOOP_COUNT + 1;
02DB  0A2D  	INCF gbl_FCV_LOOP_COUNT, W
02DC  00AD  	MOVWF gbl_FCV_LOOP_COUNT


	//Decision
	//Decision: loop_count = payloadsize?
	if (FCV_LOOP_COUNT == FCV_PAYLOADSIZE)
02DD  082C  	MOVF gbl_FCV_PAYLOADSIZE, W
02DE  062D  	XORWF gbl_FCV_LOOP_COUNT, W
02DF  1D03  	BTFSS STATUS,Z

	{

	} else {

		//Goto Connection Point
		//Goto Connection Point: [A]: A
		goto FCC_read_recieved_data_A;
02E0  2AC3  	GOTO	label30


	}

	//CSN
	//Output: 1 -> C2
	trisc = trisc & 0xFB;
02E1  30FB  	MOVLW 0xFB
02E2  0507  	ANDWF gbl_trisc, W
02E3  0087  	MOVWF gbl_trisc

	if ((1))
		portc = (portc & 0xFB) | 0x04;
02E4  30FB  	MOVLW 0xFB
02E5  1283  	BCF STATUS, RP0
02E6  0507  	ANDWF gbl_portc, W
02E7  1683  	BSF STATUS, RP0
02E8  00B1  	MOVWF CompTempVar2240
02E9  3004  	MOVLW 0x04
02EA  0431  	IORWF CompTempVar2240, W
02EB  1283  	BCF STATUS, RP0
02EC  0087  	MOVWF gbl_portc

	else
		portc = portc & 0xFB;

	//Delay
	//Delay: 5 us
	delay_us(5);
02ED  3005  	MOVLW 0x05
02EE  1683  	BSF STATUS, RP0
02EF  00B1  	MOVWF delay_us_00000_arg_del
02F0  2010  	CALL delay_us_00000


}
02F1  0008  	RETURN



void FCM_uart_int()
{

	//Connection Point
	//Connection Point: [A]: A
FCC_uart_int_A:
;

	//Call Component Macro
	//Call Component Macro: uart_rx=ReceiveRS232Char(1)
	FCV_UART_RX = FCD_RS2320_ReceiveRS232Char(1);

	//Decision
	//Decision: uart_rx = 0xEC?
	if (FCV_UART_RX == 0xEC)
	{

		//Call Component Macro
		//Call Component Macro: payload_recieve=ReceiveRS232String(1, 17)
		FCD_RS2320_ReceiveRS232String(FCV_PAYLOAD_RECIEVE,FCSZ_PAYLOAD_RECIEVE, 1, 17);

		//Decision
		//Decision: payload_recieve[16] = 'ü'?
		if (FCV_PAYLOAD_RECIEVE[16] == 'ü')
		{

		} else {

			//rx_ack
			//Output: 1 -> A5
			trisa = trisa & 0xDF;
			if ((1))
				porta = (porta & 0xDF) | 0x20;
			else
				porta = porta & 0xDF;

			//Calculation
			//Calculation:
			//  payload_transmit = Mid$ (payload_recieve,0,15)
			FCI_MIDSTRING(FCV_PAYLOAD_RECIEVE, FCSZ_PAYLOAD_RECIEVE, 0, 15, FCV_PAYLOAD_TRANSMIT,FCSZ_PAYLOAD_TRANSMIT);

			//Calculation
			//Calculation:
			//  flag_prot = 1
			FCV_FLAG_PROT = 1;

		}

	} else {

		//Goto Connection Point
		//Goto Connection Point: [A]: A
		goto FCC_uart_int_A;

	}

}



void main()

{
	//Initialization
	adcon1 = 0x07;
069C  3007  	MOVLW 0x07
069D  1683  	BSF STATUS, RP0
069E  1303  	BCF STATUS, RP1
069F  009F  	MOVWF gbl_adcon1


	
		RS232_2_UART_Init( );		//Call initialise function
06A0  23BE  	CALL FC_CAL_UAR_00072



	//Interrupt initialization code
	option_reg = 0xC0;
06A1  30C0  	MOVLW 0xC0
06A2  0081  	MOVWF gbl_option_reg



	//Call Component Macro
	//Call Component Macro: SPI_Init()
	FCD_SPI_Legacy0_SPI_Init();
06A3  2502  	CALL FCD_SPI_Le_00067


	//Calculation
	//Calculation:
	//  payloadsize = 1
	FCV_PAYLOADSIZE = 1;
06A4  3001  	MOVLW 0x01
06A5  1683  	BSF STATUS, RP0
06A6  00AC  	MOVWF gbl_FCV_PAYLOADSIZE


	//Input
	//Input: PORTA -> reg0A_rx_addr_p0_byte4
	trisa = trisa | 0x07;
06A7  3007  	MOVLW 0x07
06A8  0405  	IORWF gbl_trisa, W
06A9  0085  	MOVWF gbl_trisa

	FCV_REG0A_RX_ADDR_P0_BYTE4 = porta & 0x07;
06AA  3007  	MOVLW 0x07
06AB  1283  	BCF STATUS, RP0
06AC  0505  	ANDWF gbl_porta, W
06AD  1683  	BSF STATUS, RP0
06AE  00AB  	MOVWF gbl_FCV_REG0A_RX_ADDR_P0_BYTE4


	//Input
	//Input: A3 -> tranciever_bit
	trisa = trisa | 0x08;
06AF  3008  	MOVLW 0x08
06B0  0405  	IORWF gbl_trisa, W
06B1  0085  	MOVWF gbl_trisa

	FCV_TRANCIEVER_BIT = ((porta & 0x08) == 0x08);
06B2  3008  	MOVLW 0x08
06B3  1283  	BCF STATUS, RP0
06B4  0505  	ANDWF gbl_porta, W
06B5  1683  	BSF STATUS, RP0
06B6  00B1  	MOVWF CompTempVar2297
06B7  01B2  	CLRF CompTempVar2298
06B8  3008  	MOVLW 0x08
06B9  0231  	SUBWF CompTempVar2297, W
06BA  1903  	BTFSC STATUS,Z
06BB  0AB2  	INCF CompTempVar2298, F
06BC  1283  	BCF STATUS, RP0
06BD  106E  	BCF gbl_FCV_TRANCIEVER_BIT,0
06BE  1683  	BSF STATUS, RP0
06BF  0832  	MOVF CompTempVar2298, W
06C0  1903  	BTFSC STATUS,Z
06C1  2EC4  	GOTO	label72
06C2  1283  	BCF STATUS, RP0
06C3  146E  	BSF gbl_FCV_TRANCIEVER_BIT,0


	//Calculation
	//Calculation:
	//  reg0A_rx_addr_p0_byte4 = reg0A_rx_addr_p0_byte4 + 48
	FCV_REG0A_RX_ADDR_P0_BYTE4 = FCV_REG0A_RX_ADDR_P0_BYTE4 + 48;
06C4  3030  	MOVLW 0x30
06C5  1683  	BSF STATUS, RP0
06C6  072B  	ADDWF gbl_FCV_REG0A_RX_ADDR_P0_BYTE4, W
06C7  00AB  	MOVWF gbl_FCV_REG0A_RX_ADDR_P0_BYTE4


	//Calculation
	//Calculation:
	//  reg10_tx_addr_byte4 = reg0A_rx_addr_p0_byte4
	FCV_REG10_TX_ADDR_BYTE4 = FCV_REG0A_RX_ADDR_P0_BYTE4;
06C8  082B  	MOVF gbl_FCV_REG0A_RX_ADDR_P0_BYTE4, W
06C9  1283  	BCF STATUS, RP0
06CA  00F8  	MOVWF gbl_FCV_REG10_TX_ADDR_BYTE4


	//declare tx addr
	//Calculation:
	//  reg10_tx_addr_byte0 = 'G'
	//  reg10_tx_addr_byte1 = 'B'
	//  reg10_tx_addr_byte2 = 'P'
	//  reg10_tx_addr_byte3 = '0'
	//  reg10_tx_addr_byte4 = '0'
	FCV_REG10_TX_ADDR_BYTE0 = 'G';
06CB  3047  	MOVLW 0x47
06CC  1683  	BSF STATUS, RP0
06CD  00AF  	MOVWF gbl_FCV_REG10_TX_ADDR_BYTE0

	FCV_REG10_TX_ADDR_BYTE1 = 'B';
06CE  3042  	MOVLW 0x42
06CF  1283  	BCF STATUS, RP0
06D0  00F0  	MOVWF gbl_FCV_REG10_TX_ADDR_BYTE1

	FCV_REG10_TX_ADDR_BYTE2 = 'P';
06D1  3050  	MOVLW 0x50
06D2  00F3  	MOVWF gbl_FCV_REG10_TX_ADDR_BYTE2

	FCV_REG10_TX_ADDR_BYTE3 = '0';
06D3  3030  	MOVLW 0x30
06D4  00F5  	MOVWF gbl_FCV_REG10_TX_ADDR_BYTE3

	FCV_REG10_TX_ADDR_BYTE4 = '0';
06D5  00F8  	MOVWF gbl_FCV_REG10_TX_ADDR_BYTE4


	//declare rx addr
	//Calculation:
	//  reg0A_rx_addr_p0_byte0 = 'G'
	//  reg0A_rx_addr_p0_byte1 = 'B'
	//  reg0A_rx_addr_p0_byte2 = 'P'
	//  reg0A_rx_addr_p0_byte3 = '0'
	//  reg0A_rx_addr_p0_byte4 = '0'
	FCV_REG0A_RX_ADDR_P0_BYTE0 = 'G';
06D6  3047  	MOVLW 0x47
06D7  1683  	BSF STATUS, RP0
06D8  00A2  	MOVWF gbl_FCV_REG0A_RX_ADDR_P0_BYTE0

	FCV_REG0A_RX_ADDR_P0_BYTE1 = 'B';
06D9  3042  	MOVLW 0x42
06DA  00A6  	MOVWF gbl_FCV_REG0A_RX_ADDR_P0_BYTE1

	FCV_REG0A_RX_ADDR_P0_BYTE2 = 'P';
06DB  3050  	MOVLW 0x50
06DC  00A7  	MOVWF gbl_FCV_REG0A_RX_ADDR_P0_BYTE2

	FCV_REG0A_RX_ADDR_P0_BYTE3 = '0';
06DD  3030  	MOVLW 0x30
06DE  00A9  	MOVWF gbl_FCV_REG0A_RX_ADDR_P0_BYTE3

	FCV_REG0A_RX_ADDR_P0_BYTE4 = '0';
06DF  00AB  	MOVWF gbl_FCV_REG0A_RX_ADDR_P0_BYTE4


	//Decision
	//Decision: tranciever_bit = 1?
	if (FCV_TRANCIEVER_BIT == 1)
06E0  1283  	BCF STATUS, RP0
06E1  1C6E  	BTFSS gbl_FCV_TRANCIEVER_BIT,0
06E2  2EE7  	GOTO	label73
06E7        label73

	{

		//Interrupt
		//Interrupt: Disable RXINT
		cr_bit(pie1, RCIE);
06E3  1683  	BSF STATUS, RP0
06E4  128C  	BCF gbl_pie1,5


		//Call Macro
		//Call Macro: radio_init_tx()
		FCM_radio_init_tx();
06E5  248C  	CALL FCM_radio__0005B


	} else {
06E6  2EEA  	GOTO	label74
06EA        label74


		//Interrupt
		//Interrupt: Disable RXINT
		cr_bit(pie1, RCIE);
06E7  1683  	BSF STATUS, RP0
06E8  128C  	BCF gbl_pie1,5


		//Call Macro
		//Call Macro: radio_init_rx()
		FCM_radio_init_rx();
06E9  24C7  	CALL FCM_radio__00055


	}

	//rx_ack
	//Output: 0 -> A5
	trisa = trisa & 0xDF;
06EA  30DF  	MOVLW 0xDF
06EB  0505  	ANDWF gbl_trisa, W
06EC  0085  	MOVWF gbl_trisa

	if ((0))
		porta = (porta & 0xDF) | 0x20;
	else
		porta = porta & 0xDF;
06ED  30DF  	MOVLW 0xDF
06EE  1283  	BCF STATUS, RP0
06EF  0505  	ANDWF gbl_porta, W
06F0  0085  	MOVWF gbl_porta


	//tx_ack
	//Output: 0 -> C0
	trisc = trisc & 0xFE;
06F1  30FE  	MOVLW 0xFE
06F2  1683  	BSF STATUS, RP0
06F3  0507  	ANDWF gbl_trisc, W
06F4  0087  	MOVWF gbl_trisc

	if ((0))
		portc = (portc & 0xFE) | 0x01;
	else
		portc = portc & 0xFE;
06F5  30FE  	MOVLW 0xFE
06F6  1283  	BCF STATUS, RP0
06F7  0507  	ANDWF gbl_portc, W
06F8  0087  	MOVWF gbl_portc


	//CSN
	//Output: 1 -> C2
	trisc = trisc & 0xFB;
06F9  30FB  	MOVLW 0xFB
06FA  1683  	BSF STATUS, RP0
06FB  0507  	ANDWF gbl_trisc, W
06FC  0087  	MOVWF gbl_trisc

	if ((1))
		portc = (portc & 0xFB) | 0x04;
06FD  30FB  	MOVLW 0xFB
06FE  1283  	BCF STATUS, RP0
06FF  0507  	ANDWF gbl_portc, W
0700  1683  	BSF STATUS, RP0
0701  00B1  	MOVWF CompTempVar2299
0702  3004  	MOVLW 0x04
0703  0431  	IORWF CompTempVar2299, W
0704  1283  	BCF STATUS, RP0
0705  0087  	MOVWF gbl_portc

	else
		portc = portc & 0xFB;

	//Calculation
	//Calculation:
	//  payload_transmit = "TESTING MESSAGE!"
	FCI_SCOPY("TESTING MESSAGE!",16, FCV_PAYLOAD_TRANSMIT,FCSZ_PAYLOAD_TRANSMIT);
0706  3020  	MOVLW 0x20
0707  1683  	BSF STATUS, RP0
0708  00BA  	MOVWF CompTempVar2300+D'7'
0709  3021  	MOVLW 0x21
070A  00C2  	MOVWF CompTempVar2300+D'15'
070B  3041  	MOVLW 0x41
070C  00BF  	MOVWF CompTempVar2300+D'12'
070D  3045  	MOVLW 0x45
070E  00B4  	MOVWF CompTempVar2300+D'1'
070F  00BC  	MOVWF CompTempVar2300+D'9'
0710  00C1  	MOVWF CompTempVar2300+D'14'
0711  3047  	MOVLW 0x47
0712  00B9  	MOVWF CompTempVar2300+D'6'
0713  00C0  	MOVWF CompTempVar2300+D'13'
0714  3049  	MOVLW 0x49
0715  00B7  	MOVWF CompTempVar2300+D'4'
0716  304D  	MOVLW 0x4D
0717  00BB  	MOVWF CompTempVar2300+D'8'
0718  304E  	MOVLW 0x4E
0719  00B8  	MOVWF CompTempVar2300+D'5'
071A  3053  	MOVLW 0x53
071B  00B5  	MOVWF CompTempVar2300+D'2'
071C  00BD  	MOVWF CompTempVar2300+D'10'
071D  00BE  	MOVWF CompTempVar2300+D'11'
071E  3054  	MOVLW 0x54
071F  00B3  	MOVWF CompTempVar2300
0720  00B6  	MOVWF CompTempVar2300+D'3'
0721  01C3  	CLRF CompTempVar2300+D'16'
0722  3000  	MOVLW HIGH(CompTempVar2300+D'0')
0723  00B2  	MOVWF FCI_SCOPY_00000_arg_sSrc+D'1'
0724  30B3  	MOVLW LOW(CompTempVar2300+D'0')
0725  00B1  	MOVWF FCI_SCOPY_00000_arg_sSrc
0726  3010  	MOVLW 0x10
0727  00C4  	MOVWF FCI_SCOPY_00000_arg_iSrc_len
0728  3000  	MOVLW HIGH(gbl_FCV_PAYLOAD_TRANSMIT+D'0')
0729  00C6  	MOVWF FCI_SCOPY_00000_arg_sDst+D'1'
072A  3032  	MOVLW LOW(gbl_FCV_PAYLOAD_TRANSMIT+D'0')
072B  00C5  	MOVWF FCI_SCOPY_00000_arg_sDst
072C  3010  	MOVLW 0x10
072D  00C7  	MOVWF FCI_SCOPY_00000_arg_iDst_len
072E  21A1  	CALL FCI_SCOPY_00000


	//Calculation
	//Calculation:
	//  flagbit = 0
	FCV_FLAGBIT = 0;
072F  1283  	BCF STATUS, RP0
0730  10EE  	BCF gbl_FCV_FLAGBIT,1


	//Calculation
	//Calculation:
	//  uart_flag = 0
	FCV_UART_FLAG = 0;
0731  116E  	BCF gbl_FCV_UART_FLAG,2


	//Call Component Macro
	//Call Component Macro: Start()
	FCD_LCDDisplay0_Start();
0732  2646  	CALL FCD_LCDDis_0007B


	//Call Component Macro
	//Call Component Macro: Clear()
	FCD_LCDDisplay0_Clear();
0733  2635  	CALL FCD_LCDDis_0007C


	//Call Component Macro
	//Call Component Macro: Cursor(0, 0)
	FCD_LCDDisplay0_Cursor(0, 0);
0734  01B1  	CLRF FCD_LCDDis_0007F_arg_x
0735  01B2  	CLRF FCD_LCDDis_0007F_arg_y
0736  2617  	CALL FCD_LCDDis_0007F


	//Call Component Macro
	//Call Component Macro: PrintString("START")
	FCD_LCDDisplay0_PrintString("START", 5);
0737  3041  	MOVLW 0x41
0738  00B5  	MOVWF CompTempVar2303+D'2'
0739  3052  	MOVLW 0x52
073A  00B6  	MOVWF CompTempVar2303+D'3'
073B  3053  	MOVLW 0x53
073C  00B3  	MOVWF CompTempVar2303
073D  3054  	MOVLW 0x54
073E  00B4  	MOVWF CompTempVar2303+D'1'
073F  00B7  	MOVWF CompTempVar2303+D'4'
0740  01B8  	CLRF CompTempVar2303+D'5'
0741  3000  	MOVLW HIGH(CompTempVar2303+D'0')
0742  00B2  	MOVWF FCD_LCDDis_00081_arg_String+D'1'
0743  30B3  	MOVLW LOW(CompTempVar2303+D'0')
0744  00B1  	MOVWF FCD_LCDDis_00081_arg_String
0745  3005  	MOVLW 0x05
0746  00C0  	MOVWF FCD_LCDDis_00081_arg_MSZ_String
0747  250D  	CALL FCD_LCDDis_00081


	//Loop
	//Loop: While 1
	while (1)
0748        label75
07E4  2F48  	GOTO	label75

	{

		//CE
		//Output: 1 -> C1
		trisc = trisc & 0xFD;
0748  30FD  	MOVLW 0xFD
0749  0507  	ANDWF gbl_trisc, W
074A  0087  	MOVWF gbl_trisc

		if ((1))
			portc = (portc & 0xFD) | 0x02;
074B  30FD  	MOVLW 0xFD
074C  1283  	BCF STATUS, RP0
074D  0507  	ANDWF gbl_portc, W
074E  1683  	BSF STATUS, RP0
074F  00B1  	MOVWF CompTempVar2305
0750  3002  	MOVLW 0x02
0751  0431  	IORWF CompTempVar2305, W
0752  1283  	BCF STATUS, RP0
0753  0087  	MOVWF gbl_portc

		else
			portc = portc & 0xFD;

		//rx_ack
		//Output: 0 -> A5
		trisa = trisa & 0xDF;
0754  30DF  	MOVLW 0xDF
0755  1683  	BSF STATUS, RP0
0756  0505  	ANDWF gbl_trisa, W
0757  0085  	MOVWF gbl_trisa

		if ((0))
			porta = (porta & 0xDF) | 0x20;
		else
			porta = porta & 0xDF;
0758  30DF  	MOVLW 0xDF
0759  1283  	BCF STATUS, RP0
075A  0505  	ANDWF gbl_porta, W
075B  0085  	MOVWF gbl_porta


		//tx_ack
		//Output: 0 -> C0
		trisc = trisc & 0xFE;
075C  30FE  	MOVLW 0xFE
075D  1683  	BSF STATUS, RP0
075E  0507  	ANDWF gbl_trisc, W
075F  0087  	MOVWF gbl_trisc

		if ((0))
			portc = (portc & 0xFE) | 0x01;
		else
			portc = portc & 0xFE;
0760  30FE  	MOVLW 0xFE
0761  1283  	BCF STATUS, RP0
0762  0507  	ANDWF gbl_portc, W
0763  0087  	MOVWF gbl_portc


		//Delay
		//Delay: 1 ms
		delay_ms(1);
0764  3001  	MOVLW 0x01
0765  1683  	BSF STATUS, RP0
0766  00B5  	MOVWF delay_ms_00000_arg_del
0767  2015  	CALL delay_ms_00000


		//Decision
		//Decision: tranciever_bit = 1?
		if (FCV_TRANCIEVER_BIT == 1)
0768  1283  	BCF STATUS, RP0
0769  1C6E  	BTFSS gbl_FCV_TRANCIEVER_BIT,0
076A  2FA3  	GOTO	label76
07A3        label76

		{

			//Call Component Macro
			//Call Component Macro: Cursor(0, 0)
			FCD_LCDDisplay0_Cursor(0, 0);
076B  1683  	BSF STATUS, RP0
076C  01B1  	CLRF FCD_LCDDis_0007F_arg_x
076D  01B2  	CLRF FCD_LCDDis_0007F_arg_y
076E  2617  	CALL FCD_LCDDis_0007F


			//Call Component Macro
			//Call Component Macro: PrintString("NRF tx mode")
			FCD_LCDDisplay0_PrintString("NRF tx mode", 11);
076F  3020  	MOVLW 0x20
0770  00B6  	MOVWF CompTempVar2306+D'3'
0771  00B9  	MOVWF CompTempVar2306+D'6'
0772  3046  	MOVLW 0x46
0773  00B5  	MOVWF CompTempVar2306+D'2'
0774  304E  	MOVLW 0x4E
0775  00B3  	MOVWF CompTempVar2306
0776  3052  	MOVLW 0x52
0777  00B4  	MOVWF CompTempVar2306+D'1'
0778  3064  	MOVLW 0x64
0779  00BC  	MOVWF CompTempVar2306+D'9'
077A  3065  	MOVLW 0x65
077B  00BD  	MOVWF CompTempVar2306+D'10'
077C  306D  	MOVLW 0x6D
077D  00BA  	MOVWF CompTempVar2306+D'7'
077E  306F  	MOVLW 0x6F
077F  00BB  	MOVWF CompTempVar2306+D'8'
0780  3074  	MOVLW 0x74
0781  00B7  	MOVWF CompTempVar2306+D'4'
0782  3078  	MOVLW 0x78
0783  00B8  	MOVWF CompTempVar2306+D'5'
0784  01BE  	CLRF CompTempVar2306+D'11'
0785  3000  	MOVLW HIGH(CompTempVar2306+D'0')
0786  00B2  	MOVWF FCD_LCDDis_00081_arg_String+D'1'
0787  30B3  	MOVLW LOW(CompTempVar2306+D'0')
0788  00B1  	MOVWF FCD_LCDDis_00081_arg_String
0789  300B  	MOVLW 0x0B
078A  00C0  	MOVWF FCD_LCDDis_00081_arg_MSZ_String
078B  250D  	CALL FCD_LCDDis_00081


			//Call Macro
			//Call Macro: radio_init_tx()
			FCM_radio_init_tx();
078C  248C  	CALL FCM_radio__0005B


			//Call Macro
			//Call Macro: radio_send_data()
			FCM_radio_send_data();
078D  240B  	CALL FCM_radio__0005C


			//Call Component Macro
			//Call Component Macro: Cursor(0, 3)
			FCD_LCDDisplay0_Cursor(0, 3);
078E  1683  	BSF STATUS, RP0
078F  01B1  	CLRF FCD_LCDDis_0007F_arg_x
0790  3003  	MOVLW 0x03
0791  00B2  	MOVWF FCD_LCDDis_0007F_arg_y
0792  2617  	CALL FCD_LCDDis_0007F


			//Call Component Macro
			//Call Component Macro: PrintNumber(reg07)
			FCD_LCDDisplay0_PrintNumber(FCV_REG07);
0793  0820  	MOVF gbl_FCV_REG07, W
0794  00B1  	MOVWF FCD_LCDDis_00080_arg_Number
0795  01B2  	CLRF FCD_LCDDis_00080_arg_Number+D'1'
0796  2529  	CALL FCD_LCDDis_00080


			//Call Component Macro
			//Call Component Macro: Cursor(4, 3)
			FCD_LCDDisplay0_Cursor(4, 3);
0797  3004  	MOVLW 0x04
0798  00B1  	MOVWF FCD_LCDDis_0007F_arg_x
0799  3003  	MOVLW 0x03
079A  00B2  	MOVWF FCD_LCDDis_0007F_arg_y
079B  2617  	CALL FCD_LCDDis_0007F


			//Call Component Macro
			//Call Component Macro: PrintNumber(reg17)
			FCD_LCDDisplay0_PrintNumber(FCV_REG17);
079C  1283  	BCF STATUS, RP0
079D  087E  	MOVF gbl_FCV_REG17, W
079E  1683  	BSF STATUS, RP0
079F  00B1  	MOVWF FCD_LCDDis_00080_arg_Number
07A0  01B2  	CLRF FCD_LCDDis_00080_arg_Number+D'1'
07A1  2529  	CALL FCD_LCDDis_00080


		} else {
07A2  2F48  	GOTO	label75


			//Call Component Macro
			//Call Component Macro: Cursor(0, 0)
			FCD_LCDDisplay0_Cursor(0, 0);
07A3  1683  	BSF STATUS, RP0
07A4  01B1  	CLRF FCD_LCDDis_0007F_arg_x
07A5  01B2  	CLRF FCD_LCDDis_0007F_arg_y
07A6  2617  	CALL FCD_LCDDis_0007F


			//Call Component Macro
			//Call Component Macro: PrintString("NRF reciever")
			FCD_LCDDisplay0_PrintString("NRF reciever", 12);
07A7  3020  	MOVLW 0x20
07A8  00B6  	MOVWF CompTempVar2308+D'3'
07A9  3046  	MOVLW 0x46
07AA  00B5  	MOVWF CompTempVar2308+D'2'
07AB  304E  	MOVLW 0x4E
07AC  00B3  	MOVWF CompTempVar2308
07AD  3052  	MOVLW 0x52
07AE  00B4  	MOVWF CompTempVar2308+D'1'
07AF  3063  	MOVLW 0x63
07B0  00B9  	MOVWF CompTempVar2308+D'6'
07B1  3065  	MOVLW 0x65
07B2  00B8  	MOVWF CompTempVar2308+D'5'
07B3  00BB  	MOVWF CompTempVar2308+D'8'
07B4  00BD  	MOVWF CompTempVar2308+D'10'
07B5  3069  	MOVLW 0x69
07B6  00BA  	MOVWF CompTempVar2308+D'7'
07B7  3072  	MOVLW 0x72
07B8  00B7  	MOVWF CompTempVar2308+D'4'
07B9  00BE  	MOVWF CompTempVar2308+D'11'
07BA  3076  	MOVLW 0x76
07BB  00BC  	MOVWF CompTempVar2308+D'9'
07BC  01BF  	CLRF CompTempVar2308+D'12'
07BD  3000  	MOVLW HIGH(CompTempVar2308+D'0')
07BE  00B2  	MOVWF FCD_LCDDis_00081_arg_String+D'1'
07BF  30B3  	MOVLW LOW(CompTempVar2308+D'0')
07C0  00B1  	MOVWF FCD_LCDDis_00081_arg_String
07C1  300C  	MOVLW 0x0C
07C2  00C0  	MOVWF FCD_LCDDis_00081_arg_MSZ_String
07C3  250D  	CALL FCD_LCDDis_00081


			//Call Macro
			//Call Macro: radio_init_rx()
			FCM_radio_init_rx();
07C4  24C7  	CALL FCM_radio__00055


			//Call Macro
			//Call Macro: radio_recieve_data()
			FCM_radio_recieve_data();
07C5  23CD  	CALL FCM_radio__0005E


			//Call Component Macro
			//Call Component Macro: Cursor(0, 2)
			FCD_LCDDisplay0_Cursor(0, 2);
07C6  01B1  	CLRF FCD_LCDDis_0007F_arg_x
07C7  3002  	MOVLW 0x02
07C8  00B2  	MOVWF FCD_LCDDis_0007F_arg_y
07C9  2617  	CALL FCD_LCDDis_0007F


			//Call Component Macro
			//Call Component Macro: PrintString(payload_recieve)
			FCD_LCDDisplay0_PrintString(FCV_PAYLOAD_RECIEVE, FCSZ_PAYLOAD_RECIEVE);
07CA  3000  	MOVLW HIGH(gbl_FCV_PAYLOAD_RECIEVE+D'0')
07CB  00B2  	MOVWF FCD_LCDDis_00081_arg_String+D'1'
07CC  3020  	MOVLW LOW(gbl_FCV_PAYLOAD_RECIEVE+D'0')
07CD  00B1  	MOVWF FCD_LCDDis_00081_arg_String
07CE  3012  	MOVLW 0x12
07CF  00C0  	MOVWF FCD_LCDDis_00081_arg_MSZ_String
07D0  250D  	CALL FCD_LCDDis_00081


			//Call Component Macro
			//Call Component Macro: Cursor(0, 3)
			FCD_LCDDisplay0_Cursor(0, 3);
07D1  01B1  	CLRF FCD_LCDDis_0007F_arg_x
07D2  3003  	MOVLW 0x03
07D3  00B2  	MOVWF FCD_LCDDis_0007F_arg_y
07D4  2617  	CALL FCD_LCDDis_0007F


			//Call Component Macro
			//Call Component Macro: PrintNumber(reg07)
			FCD_LCDDisplay0_PrintNumber(FCV_REG07);
07D5  0820  	MOVF gbl_FCV_REG07, W
07D6  00B1  	MOVWF FCD_LCDDis_00080_arg_Number
07D7  01B2  	CLRF FCD_LCDDis_00080_arg_Number+D'1'
07D8  2529  	CALL FCD_LCDDis_00080


			//Call Component Macro
			//Call Component Macro: Cursor(4, 3)
			FCD_LCDDisplay0_Cursor(4, 3);
07D9  3004  	MOVLW 0x04
07DA  00B1  	MOVWF FCD_LCDDis_0007F_arg_x
07DB  3003  	MOVLW 0x03
07DC  00B2  	MOVWF FCD_LCDDis_0007F_arg_y
07DD  2617  	CALL FCD_LCDDis_0007F


			//Call Component Macro
			//Call Component Macro: PrintNumber(reg17)
			FCD_LCDDisplay0_PrintNumber(FCV_REG17);
07DE  1283  	BCF STATUS, RP0
07DF  087E  	MOVF gbl_FCV_REG17, W
07E0  1683  	BSF STATUS, RP0
07E1  00B1  	MOVWF FCD_LCDDis_00080_arg_Number
07E2  01B2  	CLRF FCD_LCDDis_00080_arg_Number+D'1'
07E3  2529  	CALL FCD_LCDDis_00080


		}


	}

	mainendloop: goto mainendloop;
}


void MX_INTERRUPT_MACRO(void)

{
}
0843  1283  	BCF STATUS, RP0
0844  1303  	BCF STATUS, RP1
0845  0E62  	SWAPF Int1BContext+D'2', W
0846  0084  	MOVWF FSR
0847  0E61  	SWAPF Int1BContext+D'1', W
0848  008A  	MOVWF PCLATH
0849  0E60  	SWAPF Int1BContext, W
084A  0083  	MOVWF STATUS
084B  0EFF  	SWAPF Int1Context, F
084C  0E7F  	SWAPF Int1Context, W
084D  0009  	RETFIE





/*********************************************************************
 *                  Flowcode CAL SPI File
 *
 * File: PIC_CAL_SPI.c
 *
 * (c) 2011 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * “Company”) for its Flowcode graphical programming language is
 * intended and supplied to you, the Company’s customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 010911 | BR | Created
 * 150911 | BR | Updated variables with typedef alternatives
 * 011211 | BR | Converted to new dynamic defines mechanism
 *
 */


//When using hardware SPI channels override port and pin conns with FCD conn definitions
//Only overwrite CS pin defines when using SPI in slave mode on a hardware channel
//Also sort out postscale and prescale options for hardware channels
#ifdef MX_SPI_REF1
	#if MX_SPI_CHANNEL_1 > 0
		#undef MX_SPI_MOSI_PIN_1
		#undef MX_SPI_MOSI_PORT_1
		#undef MX_SPI_MOSI_TRIS_1
		#undef MX_SPI_MISO_PIN_1
		#undef MX_SPI_MISO_PORT_1
		#undef MX_SPI_MISO_TRIS_1
		#undef MX_SPI_SCK_PIN_1
		#undef MX_SPI_SCK_PORT_1
		#undef MX_SPI_SCK_TRIS_1
		#undef MX_SPI_CS_PIN_1
		#undef MX_SPI_CS_PORT_1
		#undef MX_SPI_CS_TRIS_1

		#if MX_SPI_PR_SCALE_1 == 4
			#undef MX_SPI_PR_SCALE_1
			#define MX_SPI_PR_SCALE_1	0
		#endif
		#if MX_SPI_PR_SCALE_1 == 16
			#undef MX_SPI_PR_SCALE_1
			#define MX_SPI_PR_SCALE_1	1
		#endif
		#if MX_SPI_PR_SCALE_1 == 64
			#undef MX_SPI_PR_SCALE_1
			#define MX_SPI_PR_SCALE_1	2
		#endif
	#endif
	#if MX_SPI_CHANNEL_1 == 1
		#define MX_SPI_MOSI_PIN_1		MX_SPI_1_MOSI_PIN
		#define MX_SPI_MOSI_PORT_1		MX_SPI_1_MOSI_PORT
		#define MX_SPI_MOSI_TRIS_1		MX_SPI_1_MOSI_TRIS
		#define MX_SPI_MISO_PIN_1		MX_SPI_1_MISO_PIN
		#define MX_SPI_MISO_PORT_1		MX_SPI_1_MISO_PORT
		#define MX_SPI_MISO_TRIS_1		MX_SPI_1_MISO_TRIS
		#define MX_SPI_SCK_PIN_1		MX_SPI_1_CLK_PIN
		#define MX_SPI_SCK_PORT_1		MX_SPI_1_CLK_PORT
		#define MX_SPI_SCK_TRIS_1		MX_SPI_1_CLK_TRIS
		#define MX_SPI_CS_PIN_1			MX_SPI_1_SS_PIN
		#define MX_SPI_CS_PORT_1		MX_SPI_1_SS_PORT
		#define MX_SPI_CS_TRIS_1		MX_SPI_1_SS_TRIS
	#endif
	#if MX_SPI_CHANNEL_1 == 2
		#define MX_SPI_MOSI_PIN_1		MX_SPI_2_MOSI_PIN
		#define MX_SPI_MOSI_PORT_1		MX_SPI_2_MOSI_PORT
		#define MX_SPI_MOSI_TRIS_1		MX_SPI_2_MOSI_TRIS
		#define MX_SPI_MISO_PIN_1		MX_SPI_2_MISO_PIN
		#define MX_SPI_MISO_PORT_1		MX_SPI_2_MISO_PORT
		#define MX_SPI_MISO_TRIS_1		MX_SPI_2_MISO_TRIS
		#define MX_SPI_SCK_PIN_1		MX_SPI_2_CLK_PIN
		#define MX_SPI_SCK_PORT_1		MX_SPI_2_CLK_PORT
		#define MX_SPI_SCK_TRIS_1		MX_SPI_2_CLK_TRIS
		#define MX_SPI_CS_PIN_1			MX_SPI_2_SS_PIN
		#define MX_SPI_CS_PORT_1		MX_SPI_2_SS_PORT
		#define MX_SPI_CS_TRIS_1		MX_SPI_2_SS_TRIS
	#endif
	#if MX_SPI_CHANNEL_1 == 3
		#define MX_SPI_MOSI_PIN_1		MX_SPI_3_MOSI_PIN
		#define MX_SPI_MOSI_PORT_1		MX_SPI_3_MOSI_PORT
		#define MX_SPI_MOSI_TRIS_1		MX_SPI_3_MOSI_TRIS
		#define MX_SPI_MISO_PIN_1		MX_SPI_3_MISO_PIN
		#define MX_SPI_MISO_PORT_1		MX_SPI_3_MISO_PORT
		#define MX_SPI_MISO_TRIS_1		MX_SPI_3_MISO_TRIS
		#define MX_SPI_SCK_PIN_1		MX_SPI_3_CLK_PIN
		#define MX_SPI_SCK_PORT_1		MX_SPI_3_CLK_PORT
		#define MX_SPI_SCK_TRIS_1		MX_SPI_3_CLK_TRIS
		#define MX_SPI_CS_PIN_1			MX_SPI_3_SS_PIN
		#define MX_SPI_CS_PORT_1		MX_SPI_3_SS_PORT
		#define MX_SPI_CS_TRIS_1		MX_SPI_3_SS_TRIS
	#endif
	#if MX_SPI_CHANNEL_1 == 4
		#define MX_SPI_MOSI_PIN_1		MX_SPI_4_MOSI_PIN
		#define MX_SPI_MOSI_PORT_1		MX_SPI_4_MOSI_PORT
		#define MX_SPI_MOSI_TRIS_1		MX_SPI_4_MOSI_TRIS
		#define MX_SPI_MISO_PIN_1		MX_SPI_4_MISO_PIN
		#define MX_SPI_MISO_PORT_1		MX_SPI_4_MISO_PORT
		#define MX_SPI_MISO_TRIS_1		MX_SPI_4_MISO_TRIS
		#define MX_SPI_SCK_PIN_1		MX_SPI_4_CLK_PIN
		#define MX_SPI_SCK_PORT_1		MX_SPI_4_CLK_PORT
		#define MX_SPI_SCK_TRIS_1		MX_SPI_4_CLK_TRIS
		#define MX_SPI_CS_PIN_1			MX_SPI_4_SS_PIN
		#define MX_SPI_CS_PORT_1		MX_SPI_4_SS_PORT
		#define MX_SPI_CS_TRIS_1		MX_SPI_4_SS_TRIS
	#endif
#endif
#ifdef MX_SPI_REF2
	#if MX_SPI_CHANNEL_2 > 0
		#undef MX_SPI_MOSI_PIN_2
		#undef MX_SPI_MOSI_PORT_2
		#undef MX_SPI_MOSI_TRIS_2
		#undef MX_SPI_MISO_PIN_2
		#undef MX_SPI_MISO_PORT_2
		#undef MX_SPI_MISO_TRIS_2
		#undef MX_SPI_SCK_PIN_2
		#undef MX_SPI_SCK_PORT_2
		#undef MX_SPI_SCK_TRIS_2
		#undef MX_SPI_CS_PIN_2
		#undef MX_SPI_CS_PORT_2
		#undef MX_SPI_CS_TRIS_2

		#if MX_SPI_PR_SCALE_2 == 4
			#undef MX_SPI_PR_SCALE_2
			#define MX_SPI_PR_SCALE_2	0
		#endif
		#if MX_SPI_PR_SCALE_2 == 16
			#undef MX_SPI_PR_SCALE_2
			#define MX_SPI_PR_SCALE_2	1
		#endif
		#if MX_SPI_PR_SCALE_2 == 64
			#undef MX_SPI_PR_SCALE_2
			#define MX_SPI_PR_SCALE_2	2
		#endif
	#endif
	#if MX_SPI_CHANNEL_2 == 1
		#define MX_SPI_MOSI_PIN_2		MX_SPI_1_MOSI_PIN
		#define MX_SPI_MOSI_PORT_2		MX_SPI_1_MOSI_PORT
		#define MX_SPI_MOSI_TRIS_2		MX_SPI_1_MOSI_TRIS
		#define MX_SPI_MISO_PIN_2		MX_SPI_1_MISO_PIN
		#define MX_SPI_MISO_PORT_2		MX_SPI_1_MISO_PORT
		#define MX_SPI_MISO_TRIS_2		MX_SPI_1_MISO_TRIS
		#define MX_SPI_SCK_PIN_2		MX_SPI_1_CLK_PIN
		#define MX_SPI_SCK_PORT_2		MX_SPI_1_CLK_PORT
		#define MX_SPI_SCK_TRIS_2		MX_SPI_1_CLK_TRIS
		#define MX_SPI_CS_PIN_2			MX_SPI_1_SS_PIN
		#define MX_SPI_CS_PORT_2		MX_SPI_1_SS_PORT
		#define MX_SPI_CS_TRIS_2		MX_SPI_1_SS_TRIS
	#endif
	#if MX_SPI_CHANNEL_2 == 2
		#define MX_SPI_MOSI_PIN_2		MX_SPI_2_MOSI_PIN
		#define MX_SPI_MOSI_PORT_2		MX_SPI_2_MOSI_PORT
		#define MX_SPI_MOSI_TRIS_2		MX_SPI_2_MOSI_TRIS
		#define MX_SPI_MISO_PIN_2		MX_SPI_2_MISO_PIN
		#define MX_SPI_MISO_PORT_2		MX_SPI_2_MISO_PORT
		#define MX_SPI_MISO_TRIS_2		MX_SPI_2_MISO_TRIS
		#define MX_SPI_SCK_PIN_2		MX_SPI_2_CLK_PIN
		#define MX_SPI_SCK_PORT_2		MX_SPI_2_CLK_PORT
		#define MX_SPI_SCK_TRIS_2		MX_SPI_2_CLK_TRIS
		#define MX_SPI_CS_PIN_2			MX_SPI_2_SS_PIN
		#define MX_SPI_CS_PORT_2		MX_SPI_2_SS_PORT
		#define MX_SPI_CS_TRIS_2		MX_SPI_2_SS_TRIS
	#endif
	#if MX_SPI_CHANNEL_2 == 3
		#define MX_SPI_MOSI_PIN_2		MX_SPI_3_MOSI_PIN
		#define MX_SPI_MOSI_PORT_2		MX_SPI_3_MOSI_PORT
		#define MX_SPI_MOSI_TRIS_2		MX_SPI_3_MOSI_TRIS
		#define MX_SPI_MISO_PIN_2		MX_SPI_3_MISO_PIN
		#define MX_SPI_MISO_PORT_2		MX_SPI_3_MISO_PORT
		#define MX_SPI_MISO_TRIS_2		MX_SPI_3_MISO_TRIS
		#define MX_SPI_SCK_PIN_2		MX_SPI_3_CLK_PIN
		#define MX_SPI_SCK_PORT_2		MX_SPI_3_CLK_PORT
		#define MX_SPI_SCK_TRIS_2		MX_SPI_3_CLK_TRIS
		#define MX_SPI_CS_PIN_2			MX_SPI_3_SS_PIN
		#define MX_SPI_CS_PORT_2		MX_SPI_3_SS_PORT
		#define MX_SPI_CS_TRIS_2		MX_SPI_3_SS_TRIS
	#endif
	#if MX_SPI_CHANNEL_2 == 4
		#define MX_SPI_MOSI_PIN_2		MX_SPI_4_MOSI_PIN
		#define MX_SPI_MOSI_PORT_2		MX_SPI_4_MOSI_PORT
		#define MX_SPI_MOSI_TRIS_2		MX_SPI_4_MOSI_TRIS
		#define MX_SPI_MISO_PIN_2		MX_SPI_4_MISO_PIN
		#define MX_SPI_MISO_PORT_2		MX_SPI_4_MISO_PORT
		#define MX_SPI_MISO_TRIS_2		MX_SPI_4_MISO_TRIS
		#define MX_SPI_SCK_PIN_2		MX_SPI_4_CLK_PIN
		#define MX_SPI_SCK_PORT_2		MX_SPI_4_CLK_PORT
		#define MX_SPI_SCK_TRIS_2		MX_SPI_4_CLK_TRIS
		#define MX_SPI_CS_PIN_2			MX_SPI_4_SS_PIN
		#define MX_SPI_CS_PORT_2		MX_SPI_4_SS_PORT
		#define MX_SPI_CS_TRIS_2		MX_SPI_4_SS_TRIS
	#endif
#endif
#ifdef MX_SPI_REF3
	#if MX_SPI_CHANNEL_3 > 0
		#undef MX_SPI_MOSI_PIN_3
		#undef MX_SPI_MOSI_PORT_3
		#undef MX_SPI_MOSI_TRIS_3
		#undef MX_SPI_MISO_PIN_3
		#undef MX_SPI_MISO_PORT_3
		#undef MX_SPI_MISO_TRIS_3
		#undef MX_SPI_SCK_PIN_3
		#undef MX_SPI_SCK_PORT_3
		#undef MX_SPI_SCK_TRIS_3
		#undef MX_SPI_CS_PIN_3
		#undef MX_SPI_CS_PORT_3
		#undef MX_SPI_CS_TRIS_3

		#if MX_SPI_PR_SCALE_3 == 4
			#undef MX_SPI_PR_SCALE_3
			#define MX_SPI_PR_SCALE_3	0
		#endif
		#if MX_SPI_PR_SCALE_3 == 16
			#undef MX_SPI_PR_SCALE_3
			#define MX_SPI_PR_SCALE_3	1
		#endif
		#if MX_SPI_PR_SCALE_3 == 64
			#undef MX_SPI_PR_SCALE_3
			#define MX_SPI_PR_SCALE_3	2
		#endif
	#endif
	#if MX_SPI_CHANNEL_3 == 1
		#define MX_SPI_MOSI_PIN_3		MX_SPI_1_MOSI_PIN
		#define MX_SPI_MOSI_PORT_3		MX_SPI_1_MOSI_PORT
		#define MX_SPI_MOSI_TRIS_3		MX_SPI_1_MOSI_TRIS
		#define MX_SPI_MISO_PIN_3		MX_SPI_1_MISO_PIN
		#define MX_SPI_MISO_PORT_3		MX_SPI_1_MISO_PORT
		#define MX_SPI_MISO_TRIS_3		MX_SPI_1_MISO_TRIS
		#define MX_SPI_SCK_PIN_3		MX_SPI_1_CLK_PIN
		#define MX_SPI_SCK_PORT_3		MX_SPI_1_CLK_PORT
		#define MX_SPI_SCK_TRIS_3		MX_SPI_1_CLK_TRIS
		#define MX_SPI_CS_PIN_3			MX_SPI_1_SS_PIN
		#define MX_SPI_CS_PORT_3		MX_SPI_1_SS_PORT
		#define MX_SPI_CS_TRIS_3		MX_SPI_1_SS_TRIS
	#endif
	#if MX_SPI_CHANNEL_3 == 2
		#define MX_SPI_MOSI_PIN_3		MX_SPI_2_MOSI_PIN
		#define MX_SPI_MOSI_PORT_3		MX_SPI_2_MOSI_PORT
		#define MX_SPI_MOSI_TRIS_3		MX_SPI_2_MOSI_TRIS
		#define MX_SPI_MISO_PIN_3		MX_SPI_2_MISO_PIN
		#define MX_SPI_MISO_PORT_3		MX_SPI_2_MISO_PORT
		#define MX_SPI_MISO_TRIS_3		MX_SPI_2_MISO_TRIS
		#define MX_SPI_SCK_PIN_3		MX_SPI_2_CLK_PIN
		#define MX_SPI_SCK_PORT_3		MX_SPI_2_CLK_PORT
		#define MX_SPI_SCK_TRIS_3		MX_SPI_2_CLK_TRIS
		#define MX_SPI_CS_PIN_3			MX_SPI_2_SS_PIN
		#define MX_SPI_CS_PORT_3		MX_SPI_2_SS_PORT
		#define MX_SPI_CS_TRIS_3		MX_SPI_2_SS_TRIS
	#endif
	#if MX_SPI_CHANNEL_3 == 3
		#define MX_SPI_MOSI_PIN_3		MX_SPI_3_MOSI_PIN
		#define MX_SPI_MOSI_PORT_3		MX_SPI_3_MOSI_PORT
		#define MX_SPI_MOSI_TRIS_3		MX_SPI_3_MOSI_TRIS
		#define MX_SPI_MISO_PIN_3		MX_SPI_3_MISO_PIN
		#define MX_SPI_MISO_PORT_3		MX_SPI_3_MISO_PORT
		#define MX_SPI_MISO_TRIS_3		MX_SPI_3_MISO_TRIS
		#define MX_SPI_SCK_PIN_3		MX_SPI_3_CLK_PIN
		#define MX_SPI_SCK_PORT_3		MX_SPI_3_CLK_PORT
		#define MX_SPI_SCK_TRIS_3		MX_SPI_3_CLK_TRIS
		#define MX_SPI_CS_PIN_3			MX_SPI_3_SS_PIN
		#define MX_SPI_CS_PORT_3		MX_SPI_3_SS_PORT
		#define MX_SPI_CS_TRIS_3		MX_SPI_3_SS_TRIS
	#endif
	#if MX_SPI_CHANNEL_3 == 4
		#define MX_SPI_MOSI_PIN_3		MX_SPI_4_MOSI_PIN
		#define MX_SPI_MOSI_PORT_3		MX_SPI_4_MOSI_PORT
		#define MX_SPI_MOSI_TRIS_3		MX_SPI_4_MOSI_TRIS
		#define MX_SPI_MISO_PIN_3		MX_SPI_4_MISO_PIN
		#define MX_SPI_MISO_PORT_3		MX_SPI_4_MISO_PORT
		#define MX_SPI_MISO_TRIS_3		MX_SPI_4_MISO_TRIS
		#define MX_SPI_SCK_PIN_3		MX_SPI_4_CLK_PIN
		#define MX_SPI_SCK_PORT_3		MX_SPI_4_CLK_PORT
		#define MX_SPI_SCK_TRIS_3		MX_SPI_4_CLK_TRIS
		#define MX_SPI_CS_PIN_3			MX_SPI_4_SS_PIN
		#define MX_SPI_CS_PORT_3		MX_SPI_4_SS_PORT
		#define MX_SPI_CS_TRIS_3		MX_SPI_4_SS_TRIS
	#endif
#endif
#ifdef MX_SPI_REF4
	#if MX_SPI_CHANNEL_4 > 0
		#undef MX_SPI_MOSI_PIN_4
		#undef MX_SPI_MOSI_PORT_4
		#undef MX_SPI_MOSI_TRIS_4
		#undef MX_SPI_MISO_PIN_4
		#undef MX_SPI_MISO_PORT_4
		#undef MX_SPI_MISO_TRIS_4
		#undef MX_SPI_SCK_PIN_4
		#undef MX_SPI_SCK_PORT_4
		#undef MX_SPI_SCK_TRIS_4
		#undef MX_SPI_CS_PIN_4
		#undef MX_SPI_CS_PORT_4
		#undef MX_SPI_CS_TRIS_4

		#if MX_SPI_PR_SCALE_4 == 4
			#undef MX_SPI_PR_SCALE_4
			#define MX_SPI_PR_SCALE_4	0
		#endif
		#if MX_SPI_PR_SCALE_4 == 16
			#undef MX_SPI_PR_SCALE_4
			#define MX_SPI_PR_SCALE_4	1
		#endif
		#if MX_SPI_PR_SCALE_4 == 64
			#undef MX_SPI_PR_SCALE_4
			#define MX_SPI_PR_SCALE_4	2
		#endif
	#endif
	#if MX_SPI_CHANNEL_4 == 1
		#define MX_SPI_MOSI_PIN_4		MX_SPI_1_MOSI_PIN
		#define MX_SPI_MOSI_PORT_4		MX_SPI_1_MOSI_PORT
		#define MX_SPI_MOSI_TRIS_4		MX_SPI_1_MOSI_TRIS
		#define MX_SPI_MISO_PIN_4		MX_SPI_1_MISO_PIN
		#define MX_SPI_MISO_PORT_4		MX_SPI_1_MISO_PORT
		#define MX_SPI_MISO_TRIS_4		MX_SPI_1_MISO_TRIS
		#define MX_SPI_SCK_PIN_4		MX_SPI_1_CLK_PIN
		#define MX_SPI_SCK_PORT_4		MX_SPI_1_CLK_PORT
		#define MX_SPI_SCK_TRIS_4		MX_SPI_1_CLK_TRIS
		#define MX_SPI_CS_PIN_4			MX_SPI_1_SS_PIN
		#define MX_SPI_CS_PORT_4		MX_SPI_1_SS_PORT
		#define MX_SPI_CS_TRIS_4		MX_SPI_1_SS_TRIS
	#endif
	#if MX_SPI_CHANNEL_4 == 2
		#define MX_SPI_MOSI_PIN_4		MX_SPI_2_MOSI_PIN
		#define MX_SPI_MOSI_PORT_4		MX_SPI_2_MOSI_PORT
		#define MX_SPI_MOSI_TRIS_4		MX_SPI_2_MOSI_TRIS
		#define MX_SPI_MISO_PIN_4		MX_SPI_2_MISO_PIN
		#define MX_SPI_MISO_PORT_4		MX_SPI_2_MISO_PORT
		#define MX_SPI_MISO_TRIS_4		MX_SPI_2_MISO_TRIS
		#define MX_SPI_SCK_PIN_4		MX_SPI_2_CLK_PIN
		#define MX_SPI_SCK_PORT_4		MX_SPI_2_CLK_PORT
		#define MX_SPI_SCK_TRIS_4		MX_SPI_2_CLK_TRIS
		#define MX_SPI_CS_PIN_4			MX_SPI_2_SS_PIN
		#define MX_SPI_CS_PORT_4		MX_SPI_2_SS_PORT
		#define MX_SPI_CS_TRIS_4		MX_SPI_2_SS_TRIS
	#endif
	#if MX_SPI_CHANNEL_4 == 3
		#define MX_SPI_MOSI_PIN_4		MX_SPI_3_MOSI_PIN
		#define MX_SPI_MOSI_PORT_4		MX_SPI_3_MOSI_PORT
		#define MX_SPI_MOSI_TRIS_4		MX_SPI_3_MOSI_TRIS
		#define MX_SPI_MISO_PIN_4		MX_SPI_3_MISO_PIN
		#define MX_SPI_MISO_PORT_4		MX_SPI_3_MISO_PORT
		#define MX_SPI_MISO_TRIS_4		MX_SPI_3_MISO_TRIS
		#define MX_SPI_SCK_PIN_4		MX_SPI_3_CLK_PIN
		#define MX_SPI_SCK_PORT_4		MX_SPI_3_CLK_PORT
		#define MX_SPI_SCK_TRIS_4		MX_SPI_3_CLK_TRIS
		#define MX_SPI_CS_PIN_4			MX_SPI_3_SS_PIN
		#define MX_SPI_CS_PORT_4		MX_SPI_3_SS_PORT
		#define MX_SPI_CS_TRIS_4		MX_SPI_3_SS_TRIS
	#endif
	#if MX_SPI_CHANNEL_4 == 4
		#define MX_SPI_MOSI_PIN_4		MX_SPI_4_MOSI_PIN
		#define MX_SPI_MOSI_PORT_4		MX_SPI_4_MOSI_PORT
		#define MX_SPI_MOSI_TRIS_4		MX_SPI_4_MOSI_TRIS
		#define MX_SPI_MISO_PIN_4		MX_SPI_4_MISO_PIN
		#define MX_SPI_MISO_PORT_4		MX_SPI_4_MISO_PORT
		#define MX_SPI_MISO_TRIS_4		MX_SPI_4_MISO_TRIS
		#define MX_SPI_SCK_PIN_4		MX_SPI_4_CLK_PIN
		#define MX_SPI_SCK_PORT_4		MX_SPI_4_CLK_PORT
		#define MX_SPI_SCK_TRIS_4		MX_SPI_4_CLK_TRIS
		#define MX_SPI_CS_PIN_4			MX_SPI_4_SS_PIN
		#define MX_SPI_CS_PORT_4		MX_SPI_4_SS_PORT
		#define MX_SPI_CS_TRIS_4		MX_SPI_4_SS_TRIS
	#endif
#endif

#define MX_SPI_CHANNEL_X		CAL_APPEND(MX_SPI_CHANNEL_, MX_SPI_NUM)
#define MX_SPI_MOSI_PIN_X		CAL_APPEND(MX_SPI_MOSI_PIN_, MX_SPI_NUM)
#define MX_SPI_MOSI_PORT_X		CAL_APPEND(MX_SPI_MOSI_PORT_, MX_SPI_NUM)
#define MX_SPI_MOSI_TRIS_X		CAL_APPEND(MX_SPI_MOSI_TRIS_, MX_SPI_NUM)
#define MX_SPI_MISO_PIN_X		CAL_APPEND(MX_SPI_MISO_PIN_, MX_SPI_NUM)
#define MX_SPI_MISO_PORT_X		CAL_APPEND(MX_SPI_MISO_PORT_, MX_SPI_NUM)
#define MX_SPI_MISO_TRIS_X		CAL_APPEND(MX_SPI_MISO_TRIS_, MX_SPI_NUM)
#define MX_SPI_SCK_PIN_X		CAL_APPEND(MX_SPI_SCK_PIN_, MX_SPI_NUM)
#define MX_SPI_SCK_PORT_X		CAL_APPEND(MX_SPI_SCK_PORT_, MX_SPI_NUM)
#define MX_SPI_SCK_TRIS_X		CAL_APPEND(MX_SPI_SCK_TRIS_, MX_SPI_NUM)
#define MX_SPI_CS_PIN_X			CAL_APPEND(MX_SPI_CS_PIN_, MX_SPI_NUM)
#define MX_SPI_CS_PORT_X		CAL_APPEND(MX_SPI_CS_PORT_, MX_SPI_NUM)
#define MX_SPI_CS_TRIS_X		CAL_APPEND(MX_SPI_CS_TRIS_, MX_SPI_NUM)
#define MX_SPI_BMODE_X			CAL_APPEND(MX_SPI_BMODE_, MX_SPI_NUM)
#define MX_SPI_PR_SCALE_X		CAL_APPEND(MX_SPI_PR_SCALE_, MX_SPI_NUM)
#define MX_SPI_PO_SCALE_X		CAL_APPEND(MX_SPI_PO_SCALE_, MX_SPI_NUM)
#define MX_SPI_INT_X			CAL_APPEND(MX_SPI_INT_, MX_SPI_NUM)


//Function Prototypes
CALFUNCTION(void, FC_CAL_SPI_Master_Init_, (void));
CALFUNCTION(void, FC_CAL_SPI_Master_Uninit_, (void));
CALFUNCTION(MX_UINT8, FC_CAL_SPI_Master_Byte_, (MX_UINT8 DataOut));

CALFUNCTION(void, FC_CAL_SPI_Slave_Init_, (void));
CALFUNCTION(void, FC_CAL_SPI_Slave_Uninit_, (void));
CALFUNCTION(void, FC_CAL_SPI_Slave_SetTxData_, (MX_UINT8 Data));
CALFUNCTION(MX_UINT8, FC_CAL_SPI_Slave_GetRxData_, (void));


#if (MX_SPI_CHANNEL_X == 0)
  #ifndef MX_SPI_SW_DEL
    #define MX_SPI_SW_DEL
	MX_UINT8 SPI_SW_DELAY = 1;
  #endif
#endif


//Bus Mode - Bit0=CPOL, Bit1=CPHA, Bit2=CSMP
//CPOL - Clock Polarity - Idle State of the clock 0=0, 1=1
//CPHA - Clock Phase - Clock Edge 0=leading edge, 1=trailing edge
//CSMP - Input Data Bit Sample Phase
//CRAT - SPI Clock Rate 0=1/4, 1=1/16, 2=1/64


//Ensure SSPCON register is defined correctly
#ifndef SSPCON
  #ifdef SSPCON1
	#define sspcon	sspcon1
  #else
	#ifdef SSP1CON1
		#define sspcon	ssp1con1
	#endif
  #endif
#endif
#ifndef SSPBUF
  #ifdef SSP1BUF
	#define sspbuf	ssp1buf
  #endif
#endif

#ifndef SSP2CON
	#ifdef SSP2CON1
		#define ssp2con	ssp2con1
	#endif
#endif




CALFUNCTION(void, FC_CAL_SPI_Master_Init_, (void))

{
	FC_CAL_Bit_High_DDR (MX_SPI_MOSI_PORT_X, MX_SPI_MOSI_TRIS_X, MX_SPI_MOSI_PIN_X);		// MOSI pin is default high
01FF  1683  	BSF STATUS, RP0
0200  1303  	BCF STATUS, RP1
0201  1287  	BCF gbl_trisc,5
0202  1283  	BCF STATUS, RP0
0203  1687  	BSF gbl_portc,5

	FC_CAL_Bit_In_DDR   (MX_SPI_MISO_PORT_X, MX_SPI_MISO_TRIS_X, MX_SPI_MISO_PIN_X);		// MISO pin is a input
0204  1683  	BSF STATUS, RP0
0205  1607  	BSF gbl_trisc,4


	#if (MX_SPI_BMODE_X & 0x02)
		FC_CAL_Bit_Low_DDR  (MX_SPI_SCK_PORT_X, MX_SPI_SCK_TRIS_X, MX_SPI_SCK_PIN_X);		// Clock pin is default low
0206  1187  	BCF gbl_trisc,3
0207  1283  	BCF STATUS, RP0
0208  1187  	BCF gbl_portc,3

	#else
		FC_CAL_Bit_High_DDR (MX_SPI_SCK_PORT_X, MX_SPI_SCK_TRIS_X, MX_SPI_SCK_PIN_X);		// Clock pin is default high
	#endif

	#if (MX_SPI_CHANNEL_X == 1)
	 #ifndef MX_SPI_1
	 	#error "SPI channel 1 not available on this device"
	 #else
		sspcon 		 = MX_SPI_PR_SCALE_X & 0x03;			//Assign Clock Prescaler
0209  0194  	CLRF gbl_sspcon

		sspcon.CKP 	 = MX_SPI_BMODE_X & 0x01;				//Assign Clock Polarity
020A  1214  	BCF gbl_sspcon,4

		sspstat.CKE  = (MX_SPI_BMODE_X & 0x02) >> 1;		//Assign Clock Phase
020B  1683  	BSF STATUS, RP0
020C  1714  	BSF gbl_sspstat,6

		sspstat.SMP  = (MX_SPI_BMODE_X & 0x04) >> 2;		//Assign Input Data Phase
020D  1794  	BSF gbl_sspstat,7

		sspcon.SSPEN = 1;									//Activate SPI Peripheral
020E  1283  	BCF STATUS, RP0
020F  1694  	BSF gbl_sspcon,5

	 #endif
	#endif

	#if (MX_SPI_CHANNEL_X == 2)
	 #ifndef MX_SPI_2
	 	#error "SPI channel 2 not available on this device"
	 #else

	  #ifdef MX_SPI_2_REMAPPABLE
		RPINR21 = 3; 										//MISO - RB0 - RP3
		RPOR4 = 9;											//MOSI - RB1 - RP4
		RPOR5 = 10;											//SCK  - RB2 - RP5
	  #endif

		ssp2con 	  = MX_SPI_PR_SCALE_X & 0x03;		//Assign Clock Prescaler
		ssp2con.CKP   = MX_SPI_BMODE_X & 0x01;			//Assign Clock Polarity
		ssp2stat.CKE  = (MX_SPI_BMODE_X & 0x02) >> 1;	//Assign Clock Phase
		ssp2stat.SMP  = (MX_SPI_BMODE_X & 0x04) >> 2;	//Assign Input Data Phase
		ssp2con.SSPEN = 1;									//Activate SPI Peripheral
	 #endif
	#endif
}
0210  0008  	RETURN



CALFUNCTION(void, FC_CAL_SPI_Master_Uninit_, (void))
{
	#if (MX_SPI_CHANNEL_X == 1)
		sspcon = 0;
	#endif

	#if (MX_SPI_CHANNEL_X == 2)
		ssp2con = 0;
    #endif

	//Reset Pins to Inputs
	FC_CAL_Bit_In_DDR (MX_SPI_MOSI_PORT_X, MX_SPI_MOSI_TRIS_X, MX_SPI_MOSI_PIN_X);
	FC_CAL_Bit_In_DDR (MX_SPI_MISO_PORT_X, MX_SPI_MISO_TRIS_X, MX_SPI_MISO_PIN_X);
	FC_CAL_Bit_In_DDR (MX_SPI_SCK_PORT_X, MX_SPI_SCK_TRIS_X, MX_SPI_SCK_PIN_X);
}


CALFUNCTION(MX_UINT8, FC_CAL_SPI_Master_Byte_, (MX_UINT8 DataOut))

{
	MX_UINT8 retVal = 0;
004F  01B3  	CLRF FC_CAL_SPI_00066_1_retVal


	#if (MX_SPI_CHANNEL_X == 0)
		SPI_SW_DELAY = MX_SPI_PR_SCALE_X;

		MX_UINT8 idx;
		for (idx = 0; idx < 8; idx++)
		{
			retVal = retVal << 1;

			#if ((MX_SPI_BMODE_X & 0x02) == 0x00)									//CKE = 0; Set SCK active before data
				#if ((MX_SPI_BMODE_X & 0x01) == 0x00)								//CKP = 0
					FC_CAL_Bit_High(MX_SPI_SCK_PORT_X, MX_SPI_SCK_PIN_X);
				#else
					FC_CAL_Bit_Low(MX_SPI_SCK_PORT_X, MX_SPI_SCK_PIN_X);
				#endif
			#endif

			if (DataOut & 0x80)														//Test Data bit
				FC_CAL_Bit_High(MX_SPI_MOSI_PORT_X, MX_SPI_MOSI_PIN_X);				//Set SDO bit
			else
				FC_CAL_Bit_Low (MX_SPI_MOSI_PORT_X, MX_SPI_MOSI_PIN_X);				//Clear SDO bit

			delay_us(SPI_SW_DELAY);

			#if ((MX_SPI_BMODE_X & 0x02) == 0x02)									//CKE = 1; Set SCK active after data
				#if ((MX_SPI_BMODE_X & 0x01) == 0x00)								//CKP = 0
					FC_CAL_Bit_High(MX_SPI_SCK_PORT_X, MX_SPI_SCK_PIN_X);
				#else
					FC_CAL_Bit_Low(MX_SPI_SCK_PORT_X, MX_SPI_SCK_PIN_X);
				#endif
			#else																	//CKE = 0; Set SCK idle after data
				#if ((MX_SPI_BMODE_X & 0x01) == 0x00)								//CKP = 0
					FC_CAL_Bit_Low(MX_SPI_SCK_PORT_X, MX_SPI_SCK_PIN_X);
				#else
					FC_CAL_Bit_High(MX_SPI_SCK_PORT_X, MX_SPI_SCK_PIN_X);
				#endif
			#endif

			#if ((MX_SPI_BMODE_X & 0x04) == 0)										//Sample at the middle of period
				if(FC_CAL_Bit_In(MX_SPI_MISO_PORT_X, MX_SPI_MISO_PIN_X))
					retVal = retVal | 0x01;
				else
					retVal = retVal & 0xFE;
			#endif

			delay_us(SPI_SW_DELAY);

			#if ((MX_SPI_BMODE_X & 0x02) == 0x02)									//CKE = 1; Set SCK idle to complete cycle																	//CKE = 0; Set SCK idle after data
				#if ((MX_SPI_BMODE_X & 0x01) == 0x00)								//CKP = 0
					FC_CAL_Bit_Low(MX_SPI_SCK_PORT_X, MX_SPI_SCK_PIN_X);
				#else
					FC_CAL_Bit_High(MX_SPI_SCK_PORT_X, MX_SPI_SCK_PIN_X);
				#endif
			#endif

			#if ((MX_SPI_BMODE_X & 0x04) == 0x04)									//Sample at the end of period
				if(FC_CAL_Bit_In(MX_SPI_MISO_PORT_X, MX_SPI_MISO_PIN_X))
					retVal = retVal | 0x01;
				else
					retVal = retVal & 0xFE;
			#endif

			DataOut = DataOut << 1;							//Move to next data bit
		}
    #endif

	#if (MX_SPI_CHANNEL_X == 1)
		sspbuf = DataOut;					//Send outgoing byte
0050  0832  	MOVF FC_CAL_SPI_00066_arg_DataOut, W
0051  1283  	BCF STATUS, RP0
0052  0093  	MOVWF gbl_sspbuf

		while ((sspstat & 0x01) == 0);		//Wait until sspbuf is empty
0053        label6
0053  1683  	BSF STATUS, RP0
0054  1C14  	BTFSS gbl_sspstat,0
0055  2853  	GOTO	label6

		retVal = sspbuf;					//Collect incoming byte
0056  1283  	BCF STATUS, RP0
0057  0813  	MOVF gbl_sspbuf, W
0058  1683  	BSF STATUS, RP0
0059  00B3  	MOVWF FC_CAL_SPI_00066_1_retVal

	#endif

	#if (MX_SPI_CHANNEL_X == 2)
		ssp2buf = DataOut;					//Send outgoing byte
		while ((ssp2stat & 0x01) == 0);		//Wait until sspbuf is empty
		retVal = ssp2buf;					//Collect incoming byte
	#endif

	return (retVal);
005A  0833  	MOVF FC_CAL_SPI_00066_1_retVal, W
005B  00B4  	MOVWF CompTempVarRet2251

}
005C  0008  	RETURN






CALFUNCTION(void, FC_CAL_SPI_Slave_Init_, (void))
{

}

CALFUNCTION(void, FC_CAL_SPI_Slave_Uninit_, (void))
{

}

CALFUNCTION(void, FC_CAL_SPI_Slave_SetTxData_, (MX_UINT8 Data))
{

}

CALFUNCTION(MX_UINT8, FC_CAL_SPI_Slave_GetRxData_, (void))
{

}



/*********************************************************************
 *                  Flowcode CAL UART File
 *
 * File: PIC_CAL_UART.c
 *
 * (c) 2011 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * “Company”) for its Flowcode graphical programming language is
 * intended and supplied to you, the Company’s customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 010911 | BR | Created
 * 020911 | BR | Updated variables with typedef alternatives
 * 011211 | BR | Converted to new dynamic defines mechanism
 * 160112 | BR | Fixed issues with rx return type and low bauds on fast devices
 * 020212 | ST | Added <MX_UART_2_PIE4> routing to account for differences in 16F and 18F devices with 2 UARTs
 * 270212 | BR | Fixed a bug in the receive functionality
 * 280212 | BR | Sorted out auto echo functionality
 * 160412 | BR | Addition of HW change baud function
 */



#ifndef MX_UART_SW_DEFS
	#define MX_UART_SW_DEFS

	#ifdef _BOOSTC
		#define INST_COUNT	45	//65 for lower speeds or 40 for higher speeds.
	#endif
	#ifdef HI_TECH_C
		#define INST_COUNT	315
	#endif

	//Work out number of nops for software baud rate
	#define MX_INSTRUCTION_SPEED 	(MX_CLK_SPEED / 4)
	#define MX_OVERHEAD				(MX_INSTRUCTION_SPEED / INST_COUNT)
	#define SW_OFFSET				(1000000 / MX_OVERHEAD)

	//Work out software baud rates if required
	#define SW_1200_BAUD	(832 - SW_OFFSET)
	#define SW_2400_BAUD	(416 - SW_OFFSET)
	#define SW_4800_BAUD	(208 - SW_OFFSET)
	#define SW_9600_BAUD	(104 - SW_OFFSET)
	#define SW_19200_BAUD	(52 - SW_OFFSET)
	#define SW_31250_BAUD	(32 - SW_OFFSET)
	#define SW_115200_BAUD	(8 - SW_OFFSET)
#endif

 #if defined(MX_UART_CHANNEL_1) && (MX_UART_NUM==1)
	#if (MX_UART_CHANNEL_1 == 0)
		#if (MX_UART_BAUD_1 == 1200)
			#define MX_SOFT_BAUD_1	SW_1200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 1200 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_1 == 2400)
			#define MX_SOFT_BAUD_1	SW_2400_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 2400 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_1 == 4800)
			#define MX_SOFT_BAUD_1	SW_4800_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 4800 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_1 == 9600)
			#define MX_SOFT_BAUD_1	SW_9600_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 9600 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_1 == 19200)
			#define MX_SOFT_BAUD_1	SW_19200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 19200 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_1 == 31250)
			#define MX_SOFT_BAUD_1	SW_31250_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 31250 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_1 == 115200)
			#define MX_SOFT_BAUD_1	SW_115200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 115200 Not Available At This Clock Speed"
			#endif
		#endif
		#ifndef MX_SOFT_BAUD_1
			#error "UART Baud Rate not supported in Software Mode"
		#endif
	#else
		#define MX_SOFT_BAUD_1	1
		#define MX_HARD_BAUD_1	(((MX_CLK_SPEED / MX_UART_BAUD_1) - 16) / 16)
		#define MX_HARD_SLOW_1	0

		#if (MX_HARD_BAUD_1 > 255)
			#undef MX_HARD_BAUD_1
			#undef MX_HARD_SLOW_1
			#define MX_HARD_BAUD_1	(((MX_CLK_SPEED / MX_UART_BAUD_1) - 16)	/ 64)
			#define MX_HARD_SLOW_1	1
		#endif

	#endif
 #endif
 #if defined(MX_UART_CHANNEL_2) && (MX_UART_NUM==2)
	#if (MX_UART_CHANNEL_2 == 0)
		#if (MX_UART_BAUD_2 == 1200)
			#define MX_SOFT_BAUD_2	SW_1200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 1200 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_2 == 2400)
			#define MX_SOFT_BAUD_2	SW_2400_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 2400 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_2 == 4800)
			#define MX_SOFT_BAUD_2	SW_4800_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 4800 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_2 == 9600)
			#define MX_SOFT_BAUD_2	SW_9600_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 9600 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_2 == 19200)
			#define MX_SOFT_BAUD_2	SW_19200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 19200 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_2 == 31250)
			#define MX_SOFT_BAUD_2	SW_31250_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 31250 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_2 == 115200)
			#define MX_SOFT_BAUD_2	SW_115200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 115200 Not Available At This Clock Speed"
			#endif
		#endif
		#ifndef MX_SOFT_BAUD_2
			#error "UART Baud Rate not supported in Software Mode"
		#endif
	#else
		#define MX_SOFT_BAUD_2	1
		#define MX_HARD_BAUD_2	(((MX_CLK_SPEED / MX_UART_BAUD_2) - 16) / 16)
		#define MX_HARD_SLOW_2	0

		#if (MX_HARD_BAUD_2 > 255)
			#undef MX_HARD_BAUD_2
			#undef MX_HARD_SLOW_2
			#define MX_HARD_BAUD_2	(((MX_CLK_SPEED / MX_UART_BAUD_2) - 16)	/ 64)
			#define MX_HARD_SLOW_2	1
		#endif
 	#endif
 #endif
 #if defined(MX_UART_CHANNEL_3) && (MX_UART_NUM==3)
	#if (MX_UART_CHANNEL_3 == 0)
		#if (MX_UART_BAUD_3 == 1200)
			#define MX_SOFT_BAUD_3	SW_1200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 1200 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_3 == 2400)
			#define MX_SOFT_BAUD_3	SW_2400_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 2400 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_3 == 4800)
			#define MX_SOFT_BAUD_3	SW_4800_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 4800 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_3 == 9600)
			#define MX_SOFT_BAUD_3	SW_9600_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 9600 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_3 == 19200)
			#define MX_SOFT_BAUD_3	SW_19200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 19200 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_3 == 31250)
			#define MX_SOFT_BAUD_3	SW_31250_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 31250 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_3 == 115200)
			#define MX_SOFT_BAUD_3	SW_115200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 115200 Not Available At This Clock Speed"
			#endif
		#endif
		#ifndef MX_SOFT_BAUD_3
			#error "UART Baud Rate not supported in Software Mode"
		#endif
	#else
		#define MX_SOFT_BAUD_3	1
		#define MX_HARD_BAUD_3	(((MX_CLK_SPEED / MX_UART_BAUD_3) - 16) / 16)
		#define MX_HARD_SLOW_3	0

		#if (MX_HARD_BAUD_3 > 255)
			#undef MX_HARD_BAUD_3
			#undef MX_HARD_SLOW_3
			#define MX_HARD_BAUD_3	(((MX_CLK_SPEED / MX_UART_BAUD_3) - 16)	/ 64)
			#define MX_HARD_SLOW_3	1
		#endif
	#endif
 #endif
 #if defined(MX_UART_CHANNEL_4) && (MX_UART_NUM==4)
	#if (MX_UART_CHANNEL_4 == 0)
		#if (MX_UART_BAUD_4 == 1200)
			#define MX_SOFT_BAUD_4	SW_1200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 1200 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_4 == 2400)
			#define MX_SOFT_BAUD_4	SW_2400_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 2400 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_4 == 4800)
			#define MX_SOFT_BAUD_4	SW_4800_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 4800 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_4 == 9600)
			#define MX_SOFT_BAUD_4	SW_9600_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 9600 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_4 == 19200)
			#define MX_SOFT_BAUD_4	SW_19200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 19200 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_4 == 31250)
			#define MX_SOFT_BAUD_4	SW_31250_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 31250 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_4 == 115200)
			#define MX_SOFT_BAUD_4	SW_115200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 115200 Not Available At This Clock Speed"
			#endif
		#endif
		#ifndef MX_SOFT_BAUD_4
			#error "UART Baud Rate not supported in Software Mode"
		#endif
	#else
		#define MX_SOFT_BAUD_4	1
		#define MX_HARD_BAUD_4	(((MX_CLK_SPEED / MX_UART_BAUD_4) - 16) / 16)
		#define MX_HARD_SLOW_4	0

		#if (MX_HARD_BAUD_4 > 255)
			#undef MX_HARD_BAUD_4
			#undef MX_HARD_SLOW_4
			#define MX_HARD_BAUD_4	(((MX_CLK_SPEED / MX_UART_BAUD_4) - 16)	/ 64)
			#define MX_HARD_SLOW_4	1
		#endif
	#endif
 #endif


//Hardware Baud update definitions
#ifndef MX_HARD_BAUD_CHANGE_DEFS
	#define MX_HARD_BAUD_CHANGE_DEFS

	#define MX_HARD_BAUD_1200	(((MX_CLK_SPEED / 1200) - 16) / 16)
	#if (MX_HARD_BAUD_1200 > 255)
		#undef MX_HARD_BAUD_1200
		#define MX_HARD_BAUD_1200	(((MX_CLK_SPEED / 1200) - 16) / 64)
		#define MX_HARD_SLOW_1200	1
	#else
		#define MX_HARD_SLOW_1200	0
	#endif

	#define MX_HARD_BAUD_2400	(((MX_CLK_SPEED / 2400) - 16) / 16)
	#if (MX_HARD_BAUD_2400 > 255)
		#undef MX_HARD_BAUD_2400
		#define MX_HARD_BAUD_2400	(((MX_CLK_SPEED / 2400) - 16) / 64)
		#define MX_HARD_SLOW_2400	1
	#else
		#define MX_HARD_SLOW_2400	0
	#endif

	#define MX_HARD_BAUD_4800	(((MX_CLK_SPEED / 4800) - 16) / 16)
	#if (MX_HARD_BAUD_4800 > 255)
		#undef MX_HARD_BAUD_4800
		#define MX_HARD_BAUD_4800	(((MX_CLK_SPEED / 4800) - 16) / 64)
		#define MX_HARD_SLOW_4800	1
	#else
		#define MX_HARD_SLOW_4800	0
	#endif

	#define MX_HARD_BAUD_9600	(((MX_CLK_SPEED / 9600) - 16) / 16)
	#if (MX_HARD_BAUD_9600 > 255)
		#undef MX_HARD_BAUD_9600
		#define MX_HARD_BAUD_9600	(((MX_CLK_SPEED / 9600) - 16) / 64)
		#define MX_HARD_SLOW_9600	1
	#else
		#define MX_HARD_SLOW_9600	0
	#endif

	#define MX_HARD_BAUD_19200	(((MX_CLK_SPEED / 19200) - 16) / 16)
	#if (MX_HARD_BAUD_19200 > 255)
		#undef MX_HARD_BAUD_19200
		#define MX_HARD_BAUD_19200	(((MX_CLK_SPEED / 19200) - 16) / 64)
		#define MX_HARD_SLOW_19200	1
	#else
		#define MX_HARD_SLOW_19200	0
	#endif

	#define MX_HARD_BAUD_38400	(((MX_CLK_SPEED / 38400) - 16) / 16)
	#if (MX_HARD_BAUD_38400 > 255)
		#undef MX_HARD_BAUD_38400
		#define MX_HARD_BAUD_38400	(((MX_CLK_SPEED / 38400) - 16) / 64)
		#define MX_HARD_SLOW_38400	1
	#else
		#define MX_HARD_SLOW_38400	0
	#endif

	#define MX_HARD_BAUD_57600	(((MX_CLK_SPEED / 57600) - 16) / 16)
	#if (MX_HARD_BAUD_57600 > 255)
		#undef MX_HARD_BAUD_57600
		#define MX_HARD_BAUD_57600	(((MX_CLK_SPEED / 57600) - 16) / 64)
		#define MX_HARD_SLOW_57600	1
	#else
		#define MX_HARD_SLOW_57600	0
	#endif

	#define MX_HARD_BAUD_115200	(((MX_CLK_SPEED / 115200) - 16) / 16)
	#if (MX_HARD_BAUD_115200 > 255)
		#undef MX_HARD_BAUD_115200
		#define MX_HARD_BAUD_115200	(((MX_CLK_SPEED / 115200) - 16) / 64)
		#define MX_HARD_SLOW_115200	1
	#else
		#define MX_HARD_SLOW_115200	0
	#endif
#endif


//Dynamic function naming based on defines and index number
#define MX_UART_CHANNEL_X	CAL_APPEND(MX_UART_CHANNEL_, MX_UART_NUM)
#define MX_UART_TX_PIN_X	CAL_APPEND(MX_UART_TX_PIN_, MX_UART_NUM)
#define MX_UART_TX_PORT_X	CAL_APPEND(MX_UART_TX_PORT_, MX_UART_NUM)
#define MX_UART_TX_TRIS_X	CAL_APPEND(MX_UART_TX_TRIS_, MX_UART_NUM)
#define MX_UART_RX_PIN_X	CAL_APPEND(MX_UART_RX_PIN_, MX_UART_NUM)
#define MX_UART_RX_PORT_X	CAL_APPEND(MX_UART_RX_PORT_, MX_UART_NUM)
#define MX_UART_RX_TRIS_X	CAL_APPEND(MX_UART_RX_TRIS_, MX_UART_NUM)
#define MX_UART_FLOWEN_X	CAL_APPEND(MX_UART_FLOWEN_, MX_UART_NUM)
#define MX_UART_CTS_PIN_X	CAL_APPEND(MX_UART_CTS_PIN_, MX_UART_NUM)
#define MX_UART_CTS_PORT_X	CAL_APPEND(MX_UART_CTS_PORT_, MX_UART_NUM)
#define MX_UART_CTS_TRIS_X	CAL_APPEND(MX_UART_CTS_TRIS_, MX_UART_NUM)
#define MX_UART_RTS_PIN_X	CAL_APPEND(MX_UART_RTS_PIN_, MX_UART_NUM)
#define MX_UART_RTS_PORT_X	CAL_APPEND(MX_UART_RTS_PORT_, MX_UART_NUM)
#define MX_UART_RTS_TRIS_X	CAL_APPEND(MX_UART_RTS_TRIS_, MX_UART_NUM)
#define MX_UART_DBITS_X		CAL_APPEND(MX_UART_DBITS_, MX_UART_NUM)
#define MX_UART_RETURN_X	CAL_APPEND(MX_UART_RETURN_, MX_UART_NUM)
#define MX_UART_ECHO_X		CAL_APPEND(MX_UART_ECHO_, MX_UART_NUM)
#define MX_UART_INT_X		CAL_APPEND(MX_UART_INT_, MX_UART_NUM)
#define MX_UART_BAUD_X		CAL_APPEND(MX_HARD_BAUD_, MX_UART_NUM)
#define MX_SOFT_BAUD_X		CAL_APPEND(MX_SOFT_BAUD_, MX_UART_NUM)
#define MX_HARD_SLOW_X		CAL_APPEND(MX_HARD_SLOW_, MX_UART_NUM)

#define UART_Delay_CAL		CAL_APPEND(FC_CAL_UART_Delay_, MX_UART_NUM)
#define UART_Send			CAL_APPEND(FC_CAL_UART_Send_, MX_UART_NUM)
#define UART_Uninit			CAL_APPEND(FC_CAL_UART_Uninit_, MX_UART_NUM)


//Component Definitions
#define UART_STATUS_LOOP	0
#define UART_STATUS_TIMEOUT	1
#define UART_STATUS_RXBYTE	2


//Interrupt Definitions
#ifdef MX_UART_2_PIE4
  #define MX_UART2_PIE pie4
  #define MX_UART2_PIR pir4
  #define MX_UART2_TXSTA tx2sta
  #define MX_UART2_RCSTA rc2sta
  #define MX_UART2_TXREG tx2reg
  #define MX_UART2_RCREG rc2reg
#else
  #define MX_UART2_PIE pie3
  #define MX_UART2_PIR pir3
  #define MX_UART2_TXSTA txsta2
  #define MX_UART2_RCSTA rcsta2
  #define MX_UART2_TXREG txreg2
  #define MX_UART2_RCREG rcreg2
#endif

#if (MX_UART_INT_X == 1)

	#ifndef MX_UART_INT_DEFS
	#define MX_UART_INT_DEFS

		#define MX_UART_INT_CH1_FUNC
		#define MX_UART_INT_CH2_FUNC
		#define MX_UART_INT_FUNC_END

		#define MX_UART_INT_CH1_DET		ts_bit(pir1, RCIF) && ts_bit(pie1, RCIE)
		#define MX_UART_INT_CH2_DET		ts_bit(MX_UART2_PIR, RC2IF) && ts_bit(MX_UART2_PIE, RC2IE)

		#define MX_UART_INT_CH1_EN		st_bit (pie1, RCIE)
		#define MX_UART_INT_CH2_EN		st_bit (MX_UART2_PIE, RC2IE)

		#define MX_UART_INT_CH1_DIS		cr_bit (pie1, RCIE)
		#define MX_UART_INT_CH2_DIS		cr_bit (MX_UART2_PIE, RC2IE)

		#define MX_UART_INT_CH1_CLR		cr_bit (pir1, RCIF)
		#define MX_UART_INT_CH2_CLR		cr_bit (MX_UART2_PIR, RC2IF)

	#endif
#endif


//Function Prototypes
CALFUNCTION(void, FC_CAL_UART_Init_, (void));
CALFUNCTION(void, FC_CAL_UART_Uninit_, (void));
CALFUNCTION(void, FC_CAL_UART_Send_, (MX_UINT16 nChar));
CALFUNCTION(MX_SINT16, FC_CAL_UART_Receive_, (MX_UINT8 nTimeout));
CALFUNCTION(void, FC_CAL_UART_Delay_, (void));


//Peripheral Functions
CALFUNCTION(void, FC_CAL_UART_Init_, (void))

{

	#if (MX_UART_CHANNEL_X == 0)
		FC_CAL_Bit_In_DDR 	(MX_UART_RX_PORT_X, MX_UART_RX_TRIS_X, MX_UART_RX_PIN_X);		// Receive pin is a input
		FC_CAL_Bit_High_DDR (MX_UART_TX_PORT_X, MX_UART_TX_TRIS_X, MX_UART_TX_PIN_X);		// Transmit pin is default high
	#endif

	#if (MX_UART_CHANNEL_X == 1)
	  #ifndef MX_UART_1
	  	  #error "UART channel 1 not available on this device"
	  #else
		  #if (MX_HARD_SLOW_X == 1)
			cr_bit(txsta, BRGH);						//Low Speed
		  #else
			st_bit(txsta, BRGH);						//High Speed
03BE  1683  	BSF STATUS, RP0
03BF  1303  	BCF STATUS, RP1
03C0  1518  	BSF gbl_txsta,2

		  #endif
			spbrg = MX_UART_BAUD_X;   					// set the baud rate
03C1  3081  	MOVLW 0x81
03C2  0099  	MOVWF gbl_spbrg

			rcsta = 0;                    				// 8-bit, disabled
03C3  1283  	BCF STATUS, RP0
03C4  0198  	CLRF gbl_rcsta


			#if(MX_UART_DBITS_X == 9)
				st_bit(txsta, TX9);   					// 9-bit TX
				st_bit(rcsta, RX9);                    	// 9-bit RX
			#endif

			st_bit(rcsta, SPEN);         				// turn on serial interface
03C5  1798  	BSF gbl_rcsta,7

			st_bit(txsta, TXEN);
03C6  1683  	BSF STATUS, RP0
03C7  1698  	BSF gbl_txsta,5

			st_bit(rcsta, CREN);
03C8  1283  	BCF STATUS, RP0
03C9  1618  	BSF gbl_rcsta,4


			#if (MX_UART_INT_X == 1)
				MX_UART_INT_CH1_EN;
				st_bit(intcon, PEIE);
				st_bit(intcon, GIE);
			#else
				cr_bit (pie1, RCIE);
03CA  1683  	BSF STATUS, RP0
03CB  128C  	BCF gbl_pie1,5

			#endif
	  #endif
	#endif


	#if (MX_UART_CHANNEL_X == 2)

	  #ifndef MX_UART_2
		  #error "UART channel 2 not available on this device"
	  #else
		  #ifdef MX_UART_2_REMAPPABLE
			RPOR9 = 5;									//TX2 - RP9 - RB6
			RPINR16	= 10;								//RX2 - RP10 - RB7
		  #endif
		  #if (MX_HARD_SLOW_X == 1)
			cr_bit(MX_UART2_TXSTA, BRGH);						//Low Speed
		  #else
			st_bit(MX_UART2_TXSTA, BRGH);						//High Speed
		  #endif
			spbrg2 = MX_UART_BAUD_X;   				// set the baud rate
			MX_UART2_RCSTA = 0;                    				// 8-bit, disabled

			#if(MX_UART_DBITS_X == 9)
				st_bit(MX_UART2_TXSTA, TX9);   					// 9-bit TX
				st_bit(MX_UART2_RCSTA, RX9);                    // 9-bit RX
			#endif

			st_bit(MX_UART2_RCSTA, SPEN);         				// turn on serial interface
			st_bit(MX_UART2_TXSTA, TXEN);
			st_bit(MX_UART2_RCSTA, CREN);

			#if (MX_UART_INT_X == 1)
				MX_UART_INT_CH2_EN;
				st_bit(intcon, PEIE);
				st_bit(intcon, GIE);
			#else
				cr_bit (MX_UART2_PIE, RC2IE);
			#endif
	  #endif
	#endif

	#if (MX_UART_FLOWEN_X == 1)						//Flowcontrol enabled?
		FC_CAL_Bit_In_DDR (MX_UART_CTS_PORT_X, MX_UART_CTS_TRIS_X, MX_UART_CTS_PIN_X);	// CTS pin is a input
		FC_CAL_Bit_High_DDR (MX_UART_RTS_PORT_X, MX_UART_RTS_TRIS_X, MX_UART_RTS_PIN_X);	// RTS not ready to accept data
	#endif

}
03CC  0008  	RETURN




CALFUNCTION(void, FC_CAL_UART_Uninit_, (void))
{

	#if (MX_UART_CHANNEL_X == 0)
		FC_CAL_Bit_In_DDR (MX_UART_RX_PORT_X, MX_UART_RX_TRIS_X, MX_UART_RX_PIN_X);		// Receive pin is a input
		FC_CAL_Bit_In_DDR (MX_UART_TX_PORT_X, MX_UART_TX_TRIS_X, MX_UART_TX_PIN_X);		// Transmit pin is default high
	#endif

	#if (MX_UART_CHANNEL_X == 1)
			rcsta = 0;                    								// 8-bit, disabled
			txsta = 0;
		  #ifdef MX_UART_RXINT
			MX_UART_INT_CH1_DIS;
		  #endif
	#endif

	#if (MX_UART_CHANNEL_X == 2)
			MX_UART2_RCSTA = 0;                    								// 8-bit, disabled
			MX_UART2_TXSTA = 0;
		  #ifdef MX_UART_RXINT
			MX_UART_INT_CH2_DIS;
		  #endif
	#endif

	#if (MX_UART_FLOWEN_X == 1)										//Flowcontrol enabled?
		FC_CAL_Bit_In_DDR (MX_UART_CTS_PORT_X, MX_UART_CTS_TRIS_X, MX_UART_CTS_PIN_X);		// CTS pin is a input
		FC_CAL_Bit_In_DDR (MX_UART_RTS_PORT_X, MX_UART_RTS_TRIS_X, MX_UART_RTS_PIN_X);		// RTS not ready to accept data
	#endif
}



CALFUNCTION(void, FC_CAL_UART_Send_, (MX_UINT16 nChar))
{
	#if (MX_UART_FLOWEN_X == 1)
		while (FC_CAL_Bit_In(MX_UART_CTS_PORT_X, MX_UART_CTS_PIN_X) != 0);	// Wait until CTS is low
	#endif

	#if (MX_UART_CHANNEL_X == 0)													// Software UART TX
		MX_UINT8 idx;
		FC_CAL_Bit_Low(MX_UART_TX_PORT_X, MX_UART_TX_PIN_X);					// Send Start bit
		UART_Delay_CAL();
		for (idx = 0; idx < MX_UART_DBITS_X; idx++)
		{
			if (nChar & 0x01)														// Mask off data bit
				FC_CAL_Bit_High(MX_UART_TX_PORT_X, MX_UART_TX_PIN_X);
			else
				FC_CAL_Bit_Low(MX_UART_TX_PORT_X, MX_UART_TX_PIN_X);
			UART_Delay_CAL();
			nChar = nChar >> 1;														// Move to next data bit
		}
		FC_CAL_Bit_High(MX_UART_TX_PORT_X, MX_UART_TX_PIN_X);					// Send Stop bit
		UART_Delay_CAL();
	#endif

	#if (MX_UART_CHANNEL_X == 1)
		while (ts_bit(pir1, TXIF) == 0);

		#if (MX_UART_DBITS_X == 9)
			if (test_bit(nChar, 8))
				st_bit(txsta, TX9D);
			else
				cr_bit(txsta, TX9D);
	  	#endif
		txreg = nChar;
	#endif

	#if (MX_UART_CHANNEL_X == 2)
		while (ts_bit(pir3, TX2IF) == 0);

		#if (MX_UART_DBITS_X == 9)
			if (test_bit(nChar, 8))
				st_bit(MX_UART2_TXSTA, TX9D);
			else
				cr_bit(MX_UART2_TXSTA, TX9D);
		#endif
		MX_UART2_TXREG = nChar;
	#endif
}


CALFUNCTION(MX_SINT16, FC_CAL_UART_Receive_, (MX_UINT8 nTimeout))
{
  #if (MX_UART_RETURN_X == 1)
	MX_UINT16 retVal = 512;
  #else
  	MX_UINT8 retVal = 255;
  #endif

	MX_UINT8 delay1 = 0;
	MX_UINT8 regcheck = 0;
	MX_UINT8 bWaitForever = 0;
	MX_UINT8 rxStatus = UART_STATUS_LOOP;

  #if (MX_UART_CHANNEL_X == 0)
  	MX_UINT8 idx;
  #else
  	MX_UINT8 dummy = 0;
  #endif

	if (nTimeout == 255)
		bWaitForever = 1;

	#if (MX_UART_FLOWEN_X == 1)
		FC_CAL_Bit_Low (MX_UART_RTS_PORT_X, MX_UART_RTS_PIN_X);			// Ready to accept data
	#endif

	while (rxStatus == UART_STATUS_LOOP)
	{
		if (bWaitForever == 0)
		{
			if (nTimeout == 0)							//don't wait forever, so do timeout thing...
			{
				rxStatus = UART_STATUS_TIMEOUT;
			}
			else
			{
				delay_us(10);
				delay1 = delay1 + 1;
				if(delay1 == 100)
				{
					nTimeout = nTimeout - 1;
					MX_CLEAR_WATCHDOG;
					delay1 = 0;
				}
			}
		}

		#if (MX_UART_CHANNEL_X == 0)
			regcheck = FC_CAL_Bit_In(MX_UART_RX_PORT_1, MX_UART_RX_PIN_1);	//Test for start bit
			if (regcheck == 0)
				rxStatus = UART_STATUS_RXBYTE;
		#endif

		#if (MX_UART_CHANNEL_X == 1)
			regcheck = ts_bit(pir1, RCIF);
			if (regcheck != 0)
				rxStatus = UART_STATUS_RXBYTE;
		#endif

		#if (MX_UART_CHANNEL_X == 2)
			regcheck = ts_bit(MX_UART2_PIR, RC2IF);
			if (regcheck != 0)
				rxStatus = UART_STATUS_RXBYTE;
		#endif

	}

	if (rxStatus == UART_STATUS_RXBYTE)
	{
		#if (MX_UART_CHANNEL_X == 0)

			retVal = 0;
			UART_Delay_CAL();

			for (idx = 0; idx < MX_UART_DBITS_X; idx++)
			{
				if (FC_CAL_Bit_In(MX_UART_RX_PORT_X, MX_UART_RX_PIN_X))
					retVal = retVal | (0x01 << idx);

				UART_Delay_CAL();
			}
		#endif

		#if (MX_UART_CHANNEL_X == 1)
			regcheck = ts_bit(rcsta, FERR);
			if (regcheck != 0)
			{
				dummy = rcreg;						//need to read the rcreg to clear FERR
				#if (MX_UART_RETURN_X == 1)
					retVal = 0x400;					//Framing Error Flag
				#endif
			}
			else
			{
				regcheck = ts_bit(rcsta, OERR);
				if (regcheck != 0)
				{
					cr_bit(rcsta, CREN);			//Reset receiver to clear error
					st_bit(rcsta, CREN);

					#if (MX_UART_RETURN_X == 1)
						retVal = 0x800;				//Overrun Error Flag
					#endif
				}
				else
				{
					retVal = 0;

					#if (MX_UART_DBITS_X == 9)
						if(ts_bit(rcsta, RX9D))
							retVal = 0x100;
					#endif

					retVal = retVal | rcreg; 			//no error, so rx byte is valid
				}
			}
		#endif

		#if (MX_UART_CHANNEL_X == 2)
			regcheck = ts_bit(MX_UART2_RCSTA, FERR);
			if (regcheck != 0)
			{
				dummy = MX_UART2_RCREG;			//need to read the rcreg to clear FERR
				#if (MX_UART_RETURN_X == 1)
					retVal = 0x400;					//Framing Error Flag
				#endif
			}
			else
			{
				regcheck = ts_bit(MX_UART2_RCSTA, OERR);
				if (regcheck != 0)
				{
					cr_bit(MX_UART2_RCSTA, CREN);	//Reset receiver to clear error
					st_bit(MX_UART2_RCSTA, CREN);
					#if (MX_UART_RETURN_X == 1)
						retVal = 0x800;				//Overrun Error Flag
					#endif
				}
				else
				{
					retVal = 0;

					#if (MX_UART_DBITS_X == 9)
						if(ts_bit(MX_UART2_RCSTA, RX9D))
							retVal = 0x100;
					#endif

					retVal = retVal | MX_UART2_RCREG; 			//no error, so rx byte is valid
				}
			}

		#endif

		#if (MX_UART_ECHO_X == 1)
			UART_Send(retVal);
		#endif
	}

	#if (MX_UART_FLOWEN_X == 1)
		FC_CAL_Bit_High(MX_UART_RTS_PORT_X, MX_UART_RTS_PIN_X);		//not ready to accept data
	#endif

	return (retVal);
}


CALFUNCTION(void, FC_CAL_UART_Delay_, (void))
{
  #if (MX_UART_CHANNEL_X == 0)

	MX_UINT16 delay = MX_SOFT_BAUD_X;

	while (delay > 255)
	{
		delay_us(255);
		delay = delay - 255;
		MX_CLEAR_WATCHDOG;
	}
	delay_us(delay);
	MX_CLEAR_WATCHDOG;

  #endif
}


CALFUNCTION(void, FC_CAL_UART_Update_Baud_, (MX_UINT8 new_baud))
{
	//Baud Rates - Function compatible with hardware mode only
	/*
	0 - 1200
	1 - 2400
	2 - 4800
	3 - 9600
	4 - 19200
	5 - 38400
	6 - 57600
	7 - 115200
	*/

	MX_UINT8 baudrate, baudmode;

	if (new_baud > 7)
		return;

	if (new_baud == 0)
	{
		baudrate = MX_HARD_BAUD_1200;
		baudmode = MX_HARD_SLOW_1200;
	}
	else if (new_baud == 1)
	{
		baudrate = MX_HARD_BAUD_2400;
		baudmode = MX_HARD_SLOW_2400;
	}
	else if (new_baud == 2)
	{
		baudrate = MX_HARD_BAUD_4800;
		baudmode = MX_HARD_SLOW_4800;
	}
	else if (new_baud == 3)
	{
		baudrate = MX_HARD_BAUD_9600;
		baudmode = MX_HARD_SLOW_9600;
	}
	else if (new_baud == 4)
	{
		baudrate = MX_HARD_BAUD_19200;
		baudmode = MX_HARD_SLOW_19200;
	}
	else if (new_baud == 5)
	{
		baudrate = MX_HARD_BAUD_38400;
		baudmode = MX_HARD_SLOW_38400;
	}
	else if (new_baud == 6)
	{
		baudrate = MX_HARD_BAUD_57600;
		baudmode = MX_HARD_SLOW_57600;
	}
	else if (new_baud == 7)
	{
		baudrate = MX_HARD_BAUD_115200;
		baudmode = MX_HARD_SLOW_115200;
	}

	UART_Uninit();

	#if (MX_UART_CHANNEL_X == 1)

	    if (baudmode == 1)
			cr_bit(txsta, BRGH);					//Low Speed
	    else
			st_bit(txsta, BRGH);					//High Speed

		spbrg = baudrate;   						// set the baud rate
		rcsta = 0;                    				// 8-bit, disabled

		#if(MX_UART_DBITS_X == 9)
			st_bit(txsta, TX9);   					// 9-bit TX
			st_bit(rcsta, RX9);                    	// 9-bit RX
		#endif

		st_bit(rcsta, SPEN);         				// turn on serial interface
		st_bit(txsta, TXEN);
		st_bit(rcsta, CREN);

		#if (MX_UART_INT_X == 1)
			MX_UART_INT_CH1_EN;
			st_bit(intcon, PEIE);
			st_bit(intcon, GIE);
		#else
			cr_bit (pie1, RCIE);
		#endif
	#endif

	#if (MX_UART_CHANNEL_X == 2)

	  	if (baudmode == 1)
			cr_bit(MX_UART2_TXSTA, BRGH);			//Low Speed
	  	else
			st_bit(MX_UART2_TXSTA, BRGH);			//High Speed

		spbrg2 = baudrate;   						// set the baud rate
		MX_UART2_RCSTA = 0;                    		// 8-bit, disabled

		#if(MX_UART_DBITS_X == 9)
			st_bit(MX_UART2_TXSTA, TX9);   			// 9-bit TX
			st_bit(MX_UART2_RCSTA, RX9);            // 9-bit RX
		#endif

		st_bit(MX_UART2_RCSTA, SPEN);         		// turn on serial interface
		st_bit(MX_UART2_TXSTA, TXEN);
		st_bit(MX_UART2_RCSTA, CREN);

		#if (MX_UART_INT_X == 1)
			MX_UART_INT_CH2_EN;
			st_bit(intcon, PEIE);
			st_bit(intcon, GIE);
		#else
			cr_bit (MX_UART2_PIE, RC2IE);
		#endif
	#endif

	#if (MX_UART_FLOWEN_X == 1)						//Flowcontrol enabled?
		FC_CAL_Bit_In_DDR (MX_UART_CTS_PORT_X, MX_UART_CTS_TRIS_X, MX_UART_CTS_PIN_X);	// CTS pin is a input
		FC_CAL_Bit_High_DDR (MX_UART_RTS_PORT_X, MX_UART_RTS_TRIS_X, MX_UART_RTS_PIN_X);	// RTS not ready to accept data
	#endif

}

////////////////////////////////////////
// Code with no source :-)
////////////////////////////////////////
0000  2FE5  	GOTO	_startup

0004  00FF  	MOVWF Int1Context
0005  0E03  	SWAPF STATUS, W
0006  1283  	BCF STATUS, RP0
0007  1303  	BCF STATUS, RP1
0008  00E0  	MOVWF Int1BContext
0009  0E0A  	SWAPF PCLATH, W
000A  00E1  	MOVWF Int1BContext+D'1'
000B  0E04  	SWAPF FSR, W
000C  00E2  	MOVWF Int1BContext+D'2'
000D  158A  	BSF PCLATH,3
000E  120A  	BCF PCLATH,4
000F  2843  	GOTO	interrupt
0010        delay_us_00000
0010        ; { delay_us ; function begin
0010        label1
0010  0000  	NOP
0011  0000  	NOP
0012  0BB1  	DECFSZ delay_us_00000_arg_del, F
0013  2810  	GOTO	label1
0014  0008  	RETURN
0015        ; } delay_us function end

0015        delay_ms_00000
0015        ; { delay_ms ; function begin
0015  08B5  	MOVF delay_ms_00000_arg_del, F
0016  1D03  	BTFSS STATUS,Z
0017  2819  	GOTO	label2
0018  0008  	RETURN
0019        label2
0019  30F9  	MOVLW 0xF9
001A        label3
001A  0000  	NOP
001B  0000  	NOP
001C  0000  	NOP
001D  0000  	NOP
001E  0000  	NOP
001F  0000  	NOP
0020  0000  	NOP
0021  0000  	NOP
0022  0000  	NOP
0023  0000  	NOP
0024  0000  	NOP
0025  0000  	NOP
0026  0000  	NOP
0027  0000  	NOP
0028  0000  	NOP
0029  0000  	NOP
002A  3EFF  	ADDLW 0xFF
002B  1D03  	BTFSS STATUS,Z
002C  281A  	GOTO	label3
002D  0000  	NOP
002E  0000  	NOP
002F  0000  	NOP
0030  0000  	NOP
0031  0000  	NOP
0032  0000  	NOP
0033  0000  	NOP
0034  0000  	NOP
0035  0000  	NOP
0036  0000  	NOP
0037  0000  	NOP
0038  0000  	NOP
0039  0000  	NOP
003A  0000  	NOP
003B  0000  	NOP
003C  0000  	NOP
003D  0000  	NOP
003E  0BB5  	DECFSZ delay_ms_00000_arg_del, F
003F  2819  	GOTO	label2
0040  0008  	RETURN
0041        ; } delay_ms function end

0041        delay_10us_00000
0041        ; { delay_10us ; function begin
0041  08C5  	MOVF delay_10us_00000_arg_del, F
0042  1D03  	BTFSS STATUS,Z
0043  2845  	GOTO	label4
0044  0008  	RETURN
0045        label4
0045  3009  	MOVLW 0x09
0046        label5
0046  0000  	NOP
0047  3EFF  	ADDLW 0xFF
0048  1D03  	BTFSS STATUS,Z
0049  2846  	GOTO	label5
004A  0000  	NOP
004B  0000  	NOP
004C  0BC5  	DECFSZ delay_10us_00000_arg_del, F
004D  2845  	GOTO	label4
004E  0008  	RETURN
004F        ; } delay_10us function end


01D5        __div_16_1_00003
01D5        ; { __div_16_16 ; function begin
01D5  01BC  	CLRF __div_16_1_00003_1_r
01D6  01BD  	CLRF __div_16_1_00003_1_r+D'1'
01D7  01BF  	CLRF CompTempVarRet214
01D8  01C0  	CLRF CompTempVarRet214+D'1'
01D9  01BE  	CLRF __div_16_1_00003_1_i
01DA        label26
01DA  1A3E  	BTFSC __div_16_1_00003_1_i,4
01DB  0008  	RETURN
01DC  1003  	BCF STATUS,C
01DD  0DBF  	RLF CompTempVarRet214, F
01DE  0DC0  	RLF CompTempVarRet214+D'1', F
01DF  0DB6  	RLF __div_16_1_00003_arg_a, F
01E0  0DB7  	RLF __div_16_1_00003_arg_a+D'1', F
01E1  0DBC  	RLF __div_16_1_00003_1_r, F
01E2  0DBD  	RLF __div_16_1_00003_1_r+D'1', F
01E3  0839  	MOVF __div_16_1_00003_arg_b+D'1', W
01E4  023D  	SUBWF __div_16_1_00003_1_r+D'1', W
01E5  1D03  	BTFSS STATUS,Z
01E6  29E9  	GOTO	label27
01E7  0838  	MOVF __div_16_1_00003_arg_b, W
01E8  023C  	SUBWF __div_16_1_00003_1_r, W
01E9        label27
01E9  1C03  	BTFSS STATUS,C
01EA  29F2  	GOTO	label28
01EB  0838  	MOVF __div_16_1_00003_arg_b, W
01EC  02BC  	SUBWF __div_16_1_00003_1_r, F
01ED  0839  	MOVF __div_16_1_00003_arg_b+D'1', W
01EE  1C03  	BTFSS STATUS,C
01EF  03BD  	DECF __div_16_1_00003_1_r+D'1', F
01F0  02BD  	SUBWF __div_16_1_00003_1_r+D'1', F
01F1  143F  	BSF CompTempVarRet214,0
01F2        label28
01F2  0ABE  	INCF __div_16_1_00003_1_i, F
01F3  29DA  	GOTO	label26
01F4        ; } __div_16_16 function end


07E5        _startup
07E5  30D5  	MOVLW 0xD5
07E6  1283  	BCF STATUS, RP0
07E7  1303  	BCF STATUS, RP1
07E8  00CC  	MOVWF gbl_14_LSR
07E9  30C4  	MOVLW 0xC4
07EA  00CD  	MOVWF gbl_14_LSR+D'1'
07EB  30BB  	MOVLW 0xBB
07EC  00CE  	MOVWF gbl_14_LSR+D'2'
07ED  30DC  	MOVLW 0xDC
07EE  00CF  	MOVWF gbl_14_LSR+D'3'
07EF  01D0  	CLRF gbl_15_gbl_aSig
07F0  01D1  	CLRF gbl_15_gbl_aSig+D'1'
07F1  01D2  	CLRF gbl_15_gbl_aSig+D'2'
07F2  01D3  	CLRF gbl_15_gbl_aSig+D'3'
07F3  01D4  	CLRF gbl_15_gbl_bSig
07F4  01D5  	CLRF gbl_15_gbl_bSig+D'1'
07F5  01D6  	CLRF gbl_15_gbl_bSig+D'2'
07F6  01D7  	CLRF gbl_15_gbl_bSig+D'3'
07F7  01D8  	CLRF gbl_15_gbl_zSig
07F8  01D9  	CLRF gbl_15_gbl_zSig+D'1'
07F9  01DA  	CLRF gbl_15_gbl_zSig+D'2'
07FA  01DB  	CLRF gbl_15_gbl_zSig+D'3'
07FB  01E8  	CLRF gbl_15_gbl_aExp
07FC  01E9  	CLRF gbl_15_gbl_bExp
07FD  01E3  	CLRF gbl_15_gbl_zExp
07FE  01E4  	CLRF gbl_15_gbl_zExp+D'1'
07FF  01EA  	CLRF gbl_15_gbl_aSign
0800  01EB  	CLRF gbl_15_gbl_bSign
0801  01EC  	CLRF gbl_15_gbl_zSign
0802  01ED  	CLRF gbl_15_gbl_zSigZero
0803  01DC  	CLRF gbl_15_gbl_ret
0804  01DD  	CLRF gbl_15_gbl_ret+D'1'
0805  01DE  	CLRF gbl_15_gbl_ret+D'2'
0806  01DF  	CLRF gbl_15_gbl_ret+D'3'
0807  01E6  	CLRF gbl_float_rounding_mode
0808  01E7  	CLRF gbl_float_exception_flags
0809  01E5  	CLRF gbl_float_detect_tininess

0840  118A  	BCF PCLATH,3
0841  120A  	BCF PCLATH,4
0842  2E9C  	GOTO	main

2007  3F3A  	DW 0x3F3A
