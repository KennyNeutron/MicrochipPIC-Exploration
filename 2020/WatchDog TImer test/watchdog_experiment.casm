;/////////////////////////////////////////////////////////////////////////////////
;// Code Generator: BoostC Compiler - http://www.sourceboost.com
;// Version       : 7.03
;// License Type  : Pro License
;// Limitations   : PIC12,PIC16 max code size:Unlimited, max RAM banks:Unlimited
;/////////////////////////////////////////////////////////////////////////////////

/*********************************************************************
 *                  Flowcode CAL Delays File
 *
 * File: PIC_CAL_Delay.c
 *
 * (c) 2011 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * “Company”) for its Flowcode graphical programming language is
 * intended and supplied to you, the Company’s customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 010911 | BR | Created
 *
 *
 *
 */

//Original Byte Delays
void Wdt_Delay_S(char delay);
void Wdt_Delay_Ms(char delay);

//New Int Delays
void FCI_DELAYINT_US(MX_UINT16 Delay);

void FCI_DELAYINT_MS(MX_UINT16 Delay);
void FCI_DELAYINTWDT_MS(MX_UINT16 Delay);

void FCI_DELAYINT_S(MX_UINT16 Delay);
void FCI_DELAYINTWDT_S(MX_UINT16 Delay);


#ifdef HI_TECH_C

	#define nop()	asm("NOP")

	void delay_10us(char del);
	void delay_us(char del);
	void delay_ms(char del);
	void delay_s(char del);

	void delay_10us(char del)
	{
		char count;
		for(count=0; count<10; count++)
		{
			delay_us(del);
		}
	}

	void delay_us(char del)
	{
		while (del > 1)
		{
			__delay_us(1);
			del = del - 1;
		}
	}

	void delay_ms(char del)
	{
		while (del > 1)
		{
			__delay_ms(1);
			del = del - 1;
		}
	}

	void delay_s(char del)
	{
		char i;
		for(i=0; i<del; i++)
		{
			delay_ms(250);
			delay_ms(250);
			delay_ms(250);
			delay_ms(250);
		}
	}

#endif

void Wdt_Delay_S(char delay)
{
    char i;
    short j;
    for (i=0; i<delay; i++)
    {
        for (j=0; j<999; j++)
        {
            Wdt_Delay_Ms(1);
        }
    }
}

void Wdt_Delay_Ms(char delay)

{
    char i;
    for (i=0; i<delay; i++)
0059  01CA  	CLRF Wdt_Delay__0003E_1_i
005A        label6
005A  0849  	MOVF Wdt_Delay__0003E_arg_delay, W
005B  024A  	SUBWF Wdt_Delay__0003E_1_i, W
005C  1803  	BTFSC STATUS,C
0062  0ACA  	INCF Wdt_Delay__0003E_1_i, F
0063  285A  	GOTO	label6

    {
        MX_CLEAR_WATCHDOG;        //Clear Watchdog Timer
005E  0064  	CLRWDT

        delay_ms(1);
005F  3001  	MOVLW 0x01
0060  00CB  	MOVWF delay_ms_00000_arg_del
0061  2010  	CALL delay_ms_00000

    }
}
005D  0008  	RETURN



void FCI_DELAYINT_US(MX_UINT16 Delay)
{
  	while (Delay > 255)
  	{
	  	delay_us(255);
	  	Delay = Delay - 255;
  	}
  	if (Delay > 0)
  		delay_us(Delay & 0xFF);
}

void FCI_DELAYINT_MS(MX_UINT16 Delay)
{
  	while (Delay > 255)
  	{
	  	delay_ms(255);
	  	Delay = Delay - 255;
  	}
  	if (Delay > 0)
  		delay_ms(Delay & 0xFF);
}

void FCI_DELAYINTWDT_MS(MX_UINT16 Delay)
{
  	while (Delay > 255)
  	{
	  	Wdt_Delay_Ms(255);
	  	Delay = Delay - 255;
  	}
  	if (Delay > 0)
  		Wdt_Delay_Ms(Delay & 0xFF);
}

void FCI_DELAYINT_S(MX_UINT16 Delay)
{
  	while (Delay > 255)
  	{
	  	delay_s(255);
	  	Delay = Delay - 255;
  	}
  	if (Delay > 0)
  		delay_s(Delay & 0xFF);
}

void FCI_DELAYINTWDT_S(MX_UINT16 Delay)
{
  	while (Delay > 255)
  	{
	  	Wdt_Delay_S(255);
	  	Delay = Delay - 255;
  	}
  	if (Delay > 0)
  		Wdt_Delay_S(Delay & 0xFF);
}



//************************************************************************************
//**  
//**  File name:     C:\Users\gerpe\OneDrive\GER-PER 2016\Documents\KennyNeutron\2020\WatchDog TImer test\watchdog_experiment.c
//**  Title:         
//**  Description:   
//**  
//**  Generated by:  Flowcode v5.2.0.0
//**  Date:          Monday, December 28, 2020 19:04:54
//**  Licence:       Professional
//**  Registered to: xyz
//**  Licence key:   WUK7B9
//**  
//**  
//**  http://www.matrixmultimedia.com
//**  
//************************************************************************************


#define MX_PIC

#define MX_USES_UINT8 1
#define MX_USES_SINT16 0
#define MX_USES_CHAR 0
#define MX_USES_FLOAT 0
#define MX_USES_SINT32 0
#define MX_USES_BOOL 1
#define MX_USES_UINT16 0
#define MX_USES_UINT32 0
//Defines for microcontroller
#define P16F873A
#define FC_CAL_PIC
#define MX_ADC
#define MX_ADC_TYPE_1
#define MX_ADC_BITS_10
#define MX_EE
#define MX_EE_TYPE2
#define MX_EE_SIZE 128
#define MX_SPI_1
#define MX_SPI_1_MISO_PORT portc
#define MX_SPI_1_MISO_TRIS trisc
#define MX_SPI_1_MISO_PIN 4
#define MX_SPI_1_MOSI_PORT portc
#define MX_SPI_1_MOSI_TRIS trisc
#define MX_SPI_1_MOSI_PIN 5
#define MX_SPI_1_CLK_PORT portc
#define MX_SPI_1_CLK_TRIS trisc
#define MX_SPI_1_CLK_PIN 3
#define MX_SPI_1_SS_PORT portc
#define MX_SPI_1_SS_TRIS trisc
#define MX_UART_1
#define MX_UART_1_TX_PORT portc
#define MX_UART_1_TX_TRIS trisc
#define MX_UART_1_TX_PIN 6
#define MX_UART_1_RX_PORT portc
#define MX_UART_1_RX_TRIS trisc
#define MX_UART_1_RX_PIN 7
#define MX_I2C
#define MX_MI2C
#define MX_I2C_1
#define MX_I2C_1_SDA_PORT portc
#define MX_I2C_1_SDA_TRIS trisc
#define MX_I2C_1_SDA_PIN 4
#define MX_I2C_1_SCL_PORT portc
#define MX_I2C_1_SCL_TRIS trisc
#define MX_I2C_1_SCL_PIN 3
#define MX_PWM
#define MX_PWM_CNT 2
#define MX_PWM_PSCA1
#define MX_PWM_PSCA4
#define MX_PWM_PSCA16
#define MX_PWM_1_PORT portc
#define MX_PWM_1_TRIS trisc
#define MX_PWM_1_PIN 2
#define MX_PWM_2_PORT portc
#define MX_PWM_2_TRIS trisc
#define MX_PWM_2_PIN 1

//Functions
#define MX_CLK_SPEED 20000000
#ifdef _BOOSTC
#include <system.h>
#endif
#ifdef HI_TECH_C
#include <pic.h>
#endif

//Configuration data
#ifdef _BOOSTC
#pragma DATA 0x2007, 0x3f3e
#endif
#ifdef HI_TECH_C
__CONFIG(0x3f3e);
#endif

//Internal functions
#include "C:\Program Files (x86)\Flowcode\v5\FCD\internals.c"

//Macro function declarations


//Variable declarations
#define FCV_TRUE (1)
#define FCV_FALSE (0)
MX_BOOL FCV_WDT_FLAG = (0);
01CF  1042  	BCF gbl_FCV_WDT_FLAG,0

MX_UINT8 FCV_DELAYY = (0x0);
01D0  01C3  	CLRF gbl_FCV_DELAYY

MX_UINT8 FCV_RST_STAT = (0xff);
01D1  30FF  	MOVLW 0xFF
01D2  00C4  	MOVWF gbl_FCV_RST_STAT

MX_UINT8 FCV_STAT_TEMP = (0xff);
01D3  30FF  	MOVLW 0xFF
01D4  00C5  	MOVWF gbl_FCV_STAT_TEMP





//LCDDisplay(0): //Defines:

/**** Macro Substitutions ****
a = Unique Component Reference Number
b = D1 Port Letter
c = D2 Port Letter
d = D3 Port Letter
e = D4 Port Letter
f = RS Port Letter
g = E Port Letter
h = Data 1_Pin
i = Data 2 Pin
j = Data 3 Pin
k = Data 4 Pin
l = RS Pin
m = Enable Pin
n = Row Count
o = Column Count
******************************/

	//component connections
	#define LCD_1__PORT0    portb
	#define LCD_1__PORT1    portb
	#define LCD_1__PORT2    portb
	#define LCD_1__PORT3    portb
	#define LCD_1__PORT4    portb
	#define LCD_1__PORT5    portb
	#define LCD_1__TRIS0    trisb
	#define LCD_1__TRIS1    trisb
	#define LCD_1__TRIS2    trisb
	#define LCD_1__TRIS3    trisb
	#define LCD_1__TRIS4    trisb
	#define LCD_1__TRIS5    trisb
	#define LCD_1__BIT0    	2
	#define LCD_1__BIT1    	3
	#define LCD_1__BIT2    	4
	#define LCD_1__BIT3    	5
	#define LCD_1__RS      	0
	#define LCD_1__E       	1
	#define LCD_1__ROWCNT	4
	#define LCD_1__COLCNT	16

	#ifdef _BOOSTC
	  #define LCD_1__DELAY   delay_10us(10)
	#endif
	#ifdef _C2C_
	  #define LCD_1__DELAY   delay_us(100)
	#endif
	#ifdef HI_TECH_C
	  #define LCD_1__DELAY   __delay_us(120)
	#endif
	#ifndef LCD_1__DELAY
	  #define LCD_1__DELAY   delay_us(100)
	#endif




//LCDDisplay(0): //Macro function declarations

void FCD_LCDDisplay0_RawSend(MX_UINT8 in, MX_UINT8 mask);
void FCD_LCDDisplay0_Start();
void FCD_LCDDisplay0_Clear();
void FCD_LCDDisplay0_PrintASCII(MX_UINT8 Character);
void FCD_LCDDisplay0_Command(MX_UINT8 in);
void FCD_LCDDisplay0_Cursor(MX_UINT8 x, MX_UINT8 y);
void FCD_LCDDisplay0_PrintNumber(MX_SINT16 Number);
void FCD_LCDDisplay0_PrintString(MX_STRING String, MX_UINT8 MSZ_String);
void FCD_LCDDisplay0_ScrollDisplay(MX_UINT8 Direction, MX_UINT8 Num_Positions);
void FCD_LCDDisplay0_ClearLine(MX_UINT8 Line);
void FCD_LCDDisplay0_RAM_Write(MX_UINT8 nIdx, MX_UINT8 d0, MX_UINT8 d1, MX_UINT8 d2, MX_UINT8 d3, MX_UINT8 d4, MX_UINT8 d5, MX_UINT8 d6, MX_UINT8 d7);



//LCDDisplay(0): //Macro implementations


void FCD_LCDDisplay0_RawSend(MX_UINT8 in, MX_UINT8 mask)

{
	
		MX_UINT8 pt;

		FC_CAL_Bit_Low(LCD_1__PORT0, LCD_1__BIT0);
0064  1106  	BCF gbl_portb,2

		FC_CAL_Bit_Low(LCD_1__PORT1, LCD_1__BIT1);
0065  1186  	BCF gbl_portb,3

		FC_CAL_Bit_Low(LCD_1__PORT2, LCD_1__BIT2);
0066  1206  	BCF gbl_portb,4

		FC_CAL_Bit_Low(LCD_1__PORT3, LCD_1__BIT3);
0067  1286  	BCF gbl_portb,5

		FC_CAL_Bit_Low(LCD_1__PORT4, LCD_1__RS);
0068  1006  	BCF gbl_portb,0

		FC_CAL_Bit_Low(LCD_1__PORT5, LCD_1__E);
0069  1086  	BCF gbl_portb,1

		pt = ((in >> 4) & 0x0f);
006A  0E56  	SWAPF FCD_LCDDis_00051_arg_in, W
006B  390F  	ANDLW 0x0F
006C  00D8  	MOVWF FCD_LCDDis_00051_1_pt
006D  300F  	MOVLW 0x0F
006E  05D8  	ANDWF FCD_LCDDis_00051_1_pt, F

		if (pt & 0x01)
006F  1858  	BTFSC FCD_LCDDis_00051_1_pt,0

		    FC_CAL_Bit_High(LCD_1__PORT0, LCD_1__BIT0);
0070  1506  	BSF gbl_portb,2

		if (pt & 0x02)
0071  18D8  	BTFSC FCD_LCDDis_00051_1_pt,1

		    FC_CAL_Bit_High(LCD_1__PORT1, LCD_1__BIT1);
0072  1586  	BSF gbl_portb,3

		if (pt & 0x04)
0073  1958  	BTFSC FCD_LCDDis_00051_1_pt,2

		    FC_CAL_Bit_High(LCD_1__PORT2, LCD_1__BIT2);
0074  1606  	BSF gbl_portb,4

		if (pt & 0x08)
0075  19D8  	BTFSC FCD_LCDDis_00051_1_pt,3

		    FC_CAL_Bit_High(LCD_1__PORT3, LCD_1__BIT3);
0076  1686  	BSF gbl_portb,5

		if (mask)
0077  08D7  	MOVF FCD_LCDDis_00051_arg_mask, F
0078  1D03  	BTFSS STATUS,Z

		    FC_CAL_Bit_High(LCD_1__PORT4, LCD_1__RS);
0079  1406  	BSF gbl_portb,0

		LCD_1__DELAY;
007A  300A  	MOVLW 0x0A
007B  00D9  	MOVWF delay_10us_00000_arg_del
007C  203C  	CALL delay_10us_00000

		FC_CAL_Bit_High (LCD_1__PORT5, LCD_1__E);
007D  1486  	BSF gbl_portb,1

		LCD_1__DELAY;
007E  300A  	MOVLW 0x0A
007F  00D9  	MOVWF delay_10us_00000_arg_del
0080  203C  	CALL delay_10us_00000

		FC_CAL_Bit_Low (LCD_1__PORT5, LCD_1__E);
0081  1086  	BCF gbl_portb,1

		pt = (in & 0x0f);
0082  300F  	MOVLW 0x0F
0083  0556  	ANDWF FCD_LCDDis_00051_arg_in, W
0084  00D8  	MOVWF FCD_LCDDis_00051_1_pt

		LCD_1__DELAY;
0085  300A  	MOVLW 0x0A
0086  00D9  	MOVWF delay_10us_00000_arg_del
0087  203C  	CALL delay_10us_00000

		FC_CAL_Bit_Low(LCD_1__PORT0, LCD_1__BIT0);
0088  1106  	BCF gbl_portb,2

		FC_CAL_Bit_Low(LCD_1__PORT1, LCD_1__BIT1);
0089  1186  	BCF gbl_portb,3

		FC_CAL_Bit_Low(LCD_1__PORT2, LCD_1__BIT2);
008A  1206  	BCF gbl_portb,4

		FC_CAL_Bit_Low(LCD_1__PORT3, LCD_1__BIT3);
008B  1286  	BCF gbl_portb,5

		FC_CAL_Bit_Low(LCD_1__PORT4, LCD_1__RS);
008C  1006  	BCF gbl_portb,0

		FC_CAL_Bit_Low(LCD_1__PORT5, LCD_1__E);
008D  1086  	BCF gbl_portb,1

		if (pt & 0x01)
008E  1858  	BTFSC FCD_LCDDis_00051_1_pt,0

		    FC_CAL_Bit_High(LCD_1__PORT0, LCD_1__BIT0);
008F  1506  	BSF gbl_portb,2

		if (pt & 0x02)
0090  18D8  	BTFSC FCD_LCDDis_00051_1_pt,1

		    FC_CAL_Bit_High(LCD_1__PORT1, LCD_1__BIT1);
0091  1586  	BSF gbl_portb,3

		if (pt & 0x04)
0092  1958  	BTFSC FCD_LCDDis_00051_1_pt,2

		    FC_CAL_Bit_High(LCD_1__PORT2, LCD_1__BIT2);
0093  1606  	BSF gbl_portb,4

		if (pt & 0x08)
0094  19D8  	BTFSC FCD_LCDDis_00051_1_pt,3

		    FC_CAL_Bit_High(LCD_1__PORT3, LCD_1__BIT3);
0095  1686  	BSF gbl_portb,5

		if (mask)
0096  08D7  	MOVF FCD_LCDDis_00051_arg_mask, F
0097  1D03  	BTFSS STATUS,Z

		    FC_CAL_Bit_High(LCD_1__PORT4, LCD_1__RS);
0098  1406  	BSF gbl_portb,0

		LCD_1__DELAY;
0099  300A  	MOVLW 0x0A
009A  00D9  	MOVWF delay_10us_00000_arg_del
009B  203C  	CALL delay_10us_00000

		FC_CAL_Bit_High (LCD_1__PORT5, LCD_1__E);
009C  1486  	BSF gbl_portb,1

		LCD_1__DELAY;
009D  300A  	MOVLW 0x0A
009E  00D9  	MOVWF delay_10us_00000_arg_del
009F  203C  	CALL delay_10us_00000

		FC_CAL_Bit_Low (LCD_1__PORT5, LCD_1__E);
00A0  1086  	BCF gbl_portb,1

		LCD_1__DELAY;
00A1  300A  	MOVLW 0x0A
00A2  00D9  	MOVWF delay_10us_00000_arg_del
00A3  203C  	CALL delay_10us_00000


}
00A4  0008  	RETURN


void FCD_LCDDisplay0_Start()

{
	
		FC_CAL_Bit_Low_DDR(LCD_1__PORT0, LCD_1__TRIS0, LCD_1__BIT0);
00F0  1683  	BSF STATUS, RP0
00F1  1303  	BCF STATUS, RP1
00F2  1106  	BCF gbl_trisb,2
00F3  1283  	BCF STATUS, RP0
00F4  1106  	BCF gbl_portb,2

		FC_CAL_Bit_Low_DDR(LCD_1__PORT1, LCD_1__TRIS1, LCD_1__BIT1);
00F5  1683  	BSF STATUS, RP0
00F6  1186  	BCF gbl_trisb,3
00F7  1283  	BCF STATUS, RP0
00F8  1186  	BCF gbl_portb,3

		FC_CAL_Bit_Low_DDR(LCD_1__PORT2, LCD_1__TRIS2, LCD_1__BIT2);
00F9  1683  	BSF STATUS, RP0
00FA  1206  	BCF gbl_trisb,4
00FB  1283  	BCF STATUS, RP0
00FC  1206  	BCF gbl_portb,4

		FC_CAL_Bit_Low_DDR(LCD_1__PORT3, LCD_1__TRIS3, LCD_1__BIT3);
00FD  1683  	BSF STATUS, RP0
00FE  1286  	BCF gbl_trisb,5
00FF  1283  	BCF STATUS, RP0
0100  1286  	BCF gbl_portb,5

		FC_CAL_Bit_Low_DDR(LCD_1__PORT4, LCD_1__TRIS4, LCD_1__RS);
0101  1683  	BSF STATUS, RP0
0102  1006  	BCF gbl_trisb,0
0103  1283  	BCF STATUS, RP0
0104  1006  	BCF gbl_portb,0

		FC_CAL_Bit_Low_DDR(LCD_1__PORT5, LCD_1__TRIS5, LCD_1__E);
0105  1683  	BSF STATUS, RP0
0106  1086  	BCF gbl_trisb,1
0107  1283  	BCF STATUS, RP0
0108  1086  	BCF gbl_portb,1


		Wdt_Delay_Ms(12);
0109  300C  	MOVLW 0x0C
010A  00C9  	MOVWF Wdt_Delay__0003E_arg_delay
010B  2059  	CALL Wdt_Delay__0003E


		FCD_LCDDisplay0_RawSend(0x33, 0);
010C  3033  	MOVLW 0x33
010D  00D6  	MOVWF FCD_LCDDis_00051_arg_in
010E  01D7  	CLRF FCD_LCDDis_00051_arg_mask
010F  2064  	CALL FCD_LCDDis_00051

		Wdt_Delay_Ms(2);
0110  3002  	MOVLW 0x02
0111  00C9  	MOVWF Wdt_Delay__0003E_arg_delay
0112  2059  	CALL Wdt_Delay__0003E

		FCD_LCDDisplay0_RawSend(0x33, 0);
0113  3033  	MOVLW 0x33
0114  00D6  	MOVWF FCD_LCDDis_00051_arg_in
0115  01D7  	CLRF FCD_LCDDis_00051_arg_mask
0116  2064  	CALL FCD_LCDDis_00051

		Wdt_Delay_Ms(2);
0117  3002  	MOVLW 0x02
0118  00C9  	MOVWF Wdt_Delay__0003E_arg_delay
0119  2059  	CALL Wdt_Delay__0003E

		FCD_LCDDisplay0_RawSend(0x32, 0);
011A  3032  	MOVLW 0x32
011B  00D6  	MOVWF FCD_LCDDis_00051_arg_in
011C  01D7  	CLRF FCD_LCDDis_00051_arg_mask
011D  2064  	CALL FCD_LCDDis_00051

		Wdt_Delay_Ms(2);
011E  3002  	MOVLW 0x02
011F  00C9  	MOVWF Wdt_Delay__0003E_arg_delay
0120  2059  	CALL Wdt_Delay__0003E

		FCD_LCDDisplay0_RawSend(0x2c, 0);
0121  302C  	MOVLW 0x2C
0122  00D6  	MOVWF FCD_LCDDis_00051_arg_in
0123  01D7  	CLRF FCD_LCDDis_00051_arg_mask
0124  2064  	CALL FCD_LCDDis_00051

		Wdt_Delay_Ms(2);
0125  3002  	MOVLW 0x02
0126  00C9  	MOVWF Wdt_Delay__0003E_arg_delay
0127  2059  	CALL Wdt_Delay__0003E

		FCD_LCDDisplay0_RawSend(0x06, 0);
0128  3006  	MOVLW 0x06
0129  00D6  	MOVWF FCD_LCDDis_00051_arg_in
012A  01D7  	CLRF FCD_LCDDis_00051_arg_mask
012B  2064  	CALL FCD_LCDDis_00051

		Wdt_Delay_Ms(2);
012C  3002  	MOVLW 0x02
012D  00C9  	MOVWF Wdt_Delay__0003E_arg_delay
012E  2059  	CALL Wdt_Delay__0003E

		FCD_LCDDisplay0_RawSend(0x0c, 0);
012F  300C  	MOVLW 0x0C
0130  00D6  	MOVWF FCD_LCDDis_00051_arg_in
0131  01D7  	CLRF FCD_LCDDis_00051_arg_mask
0132  2064  	CALL FCD_LCDDis_00051

		Wdt_Delay_Ms(2);
0133  3002  	MOVLW 0x02
0134  00C9  	MOVWF Wdt_Delay__0003E_arg_delay
0135  2059  	CALL Wdt_Delay__0003E


		//clear the display
		FCD_LCDDisplay0_RawSend(0x01, 0);
0136  3001  	MOVLW 0x01
0137  00D6  	MOVWF FCD_LCDDis_00051_arg_in
0138  01D7  	CLRF FCD_LCDDis_00051_arg_mask
0139  2064  	CALL FCD_LCDDis_00051

		Wdt_Delay_Ms(2);
013A  3002  	MOVLW 0x02
013B  00C9  	MOVWF Wdt_Delay__0003E_arg_delay
013C  2059  	CALL Wdt_Delay__0003E

		FCD_LCDDisplay0_RawSend(0x02, 0);
013D  3002  	MOVLW 0x02
013E  00D6  	MOVWF FCD_LCDDis_00051_arg_in
013F  01D7  	CLRF FCD_LCDDis_00051_arg_mask
0140  2064  	CALL FCD_LCDDis_00051

		Wdt_Delay_Ms(2);
0141  3002  	MOVLW 0x02
0142  00C9  	MOVWF Wdt_Delay__0003E_arg_delay
0143  2059  	CALL Wdt_Delay__0003E


}
0144  0008  	RETURN


void FCD_LCDDisplay0_Clear()

{
	
		FCD_LCDDisplay0_RawSend(0x01, 0);
00DF  3001  	MOVLW 0x01
00E0  1283  	BCF STATUS, RP0
00E1  1303  	BCF STATUS, RP1
00E2  00D6  	MOVWF FCD_LCDDis_00051_arg_in
00E3  01D7  	CLRF FCD_LCDDis_00051_arg_mask
00E4  2064  	CALL FCD_LCDDis_00051

		Wdt_Delay_Ms(2);
00E5  3002  	MOVLW 0x02
00E6  00C9  	MOVWF Wdt_Delay__0003E_arg_delay
00E7  2059  	CALL Wdt_Delay__0003E

		FCD_LCDDisplay0_RawSend(0x02, 0);
00E8  3002  	MOVLW 0x02
00E9  00D6  	MOVWF FCD_LCDDis_00051_arg_in
00EA  01D7  	CLRF FCD_LCDDis_00051_arg_mask
00EB  2064  	CALL FCD_LCDDis_00051

		Wdt_Delay_Ms(2);
00EC  3002  	MOVLW 0x02
00ED  00C9  	MOVWF Wdt_Delay__0003E_arg_delay
00EE  2059  	CALL Wdt_Delay__0003E


}
00EF  0008  	RETURN


void FCD_LCDDisplay0_PrintASCII(MX_UINT8 Character)
{
	
		FCD_LCDDisplay0_RawSend(Character, 0x10);

}

void FCD_LCDDisplay0_Command(MX_UINT8 in)
{
	
		FCD_LCDDisplay0_RawSend(in, 0);
		Wdt_Delay_Ms(2);

}

void FCD_LCDDisplay0_Cursor(MX_UINT8 x, MX_UINT8 y)

{
	
	  #if (LCD_1__ROWCNT == 1)
	    y=0x80;
	  #endif

	  #if (LCD_1__ROWCNT == 2)
		if (y==0)
			y=0x80;
		else
			y=0xc0;
	  #endif

	  #if (LCD_1__ROWCNT == 4)
		if (y==0)
00C1  08C8  	MOVF FCD_LCDDis_00056_arg_y, F
00C2  1D03  	BTFSS STATUS,Z
00C3  28C7  	GOTO	label8
00C7        label8

			y=0x80;
00C4  3080  	MOVLW 0x80
00C5  00C8  	MOVWF FCD_LCDDis_00056_arg_y

		else if (y==1)
00C6  28D6  	GOTO	label11
00C7  0348  	DECF FCD_LCDDis_00056_arg_y, W
00C8  1D03  	BTFSS STATUS,Z
00C9  28CD  	GOTO	label9
00CD        label9

			y=0xc0;
00CA  30C0  	MOVLW 0xC0
00CB  00C8  	MOVWF FCD_LCDDis_00056_arg_y


		#if (LCD_1__COLCNT == 16)
			else if (y==2)
00CC  28D6  	GOTO	label11
00CD  0848  	MOVF FCD_LCDDis_00056_arg_y, W
00CE  3A02  	XORLW 0x02
00CF  1D03  	BTFSS STATUS,Z
00D0  28D4  	GOTO	label10
00D4        label10

				y=0x90;
00D1  3090  	MOVLW 0x90
00D2  00C8  	MOVWF FCD_LCDDis_00056_arg_y

			else
00D3  28D6  	GOTO	label11
00D6        label11

				y=0xd0;
00D4  30D0  	MOVLW 0xD0
00D5  00C8  	MOVWF FCD_LCDDis_00056_arg_y

		#endif

		#if (LCD_1__COLCNT == 20)
			else if (y==2)
				y=0x94;
			else
				y=0xd4;
		#endif
	  #endif

		FCD_LCDDisplay0_RawSend(y+x, 0);
00D6  0847  	MOVF FCD_LCDDis_00056_arg_x, W
00D7  0748  	ADDWF FCD_LCDDis_00056_arg_y, W
00D8  00D6  	MOVWF FCD_LCDDis_00051_arg_in
00D9  01D7  	CLRF FCD_LCDDis_00051_arg_mask
00DA  2064  	CALL FCD_LCDDis_00051

		Wdt_Delay_Ms(2);
00DB  3002  	MOVLW 0x02
00DC  00C9  	MOVWF Wdt_Delay__0003E_arg_delay
00DD  2059  	CALL Wdt_Delay__0003E


}
00DE  0008  	RETURN


void FCD_LCDDisplay0_PrintNumber(MX_SINT16 Number)
{
	
		MX_SINT16 tmp_int;
		MX_UINT8 tmp_byte;

		if (Number < 0)
		{
			FCD_LCDDisplay0_RawSend('-', 0x10);
			Number = 0 - Number;
		}

		tmp_int = Number;
		if (Number >= 10000)
		{
			tmp_byte = tmp_int / 10000;
			FCD_LCDDisplay0_RawSend('0' + tmp_byte, 0x10);

			while (tmp_byte > 0)
			{
				tmp_int = tmp_int - 10000;
				tmp_byte--;
			}
		}
		if (Number >= 1000)
		{
			tmp_byte = tmp_int / 1000;
			FCD_LCDDisplay0_RawSend('0' + tmp_byte, 0x10);

			while (tmp_byte > 0)
			{
				tmp_int = tmp_int - 1000;
				tmp_byte--;
			}
		}
		if (Number >= 100)
		{
			tmp_byte = tmp_int / 100;
			FCD_LCDDisplay0_RawSend('0' + tmp_byte, 0x10);

			while (tmp_byte > 0)
			{
				tmp_int = tmp_int - 100;
				tmp_byte--;
			}
		}
		if (Number >= 10)
		{
			tmp_byte = tmp_int / 10;
			FCD_LCDDisplay0_RawSend('0' + tmp_byte, 0x10);

			while (tmp_byte > 0)
			{
				tmp_int = tmp_int - 10;
				tmp_byte--;
			}
		}
		FCD_LCDDisplay0_RawSend('0' + tmp_int, 0x10);

}

void FCD_LCDDisplay0_PrintString(MX_STRING String, MX_UINT8 MSZ_String)

{
	
		MX_UINT8 idx = 0;
00A5  01D5  	CLRF FCD_LCDDis_00058_1_idx


		for (idx=0; idx<MSZ_String; idx++)
00A6  01D5  	CLRF FCD_LCDDis_00058_1_idx
00A7        label7
00A7  0854  	MOVF FCD_LCDDis_00058_arg_MSZ_String, W
00A8  0255  	SUBWF FCD_LCDDis_00058_1_idx, W
00A9  1803  	BTFSC STATUS,C
00BF  0AD5  	INCF FCD_LCDDis_00058_1_idx, F
00C0  28A7  	GOTO	label7

		{
			if (String[idx] == 0)
00AB  1383  	BCF STATUS,IRP
00AC  1848  	BTFSC FCD_LCDDis_00058_arg_String+D'1',0
00AD  1783  	BSF STATUS,IRP
00AE  0847  	MOVF FCD_LCDDis_00058_arg_String, W
00AF  0755  	ADDWF FCD_LCDDis_00058_1_idx, W
00B0  0084  	MOVWF FSR
00B1  0880  	MOVF INDF, F
00B2  1903  	BTFSC STATUS,Z

			{
				break;

			}
			FCD_LCDDisplay0_RawSend(String[idx], 0x10);
00B4  1383  	BCF STATUS,IRP
00B5  1848  	BTFSC FCD_LCDDis_00058_arg_String+D'1',0
00B6  1783  	BSF STATUS,IRP
00B7  0847  	MOVF FCD_LCDDis_00058_arg_String, W
00B8  0755  	ADDWF FCD_LCDDis_00058_1_idx, W
00B9  0084  	MOVWF FSR
00BA  0800  	MOVF INDF, W
00BB  00D6  	MOVWF FCD_LCDDis_00051_arg_in
00BC  3010  	MOVLW 0x10
00BD  00D7  	MOVWF FCD_LCDDis_00051_arg_mask
00BE  2064  	CALL FCD_LCDDis_00051

		}

}
00AA  0008  	RETURN
00B3  0008  	RETURN


void FCD_LCDDisplay0_ScrollDisplay(MX_UINT8 Direction, MX_UINT8 Num_Positions)
{
	
		MX_UINT8 cmd = 0;
		MX_UINT8 count;

		//Choose the direction
		switch (Direction)
		{
			case 0:
			case 'l':
			case 'L':

				cmd = 0x18;
				break;

			case 1:
			case 'r':
			case 'R':

				cmd = 0x1C;
				break;

			default:
				break;
		}

		//If direction accepted then scroll the specified amount
		if (cmd)
		{
			for (count = 0; count < Num_Positions; count++)
				FCD_LCDDisplay0_Command(cmd);
		}

}

void FCD_LCDDisplay0_ClearLine(MX_UINT8 Line)
{
	
		MX_UINT8 count;
		MX_UINT8 rowcount;

		//Define number of columns per line
		#if (LCD_1__ROWCNT == 1)
			rowcount=80;
		#endif

		#if (LCD_1__ROWCNT == 2)
			rowcount=40;
		#endif

		#if (LCD_1__ROWCNT == 4)
			#if (LCD_1__COLCNT == 16)
				rowcount=16;
			#endif
			#if (LCD_1__COLCNT == 20)
				rowcount=20;
			#endif
		#endif

		//Start at beginning of the line
		FCD_LCDDisplay0_Cursor (0, Line);

		//Send out spaces to clear line
		for (count = 0; count < rowcount; count++)
			FCD_LCDDisplay0_RawSend(' ', 0x10);

		//Move back to the beginning of the line.
		FCD_LCDDisplay0_Cursor (0, Line);

}

void FCD_LCDDisplay0_RAM_Write(MX_UINT8 nIdx, MX_UINT8 d0, MX_UINT8 d1, MX_UINT8 d2, MX_UINT8 d3, MX_UINT8 d4, MX_UINT8 d5, MX_UINT8 d6, MX_UINT8 d7)
{
	   //set CGRAM address

	   FCD_LCDDisplay0_RawSend(64 + (nIdx << 3), 0);
	   delay_ms(2);

	   //write CGRAM data
	   FCD_LCDDisplay0_RawSend(d0, 0x10);
	   FCD_LCDDisplay0_RawSend(d1, 0x10);
	   FCD_LCDDisplay0_RawSend(d2, 0x10);
	   FCD_LCDDisplay0_RawSend(d3, 0x10);
	   FCD_LCDDisplay0_RawSend(d4, 0x10);
	   FCD_LCDDisplay0_RawSend(d5, 0x10);
	   FCD_LCDDisplay0_RawSend(d6, 0x10);
	   FCD_LCDDisplay0_RawSend(d7, 0x10);

	   //Clear the display
	   FCD_LCDDisplay0_RawSend(0x01, 0);
	   delay_ms(2);
	   FCD_LCDDisplay0_RawSend(0x02, 0);
	   delay_ms(2);

}

#include "C:\Program Files (x86)\Flowcode\v5\CAL\includes.c"

//Macro implementations



void main()

{
	//Initialization
	adcon1 = 0x07;
0145  3007  	MOVLW 0x07
0146  1683  	BSF STATUS, RP0
0147  1303  	BCF STATUS, RP1
0148  009F  	MOVWF gbl_adcon1



	//Interrupt initialization code
	option_reg = 0xC0;
0149  30C0  	MOVLW 0xC0
014A  0081  	MOVWF gbl_option_reg



	//C Code
	//C Code:
	/*
	  Enter C code below this comment
	*/
	MX_UINT8 FCV_STATT = status;
014B  0803  	MOVF gbl_status, W
014C  1283  	BCF STATUS, RP0
014D  00C6  	MOVWF main_1_FCV_STATT


	//C Code
	//C Code:
	//MOV FCV_STAT TO STAT_TEMP
	FCV_STAT_TEMP=FCV_STATT;
014E  0846  	MOVF main_1_FCV_STATT, W
014F  00C5  	MOVWF gbl_FCV_STAT_TEMP


	//C Code
	//C Code:
	/*
	  Enter C code below this comment
	*/
	option_reg=0b00011110;
0150  301E  	MOVLW 0x1E
0151  1683  	BSF STATUS, RP0
0152  0081  	MOVWF gbl_option_reg


	//C Code
	//C Code:
	// STAT_TEMP && b'00010000'
	FCV_STAT_TEMP=FCV_STAT_TEMP&16;
0153  3010  	MOVLW 0x10
0154  1283  	BCF STATUS, RP0
0155  0545  	ANDWF gbl_FCV_STAT_TEMP, W
0156  00C5  	MOVWF gbl_FCV_STAT_TEMP

	if(FCV_STAT_TEMP==0){
0157  08C5  	MOVF gbl_FCV_STAT_TEMP, F
0158  1D03  	BTFSS STATUS,Z
0159  295C  	GOTO	label12
015C        label12

	    FCV_WDT_FLAG=0;
015A  1042  	BCF gbl_FCV_WDT_FLAG,0

	}else{
015B  295D  	GOTO	label13
015D        label13

	    FCV_WDT_FLAG=1;
015C  1442  	BSF gbl_FCV_WDT_FLAG,0

	}

	//Call Component Macro
	//Call Component Macro: Start()
	FCD_LCDDisplay0_Start();
015D  20F0  	CALL FCD_LCDDis_00052


	//Call Component Macro
	//Call Component Macro: Clear()
	FCD_LCDDisplay0_Clear();
015E  20DF  	CALL FCD_LCDDis_00053


	//Call Component Macro
	//Call Component Macro: Cursor(0, 0)
	FCD_LCDDisplay0_Cursor(0, 0);
015F  01C7  	CLRF FCD_LCDDis_00056_arg_x
0160  01C8  	CLRF FCD_LCDDis_00056_arg_y
0161  20C1  	CALL FCD_LCDDis_00056


	//Decision
	//Decision: wdt_flag = 0?
	if (FCV_WDT_FLAG == 0)
0162  1842  	BTFSC gbl_FCV_WDT_FLAG,0
0163  297F  	GOTO	label14
017F        label14

	{

		//Call Component Macro
		//Call Component Macro: PrintString("WARM RESET")
		FCD_LCDDisplay0_PrintString("WARM RESET", 10);
0164  3020  	MOVLW 0x20
0165  00CD  	MOVWF CompTempVar2217+D'4'
0166  3041  	MOVLW 0x41
0167  00CA  	MOVWF CompTempVar2217+D'1'
0168  3045  	MOVLW 0x45
0169  00CF  	MOVWF CompTempVar2217+D'6'
016A  00D1  	MOVWF CompTempVar2217+D'8'
016B  304D  	MOVLW 0x4D
016C  00CC  	MOVWF CompTempVar2217+D'3'
016D  3052  	MOVLW 0x52
016E  00CB  	MOVWF CompTempVar2217+D'2'
016F  00CE  	MOVWF CompTempVar2217+D'5'
0170  3053  	MOVLW 0x53
0171  00D0  	MOVWF CompTempVar2217+D'7'
0172  3054  	MOVLW 0x54
0173  00D2  	MOVWF CompTempVar2217+D'9'
0174  3057  	MOVLW 0x57
0175  00C9  	MOVWF CompTempVar2217
0176  01D3  	CLRF CompTempVar2217+D'10'
0177  3000  	MOVLW HIGH(CompTempVar2217+D'0')
0178  00C8  	MOVWF FCD_LCDDis_00058_arg_String+D'1'
0179  3049  	MOVLW LOW(CompTempVar2217+D'0')
017A  00C7  	MOVWF FCD_LCDDis_00058_arg_String
017B  300A  	MOVLW 0x0A
017C  00D4  	MOVWF FCD_LCDDis_00058_arg_MSZ_String
017D  20A5  	CALL FCD_LCDDis_00058


	} else {
017E  299A  	GOTO	label15
019A        label15


		//Call Component Macro
		//Call Component Macro: PrintString("COLD RESET")
		FCD_LCDDisplay0_PrintString("COLD RESET", 10);
017F  3020  	MOVLW 0x20
0180  00CD  	MOVWF CompTempVar2219+D'4'
0181  3043  	MOVLW 0x43
0182  00C9  	MOVWF CompTempVar2219
0183  3044  	MOVLW 0x44
0184  00CC  	MOVWF CompTempVar2219+D'3'
0185  3045  	MOVLW 0x45
0186  00CF  	MOVWF CompTempVar2219+D'6'
0187  00D1  	MOVWF CompTempVar2219+D'8'
0188  304C  	MOVLW 0x4C
0189  00CB  	MOVWF CompTempVar2219+D'2'
018A  304F  	MOVLW 0x4F
018B  00CA  	MOVWF CompTempVar2219+D'1'
018C  3052  	MOVLW 0x52
018D  00CE  	MOVWF CompTempVar2219+D'5'
018E  3053  	MOVLW 0x53
018F  00D0  	MOVWF CompTempVar2219+D'7'
0190  3054  	MOVLW 0x54
0191  00D2  	MOVWF CompTempVar2219+D'9'
0192  01D3  	CLRF CompTempVar2219+D'10'
0193  3000  	MOVLW HIGH(CompTempVar2219+D'0')
0194  00C8  	MOVWF FCD_LCDDis_00058_arg_String+D'1'
0195  3049  	MOVLW LOW(CompTempVar2219+D'0')
0196  00C7  	MOVWF FCD_LCDDis_00058_arg_String
0197  300A  	MOVLW 0x0A
0198  00D4  	MOVWF FCD_LCDDis_00058_arg_MSZ_String
0199  20A5  	CALL FCD_LCDDis_00058


	}

	//Output
	//Output: 1 -> C3
	trisc = trisc & 0xF7;
019A  30F7  	MOVLW 0xF7
019B  1683  	BSF STATUS, RP0
019C  0507  	ANDWF gbl_trisc, W
019D  0087  	MOVWF gbl_trisc

	if ((1))
		portc = (portc & 0xF7) | 0x08;
019E  30F7  	MOVLW 0xF7
019F  1283  	BCF STATUS, RP0
01A0  0507  	ANDWF gbl_portc, W
01A1  00C7  	MOVWF CompTempVar2221
01A2  3008  	MOVLW 0x08
01A3  0447  	IORWF CompTempVar2221, W
01A4  0087  	MOVWF gbl_portc

	else
		portc = portc & 0xF7;

	//Calculation
	//Calculation:
	//  delayy = 0
	FCV_DELAYY = 0;
01A5  01C3  	CLRF gbl_FCV_DELAYY


	//Loop
	//Loop: While 1
	while (1)
01A6        label16
01A9  29A6  	GOTO	label16

	{

		//Delay
		//Delay: 5 s
		delay_s(5);
01A6  3005  	MOVLW 0x05
01A7  00C7  	MOVWF delay_s_00000_arg_del
01A8  204A  	CALL delay_s_00000



	}

	mainendloop: goto mainendloop;
}


void MX_INTERRUPT_MACRO(void)

{
}
01D8  1283  	BCF STATUS, RP0
01D9  1303  	BCF STATUS, RP1
01DA  0E36  	SWAPF Int1BContext+D'2', W
01DB  0084  	MOVWF FSR
01DC  0E35  	SWAPF Int1BContext+D'1', W
01DD  008A  	MOVWF PCLATH
01DE  0E34  	SWAPF Int1BContext, W
01DF  0083  	MOVWF STATUS
01E0  0EFF  	SWAPF Int1Context, F
01E1  0E7F  	SWAPF Int1Context, W
01E2  0009  	RETFIE





////////////////////////////////////////
// Code with no source :-)
////////////////////////////////////////
0000  29AA  	GOTO	_startup

0004  00FF  	MOVWF Int1Context
0005  0E03  	SWAPF STATUS, W
0006  1283  	BCF STATUS, RP0
0007  1303  	BCF STATUS, RP1
0008  00B4  	MOVWF Int1BContext
0009  0E0A  	SWAPF PCLATH, W
000A  00B5  	MOVWF Int1BContext+D'1'
000B  0E04  	SWAPF FSR, W
000C  00B6  	MOVWF Int1BContext+D'2'
000D  118A  	BCF PCLATH,3
000E  120A  	BCF PCLATH,4
000F  29D8  	GOTO	interrupt
0010        delay_ms_00000
0010        ; { delay_ms ; function begin
0010  08CB  	MOVF delay_ms_00000_arg_del, F
0011  1D03  	BTFSS STATUS,Z
0012  2814  	GOTO	label1
0013  0008  	RETURN
0014        label1
0014  30F9  	MOVLW 0xF9
0015        label2
0015  0000  	NOP
0016  0000  	NOP
0017  0000  	NOP
0018  0000  	NOP
0019  0000  	NOP
001A  0000  	NOP
001B  0000  	NOP
001C  0000  	NOP
001D  0000  	NOP
001E  0000  	NOP
001F  0000  	NOP
0020  0000  	NOP
0021  0000  	NOP
0022  0000  	NOP
0023  0000  	NOP
0024  0000  	NOP
0025  3EFF  	ADDLW 0xFF
0026  1D03  	BTFSS STATUS,Z
0027  2815  	GOTO	label2
0028  0000  	NOP
0029  0000  	NOP
002A  0000  	NOP
002B  0000  	NOP
002C  0000  	NOP
002D  0000  	NOP
002E  0000  	NOP
002F  0000  	NOP
0030  0000  	NOP
0031  0000  	NOP
0032  0000  	NOP
0033  0000  	NOP
0034  0000  	NOP
0035  0000  	NOP
0036  0000  	NOP
0037  0000  	NOP
0038  0000  	NOP
0039  0BCB  	DECFSZ delay_ms_00000_arg_del, F
003A  2814  	GOTO	label1
003B  0008  	RETURN
003C        ; } delay_ms function end

003C        delay_10us_00000
003C        ; { delay_10us ; function begin
003C  08D9  	MOVF delay_10us_00000_arg_del, F
003D  1D03  	BTFSS STATUS,Z
003E  2840  	GOTO	label3
003F  0008  	RETURN
0040        label3
0040  3009  	MOVLW 0x09
0041        label4
0041  0000  	NOP
0042  3EFF  	ADDLW 0xFF
0043  1D03  	BTFSS STATUS,Z
0044  2841  	GOTO	label4
0045  0000  	NOP
0046  0000  	NOP
0047  0BD9  	DECFSZ delay_10us_00000_arg_del, F
0048  2840  	GOTO	label3
0049  0008  	RETURN
004A        ; } delay_10us function end

004A        delay_s_00000
004A        ; { delay_s ; function begin
004A        label5
004A  30FA  	MOVLW 0xFA
004B  00CB  	MOVWF delay_ms_00000_arg_del
004C  2010  	CALL delay_ms_00000
004D  30FA  	MOVLW 0xFA
004E  00CB  	MOVWF delay_ms_00000_arg_del
004F  2010  	CALL delay_ms_00000
0050  30FA  	MOVLW 0xFA
0051  00CB  	MOVWF delay_ms_00000_arg_del
0052  2010  	CALL delay_ms_00000
0053  30FA  	MOVLW 0xFA
0054  00CB  	MOVWF delay_ms_00000_arg_del
0055  2010  	CALL delay_ms_00000
0056  0BC7  	DECFSZ delay_s_00000_arg_del, F
0057  284A  	GOTO	label5
0058  0008  	RETURN
0059        ; } delay_s function end


01AA        _startup
01AA  30D5  	MOVLW 0xD5
01AB  1283  	BCF STATUS, RP0
01AC  1303  	BCF STATUS, RP1
01AD  00A0  	MOVWF gbl_14_LSR
01AE  30C4  	MOVLW 0xC4
01AF  00A1  	MOVWF gbl_14_LSR+D'1'
01B0  30BB  	MOVLW 0xBB
01B1  00A2  	MOVWF gbl_14_LSR+D'2'
01B2  30DC  	MOVLW 0xDC
01B3  00A3  	MOVWF gbl_14_LSR+D'3'
01B4  01A4  	CLRF gbl_15_gbl_aSig
01B5  01A5  	CLRF gbl_15_gbl_aSig+D'1'
01B6  01A6  	CLRF gbl_15_gbl_aSig+D'2'
01B7  01A7  	CLRF gbl_15_gbl_aSig+D'3'
01B8  01A8  	CLRF gbl_15_gbl_bSig
01B9  01A9  	CLRF gbl_15_gbl_bSig+D'1'
01BA  01AA  	CLRF gbl_15_gbl_bSig+D'2'
01BB  01AB  	CLRF gbl_15_gbl_bSig+D'3'
01BC  01AC  	CLRF gbl_15_gbl_zSig
01BD  01AD  	CLRF gbl_15_gbl_zSig+D'1'
01BE  01AE  	CLRF gbl_15_gbl_zSig+D'2'
01BF  01AF  	CLRF gbl_15_gbl_zSig+D'3'
01C0  01BC  	CLRF gbl_15_gbl_aExp
01C1  01BD  	CLRF gbl_15_gbl_bExp
01C2  01B7  	CLRF gbl_15_gbl_zExp
01C3  01B8  	CLRF gbl_15_gbl_zExp+D'1'
01C4  01BE  	CLRF gbl_15_gbl_aSign
01C5  01BF  	CLRF gbl_15_gbl_bSign
01C6  01C0  	CLRF gbl_15_gbl_zSign
01C7  01C1  	CLRF gbl_15_gbl_zSigZero
01C8  01B0  	CLRF gbl_15_gbl_ret
01C9  01B1  	CLRF gbl_15_gbl_ret+D'1'
01CA  01B2  	CLRF gbl_15_gbl_ret+D'2'
01CB  01B3  	CLRF gbl_15_gbl_ret+D'3'
01CC  01BA  	CLRF gbl_float_rounding_mode
01CD  01BB  	CLRF gbl_float_exception_flags
01CE  01B9  	CLRF gbl_float_detect_tininess

01D5  118A  	BCF PCLATH,3
01D6  120A  	BCF PCLATH,4
01D7  2945  	GOTO	main

2007  3F3E  	DW 0x3F3E
