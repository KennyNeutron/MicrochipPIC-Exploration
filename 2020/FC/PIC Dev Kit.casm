;/////////////////////////////////////////////////////////////////////////////////
;// Code Generator: BoostC Compiler - http://www.sourceboost.com
;// Version       : 7.03
;// License Type  : Pro License
;// Limitations   : PIC12,PIC16 max code size:Unlimited, max RAM banks:Unlimited
;/////////////////////////////////////////////////////////////////////////////////

/*********************************************************************
 *                  Flowcode CAL Delays File
 *
 * File: PIC_CAL_Delay.c
 *
 * (c) 2011 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * “Company”) for its Flowcode graphical programming language is
 * intended and supplied to you, the Company’s customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 010911 | BR | Created
 *
 *
 *
 */

//Original Byte Delays
void Wdt_Delay_S(char delay);
void Wdt_Delay_Ms(char delay);

//New Int Delays
void FCI_DELAYINT_US(MX_UINT16 Delay);

void FCI_DELAYINT_MS(MX_UINT16 Delay);
void FCI_DELAYINTWDT_MS(MX_UINT16 Delay);

void FCI_DELAYINT_S(MX_UINT16 Delay);
void FCI_DELAYINTWDT_S(MX_UINT16 Delay);


#ifdef HI_TECH_C

	#define nop()	asm("NOP")

	void delay_10us(char del);
	void delay_us(char del);
	void delay_ms(char del);
	void delay_s(char del);

	void delay_10us(char del)
	{
		char count;
		for(count=0; count<10; count++)
		{
			delay_us(del);
		}
	}

	void delay_us(char del)
	{
		while (del > 1)
		{
			__delay_us(1);
			del = del - 1;
		}
	}

	void delay_ms(char del)
	{
		while (del > 1)
		{
			__delay_ms(1);
			del = del - 1;
		}
	}

	void delay_s(char del)
	{
		char i;
		for(i=0; i<del; i++)
		{
			delay_ms(250);
			delay_ms(250);
			delay_ms(250);
			delay_ms(250);
		}
	}

#endif

void Wdt_Delay_S(char delay)
{
    char i;
    short j;
    for (i=0; i<delay; i++)
    {
        for (j=0; j<999; j++)
        {
            Wdt_Delay_Ms(1);
        }
    }
}

void Wdt_Delay_Ms(char delay)

{
    char i;
    for (i=0; i<delay; i++)
007D  01D0  	CLRF Wdt_Delay__0003E_1_i
007E        label10
007E  084F  	MOVF Wdt_Delay__0003E_arg_delay, W
007F  0250  	SUBWF Wdt_Delay__0003E_1_i, W
0080  1803  	BTFSC STATUS,C
0086  0AD0  	INCF Wdt_Delay__0003E_1_i, F
0087  287E  	GOTO	label10

    {
        MX_CLEAR_WATCHDOG;        //Clear Watchdog Timer
0082  0064  	CLRWDT

        delay_ms(1);
0083  3001  	MOVLW 0x01
0084  00D1  	MOVWF delay_ms_00000_arg_del
0085  2010  	CALL delay_ms_00000

    }
}
0081  0008  	RETURN



void FCI_DELAYINT_US(MX_UINT16 Delay)
{
  	while (Delay > 255)
  	{
	  	delay_us(255);
	  	Delay = Delay - 255;
  	}
  	if (Delay > 0)
  		delay_us(Delay & 0xFF);
}

void FCI_DELAYINT_MS(MX_UINT16 Delay)
{
  	while (Delay > 255)
  	{
	  	delay_ms(255);
	  	Delay = Delay - 255;
  	}
  	if (Delay > 0)
  		delay_ms(Delay & 0xFF);
}

void FCI_DELAYINTWDT_MS(MX_UINT16 Delay)
{
  	while (Delay > 255)
  	{
	  	Wdt_Delay_Ms(255);
	  	Delay = Delay - 255;
  	}
  	if (Delay > 0)
  		Wdt_Delay_Ms(Delay & 0xFF);
}

void FCI_DELAYINT_S(MX_UINT16 Delay)
{
  	while (Delay > 255)
  	{
	  	delay_s(255);
	  	Delay = Delay - 255;
  	}
  	if (Delay > 0)
  		delay_s(Delay & 0xFF);
}

void FCI_DELAYINTWDT_S(MX_UINT16 Delay)
{
  	while (Delay > 255)
  	{
	  	Wdt_Delay_S(255);
	  	Delay = Delay - 255;
  	}
  	if (Delay > 0)
  		Wdt_Delay_S(Delay & 0xFF);
}



//************************************************************************************
//**  
//**  File name:     C:\Users\gerpe\OneDrive\GER-PER 2016\Documents\KennyNeutron\2020\FC\PIC Dev Kit.c
//**  Title:         
//**  Description:   
//**  
//**  Generated by:  Flowcode v5.2.0.0
//**  Date:          Thursday, July 16, 2020 20:05:56
//**  Licence:       Professional
//**  Registered to: xyz
//**  Licence key:   WUK7B9
//**  
//**  
//**  http://www.matrixmultimedia.com
//**  
//************************************************************************************


#define MX_PIC

#define MX_USES_UINT8 1
#define MX_USES_SINT16 0
#define MX_USES_CHAR 0
#define MX_USES_FLOAT 0
#define MX_USES_SINT32 0
#define MX_USES_BOOL 1
#define MX_USES_UINT16 0
#define MX_USES_UINT32 0
//Defines for microcontroller
#define P16F873A
#define FC_CAL_PIC
#define MX_ADC
#define MX_ADC_TYPE_1
#define MX_ADC_BITS_10
#define MX_EE
#define MX_EE_TYPE2
#define MX_EE_SIZE 128
#define MX_SPI_1
#define MX_SPI_1_MISO_PORT portc
#define MX_SPI_1_MISO_TRIS trisc
#define MX_SPI_1_MISO_PIN 4
#define MX_SPI_1_MOSI_PORT portc
#define MX_SPI_1_MOSI_TRIS trisc
#define MX_SPI_1_MOSI_PIN 5
#define MX_SPI_1_CLK_PORT portc
#define MX_SPI_1_CLK_TRIS trisc
#define MX_SPI_1_CLK_PIN 3
#define MX_SPI_1_SS_PORT portc
#define MX_SPI_1_SS_TRIS trisc
#define MX_UART_1
#define MX_UART_1_TX_PORT portc
#define MX_UART_1_TX_TRIS trisc
#define MX_UART_1_TX_PIN 6
#define MX_UART_1_RX_PORT portc
#define MX_UART_1_RX_TRIS trisc
#define MX_UART_1_RX_PIN 7
#define MX_I2C
#define MX_MI2C
#define MX_I2C_1
#define MX_I2C_1_SDA_PORT portc
#define MX_I2C_1_SDA_TRIS trisc
#define MX_I2C_1_SDA_PIN 4
#define MX_I2C_1_SCL_PORT portc
#define MX_I2C_1_SCL_TRIS trisc
#define MX_I2C_1_SCL_PIN 3
#define MX_PWM
#define MX_PWM_CNT 2
#define MX_PWM_PSCA1
#define MX_PWM_PSCA4
#define MX_PWM_PSCA16
#define MX_PWM_1_PORT portc
#define MX_PWM_1_TRIS trisc
#define MX_PWM_1_PIN 2
#define MX_PWM_2_PORT portc
#define MX_PWM_2_TRIS trisc
#define MX_PWM_2_PIN 1

//Functions
#define MX_CLK_SPEED 20000000
#ifdef _BOOSTC
#include <system.h>
#endif
#ifdef HI_TECH_C
#include <pic.h>
#endif

//Configuration data
#ifdef _BOOSTC
#pragma DATA 0x2007, 0x3f32
#endif
#ifdef HI_TECH_C
__CONFIG(0x3f32);
#endif

//Internal functions
#include "C:\Program Files (x86)\Flowcode\v5\FCD\internals.c"

//Macro function declarations
void FCM_display();


//Variable declarations
#define FCV_TRUE (1)
#define FCV_FALSE (0)
MX_UINT8 FCV_B_SW2 = (0x1);
051E  3001  	MOVLW 0x01
051F  00C4  	MOVWF gbl_FCV_B_SW2

MX_BOOL FCV_FLAG0 = (0);
0520  1045  	BCF gbl_FCV_FLAG0,0

MX_UINT8 FCV_ANALOG0 = (0xff);
0521  30FF  	MOVLW 0xFF
0522  00C6  	MOVWF gbl_FCV_ANALOG0

MX_UINT8 FCV_BRIGHTNESS = (0x0);
0523  01C7  	CLRF gbl_FCV_BRIGHTNESS

MX_BOOL FCV_B_SW0 = (1);
0524  14C5  	BSF gbl_FCV_B_SW0,1

MX_BOOL FCV_B_SW1 = (1);
0525  1545  	BSF gbl_FCV_B_SW1,2





//LCDDisplay(0): //Defines:

/**** Macro Substitutions ****
a = Unique Component Reference Number
b = D1 Port Letter
c = D2 Port Letter
d = D3 Port Letter
e = D4 Port Letter
f = RS Port Letter
g = E Port Letter
h = Data 1_Pin
i = Data 2 Pin
j = Data 3 Pin
k = Data 4 Pin
l = RS Pin
m = Enable Pin
n = Row Count
o = Column Count
******************************/

	//component connections
	#define LCD_1__PORT0    portb
	#define LCD_1__PORT1    portb
	#define LCD_1__PORT2    portb
	#define LCD_1__PORT3    portb
	#define LCD_1__PORT4    portb
	#define LCD_1__PORT5    portb
	#define LCD_1__TRIS0    trisb
	#define LCD_1__TRIS1    trisb
	#define LCD_1__TRIS2    trisb
	#define LCD_1__TRIS3    trisb
	#define LCD_1__TRIS4    trisb
	#define LCD_1__TRIS5    trisb
	#define LCD_1__BIT0    	2
	#define LCD_1__BIT1    	3
	#define LCD_1__BIT2    	4
	#define LCD_1__BIT3    	5
	#define LCD_1__RS      	0
	#define LCD_1__E       	1
	#define LCD_1__ROWCNT	4
	#define LCD_1__COLCNT	16

	#ifdef _BOOSTC
	  #define LCD_1__DELAY   delay_10us(10)
	#endif
	#ifdef _C2C_
	  #define LCD_1__DELAY   delay_us(100)
	#endif
	#ifdef HI_TECH_C
	  #define LCD_1__DELAY   __delay_us(120)
	#endif
	#ifndef LCD_1__DELAY
	  #define LCD_1__DELAY   delay_us(100)
	#endif




//LCDDisplay(0): //Macro function declarations

void FCD_LCDDisplay0_RawSend(MX_UINT8 in, MX_UINT8 mask);
void FCD_LCDDisplay0_Start();
void FCD_LCDDisplay0_Clear();
void FCD_LCDDisplay0_PrintASCII(MX_UINT8 Character);
void FCD_LCDDisplay0_Command(MX_UINT8 in);
void FCD_LCDDisplay0_Cursor(MX_UINT8 x, MX_UINT8 y);
void FCD_LCDDisplay0_PrintNumber(MX_SINT16 Number);
void FCD_LCDDisplay0_PrintString(MX_STRING String, MX_UINT8 MSZ_String);
void FCD_LCDDisplay0_ScrollDisplay(MX_UINT8 Direction, MX_UINT8 Num_Positions);
void FCD_LCDDisplay0_ClearLine(MX_UINT8 Line);
void FCD_LCDDisplay0_RAM_Write(MX_UINT8 nIdx, MX_UINT8 d0, MX_UINT8 d1, MX_UINT8 d2, MX_UINT8 d3, MX_UINT8 d4, MX_UINT8 d5, MX_UINT8 d6, MX_UINT8 d7);


//ADC(0): //Defines:

/**** Macro Substitutions ****
a = Unique Reference
b = Which ADC Channel
c = Acquisition time
d = Conversion Speed
e = VRef+ Option
f = VRef Voltage x 0.01V
******************************/

//Common Defines

#define ADC_7_MX_ADC_CHANNEL	0
#define ADC_7_MX_ADC_ACTIME	40
#define ADC_7_MX_ADC_CONVSP	3
#define ADC_7_MX_ADC_VREFOP	0
#define ADC_7_MX_ADC_VREFVOL	500

#ifndef MX_ADC_CHANNEL_0
 #define MX_ADC_CHANNEL_0			//Inform CAL ADC channel 0 is now in use.
#endif

#ifndef MX_ADC_REF					//Inform CAL ADC peripheral is now in use
 #define MX_ADC_REF
#endif

extern void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge);
extern MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode);
extern void FC_CAL_Disable_ADC (void);




//ADC(0): //Macro function declarations

void FCD_ADC0_SampleADC();
MX_UINT8 FCD_ADC0_ReadAsByte();
MX_UINT16 FCD_ADC0_ReadAsInt();
MX_FLOAT FCD_ADC0_ReadAsVoltage();
void FCD_ADC0_ReadAsString(MX_CHAR* FCR_RETVAL, MX_UINT8 FCR_RETVAL_SIZE);
void FCD_ADC0_ADC_RAW_Configure_Channel();
MX_UINT8 FCD_ADC0_ADC_RAW_Sample_Channel_Byte();
MX_UINT16 FCD_ADC0_ADC_RAW_Sample_Channel_Int();
MX_UINT8 FCD_ADC0_ADC_RAW_Average_Channel_Byte(MX_UINT8 NumSamples, MX_UINT8 DelayUs);
MX_UINT16 FCD_ADC0_ADC_RAW_Average_Channel_Int(MX_UINT8 NumSamples, MX_UINT8 DelayUs);
void FCD_ADC0_ADC_RAW_Disable_Channel();


//PWM(0): //Defines:

/**** Macro Substitutions ****
a = Unique Reference
b = PWM Channel - 0=SW / 1-8=HW
c = PWM Alt Pin FCD_PWM0_Enable - 0=Standard / 1=Alt
d = PWM Period
e = PWM Prescaler 1
******************************/

//Period and Prescaler Defines
#ifndef MX_PWM_PERIOD
  #define MX_PWM_PERIOD				255
#else
  #if (MX_PWM_PERIOD != 255)
    #error "PWM period value must be the same in all PWM modules"
  #endif
#endif

#ifndef MX_PWM_PRESCALE1
  #define MX_PWM_PRESCALE1			1
#else
  #if (MX_PWM_PRESCALE1 != 1)
    #error "PWM prescale value must be the same in all PWM modules"
  #endif
#endif

//Definitions for PWM slot allocation
#ifndef	MX_PWM_REF1
			#define MX_PWM_REF1
			#define PWM_8_MX_PWM_UREF			1
			#define MX_PWM_CHANNEL_1		2
			#define MX_PWM_HWALT_1			0
#else
 #ifndef	MX_PWM_REF2
			#define MX_PWM_REF2
			#define PWM_8_MX_PWM_UREF			2
			#define MX_PWM_CHANNEL_2		2
			#define MX_PWM_HWALT_2			0
 #else
  #ifndef	MX_PWM_REF3
			#define MX_PWM_REF3
			#define PWM_8_MX_PWM_UREF			3
			#define MX_PWM_CHANNEL_3		2
			#define MX_PWM_HWALT_3			0
  #else
   #ifndef	MX_PWM_REF4
			#define MX_PWM_REF4
			#define PWM_8_MX_PWM_UREF			4
			#define MX_PWM_CHANNEL_4		2
			#define MX_PWM_HWALT_4			0
   #else
    #ifndef	MX_PWM_REF5
			#define MX_PWM_REF5
			#define PWM_8_MX_PWM_UREF			5
			#define MX_PWM_CHANNEL_5		2
			#define MX_PWM_HWALT_5			0
    #else
     #ifndef	MX_PWM_REF6
			#define MX_PWM_REF6
			#define PWM_8_MX_PWM_UREF			6
			#define MX_PWM_CHANNEL_6		2
			#define MX_PWM_HWALT_6			0
     #else
      #ifndef	MX_PWM_REF7
			#define MX_PWM_REF7
			#define PWM_8_MX_PWM_UREF			7
			#define MX_PWM_CHANNEL_7		2
			#define MX_PWM_HWALT_7			0
      #else
       #ifndef	MX_PWM_REF8
			#define MX_PWM_REF8
			#define PWM_8_MX_PWM_UREF			8
			#define MX_PWM_CHANNEL_8		2
			#define MX_PWM_HWALT_8			0
       #else
        #ifndef	MX_PWM_REF9
			#define MX_PWM_REF9
			#define PWM_8_MX_PWM_UREF			9
			#define MX_PWM_CHANNEL_9		2
			#define MX_PWM_HWALT_9			0
        #else
         #ifndef	MX_PWM_REF10
			#define MX_PWM_REF10
			#define PWM_8_MX_PWM_UREF			10
			#define MX_PWM_CHANNEL_10		2
			#define MX_PWM_HWALT_10			0
         #endif
        #endif
       #endif
      #endif
     #endif
    #endif
   #endif
  #endif
 #endif
#endif

#define PWM_8_PWM_Enable_Channel		CAL_APPEND(FC_CAL_PWM_Enable_Channel_, PWM_8_MX_PWM_UREF)
#define PWM_8_PWM_Disable_Channel		CAL_APPEND(FC_CAL_PWM_Disable_Channel_, PWM_8_MX_PWM_UREF)
#define PWM_8_PWM_Set_Duty_8Bit		CAL_APPEND(FC_CAL_PWM_Set_Duty_8Bit_, PWM_8_MX_PWM_UREF)
#define PWM_8_PWM_Change_Period		CAL_APPEND(FC_CAL_PWM_Change_Period_, PWM_8_MX_PWM_UREF)
#define PWM_8_PWM_Set_Duty_10Bit		CAL_APPEND(FC_CAL_PWM_Set_Duty_10Bit_, PWM_8_MX_PWM_UREF)

extern void PWM_8_PWM_Enable_Channel ();
extern void PWM_8_PWM_Disable_Channel ();
extern void PWM_8_PWM_Set_Duty_8Bit (MX_UINT8 duty);
extern void PWM_8_PWM_Change_Period (MX_UINT8 period, MX_UINT16 prescaler);
extern void PWM_8_PWM_Set_Duty_10Bit (MX_UINT16 duty);




//PWM(0): //Macro function declarations

void FCD_PWM0_Enable();
void FCD_PWM0_Disable();
void FCD_PWM0_SetDutyCycle(MX_UINT8 nDuty);
void FCD_PWM0_ChangePeriod(MX_UINT8 nPeriodVal, MX_UINT8 nPrescalerVal);
void FCD_PWM0_SetDutyCycle10bit(MX_SINT16 nDuty);



//LCDDisplay(0): //Macro implementations


void FCD_LCDDisplay0_RawSend(MX_UINT8 in, MX_UINT8 mask)

{
	
		MX_UINT8 pt;

		FC_CAL_Bit_Low(LCD_1__PORT0, LCD_1__BIT0);
008B  1106  	BCF gbl_portb,2

		FC_CAL_Bit_Low(LCD_1__PORT1, LCD_1__BIT1);
008C  1186  	BCF gbl_portb,3

		FC_CAL_Bit_Low(LCD_1__PORT2, LCD_1__BIT2);
008D  1206  	BCF gbl_portb,4

		FC_CAL_Bit_Low(LCD_1__PORT3, LCD_1__BIT3);
008E  1286  	BCF gbl_portb,5

		FC_CAL_Bit_Low(LCD_1__PORT4, LCD_1__RS);
008F  1006  	BCF gbl_portb,0

		FC_CAL_Bit_Low(LCD_1__PORT5, LCD_1__E);
0090  1086  	BCF gbl_portb,1

		pt = ((in >> 4) & 0x0f);
0091  0E5D  	SWAPF FCD_LCDDis_00056_arg_in, W
0092  390F  	ANDLW 0x0F
0093  00DF  	MOVWF FCD_LCDDis_00056_1_pt
0094  300F  	MOVLW 0x0F
0095  05DF  	ANDWF FCD_LCDDis_00056_1_pt, F

		if (pt & 0x01)
0096  185F  	BTFSC FCD_LCDDis_00056_1_pt,0

		    FC_CAL_Bit_High(LCD_1__PORT0, LCD_1__BIT0);
0097  1506  	BSF gbl_portb,2

		if (pt & 0x02)
0098  18DF  	BTFSC FCD_LCDDis_00056_1_pt,1

		    FC_CAL_Bit_High(LCD_1__PORT1, LCD_1__BIT1);
0099  1586  	BSF gbl_portb,3

		if (pt & 0x04)
009A  195F  	BTFSC FCD_LCDDis_00056_1_pt,2

		    FC_CAL_Bit_High(LCD_1__PORT2, LCD_1__BIT2);
009B  1606  	BSF gbl_portb,4

		if (pt & 0x08)
009C  19DF  	BTFSC FCD_LCDDis_00056_1_pt,3

		    FC_CAL_Bit_High(LCD_1__PORT3, LCD_1__BIT3);
009D  1686  	BSF gbl_portb,5

		if (mask)
009E  08DE  	MOVF FCD_LCDDis_00056_arg_mask, F
009F  1D03  	BTFSS STATUS,Z

		    FC_CAL_Bit_High(LCD_1__PORT4, LCD_1__RS);
00A0  1406  	BSF gbl_portb,0

		LCD_1__DELAY;
00A1  300A  	MOVLW 0x0A
00A2  00E0  	MOVWF delay_10us_00000_arg_del
00A3  203C  	CALL delay_10us_00000

		FC_CAL_Bit_High (LCD_1__PORT5, LCD_1__E);
00A4  1486  	BSF gbl_portb,1

		LCD_1__DELAY;
00A5  300A  	MOVLW 0x0A
00A6  00E0  	MOVWF delay_10us_00000_arg_del
00A7  203C  	CALL delay_10us_00000

		FC_CAL_Bit_Low (LCD_1__PORT5, LCD_1__E);
00A8  1086  	BCF gbl_portb,1

		pt = (in & 0x0f);
00A9  300F  	MOVLW 0x0F
00AA  055D  	ANDWF FCD_LCDDis_00056_arg_in, W
00AB  00DF  	MOVWF FCD_LCDDis_00056_1_pt

		LCD_1__DELAY;
00AC  300A  	MOVLW 0x0A
00AD  00E0  	MOVWF delay_10us_00000_arg_del
00AE  203C  	CALL delay_10us_00000

		FC_CAL_Bit_Low(LCD_1__PORT0, LCD_1__BIT0);
00AF  1106  	BCF gbl_portb,2

		FC_CAL_Bit_Low(LCD_1__PORT1, LCD_1__BIT1);
00B0  1186  	BCF gbl_portb,3

		FC_CAL_Bit_Low(LCD_1__PORT2, LCD_1__BIT2);
00B1  1206  	BCF gbl_portb,4

		FC_CAL_Bit_Low(LCD_1__PORT3, LCD_1__BIT3);
00B2  1286  	BCF gbl_portb,5

		FC_CAL_Bit_Low(LCD_1__PORT4, LCD_1__RS);
00B3  1006  	BCF gbl_portb,0

		FC_CAL_Bit_Low(LCD_1__PORT5, LCD_1__E);
00B4  1086  	BCF gbl_portb,1

		if (pt & 0x01)
00B5  185F  	BTFSC FCD_LCDDis_00056_1_pt,0

		    FC_CAL_Bit_High(LCD_1__PORT0, LCD_1__BIT0);
00B6  1506  	BSF gbl_portb,2

		if (pt & 0x02)
00B7  18DF  	BTFSC FCD_LCDDis_00056_1_pt,1

		    FC_CAL_Bit_High(LCD_1__PORT1, LCD_1__BIT1);
00B8  1586  	BSF gbl_portb,3

		if (pt & 0x04)
00B9  195F  	BTFSC FCD_LCDDis_00056_1_pt,2

		    FC_CAL_Bit_High(LCD_1__PORT2, LCD_1__BIT2);
00BA  1606  	BSF gbl_portb,4

		if (pt & 0x08)
00BB  19DF  	BTFSC FCD_LCDDis_00056_1_pt,3

		    FC_CAL_Bit_High(LCD_1__PORT3, LCD_1__BIT3);
00BC  1686  	BSF gbl_portb,5

		if (mask)
00BD  08DE  	MOVF FCD_LCDDis_00056_arg_mask, F
00BE  1D03  	BTFSS STATUS,Z

		    FC_CAL_Bit_High(LCD_1__PORT4, LCD_1__RS);
00BF  1406  	BSF gbl_portb,0

		LCD_1__DELAY;
00C0  300A  	MOVLW 0x0A
00C1  00E0  	MOVWF delay_10us_00000_arg_del
00C2  203C  	CALL delay_10us_00000

		FC_CAL_Bit_High (LCD_1__PORT5, LCD_1__E);
00C3  1486  	BSF gbl_portb,1

		LCD_1__DELAY;
00C4  300A  	MOVLW 0x0A
00C5  00E0  	MOVWF delay_10us_00000_arg_del
00C6  203C  	CALL delay_10us_00000

		FC_CAL_Bit_Low (LCD_1__PORT5, LCD_1__E);
00C7  1086  	BCF gbl_portb,1

		LCD_1__DELAY;
00C8  300A  	MOVLW 0x0A
00C9  00E0  	MOVWF delay_10us_00000_arg_del
00CA  203C  	CALL delay_10us_00000


}
00CB  0008  	RETURN


void FCD_LCDDisplay0_Start()

{
	
		FC_CAL_Bit_Low_DDR(LCD_1__PORT0, LCD_1__TRIS0, LCD_1__BIT0);
03A0  1683  	BSF STATUS, RP0
03A1  1303  	BCF STATUS, RP1
03A2  1106  	BCF gbl_trisb,2
03A3  1283  	BCF STATUS, RP0
03A4  1106  	BCF gbl_portb,2

		FC_CAL_Bit_Low_DDR(LCD_1__PORT1, LCD_1__TRIS1, LCD_1__BIT1);
03A5  1683  	BSF STATUS, RP0
03A6  1186  	BCF gbl_trisb,3
03A7  1283  	BCF STATUS, RP0
03A8  1186  	BCF gbl_portb,3

		FC_CAL_Bit_Low_DDR(LCD_1__PORT2, LCD_1__TRIS2, LCD_1__BIT2);
03A9  1683  	BSF STATUS, RP0
03AA  1206  	BCF gbl_trisb,4
03AB  1283  	BCF STATUS, RP0
03AC  1206  	BCF gbl_portb,4

		FC_CAL_Bit_Low_DDR(LCD_1__PORT3, LCD_1__TRIS3, LCD_1__BIT3);
03AD  1683  	BSF STATUS, RP0
03AE  1286  	BCF gbl_trisb,5
03AF  1283  	BCF STATUS, RP0
03B0  1286  	BCF gbl_portb,5

		FC_CAL_Bit_Low_DDR(LCD_1__PORT4, LCD_1__TRIS4, LCD_1__RS);
03B1  1683  	BSF STATUS, RP0
03B2  1006  	BCF gbl_trisb,0
03B3  1283  	BCF STATUS, RP0
03B4  1006  	BCF gbl_portb,0

		FC_CAL_Bit_Low_DDR(LCD_1__PORT5, LCD_1__TRIS5, LCD_1__E);
03B5  1683  	BSF STATUS, RP0
03B6  1086  	BCF gbl_trisb,1
03B7  1283  	BCF STATUS, RP0
03B8  1086  	BCF gbl_portb,1


		Wdt_Delay_Ms(12);
03B9  300C  	MOVLW 0x0C
03BA  00CF  	MOVWF Wdt_Delay__0003E_arg_delay
03BB  207D  	CALL Wdt_Delay__0003E


		FCD_LCDDisplay0_RawSend(0x33, 0);
03BC  3033  	MOVLW 0x33
03BD  00DD  	MOVWF FCD_LCDDis_00056_arg_in
03BE  01DE  	CLRF FCD_LCDDis_00056_arg_mask
03BF  208B  	CALL FCD_LCDDis_00056

		Wdt_Delay_Ms(2);
03C0  3002  	MOVLW 0x02
03C1  00CF  	MOVWF Wdt_Delay__0003E_arg_delay
03C2  207D  	CALL Wdt_Delay__0003E

		FCD_LCDDisplay0_RawSend(0x33, 0);
03C3  3033  	MOVLW 0x33
03C4  00DD  	MOVWF FCD_LCDDis_00056_arg_in
03C5  01DE  	CLRF FCD_LCDDis_00056_arg_mask
03C6  208B  	CALL FCD_LCDDis_00056

		Wdt_Delay_Ms(2);
03C7  3002  	MOVLW 0x02
03C8  00CF  	MOVWF Wdt_Delay__0003E_arg_delay
03C9  207D  	CALL Wdt_Delay__0003E

		FCD_LCDDisplay0_RawSend(0x32, 0);
03CA  3032  	MOVLW 0x32
03CB  00DD  	MOVWF FCD_LCDDis_00056_arg_in
03CC  01DE  	CLRF FCD_LCDDis_00056_arg_mask
03CD  208B  	CALL FCD_LCDDis_00056

		Wdt_Delay_Ms(2);
03CE  3002  	MOVLW 0x02
03CF  00CF  	MOVWF Wdt_Delay__0003E_arg_delay
03D0  207D  	CALL Wdt_Delay__0003E

		FCD_LCDDisplay0_RawSend(0x2c, 0);
03D1  302C  	MOVLW 0x2C
03D2  00DD  	MOVWF FCD_LCDDis_00056_arg_in
03D3  01DE  	CLRF FCD_LCDDis_00056_arg_mask
03D4  208B  	CALL FCD_LCDDis_00056

		Wdt_Delay_Ms(2);
03D5  3002  	MOVLW 0x02
03D6  00CF  	MOVWF Wdt_Delay__0003E_arg_delay
03D7  207D  	CALL Wdt_Delay__0003E

		FCD_LCDDisplay0_RawSend(0x06, 0);
03D8  3006  	MOVLW 0x06
03D9  00DD  	MOVWF FCD_LCDDis_00056_arg_in
03DA  01DE  	CLRF FCD_LCDDis_00056_arg_mask
03DB  208B  	CALL FCD_LCDDis_00056

		Wdt_Delay_Ms(2);
03DC  3002  	MOVLW 0x02
03DD  00CF  	MOVWF Wdt_Delay__0003E_arg_delay
03DE  207D  	CALL Wdt_Delay__0003E

		FCD_LCDDisplay0_RawSend(0x0c, 0);
03DF  300C  	MOVLW 0x0C
03E0  00DD  	MOVWF FCD_LCDDis_00056_arg_in
03E1  01DE  	CLRF FCD_LCDDis_00056_arg_mask
03E2  208B  	CALL FCD_LCDDis_00056

		Wdt_Delay_Ms(2);
03E3  3002  	MOVLW 0x02
03E4  00CF  	MOVWF Wdt_Delay__0003E_arg_delay
03E5  207D  	CALL Wdt_Delay__0003E


		//clear the display
		FCD_LCDDisplay0_RawSend(0x01, 0);
03E6  3001  	MOVLW 0x01
03E7  00DD  	MOVWF FCD_LCDDis_00056_arg_in
03E8  01DE  	CLRF FCD_LCDDis_00056_arg_mask
03E9  208B  	CALL FCD_LCDDis_00056

		Wdt_Delay_Ms(2);
03EA  3002  	MOVLW 0x02
03EB  00CF  	MOVWF Wdt_Delay__0003E_arg_delay
03EC  207D  	CALL Wdt_Delay__0003E

		FCD_LCDDisplay0_RawSend(0x02, 0);
03ED  3002  	MOVLW 0x02
03EE  00DD  	MOVWF FCD_LCDDis_00056_arg_in
03EF  01DE  	CLRF FCD_LCDDis_00056_arg_mask
03F0  208B  	CALL FCD_LCDDis_00056

		Wdt_Delay_Ms(2);
03F1  3002  	MOVLW 0x02
03F2  00CF  	MOVWF Wdt_Delay__0003E_arg_delay
03F3  207D  	CALL Wdt_Delay__0003E


}
03F4  0008  	RETURN


void FCD_LCDDisplay0_Clear()

{
	
		FCD_LCDDisplay0_RawSend(0x01, 0);
038F  3001  	MOVLW 0x01
0390  1283  	BCF STATUS, RP0
0391  1303  	BCF STATUS, RP1
0392  00DD  	MOVWF FCD_LCDDis_00056_arg_in
0393  01DE  	CLRF FCD_LCDDis_00056_arg_mask
0394  208B  	CALL FCD_LCDDis_00056

		Wdt_Delay_Ms(2);
0395  3002  	MOVLW 0x02
0396  00CF  	MOVWF Wdt_Delay__0003E_arg_delay
0397  207D  	CALL Wdt_Delay__0003E

		FCD_LCDDisplay0_RawSend(0x02, 0);
0398  3002  	MOVLW 0x02
0399  00DD  	MOVWF FCD_LCDDis_00056_arg_in
039A  01DE  	CLRF FCD_LCDDis_00056_arg_mask
039B  208B  	CALL FCD_LCDDis_00056

		Wdt_Delay_Ms(2);
039C  3002  	MOVLW 0x02
039D  00CF  	MOVWF Wdt_Delay__0003E_arg_delay
039E  207D  	CALL Wdt_Delay__0003E


}
039F  0008  	RETURN


void FCD_LCDDisplay0_PrintASCII(MX_UINT8 Character)
{
	
		FCD_LCDDisplay0_RawSend(Character, 0x10);

}

void FCD_LCDDisplay0_Command(MX_UINT8 in)
{
	
		FCD_LCDDisplay0_RawSend(in, 0);
		Wdt_Delay_Ms(2);

}

void FCD_LCDDisplay0_Cursor(MX_UINT8 x, MX_UINT8 y)

{
	
	  #if (LCD_1__ROWCNT == 1)
	    y=0x80;
	  #endif

	  #if (LCD_1__ROWCNT == 2)
		if (y==0)
			y=0x80;
		else
			y=0xc0;
	  #endif

	  #if (LCD_1__ROWCNT == 4)
		if (y==0)
027C  08CE  	MOVF FCD_LCDDis_00052_arg_y, F
027D  1D03  	BTFSS STATUS,Z
027E  2A82  	GOTO	label42
0282        label42

			y=0x80;
027F  3080  	MOVLW 0x80
0280  00CE  	MOVWF FCD_LCDDis_00052_arg_y

		else if (y==1)
0281  2A91  	GOTO	label45
0282  034E  	DECF FCD_LCDDis_00052_arg_y, W
0283  1D03  	BTFSS STATUS,Z
0284  2A88  	GOTO	label43
0288        label43

			y=0xc0;
0285  30C0  	MOVLW 0xC0
0286  00CE  	MOVWF FCD_LCDDis_00052_arg_y


		#if (LCD_1__COLCNT == 16)
			else if (y==2)
0287  2A91  	GOTO	label45
0288  084E  	MOVF FCD_LCDDis_00052_arg_y, W
0289  3A02  	XORLW 0x02
028A  1D03  	BTFSS STATUS,Z
028B  2A8F  	GOTO	label44
028F        label44

				y=0x90;
028C  3090  	MOVLW 0x90
028D  00CE  	MOVWF FCD_LCDDis_00052_arg_y

			else
028E  2A91  	GOTO	label45
0291        label45

				y=0xd0;
028F  30D0  	MOVLW 0xD0
0290  00CE  	MOVWF FCD_LCDDis_00052_arg_y

		#endif

		#if (LCD_1__COLCNT == 20)
			else if (y==2)
				y=0x94;
			else
				y=0xd4;
		#endif
	  #endif

		FCD_LCDDisplay0_RawSend(y+x, 0);
0291  084D  	MOVF FCD_LCDDis_00052_arg_x, W
0292  074E  	ADDWF FCD_LCDDis_00052_arg_y, W
0293  00DD  	MOVWF FCD_LCDDis_00056_arg_in
0294  01DE  	CLRF FCD_LCDDis_00056_arg_mask
0295  208B  	CALL FCD_LCDDis_00056

		Wdt_Delay_Ms(2);
0296  3002  	MOVLW 0x02
0297  00CF  	MOVWF Wdt_Delay__0003E_arg_delay
0298  207D  	CALL Wdt_Delay__0003E


}
0299  0008  	RETURN


void FCD_LCDDisplay0_PrintNumber(MX_SINT16 Number)

{
	
		MX_SINT16 tmp_int;
		MX_UINT8 tmp_byte;

		if (Number < 0)
0172  1FCD  	BTFSS FCD_LCDDis_00054_arg_Number+D'1',7
0173  2981  	GOTO	label20
0181        label20

		{
			FCD_LCDDisplay0_RawSend('-', 0x10);
0174  302D  	MOVLW 0x2D
0175  00DD  	MOVWF FCD_LCDDis_00056_arg_in
0176  3010  	MOVLW 0x10
0177  00DE  	MOVWF FCD_LCDDis_00056_arg_mask
0178  208B  	CALL FCD_LCDDis_00056

			Number = 0 - Number;
0179  084C  	MOVF FCD_LCDDis_00054_arg_Number, W
017A  3C00  	SUBLW 0x00
017B  00D1  	MOVWF CompTempVar2206
017C  09CD  	COMF FCD_LCDDis_00054_arg_Number+D'1', F
017D  1803  	BTFSC STATUS,C
017E  0ACD  	INCF FCD_LCDDis_00054_arg_Number+D'1', F
017F  0851  	MOVF CompTempVar2206, W
0180  00CC  	MOVWF FCD_LCDDis_00054_arg_Number

		}

		tmp_int = Number;
0181  084C  	MOVF FCD_LCDDis_00054_arg_Number, W
0182  00CE  	MOVWF FCD_LCDDis_00054_1_tmp_int
0183  084D  	MOVF FCD_LCDDis_00054_arg_Number+D'1', W
0184  00CF  	MOVWF FCD_LCDDis_00054_1_tmp_int+D'1'

		if (Number >= 10000)
0185  3027  	MOVLW 0x27
0186  024D  	SUBWF FCD_LCDDis_00054_arg_Number+D'1', W
0187  1D03  	BTFSS STATUS,Z
0188  298B  	GOTO	label21
0189  3010  	MOVLW 0x10
018A  024C  	SUBWF FCD_LCDDis_00054_arg_Number, W
018B        label21
018B  1C03  	BTFSS STATUS,C
018C  29B9  	GOTO	label25
018D  1BCD  	BTFSC FCD_LCDDis_00054_arg_Number+D'1',7
018E  29B9  	GOTO	label25

		{
			tmp_byte = tmp_int / 10000;
018F  01D5  	CLRF CompTempVar2209
0190  084E  	MOVF FCD_LCDDis_00054_1_tmp_int, W
0191  00D1  	MOVWF __div_16_1_00003_arg_a
0192  084F  	MOVF FCD_LCDDis_00054_1_tmp_int+D'1', W
0193  00D2  	MOVWF __div_16_1_00003_arg_a+D'1'
0194  1FCF  	BTFSS FCD_LCDDis_00054_1_tmp_int+D'1',7
0195  299C  	GOTO	label22
0196  09D1  	COMF __div_16_1_00003_arg_a, F
0197  09D2  	COMF __div_16_1_00003_arg_a+D'1', F
0198  0AD1  	INCF __div_16_1_00003_arg_a, F
0199  1903  	BTFSC STATUS,Z
019A  0AD2  	INCF __div_16_1_00003_arg_a+D'1', F
019B  0AD5  	INCF CompTempVar2209, F
019C        label22
019C  3010  	MOVLW 0x10
019D  00D3  	MOVWF __div_16_1_00003_arg_b
019E  3027  	MOVLW 0x27
019F  00D4  	MOVWF __div_16_1_00003_arg_b+D'1'
01A0  205E  	CALL __div_16_1_00003
01A1  085A  	MOVF CompTempVarRet214, W
01A2  00D0  	MOVWF FCD_LCDDis_00054_1_tmp_byte
01A3  1C55  	BTFSS CompTempVar2209,0
01A4  29A7  	GOTO	label23
01A5  09D0  	COMF FCD_LCDDis_00054_1_tmp_byte, F
01A6  0AD0  	INCF FCD_LCDDis_00054_1_tmp_byte, F
01A7        label23

			FCD_LCDDisplay0_RawSend('0' + tmp_byte, 0x10);
01A7  0850  	MOVF FCD_LCDDis_00054_1_tmp_byte, W
01A8  3E30  	ADDLW 0x30
01A9  00DD  	MOVWF FCD_LCDDis_00056_arg_in
01AA  3010  	MOVLW 0x10
01AB  00DE  	MOVWF FCD_LCDDis_00056_arg_mask
01AC  208B  	CALL FCD_LCDDis_00056


			while (tmp_byte > 0)
01AD        label24
01AD  0850  	MOVF FCD_LCDDis_00054_1_tmp_byte, W
01AE  3C00  	SUBLW 0x00
01AF  1803  	BTFSC STATUS,C
01B0  29B9  	GOTO	label25
01B8  29AD  	GOTO	label24
01B9        label25

			{
				tmp_int = tmp_int - 10000;
01B1  3010  	MOVLW 0x10
01B2  02CE  	SUBWF FCD_LCDDis_00054_1_tmp_int, F
01B3  3027  	MOVLW 0x27
01B4  1C03  	BTFSS STATUS,C
01B5  3028  	MOVLW 0x28
01B6  02CF  	SUBWF FCD_LCDDis_00054_1_tmp_int+D'1', F

				tmp_byte--;
01B7  03D0  	DECF FCD_LCDDis_00054_1_tmp_byte, F

			}
		}
		if (Number >= 1000)
01B9  3003  	MOVLW 0x03
01BA  024D  	SUBWF FCD_LCDDis_00054_arg_Number+D'1', W
01BB  1D03  	BTFSS STATUS,Z
01BC  29BF  	GOTO	label26
01BD  30E8  	MOVLW 0xE8
01BE  024C  	SUBWF FCD_LCDDis_00054_arg_Number, W
01BF        label26
01BF  1C03  	BTFSS STATUS,C
01C0  29EF  	GOTO	label30
01C1  1BCD  	BTFSC FCD_LCDDis_00054_arg_Number+D'1',7
01C2  29EF  	GOTO	label30

		{
			tmp_byte = tmp_int / 1000;
01C3  01D6  	CLRF CompTempVar2213
01C4  084E  	MOVF FCD_LCDDis_00054_1_tmp_int, W
01C5  00D1  	MOVWF __div_16_1_00003_arg_a
01C6  084F  	MOVF FCD_LCDDis_00054_1_tmp_int+D'1', W
01C7  00D2  	MOVWF __div_16_1_00003_arg_a+D'1'
01C8  1FCF  	BTFSS FCD_LCDDis_00054_1_tmp_int+D'1',7
01C9  29D0  	GOTO	label27
01CA  09D1  	COMF __div_16_1_00003_arg_a, F
01CB  09D2  	COMF __div_16_1_00003_arg_a+D'1', F
01CC  0AD1  	INCF __div_16_1_00003_arg_a, F
01CD  1903  	BTFSC STATUS,Z
01CE  0AD2  	INCF __div_16_1_00003_arg_a+D'1', F
01CF  0AD6  	INCF CompTempVar2213, F
01D0        label27
01D0  30E8  	MOVLW 0xE8
01D1  00D3  	MOVWF __div_16_1_00003_arg_b
01D2  3003  	MOVLW 0x03
01D3  00D4  	MOVWF __div_16_1_00003_arg_b+D'1'
01D4  205E  	CALL __div_16_1_00003
01D5  085A  	MOVF CompTempVarRet214, W
01D6  00D5  	MOVWF CompTempVar2212
01D7  1C56  	BTFSS CompTempVar2213,0
01D8  29DB  	GOTO	label28
01D9  09D5  	COMF CompTempVar2212, F
01DA  0AD5  	INCF CompTempVar2212, F
01DB        label28
01DB  0855  	MOVF CompTempVar2212, W
01DC  00D0  	MOVWF FCD_LCDDis_00054_1_tmp_byte

			FCD_LCDDisplay0_RawSend('0' + tmp_byte, 0x10);
01DD  0850  	MOVF FCD_LCDDis_00054_1_tmp_byte, W
01DE  3E30  	ADDLW 0x30
01DF  00DD  	MOVWF FCD_LCDDis_00056_arg_in
01E0  3010  	MOVLW 0x10
01E1  00DE  	MOVWF FCD_LCDDis_00056_arg_mask
01E2  208B  	CALL FCD_LCDDis_00056


			while (tmp_byte > 0)
01E3        label29
01E3  0850  	MOVF FCD_LCDDis_00054_1_tmp_byte, W
01E4  3C00  	SUBLW 0x00
01E5  1803  	BTFSC STATUS,C
01E6  29EF  	GOTO	label30
01EE  29E3  	GOTO	label29
01EF        label30

			{
				tmp_int = tmp_int - 1000;
01E7  30E8  	MOVLW 0xE8
01E8  02CE  	SUBWF FCD_LCDDis_00054_1_tmp_int, F
01E9  3003  	MOVLW 0x03
01EA  1C03  	BTFSS STATUS,C
01EB  3004  	MOVLW 0x04
01EC  02CF  	SUBWF FCD_LCDDis_00054_1_tmp_int+D'1', F

				tmp_byte--;
01ED  03D0  	DECF FCD_LCDDis_00054_1_tmp_byte, F

			}
		}
		if (Number >= 100)
01EF  084D  	MOVF FCD_LCDDis_00054_arg_Number+D'1', W
01F0  3A80  	XORLW 0x80
01F1  00D1  	MOVWF CompTempVar2216
01F2  3080  	MOVLW 0x80
01F3  0251  	SUBWF CompTempVar2216, W
01F4  1D03  	BTFSS STATUS,Z
01F5  29F8  	GOTO	label31
01F6  3064  	MOVLW 0x64
01F7  024C  	SUBWF FCD_LCDDis_00054_arg_Number, W
01F8        label31
01F8  1C03  	BTFSS STATUS,C
01F9  2A24  	GOTO	label35

		{
			tmp_byte = tmp_int / 100;
01FA  01D6  	CLRF CompTempVar2218
01FB  084E  	MOVF FCD_LCDDis_00054_1_tmp_int, W
01FC  00D1  	MOVWF __div_16_1_00003_arg_a
01FD  084F  	MOVF FCD_LCDDis_00054_1_tmp_int+D'1', W
01FE  00D2  	MOVWF __div_16_1_00003_arg_a+D'1'
01FF  1FCF  	BTFSS FCD_LCDDis_00054_1_tmp_int+D'1',7
0200  2A07  	GOTO	label32
0201  09D1  	COMF __div_16_1_00003_arg_a, F
0202  09D2  	COMF __div_16_1_00003_arg_a+D'1', F
0203  0AD1  	INCF __div_16_1_00003_arg_a, F
0204  1903  	BTFSC STATUS,Z
0205  0AD2  	INCF __div_16_1_00003_arg_a+D'1', F
0206  0AD6  	INCF CompTempVar2218, F
0207        label32
0207  3064  	MOVLW 0x64
0208  00D3  	MOVWF __div_16_1_00003_arg_b
0209  01D4  	CLRF __div_16_1_00003_arg_b+D'1'
020A  205E  	CALL __div_16_1_00003
020B  085A  	MOVF CompTempVarRet214, W
020C  00D5  	MOVWF CompTempVar2217
020D  1C56  	BTFSS CompTempVar2218,0
020E  2A11  	GOTO	label33
020F  09D5  	COMF CompTempVar2217, F
0210  0AD5  	INCF CompTempVar2217, F
0211        label33
0211  0855  	MOVF CompTempVar2217, W
0212  00D0  	MOVWF FCD_LCDDis_00054_1_tmp_byte

			FCD_LCDDisplay0_RawSend('0' + tmp_byte, 0x10);
0213  0850  	MOVF FCD_LCDDis_00054_1_tmp_byte, W
0214  3E30  	ADDLW 0x30
0215  00DD  	MOVWF FCD_LCDDis_00056_arg_in
0216  3010  	MOVLW 0x10
0217  00DE  	MOVWF FCD_LCDDis_00056_arg_mask
0218  208B  	CALL FCD_LCDDis_00056


			while (tmp_byte > 0)
0219        label34
0219  0850  	MOVF FCD_LCDDis_00054_1_tmp_byte, W
021A  3C00  	SUBLW 0x00
021B  1803  	BTFSC STATUS,C
021C  2A24  	GOTO	label35
0223  2A19  	GOTO	label34
0224        label35

			{
				tmp_int = tmp_int - 100;
021D  3064  	MOVLW 0x64
021E  02CE  	SUBWF FCD_LCDDis_00054_1_tmp_int, F
021F  08CF  	MOVF FCD_LCDDis_00054_1_tmp_int+D'1', F
0220  1C03  	BTFSS STATUS,C
0221  03CF  	DECF FCD_LCDDis_00054_1_tmp_int+D'1', F

				tmp_byte--;
0222  03D0  	DECF FCD_LCDDis_00054_1_tmp_byte, F

			}
		}
		if (Number >= 10)
0224  084D  	MOVF FCD_LCDDis_00054_arg_Number+D'1', W
0225  3A80  	XORLW 0x80
0226  00D1  	MOVWF CompTempVar2221
0227  3080  	MOVLW 0x80
0228  0251  	SUBWF CompTempVar2221, W
0229  1D03  	BTFSS STATUS,Z
022A  2A2D  	GOTO	label36
022B  300A  	MOVLW 0x0A
022C  024C  	SUBWF FCD_LCDDis_00054_arg_Number, W
022D        label36
022D  1C03  	BTFSS STATUS,C
022E  2A59  	GOTO	label40

		{
			tmp_byte = tmp_int / 10;
022F  01D6  	CLRF CompTempVar2223
0230  084E  	MOVF FCD_LCDDis_00054_1_tmp_int, W
0231  00D1  	MOVWF __div_16_1_00003_arg_a
0232  084F  	MOVF FCD_LCDDis_00054_1_tmp_int+D'1', W
0233  00D2  	MOVWF __div_16_1_00003_arg_a+D'1'
0234  1FCF  	BTFSS FCD_LCDDis_00054_1_tmp_int+D'1',7
0235  2A3C  	GOTO	label37
0236  09D1  	COMF __div_16_1_00003_arg_a, F
0237  09D2  	COMF __div_16_1_00003_arg_a+D'1', F
0238  0AD1  	INCF __div_16_1_00003_arg_a, F
0239  1903  	BTFSC STATUS,Z
023A  0AD2  	INCF __div_16_1_00003_arg_a+D'1', F
023B  0AD6  	INCF CompTempVar2223, F
023C        label37
023C  300A  	MOVLW 0x0A
023D  00D3  	MOVWF __div_16_1_00003_arg_b
023E  01D4  	CLRF __div_16_1_00003_arg_b+D'1'
023F  205E  	CALL __div_16_1_00003
0240  085A  	MOVF CompTempVarRet214, W
0241  00D5  	MOVWF CompTempVar2222
0242  1C56  	BTFSS CompTempVar2223,0
0243  2A46  	GOTO	label38
0244  09D5  	COMF CompTempVar2222, F
0245  0AD5  	INCF CompTempVar2222, F
0246        label38
0246  0855  	MOVF CompTempVar2222, W
0247  00D0  	MOVWF FCD_LCDDis_00054_1_tmp_byte

			FCD_LCDDisplay0_RawSend('0' + tmp_byte, 0x10);
0248  0850  	MOVF FCD_LCDDis_00054_1_tmp_byte, W
0249  3E30  	ADDLW 0x30
024A  00DD  	MOVWF FCD_LCDDis_00056_arg_in
024B  3010  	MOVLW 0x10
024C  00DE  	MOVWF FCD_LCDDis_00056_arg_mask
024D  208B  	CALL FCD_LCDDis_00056


			while (tmp_byte > 0)
024E        label39
024E  0850  	MOVF FCD_LCDDis_00054_1_tmp_byte, W
024F  3C00  	SUBLW 0x00
0250  1803  	BTFSC STATUS,C
0251  2A59  	GOTO	label40
0258  2A4E  	GOTO	label39
0259        label40

			{
				tmp_int = tmp_int - 10;
0252  300A  	MOVLW 0x0A
0253  02CE  	SUBWF FCD_LCDDis_00054_1_tmp_int, F
0254  08CF  	MOVF FCD_LCDDis_00054_1_tmp_int+D'1', F
0255  1C03  	BTFSS STATUS,C
0256  03CF  	DECF FCD_LCDDis_00054_1_tmp_int+D'1', F

				tmp_byte--;
0257  03D0  	DECF FCD_LCDDis_00054_1_tmp_byte, F

			}
		}
		FCD_LCDDisplay0_RawSend('0' + tmp_int, 0x10);
0259  084E  	MOVF FCD_LCDDis_00054_1_tmp_int, W
025A  3E30  	ADDLW 0x30
025B  00DD  	MOVWF FCD_LCDDis_00056_arg_in
025C  3010  	MOVLW 0x10
025D  00DE  	MOVWF FCD_LCDDis_00056_arg_mask
025E  208B  	CALL FCD_LCDDis_00056


}
025F  0008  	RETURN


void FCD_LCDDisplay0_PrintString(MX_STRING String, MX_UINT8 MSZ_String)

{
	
		MX_UINT8 idx = 0;
0260  01DC  	CLRF FCD_LCDDis_00053_1_idx


		for (idx=0; idx<MSZ_String; idx++)
0261  01DC  	CLRF FCD_LCDDis_00053_1_idx
0262        label41
0262  085B  	MOVF FCD_LCDDis_00053_arg_MSZ_String, W
0263  025C  	SUBWF FCD_LCDDis_00053_1_idx, W
0264  1803  	BTFSC STATUS,C
027A  0ADC  	INCF FCD_LCDDis_00053_1_idx, F
027B  2A62  	GOTO	label41

		{
			if (String[idx] == 0)
0266  1383  	BCF STATUS,IRP
0267  184D  	BTFSC FCD_LCDDis_00053_arg_String+D'1',0
0268  1783  	BSF STATUS,IRP
0269  084C  	MOVF FCD_LCDDis_00053_arg_String, W
026A  075C  	ADDWF FCD_LCDDis_00053_1_idx, W
026B  0084  	MOVWF FSR
026C  0880  	MOVF INDF, F
026D  1903  	BTFSC STATUS,Z

			{
				break;

			}
			FCD_LCDDisplay0_RawSend(String[idx], 0x10);
026F  1383  	BCF STATUS,IRP
0270  184D  	BTFSC FCD_LCDDis_00053_arg_String+D'1',0
0271  1783  	BSF STATUS,IRP
0272  084C  	MOVF FCD_LCDDis_00053_arg_String, W
0273  075C  	ADDWF FCD_LCDDis_00053_1_idx, W
0274  0084  	MOVWF FSR
0275  0800  	MOVF INDF, W
0276  00DD  	MOVWF FCD_LCDDis_00056_arg_in
0277  3010  	MOVLW 0x10
0278  00DE  	MOVWF FCD_LCDDis_00056_arg_mask
0279  208B  	CALL FCD_LCDDis_00056

		}

}
0265  0008  	RETURN
026E  0008  	RETURN


void FCD_LCDDisplay0_ScrollDisplay(MX_UINT8 Direction, MX_UINT8 Num_Positions)
{
	
		MX_UINT8 cmd = 0;
		MX_UINT8 count;

		//Choose the direction
		switch (Direction)
		{
			case 0:
			case 'l':
			case 'L':

				cmd = 0x18;
				break;

			case 1:
			case 'r':
			case 'R':

				cmd = 0x1C;
				break;

			default:
				break;
		}

		//If direction accepted then scroll the specified amount
		if (cmd)
		{
			for (count = 0; count < Num_Positions; count++)
				FCD_LCDDisplay0_Command(cmd);
		}

}

void FCD_LCDDisplay0_ClearLine(MX_UINT8 Line)

{
	
		MX_UINT8 count;
		MX_UINT8 rowcount;

		//Define number of columns per line
		#if (LCD_1__ROWCNT == 1)
			rowcount=80;
		#endif

		#if (LCD_1__ROWCNT == 2)
			rowcount=40;
		#endif

		#if (LCD_1__ROWCNT == 4)
			#if (LCD_1__COLCNT == 16)
				rowcount=16;
0378  3010  	MOVLW 0x10
0379  00CC  	MOVWF FCD_LCDDis_0005D_1_rowcount

			#endif
			#if (LCD_1__COLCNT == 20)
				rowcount=20;
			#endif
		#endif

		//Start at beginning of the line
		FCD_LCDDisplay0_Cursor (0, Line);
037A  01CD  	CLRF FCD_LCDDis_00052_arg_x
037B  084A  	MOVF FCD_LCDDis_0005D_arg_Line, W
037C  00CE  	MOVWF FCD_LCDDis_00052_arg_y
037D  227C  	CALL FCD_LCDDis_00052


		//Send out spaces to clear line
		for (count = 0; count < rowcount; count++)
037E  01CB  	CLRF FCD_LCDDis_0005D_1_count
037F        label52
037F  084C  	MOVF FCD_LCDDis_0005D_1_rowcount, W
0380  024B  	SUBWF FCD_LCDDis_0005D_1_count, W
0381  1803  	BTFSC STATUS,C
0382  2B8A  	GOTO	label53
0388  0ACB  	INCF FCD_LCDDis_0005D_1_count, F
0389  2B7F  	GOTO	label52
038A        label53

			FCD_LCDDisplay0_RawSend(' ', 0x10);
0383  3020  	MOVLW 0x20
0384  00DD  	MOVWF FCD_LCDDis_00056_arg_in
0385  3010  	MOVLW 0x10
0386  00DE  	MOVWF FCD_LCDDis_00056_arg_mask
0387  208B  	CALL FCD_LCDDis_00056


		//Move back to the beginning of the line.
		FCD_LCDDisplay0_Cursor (0, Line);
038A  01CD  	CLRF FCD_LCDDis_00052_arg_x
038B  084A  	MOVF FCD_LCDDis_0005D_arg_Line, W
038C  00CE  	MOVWF FCD_LCDDis_00052_arg_y
038D  227C  	CALL FCD_LCDDis_00052


}
038E  0008  	RETURN


void FCD_LCDDisplay0_RAM_Write(MX_UINT8 nIdx, MX_UINT8 d0, MX_UINT8 d1, MX_UINT8 d2, MX_UINT8 d3, MX_UINT8 d4, MX_UINT8 d5, MX_UINT8 d6, MX_UINT8 d7)
{
	   //set CGRAM address

	   FCD_LCDDisplay0_RawSend(64 + (nIdx << 3), 0);
	   delay_ms(2);

	   //write CGRAM data
	   FCD_LCDDisplay0_RawSend(d0, 0x10);
	   FCD_LCDDisplay0_RawSend(d1, 0x10);
	   FCD_LCDDisplay0_RawSend(d2, 0x10);
	   FCD_LCDDisplay0_RawSend(d3, 0x10);
	   FCD_LCDDisplay0_RawSend(d4, 0x10);
	   FCD_LCDDisplay0_RawSend(d5, 0x10);
	   FCD_LCDDisplay0_RawSend(d6, 0x10);
	   FCD_LCDDisplay0_RawSend(d7, 0x10);

	   //Clear the display
	   FCD_LCDDisplay0_RawSend(0x01, 0);
	   delay_ms(2);
	   FCD_LCDDisplay0_RawSend(0x02, 0);
	   delay_ms(2);

}



//ADC(0): //Macro implementations


void FCD_ADC0_SampleADC()
{
	
	    //unused

}

MX_UINT8 FCD_ADC0_ReadAsByte()

{
	
		MX_UINT8 retVal;

		//Configure & Enable ADC Channel
		FC_CAL_Enable_ADC ( ADC_7_MX_ADC_CHANNEL , ADC_7_MX_ADC_CONVSP , ADC_7_MX_ADC_VREFOP , ADC_7_MX_ADC_ACTIME );
03F5  1283  	BCF STATUS, RP0
03F6  1303  	BCF STATUS, RP1
03F7  01CB  	CLRF FC_CAL_Ena_0005F_arg_Channel
03F8  3003  	MOVLW 0x03
03F9  00CC  	MOVWF FC_CAL_Ena_0005F_arg_Conv_Speed
03FA  01CD  	CLRF FC_CAL_Ena_0005F_arg_Vref
03FB  3028  	MOVLW 0x28
03FC  00CE  	MOVWF FC_CAL_Ena_0005F_arg_T_Charge
03FD  2118  	CALL FC_CAL_Ena_0005F


		retVal = FC_CAL_Sample_ADC( 0 );				//Perform Sample - Return as byte
03FE  01CB  	CLRF FC_CAL_Sam_00060_arg_Sample_Mode
03FF  20CC  	CALL FC_CAL_Sam_00060
0400  084E  	MOVF CompTempVarRet2238, W
0401  00CA  	MOVWF FCD_ADC0_R_00063_1_retVal


		FC_CAL_Disable_ADC ();
0402  215F  	CALL FC_CAL_Dis_00061


		return (retVal);
0403  084A  	MOVF FCD_ADC0_R_00063_1_retVal, W
0404  00CB  	MOVWF CompTempVarRet2244


}
0405  0008  	RETURN


MX_UINT16 FCD_ADC0_ReadAsInt()
{
	
		MX_UINT16 retVal;

		//Configure & Enable ADC Channel
		FC_CAL_Enable_ADC ( ADC_7_MX_ADC_CHANNEL , ADC_7_MX_ADC_CONVSP , ADC_7_MX_ADC_VREFOP , ADC_7_MX_ADC_ACTIME );

		retVal = FC_CAL_Sample_ADC( 1 );				//Perform Sample - Return as MX_UINT16

		FC_CAL_Disable_ADC ();

		return (retVal);

}

MX_FLOAT FCD_ADC0_ReadAsVoltage()
{
	
		MX_UINT16 iSample;
		MX_FLOAT fSample, fVoltage, fVperDiv;

		//Configure & Enable ADC Channel
		FC_CAL_Enable_ADC ( ADC_7_MX_ADC_CHANNEL , ADC_7_MX_ADC_CONVSP , ADC_7_MX_ADC_VREFOP , ADC_7_MX_ADC_ACTIME );

	  #ifdef MX_ADC_BITS_8
		iSample = FC_CAL_Sample_ADC( 0 );								//Perform Sample - Return as byte
	  #else
		iSample = FC_CAL_Sample_ADC( 1 );								//Perform Sample - Return as MX_UINT16
	  #endif

	  	FC_CAL_Disable_ADC ();											//Switch off ADC peripheral
		fVoltage = flt_fromi( ADC_7_MX_ADC_VREFVOL );						//Convert reference voltage count to floating point (0 - 500 x 10mV)
		fVoltage = flt_mul(fVoltage, 0.01);								//Convert reference voltage count to actual voltage (0 - 5)

	  #ifdef MX_ADC_BITS_8
		fVperDiv = flt_mul(fVoltage, 0.00390625);						//Convert actual voltage to voltage per division (VRef / 256)
	  #endif
	  #ifdef MX_ADC_BITS_10
		fVperDiv = flt_mul(fVoltage, 0.000976);							//Convert actual voltage to voltage per division (VRef / 1024)
	  #endif
	  #ifdef MX_ADC_BITS_12
		fVperDiv = flt_mul(fVoltage, 0.00024414);						//Convert actual voltage to voltage per division (VRef / 4096)
	  #endif

		fSample = flt_fromi(iSample);									//Convert to floating point variable
		fVoltage = flt_mul(fSample, fVperDiv);							//Calculate floating point voltage

		return (fVoltage);

}

void FCD_ADC0_ReadAsString(MX_CHAR* FCR_RETVAL, MX_UINT8 FCR_RETVAL_SIZE)
{
	
		MX_FLOAT fVoltage;

		fVoltage = FCD_ADC0_ReadAsVoltage();
		FCI_FLOAT_TO_STRING(fVoltage, 2, FCR_RETVAL, FCR_RETVAL_SIZE);	//Convert to String

}

void FCD_ADC0_ADC_RAW_Configure_Channel()
{
	
		//Configure & Enable ADC Channel
		FC_CAL_Enable_ADC ( ADC_7_MX_ADC_CHANNEL , ADC_7_MX_ADC_CONVSP , ADC_7_MX_ADC_VREFOP , ADC_7_MX_ADC_ACTIME );

}

MX_UINT8 FCD_ADC0_ADC_RAW_Sample_Channel_Byte()
{
	
		return FC_CAL_Sample_ADC( 0 );									//Perform Sample - Return as byte

}

MX_UINT16 FCD_ADC0_ADC_RAW_Sample_Channel_Int()
{
	
		return FC_CAL_Sample_ADC( 1 );									//Perform Sample - Return as MX_UINT16

}

MX_UINT8 FCD_ADC0_ADC_RAW_Average_Channel_Byte(MX_UINT8 NumSamples, MX_UINT8 DelayUs)
{
	
		MX_UINT32 average = 0;
		MX_UINT8 count;

		for (count=0; count<NumSamples; count++)
		{
			average = average + FC_CAL_Sample_ADC( 0 );					//Perform Sample - Return as byte - add to average

			if (DelayUs)
				delay_us(DelayUs);										//If delay is not 0 then pause between samples
		}
		average = average / count;

		return (average & 0xFF);										//Return average as byte

}

MX_UINT16 FCD_ADC0_ADC_RAW_Average_Channel_Int(MX_UINT8 NumSamples, MX_UINT8 DelayUs)
{
	
		MX_UINT32 average = 0;
		MX_UINT8 count;

		for (count=0; count<NumSamples; count++)
		{
			average = average + FC_CAL_Sample_ADC( 1 );					//Perform Sample - Return as MX_UINT16 - add to average

			if (DelayUs)
				delay_us(DelayUs);										//If delay is not 0 then pause between samples
		}
		average = average / count;

		return (average & 0x1FFF);										//Return average as MX_SINT16

}

void FCD_ADC0_ADC_RAW_Disable_Channel()
{
	
		FC_CAL_Disable_ADC ();											//Disable ADC Channel

}



//PWM(0): //Macro implementations


void FCD_PWM0_Enable()

{
	
		PWM_8_PWM_Change_Period (MX_PWM_PERIOD, MX_PWM_PRESCALE1);
036E  30FF  	MOVLW 0xFF
036F  1283  	BCF STATUS, RP0
0370  1303  	BCF STATUS, RP1
0371  00CA  	MOVWF FC_CAL_PWM_00071_arg_period
0372  3001  	MOVLW 0x01
0373  00CB  	MOVWF FC_CAL_PWM_00071_arg_prescaler
0374  01CC  	CLRF FC_CAL_PWM_00071_arg_prescaler+D'1'
0375  20F0  	CALL FC_CAL_PWM_00071

		PWM_8_PWM_Enable_Channel ();
0376  2110  	CALL FC_CAL_PWM_0006E


}
0377  0008  	RETURN


void FCD_PWM0_Disable()
{
	
		PWM_8_PWM_Disable_Channel();

}

void FCD_PWM0_SetDutyCycle(MX_UINT8 nDuty)

{
	
		PWM_8_PWM_Set_Duty_8Bit(nDuty);
016E  084A  	MOVF FCD_PWM0_S_00055_arg_nDuty, W
016F  00CB  	MOVWF FC_CAL_PWM_00070_arg_duty
0170  2088  	CALL FC_CAL_PWM_00070


}
0171  0008  	RETURN


void FCD_PWM0_ChangePeriod(MX_UINT8 nPeriodVal, MX_UINT8 nPrescalerVal)
{
	
		PWM_8_PWM_Change_Period (nPeriodVal, nPrescalerVal);

}

void FCD_PWM0_SetDutyCycle10bit(MX_SINT16 nDuty)
{
	
		PWM_8_PWM_Set_Duty_10Bit(nDuty);

}

#include "C:\Program Files (x86)\Flowcode\v5\CAL\includes.c"

//Macro implementations


void FCM_display()

{

	//Call Component Macro
	//Call Component Macro: Cursor(2, 0)
	FCD_LCDDisplay0_Cursor(2, 0);
02B0  3002  	MOVLW 0x02
02B1  1283  	BCF STATUS, RP0
02B2  1303  	BCF STATUS, RP1
02B3  00CD  	MOVWF FCD_LCDDis_00052_arg_x
02B4  01CE  	CLRF FCD_LCDDis_00052_arg_y
02B5  227C  	CALL FCD_LCDDis_00052


	//Call Component Macro
	//Call Component Macro: PrintString("HELLO WORLD!")
	FCD_LCDDisplay0_PrintString("HELLO WORLD!", 12);
02B6  3020  	MOVLW 0x20
02B7  00D3  	MOVWF CompTempVar2188+D'5'
02B8  3021  	MOVLW 0x21
02B9  00D9  	MOVWF CompTempVar2188+D'11'
02BA  3044  	MOVLW 0x44
02BB  00D8  	MOVWF CompTempVar2188+D'10'
02BC  3045  	MOVLW 0x45
02BD  00CF  	MOVWF CompTempVar2188+D'1'
02BE  3048  	MOVLW 0x48
02BF  00CE  	MOVWF CompTempVar2188
02C0  304C  	MOVLW 0x4C
02C1  00D0  	MOVWF CompTempVar2188+D'2'
02C2  00D1  	MOVWF CompTempVar2188+D'3'
02C3  00D7  	MOVWF CompTempVar2188+D'9'
02C4  304F  	MOVLW 0x4F
02C5  00D2  	MOVWF CompTempVar2188+D'4'
02C6  00D5  	MOVWF CompTempVar2188+D'7'
02C7  3052  	MOVLW 0x52
02C8  00D6  	MOVWF CompTempVar2188+D'8'
02C9  3057  	MOVLW 0x57
02CA  00D4  	MOVWF CompTempVar2188+D'6'
02CB  01DA  	CLRF CompTempVar2188+D'12'
02CC  3000  	MOVLW HIGH(CompTempVar2188+D'0')
02CD  00CD  	MOVWF FCD_LCDDis_00053_arg_String+D'1'
02CE  304E  	MOVLW LOW(CompTempVar2188+D'0')
02CF  00CC  	MOVWF FCD_LCDDis_00053_arg_String
02D0  300C  	MOVLW 0x0C
02D1  00DB  	MOVWF FCD_LCDDis_00053_arg_MSZ_String
02D2  2260  	CALL FCD_LCDDis_00053


	//Call Component Macro
	//Call Component Macro: Cursor(0, 1)
	FCD_LCDDisplay0_Cursor(0, 1);
02D3  01CD  	CLRF FCD_LCDDis_00052_arg_x
02D4  3001  	MOVLW 0x01
02D5  00CE  	MOVWF FCD_LCDDis_00052_arg_y
02D6  227C  	CALL FCD_LCDDis_00052


	//Call Component Macro
	//Call Component Macro: PrintNumber(b_sw0)
	FCD_LCDDisplay0_PrintNumber(FCV_B_SW0);
02D7  01CD  	CLRF FCD_LCDDis_00054_arg_Number+D'1'
02D8  01CC  	CLRF FCD_LCDDis_00054_arg_Number
02D9  18C5  	BTFSC gbl_FCV_B_SW0,1
02DA  0ACC  	INCF FCD_LCDDis_00054_arg_Number, F
02DB  2172  	CALL FCD_LCDDis_00054


	//Call Component Macro
	//Call Component Macro: Cursor(0, 2)
	FCD_LCDDisplay0_Cursor(0, 2);
02DC  01CD  	CLRF FCD_LCDDis_00052_arg_x
02DD  3002  	MOVLW 0x02
02DE  00CE  	MOVWF FCD_LCDDis_00052_arg_y
02DF  227C  	CALL FCD_LCDDis_00052


	//Call Component Macro
	//Call Component Macro: PrintNumber(b_sw1)
	FCD_LCDDisplay0_PrintNumber(FCV_B_SW1);
02E0  01CD  	CLRF FCD_LCDDis_00054_arg_Number+D'1'
02E1  01CC  	CLRF FCD_LCDDis_00054_arg_Number
02E2  1945  	BTFSC gbl_FCV_B_SW1,2
02E3  0ACC  	INCF FCD_LCDDis_00054_arg_Number, F
02E4  2172  	CALL FCD_LCDDis_00054


	//Call Component Macro
	//Call Component Macro: Cursor(0, 3)
	FCD_LCDDisplay0_Cursor(0, 3);
02E5  01CD  	CLRF FCD_LCDDis_00052_arg_x
02E6  3003  	MOVLW 0x03
02E7  00CE  	MOVWF FCD_LCDDis_00052_arg_y
02E8  227C  	CALL FCD_LCDDis_00052


	//Call Component Macro
	//Call Component Macro: PrintNumber(b_sw2)
	FCD_LCDDisplay0_PrintNumber(FCV_B_SW2);
02E9  0844  	MOVF gbl_FCV_B_SW2, W
02EA  00CC  	MOVWF FCD_LCDDis_00054_arg_Number
02EB  01CD  	CLRF FCD_LCDDis_00054_arg_Number+D'1'
02EC  2172  	CALL FCD_LCDDis_00054


	//Call Component Macro
	//Call Component Macro: Cursor(3, 1)
	FCD_LCDDisplay0_Cursor(3, 1);
02ED  3003  	MOVLW 0x03
02EE  00CD  	MOVWF FCD_LCDDis_00052_arg_x
02EF  3001  	MOVLW 0x01
02F0  00CE  	MOVWF FCD_LCDDis_00052_arg_y
02F1  227C  	CALL FCD_LCDDis_00052


	//Decision
	//Decision: flag0 = 1?
	if (FCV_FLAG0 == 1)
02F2  1C45  	BTFSS gbl_FCV_FLAG0,0
02F3  2B1A  	GOTO	label48
031A        label48

	{

		//Call Component Macro
		//Call Component Macro: PrintString("ON")
		FCD_LCDDisplay0_PrintString("ON", 2);
02F4  304F  	MOVLW 0x4F
02F5  00CE  	MOVWF CompTempVar2190
02F6  304E  	MOVLW 0x4E
02F7  00CF  	MOVWF CompTempVar2190+D'1'
02F8  01D0  	CLRF CompTempVar2190+D'2'
02F9  3000  	MOVLW HIGH(CompTempVar2190+D'0')
02FA  00CD  	MOVWF FCD_LCDDis_00053_arg_String+D'1'
02FB  304E  	MOVLW LOW(CompTempVar2190+D'0')
02FC  00CC  	MOVWF FCD_LCDDis_00053_arg_String
02FD  3002  	MOVLW 0x02
02FE  00DB  	MOVWF FCD_LCDDis_00053_arg_MSZ_String
02FF  2260  	CALL FCD_LCDDis_00053


		//Call Component Macro
		//Call Component Macro: SetDutyCycle(analog0)
		FCD_PWM0_SetDutyCycle(FCV_ANALOG0);
0300  0846  	MOVF gbl_FCV_ANALOG0, W
0301  00CA  	MOVWF FCD_PWM0_S_00055_arg_nDuty
0302  216E  	CALL FCD_PWM0_S_00055


		//Call Component Macro
		//Call Component Macro: Cursor(3, 2)
		FCD_LCDDisplay0_Cursor(3, 2);
0303  3003  	MOVLW 0x03
0304  00CD  	MOVWF FCD_LCDDis_00052_arg_x
0305  3002  	MOVLW 0x02
0306  00CE  	MOVWF FCD_LCDDis_00052_arg_y
0307  227C  	CALL FCD_LCDDis_00052


		//Call Component Macro
		//Call Component Macro: PrintNumber(brightness)
		FCD_LCDDisplay0_PrintNumber(FCV_BRIGHTNESS);
0308  0847  	MOVF gbl_FCV_BRIGHTNESS, W
0309  00CC  	MOVWF FCD_LCDDis_00054_arg_Number
030A  01CD  	CLRF FCD_LCDDis_00054_arg_Number+D'1'
030B  2172  	CALL FCD_LCDDis_00054


		//Call Component Macro
		//Call Component Macro: PrintString("%  ")
		FCD_LCDDisplay0_PrintString("%  ", 3);
030C  3025  	MOVLW 0x25
030D  00CE  	MOVWF CompTempVar2192
030E  3020  	MOVLW 0x20
030F  00CF  	MOVWF CompTempVar2192+D'1'
0310  00D0  	MOVWF CompTempVar2192+D'2'
0311  01D1  	CLRF CompTempVar2192+D'3'
0312  3000  	MOVLW HIGH(CompTempVar2192+D'0')
0313  00CD  	MOVWF FCD_LCDDis_00053_arg_String+D'1'
0314  304E  	MOVLW LOW(CompTempVar2192+D'0')
0315  00CC  	MOVWF FCD_LCDDis_00053_arg_String
0316  3003  	MOVLW 0x03
0317  00DB  	MOVWF FCD_LCDDis_00053_arg_MSZ_String
0318  2260  	CALL FCD_LCDDis_00053


	} else {
0319  2B29  	GOTO	label49
0329        label49


		//Call Component Macro
		//Call Component Macro: PrintString("OFF")
		FCD_LCDDisplay0_PrintString("OFF", 3);
031A  304F  	MOVLW 0x4F
031B  00CE  	MOVWF CompTempVar2194
031C  3046  	MOVLW 0x46
031D  00CF  	MOVWF CompTempVar2194+D'1'
031E  00D0  	MOVWF CompTempVar2194+D'2'
031F  01D1  	CLRF CompTempVar2194+D'3'
0320  3000  	MOVLW HIGH(CompTempVar2194+D'0')
0321  00CD  	MOVWF FCD_LCDDis_00053_arg_String+D'1'
0322  304E  	MOVLW LOW(CompTempVar2194+D'0')
0323  00CC  	MOVWF FCD_LCDDis_00053_arg_String
0324  3003  	MOVLW 0x03
0325  00DB  	MOVWF FCD_LCDDis_00053_arg_MSZ_String
0326  2260  	CALL FCD_LCDDis_00053


		//Call Component Macro
		//Call Component Macro: SetDutyCycle(0)
		FCD_PWM0_SetDutyCycle(0);
0327  01CA  	CLRF FCD_PWM0_S_00055_arg_nDuty
0328  216E  	CALL FCD_PWM0_S_00055


	}

	//Decision
	//Decision: analog0 < 10?
	if (FCV_ANALOG0 < 10)
0329  300A  	MOVLW 0x0A
032A  0246  	SUBWF gbl_FCV_ANALOG0, W
032B  1803  	BTFSC STATUS,C
032C  2B42  	GOTO	label50
0342        label50

	{

		//Call Component Macro
		//Call Component Macro: Cursor(13, 3)
		FCD_LCDDisplay0_Cursor(13, 3);
032D  300D  	MOVLW 0x0D
032E  00CD  	MOVWF FCD_LCDDis_00052_arg_x
032F  3003  	MOVLW 0x03
0330  00CE  	MOVWF FCD_LCDDis_00052_arg_y
0331  227C  	CALL FCD_LCDDis_00052


		//Call Component Macro
		//Call Component Macro: PrintString("  ")
		FCD_LCDDisplay0_PrintString("  ", 2);
0332  3020  	MOVLW 0x20
0333  00CE  	MOVWF CompTempVar2196
0334  00CF  	MOVWF CompTempVar2196+D'1'
0335  01D0  	CLRF CompTempVar2196+D'2'
0336  3000  	MOVLW HIGH(CompTempVar2196+D'0')
0337  00CD  	MOVWF FCD_LCDDis_00053_arg_String+D'1'
0338  304E  	MOVLW LOW(CompTempVar2196+D'0')
0339  00CC  	MOVWF FCD_LCDDis_00053_arg_String
033A  3002  	MOVLW 0x02
033B  00DB  	MOVWF FCD_LCDDis_00053_arg_MSZ_String
033C  2260  	CALL FCD_LCDDis_00053


		//Call Component Macro
		//Call Component Macro: PrintNumber(analog0)
		FCD_LCDDisplay0_PrintNumber(FCV_ANALOG0);
033D  0846  	MOVF gbl_FCV_ANALOG0, W
033E  00CC  	MOVWF FCD_LCDDis_00054_arg_Number
033F  01CD  	CLRF FCD_LCDDis_00054_arg_Number+D'1'
0340  2172  	CALL FCD_LCDDis_00054


	} else {

		//Decision
		//Decision: analog0 < 100 AND analog0 > 9?
		if (FCV_ANALOG0 < 100 & FCV_ANALOG0 > 9)
0342  01CB  	CLRF CompTempVar2199
0343  3064  	MOVLW 0x64
0344  0246  	SUBWF gbl_FCV_ANALOG0, W
0345  1C03  	BTFSS STATUS,C
0346  0ACB  	INCF CompTempVar2199, F
0347  01CA  	CLRF CompTempVar2198
0348  0846  	MOVF gbl_FCV_ANALOG0, W
0349  3C09  	SUBLW 0x09
034A  1C03  	BTFSS STATUS,C
034B  0ACA  	INCF CompTempVar2198, F
034C  084A  	MOVF CompTempVar2198, W
034D  054B  	ANDWF CompTempVar2199, W
034E  1903  	BTFSC STATUS,Z
034F  2B64  	GOTO	label51
0364        label51

		{

			//Call Component Macro
			//Call Component Macro: Cursor(13, 3)
			FCD_LCDDisplay0_Cursor(13, 3);
0350  300D  	MOVLW 0x0D
0351  00CD  	MOVWF FCD_LCDDis_00052_arg_x
0352  3003  	MOVLW 0x03
0353  00CE  	MOVWF FCD_LCDDis_00052_arg_y
0354  227C  	CALL FCD_LCDDis_00052


			//Call Component Macro
			//Call Component Macro: PrintString(" ")
			FCD_LCDDisplay0_PrintString(" ", 1);
0355  3020  	MOVLW 0x20
0356  00CE  	MOVWF CompTempVar2200
0357  01CF  	CLRF CompTempVar2200+D'1'
0358  3000  	MOVLW HIGH(CompTempVar2200+D'0')
0359  00CD  	MOVWF FCD_LCDDis_00053_arg_String+D'1'
035A  304E  	MOVLW LOW(CompTempVar2200+D'0')
035B  00CC  	MOVWF FCD_LCDDis_00053_arg_String
035C  3001  	MOVLW 0x01
035D  00DB  	MOVWF FCD_LCDDis_00053_arg_MSZ_String
035E  2260  	CALL FCD_LCDDis_00053


			//Call Component Macro
			//Call Component Macro: PrintNumber(analog0)
			FCD_LCDDisplay0_PrintNumber(FCV_ANALOG0);
035F  0846  	MOVF gbl_FCV_ANALOG0, W
0360  00CC  	MOVWF FCD_LCDDis_00054_arg_Number
0361  01CD  	CLRF FCD_LCDDis_00054_arg_Number+D'1'
0362  2172  	CALL FCD_LCDDis_00054


		} else {

			//Call Component Macro
			//Call Component Macro: Cursor(13, 3)
			FCD_LCDDisplay0_Cursor(13, 3);
0364  300D  	MOVLW 0x0D
0365  00CD  	MOVWF FCD_LCDDis_00052_arg_x
0366  3003  	MOVLW 0x03
0367  00CE  	MOVWF FCD_LCDDis_00052_arg_y
0368  227C  	CALL FCD_LCDDis_00052


			//Call Component Macro
			//Call Component Macro: PrintNumber(analog0)
			FCD_LCDDisplay0_PrintNumber(FCV_ANALOG0);
0369  0846  	MOVF gbl_FCV_ANALOG0, W
036A  00CC  	MOVWF FCD_LCDDis_00054_arg_Number
036B  01CD  	CLRF FCD_LCDDis_00054_arg_Number+D'1'
036C  2172  	CALL FCD_LCDDis_00054


		}

	}

}
0341  0008  	RETURN
0363  0008  	RETURN
036D  0008  	RETURN




void main()

{
	//Initialization
	adcon1 = 0x07;
0406  3007  	MOVLW 0x07
0407  1683  	BSF STATUS, RP0
0408  1303  	BCF STATUS, RP1
0409  009F  	MOVWF gbl_adcon1



	//Interrupt initialization code
	option_reg = 0xC0;
040A  30C0  	MOVLW 0xC0
040B  0081  	MOVWF gbl_option_reg



	//Call Component Macro
	//Call Component Macro: Start()
	FCD_LCDDisplay0_Start();
040C  23A0  	CALL FCD_LCDDis_00057


	//Call Component Macro
	//Call Component Macro: Clear()
	FCD_LCDDisplay0_Clear();
040D  238F  	CALL FCD_LCDDis_00058


	//Call Component Macro
	//Call Component Macro: Cursor(3, 0)
	FCD_LCDDisplay0_Cursor(3, 0);
040E  3003  	MOVLW 0x03
040F  00CD  	MOVWF FCD_LCDDis_00052_arg_x
0410  01CE  	CLRF FCD_LCDDis_00052_arg_y
0411  227C  	CALL FCD_LCDDis_00052


	//Call Component Macro
	//Call Component Macro: PrintString("BOOTING")
	FCD_LCDDisplay0_PrintString("BOOTING", 7);
0412  3042  	MOVLW 0x42
0413  00CE  	MOVWF CompTempVar2281
0414  304F  	MOVLW 0x4F
0415  00CF  	MOVWF CompTempVar2281+D'1'
0416  00D0  	MOVWF CompTempVar2281+D'2'
0417  3054  	MOVLW 0x54
0418  00D1  	MOVWF CompTempVar2281+D'3'
0419  3049  	MOVLW 0x49
041A  00D2  	MOVWF CompTempVar2281+D'4'
041B  304E  	MOVLW 0x4E
041C  00D3  	MOVWF CompTempVar2281+D'5'
041D  3047  	MOVLW 0x47
041E  00D4  	MOVWF CompTempVar2281+D'6'
041F  01D5  	CLRF CompTempVar2281+D'7'
0420  3000  	MOVLW HIGH(CompTempVar2281+D'0')
0421  00CD  	MOVWF FCD_LCDDis_00053_arg_String+D'1'
0422  304E  	MOVLW LOW(CompTempVar2281+D'0')
0423  00CC  	MOVWF FCD_LCDDis_00053_arg_String
0424  3007  	MOVLW 0x07
0425  00DB  	MOVWF FCD_LCDDis_00053_arg_MSZ_String
0426  2260  	CALL FCD_LCDDis_00053


	//Delay
	//Delay: 1 s
	delay_s(1);
0427  3001  	MOVLW 0x01
0428  00CA  	MOVWF delay_s_00000_arg_del
0429  204F  	CALL delay_s_00000


	//Call Component Macro
	//Call Component Macro: PrintString(".")
	FCD_LCDDisplay0_PrintString(".", 1);
042A  302E  	MOVLW 0x2E
042B  00CE  	MOVWF CompTempVar2283
042C  01CF  	CLRF CompTempVar2283+D'1'
042D  3000  	MOVLW HIGH(CompTempVar2283+D'0')
042E  00CD  	MOVWF FCD_LCDDis_00053_arg_String+D'1'
042F  304E  	MOVLW LOW(CompTempVar2283+D'0')
0430  00CC  	MOVWF FCD_LCDDis_00053_arg_String
0431  3001  	MOVLW 0x01
0432  00DB  	MOVWF FCD_LCDDis_00053_arg_MSZ_String
0433  2260  	CALL FCD_LCDDis_00053


	//Delay
	//Delay: 1 s
	delay_s(1);
0434  3001  	MOVLW 0x01
0435  00CA  	MOVWF delay_s_00000_arg_del
0436  204F  	CALL delay_s_00000


	//Call Component Macro
	//Call Component Macro: PrintString(".")
	FCD_LCDDisplay0_PrintString(".", 1);
0437  302E  	MOVLW 0x2E
0438  00CE  	MOVWF CompTempVar2285
0439  01CF  	CLRF CompTempVar2285+D'1'
043A  3000  	MOVLW HIGH(CompTempVar2285+D'0')
043B  00CD  	MOVWF FCD_LCDDis_00053_arg_String+D'1'
043C  304E  	MOVLW LOW(CompTempVar2285+D'0')
043D  00CC  	MOVWF FCD_LCDDis_00053_arg_String
043E  3001  	MOVLW 0x01
043F  00DB  	MOVWF FCD_LCDDis_00053_arg_MSZ_String
0440  2260  	CALL FCD_LCDDis_00053


	//Delay
	//Delay: 1 s
	delay_s(1);
0441  3001  	MOVLW 0x01
0442  00CA  	MOVWF delay_s_00000_arg_del
0443  204F  	CALL delay_s_00000


	//Call Component Macro
	//Call Component Macro: PrintString(".")
	FCD_LCDDisplay0_PrintString(".", 1);
0444  302E  	MOVLW 0x2E
0445  00CE  	MOVWF CompTempVar2287
0446  01CF  	CLRF CompTempVar2287+D'1'
0447  3000  	MOVLW HIGH(CompTempVar2287+D'0')
0448  00CD  	MOVWF FCD_LCDDis_00053_arg_String+D'1'
0449  304E  	MOVLW LOW(CompTempVar2287+D'0')
044A  00CC  	MOVWF FCD_LCDDis_00053_arg_String
044B  3001  	MOVLW 0x01
044C  00DB  	MOVWF FCD_LCDDis_00053_arg_MSZ_String
044D  2260  	CALL FCD_LCDDis_00053


	//Delay
	//Delay: 1 s
	delay_s(1);
044E  3001  	MOVLW 0x01
044F  00CA  	MOVWF delay_s_00000_arg_del
0450  204F  	CALL delay_s_00000


	//Call Component Macro
	//Call Component Macro: Clear()
	FCD_LCDDisplay0_Clear();
0451  238F  	CALL FCD_LCDDis_00058


	//Call Component Macro
	//Call Component Macro: Enable()
	FCD_PWM0_Enable();
0452  236E  	CALL FCD_PWM0_E_00073


	//Loop
	//Loop: While 1
	while (1)
0453        label54
04F8  2C53  	GOTO	label54

	{

		//Call Macro
		//Call Macro: display()
		FCM_display();
0453  22B0  	CALL FCM_displa_00051


		//Input
		//Input: A2 -> b_sw2
		trisa = trisa | 0x04;
0454  3004  	MOVLW 0x04
0455  1683  	BSF STATUS, RP0
0456  0405  	IORWF gbl_trisa, W
0457  0085  	MOVWF gbl_trisa

		FCV_B_SW2 = ((porta & 0x04) == 0x04);
0458  3004  	MOVLW 0x04
0459  1283  	BCF STATUS, RP0
045A  0505  	ANDWF gbl_porta, W
045B  00CA  	MOVWF CompTempVar2289
045C  01C4  	CLRF gbl_FCV_B_SW2
045D  3004  	MOVLW 0x04
045E  024A  	SUBWF CompTempVar2289, W
045F  1903  	BTFSC STATUS,Z
0460  0AC4  	INCF gbl_FCV_B_SW2, F


		//Input
		//Input: A3 -> b_sw1
		trisa = trisa | 0x08;
0461  3008  	MOVLW 0x08
0462  1683  	BSF STATUS, RP0
0463  0405  	IORWF gbl_trisa, W
0464  0085  	MOVWF gbl_trisa

		FCV_B_SW1 = ((porta & 0x08) == 0x08);
0465  3008  	MOVLW 0x08
0466  1283  	BCF STATUS, RP0
0467  0505  	ANDWF gbl_porta, W
0468  00CA  	MOVWF CompTempVar2291
0469  01CB  	CLRF CompTempVar2292
046A  3008  	MOVLW 0x08
046B  024A  	SUBWF CompTempVar2291, W
046C  1903  	BTFSC STATUS,Z
046D  0ACB  	INCF CompTempVar2292, F
046E  1145  	BCF gbl_FCV_B_SW1,2
046F  084B  	MOVF CompTempVar2292, W
0470  1D03  	BTFSS STATUS,Z
0471  1545  	BSF gbl_FCV_B_SW1,2


		//Input
		//Input: A4 -> b_sw0
		trisa = trisa | 0x10;
0472  3010  	MOVLW 0x10
0473  1683  	BSF STATUS, RP0
0474  0405  	IORWF gbl_trisa, W
0475  0085  	MOVWF gbl_trisa

		FCV_B_SW0 = ((porta & 0x10) == 0x10);
0476  3010  	MOVLW 0x10
0477  1283  	BCF STATUS, RP0
0478  0505  	ANDWF gbl_porta, W
0479  00CA  	MOVWF CompTempVar2293
047A  01CB  	CLRF CompTempVar2294
047B  3010  	MOVLW 0x10
047C  024A  	SUBWF CompTempVar2293, W
047D  1903  	BTFSC STATUS,Z
047E  0ACB  	INCF CompTempVar2294, F
047F  10C5  	BCF gbl_FCV_B_SW0,1
0480  084B  	MOVF CompTempVar2294, W
0481  1D03  	BTFSS STATUS,Z
0482  14C5  	BSF gbl_FCV_B_SW0,1


		//Call Component Macro
		//Call Component Macro: analog0=ReadAsByte()
		FCV_ANALOG0 = FCD_ADC0_ReadAsByte();
0483  23F5  	CALL FCD_ADC0_R_00063
0484  084B  	MOVF CompTempVarRet2244, W
0485  00C6  	MOVWF gbl_FCV_ANALOG0


		//Decision
		//Decision: b_sw2 = 0?
		if (FCV_B_SW2 == 0)
0486  08C4  	MOVF gbl_FCV_B_SW2, F
0487  1D03  	BTFSS STATUS,Z
0488  2CA7  	GOTO	label59
0489        label55
04A7        label59

		{

			//Loop
			//Loop: While b_sw2 = 0
			while (FCV_B_SW2 == 0)
0489  08C4  	MOVF gbl_FCV_B_SW2, F
048A  1D03  	BTFSS STATUS,Z
048B  2C9C  	GOTO	label56
049B  2C89  	GOTO	label55
049C        label56

			{

				//Input
				//Input: A2 -> b_sw2
				trisa = trisa | 0x04;
048C  3004  	MOVLW 0x04
048D  1683  	BSF STATUS, RP0
048E  0405  	IORWF gbl_trisa, W
048F  0085  	MOVWF gbl_trisa

				FCV_B_SW2 = ((porta & 0x04) == 0x04);
0490  3004  	MOVLW 0x04
0491  1283  	BCF STATUS, RP0
0492  0505  	ANDWF gbl_porta, W
0493  00CA  	MOVWF CompTempVar2295
0494  01CB  	CLRF CompTempVar2296
0495  3004  	MOVLW 0x04
0496  024A  	SUBWF CompTempVar2295, W
0497  1903  	BTFSC STATUS,Z
0498  0ACB  	INCF CompTempVar2296, F
0499  084B  	MOVF CompTempVar2296, W
049A  00C4  	MOVWF gbl_FCV_B_SW2



			}

			//Decision
			//Decision: flag0 = 1?
			if (FCV_FLAG0 == 1)
049C  1C45  	BTFSS gbl_FCV_FLAG0,0
049D  2CA0  	GOTO	label57
04A0        label57

			{

				//Calculation
				//Calculation:
				//  flag0 = 0
				FCV_FLAG0 = 0;
049E  1045  	BCF gbl_FCV_FLAG0,0


			} else {
049F  2CA1  	GOTO	label58
04A1        label58


				//Calculation
				//Calculation:
				//  flag0 = 1
				FCV_FLAG0 = 1;
04A0  1445  	BSF gbl_FCV_FLAG0,0


			}

			//Call Component Macro
			//Call Component Macro: ClearLine(1)
			FCD_LCDDisplay0_ClearLine(1);
04A1  3001  	MOVLW 0x01
04A2  00CA  	MOVWF FCD_LCDDis_0005D_arg_Line
04A3  2378  	CALL FCD_LCDDis_0005D


			//Call Component Macro
			//Call Component Macro: ClearLine(2)
			FCD_LCDDisplay0_ClearLine(2);
04A4  3002  	MOVLW 0x02
04A5  00CA  	MOVWF FCD_LCDDis_0005D_arg_Line
04A6  2378  	CALL FCD_LCDDis_0005D


		// } else {

		}

		//Decision
		//Decision: b_sw1 = 0?
		if (FCV_B_SW1 == 0)
04A7  1945  	BTFSC gbl_FCV_B_SW1,2
04A8  2CC8  	GOTO	label64
04A9        label60
04C8        label64

		{

			//Loop
			//Loop: While b_sw1 = 0
			while (FCV_B_SW1 == 0)
04A9  1945  	BTFSC gbl_FCV_B_SW1,2
04AA  2CBD  	GOTO	label61
04BC  2CA9  	GOTO	label60
04BD        label61

			{

				//Input
				//Input: A3 -> b_sw1
				trisa = trisa | 0x08;
04AB  3008  	MOVLW 0x08
04AC  1683  	BSF STATUS, RP0
04AD  0405  	IORWF gbl_trisa, W
04AE  0085  	MOVWF gbl_trisa

				FCV_B_SW1 = ((porta & 0x08) == 0x08);
04AF  3008  	MOVLW 0x08
04B0  1283  	BCF STATUS, RP0
04B1  0505  	ANDWF gbl_porta, W
04B2  00CA  	MOVWF CompTempVar2297
04B3  01CB  	CLRF CompTempVar2298
04B4  3008  	MOVLW 0x08
04B5  024A  	SUBWF CompTempVar2297, W
04B6  1903  	BTFSC STATUS,Z
04B7  0ACB  	INCF CompTempVar2298, F
04B8  1145  	BCF gbl_FCV_B_SW1,2
04B9  084B  	MOVF CompTempVar2298, W
04BA  1D03  	BTFSS STATUS,Z
04BB  1545  	BSF gbl_FCV_B_SW1,2



			}

			//Decision
			//Decision: flag0 = 1?
			if (FCV_FLAG0 == 1)
04BD  1C45  	BTFSS gbl_FCV_FLAG0,0
04BE  2CC1  	GOTO	label62
04C1        label62

			{

				//Calculation
				//Calculation:
				//  flag0 = 0
				FCV_FLAG0 = 0;
04BF  1045  	BCF gbl_FCV_FLAG0,0


			} else {
04C0  2CC2  	GOTO	label63
04C2        label63


				//Calculation
				//Calculation:
				//  flag0 = 1
				FCV_FLAG0 = 1;
04C1  1445  	BSF gbl_FCV_FLAG0,0


			}

			//Call Component Macro
			//Call Component Macro: ClearLine(1)
			FCD_LCDDisplay0_ClearLine(1);
04C2  3001  	MOVLW 0x01
04C3  00CA  	MOVWF FCD_LCDDis_0005D_arg_Line
04C4  2378  	CALL FCD_LCDDis_0005D


			//Call Component Macro
			//Call Component Macro: ClearLine(2)
			FCD_LCDDisplay0_ClearLine(2);
04C5  3002  	MOVLW 0x02
04C6  00CA  	MOVWF FCD_LCDDis_0005D_arg_Line
04C7  2378  	CALL FCD_LCDDis_0005D


		// } else {

		}

		//Decision
		//Decision: b_sw0 = 0?
		if (FCV_B_SW0 == 0)
04C8  18C5  	BTFSC gbl_FCV_B_SW0,1
04C9  2CE9  	GOTO	label69
04CA        label65
04E9        label69

		{

			//Loop
			//Loop: While b_sw0 = 0
			while (FCV_B_SW0 == 0)
04CA  18C5  	BTFSC gbl_FCV_B_SW0,1
04CB  2CDE  	GOTO	label66
04DD  2CCA  	GOTO	label65
04DE        label66

			{

				//Input
				//Input: A4 -> b_sw0
				trisa = trisa | 0x10;
04CC  3010  	MOVLW 0x10
04CD  1683  	BSF STATUS, RP0
04CE  0405  	IORWF gbl_trisa, W
04CF  0085  	MOVWF gbl_trisa

				FCV_B_SW0 = ((porta & 0x10) == 0x10);
04D0  3010  	MOVLW 0x10
04D1  1283  	BCF STATUS, RP0
04D2  0505  	ANDWF gbl_porta, W
04D3  00CA  	MOVWF CompTempVar2299
04D4  01CB  	CLRF CompTempVar2300
04D5  3010  	MOVLW 0x10
04D6  024A  	SUBWF CompTempVar2299, W
04D7  1903  	BTFSC STATUS,Z
04D8  0ACB  	INCF CompTempVar2300, F
04D9  10C5  	BCF gbl_FCV_B_SW0,1
04DA  084B  	MOVF CompTempVar2300, W
04DB  1D03  	BTFSS STATUS,Z
04DC  14C5  	BSF gbl_FCV_B_SW0,1



			}

			//Decision
			//Decision: flag0 = 1?
			if (FCV_FLAG0 == 1)
04DE  1C45  	BTFSS gbl_FCV_FLAG0,0
04DF  2CE2  	GOTO	label67
04E2        label67

			{

				//Calculation
				//Calculation:
				//  flag0 = 0
				FCV_FLAG0 = 0;
04E0  1045  	BCF gbl_FCV_FLAG0,0


			} else {
04E1  2CE3  	GOTO	label68
04E3        label68


				//Calculation
				//Calculation:
				//  flag0 = 1
				FCV_FLAG0 = 1;
04E2  1445  	BSF gbl_FCV_FLAG0,0


			}

			//Call Component Macro
			//Call Component Macro: ClearLine(1)
			FCD_LCDDisplay0_ClearLine(1);
04E3  3001  	MOVLW 0x01
04E4  00CA  	MOVWF FCD_LCDDis_0005D_arg_Line
04E5  2378  	CALL FCD_LCDDis_0005D


			//Call Component Macro
			//Call Component Macro: ClearLine(2)
			FCD_LCDDisplay0_ClearLine(2);
04E6  3002  	MOVLW 0x02
04E7  00CA  	MOVWF FCD_LCDDis_0005D_arg_Line
04E8  2378  	CALL FCD_LCDDis_0005D


		// } else {

		}

		//Calculation
		//Calculation:
		//  brightness = (analog0 * 100) / 255
		FCV_BRIGHTNESS = (FCV_ANALOG0 * 100) / 255;
04E9  0846  	MOVF gbl_FCV_ANALOG0, W
04EA  00CA  	MOVWF __mul_8u_8_00006_arg_a
04EB  3064  	MOVLW 0x64
04EC  00CB  	MOVWF __mul_8u_8_00006_arg_b
04ED  229A  	CALL __mul_8u_8_00006
04EE  084F  	MOVF CompTempVarRet452, W
04EF  00D1  	MOVWF __div_16_1_00003_arg_a
04F0  0850  	MOVF CompTempVarRet452+D'1', W
04F1  00D2  	MOVWF __div_16_1_00003_arg_a+D'1'
04F2  30FF  	MOVLW 0xFF
04F3  00D3  	MOVWF __div_16_1_00003_arg_b
04F4  01D4  	CLRF __div_16_1_00003_arg_b+D'1'
04F5  205E  	CALL __div_16_1_00003
04F6  085A  	MOVF CompTempVarRet214, W
04F7  00C7  	MOVWF gbl_FCV_BRIGHTNESS



	}

	mainendloop: goto mainendloop;
}


void MX_INTERRUPT_MACRO(void)

{
}
0529  1283  	BCF STATUS, RP0
052A  1303  	BCF STATUS, RP1
052B  0E36  	SWAPF Int1BContext+D'2', W
052C  0084  	MOVWF FSR
052D  0E35  	SWAPF Int1BContext+D'1', W
052E  008A  	MOVWF PCLATH
052F  0E34  	SWAPF Int1BContext, W
0530  0083  	MOVWF STATUS
0531  0EFF  	SWAPF Int1Context, F
0532  0E7F  	SWAPF Int1Context, W
0533  0009  	RETFIE





/*********************************************************************
 *                  Flowcode CAL ADC File
 *
 * File: PIC_CAL_ADC.c
 *
 * (c) 2011 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * “Company”) for its Flowcode graphical programming language is
 * intended and supplied to you, the Company’s customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 060911 | BR | Created
 * 200911 | BR | Updated to include all ADC type files
 */


//ADC Function Prototypes
void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge);
MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode);
void FC_CAL_Disable_ADC (void);


//ADC Global Variables
MX_UINT8 old_tris, tris_mask;
MX_UINT8 * tris_reg;					//TRIS register pointer


// ADC Type 1 Supported Devices ************************************************************
// 16F818, 16F819, 16F873A, 16F874A, 16F876A, 16F877A,
// *******************************************************************************************/

#ifdef MX_ADC_TYPE_1
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)

	{
		switch (Channel)
011B  292C  	GOTO	label18

		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
0118  084B  	MOVF FC_CAL_Ena_0005F_arg_Channel, W
0119  3A00  	XORLW 0x00
011A  1D03  	BTFSS STATUS,Z

					tris_mask = 0x01;
011C  3001  	MOVLW 0x01
011D  00C9  	MOVWF gbl_tris_mask

					tris_reg = &trisa;
011E  3000  	MOVLW HIGH(gbl_trisa+D'0')
011F  00BA  	MOVWF gbl_tris_reg+D'1'
0120  3085  	MOVLW LOW(gbl_trisa+D'0')
0121  00B9  	MOVWF gbl_tris_reg

					if (Vref == 0)
0122  08CD  	MOVF FC_CAL_Ena_0005F_arg_Vref, F
0123  1D03  	BTFSS STATUS,Z
0124  2929  	GOTO	label17
0129        label17

						adcon1 = 0x0E;
0125  300E  	MOVLW 0x0E
0126  1683  	BSF STATUS, RP0
0127  009F  	MOVWF gbl_adcon1

					else
0128  292C  	GOTO	label18
012C        label18

						adcon1 = 0x05;
0129  3005  	MOVLW 0x05
012A  1683  	BSF STATUS, RP0
012B  009F  	MOVWF gbl_adcon1

					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					if (Vref == 0)
						adcon1 = 0x04;
					else
						adcon1 = 0x05;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					if (Vref == 0)
						adcon1 = 0x02;
					else
						adcon1 = 0x03;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					if (Vref == 0)
						adcon1 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					if (Vref == 0)
						adcon1 = 0x02;
					else
						adcon1 = 0x03;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x01;
					tris_reg = &trise;
					if (Vref == 0)
						adcon1 = 0x09;
					else
						adcon1 = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trise;
					if (Vref == 0)
						adcon1 = 0x00;
					else
						adcon1 = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trise;
					if (Vref == 0)
						adcon1 = 0x00;
					else
						adcon1 = 0x01;
					break;
			#endif
		}

		if (Conv_Speed > 3)										//assign conversion speed
012C  1283  	BCF STATUS, RP0
012D  084C  	MOVF FC_CAL_Ena_0005F_arg_Conv_Speed, W
012E  3C03  	SUBLW 0x03
012F  1803  	BTFSC STATUS,C
0130  2933  	GOTO	label19

			st_bit(adcon1, ADCS2);
0131  1683  	BSF STATUS, RP0
0132  171F  	BSF gbl_adcon1,6


		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
0133  1383  	BCF STATUS,IRP
0134  1283  	BCF STATUS, RP0
0135  183A  	BTFSC gbl_tris_reg+D'1',0
0136  1783  	BSF STATUS,IRP
0137  0839  	MOVF gbl_tris_reg, W
0138  0084  	MOVWF FSR
0139  0800  	MOVF INDF, W
013A  00C8  	MOVWF gbl_old_tris

		*tris_reg = old_tris | tris_mask;
013B  0849  	MOVF gbl_tris_mask, W
013C  0448  	IORWF gbl_old_tris, W
013D  00CF  	MOVWF CompTempVar2232
013E  0080  	MOVWF INDF

		adcon0 = (0x01 | (Conv_Speed << 6)) | (Channel << 3);	//turn ADC on
013F  084C  	MOVF FC_CAL_Ena_0005F_arg_Conv_Speed, W
0140  00CF  	MOVWF CompTempVar2233
0141  01D0  	CLRF CompTempVar2234
0142  0DCF  	RLF CompTempVar2233, F
0143  0DD0  	RLF CompTempVar2234, F
0144  0DCF  	RLF CompTempVar2233, F
0145  0DD0  	RLF CompTempVar2234, F
0146  0DCF  	RLF CompTempVar2233, F
0147  0DD0  	RLF CompTempVar2234, F
0148  0DCF  	RLF CompTempVar2233, F
0149  0DD0  	RLF CompTempVar2234, F
014A  0DCF  	RLF CompTempVar2233, F
014B  0DD0  	RLF CompTempVar2234, F
014C  0DCF  	RLF CompTempVar2233, F
014D  0DD0  	RLF CompTempVar2234, F
014E  30C0  	MOVLW 0xC0
014F  054F  	ANDWF CompTempVar2233, W
0150  3801  	IORLW 0x01
0151  00D2  	MOVWF CompTempVar2237
0152  084B  	MOVF FC_CAL_Ena_0005F_arg_Channel, W
0153  00D1  	MOVWF CompTempVar2236
0154  0DD1  	RLF CompTempVar2236, F
0155  0DD1  	RLF CompTempVar2236, F
0156  0DD1  	RLF CompTempVar2236, F
0157  30F8  	MOVLW 0xF8
0158  0551  	ANDWF CompTempVar2236, W
0159  0452  	IORWF CompTempVar2237, W
015A  009F  	MOVWF gbl_adcon0

		delay_us(T_Charge);										//wait the acquisition time
015B  084E  	MOVF FC_CAL_Ena_0005F_arg_T_Charge, W
015C  00CF  	MOVWF delay_us_00000_arg_del
015D  204A  	CALL delay_us_00000

	}
015E  0008  	RETURN


	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)

	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x04;									//begin conversion and wait until it has finished
00CC  3004  	MOVLW 0x04
00CD  041F  	IORWF gbl_adcon0, W
00CE  009F  	MOVWF gbl_adcon0

		while (adcon0 & 0x04);
00CF        label11
00CF  191F  	BTFSC gbl_adcon0,2
00D0  28CF  	GOTO	label11

		if (Sample_Mode)
00D1  08CB  	MOVF FC_CAL_Sam_00060_arg_Sample_Mode, F
00D2  1903  	BTFSC STATUS,Z
00D3  28E8  	GOTO	label12
00E8        label12

		{
			iRetVal = (adresh << 2);							//10-bit ADC
00D4  081E  	MOVF gbl_adresh, W
00D5  00CC  	MOVWF FC_CAL_Sam_00060_1_iRetVal
00D6  01CD  	CLRF FC_CAL_Sam_00060_1_iRetVal+D'1'
00D7  0DCC  	RLF FC_CAL_Sam_00060_1_iRetVal, F
00D8  0DCD  	RLF FC_CAL_Sam_00060_1_iRetVal+D'1', F
00D9  0DCC  	RLF FC_CAL_Sam_00060_1_iRetVal, F
00DA  0DCD  	RLF FC_CAL_Sam_00060_1_iRetVal+D'1', F
00DB  30FC  	MOVLW 0xFC
00DC  05CC  	ANDWF FC_CAL_Sam_00060_1_iRetVal, F

			iRetVal = iRetVal | (adresl >> 6);
00DD  1683  	BSF STATUS, RP0
00DE  0C1E  	RRF gbl_adresl, W
00DF  1283  	BCF STATUS, RP0
00E0  00CE  	MOVWF CompTempVar2241
00E1  0CCE  	RRF CompTempVar2241, F
00E2  0ECE  	SWAPF CompTempVar2241, F
00E3  3003  	MOVLW 0x03
00E4  054E  	ANDWF CompTempVar2241, W
00E5  04CC  	IORWF FC_CAL_Sam_00060_1_iRetVal, F
00E6  08CD  	MOVF FC_CAL_Sam_00060_1_iRetVal+D'1', F

		}
		else
00E7  28EB  	GOTO	label13
00EB        label13

			iRetVal = adresh;									//8-bit ADC
00E8  081E  	MOVF gbl_adresh, W
00E9  00CC  	MOVWF FC_CAL_Sam_00060_1_iRetVal
00EA  01CD  	CLRF FC_CAL_Sam_00060_1_iRetVal+D'1'


		return (iRetVal);
00EB  084C  	MOVF FC_CAL_Sam_00060_1_iRetVal, W
00EC  00CE  	MOVWF CompTempVarRet2238
00ED  084D  	MOVF FC_CAL_Sam_00060_1_iRetVal+D'1', W
00EE  00CF  	MOVWF CompTempVarRet2238+D'1'

	}
00EF  0008  	RETURN


	void FC_CAL_Disable_ADC ()

	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
015F  1383  	BCF STATUS,IRP
0160  1283  	BCF STATUS, RP0
0161  1303  	BCF STATUS, RP1
0162  183A  	BTFSC gbl_tris_reg+D'1',0
0163  1783  	BSF STATUS,IRP
0164  0839  	MOVF gbl_tris_reg, W
0165  0084  	MOVWF FSR
0166  0848  	MOVF gbl_old_tris, W
0167  0080  	MOVWF INDF

		adcon1 = 0x07;
0168  3007  	MOVLW 0x07
0169  1683  	BSF STATUS, RP0
016A  009F  	MOVWF gbl_adcon1

		adcon0 = 0x00;
016B  1283  	BCF STATUS, RP0
016C  019F  	CLRF gbl_adcon0

	}
016D  0008  	RETURN

#endif


// ADC Type 2 Supported Devices ************************************************************
// 16F88
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_2
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		if (Vref == 1)											//assign VREF functionality
			st_bit(adcon1, VCFG1);

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ansel = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ansel = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ansel = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					ansel = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x10;
					tris_reg = &trisa;
					ansel = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x20;
					tris_reg = &trisb;
					ansel = 0x20;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x40;
					tris_reg = &trisb;
					ansel = 0x40;
					break;
			#endif
		}

		if (Conv_Speed > 3)										//assign conversion speed
			st_bit(adcon1, ADCS2);

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Conv_Speed << 6)) | (Channel << 3);	//turn ADC on
		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x04;									//begin conversion and wait until it has finished
		while (adcon0 & 0x04);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		ansel = 0x00;
		adcon0 = 0x00;
	}
#endif


// ADC Type 3 Supported Devices ************************************************************
// 16F616, 16F676, 16F677, 16F684, 16F685, 16F687, 16F688, 16F689, 16F690
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_3
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon1 = ((Conv_Speed & 0x07) << 4);				//assign conversion rate

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ansel = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ansel = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ansel = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x10;
					tris_reg = &trisa;
					ansel = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x01;
					tris_reg = &trisc;
					ansel = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x02;
					tris_reg = &trisc;
					ansel = 0x20;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x04;
					tris_reg = &trisc;
					ansel = 0x40;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x08;
					tris_reg = &trisc;
					ansel = 0x80;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x40;
					tris_reg = &trisc;
					anselh = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x80;
					tris_reg = &trisc;
					anselh = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x10;
					tris_reg = &trisb;
					anselh = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x20;
					tris_reg = &trisb;
					anselh = 0x08;
					break;
			#endif
		}

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on

		if (Vref == 1)											//assign VREF functionality
			st_bit(adcon0, VCFG);

		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x02;									//begin conversion and wait until it has finished
		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		ansel = 0x00;
		adcon0 = 0x00;
		#ifdef ANSELH
			anselh = 0x00;
		#endif
	}
#endif


// ADC Type 4 Supported Devices ************************************************************
// 16F737, 16F747, 16F767, 16F777
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_4
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon2 = 0x00;

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					adcon1 = 0x0E;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					adcon1 = 0x0D;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					adcon1 = 0x0C;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					adcon1 = 0x0B;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					adcon1 = 0x0A;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x01;
					tris_reg = &trise;
					adcon1 = 0x09;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trise;
					adcon1 = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trise;
					adcon1 = 0x07;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x04;
					tris_reg = &trisb;
					adcon1 = 0x06;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x08;
					tris_reg = &trisb;
					adcon1 = 0x05;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x02;
					tris_reg = &trisb;
					adcon1 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x10;
					tris_reg = &trisb;
					adcon1 = 0x03;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_12
				case (12):
					tris_mask = 0x01;
					tris_reg = &trisb;
					adcon1 = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_13
				case (13):
					tris_mask = 0x20;
					tris_reg = &trisb;
					adcon1 = 0x01;
					break;
			#endif
		}

		if (Vref == 1)											//assign VREF functionality
			st_bit(adcon1, VCFG0);

		if (Conv_Speed > 3)										//assign conversion speed
			st_bit(adcon1, ADCS2);

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Conv_Speed << 6));					//turn ADC on
		adcon0 = adcon0 | ((Channel & 0x07) << 3);
		adcon0 = adcon0 | ((Channel & 0x08) >> 2);
		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x04;									//begin conversion and wait until it has finished
		while (adcon0 & 0x04);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		adcon1 = 0x07;
		adcon0 = 0x00;
	}
#endif


// ADC Type 5 Supported Devices ************************************************************
// 12F615, 12HV615, 12F675, 12F683
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_5
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		tris_reg = &trisio;

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					ansel = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					ansel = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					ansel = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x10;
					ansel = 0x08;
					break;
			#endif
		}

		ansel = ansel | ((Conv_Speed & 0x07) << 4);				//assign conversion speed

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on

		if (Vref == 1)											//assign VREF functionality
			st_bit(adcon0, VCFG);

		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x02;									//begin conversion and wait until it has finished
		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		ansel = 0x00;
		adcon0 = 0x00;
	}
#endif


// ADC Type 6 Supported Devices ************************************************************
// 16C72, 16C72A, 16CR72, 16F72, 16C73, 16C73A, 16C73B, 16F73, 16C74, 16C74A, 16C74B, 16F74,
// 16C76, 16F76, 16C77, 16F77, 16C716, 16F716
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_6
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					adcon1 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					adcon1 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					adcon1 = 0x00;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					adcon1 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					adcon1 = 0x00;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x01;
					tris_reg = &trise;
					adcon1 = 0x00;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trise;
					adcon1 = 0x00;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trise;
					adcon1 = 0x00;
					break;
			#endif
		}

		if (Vref != 0)											//assign VREF functionality
			adcon1 = adcon1 + 1;

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Conv_Speed << 6)) | (Channel << 3);	//turn ADC on
		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x04;									//begin conversion and wait until it has finished
		while (adcon0 & 0x04);
		if (Sample_Mode)
		{
			iRetVal = (adres << 2);								//10-bit ADC
		}
		else
			iRetVal = adres;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		adcon1 = 0x07;
		adcon0 = 0x00;
	}
#endif



// ADC Type 7 Supported Devices ************************************************************
// 16F883, 16F884, 16F886, 16F887
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_7
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon1 = 0x00;

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ansel = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ansel = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ansel = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					ansel = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					ansel = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x01;
					tris_reg = &trise;
					ansel = 0x20;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trise;
					ansel = 0x40;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trise;
					ansel = 0x80;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x04;
					tris_reg = &trisb;
					anselh = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x08;
					tris_reg = &trisb;
					anselh = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x02;
					tris_reg = &trisb;
					anselh = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x10;
					tris_reg = &trisb;
					anselh = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_12
				case (13):
					tris_mask = 0x01;
					tris_reg = &trisb;
					anselh = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_13
				case (13):
					tris_mask = 0x20;
					tris_reg = &trisb;
					anselh = 0x20;
					break;
			#endif
		}

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Conv_Speed << 6)) | (Channel << 2);	//turn ADC on

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon0, VCFG0);

		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x02;									//begin conversion and wait until it has finished
		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		ansel = 0x00;
		adcon0 = 0x00;
		#ifdef ANSELH
			anselh = 0x00;
		#endif
	}
#endif


// ADC Type 8 Supported Devices ************************************************************
// 16F785
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_8
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ansel0 = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ansel0 = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ansel0 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x10;
					tris_reg = &trisa;
					ansel0 = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x01;
					tris_reg = &trisc;
					ansel0 = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x02;
					tris_reg = &trisc;
					ansel0 = 0x20;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x04;
					tris_reg = &trisc;
					ansel0 = 0x40;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x08;
					tris_reg = &trisc;
					ansel0 = 0x80;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x40;
					tris_reg = &trisc;
					ansel1 = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x80;
					tris_reg = &trisc;
					ansel1 = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x10;
					tris_reg = &trisb;
					ansel1 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x20;
					tris_reg = &trisb;
					ansel1 = 0x08;
					break;
			#endif
		}

		adcon1 = ((Conv_Speed & 0x07) << 4);					//assign conversion rate

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon0, VCFG);

		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x02;									//begin conversion and wait until it has finished
		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		ansel0 = 0x00;
		adcon0 = 0x00;
		#ifdef ANSEL1
			ansel1 = 0x00;
		#endif
	}
#endif


// ADC Type 9 Supported Devices ************************************************************
// 16F913, 16F914, 16F916, 16F917, 16F946
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_9
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ansel = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ansel = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ansel = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					ansel = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					ansel = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x01;
					tris_reg = &trise;
					ansel = 0x20;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trise;
					ansel = 0x40;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trise;
					ansel = 0x80;
					break;
			#endif
		}

		adcon1 = ((Conv_Speed & 0x07) << 4);					//assign conversion rate

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon0, VCFG0);

		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x02;									//begin conversion and wait until it has finished
		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		adcon0 = 0x00;
		ansel = 0x00;
	}
#endif


// ADC Type 10 Supported Devices ***********************************************************
// 12C671, 12C672, 12CE673, 12CE674
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_10
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		tris_reg = &trisio;

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					if (Vref == 0)
						adcon1 = 0x06;
					else
						adcon1 = 0x05;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					adcon1 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					if (Vref == 0)
						adcon1 = 0x02;
					else
						adcon1 = 0x03;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					if (Vref == 0)
						adcon1 = 0x00;
					else
						adcon1 = 0x01;
					break;
			#endif
		}

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Conv_Speed << 6)) | (Channel << 3);	//turn ADC on
		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x02;									//begin conversion and wait until it has finished
		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adres << 2);								//10-bit ADC
		}
		else
			iRetVal = adres;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		adcon1 = 0x07;
		adcon0 = 0x00;
	}
#endif


// ADC Type 11 Supported Devices ***********************************************************
// 16C717, 16C770, 16C771
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_11
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon1 = 0x00;

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ansel = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ansel = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ansel = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					ansel = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x01;
					tris_reg = &trisb;
					ansel = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x02;
					tris_reg = &trisb;
					ansel = 0x20;
					break;
			#endif
		}

		if (Conv_Speed > 3)										//assign conversion speed
			st_bit(adcon1, ADFM);

		if (Vref != 0)											//assign VREF functionality
		{
			st_bit(adcon1, VCFG0);
			st_bit(adcon1, VCFG1);
		}

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Conv_Speed << 6)) | (Channel << 3);	//turn ADC on
		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x04;									//begin conversion and wait until it has finished
		while (adcon0 & 0x04);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		adcon0 = 0x00;
		ansel = 0x00;
	}
#endif


// ADC Type 12 Supported Devices ***********************************************************
// 18F6310, 18F6390, 18F6410, 18F6490, 18F6520, 18F6527, 18F6585, 18F66J60, 18F66J65,
// 18F6620, 18F6622, 18F6627, 18F6680, 18F67J60, 18F6720, 18F6722, 18F8310, 18F8390,
// 18F8410, 18F8490, 18F8520, 18F8527, 18F8585, 18F86J60, 18F86J65, 18F8620, 18F8622,
// 18F8627, 18F8680, 18F87J60, 18F8720, 18F8722, 18F96J60, 18F96J65, 18F97J60
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_12
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon2 = Conv_Speed & 0x07;								//assign conversion rate

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					adcon1 = 0x0E;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					adcon1 = 0x0D;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					adcon1 = 0x0C;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					adcon1 = 0x0B;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					adcon1 = 0x0A;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x01;
					tris_reg = &trisf;
					adcon1 = 0x09;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trisf;
					adcon1 = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trisf;
					adcon1 = 0x07;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x08;
					tris_reg = &trisf;
					adcon1 = 0x06;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x10;
					tris_reg = &trisf;
					adcon1 = 0x05;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x20;
					tris_reg = &trisf;
					adcon1 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x40;
					tris_reg = &trisf;
					adcon1 = 0x03;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_12
				case (12):
					tris_mask = 0x10;
					tris_reg = &trish;
					adcon1 = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_13
				case (13):
					tris_mask = 0x20;
					tris_reg = &trish;
					adcon1 = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_14
				case (14):
					tris_mask = 0x40;
					tris_reg = &trish;
					adcon1 = 0x00;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_15
				case (15):
					tris_mask = 0x80;
					tris_reg = &trish;
					adcon1 = 0x00;
					break;
			#endif
		}

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon0, VCFG0);

		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x02;									//begin conversion and wait until it has finished
		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		adcon1 = 0x0f;
		adcon0 = 0x00;
	}
#endif


// ADC Type 13 Supported Devices ***********************************************************
// 18F2220, 18F2221, 18F2320, 18F2321, 18F24J10, 18F2410, 18F2420, 18F2423, 18F2450,
// 18F2455, 18F2480, 18F25J10, 18F2510, 18F2515, 18F2520, 18F2523, 18F2525, 18F2550,
// 18F2580, 18F2585, 18F2610, 18F2620, 18F2680, 18F4220, 18F4221, 18F4320, 18F4321,
// 18F44J10, 18F4410, 18F4420, 18F4423, 18F4450, 18F4455, 18F4480, 18F45J10, 18F4510,
// 18F4515, 18F4520, 18F4523, 18F4525, 18F4550, 18F4580, 18F4585, 18F4610, 18F4620,
// 18F4680, 18F4682, 18F4685
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_13
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon2 = Conv_Speed & 0x07;								//assign conversion rate

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					adcon1 = 0x0E;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					adcon1 = 0x0D;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					adcon1 = 0x0C;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					adcon1 = 0x0B;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					adcon1 = 0x0A;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x01;
					tris_reg = &trise;
					adcon1 = 0x09;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trise;
					adcon1 = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trise;
					adcon1 = 0x07;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x04;
					tris_reg = &trisb;
					adcon1 = 0x06;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x08;
					tris_reg = &trisb;
					adcon1 = 0x05;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x02;
					tris_reg = &trisb;
					adcon1 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x10;
					tris_reg = &trisb;
					adcon1 = 0x03;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_12
				case (12):
					tris_mask = 0x01;
					tris_reg = &trisb;
					adcon1 = 0x02;
					break;
			#endif
		}

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon0, VCFG0);

		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x02;									//begin conversion and wait until it has finished
		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
		  #ifdef MX_ADC_BITS_12
			iRetVal = (adresh << 4);							//12-bit ADC
			iRetVal = iRetVal | (adresl >> 4);
		  #else
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		  #endif
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		adcon1 = 0x0f;
		adcon0 = 0x00;
	}
#endif


// ADC Type 14 Supported Devices ***********************************************************
// 18F2331, 18F2431, 18F4331, 18F4431
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_14
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon1 = 0x00;											//set up ADC conversion
		adcon2 = Conv_Speed & 0x07;
		adcon3 = 0x00;
		adchs = 0x00;

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					adcon0 = 0x00;
					ansel0 = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					adcon0 = 0x04;
					ansel0 = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					adcon0 = 0x08;
					ansel0 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					adcon0 = 0x0C;
					ansel0 = 0x08;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x10;
					tris_reg = &trisa;
					adcon0 = 0x00;
					adchs = 0x01;
					ansel0 = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x20;
					tris_reg = &trisa;
					adcon0 = 0x04;
					adchs = 0x10;
					ansel0 = 0x20;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x01;
					tris_reg = &trise;
					adcon0 = 0x08;
					adchs = 0x04;
					ansel0 = 0x40;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x02;
					tris_reg = &trise;
					adcon0 = 0x0C;
					adchs = 0x40;
					ansel0 = 0x80;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x04;
					tris_reg = &trisb;
					adcon0 = 0x00;
					adchs = 0x02;
					ansel1 = 0x01;
					break;
			#endif
		}

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = adcon0 | 0x01;									//turn ADC on

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon0, VCFG0);

		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x02;									//begin conversion and wait until it has finished
		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		adcon0 = 0x00;
		ansel0 = 0x00;
		#ifdef ANSEL1
			ansel1 = 0x00;
		#endif
	}
#endif


// ADC Type 15 Supported Devices ***********************************************************
// 18F1220, 18F1320
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_15
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon2 = Conv_Speed & 0x07;								//assign conversion rate

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					adcon1 = 0x7E;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					adcon1 = 0x7D;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					adcon1 = 0x7B;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					adcon1 = 0x77;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x01;
					tris_reg = &trisb;
					adcon1 = 0x6F;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x02;
					tris_reg = &trisb;
					adcon1 = 0x5F;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x10;
					tris_reg = &trisb;
					adcon1 = 0x3F;
					break;
			#endif
		}

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon0, VCFG0);

		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x02;									//begin conversion and wait until it has finished
		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		adcon1 = 0x7f;
		adcon0 = 0x00;
	}
#endif


// ADC Type 16 Supported Devices ***********************************************************
// 18F242, 18F2439, 18F248, 18F252, 18F2539, 18F258, 18F442, 18F4439, 18F448, 18F452,
// 18F4539, 18F458
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_16
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					if (Vref != 0)
						adcon1 = 0x05;
					else
						adcon1 = 0x0E;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					if (Vref != 0)
						adcon1 = 0x05;
					else
						adcon1 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					if (Vref != 0)
						adcon1 = 0x03;
					else
						adcon1 = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					adcon1 = 0x04;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					if (Vref != 0)
						adcon1 = 0x03;
					else
						adcon1 = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x01;
					tris_reg = &trise;
					if (Vref != 0)
						adcon1 = 0x0A;
					else
						adcon1 = 0x09;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trise;
					if (Vref != 0)
						adcon1 = 0x01;
					else
						adcon1 = 0x00;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trise;
					if (Vref != 0)
						adcon1 = 0x01;
					else
						adcon1 = 0x00;
					break;
			#endif
		}

		if (Conv_Speed > 3)										//assign conversion speed
			st_bit(adcon1, ADCS2);

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Conv_Speed << 6)) | (Channel << 3);	//turn ADC on
		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x04;									//begin conversion and wait until it has finished
		while (adcon0 & 0x04);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		adcon1 = 0x07;
		adcon0 = 0x00;
	}
#endif


// ADC Type 17 Supported Devices ***********************************************************
// 18F1230, 18F1330
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_17
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon2 = Conv_Speed & 0x07;
		adcon1 = 0x00 | (0x01 << Channel);

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x10;
					tris_reg = &trisa;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x40;
					tris_reg = &trisa;
					break;
			#endif
		}

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon1, VCFG0);

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on
		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x02;									//begin conversion and wait until it has finished
		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		adcon1 = 0x00;
		adcon0 = 0x00;
	}
#endif


// ADC Type 18 Supported Devices ***********************************************************
// 16F722, 16F723, 16F724, 16F726, 16F727, 16F1933, 16F1934, 16F1936, 16F1937, 16F1939
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_18

	#ifndef ADREF1
		#define ADREF1 ADPREF1
	#endif

	MX_UINT8 * ansel_reg;					//ANSEL register pointer

	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon1 = (Conv_Speed & 0x07) << 4;						//assign conversion rate

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					ansel_reg = &ansela;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x01;
					tris_reg = &trise;
					ansel_reg = &ansele;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trise;
					ansel_reg = &ansele;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trise;
					ansel_reg = &ansele;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x04;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x08;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x02;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x10;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_12
				case (12):
					tris_mask = 0x01;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_13
				case (13):
					tris_mask = 0x20;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
		}

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon1, ADREF1);

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		*ansel_reg = *ansel_reg | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on
		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x02;									//begin conversion and wait until it has finished
		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		*ansel_reg = 0x00;
		adcon0 = 0x00;
	}
#endif


// ADC Type 19 Supported Devices ***********************************************************
// 18F13K50, 18F14K50, 18LF13K50, 18LF14K50
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_19
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon1 = 0;

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					ansel = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					ansel = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					ansel = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x10;
					tris_reg = &trisa;
					ansel = 0x08;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x01;
					tris_reg = &trisc;
					ansel = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x02;
					tris_reg = &trisc;
					ansel = 0x20;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x04;
					tris_reg = &trisc;
					ansel = 0x40;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x08;
					tris_reg = &trisc;
					adcon1 = 0x80;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x40;
					tris_reg = &trisc;
					anselh = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x80;
					tris_reg = &trisc;
					anselh = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x10;
					tris_reg = &trisb;
					anselh = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x20;
					tris_reg = &trisb;
					anselh = 0x08;
					break;
			#endif
		}

		adcon2 = Conv_Speed & 0x07;								//assign conversion rate

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon1, PVCFG0);

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on
		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x02;									//begin conversion and wait until it has finished
		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		ansel = 0;
		adcon0 = 0x00;
		#ifdef ANSELH
			anselh = 0;
		#endif
	}
#endif


// ADC Type 20 Supported Devices ***********************************************************
// 18F23K20, 18F24K20, 18F25K20, 18F26K20, 18F43K20, 18F44K20, 18F45K20, 18F16K20
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_20
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon1 = 0;

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ansel = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ansel = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ansel = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					ansel = 0x08;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					ansel = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x01;
					tris_reg = &trise;
					ansel = 0x20;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trise;
					ansel = 0x40;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trise;
					adcon1 = 0x80;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x04;
					tris_reg = &trisb;
					anselh = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x08;
					tris_reg = &trisb;
					anselh = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x02;
					tris_reg = &trisb;
					anselh = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x10;
					tris_reg = &trisb;
					anselh = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_12
				case (12):
					tris_mask = 0x01;
					tris_reg = &trisb;
					anselh = 0x10;
					break;
			#endif
		}

		adcon2 = Conv_Speed & 0x07;								//assign conversion rate

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon1, VCFG0);

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on
		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x02;									//begin conversion and wait until it has finished
		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		ansel = 0;
		adcon0 = 0x00;
		#ifdef ANSELH
			anselh = 0;
		#endif
	}
#endif


// ADC Type 21 Supported Devices ***********************************************************
// 18F2xJ11, 18F4xJ11
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_21
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon1 = 0;

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ancon0 = 0xFE;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ancon0 = 0xFD;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ancon0 = 0xFB;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					ancon0 = 0xF7;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					ancon0 = 0xEF;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x01;
					tris_reg = &trise;
					ancon0 = 0xDF;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trise;
					ancon0 = 0xBF;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trise;
					ancon0 = 0x7F;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x04;
					tris_reg = &trisb;
					ancon1 = 0x1E;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x08;
					tris_reg = &trisb;
					ancon1 = 0x1D;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x02;
					tris_reg = &trisb;
					ancon1 = 0x1B;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x10;
					tris_reg = &trisb;
					ancon1 = 0x17;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_12
				case (12):
					tris_mask = 0x01;
					tris_reg = &trisb;
					ancon1 = 0x0F;
					break;
			#endif
		}

		adcon1 = Conv_Speed & 0x07;								//assign conversion rate

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon0, VCFG0);

		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x02;									//begin conversion and wait until it has finished
		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		ancon0 = 0xFF;
		ancon1 = 0x1F;
		adcon0 = 0x00;
	}
#endif


// ADC Type 22 Supported Devices ***********************************************************
// 10F220, 10F222
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_22
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon0 = 0x00;

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					asm("movf 1,w");
					asm("tris 6");
					adcon0 = 0x40;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					asm("movf 2,w");
					asm("tris 6");
					adcon0 = 0x84;
					break;
			#endif
		}

		adcon0 = adcon0 | 0x01;									//turn ADC on
		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x02;									//begin conversion and wait until it has finished
		while (adcon0 & 0x02);
		if (Sample_Mode)
			iRetVal = (adres << 2);								//10-bit ADC
		else
			iRetVal = adres;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		adcon0 = 0x00;											//Reset ADC Registers
	}
#endif


// ADC Type 23 Supported Devices ***********************************************************
// 16F1826, 16F1827
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_23

	MX_UINT8 * ansel_reg;					//ANSEL register pointer

	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon1 = (Conv_Speed & 0x07) << 4;						//assign conversion rate

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					ansel_reg = &ansela;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x10;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x40;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x80;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x20;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x10;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x08;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x04;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x02;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
		}

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon1, ADPREF1);

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		*ansel_reg = *ansel_reg | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on
		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x02;									//begin conversion and wait until it has finished
		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		*ansel_reg = 0x00;
		adcon0 = 0x00;
	}
#endif


// ADC Type 24 Supported Devices ***********************************************************
// 18F65J50, 18F66J50, 18F66J55, 18F67J50, 18F85J50, 18F86J50, 18F86J55, 18F87J50
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_24
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon1 = (Conv_Speed & 0x07);

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ancon0 = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ancon0 = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ancon0 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					ancon0 = 0x08;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					ancon0 = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trisf;
					ancon0 = 0x80;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x20;
					tris_reg = &trisf;
					ancon1 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x40;
					tris_reg = &trisf;
					ancon1 = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_12
				case (12):
					tris_mask = 0x10;
					tris_reg = &trish;
					ancon1 = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_13
				case (13):
					tris_mask = 0x20;
					tris_reg = &trish;
					ancon1 = 0x20;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_14
				case (14):
					tris_mask = 0x40;
					tris_reg = &trish;
					ancon1 = 0x40;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_15
				case (15):
					tris_mask = 0x80;
					tris_reg = &trish;
					ancon1 = 0x80;
					break;
			#endif
		}

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon0, VCFG0);

		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x02;									//begin conversion and wait until it has finished
		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		ancon0 = 0x00;
		ancon1 = 0x00;
		adcon0 = 0x00;
	}
#endif


// ADC Type 25 Supported Devices ***********************************************************
// 18F66J93, 18F67J93, 18F86J93, 18F87J93, 18F66J90, 18F67J90, 18F86J90, 18F87J90
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_25
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon2 = Conv_Speed & 0x07;

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					adcon1 = 0x0E;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					adcon1 = 0x0D;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					adcon1 = 0x0C;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					adcon1 = 0x0B;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					adcon1 = 0x0A;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x80;
					tris_reg = &trisf;
					adcon1 = 0x09;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trisf;
					adcon1 = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trisf;
					adcon1 = 0x07;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x08;
					tris_reg = &trisf;
					adcon1 = 0x06;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x10;
					tris_reg = &trisf;
					adcon1 = 0x05;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x20;
					tris_reg = &trisf;
					adcon1 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x40;
					tris_reg = &trisf;
					adcon1 = 0x03;
					break;
			#endif
		}

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon1, VCFG0);

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on

		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x02;									//begin conversion and wait until it has finished
		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		adcon1 = 0x0f;
		adcon0 = 0x00;
	}
#endif


// ADC Type 26 Supported Devices ***********************************************************
// 16F1822, 16F1823, 16F1824, 16F1825, 16F1828, 16F1829
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_26

	MX_UINT8 * ansel_reg;					//ANSEL register pointer

	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon1 = (Conv_Speed & 0x07) << 4;						//assign conversion rate

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x10;
					tris_reg = &trisa;
					ansel_reg = &ansela;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x01;
					tris_reg = &trisc;
					ansel_reg = &anselc;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x02;
					tris_reg = &trisc;
					ansel_reg = &anselc;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x04;
					tris_reg = &trisc;
					ansel_reg = &anselc;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x08;
					tris_reg = &trisc;
					ansel_reg = &anselc;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x40;
					tris_reg = &trisc;
					ansel_reg = &anselc;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x80;
					tris_reg = &trisc;
					ansel_reg = &anselc;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x10;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x20;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
		}

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon1, ADPREF1);

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		*ansel_reg = *ansel_reg | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on
		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x02;									//begin conversion and wait until it has finished
		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		*ansel_reg = 0x00;
		adcon0 = 0x00;
	}
#endif


// ADC Type 27 Supported Devices ***********************************************************
// 16F1946, 16F1947
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_27

	MX_UINT8 * ansel_reg;					//ANSEL register pointer

	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon1 = (Conv_Speed & 0x07) << 4;						//assign conversion rate

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					ansel_reg = &ansela;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x80;
					tris_reg = &trisf;
					ansel_reg = &anself;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trisf;
					ansel_reg = &anself;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trisf;
					ansel_reg = &anself;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x08;
					tris_reg = &trisf;
					ansel_reg = &anself;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x10;
					tris_reg = &trisf;
					ansel_reg = &anself;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x20;
					tris_reg = &trisf;
					ansel_reg = &anself;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x40;
					tris_reg = &trisf;
					ansel_reg = &anself;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_12
				case (11):
					tris_mask = 0x10;
					tris_reg = &trisg;
					ansel_reg = &anselg;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_13
				case (11):
					tris_mask = 0x08;
					tris_reg = &trisg;
					ansel_reg = &anselg;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_14
				case (11):
					tris_mask = 0x04;
					tris_reg = &trisg;
					ansel_reg = &anselg;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_15
				case (11):
					tris_mask = 0x02;
					tris_reg = &trisg;
					ansel_reg = &anselg;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_16
				case (11):
					tris_mask = 0x01;
					tris_reg = &trisg;
					ansel_reg = &anselg;
					break;
			#endif
		}

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon1, ADPREF1);

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		*ansel_reg = *ansel_reg | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on
		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x02;									//begin conversion and wait until it has finished
		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		*ansel_reg = 0x00;
		adcon0 = 0x00;
	}
#endif


// ADC Type 28 Supported Devices ***********************************************************
// 18F65K22, 18F66K22, 18F67K22, 18F85K22, 18F86K22, 18F87K22,
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_28
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon2 = Conv_Speed & 0x07;

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ancon0 = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ancon0 = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ancon0 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					ancon0 = 0x08;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					ancon0 = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x80;
					tris_reg = &trisf;
					ancon0 = 0x20;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trisf;
					ancon0 = 0x40;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trisf;
					ancon0 = 0x80;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x08;
					tris_reg = &trisf;
					ancon1 = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x10;
					tris_reg = &trisf;
					ancon1 = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x20;
					tris_reg = &trisf;
					ancon1 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x40;
					tris_reg = &trisf;
					ancon1 = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_12
				case (12):
					tris_mask = 0x10;
					tris_reg = &trish;
					ancon1 = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_13
				case (13):
					tris_mask = 0x20;
					tris_reg = &trish;
					ancon1 = 0x20;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_14
				case (14):
					tris_mask = 0x40;
					tris_reg = &trish;
					ancon1 = 0x40;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_15
				case (15):
					tris_mask = 0x80;
					tris_reg = &trish;
					ancon1 = 0x80;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_16
				case (16):
					tris_mask = 0x10;
					tris_reg = &trisg;
					ancon2 = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_17
				case (17):
					tris_mask = 0x08;
					tris_reg = &trisg;
					ancon2 = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_18
				case (18):
					tris_mask = 0x04;
					tris_reg = &trisg;
					ancon2 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_19
				case (19):
					tris_mask = 0x02;
					tris_reg = &trisg;
					ancon2 = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_20
				case (20):
					tris_mask = 0x08;
					tris_reg = &trish;
					ancon2 = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_21
				case (21):
					tris_mask = 0x04;
					tris_reg = &trish;
					ancon2 = 0x20;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_22
				case (22):
					tris_mask = 0x02;
					tris_reg = &trish;
					ancon2 = 0x40;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_23
				case (23):
					tris_mask = 0x01;
					tris_reg = &trish;
					ancon2 = 0x80;
					break;
			#endif
		}

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon1, VCFG0);

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on

		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x02;									//begin conversion and wait until it has finished
		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 4);							//12-bit ADC
			iRetVal = iRetVal | (adresl >> 4);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		adcon0 = 0x00;
		ancon0 = 0x00;
		#ifdef ANCON1
			ancon1 = 0x00;
		#endif
		#ifdef ANCON2
			ancon2 = 0x00;
		#endif
	}
#endif


// ADC Type 29 Supported Devices ***********************************************************
// 18F23K22, 18F24K22, 18F25K22, 18F26K22, 18F43K22, 18F44K22, 18F45K22, 18F46K22,
// 18LF23K22, 18LF24K22, 18LF25K22, 18LF26K22, 18LF43K22, 18LF44K22, 18LF45K22, 18LF46K22,
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_29

	MX_UINT8 * ansel_reg;					//ANSEL register pointer

	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon2 = Conv_Speed & 0x07;

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					ansel_reg = &ansela;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x01;
					tris_reg = &trise;
					ansel_reg = &ansele;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trise;
					ansel_reg = &ansele;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trise;
					ansel_reg = &ansele;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x04;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x08;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x02;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x10;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_12
				case (12):
					tris_mask = 0x01;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_13
				case (13):
					tris_mask = 0x20;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_14
				case (14):
					tris_mask = 0x04;
					tris_reg = &trisc;
					ansel_reg = &anselc;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_15
				case (15):
					tris_mask = 0x08;
					tris_reg = &trisc;
					ansel_reg = &anselc;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_16
				case (16):
					tris_mask = 0x10;
					tris_reg = &trisc;
					ansel_reg = &anselc;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_17
				case (17):
					tris_mask = 0x20;
					tris_reg = &trisc;
					ansel_reg = &anselc;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_18
				case (18):
					tris_mask = 0x40;
					tris_reg = &trisc;
					ansel_reg = &anselc;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_19
				case (19):
					tris_mask = 0x80;
					tris_reg = &trisc;
					ansel_reg = &anselc;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_20
				case (20):
					tris_mask = 0x01;
					tris_reg = &trisd;
					ansel_reg = &anseld;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_21
				case (21):
					tris_mask = 0x02;
					tris_reg = &trisd;
					ansel_reg = &anseld;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_22
				case (22):
					tris_mask = 0x04;
					tris_reg = &trisd;
					ansel_reg = &anseld;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_23
				case (23):
					tris_mask = 0x08;
					tris_reg = &trisd;
					ansel_reg = &anseld;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_24
				case (24):
					tris_mask = 0x10;
					tris_reg = &trisd;
					ansel_reg = &anseld;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_25
				case (25):
					tris_mask = 0x20;
					tris_reg = &trisd;
					ansel_reg = &anseld;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_26
				case (26):
					tris_mask = 0x40;
					tris_reg = &trisd;
					ansel_reg = &anseld;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_27
				case (27):
					tris_mask = 0x80;
					tris_reg = &trisd;
					ansel_reg = &anseld;
					break;
			#endif
		}

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon1, PVCFG0);

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		*ansel_reg = ansel_reg | tris_mask;

		adcon0 = (0x01 | (Channel << 2));						//turn ADC on

		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x02;									//begin conversion and wait until it has finished
		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		*ansel_reg = 0x00;
		adcon0 = 0x00;
	}
#endif


// ADC Type 30 Supported Devices ************************************************************
// 16F870, 16F871, 16F872, 16F873, 16F874, 16F876, 16F877
// *******************************************************************************************/

#ifdef MX_ADC_TYPE_30
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					if (Vref == 0)
						adcon1 = 0x0E;
					else
						adcon1 = 0x05;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					if (Vref == 0)
						adcon1 = 0x04;
					else
						adcon1 = 0x05;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					if (Vref == 0)
						adcon1 = 0x02;
					else
						adcon1 = 0x03;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					if (Vref == 0)
						adcon1 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					if (Vref == 0)
						adcon1 = 0x02;
					else
						adcon1 = 0x03;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x01;
					tris_reg = &trise;
					if (Vref == 0)
						adcon1 = 0x09;
					else
						adcon1 = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trise;
					if (Vref == 0)
						adcon1 = 0x00;
					else
						adcon1 = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trise;
					if (Vref == 0)
						adcon1 = 0x00;
					else
						adcon1 = 0x01;
					break;
			#endif
		}

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Conv_Speed << 6)) | (Channel << 3);	//turn ADC on
		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x04;									//begin conversion and wait until it has finished
		while (adcon0 & 0x04);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		adcon1 = 0x07;
		adcon0 = 0x00;
	}
#endif

/*********************************************************************
 *                  Flowcode CAL PWM File
 *
 * File: PIC_CAL_PWM.c
 *
 * (c) 2011 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * “Company”) for its Flowcode graphical programming language is
 * intended and supplied to you, the Company’s customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 270911 | BR | Created
 * 021211 | BR | Converted to new dynamic defines mechanism
 *
 */


#define MX_PWM_CHANNEL_X		CAL_APPEND(MX_PWM_CHANNEL_, MX_PWM_NUM)
#define MX_PWM_HWALT_X			CAL_APPEND(MX_PWM_HWALT_, MX_PWM_NUM)


//I2C Master Functions
CALFUNCTION(void, FC_CAL_PWM_Enable_Channel_, (void));
CALFUNCTION(void, FC_CAL_PWM_Disable_Channel_, (void));
CALFUNCTION(void, FC_CAL_PWM_Set_Duty_8Bit_, (MX_UINT8 duty));
CALFUNCTION(void, FC_CAL_PWM_Change_Period_, (MX_UINT8 period, MX_UINT16 prescaler));
CALFUNCTION(void, FC_CAL_PWM_Set_Duty_10Bit_, (MX_UINT16 duty));


CALFUNCTION(void, FC_CAL_PWM_Enable_Channel_, (void))

{

 #ifdef MX_PWM

	#if (MX_PWM_CHANNEL_X == 1)
	  #ifdef MX_PWM_REMAPPABLE
	  	RPOR3 = 14;														//PWM1 - 14 - RB0 - RP3
	  #endif

		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
		  #ifndef MX_PWM_1_PORT											//Error checking
			#error "This chip does not have PWM channel 1 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_1_PORT, MX_PWM_1_TRIS, MX_PWM_1_PIN);			//PWM pin is an output
		#else															//Alternate PWM Pin
		  #ifndef MX_PWM_1_PORT_A										//Error checking
			#error "This chip does not have PWM alt channel 1 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_1_PORT_A, MX_PWM_1_TRIS_A, MX_PWM_1_PIN_A);		//PWM pin is an output
		#endif

		ccp1con = 0x0C;													//Enable Capture Compare Channel 1
	#endif

	#if (MX_PWM_CHANNEL_X == 2)
	  #ifdef MX_PWM_REMAPPABLE
	  	RPOR4 = 18;														//PWM2 - 18 - RB1 - RP4
	  #endif

		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
		  #ifndef MX_PWM_2_PORT											//Error checking
			#error "This chip does not have PWM channel 2 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_2_PORT, MX_PWM_2_TRIS, MX_PWM_2_PIN);			//PWM pin is an output
0110  1683  	BSF STATUS, RP0
0111  1303  	BCF STATUS, RP1
0112  1087  	BCF gbl_trisc,1
0113  1283  	BCF STATUS, RP0
0114  1087  	BCF gbl_portc,1

		#else															//Alternate PWM Pin
		  #ifndef MX_PWM_2_PORT_A										//Error checking
			#error "This chip does not have PWM alt channel 2 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_2_PORT_A, MX_PWM_2_TRIS_A, MX_PWM_2_PIN_A);		//PWM pin is an output
		#endif

		ccp2con = 0x0C;													//Enable Capture Compare Channel 2
0115  300C  	MOVLW 0x0C
0116  009D  	MOVWF gbl_ccp2con

	#endif

	#if (MX_PWM_CHANNEL_X == 3)
	  #ifdef MX_PWM_REMAPPABLE
	  	RPOR5 = 22;														//PWM3 - 22 - RB2 - RP5
	  #endif

		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
		  #ifndef MX_PWM_3_PORT											//Error checking
			#error "This chip does not have PWM channel 3 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_3_PORT, MX_PWM_3_TRIS, MX_PWM_3_PIN);			//PWM pin is an output
		#else															//Alternate PWM Pin
		  #ifndef MX_PWM_3_PORT_A										//Error checking
			#error "This chip does not have PWM alt channel 3 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_3_PORT_A, MX_PWM_3_TRIS_A, MX_PWM_3_PIN_A);		//PWM pin is an output
		#endif

		ccp3con = 0x0C;													//Enable Capture Compare Channel 3 *****************************************************************
	#endif

	#if (MX_PWM_CHANNEL_X == 4)
		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
		  #ifndef MX_PWM_4_PORT											//Error checking
			#error "This chip does not have PWM channel 4 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_4_PORT, MX_PWM_4_TRIS, MX_PWM_4_PIN);			//PWM pin is an output
		#else															//Alternate PWM Pin
		  #ifndef MX_PWM_4_PORT_A										//Error checking
			#error "This chip does not have PWM alt channel 4 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_4_PORT_A, MX_PWM_4_TRIS_A, MX_PWM_4_PIN_A);		//PWM pin is an output
		#endif

		ccp4con = 0x0C;													//Enable Capture Compare Channel 4 *****************************************************************
	#endif

	#if (MX_PWM_CHANNEL_X == 5)
		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
		  #ifndef MX_PWM_5_PORT											//Error checking
			#error "This chip does not have PWM channel 5 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_5_PORT, MX_PWM_5_TRIS, MX_PWM_5_PIN);			//PWM pin is an output
		#else															//Alternate PWM Pin
		  #ifndef MX_PWM_5_PORT_A										//Error checking
			#error "This chip does not have PWM alt channel 5 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_5_PORT_A, MX_PWM_5_TRIS_A, MX_PWM_5_PIN_A);		//PWM pin is an output
		#endif

		ccp5con = 0x0C;													//Enable Capture Compare Channel 5 *****************************************************************
	#endif

	#if (MX_PWM_CHANNEL_X == 6)
		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
		  #ifndef MX_PWM_6_PORT											//Error checking
			#error "This chip does not have PWM channel 6 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_6_PORT, MX_PWM_6_TRIS, MX_PWM_6_PIN);			//PWM pin is an output
		#else															//Alternate PWM Pin
		  #ifndef MX_PWM_6_PORT_A										//Error checking
			#error "This chip does not have PWM alt channel 6 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_6_PORT_A, MX_PWM_6_TRIS_A, MX_PWM_6_PIN_A);		//PWM pin is an output
		#endif

		ccp6con = 0x0C;													//Enable Capture Compare Channel 6 *****************************************************************
	#endif

	#if (MX_PWM_CHANNEL_X == 7)
		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
		  #ifndef MX_PWM_7_PORT											//Error checking
			#error "This chip does not have PWM channel 7 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_7_PORT, MX_PWM_7_TRIS, MX_PWM_7_PIN);			//PWM pin is an output
		#else															//Alternate PWM Pin
		  #ifndef MX_PWM_7_PORT_A										//Error checking
			#error "This chip does not have PWM alt channel 7 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_7_PORT_A, MX_PWM_7_TRIS_A, MX_PWM_7_PIN_A);		//PWM pin is an output
		#endif

		ccp7con = 0x0C;													//Enable Capture Compare Channel 5 *****************************************************************
	#endif

	#if (MX_PWM_CHANNEL_X == 8)
		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
		  #ifndef MX_PWM_8_PORT											//Error checking
			#error "This chip does not have PWM channel 8 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_8_PORT, MX_PWM_8_TRIS, MX_PWM_8_PIN);			//PWM pin is an output
		#else															//Alternate PWM Pin
		  #ifndef MX_PWM_8_PORT_A										//Error checking
			#error "This chip does not have PWM alt channel 8 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_8_PORT_A, MX_PWM_8_TRIS_A, MX_PWM_8_PIN_A);		//PWM pin is an output
		#endif

		ccp8con = 0x0C;													//Enable Capture Compare Channel 8 *****************************************************************
	#endif

	#if (MX_PWM_CHANNEL_X == 9)
		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
		  #ifndef MX_PWM_9_PORT											//Error checking
			#error "This chip does not have PWM channel 9 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_9_PORT, MX_PWM_9_TRIS, MX_PWM_9_PIN);			//PWM pin is an output
		#else															//Alternate PWM Pin
		  #ifndef MX_PWM_9_PORT_A										//Error checking
			#error "This chip does not have PWM alt channel 9 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_9_PORT_A, MX_PWM_9_TRIS_A, MX_PWM_9_PIN_A);		//PWM pin is an output
		#endif

		ccp9con = 0x0C;													//Enable Capture Compare Channel 9 *****************************************************************
	#endif

	#if (MX_PWM_CHANNEL_X == 10)
		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
		  #ifndef MX_PWM_10_PORT											//Error checking
			#error "This chip does not have PWM channel 10 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_10_PORT, MX_PWM_10_TRIS, MX_PWM_10_PIN);			//PWM pin is an output
		#else															//Alternate PWM Pin
		  #ifndef MX_PWM_10_PORT_A										//Error checking
			#error "This chip does not have PWM alt channel 10 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_10_PORT_A, MX_PWM_10_TRIS_A, MX_PWM_10_PIN_A);		//PWM pin is an output
		#endif

		ccp10con = 0x0C;												//Enable Capture Compare Channel 10 *****************************************************************
	#endif

 #else
 	#error "Hardware PWM not supported by Target microcontroller."
 #endif

}
0117  0008  	RETURN



CALFUNCTION(void, FC_CAL_PWM_Disable_Channel_, (void))
{
	#if (MX_PWM_CHANNEL_X == 1)
		ccp1con = 0x00;													//Disable Capture Compare Channel 1
		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_1_PORT, MX_PWM_1_TRIS, MX_PWM_1_PIN);			//PWM pin is an input
		#else															//Alternate PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_1_PORT_A, MX_PWM_1_TRIS_A, MX_PWM_1_PIN_A);		//PWM pin is an input
		#endif
	#endif

	#if (MX_PWM_CHANNEL_X == 2)
		ccp2con = 0x00;													//Disable Capture Compare Channel 2
		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_2_PORT, MX_PWM_2_TRIS, MX_PWM_2_PIN);			//PWM pin is an input
		#else															//Alternate PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_2_PORT_A, MX_PWM_2_TRIS_A, MX_PWM_2_PIN_A);		//PWM pin is an input
		#endif
	#endif

	#if (MX_PWM_CHANNEL_X == 3)
		ccp3con = 0x00;													//Disable Capture Compare Channel 3
		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_3_PORT, MX_PWM_3_TRIS, MX_PWM_3_PIN);			//PWM pin is an input
		#else															//Alternate PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_3_PORT_A, MX_PWM_3_TRIS_A, MX_PWM_3_PIN_A);		//PWM pin is an input
		#endif
	#endif

	#if (MX_PWM_CHANNEL_X == 4)
		ccp4con = 0x00;													//Disable Capture Compare Channel 4
		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_4_PORT, MX_PWM_4_TRIS, MX_PWM_4_PIN);			//PWM pin is an input
		#else															//Alternate PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_4_PORT_A, MX_PWM_4_TRIS_A, MX_PWM_4_PIN_A);		//PWM pin is an input
		#endif
	#endif

	#if (MX_PWM_CHANNEL_X == 5)
		ccp5con = 0x00;													//Disable Capture Compare Channel 5
		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_5_PORT, MX_PWM_5_TRIS, MX_PWM_5_PIN);			//PWM pin is an input
		#else															//Alternate PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_5_PORT_A, MX_PWM_5_TRIS_A, MX_PWM_5_PIN_A);		//PWM pin is an input
		#endif
	#endif

	#if (MX_PWM_CHANNEL_X == 6)
		ccp6con = 0x00;													//Disable Capture Compare Channel 6
		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_6_PORT, MX_PWM_6_TRIS, MX_PWM_6_PIN);			//PWM pin is an input
		#else															//Alternate PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_6_PORT_A, MX_PWM_6_TRIS_A, MX_PWM_6_PIN_A);		//PWM pin is an input
		#endif
	#endif

	#if (MX_PWM_CHANNEL_X == 7)
		ccp7con = 0x00;													//Disable Capture Compare Channel 7
		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_7_PORT, MX_PWM_7_TRIS, MX_PWM_7_PIN);			//PWM pin is an input
		#else															//Alternate PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_7_PORT_A, MX_PWM_7_TRIS_A, MX_PWM_7_PIN_A);		//PWM pin is an input
		#endif
	#endif

	#if (MX_PWM_CHANNEL_X == 8)
		ccp8con = 0x00;													//Disable Capture Compare Channel 8
		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_8_PORT, MX_PWM_8_TRIS, MX_PWM_8_PIN);			//PWM pin is an input
		#else															//Alternate PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_8_PORT_A, MX_PWM_8_TRIS_A, MX_PWM_8_PIN_A);		//PWM pin is an input
		#endif
	#endif

	#if (MX_PWM_CHANNEL_X == 9)
		ccp9con = 0x00;													//Disable Capture Compare Channel 9
		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_9_PORT, MX_PWM_9_TRIS, MX_PWM_9_PIN);			//PWM pin is an input
		#else															//Alternate PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_9_PORT_A, MX_PWM_9_TRIS_A, MX_PWM_9_PIN_A);		//PWM pin is an input
		#endif
	#endif

	#if (MX_PWM_CHANNEL_X == 10)
		ccp10con = 0x00;												//Disable Capture Compare Channel 10
		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_10_PORT, MX_PWM_10_TRIS, MX_PWM_10_PIN);			//PWM pin is an input
		#else															//Alternate PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_10_PORT_A, MX_PWM_10_TRIS_A, MX_PWM_10_PIN_A);		//PWM pin is an input
		#endif
	#endif
}


CALFUNCTION(void, FC_CAL_PWM_Set_Duty_8Bit_, (MX_UINT8 duty))

{
	#if (MX_PWM_CHANNEL_X == 1)
		ccpr1l = duty;													//Update Capture Compare Count 1
	#endif

	#if (MX_PWM_CHANNEL_X == 2)
		ccpr2l = duty;													//Update Capture Compare Count 2
0088  084B  	MOVF FC_CAL_PWM_00070_arg_duty, W
0089  009B  	MOVWF gbl_ccpr2l

	#endif

	#if (MX_PWM_CHANNEL_X == 3)
		ccpr3l = duty;													//Update Capture Compare Count 3
	#endif

	#if (MX_PWM_CHANNEL_X == 4)
		ccpr4l = duty;													//Update Capture Compare Count 4
	#endif

	#if (MX_PWM_CHANNEL_X == 5)
		ccpr5l = duty;													//Update Capture Compare Count 5
	#endif

	#if (MX_PWM_CHANNEL_X == 6)
		ccpr6l = duty;													//Update Capture Compare Count 6
	#endif

	#if (MX_PWM_CHANNEL_X == 7)
		ccpr7l = duty;													//Update Capture Compare Count 7
	#endif

	#if (MX_PWM_CHANNEL_X == 8)
		ccpr8l = duty;													//Update Capture Compare Count 8
	#endif

	#if (MX_PWM_CHANNEL_X == 9)
		ccpr9l = duty;													//Update Capture Compare Count 9
	#endif

	#if (MX_PWM_CHANNEL_X == 10)
		ccpr10l = duty;													//Update Capture Compare Count 10
	#endif
}
008A  0008  	RETURN



CALFUNCTION(void, FC_CAL_PWM_Change_Period_, (MX_UINT8 period, MX_UINT16 prescaler))

{
  #ifdef MX_PWM								//Hardware Mode
	pr2 = period;
00F0  084A  	MOVF FC_CAL_PWM_00071_arg_period, W
00F1  1683  	BSF STATUS, RP0
00F2  0092  	MOVWF gbl_pr2

	switch (prescaler)
	{
	  #ifdef MX_PWM_PSCA1
		case 1:
00F3  3001  	MOVLW 0x01
00F4  1283  	BCF STATUS, RP0
00F5  064B  	XORWF FC_CAL_PWM_00071_arg_prescaler, W
00F6  1903  	BTFSC STATUS,Z
00F7  084C  	MOVF FC_CAL_PWM_00071_arg_prescaler+D'1', W
00F8  1903  	BTFSC STATUS,Z
00F9  2907  	GOTO	label14
0107        label14

			t2con = 0x04;
0107  3004  	MOVLW 0x04
0108  0092  	MOVWF gbl_t2con

			break;
	  #endif
	  #ifdef MX_PWM_PSCA4
		case 4:
00FA  3004  	MOVLW 0x04
00FB  064B  	XORWF FC_CAL_PWM_00071_arg_prescaler, W
00FC  1903  	BTFSC STATUS,Z
00FD  084C  	MOVF FC_CAL_PWM_00071_arg_prescaler+D'1', W
00FE  1903  	BTFSC STATUS,Z
00FF  290A  	GOTO	label15
010A        label15

			t2con = 0x05;
010A  3005  	MOVLW 0x05
010B  0092  	MOVWF gbl_t2con

			break;
	  #endif
	  #ifdef MX_PWM_PSCA16
		case 16:
0100  3010  	MOVLW 0x10
0101  064B  	XORWF FC_CAL_PWM_00071_arg_prescaler, W
0102  1903  	BTFSC STATUS,Z
0103  084C  	MOVF FC_CAL_PWM_00071_arg_prescaler+D'1', W
0104  1903  	BTFSC STATUS,Z
0105  290D  	GOTO	label16
010D        label16

			t2con = 0x06;
010D  3006  	MOVLW 0x06
010E  0092  	MOVWF gbl_t2con

			break;
	  #endif
	  #ifdef MX_PWM_PSCA64
		case 64:
			t2con = 0x07;					//Note some earlier devices do not have the /64 option
			break;
	  #endif
	}
  #endif
}
0106  0008  	RETURN
0109  0008  	RETURN
010C  0008  	RETURN
010F  0008  	RETURN



CALFUNCTION(void, FC_CAL_PWM_Set_Duty_10Bit_, (MX_UINT16 duty))
{
	char nCCPxCONtemp;

	#if (MX_PWM_CHANNEL_X == 1)
		ccpr1l = (duty & 0x3FC) >> 2;									//Update Capture Compare Count 1
		duty = (duty & 0x03) << 4;
		nCCPxCONtemp = (ccp1con & 0xCF) | duty;
		ccp1con = nCCPxCONtemp;
	#endif

	#if (MX_PWM_CHANNEL_X == 2)
		ccpr2l = (duty & 0x3FC) >> 2;									//Update Capture Compare Count 2
		duty = (duty & 0x03) << 4;
		nCCPxCONtemp = (ccp2con & 0xCF) | duty;
		ccp2con = nCCPxCONtemp;
	#endif

	#if (MX_PWM_CHANNEL_X == 3)
		ccpr3l = (duty & 0x3FC) >> 2;									//Update Capture Compare Count 3
		duty = (duty & 0x03) << 4;
		nCCPxCONtemp = (ccp3con & 0xCF) | duty;
		ccp3con = nCCPxCONtemp;
	#endif

	#if (MX_PWM_CHANNEL_X == 4)
		ccpr4l = (duty & 0x3FC) >> 2;									//Update Capture Compare Count 4
		duty = (duty & 0x03) << 4;
		nCCPxCONtemp = (ccp4con & 0xCF) | duty;
		ccp4con = nCCPxCONtemp;
	#endif

	#if (MX_PWM_CHANNEL_X == 5)
		ccpr5l = (duty & 0x3FC) >> 2;									//Update Capture Compare Count 5
		duty = (duty & 0x03) << 4;
		nCCPxCONtemp = (ccp5con & 0xCF) | duty;
		ccp5con = nCCPxCONtemp;
	#endif

	#if (MX_PWM_CHANNEL_X == 6)
		ccpr6l = (duty & 0x3FC) >> 2;									//Update Capture Compare Count 6
		duty = (duty & 0x03) << 4;
		nCCPxCONtemp = (ccp6con & 0xCF) | duty;
		ccp6con = nCCPxCONtemp;
	#endif

	#if (MX_PWM_CHANNEL_X == 7)
		ccpr7l = (duty & 0x3FC) >> 2;									//Update Capture Compare Count 7
		duty = (duty & 0x03) << 4;
		nCCPxCONtemp = (ccp7con & 0xCF) | duty;
		ccp7con = nCCPxCONtemp;
	#endif

	#if (MX_PWM_CHANNEL_X == 8)
		ccpr8l = (duty & 0x3FC) >> 2;									//Update Capture Compare Count 8
		duty = (duty & 0x03) << 4;
		nCCPxCONtemp = (ccp8con & 0xCF) | duty;
		ccp8con = nCCPxCONtemp;
	#endif

	#if (MX_PWM_CHANNEL_X == 9)
		ccpr9l = (duty & 0x3FC) >> 2;									//Update Capture Compare Count 9
		duty = (duty & 0x03) << 4;
		nCCPxCONtemp = (ccp9con & 0xCF) | duty;
		ccp9con = nCCPxCONtemp;
	#endif

	#if (MX_PWM_CHANNEL_X == 10)
		ccpr10l = (duty & 0x3FC) >> 2;									//Update Capture Compare Count 10
		duty = (duty & 0x03) << 4;
		nCCPxCONtemp = (ccp10con & 0xCF) | duty;
		ccp10con = nCCPxCONtemp;
	#endif
}


////////////////////////////////////////
// Code with no source :-)
////////////////////////////////////////
0000  2CF9  	GOTO	_startup

0004  00FF  	MOVWF Int1Context
0005  0E03  	SWAPF STATUS, W
0006  1283  	BCF STATUS, RP0
0007  1303  	BCF STATUS, RP1
0008  00B4  	MOVWF Int1BContext
0009  0E0A  	SWAPF PCLATH, W
000A  00B5  	MOVWF Int1BContext+D'1'
000B  0E04  	SWAPF FSR, W
000C  00B6  	MOVWF Int1BContext+D'2'
000D  118A  	BCF PCLATH,3
000E  120A  	BCF PCLATH,4
000F  2D29  	GOTO	interrupt
0010        delay_ms_00000
0010        ; { delay_ms ; function begin
0010  08D1  	MOVF delay_ms_00000_arg_del, F
0011  1D03  	BTFSS STATUS,Z
0012  2814  	GOTO	label1
0013  0008  	RETURN
0014        label1
0014  30F9  	MOVLW 0xF9
0015        label2
0015  0000  	NOP
0016  0000  	NOP
0017  0000  	NOP
0018  0000  	NOP
0019  0000  	NOP
001A  0000  	NOP
001B  0000  	NOP
001C  0000  	NOP
001D  0000  	NOP
001E  0000  	NOP
001F  0000  	NOP
0020  0000  	NOP
0021  0000  	NOP
0022  0000  	NOP
0023  0000  	NOP
0024  0000  	NOP
0025  3EFF  	ADDLW 0xFF
0026  1D03  	BTFSS STATUS,Z
0027  2815  	GOTO	label2
0028  0000  	NOP
0029  0000  	NOP
002A  0000  	NOP
002B  0000  	NOP
002C  0000  	NOP
002D  0000  	NOP
002E  0000  	NOP
002F  0000  	NOP
0030  0000  	NOP
0031  0000  	NOP
0032  0000  	NOP
0033  0000  	NOP
0034  0000  	NOP
0035  0000  	NOP
0036  0000  	NOP
0037  0000  	NOP
0038  0000  	NOP
0039  0BD1  	DECFSZ delay_ms_00000_arg_del, F
003A  2814  	GOTO	label1
003B  0008  	RETURN
003C        ; } delay_ms function end

003C        delay_10us_00000
003C        ; { delay_10us ; function begin
003C  08E0  	MOVF delay_10us_00000_arg_del, F
003D  1D03  	BTFSS STATUS,Z
003E  2840  	GOTO	label3
003F  0008  	RETURN
0040        label3
0040  3009  	MOVLW 0x09
0041        label4
0041  0000  	NOP
0042  3EFF  	ADDLW 0xFF
0043  1D03  	BTFSS STATUS,Z
0044  2841  	GOTO	label4
0045  0000  	NOP
0046  0000  	NOP
0047  0BE0  	DECFSZ delay_10us_00000_arg_del, F
0048  2840  	GOTO	label3
0049  0008  	RETURN
004A        ; } delay_10us function end

004A        delay_us_00000
004A        ; { delay_us ; function begin
004A        label5
004A  0000  	NOP
004B  0000  	NOP
004C  0BCF  	DECFSZ delay_us_00000_arg_del, F
004D  284A  	GOTO	label5
004E  0008  	RETURN
004F        ; } delay_us function end

004F        delay_s_00000
004F        ; { delay_s ; function begin
004F        label6
004F  30FA  	MOVLW 0xFA
0050  00D1  	MOVWF delay_ms_00000_arg_del
0051  2010  	CALL delay_ms_00000
0052  30FA  	MOVLW 0xFA
0053  00D1  	MOVWF delay_ms_00000_arg_del
0054  2010  	CALL delay_ms_00000
0055  30FA  	MOVLW 0xFA
0056  00D1  	MOVWF delay_ms_00000_arg_del
0057  2010  	CALL delay_ms_00000
0058  30FA  	MOVLW 0xFA
0059  00D1  	MOVWF delay_ms_00000_arg_del
005A  2010  	CALL delay_ms_00000
005B  0BCA  	DECFSZ delay_s_00000_arg_del, F
005C  284F  	GOTO	label6
005D  0008  	RETURN
005E        ; } delay_s function end

005E        __div_16_1_00003
005E        ; { __div_16_16 ; function begin
005E  01D7  	CLRF __div_16_1_00003_1_r
005F  01D8  	CLRF __div_16_1_00003_1_r+D'1'
0060  01DA  	CLRF CompTempVarRet214
0061  01DB  	CLRF CompTempVarRet214+D'1'
0062  01D9  	CLRF __div_16_1_00003_1_i
0063        label7
0063  1A59  	BTFSC __div_16_1_00003_1_i,4
0064  0008  	RETURN
0065  1003  	BCF STATUS,C
0066  0DDA  	RLF CompTempVarRet214, F
0067  0DDB  	RLF CompTempVarRet214+D'1', F
0068  0DD1  	RLF __div_16_1_00003_arg_a, F
0069  0DD2  	RLF __div_16_1_00003_arg_a+D'1', F
006A  0DD7  	RLF __div_16_1_00003_1_r, F
006B  0DD8  	RLF __div_16_1_00003_1_r+D'1', F
006C  0854  	MOVF __div_16_1_00003_arg_b+D'1', W
006D  0258  	SUBWF __div_16_1_00003_1_r+D'1', W
006E  1D03  	BTFSS STATUS,Z
006F  2872  	GOTO	label8
0070  0853  	MOVF __div_16_1_00003_arg_b, W
0071  0257  	SUBWF __div_16_1_00003_1_r, W
0072        label8
0072  1C03  	BTFSS STATUS,C
0073  287B  	GOTO	label9
0074  0853  	MOVF __div_16_1_00003_arg_b, W
0075  02D7  	SUBWF __div_16_1_00003_1_r, F
0076  0854  	MOVF __div_16_1_00003_arg_b+D'1', W
0077  1C03  	BTFSS STATUS,C
0078  03D8  	DECF __div_16_1_00003_1_r+D'1', F
0079  02D8  	SUBWF __div_16_1_00003_1_r+D'1', F
007A  145A  	BSF CompTempVarRet214,0
007B        label9
007B  0AD9  	INCF __div_16_1_00003_1_i, F
007C  2863  	GOTO	label7
007D        ; } __div_16_16 function end


029A        __mul_8u_8_00006
029A        ; { __mul_8u_8u ; function begin
029A  01CC  	CLRF __mul_8u_8_00006_1_i
029B  01CF  	CLRF CompTempVarRet452
029C  01D0  	CLRF CompTempVarRet452+D'1'
029D  084A  	MOVF __mul_8u_8_00006_arg_a, W
029E  00CD  	MOVWF __mul_8u_8_00006_1_t
029F  01CE  	CLRF __mul_8u_8_00006_1_t+D'1'
02A0        label46
02A0  19CC  	BTFSC __mul_8u_8_00006_1_i,3
02A1  0008  	RETURN
02A2  1C4B  	BTFSS __mul_8u_8_00006_arg_b,0
02A3  2AAA  	GOTO	label47
02A4  084D  	MOVF __mul_8u_8_00006_1_t, W
02A5  07CF  	ADDWF CompTempVarRet452, F
02A6  1803  	BTFSC gbl_status,0
02A7  0AD0  	INCF CompTempVarRet452+D'1', F
02A8  084E  	MOVF __mul_8u_8_00006_1_t+D'1', W
02A9  07D0  	ADDWF CompTempVarRet452+D'1', F
02AA        label47
02AA  0CCB  	RRF __mul_8u_8_00006_arg_b, F
02AB  1003  	BCF gbl_status,0
02AC  0DCD  	RLF __mul_8u_8_00006_1_t, F
02AD  0DCE  	RLF __mul_8u_8_00006_1_t+D'1', F
02AE  0ACC  	INCF __mul_8u_8_00006_1_i, F
02AF  2AA0  	GOTO	label46
02B0        ; } __mul_8u_8u function end


04F9        _startup
04F9  30D5  	MOVLW 0xD5
04FA  1283  	BCF STATUS, RP0
04FB  1303  	BCF STATUS, RP1
04FC  00A0  	MOVWF gbl_14_LSR
04FD  30C4  	MOVLW 0xC4
04FE  00A1  	MOVWF gbl_14_LSR+D'1'
04FF  30BB  	MOVLW 0xBB
0500  00A2  	MOVWF gbl_14_LSR+D'2'
0501  30DC  	MOVLW 0xDC
0502  00A3  	MOVWF gbl_14_LSR+D'3'
0503  01A4  	CLRF gbl_15_gbl_aSig
0504  01A5  	CLRF gbl_15_gbl_aSig+D'1'
0505  01A6  	CLRF gbl_15_gbl_aSig+D'2'
0506  01A7  	CLRF gbl_15_gbl_aSig+D'3'
0507  01A8  	CLRF gbl_15_gbl_bSig
0508  01A9  	CLRF gbl_15_gbl_bSig+D'1'
0509  01AA  	CLRF gbl_15_gbl_bSig+D'2'
050A  01AB  	CLRF gbl_15_gbl_bSig+D'3'
050B  01AC  	CLRF gbl_15_gbl_zSig
050C  01AD  	CLRF gbl_15_gbl_zSig+D'1'
050D  01AE  	CLRF gbl_15_gbl_zSig+D'2'
050E  01AF  	CLRF gbl_15_gbl_zSig+D'3'
050F  01BE  	CLRF gbl_15_gbl_aExp
0510  01BF  	CLRF gbl_15_gbl_bExp
0511  01B7  	CLRF gbl_15_gbl_zExp
0512  01B8  	CLRF gbl_15_gbl_zExp+D'1'
0513  01C0  	CLRF gbl_15_gbl_aSign
0514  01C1  	CLRF gbl_15_gbl_bSign
0515  01C2  	CLRF gbl_15_gbl_zSign
0516  01C3  	CLRF gbl_15_gbl_zSigZero
0517  01B0  	CLRF gbl_15_gbl_ret
0518  01B1  	CLRF gbl_15_gbl_ret+D'1'
0519  01B2  	CLRF gbl_15_gbl_ret+D'2'
051A  01B3  	CLRF gbl_15_gbl_ret+D'3'
051B  01BC  	CLRF gbl_float_rounding_mode
051C  01BD  	CLRF gbl_float_exception_flags
051D  01BB  	CLRF gbl_float_detect_tininess

0526  118A  	BCF PCLATH,3
0527  120A  	BCF PCLATH,4
0528  2C06  	GOTO	main

2007  3F32  	DW 0x3F32
