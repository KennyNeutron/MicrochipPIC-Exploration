;/////////////////////////////////////////////////////////////////////////////////
;// Code Generator: BoostC Compiler - http://www.sourceboost.com
;// Version       : 7.03
;// License Type  : Pro License
;// Limitations   : PIC12,PIC16 max code size:Unlimited, max RAM banks:Unlimited
;/////////////////////////////////////////////////////////////////////////////////

/*********************************************************************
 *                  Flowcode CAL Delays File
 *
 * File: PIC_CAL_Delay.c
 *
 * (c) 2011 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * “Company”) for its Flowcode graphical programming language is
 * intended and supplied to you, the Company’s customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 010911 | BR | Created
 *
 *
 *
 */

//Original Byte Delays
void Wdt_Delay_S(char delay);
void Wdt_Delay_Ms(char delay);

//New Int Delays
void FCI_DELAYINT_US(MX_UINT16 Delay);

void FCI_DELAYINT_MS(MX_UINT16 Delay);
void FCI_DELAYINTWDT_MS(MX_UINT16 Delay);

void FCI_DELAYINT_S(MX_UINT16 Delay);
void FCI_DELAYINTWDT_S(MX_UINT16 Delay);


#ifdef HI_TECH_C

	#define nop()	asm("NOP")

	void delay_10us(char del);
	void delay_us(char del);
	void delay_ms(char del);
	void delay_s(char del);

	void delay_10us(char del)
	{
		char count;
		for(count=0; count<10; count++)
		{
			delay_us(del);
		}
	}

	void delay_us(char del)
	{
		while (del > 1)
		{
			__delay_us(1);
			del = del - 1;
		}
	}

	void delay_ms(char del)
	{
		while (del > 1)
		{
			__delay_ms(1);
			del = del - 1;
		}
	}

	void delay_s(char del)
	{
		char i;
		for(i=0; i<del; i++)
		{
			delay_ms(250);
			delay_ms(250);
			delay_ms(250);
			delay_ms(250);
		}
	}

#endif

void Wdt_Delay_S(char delay)
{
    char i;
    short j;
    for (i=0; i<delay; i++)
    {
        for (j=0; j<999; j++)
        {
            Wdt_Delay_Ms(1);
        }
    }
}

void Wdt_Delay_Ms(char delay)

{
    char i;
    for (i=0; i<delay; i++)
007F  01F8  	CLRF Wdt_Delay__0003E_1_i
0080        label10
0080  0877  	MOVF Wdt_Delay__0003E_arg_delay, W
0081  0278  	SUBWF Wdt_Delay__0003E_1_i, W
0082  1803  	BTFSC STATUS,C
0088  0AF8  	INCF Wdt_Delay__0003E_1_i, F
0089  2880  	GOTO	label10

    {
        MX_CLEAR_WATCHDOG;        //Clear Watchdog Timer
0084  0064  	CLRWDT

        delay_ms(1);
0085  3001  	MOVLW 0x01
0086  00F9  	MOVWF delay_ms_00000_arg_del
0087  2010  	CALL delay_ms_00000

    }
}
0083  0008  	RETURN



void FCI_DELAYINT_US(MX_UINT16 Delay)
{
  	while (Delay > 255)
  	{
	  	delay_us(255);
	  	Delay = Delay - 255;
  	}
  	if (Delay > 0)
  		delay_us(Delay & 0xFF);
}

void FCI_DELAYINT_MS(MX_UINT16 Delay)
{
  	while (Delay > 255)
  	{
	  	delay_ms(255);
	  	Delay = Delay - 255;
  	}
  	if (Delay > 0)
  		delay_ms(Delay & 0xFF);
}

void FCI_DELAYINTWDT_MS(MX_UINT16 Delay)
{
  	while (Delay > 255)
  	{
	  	Wdt_Delay_Ms(255);
	  	Delay = Delay - 255;
  	}
  	if (Delay > 0)
  		Wdt_Delay_Ms(Delay & 0xFF);
}

void FCI_DELAYINT_S(MX_UINT16 Delay)
{
  	while (Delay > 255)
  	{
	  	delay_s(255);
	  	Delay = Delay - 255;
  	}
  	if (Delay > 0)
  		delay_s(Delay & 0xFF);
}

void FCI_DELAYINTWDT_S(MX_UINT16 Delay)
{
  	while (Delay > 255)
  	{
	  	Wdt_Delay_S(255);
	  	Delay = Delay - 255;
  	}
  	if (Delay > 0)
  		Wdt_Delay_S(Delay & 0xFF);
}



/*********************************************************************
 *                  Flowcode CAL String File
 *
 * File: PIC_CAL_String.c
 *
 * (c) 2011 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * “Company”) for its Flowcode graphical programming language is
 * intended and supplied to you, the Company’s customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 010911 | BR | Created
 * 150911 | JW | Added v5 string functions
 * 270212 | BR | Fixed an issue with ToUpper where the 1st character was being returned as null
 * 120312 | BR | Fixed an issue with some of the float functions not using CAL functions
 */


// Useful call for finding the length of an (uncorrupted) string
#define FCI_GETLENGTH__x(str, max, idx)         for (idx = 0; idx < max; idx++) if (str[idx] == 0) break
#define FCI_STRMOV__x(str, max, dst, dlen, ix)  for (ix = 0; ix < (max) && ix < (dlen) && str[ix] != '\0'; ix++) dst[ix] = str[ix]
#define FCI_CONCATENATE(s0, l0, s1, l1, sd, ld) FCI_SHEAD(s0, l0, s1, l1, sd, ld)


#ifndef MX_USES_UINT32
	#define MX_USES_UINT32 0
#endif
#ifndef MX_USES_SINT32
	#define MX_USES_SINT32 0
#endif


#if (MX_USES_UINT32 || MX_USES_SINT32)
	#define MX_STRF_LONG
	#define MX_ULONG MX_UINT32
	#define MX_SLONG MX_SINT32
#else
	#define MX_ULONG MX_UINT16
	#define MX_SLONG MX_SINT16
#endif


//String function definitions
MX_UINT8 FCI_GETCHAR(MX_STRING sStr1, MX_UINT8 iStr1_len, MX_UINT8 iPos);
MX_UINT8 FCI_GETLENGTH(MX_STRING sStr1, MX_UINT8 iStr1_len);
MX_UINT8 FCI_MIDSTRING(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_UINT8 iStart, MX_UINT8 iCount, MX_STRING sDst, MX_UINT8 iDst_len);
MX_UINT8 FCI_LEFTSTRING(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_UINT8 iCount, MX_STRING sDst, MX_UINT8 iDst_len);
MX_UINT8 FCI_RIGHTSTRING(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_UINT8 iCount, MX_STRING sDst, MX_UINT8 iDst_len);
MX_UINT8 FCI_TOSTRING(MX_SLONG iSrc1, MX_STRING sDst, MX_UINT8 iDst_len);
void FCI_TOLOWER(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len);
void FCI_TOUPPER(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len);
MX_UINT8 FCI_COMPARE(MX_STRING sSrc1, MX_UINT8 iSrc1_len, MX_STRING sSrc2, MX_UINT8 iSrc2_len, MX_UINT8 iNoCase);
MX_UINT8 FCI_FLOAT_TO_STRING(MX_FLOAT Number, MX_UINT8 Precision, MX_STRING String, MX_UINT8 MSZ_String);
MX_UINT8 FCI_NUMBER_TO_HEX(MX_ULONG Number, MX_STRING String, MX_UINT8 MSZ_String);
MX_SINT32 FCI_STRING_TO_INT(MX_STRING String, MX_UINT8 MSZ_String);
MX_FLOAT FCI_STRING_TO_FLOAT(MX_STRING String, MX_UINT8 MSZ_String);

// Functions for contatenation
MX_UINT8 FCI_STRREV(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len);
MX_UINT8 FCI_STRMOV(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len);
void FCI_SHEAD(MX_STRING sSrc1, MX_UINT8 iSrc1_len, MX_STRING sSrc2, MX_UINT8 iSrc2_len, MX_STRING sDst, MX_UINT8 iDst_len);
void FCI_SCOPY(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len);



MX_UINT8 FCI_GETCHAR(MX_STRING sStr1, MX_UINT8 iStr1_len, MX_UINT8 iPos)
{
	MX_UINT8 tmp;
	FCI_GETLENGTH__x(sStr1, iStr1_len, tmp);

	if(iPos < tmp)
		return sStr1[iPos];
	return '\0';
}

MX_UINT8 FCI_GETLENGTH(MX_STRING sStr1, MX_UINT8 iStr1_len)
{
	MX_UINT8 tmp;
	FCI_GETLENGTH__x(sStr1, iStr1_len, tmp);
	return (tmp);
}

MX_UINT8 FCI_MIDSTRING(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_UINT8 iStart, MX_UINT8 iCount, MX_STRING sDst, MX_UINT8 iDst_len)
{
	if (iDst_len == 0) return 0;
	MX_UINT8 idx;
	FCI_GETLENGTH__x(sSrc, iSrc_len, idx);	//find the length of the source string

	if (iStart >= idx)
	{
		*sDst = '\0';						//starting position is beyond string length, so return a null string
	}
	else
	{
		if ((iStart + iCount) >= idx)		//Make sure the required length is not too big
			iCount = idx - iStart;
		if (iCount > (iDst_len))			//make sure the required length is not too big
			iCount = (iDst_len);

		sSrc += iStart;						//Move to the correct place in the source string

		for (idx = 0; idx < iCount; idx++)	//Copy the contents of the source string
		{
			*sDst = *sSrc;
			sDst++;
			sSrc++;
		}
		if (idx < iDst_len)						//add terminating null (if we can)
			*sDst = '\0';
	}
	return (idx);
}

MX_UINT8 FCI_LEFTSTRING(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_UINT8 iCount, MX_STRING sDst, MX_UINT8 iDst_len)
{
	if (iDst_len == 0) return 0;
	MX_UINT8 idx;
	FCI_GETLENGTH__x(sSrc, iSrc_len, idx);	//find the length of the source string

	if (iCount > idx)						//make sure the required length is not too big
		iCount = idx;
	if (iCount > (iDst_len))			//make sure the required length is not too big
		iCount = (iDst_len);

	for (idx = 0; idx < iCount; idx++)		//copy the required MX_UINT8acters
	{
		*sDst = *sSrc;
		sDst++;
		sSrc++;
	}
	if (idx < iDst_len)						//add terminating null (if we can)
		*sDst = '\0';
	return (idx);
}

MX_UINT8 FCI_RIGHTSTRING(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_UINT8 iCount, MX_STRING sDst, MX_UINT8 iDst_len)
{
	if (iDst_len == 0) return 0;
	MX_UINT8 idx;
	MX_UINT8 delta;

	FCI_GETLENGTH__x(sSrc, iSrc_len, idx);	//find the length of the source string

	if (iCount > idx)						//make sure the required length is not too big
		iCount = idx;
	delta = idx - iCount;					//get the offset
	if (iCount > (iDst_len))				//make sure the required length is not too big
		iCount = (iDst_len);
	sSrc += delta;							//Move to the correct place in the source string

	for(idx = 0; idx < iCount; idx++)		//copy the required MX_UINT8acters
	{
		*sDst = *sSrc;
		sDst++;
		sSrc++;
	}
	if (idx < iDst_len)						//add terminating null (if we can)
		*sDst = '\0';
	return (idx);
}

MX_UINT8 FCI_TOSTRING(MX_SLONG iSrc1, MX_STRING sDst, MX_UINT8 iDst_len)

{
	if (iDst_len == 0) return 0;
03F3  08F6  	MOVF FCI_TOSTRI_00049_arg_iDst_len, F
03F4  1D03  	BTFSS STATUS,Z
03F5  2BF8  	GOTO	label65
03F6  01FB  	CLRF CompTempVarRet2009
03F8        label65

	MX_UINT8 tmp1;

	#ifdef MX_STRF_LONG
		unsigned long top = 1000000000; 	// Maximum power of 10 less than 4294967296
	#else
		unsigned short top = 10000; 		// Maximum power of 10 less than 65536
03F8  3010  	MOVLW 0x10
03F9  00F8  	MOVWF FCI_TOSTRI_00049_1_top
03FA  3027  	MOVLW 0x27
03FB  00F9  	MOVWF FCI_TOSTRI_00049_1_top+D'1'

	#endif

	MX_UINT8 idx = 0;
03FC  01FA  	CLRF FCI_TOSTRI_00049_1_idx


	//copy source 1 into destination:
	//minus sign
	if (iSrc1 < 0)
03FD  1FF3  	BTFSS FCI_TOSTRI_00049_arg_iSrc1+D'1',7
03FE  2C0F  	GOTO	label66

	{
		sDst[0] = '-';
03FF  1383  	BCF STATUS,IRP
0400  1875  	BTFSC FCI_TOSTRI_00049_arg_sDst+D'1',0
0401  1783  	BSF STATUS,IRP
0402  0874  	MOVF FCI_TOSTRI_00049_arg_sDst, W
0403  0084  	MOVWF FSR
0404  01FC  	CLRF CompTempVar2011
0405  087C  	MOVF CompTempVar2011, W
0406  0784  	ADDWF FSR, F
0407  302D  	MOVLW 0x2D
0408  0080  	MOVWF INDF

		idx++;
0409  0AFA  	INCF FCI_TOSTRI_00049_1_idx, F

		iSrc1 = -iSrc1;
040A  09F2  	COMF FCI_TOSTRI_00049_arg_iSrc1, F
040B  09F3  	COMF FCI_TOSTRI_00049_arg_iSrc1+D'1', F
040C  0AF2  	INCF FCI_TOSTRI_00049_arg_iSrc1, F
040D  1903  	BTFSC STATUS,Z
040E  0AF3  	INCF FCI_TOSTRI_00049_arg_iSrc1+D'1', F
040F        label66

	}

	tmp1 = 0;    // Nothing added yet
040F  01F7  	CLRF FCI_TOSTRI_00049_1_tmp1

	if (iSrc1 == 0) // Force showing zero
0410  08F2  	MOVF FCI_TOSTRI_00049_arg_iSrc1, F
0411  1D03  	BTFSS STATUS,Z
0412  2C1A  	GOTO	label67
0413  08F3  	MOVF FCI_TOSTRI_00049_arg_iSrc1+D'1', F
0414  1D03  	BTFSS STATUS,Z
0415  2C1A  	GOTO	label67
041A        label67

	{
		tmp1 = 1;
0416  3001  	MOVLW 0x01
0417  00F7  	MOVWF FCI_TOSTRI_00049_1_tmp1

		top = 1;
0418  00F8  	MOVWF FCI_TOSTRI_00049_1_top
0419  01F9  	CLRF FCI_TOSTRI_00049_1_top+D'1'

	}
	while (( idx < iDst_len) && (top > 0))
041A  0876  	MOVF FCI_TOSTRI_00049_arg_iDst_len, W
041B  027A  	SUBWF FCI_TOSTRI_00049_1_idx, W
041C  1803  	BTFSC STATUS,C
041D  2C79  	GOTO	label72
041E  0878  	MOVF FCI_TOSTRI_00049_1_top, W
041F  3C00  	SUBLW 0x00
0420  1803  	BTFSC STATUS,C
0421  0879  	MOVF FCI_TOSTRI_00049_1_top+D'1', W
0422  1903  	BTFSC STATUS,Z
0423  2C79  	GOTO	label72
0478  2C1A  	GOTO	label67
0479        label72

	{
		#ifdef MX_STRF_LONG
		if (((unsigned long)iSrc1 >= top) || (tmp1))
		#else
		if (((unsigned)iSrc1 >= top) || (tmp1))
0424  0879  	MOVF FCI_TOSTRI_00049_1_top+D'1', W
0425  0273  	SUBWF FCI_TOSTRI_00049_arg_iSrc1+D'1', W
0426  1D03  	BTFSS STATUS,Z
0427  2C2A  	GOTO	label68
0428  0878  	MOVF FCI_TOSTRI_00049_1_top, W
0429  0272  	SUBWF FCI_TOSTRI_00049_arg_iSrc1, W
042A        label68
042A  1803  	BTFSC STATUS,C
042B  2C2F  	GOTO	label69
042C  08F7  	MOVF FCI_TOSTRI_00049_1_tmp1, F
042D  1903  	BTFSC STATUS,Z
042E  2C68  	GOTO	label71
042F        label69
0468        label71

		#endif
		{
			#ifdef MX_STRF_LONG
			tmp1 = (unsigned long)iSrc1 / top;	// Top digit
			#else
			tmp1 = (unsigned)iSrc1 / top;	// Top digit
042F  0872  	MOVF FCI_TOSTRI_00049_arg_iSrc1, W
0430  00FC  	MOVWF __div_16_1_00003_arg_a
0431  0873  	MOVF FCI_TOSTRI_00049_arg_iSrc1+D'1', W
0432  00FD  	MOVWF __div_16_1_00003_arg_a+D'1'
0433  0878  	MOVF FCI_TOSTRI_00049_1_top, W
0434  1683  	BSF STATUS, RP0
0435  00A0  	MOVWF __div_16_1_00003_arg_b
0436  1283  	BCF STATUS, RP0
0437  0879  	MOVF FCI_TOSTRI_00049_1_top+D'1', W
0438  1683  	BSF STATUS, RP0
0439  00A1  	MOVWF __div_16_1_00003_arg_b+D'1'
043A  205E  	CALL __div_16_1_00003
043B  0825  	MOVF CompTempVarRet214, W
043C  1283  	BCF STATUS, RP0
043D  00F7  	MOVWF FCI_TOSTRI_00049_1_tmp1

			#endif
			sDst[idx] = '0' + tmp1;			// Add digit to buffer
043E  0877  	MOVF FCI_TOSTRI_00049_1_tmp1, W
043F  3E30  	ADDLW 0x30
0440  00FC  	MOVWF CompTempVar2015
0441  1383  	BCF STATUS,IRP
0442  1875  	BTFSC FCI_TOSTRI_00049_arg_sDst+D'1',0
0443  1783  	BSF STATUS,IRP
0444  0874  	MOVF FCI_TOSTRI_00049_arg_sDst, W
0445  077A  	ADDWF FCI_TOSTRI_00049_1_idx, W
0446  0084  	MOVWF FSR
0447  087C  	MOVF CompTempVar2015, W
0448  0080  	MOVWF INDF

			idx++;
0449  0AFA  	INCF FCI_TOSTRI_00049_1_idx, F

			iSrc1 -= tmp1 * top;			// Remove digit
044A  0877  	MOVF FCI_TOSTRI_00049_1_tmp1, W
044B  00FC  	MOVWF __mul_16u__0000C_arg_a
044C  01FD  	CLRF __mul_16u__0000C_arg_a+D'1'
044D  0878  	MOVF FCI_TOSTRI_00049_1_top, W
044E  1683  	BSF STATUS, RP0
044F  00A0  	MOVWF __mul_16u__0000C_arg_b
0450  1283  	BCF STATUS, RP0
0451  0879  	MOVF FCI_TOSTRI_00049_1_top+D'1', W
0452  1683  	BSF STATUS, RP0
0453  00A1  	MOVWF __mul_16u__0000C_arg_b+D'1'
0454  20F8  	CALL __mul_16u__0000C
0455  0826  	MOVF CompTempVarRet455, W
0456  1283  	BCF STATUS, RP0
0457  00FE  	MOVWF CompTempVar2016
0458  1683  	BSF STATUS, RP0
0459  0827  	MOVF CompTempVarRet455+D'1', W
045A  00A2  	MOVWF CompTempVar2017
045B  1283  	BCF STATUS, RP0
045C  087E  	MOVF CompTempVar2016, W
045D  02F2  	SUBWF FCI_TOSTRI_00049_arg_iSrc1, F
045E  1683  	BSF STATUS, RP0
045F  0822  	MOVF CompTempVar2017, W
0460  1803  	BTFSC STATUS,C
0461  2C64  	GOTO	label70
0462  1283  	BCF STATUS, RP0
0463  03F3  	DECF FCI_TOSTRI_00049_arg_iSrc1+D'1', F
0464  1283  	BCF STATUS, RP0
0465  02F3  	SUBWF FCI_TOSTRI_00049_arg_iSrc1+D'1', F

			tmp1 = 1;						// Add zeros now
0466  3001  	MOVLW 0x01
0467  00F7  	MOVWF FCI_TOSTRI_00049_1_tmp1

		}
		top /= 10;							// Go to next digit
0468  0878  	MOVF FCI_TOSTRI_00049_1_top, W
0469  00FC  	MOVWF __div_16_1_00003_arg_a
046A  0879  	MOVF FCI_TOSTRI_00049_1_top+D'1', W
046B  00FD  	MOVWF __div_16_1_00003_arg_a+D'1'
046C  300A  	MOVLW 0x0A
046D  1683  	BSF STATUS, RP0
046E  00A0  	MOVWF __div_16_1_00003_arg_b
046F  01A1  	CLRF __div_16_1_00003_arg_b+D'1'
0470  205E  	CALL __div_16_1_00003
0471  0825  	MOVF CompTempVarRet214, W
0472  1283  	BCF STATUS, RP0
0473  00F8  	MOVWF FCI_TOSTRI_00049_1_top
0474  1683  	BSF STATUS, RP0
0475  0826  	MOVF CompTempVarRet214+D'1', W
0476  1283  	BCF STATUS, RP0
0477  00F9  	MOVWF FCI_TOSTRI_00049_1_top+D'1'

	}

	if (idx < iDst_len)						//add terminating null (if we can)
0479  0876  	MOVF FCI_TOSTRI_00049_arg_iDst_len, W
047A  027A  	SUBWF FCI_TOSTRI_00049_1_idx, W
047B  1803  	BTFSC STATUS,C
047C  2C85  	GOTO	label73
0485        label73

		sDst[idx] = '\0';
047D  1383  	BCF STATUS,IRP
047E  1875  	BTFSC FCI_TOSTRI_00049_arg_sDst+D'1',0
047F  1783  	BSF STATUS,IRP
0480  0874  	MOVF FCI_TOSTRI_00049_arg_sDst, W
0481  077A  	ADDWF FCI_TOSTRI_00049_1_idx, W
0482  0084  	MOVWF FSR
0483  3000  	MOVLW 0x00
0484  0080  	MOVWF INDF

	return (idx);
0485  087A  	MOVF FCI_TOSTRI_00049_1_idx, W
0486  00FB  	MOVWF CompTempVarRet2009

}
03F7  0008  	RETURN
0487  0008  	RETURN




void FCI_TOLOWER(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len)
{
	if (iDst_len == 0) return;
	MX_UINT8 idx;
	MX_UINT8 ch;

	if (iSrc_len < iDst_len) iSrc_len = iDst_len; // Bound so cant overflow dest
	//copy source into destination and change to lower case
	for (idx=0; idx<iSrc_len; idx++)
	{
		ch = sSrc[idx];
		if ((ch >= 'A') && (ch <= 'Z'))
		{
			ch ^= 0x20;
		}
		sDst[idx] = ch;
		if (ch == 0)
		{
			break;
		}
	}
	if (idx < iDst_len)						//add terminating null (if we can)
		sDst[idx] = '\0';
}

void FCI_TOUPPER(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len)
{
	if (iDst_len == 0) return;
	MX_UINT8 idx;
	MX_UINT8 ch;

	if (iSrc_len < iDst_len) iSrc_len = iDst_len; // Bound so cant overflow dest
	//copy source into destination and change to upper case
	for (idx=0; idx<iSrc_len; idx++)
	{
		ch = sSrc[idx];
		if ((ch >= 'a') && (ch <= 'z'))
		{
			ch ^= 0x20;
		}
		sDst[idx] = ch;
		if (ch == 0)
		{
			break;
		}
	}
	if (idx < iDst_len)						//add terminating null (if we can)
		sDst[idx] = '\0';
}

MX_UINT8 FCI_COMPARE(MX_STRING sSrc1, MX_UINT8 iSrc1_len, MX_STRING sSrc2, MX_UINT8 iSrc2_len, MX_UINT8 iNoCase)
{
	MX_UINT8 iRetVal = 0;
	MX_UINT8 idx;
	MX_UINT8 ch1, ch2;

	for (idx=0; idx < iSrc1_len; idx++)	//compare a byte from the strings
	{
		if (idx < iSrc2_len)
		{
			ch1 = *sSrc1;
			ch2 = *sSrc2;

			if (iNoCase)
			{
				if ((ch1 >= 'a') && (ch1 <= 'z'))
					ch1 = (ch1 & 0xDF);

				if ((ch2 >= 'a') && (ch2 <= 'z'))
					ch2 = (ch2 & 0xDF);

			}

			if (ch1 < ch2)
			{
				return(255);
			}
			else if (ch1 > ch2)
			{
				return(1);
			}

			sSrc1++;
			sSrc2++;
		}
		else
		{
			if (*sSrc1 == 0)
				return (0);				//end of source1 as well, so ok
			else
				return (1);				//reached the end of iSrc2, but still more of iSrc1
		}
	}

	if (iSrc1_len == iSrc2_len)			//reached the end of iSrc1.  If we're also at the end of iSrc2, then return 0
		return (0);
	else
	{
		if (*sSrc2 == 0)
			return (0);					//end of source1 as well, so ok
		else
			return (255);				//not at end of source2, so return -1
	}
}


MX_UINT8 FCI_FLOAT_TO_STRING(MX_FLOAT Number, MX_UINT8 Precision, MX_STRING String, MX_UINT8 MSZ_String)
{
	MX_SINT16 whole;
	MX_UINT8 str_length;
	MX_UINT8 idx;
	MX_UINT8 stringidx = 0;
	MX_FLOAT real, temp;
	MX_UINT8 old;
	MX_UINT8 temp_string[10];

	#ifdef _BOOSTC									//BoostC Floating Point

		float_rounding_mode = 3;					//Always round to zero
		whole = float32_to_int32(Number);			//Convert to whole integer
		temp = float32_from_int32(whole);			//Convert whole number back to floating point

		if (float32_ge(Number,0))
		{
			real = float32_sub(Number, temp);		//Subtract whole number from floating point number
		}
		else
		{
			if (whole == 0)							//Fix -0 bug
			{
				String[stringidx] = '-';
				stringidx = stringidx + 1;
			}

			real = float32_sub(temp, Number);		//Subtract floating point number from whole number
		}
	#endif

	#ifdef HI_TECH_C								//HiTECH Floating Point

		whole = (int)Number;						//Convert to whole integer
		temp = whole;								//Convert whole number back to floating point

		if (Number >= 0)
		{
			real = Number - temp;					//Subtract whole number from floating point number
		}
		else
		{
			if (whole == 0)							//Fix -0 bug
			{
				String[stringidx] = '-';
				stringidx = stringidx + 1;
			}

			real = temp - Number;					//Subtract floating point number from whole number
		}
	#endif

	str_length = FCI_TOSTRING(whole, temp_string, 5);		//Convert integer numbers to strings

	for (idx=0; idx<str_length; idx++)						//Copy whole part of number to string
	{
		if(stringidx < MSZ_String)
		{
			String[stringidx] = temp_string[idx];
			stringidx = stringidx + 1;
		}
	}

	if(stringidx < MSZ_String)						//Add decimal point to string
	{
		String[stringidx] = '.';
		stringidx = stringidx + 1;
	}

	for (idx = 0; idx < Precision; idx++)			//Output Real Part Of Number
	{
		if (stringidx >= MSZ_String)
			break;

		#ifdef _BOOSTC								//BoostC Floating Point
			real = float32_mul(real, 10);
			whole = float32_to_int32(real);			//Convert to whole integer
			temp = float32_from_int32(whole);		//Convert whole number back to floating point
			real = float32_sub(real, temp);			//Subtract whole number from floating point number
		#endif
		#ifdef HI_TECH_C							//HiTECH Floating Point
			real = real * 10;
			whole = (int)real;						//Convert to whole integer
			temp = whole;							//Convert whole number back to floating point
			real = real - temp;						//Subtract whole number from floating point number
		#endif

		String[stringidx] = '0' + whole;
		stringidx = stringidx + 1;
	}

	if(stringidx < MSZ_String)									//Add null termination to string
	{
		String[stringidx] = 0;
	}

	return stringidx;
}











MX_UINT8 FCI_NUMBER_TO_HEX(MX_ULONG Number, MX_STRING String, MX_UINT8 MSZ_String)
{
	MX_UINT8 stringidx;
	MX_UINT8 idx = 0;
	MX_UINT8 temp;
	MX_UINT8 digit[8] = {0,0,0,0,0,0,0,0};

	#ifdef MX_STRF_LONG
		MX_UINT32 num = Number;
	#else
		MX_UINT16 num = Number;
	#endif

	//Check that output string is long enough to store result
	if((Number > 0xFFFF) && (MSZ_String < 10))
		return 0;

	if((Number > 0xFF) && (MSZ_String < 6))
		return 0;

	if((Number <= 0xFF) && (MSZ_String < 4))
		return 0;

	//Initialise start of string with hexadecimal indicator
	String[0] = '0';
	String[1] = 'x';

	//Calculate hex values
	do
	{
		temp = num % 16;
		num = num >> 4;

		if(temp > 9)
		{
			temp = temp - 10;
			digit[idx] = temp + 'A';
		}
		else
			digit[idx] = temp + '0';

		idx = idx + 1;
	} while (num > 0);

	//Copy Hex values over to output string
	for (stringidx = 2; stringidx < (idx + 2); stringidx++)
		String[stringidx] = digit[idx - (stringidx - 1)];

	//Add null termination to string
	if(stringidx < MSZ_String)
	{
		String[stringidx] = 0;
	}

	return stringidx;
}


MX_SINT32 FCI_STRING_TO_INT(MX_STRING String, MX_UINT8 MSZ_String)
{
	MX_UINT8 bNegative = 0;
	MX_UINT8 idx = 0;
	MX_SINT32 RetVal = 0;

	//Is number negative
	if(String[0] == '-')
	{
		bNegative = 1;
		idx = 1;
	}

	//While string contains a valid number
	while (idx < MSZ_String && String[idx] >= '0' && String[idx] <= '9')
	{
		//Pull MX_UINT8acter from string and add to running total
		RetVal = (long) RetVal * 10;
		RetVal = (long) RetVal + (String[idx] - '0');
		idx = idx + 1;
	}

	if (bNegative)
		RetVal = (long) 0 - RetVal;

	return RetVal;
}


MX_FLOAT FCI_STRING_TO_FLOAT(MX_STRING String, MX_UINT8 MSZ_String)
{
	MX_FLOAT RetVal = 0;
	MX_FLOAT real_divider = 1;
	MX_UINT32 whole, real;			//Changed from INT 23/07/10
	MX_UINT8 idx = 0;
	MX_UINT8 idx2 = 0;
	MX_UINT8 offset = 0;
	MX_UINT8 bNegative = 0;
	MX_UINT8 Comp_String[8];

	//Is number negative
	if(String[0] == '-')
	{
		bNegative = 1;
		offset = 1;
	}

	//Scan for decimal point
	for(idx=offset; idx<MSZ_String; idx++)
	{
		if(String[idx] == '.')
			break;
	}

	//Convert whole portion of number from string
	whole = FCI_STRING_TO_INT (String, idx);

	//No decimal point found
	if(idx == MSZ_String)
	{
		#ifdef _BOOSTC
			RetVal = float32_from_int32(whole);
		#endif
		#ifdef HI_TECH_C
			RetVal = (int)whole;
		#endif
		return RetVal;
	}

	//Collect real portion of number into new string
	offset = idx + 1;
	for(idx=offset; idx<MSZ_String; idx++)
	{
		if(String[idx] >= '0' && String[idx] <= '9')
		{
			Comp_String[idx - offset] = String[idx];
			#ifdef _BOOSTC
				real_divider = float32_mul(real_divider, 0.1);
			#endif
			#ifdef HI_TECH_C
				real_divider = real_divider * 0.1;
			#endif
		}
		else
			break;
	}

	//Convert real portion of number from string
	real = FCI_STRING_TO_INT (Comp_String, (idx - offset));

	//Adjust weighting of values and combine into one float variable
	#ifdef _BOOSTC

		RetVal = float32_from_int32(real);
		RetVal = float32_mul(RetVal, real_divider);
		real_divider = float32_from_int32(whole);
		RetVal = float32_add(RetVal, real_divider);

		if (bNegative)
			RetVal = float32_sub(0, RetVal);

	#endif
	#ifdef HI_TECH_C

		RetVal = (MX_FLOAT)real;
		RetVal = RetVal * real_divider;
		real_divider = (MX_FLOAT)whole;
		RetVal = RetVal + real_divider;

		if (bNegative)
			RetVal = 0 - RetVal;
	#endif

	return RetVal;
}



/*=----------------------------------------------------------------------=*\
   Use :Move but do not null-terminate sSrc to sDst, max len iSrc_len
       :This differs from FCI_STRMOV() in that the bytes are copied from the
       :end of the string to the start
       :Returns length of copy
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCI_STRREV(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len)
{
  MX_UINT8 ix, len;
  FCI_GETLENGTH__x(sSrc, iSrc_len, len);
  if (len > iDst_len)
  {
    len = iDst_len;
  }
  ix = len;
  while (ix > 0)
  {
    ix--;
    sDst[ix] = sSrc[ix];
  }
  // No null terminate
  // Return length of string
  return len;
}


/*=----------------------------------------------------------------------=*\
   Use :Move but do not null-terminate sSrc to sDst, max len iSrc_len
       :Returns length of copy
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCI_STRMOV(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len)
{
  MX_UINT8 ix;
  ix = 0;
  while (ix < iSrc_len && ix < iDst_len && sSrc[ix] != '\0')
  {
    sDst[ix] = sSrc[ix];
    ix++;
  }
  // No null terminate
  // Return length of string
  return ix;
}

/*=----------------------------------------------------------------------=*\
   Use :Concatenate sDst = (sSrc1 + sSrc2)
       :sDst is only null terminated if the concat doesnt overflow
       :
\*=----------------------------------------------------------------------=*/
void FCI_SHEAD(MX_STRING sSrc1, MX_UINT8 iSrc1_len, MX_STRING sSrc2, MX_UINT8 iSrc2_len, MX_STRING sDst, MX_UINT8 iDst_len)
{
  MX_UINT8 len, strt;

  len = 0;
  if (sSrc2 == sDst)
  {
    FCI_GETLENGTH__x(sSrc1, iSrc1_len, strt);
    if (strt < iDst_len)
    {
      // Copy second, in reverse
      // len = FCI_STRREV(sSrc2, iSrc2_len, sDst + strt, iDst_len - strt);
      FCI_GETLENGTH__x(sSrc2, iSrc2_len, len);
      if (len > (iDst_len - strt))
      {
        len = (iDst_len - strt); // Length of string to copy to
      }
      iSrc2_len = strt + len; // Use no longer needed var as an offset
      strt = len;
      while (strt > 0)
      {
        strt--;
        iSrc2_len--;
        sDst[iSrc2_len] = sSrc2[strt];
      }
      // Move first
      FCI_STRMOV__x(sSrc1, iSrc1_len, sDst, iDst_len, strt);
      len += strt;
    }
    else
    {
      // Copy first
      FCI_STRMOV__x(sSrc1, iSrc1_len, sDst, iDst_len, len);
    }
  }
  else
  {
    // Copy first
    FCI_STRMOV__x(sSrc1, iSrc1_len, sDst, iDst_len, len);
    // Copy second
    if (len < iDst_len)
    {
      sSrc1 = sDst + len; // make temp copies in no longer used variables
      iSrc1_len = iDst_len - len;
      FCI_STRMOV__x(sSrc2, iSrc2_len, sSrc1, iSrc1_len, strt);
      len += strt;
    }
  }
  // Terminate (only if can)
  if (len < iDst_len)
  {
    sDst[len] = '\0';
  }
}


/*=----------------------------------------------------------------------=*\
   Use :Copy and null-terminate sSrc to sDst, max len iSrc_len
       :sDst is only null terminated if the concat doesnt overflow
       :
\*=----------------------------------------------------------------------=*/
void FCI_SCOPY(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len)
{
  MX_UINT8 len;

  // Move first
  FCI_STRMOV__x(sSrc, iSrc_len, sDst, iDst_len, len);
  // Terminate (only if can)
  if (len < iDst_len)
  {
    sDst[len] = '\0';
  }
}




//************************************************************************************
//**  
//**  File name:     C:\Users\gerpe\OneDrive\GER-PER 2016\Documents\KennyNeutron\2020\FC\PIC Dev Kit_ProcessingSerial.c
//**  Title:         
//**  Description:   
//**  
//**  Generated by:  Flowcode v5.2.0.0
//**  Date:          Sunday, July 19, 2020 20:01:52
//**  Licence:       Professional
//**  Registered to: xyz
//**  Licence key:   WUK7B9
//**  
//**  
//**  http://www.matrixmultimedia.com
//**  
//************************************************************************************


#define MX_PIC

#define MX_USES_UINT8 1
#define MX_USES_SINT16 0
#define MX_USES_CHAR 2
#define MX_USES_FLOAT 0
#define MX_USES_SINT32 0
#define MX_USES_BOOL 1
#define MX_USES_UINT16 0
#define MX_USES_UINT32 0
//Defines for microcontroller
#define P16F873A
#define FC_CAL_PIC
#define MX_ADC
#define MX_ADC_TYPE_1
#define MX_ADC_BITS_10
#define MX_EE
#define MX_EE_TYPE2
#define MX_EE_SIZE 128
#define MX_SPI_1
#define MX_SPI_1_MISO_PORT portc
#define MX_SPI_1_MISO_TRIS trisc
#define MX_SPI_1_MISO_PIN 4
#define MX_SPI_1_MOSI_PORT portc
#define MX_SPI_1_MOSI_TRIS trisc
#define MX_SPI_1_MOSI_PIN 5
#define MX_SPI_1_CLK_PORT portc
#define MX_SPI_1_CLK_TRIS trisc
#define MX_SPI_1_CLK_PIN 3
#define MX_SPI_1_SS_PORT portc
#define MX_SPI_1_SS_TRIS trisc
#define MX_UART_1
#define MX_UART_1_TX_PORT portc
#define MX_UART_1_TX_TRIS trisc
#define MX_UART_1_TX_PIN 6
#define MX_UART_1_RX_PORT portc
#define MX_UART_1_RX_TRIS trisc
#define MX_UART_1_RX_PIN 7
#define MX_I2C
#define MX_MI2C
#define MX_I2C_1
#define MX_I2C_1_SDA_PORT portc
#define MX_I2C_1_SDA_TRIS trisc
#define MX_I2C_1_SDA_PIN 4
#define MX_I2C_1_SCL_PORT portc
#define MX_I2C_1_SCL_TRIS trisc
#define MX_I2C_1_SCL_PIN 3
#define MX_PWM
#define MX_PWM_CNT 2
#define MX_PWM_PSCA1
#define MX_PWM_PSCA4
#define MX_PWM_PSCA16
#define MX_PWM_1_PORT portc
#define MX_PWM_1_TRIS trisc
#define MX_PWM_1_PIN 2
#define MX_PWM_2_PORT portc
#define MX_PWM_2_TRIS trisc
#define MX_PWM_2_PIN 1

//Functions
#define MX_CLK_SPEED 20000000
#ifdef _BOOSTC
#include <system.h>
#endif
#ifdef HI_TECH_C
#include <pic.h>
#endif

//Configuration data
#ifdef _BOOSTC
#pragma DATA 0x2007, 0x3f32
#endif
#ifdef HI_TECH_C
__CONFIG(0x3f32);
#endif

//Internal functions
#include "C:\Program Files (x86)\Flowcode\v5\FCD\internals.c"

//Macro function declarations
void FCM_display();


//Variable declarations
#define FCSZ_STRING_BRIGHTNESS 20
#define FCSZ_STRING_FLAG0 20
#define FCV_TRUE (1)
#define FCV_FALSE (0)
MX_UINT8 FCV_B_SW2 = (0x1);
06A6  3001  	MOVLW 0x01
06A7  00EC  	MOVWF gbl_FCV_B_SW2

MX_BOOL FCV_FLAG0 = (0);
06A8  106D  	BCF gbl_FCV_FLAG0,0

MX_CHAR FCV_STRING_BRIGHTNESS[FCSZ_STRING_BRIGHTNESS] = ("");
06A9  01A0  	CLRF gbl_FCV_STRING_BRIGHTNESS

MX_CHAR FCV_STRING_FLAG0[FCSZ_STRING_FLAG0] = ("");
06AA  01B4  	CLRF gbl_FCV_STRING_FLAG0

MX_UINT8 FCV_ANALOG0 = (0xff);
06AB  30FF  	MOVLW 0xFF
06AC  00EE  	MOVWF gbl_FCV_ANALOG0

MX_UINT8 FCV_BRIGHTNESS = (0x0);
06AD  01EF  	CLRF gbl_FCV_BRIGHTNESS

MX_BOOL FCV_B_SW0 = (1);
06AE  14ED  	BSF gbl_FCV_B_SW0,1

MX_BOOL FCV_B_SW1 = (1);
06AF  156D  	BSF gbl_FCV_B_SW1,2





//LCDDisplay(0): //Defines:

/**** Macro Substitutions ****
a = Unique Component Reference Number
b = D1 Port Letter
c = D2 Port Letter
d = D3 Port Letter
e = D4 Port Letter
f = RS Port Letter
g = E Port Letter
h = Data 1_Pin
i = Data 2 Pin
j = Data 3 Pin
k = Data 4 Pin
l = RS Pin
m = Enable Pin
n = Row Count
o = Column Count
******************************/

	//component connections
	#define LCD_1__PORT0    portb
	#define LCD_1__PORT1    portb
	#define LCD_1__PORT2    portb
	#define LCD_1__PORT3    portb
	#define LCD_1__PORT4    portb
	#define LCD_1__PORT5    portb
	#define LCD_1__TRIS0    trisb
	#define LCD_1__TRIS1    trisb
	#define LCD_1__TRIS2    trisb
	#define LCD_1__TRIS3    trisb
	#define LCD_1__TRIS4    trisb
	#define LCD_1__TRIS5    trisb
	#define LCD_1__BIT0    	2
	#define LCD_1__BIT1    	3
	#define LCD_1__BIT2    	4
	#define LCD_1__BIT3    	5
	#define LCD_1__RS      	0
	#define LCD_1__E       	1
	#define LCD_1__ROWCNT	4
	#define LCD_1__COLCNT	16

	#ifdef _BOOSTC
	  #define LCD_1__DELAY   delay_10us(10)
	#endif
	#ifdef _C2C_
	  #define LCD_1__DELAY   delay_us(100)
	#endif
	#ifdef HI_TECH_C
	  #define LCD_1__DELAY   __delay_us(120)
	#endif
	#ifndef LCD_1__DELAY
	  #define LCD_1__DELAY   delay_us(100)
	#endif




//LCDDisplay(0): //Macro function declarations

void FCD_LCDDisplay0_RawSend(MX_UINT8 in, MX_UINT8 mask);
void FCD_LCDDisplay0_Start();
void FCD_LCDDisplay0_Clear();
void FCD_LCDDisplay0_PrintASCII(MX_UINT8 Character);
void FCD_LCDDisplay0_Command(MX_UINT8 in);
void FCD_LCDDisplay0_Cursor(MX_UINT8 x, MX_UINT8 y);
void FCD_LCDDisplay0_PrintNumber(MX_SINT16 Number);
void FCD_LCDDisplay0_PrintString(MX_STRING String, MX_UINT8 MSZ_String);
void FCD_LCDDisplay0_ScrollDisplay(MX_UINT8 Direction, MX_UINT8 Num_Positions);
void FCD_LCDDisplay0_ClearLine(MX_UINT8 Line);
void FCD_LCDDisplay0_RAM_Write(MX_UINT8 nIdx, MX_UINT8 d0, MX_UINT8 d1, MX_UINT8 d2, MX_UINT8 d3, MX_UINT8 d4, MX_UINT8 d5, MX_UINT8 d6, MX_UINT8 d7);


//ADC(0): //Defines:

/**** Macro Substitutions ****
a = Unique Reference
b = Which ADC Channel
c = Acquisition time
d = Conversion Speed
e = VRef+ Option
f = VRef Voltage x 0.01V
******************************/

//Common Defines

#define ADC_6_MX_ADC_CHANNEL	0
#define ADC_6_MX_ADC_ACTIME	40
#define ADC_6_MX_ADC_CONVSP	3
#define ADC_6_MX_ADC_VREFOP	0
#define ADC_6_MX_ADC_VREFVOL	500

#ifndef MX_ADC_CHANNEL_0
 #define MX_ADC_CHANNEL_0			//Inform CAL ADC channel 0 is now in use.
#endif

#ifndef MX_ADC_REF					//Inform CAL ADC peripheral is now in use
 #define MX_ADC_REF
#endif

extern void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge);
extern MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode);
extern void FC_CAL_Disable_ADC (void);




//ADC(0): //Macro function declarations

void FCD_ADC0_SampleADC();
MX_UINT8 FCD_ADC0_ReadAsByte();
MX_UINT16 FCD_ADC0_ReadAsInt();
MX_FLOAT FCD_ADC0_ReadAsVoltage();
void FCD_ADC0_ReadAsString(MX_CHAR* FCR_RETVAL, MX_UINT8 FCR_RETVAL_SIZE);
void FCD_ADC0_ADC_RAW_Configure_Channel();
MX_UINT8 FCD_ADC0_ADC_RAW_Sample_Channel_Byte();
MX_UINT16 FCD_ADC0_ADC_RAW_Sample_Channel_Int();
MX_UINT8 FCD_ADC0_ADC_RAW_Average_Channel_Byte(MX_UINT8 NumSamples, MX_UINT8 DelayUs);
MX_UINT16 FCD_ADC0_ADC_RAW_Average_Channel_Int(MX_UINT8 NumSamples, MX_UINT8 DelayUs);
void FCD_ADC0_ADC_RAW_Disable_Channel();


//PWM(0): //Defines:

/**** Macro Substitutions ****
a = Unique Reference
b = PWM Channel - 0=SW / 1-8=HW
c = PWM Alt Pin FCD_PWM0_Enable - 0=Standard / 1=Alt
d = PWM Period
e = PWM Prescaler 1
******************************/

//Period and Prescaler Defines
#ifndef MX_PWM_PERIOD
  #define MX_PWM_PERIOD				255
#else
  #if (MX_PWM_PERIOD != 255)
    #error "PWM period value must be the same in all PWM modules"
  #endif
#endif

#ifndef MX_PWM_PRESCALE1
  #define MX_PWM_PRESCALE1			1
#else
  #if (MX_PWM_PRESCALE1 != 1)
    #error "PWM prescale value must be the same in all PWM modules"
  #endif
#endif

//Definitions for PWM slot allocation
#ifndef	MX_PWM_REF1
			#define MX_PWM_REF1
			#define PWM_7_MX_PWM_UREF			1
			#define MX_PWM_CHANNEL_1		2
			#define MX_PWM_HWALT_1			0
#else
 #ifndef	MX_PWM_REF2
			#define MX_PWM_REF2
			#define PWM_7_MX_PWM_UREF			2
			#define MX_PWM_CHANNEL_2		2
			#define MX_PWM_HWALT_2			0
 #else
  #ifndef	MX_PWM_REF3
			#define MX_PWM_REF3
			#define PWM_7_MX_PWM_UREF			3
			#define MX_PWM_CHANNEL_3		2
			#define MX_PWM_HWALT_3			0
  #else
   #ifndef	MX_PWM_REF4
			#define MX_PWM_REF4
			#define PWM_7_MX_PWM_UREF			4
			#define MX_PWM_CHANNEL_4		2
			#define MX_PWM_HWALT_4			0
   #else
    #ifndef	MX_PWM_REF5
			#define MX_PWM_REF5
			#define PWM_7_MX_PWM_UREF			5
			#define MX_PWM_CHANNEL_5		2
			#define MX_PWM_HWALT_5			0
    #else
     #ifndef	MX_PWM_REF6
			#define MX_PWM_REF6
			#define PWM_7_MX_PWM_UREF			6
			#define MX_PWM_CHANNEL_6		2
			#define MX_PWM_HWALT_6			0
     #else
      #ifndef	MX_PWM_REF7
			#define MX_PWM_REF7
			#define PWM_7_MX_PWM_UREF			7
			#define MX_PWM_CHANNEL_7		2
			#define MX_PWM_HWALT_7			0
      #else
       #ifndef	MX_PWM_REF8
			#define MX_PWM_REF8
			#define PWM_7_MX_PWM_UREF			8
			#define MX_PWM_CHANNEL_8		2
			#define MX_PWM_HWALT_8			0
       #else
        #ifndef	MX_PWM_REF9
			#define MX_PWM_REF9
			#define PWM_7_MX_PWM_UREF			9
			#define MX_PWM_CHANNEL_9		2
			#define MX_PWM_HWALT_9			0
        #else
         #ifndef	MX_PWM_REF10
			#define MX_PWM_REF10
			#define PWM_7_MX_PWM_UREF			10
			#define MX_PWM_CHANNEL_10		2
			#define MX_PWM_HWALT_10			0
         #endif
        #endif
       #endif
      #endif
     #endif
    #endif
   #endif
  #endif
 #endif
#endif

#define PWM_7_PWM_Enable_Channel		CAL_APPEND(FC_CAL_PWM_Enable_Channel_, PWM_7_MX_PWM_UREF)
#define PWM_7_PWM_Disable_Channel		CAL_APPEND(FC_CAL_PWM_Disable_Channel_, PWM_7_MX_PWM_UREF)
#define PWM_7_PWM_Set_Duty_8Bit		CAL_APPEND(FC_CAL_PWM_Set_Duty_8Bit_, PWM_7_MX_PWM_UREF)
#define PWM_7_PWM_Change_Period		CAL_APPEND(FC_CAL_PWM_Change_Period_, PWM_7_MX_PWM_UREF)
#define PWM_7_PWM_Set_Duty_10Bit		CAL_APPEND(FC_CAL_PWM_Set_Duty_10Bit_, PWM_7_MX_PWM_UREF)

extern void PWM_7_PWM_Enable_Channel ();
extern void PWM_7_PWM_Disable_Channel ();
extern void PWM_7_PWM_Set_Duty_8Bit (MX_UINT8 duty);
extern void PWM_7_PWM_Change_Period (MX_UINT8 period, MX_UINT16 prescaler);
extern void PWM_7_PWM_Set_Duty_10Bit (MX_UINT16 duty);




//PWM(0): //Macro function declarations

void FCD_PWM0_Enable();
void FCD_PWM0_Disable();
void FCD_PWM0_SetDutyCycle(MX_UINT8 nDuty);
void FCD_PWM0_ChangePeriod(MX_UINT8 nPeriodVal, MX_UINT8 nPrescalerVal);
void FCD_PWM0_SetDutyCycle10bit(MX_SINT16 nDuty);


//RS232(0): //Defines:

/**** Macro Substitutions ****
a = Unique Reference
b = Uart Channel		(0-software / 1-4 hardware)
c = tx pin
d = tx port
e = rx pin
f = rx port
g = flow control		(0-Off / 1-On)
h = cts pin
i = cts port
j = rts pin
k = rts port
l = baud rate
m = data bits			(7/8/9) (7 only supported in software modes)
n = return type		(0-byte / 1-MX_UINT16)
o = echo enable		(0-Off / 1-On)
******************************/

//Definitions for RS232 UART slot allocation
#ifndef	MX_UART_REF1
	#define MX_UART_REF1
	#define RS232_8_MX_UART_UREF			1
	#define MX_UART_CHANNEL_1		1
	#define MX_UART_TX_PIN_1		0
	#define MX_UART_TX_PORT_1		porta
	#define MX_UART_TX_TRIS_1		trisa
	#define MX_UART_RX_PIN_1		0
	#define MX_UART_RX_PORT_1		porta
	#define MX_UART_RX_TRIS_1		trisa
	#define MX_UART_FLOWEN_1		0
	#define MX_UART_CTS_PIN_1		4
	#define MX_UART_CTS_PORT_1		portc
	#define MX_UART_CTS_TRIS_1		trisc
	#define MX_UART_RTS_PIN_1		0
	#define MX_UART_RTS_PORT_1		portc
	#define MX_UART_RTS_TRIS_1		trisc
	#define MX_UART_BAUD_1			9600
	#define MX_UART_DBITS_1			8
	#define MX_UART_RETURN_1		0
	#define MX_UART_ECHO_1			0
	#define MX_UART_INT_1			0
#else
 #ifndef	MX_UART_REF2
	#define MX_UART_REF2
	#define RS232_8_MX_UART_UREF			2
	#define MX_UART_CHANNEL_2		1
	#define MX_UART_TX_PIN_2		0
	#define MX_UART_TX_PORT_2		porta
	#define MX_UART_TX_TRIS_2		trisa
	#define MX_UART_RX_PIN_2		0
	#define MX_UART_RX_PORT_2		porta
	#define MX_UART_RX_TRIS_2		trisa
	#define MX_UART_FLOWEN_2		0
	#define MX_UART_CTS_PIN_2		4
	#define MX_UART_CTS_PORT_2		portc
	#define MX_UART_CTS_TRIS_2		trisc
	#define MX_UART_RTS_PIN_2		0
	#define MX_UART_RTS_PORT_2		portc
	#define MX_UART_RTS_TRIS_2		trisc
	#define MX_UART_BAUD_2			9600
	#define MX_UART_DBITS_2			8
	#define MX_UART_RETURN_2		0
	#define MX_UART_ECHO_2			0
	#define MX_UART_INT_2			0
 #else
  #ifndef	MX_UART_REF3
	#define MX_UART_REF3
	#define RS232_8_MX_UART_UREF			3
	#define MX_UART_CHANNEL_3		1
	#define MX_UART_TX_PIN_3		0
	#define MX_UART_TX_PORT_3		porta
	#define MX_UART_TX_TRIS_3		trisa
	#define MX_UART_RX_PIN_3		0
	#define MX_UART_RX_PORT_3		porta
	#define MX_UART_RX_TRIS_3		trisa
	#define MX_UART_FLOWEN_3		0
	#define MX_UART_CTS_PIN_3		4
	#define MX_UART_CTS_PORT_3		portc
	#define MX_UART_CTS_TRIS_3		trisc
	#define MX_UART_RTS_PIN_3		0
	#define MX_UART_RTS_PORT_3		portc
	#define MX_UART_RTS_TRIS_3		trisc
	#define MX_UART_BAUD_3			9600
	#define MX_UART_DBITS_3			8
	#define MX_UART_RETURN_3		0
	#define MX_UART_ECHO_3			0
	#define MX_UART_INT_3			0
  #else
   #ifndef	MX_UART_REF4
	#define MX_UART_REF4
	#define RS232_8_MX_UART_UREF			4
	#define MX_UART_CHANNEL_4		1
	#define MX_UART_TX_PIN_4		0
	#define MX_UART_TX_PORT_4		porta
	#define MX_UART_TX_TRIS_4		trisa
	#define MX_UART_RX_PIN_4		0
	#define MX_UART_RX_PORT_4		porta
	#define MX_UART_RX_TRIS_4		trisa
	#define MX_UART_FLOWEN_4		0
	#define MX_UART_CTS_PIN_4		4
	#define MX_UART_CTS_PORT_4		portc
	#define MX_UART_CTS_TRIS_4		trisc
	#define MX_UART_RTS_PIN_4		0
	#define MX_UART_RTS_PORT_4		portc
	#define MX_UART_RTS_TRIS_4		trisc
	#define MX_UART_BAUD_4			9600
	#define MX_UART_DBITS_4			8
	#define MX_UART_RETURN_4		0
	#define MX_UART_ECHO_4			0
	#define MX_UART_INT_4			0
   #endif
  #endif
 #endif
#endif

#define RS232_8_UART_Init		CAL_APPEND(FC_CAL_UART_Init_, RS232_8_MX_UART_UREF)
#define RS232_8_UART_Send		CAL_APPEND(FC_CAL_UART_Send_, RS232_8_MX_UART_UREF)
#define RS232_8_UART_Receive		CAL_APPEND(FC_CAL_UART_Receive_, RS232_8_MX_UART_UREF)
#define RS232_8_UART_Update_Baud CAL_APPEND(FC_CAL_UART_Update_Baud_, RS232_8_MX_UART_UREF)

extern void RS232_8_UART_Init();
extern void RS232_8_UART_Send(MX_UINT16 nChar);
extern MX_SINT16 RS232_8_UART_Receive(MX_UINT8 nTimeout);
extern void RS232_8_UART_Update_Baud(MX_UINT8 newbaud);




//RS232(0): //Macro function declarations

void FCD_RS2320_SendRS232Char(MX_SINT16 nChar);
void FCD_RS2320_SendRS232String(MX_STRING String, MX_UINT8 MSZ_String);
MX_SINT16 FCD_RS2320_ReceiveRS232Char(MX_UINT8 nTimeout);
void FCD_RS2320_ReceiveRS232String(MX_CHAR* FCR_RETVAL, MX_UINT8 FCR_RETVAL_SIZE, MX_UINT8 nTimeout, MX_UINT8 NumBytes);
void FCD_RS2320_ChangeHWBaud(MX_UINT8 newbaud);



//LCDDisplay(0): //Macro implementations


void FCD_LCDDisplay0_RawSend(MX_UINT8 in, MX_UINT8 mask)

{
	
		MX_UINT8 pt;

		FC_CAL_Bit_Low(LCD_1__PORT0, LCD_1__BIT0);
008D  1283  	BCF STATUS, RP0
008E  1106  	BCF gbl_portb,2

		FC_CAL_Bit_Low(LCD_1__PORT1, LCD_1__BIT1);
008F  1186  	BCF gbl_portb,3

		FC_CAL_Bit_Low(LCD_1__PORT2, LCD_1__BIT2);
0090  1206  	BCF gbl_portb,4

		FC_CAL_Bit_Low(LCD_1__PORT3, LCD_1__BIT3);
0091  1286  	BCF gbl_portb,5

		FC_CAL_Bit_Low(LCD_1__PORT4, LCD_1__RS);
0092  1006  	BCF gbl_portb,0

		FC_CAL_Bit_Low(LCD_1__PORT5, LCD_1__E);
0093  1086  	BCF gbl_portb,1

		pt = ((in >> 4) & 0x0f);
0094  1683  	BSF STATUS, RP0
0095  0E2E  	SWAPF FCD_LCDDis_00056_arg_in, W
0096  390F  	ANDLW 0x0F
0097  00B0  	MOVWF FCD_LCDDis_00056_1_pt
0098  300F  	MOVLW 0x0F
0099  05B0  	ANDWF FCD_LCDDis_00056_1_pt, F

		if (pt & 0x01)
009A  1C30  	BTFSS FCD_LCDDis_00056_1_pt,0
009B  289E  	GOTO	label11

		    FC_CAL_Bit_High(LCD_1__PORT0, LCD_1__BIT0);
009C  1283  	BCF STATUS, RP0
009D  1506  	BSF gbl_portb,2

		if (pt & 0x02)
009E  1683  	BSF STATUS, RP0
009F  1CB0  	BTFSS FCD_LCDDis_00056_1_pt,1
00A0  28A3  	GOTO	label12

		    FC_CAL_Bit_High(LCD_1__PORT1, LCD_1__BIT1);
00A1  1283  	BCF STATUS, RP0
00A2  1586  	BSF gbl_portb,3

		if (pt & 0x04)
00A3  1683  	BSF STATUS, RP0
00A4  1D30  	BTFSS FCD_LCDDis_00056_1_pt,2
00A5  28A8  	GOTO	label13

		    FC_CAL_Bit_High(LCD_1__PORT2, LCD_1__BIT2);
00A6  1283  	BCF STATUS, RP0
00A7  1606  	BSF gbl_portb,4

		if (pt & 0x08)
00A8  1683  	BSF STATUS, RP0
00A9  1DB0  	BTFSS FCD_LCDDis_00056_1_pt,3
00AA  28AD  	GOTO	label14

		    FC_CAL_Bit_High(LCD_1__PORT3, LCD_1__BIT3);
00AB  1283  	BCF STATUS, RP0
00AC  1686  	BSF gbl_portb,5

		if (mask)
00AD  1683  	BSF STATUS, RP0
00AE  08AF  	MOVF FCD_LCDDis_00056_arg_mask, F
00AF  1903  	BTFSC STATUS,Z
00B0  28B3  	GOTO	label15

		    FC_CAL_Bit_High(LCD_1__PORT4, LCD_1__RS);
00B1  1283  	BCF STATUS, RP0
00B2  1406  	BSF gbl_portb,0

		LCD_1__DELAY;
00B3  300A  	MOVLW 0x0A
00B4  1683  	BSF STATUS, RP0
00B5  00B1  	MOVWF delay_10us_00000_arg_del
00B6  203C  	CALL delay_10us_00000

		FC_CAL_Bit_High (LCD_1__PORT5, LCD_1__E);
00B7  1283  	BCF STATUS, RP0
00B8  1486  	BSF gbl_portb,1

		LCD_1__DELAY;
00B9  300A  	MOVLW 0x0A
00BA  1683  	BSF STATUS, RP0
00BB  00B1  	MOVWF delay_10us_00000_arg_del
00BC  203C  	CALL delay_10us_00000

		FC_CAL_Bit_Low (LCD_1__PORT5, LCD_1__E);
00BD  1283  	BCF STATUS, RP0
00BE  1086  	BCF gbl_portb,1

		pt = (in & 0x0f);
00BF  300F  	MOVLW 0x0F
00C0  1683  	BSF STATUS, RP0
00C1  052E  	ANDWF FCD_LCDDis_00056_arg_in, W
00C2  00B0  	MOVWF FCD_LCDDis_00056_1_pt

		LCD_1__DELAY;
00C3  300A  	MOVLW 0x0A
00C4  00B1  	MOVWF delay_10us_00000_arg_del
00C5  203C  	CALL delay_10us_00000

		FC_CAL_Bit_Low(LCD_1__PORT0, LCD_1__BIT0);
00C6  1283  	BCF STATUS, RP0
00C7  1106  	BCF gbl_portb,2

		FC_CAL_Bit_Low(LCD_1__PORT1, LCD_1__BIT1);
00C8  1186  	BCF gbl_portb,3

		FC_CAL_Bit_Low(LCD_1__PORT2, LCD_1__BIT2);
00C9  1206  	BCF gbl_portb,4

		FC_CAL_Bit_Low(LCD_1__PORT3, LCD_1__BIT3);
00CA  1286  	BCF gbl_portb,5

		FC_CAL_Bit_Low(LCD_1__PORT4, LCD_1__RS);
00CB  1006  	BCF gbl_portb,0

		FC_CAL_Bit_Low(LCD_1__PORT5, LCD_1__E);
00CC  1086  	BCF gbl_portb,1

		if (pt & 0x01)
00CD  1683  	BSF STATUS, RP0
00CE  1C30  	BTFSS FCD_LCDDis_00056_1_pt,0
00CF  28D2  	GOTO	label16

		    FC_CAL_Bit_High(LCD_1__PORT0, LCD_1__BIT0);
00D0  1283  	BCF STATUS, RP0
00D1  1506  	BSF gbl_portb,2

		if (pt & 0x02)
00D2  1683  	BSF STATUS, RP0
00D3  1CB0  	BTFSS FCD_LCDDis_00056_1_pt,1
00D4  28D7  	GOTO	label17

		    FC_CAL_Bit_High(LCD_1__PORT1, LCD_1__BIT1);
00D5  1283  	BCF STATUS, RP0
00D6  1586  	BSF gbl_portb,3

		if (pt & 0x04)
00D7  1683  	BSF STATUS, RP0
00D8  1D30  	BTFSS FCD_LCDDis_00056_1_pt,2
00D9  28DC  	GOTO	label18

		    FC_CAL_Bit_High(LCD_1__PORT2, LCD_1__BIT2);
00DA  1283  	BCF STATUS, RP0
00DB  1606  	BSF gbl_portb,4

		if (pt & 0x08)
00DC  1683  	BSF STATUS, RP0
00DD  1DB0  	BTFSS FCD_LCDDis_00056_1_pt,3
00DE  28E1  	GOTO	label19

		    FC_CAL_Bit_High(LCD_1__PORT3, LCD_1__BIT3);
00DF  1283  	BCF STATUS, RP0
00E0  1686  	BSF gbl_portb,5

		if (mask)
00E1  1683  	BSF STATUS, RP0
00E2  08AF  	MOVF FCD_LCDDis_00056_arg_mask, F
00E3  1903  	BTFSC STATUS,Z
00E4  28E7  	GOTO	label20

		    FC_CAL_Bit_High(LCD_1__PORT4, LCD_1__RS);
00E5  1283  	BCF STATUS, RP0
00E6  1406  	BSF gbl_portb,0

		LCD_1__DELAY;
00E7  300A  	MOVLW 0x0A
00E8  1683  	BSF STATUS, RP0
00E9  00B1  	MOVWF delay_10us_00000_arg_del
00EA  203C  	CALL delay_10us_00000

		FC_CAL_Bit_High (LCD_1__PORT5, LCD_1__E);
00EB  1283  	BCF STATUS, RP0
00EC  1486  	BSF gbl_portb,1

		LCD_1__DELAY;
00ED  300A  	MOVLW 0x0A
00EE  1683  	BSF STATUS, RP0
00EF  00B1  	MOVWF delay_10us_00000_arg_del
00F0  203C  	CALL delay_10us_00000

		FC_CAL_Bit_Low (LCD_1__PORT5, LCD_1__E);
00F1  1283  	BCF STATUS, RP0
00F2  1086  	BCF gbl_portb,1

		LCD_1__DELAY;
00F3  300A  	MOVLW 0x0A
00F4  1683  	BSF STATUS, RP0
00F5  00B1  	MOVWF delay_10us_00000_arg_del
00F6  203C  	CALL delay_10us_00000


}
00F7  0008  	RETURN


void FCD_LCDDisplay0_Start()

{
	
		FC_CAL_Bit_Low_DDR(LCD_1__PORT0, LCD_1__TRIS0, LCD_1__BIT0);
04D9  1683  	BSF STATUS, RP0
04DA  1303  	BCF STATUS, RP1
04DB  1106  	BCF gbl_trisb,2
04DC  1283  	BCF STATUS, RP0
04DD  1106  	BCF gbl_portb,2

		FC_CAL_Bit_Low_DDR(LCD_1__PORT1, LCD_1__TRIS1, LCD_1__BIT1);
04DE  1683  	BSF STATUS, RP0
04DF  1186  	BCF gbl_trisb,3
04E0  1283  	BCF STATUS, RP0
04E1  1186  	BCF gbl_portb,3

		FC_CAL_Bit_Low_DDR(LCD_1__PORT2, LCD_1__TRIS2, LCD_1__BIT2);
04E2  1683  	BSF STATUS, RP0
04E3  1206  	BCF gbl_trisb,4
04E4  1283  	BCF STATUS, RP0
04E5  1206  	BCF gbl_portb,4

		FC_CAL_Bit_Low_DDR(LCD_1__PORT3, LCD_1__TRIS3, LCD_1__BIT3);
04E6  1683  	BSF STATUS, RP0
04E7  1286  	BCF gbl_trisb,5
04E8  1283  	BCF STATUS, RP0
04E9  1286  	BCF gbl_portb,5

		FC_CAL_Bit_Low_DDR(LCD_1__PORT4, LCD_1__TRIS4, LCD_1__RS);
04EA  1683  	BSF STATUS, RP0
04EB  1006  	BCF gbl_trisb,0
04EC  1283  	BCF STATUS, RP0
04ED  1006  	BCF gbl_portb,0

		FC_CAL_Bit_Low_DDR(LCD_1__PORT5, LCD_1__TRIS5, LCD_1__E);
04EE  1683  	BSF STATUS, RP0
04EF  1086  	BCF gbl_trisb,1
04F0  1283  	BCF STATUS, RP0
04F1  1086  	BCF gbl_portb,1


		Wdt_Delay_Ms(12);
04F2  300C  	MOVLW 0x0C
04F3  00F7  	MOVWF Wdt_Delay__0003E_arg_delay
04F4  207F  	CALL Wdt_Delay__0003E


		FCD_LCDDisplay0_RawSend(0x33, 0);
04F5  3033  	MOVLW 0x33
04F6  1683  	BSF STATUS, RP0
04F7  00AE  	MOVWF FCD_LCDDis_00056_arg_in
04F8  01AF  	CLRF FCD_LCDDis_00056_arg_mask
04F9  208D  	CALL FCD_LCDDis_00056

		Wdt_Delay_Ms(2);
04FA  3002  	MOVLW 0x02
04FB  1283  	BCF STATUS, RP0
04FC  00F7  	MOVWF Wdt_Delay__0003E_arg_delay
04FD  207F  	CALL Wdt_Delay__0003E

		FCD_LCDDisplay0_RawSend(0x33, 0);
04FE  3033  	MOVLW 0x33
04FF  1683  	BSF STATUS, RP0
0500  00AE  	MOVWF FCD_LCDDis_00056_arg_in
0501  01AF  	CLRF FCD_LCDDis_00056_arg_mask
0502  208D  	CALL FCD_LCDDis_00056

		Wdt_Delay_Ms(2);
0503  3002  	MOVLW 0x02
0504  1283  	BCF STATUS, RP0
0505  00F7  	MOVWF Wdt_Delay__0003E_arg_delay
0506  207F  	CALL Wdt_Delay__0003E

		FCD_LCDDisplay0_RawSend(0x32, 0);
0507  3032  	MOVLW 0x32
0508  1683  	BSF STATUS, RP0
0509  00AE  	MOVWF FCD_LCDDis_00056_arg_in
050A  01AF  	CLRF FCD_LCDDis_00056_arg_mask
050B  208D  	CALL FCD_LCDDis_00056

		Wdt_Delay_Ms(2);
050C  3002  	MOVLW 0x02
050D  1283  	BCF STATUS, RP0
050E  00F7  	MOVWF Wdt_Delay__0003E_arg_delay
050F  207F  	CALL Wdt_Delay__0003E

		FCD_LCDDisplay0_RawSend(0x2c, 0);
0510  302C  	MOVLW 0x2C
0511  1683  	BSF STATUS, RP0
0512  00AE  	MOVWF FCD_LCDDis_00056_arg_in
0513  01AF  	CLRF FCD_LCDDis_00056_arg_mask
0514  208D  	CALL FCD_LCDDis_00056

		Wdt_Delay_Ms(2);
0515  3002  	MOVLW 0x02
0516  1283  	BCF STATUS, RP0
0517  00F7  	MOVWF Wdt_Delay__0003E_arg_delay
0518  207F  	CALL Wdt_Delay__0003E

		FCD_LCDDisplay0_RawSend(0x06, 0);
0519  3006  	MOVLW 0x06
051A  1683  	BSF STATUS, RP0
051B  00AE  	MOVWF FCD_LCDDis_00056_arg_in
051C  01AF  	CLRF FCD_LCDDis_00056_arg_mask
051D  208D  	CALL FCD_LCDDis_00056

		Wdt_Delay_Ms(2);
051E  3002  	MOVLW 0x02
051F  1283  	BCF STATUS, RP0
0520  00F7  	MOVWF Wdt_Delay__0003E_arg_delay
0521  207F  	CALL Wdt_Delay__0003E

		FCD_LCDDisplay0_RawSend(0x0c, 0);
0522  300C  	MOVLW 0x0C
0523  1683  	BSF STATUS, RP0
0524  00AE  	MOVWF FCD_LCDDis_00056_arg_in
0525  01AF  	CLRF FCD_LCDDis_00056_arg_mask
0526  208D  	CALL FCD_LCDDis_00056

		Wdt_Delay_Ms(2);
0527  3002  	MOVLW 0x02
0528  1283  	BCF STATUS, RP0
0529  00F7  	MOVWF Wdt_Delay__0003E_arg_delay
052A  207F  	CALL Wdt_Delay__0003E


		//clear the display
		FCD_LCDDisplay0_RawSend(0x01, 0);
052B  3001  	MOVLW 0x01
052C  1683  	BSF STATUS, RP0
052D  00AE  	MOVWF FCD_LCDDis_00056_arg_in
052E  01AF  	CLRF FCD_LCDDis_00056_arg_mask
052F  208D  	CALL FCD_LCDDis_00056

		Wdt_Delay_Ms(2);
0530  3002  	MOVLW 0x02
0531  1283  	BCF STATUS, RP0
0532  00F7  	MOVWF Wdt_Delay__0003E_arg_delay
0533  207F  	CALL Wdt_Delay__0003E

		FCD_LCDDisplay0_RawSend(0x02, 0);
0534  3002  	MOVLW 0x02
0535  1683  	BSF STATUS, RP0
0536  00AE  	MOVWF FCD_LCDDis_00056_arg_in
0537  01AF  	CLRF FCD_LCDDis_00056_arg_mask
0538  208D  	CALL FCD_LCDDis_00056

		Wdt_Delay_Ms(2);
0539  3002  	MOVLW 0x02
053A  1283  	BCF STATUS, RP0
053B  00F7  	MOVWF Wdt_Delay__0003E_arg_delay
053C  207F  	CALL Wdt_Delay__0003E


}
053D  0008  	RETURN


void FCD_LCDDisplay0_Clear()

{
	
		FCD_LCDDisplay0_RawSend(0x01, 0);
04C5  3001  	MOVLW 0x01
04C6  1683  	BSF STATUS, RP0
04C7  1303  	BCF STATUS, RP1
04C8  00AE  	MOVWF FCD_LCDDis_00056_arg_in
04C9  01AF  	CLRF FCD_LCDDis_00056_arg_mask
04CA  208D  	CALL FCD_LCDDis_00056

		Wdt_Delay_Ms(2);
04CB  3002  	MOVLW 0x02
04CC  1283  	BCF STATUS, RP0
04CD  00F7  	MOVWF Wdt_Delay__0003E_arg_delay
04CE  207F  	CALL Wdt_Delay__0003E

		FCD_LCDDisplay0_RawSend(0x02, 0);
04CF  3002  	MOVLW 0x02
04D0  1683  	BSF STATUS, RP0
04D1  00AE  	MOVWF FCD_LCDDis_00056_arg_in
04D2  01AF  	CLRF FCD_LCDDis_00056_arg_mask
04D3  208D  	CALL FCD_LCDDis_00056

		Wdt_Delay_Ms(2);
04D4  3002  	MOVLW 0x02
04D5  1283  	BCF STATUS, RP0
04D6  00F7  	MOVWF Wdt_Delay__0003E_arg_delay
04D7  207F  	CALL Wdt_Delay__0003E


}
04D8  0008  	RETURN


void FCD_LCDDisplay0_PrintASCII(MX_UINT8 Character)
{
	
		FCD_LCDDisplay0_RawSend(Character, 0x10);

}

void FCD_LCDDisplay0_Command(MX_UINT8 in)
{
	
		FCD_LCDDisplay0_RawSend(in, 0);
		Wdt_Delay_Ms(2);

}

void FCD_LCDDisplay0_Cursor(MX_UINT8 x, MX_UINT8 y)

{
	
	  #if (LCD_1__ROWCNT == 1)
	    y=0x80;
	  #endif

	  #if (LCD_1__ROWCNT == 2)
		if (y==0)
			y=0x80;
		else
			y=0xc0;
	  #endif

	  #if (LCD_1__ROWCNT == 4)
		if (y==0)
02E4  08F6  	MOVF FCD_LCDDis_00052_arg_y, F
02E5  1D03  	BTFSS STATUS,Z
02E6  2AEA  	GOTO	label55
02EA        label55

			y=0x80;
02E7  3080  	MOVLW 0x80
02E8  00F6  	MOVWF FCD_LCDDis_00052_arg_y

		else if (y==1)
02E9  2AF9  	GOTO	label58
02EA  0376  	DECF FCD_LCDDis_00052_arg_y, W
02EB  1D03  	BTFSS STATUS,Z
02EC  2AF0  	GOTO	label56
02F0        label56

			y=0xc0;
02ED  30C0  	MOVLW 0xC0
02EE  00F6  	MOVWF FCD_LCDDis_00052_arg_y


		#if (LCD_1__COLCNT == 16)
			else if (y==2)
02EF  2AF9  	GOTO	label58
02F0  0876  	MOVF FCD_LCDDis_00052_arg_y, W
02F1  3A02  	XORLW 0x02
02F2  1D03  	BTFSS STATUS,Z
02F3  2AF7  	GOTO	label57
02F7        label57

				y=0x90;
02F4  3090  	MOVLW 0x90
02F5  00F6  	MOVWF FCD_LCDDis_00052_arg_y

			else
02F6  2AF9  	GOTO	label58
02F9        label58

				y=0xd0;
02F7  30D0  	MOVLW 0xD0
02F8  00F6  	MOVWF FCD_LCDDis_00052_arg_y

		#endif

		#if (LCD_1__COLCNT == 20)
			else if (y==2)
				y=0x94;
			else
				y=0xd4;
		#endif
	  #endif

		FCD_LCDDisplay0_RawSend(y+x, 0);
02F9  0875  	MOVF FCD_LCDDis_00052_arg_x, W
02FA  0776  	ADDWF FCD_LCDDis_00052_arg_y, W
02FB  1683  	BSF STATUS, RP0
02FC  00AE  	MOVWF FCD_LCDDis_00056_arg_in
02FD  01AF  	CLRF FCD_LCDDis_00056_arg_mask
02FE  208D  	CALL FCD_LCDDis_00056

		Wdt_Delay_Ms(2);
02FF  3002  	MOVLW 0x02
0300  1283  	BCF STATUS, RP0
0301  00F7  	MOVWF Wdt_Delay__0003E_arg_delay
0302  207F  	CALL Wdt_Delay__0003E


}
0303  0008  	RETURN


void FCD_LCDDisplay0_PrintNumber(MX_SINT16 Number)

{
	
		MX_SINT16 tmp_int;
		MX_UINT8 tmp_byte;

		if (Number < 0)
01C0  1FF5  	BTFSS FCD_LCDDis_00054_arg_Number+D'1',7
01C1  29D1  	GOTO	label33
01D1        label33

		{
			FCD_LCDDisplay0_RawSend('-', 0x10);
01C2  302D  	MOVLW 0x2D
01C3  1683  	BSF STATUS, RP0
01C4  00AE  	MOVWF FCD_LCDDis_00056_arg_in
01C5  3010  	MOVLW 0x10
01C6  00AF  	MOVWF FCD_LCDDis_00056_arg_mask
01C7  208D  	CALL FCD_LCDDis_00056

			Number = 0 - Number;
01C8  1283  	BCF STATUS, RP0
01C9  0874  	MOVF FCD_LCDDis_00054_arg_Number, W
01CA  3C00  	SUBLW 0x00
01CB  00F9  	MOVWF CompTempVar2206
01CC  09F5  	COMF FCD_LCDDis_00054_arg_Number+D'1', F
01CD  1803  	BTFSC STATUS,C
01CE  0AF5  	INCF FCD_LCDDis_00054_arg_Number+D'1', F
01CF  0879  	MOVF CompTempVar2206, W
01D0  00F4  	MOVWF FCD_LCDDis_00054_arg_Number

		}

		tmp_int = Number;
01D1  0874  	MOVF FCD_LCDDis_00054_arg_Number, W
01D2  00F6  	MOVWF FCD_LCDDis_00054_1_tmp_int
01D3  0875  	MOVF FCD_LCDDis_00054_arg_Number+D'1', W
01D4  00F7  	MOVWF FCD_LCDDis_00054_1_tmp_int+D'1'

		if (Number >= 10000)
01D5  3027  	MOVLW 0x27
01D6  0275  	SUBWF FCD_LCDDis_00054_arg_Number+D'1', W
01D7  1D03  	BTFSS STATUS,Z
01D8  29DB  	GOTO	label34
01D9  3010  	MOVLW 0x10
01DA  0274  	SUBWF FCD_LCDDis_00054_arg_Number, W
01DB        label34
01DB  1C03  	BTFSS STATUS,C
01DC  2A0D  	GOTO	label38
01DD  1BF5  	BTFSC FCD_LCDDis_00054_arg_Number+D'1',7
01DE  2A0D  	GOTO	label38

		{
			tmp_byte = tmp_int / 10000;
01DF  01FE  	CLRF CompTempVar2209
01E0  0876  	MOVF FCD_LCDDis_00054_1_tmp_int, W
01E1  00FC  	MOVWF __div_16_1_00003_arg_a
01E2  0877  	MOVF FCD_LCDDis_00054_1_tmp_int+D'1', W
01E3  00FD  	MOVWF __div_16_1_00003_arg_a+D'1'
01E4  1FF7  	BTFSS FCD_LCDDis_00054_1_tmp_int+D'1',7
01E5  29EC  	GOTO	label35
01E6  09FC  	COMF __div_16_1_00003_arg_a, F
01E7  09FD  	COMF __div_16_1_00003_arg_a+D'1', F
01E8  0AFC  	INCF __div_16_1_00003_arg_a, F
01E9  1903  	BTFSC STATUS,Z
01EA  0AFD  	INCF __div_16_1_00003_arg_a+D'1', F
01EB  0AFE  	INCF CompTempVar2209, F
01EC        label35
01EC  3010  	MOVLW 0x10
01ED  1683  	BSF STATUS, RP0
01EE  00A0  	MOVWF __div_16_1_00003_arg_b
01EF  3027  	MOVLW 0x27
01F0  00A1  	MOVWF __div_16_1_00003_arg_b+D'1'
01F1  205E  	CALL __div_16_1_00003
01F2  0825  	MOVF CompTempVarRet214, W
01F3  1283  	BCF STATUS, RP0
01F4  00F8  	MOVWF FCD_LCDDis_00054_1_tmp_byte
01F5  1C7E  	BTFSS CompTempVar2209,0
01F6  29F9  	GOTO	label36
01F7  09F8  	COMF FCD_LCDDis_00054_1_tmp_byte, F
01F8  0AF8  	INCF FCD_LCDDis_00054_1_tmp_byte, F
01F9        label36

			FCD_LCDDisplay0_RawSend('0' + tmp_byte, 0x10);
01F9  0878  	MOVF FCD_LCDDis_00054_1_tmp_byte, W
01FA  3E30  	ADDLW 0x30
01FB  1683  	BSF STATUS, RP0
01FC  00AE  	MOVWF FCD_LCDDis_00056_arg_in
01FD  3010  	MOVLW 0x10
01FE  00AF  	MOVWF FCD_LCDDis_00056_arg_mask
01FF  208D  	CALL FCD_LCDDis_00056


			while (tmp_byte > 0)
0200        label37
0200  1283  	BCF STATUS, RP0
0201  0878  	MOVF FCD_LCDDis_00054_1_tmp_byte, W
0202  3C00  	SUBLW 0x00
0203  1803  	BTFSC STATUS,C
0204  2A0D  	GOTO	label38
020C  2A00  	GOTO	label37
020D        label38

			{
				tmp_int = tmp_int - 10000;
0205  3010  	MOVLW 0x10
0206  02F6  	SUBWF FCD_LCDDis_00054_1_tmp_int, F
0207  3027  	MOVLW 0x27
0208  1C03  	BTFSS STATUS,C
0209  3028  	MOVLW 0x28
020A  02F7  	SUBWF FCD_LCDDis_00054_1_tmp_int+D'1', F

				tmp_byte--;
020B  03F8  	DECF FCD_LCDDis_00054_1_tmp_byte, F

			}
		}
		if (Number >= 1000)
020D  3003  	MOVLW 0x03
020E  0275  	SUBWF FCD_LCDDis_00054_arg_Number+D'1', W
020F  1D03  	BTFSS STATUS,Z
0210  2A13  	GOTO	label39
0211  30E8  	MOVLW 0xE8
0212  0274  	SUBWF FCD_LCDDis_00054_arg_Number, W
0213        label39
0213  1C03  	BTFSS STATUS,C
0214  2A47  	GOTO	label43
0215  1BF5  	BTFSC FCD_LCDDis_00054_arg_Number+D'1',7
0216  2A47  	GOTO	label43

		{
			tmp_byte = tmp_int / 1000;
0217  01F9  	CLRF CompTempVar2213
0218  0876  	MOVF FCD_LCDDis_00054_1_tmp_int, W
0219  00FC  	MOVWF __div_16_1_00003_arg_a
021A  0877  	MOVF FCD_LCDDis_00054_1_tmp_int+D'1', W
021B  00FD  	MOVWF __div_16_1_00003_arg_a+D'1'
021C  1FF7  	BTFSS FCD_LCDDis_00054_1_tmp_int+D'1',7
021D  2A24  	GOTO	label40
021E  09FC  	COMF __div_16_1_00003_arg_a, F
021F  09FD  	COMF __div_16_1_00003_arg_a+D'1', F
0220  0AFC  	INCF __div_16_1_00003_arg_a, F
0221  1903  	BTFSC STATUS,Z
0222  0AFD  	INCF __div_16_1_00003_arg_a+D'1', F
0223  0AF9  	INCF CompTempVar2213, F
0224        label40
0224  30E8  	MOVLW 0xE8
0225  1683  	BSF STATUS, RP0
0226  00A0  	MOVWF __div_16_1_00003_arg_b
0227  3003  	MOVLW 0x03
0228  00A1  	MOVWF __div_16_1_00003_arg_b+D'1'
0229  205E  	CALL __div_16_1_00003
022A  0825  	MOVF CompTempVarRet214, W
022B  1283  	BCF STATUS, RP0
022C  00FE  	MOVWF CompTempVar2212
022D  1C79  	BTFSS CompTempVar2213,0
022E  2A31  	GOTO	label41
022F  09FE  	COMF CompTempVar2212, F
0230  0AFE  	INCF CompTempVar2212, F
0231        label41
0231  087E  	MOVF CompTempVar2212, W
0232  00F8  	MOVWF FCD_LCDDis_00054_1_tmp_byte

			FCD_LCDDisplay0_RawSend('0' + tmp_byte, 0x10);
0233  0878  	MOVF FCD_LCDDis_00054_1_tmp_byte, W
0234  3E30  	ADDLW 0x30
0235  1683  	BSF STATUS, RP0
0236  00AE  	MOVWF FCD_LCDDis_00056_arg_in
0237  3010  	MOVLW 0x10
0238  00AF  	MOVWF FCD_LCDDis_00056_arg_mask
0239  208D  	CALL FCD_LCDDis_00056


			while (tmp_byte > 0)
023A        label42
023A  1283  	BCF STATUS, RP0
023B  0878  	MOVF FCD_LCDDis_00054_1_tmp_byte, W
023C  3C00  	SUBLW 0x00
023D  1803  	BTFSC STATUS,C
023E  2A47  	GOTO	label43
0246  2A3A  	GOTO	label42
0247        label43

			{
				tmp_int = tmp_int - 1000;
023F  30E8  	MOVLW 0xE8
0240  02F6  	SUBWF FCD_LCDDis_00054_1_tmp_int, F
0241  3003  	MOVLW 0x03
0242  1C03  	BTFSS STATUS,C
0243  3004  	MOVLW 0x04
0244  02F7  	SUBWF FCD_LCDDis_00054_1_tmp_int+D'1', F

				tmp_byte--;
0245  03F8  	DECF FCD_LCDDis_00054_1_tmp_byte, F

			}
		}
		if (Number >= 100)
0247  0875  	MOVF FCD_LCDDis_00054_arg_Number+D'1', W
0248  3A80  	XORLW 0x80
0249  00F9  	MOVWF CompTempVar2216
024A  3080  	MOVLW 0x80
024B  0279  	SUBWF CompTempVar2216, W
024C  1D03  	BTFSS STATUS,Z
024D  2A50  	GOTO	label44
024E  3064  	MOVLW 0x64
024F  0274  	SUBWF FCD_LCDDis_00054_arg_Number, W
0250        label44
0250  1C03  	BTFSS STATUS,C
0251  2A80  	GOTO	label48

		{
			tmp_byte = tmp_int / 100;
0252  01F9  	CLRF CompTempVar2218
0253  0876  	MOVF FCD_LCDDis_00054_1_tmp_int, W
0254  00FC  	MOVWF __div_16_1_00003_arg_a
0255  0877  	MOVF FCD_LCDDis_00054_1_tmp_int+D'1', W
0256  00FD  	MOVWF __div_16_1_00003_arg_a+D'1'
0257  1FF7  	BTFSS FCD_LCDDis_00054_1_tmp_int+D'1',7
0258  2A5F  	GOTO	label45
0259  09FC  	COMF __div_16_1_00003_arg_a, F
025A  09FD  	COMF __div_16_1_00003_arg_a+D'1', F
025B  0AFC  	INCF __div_16_1_00003_arg_a, F
025C  1903  	BTFSC STATUS,Z
025D  0AFD  	INCF __div_16_1_00003_arg_a+D'1', F
025E  0AF9  	INCF CompTempVar2218, F
025F        label45
025F  3064  	MOVLW 0x64
0260  1683  	BSF STATUS, RP0
0261  00A0  	MOVWF __div_16_1_00003_arg_b
0262  01A1  	CLRF __div_16_1_00003_arg_b+D'1'
0263  205E  	CALL __div_16_1_00003
0264  0825  	MOVF CompTempVarRet214, W
0265  1283  	BCF STATUS, RP0
0266  00FE  	MOVWF CompTempVar2217
0267  1C79  	BTFSS CompTempVar2218,0
0268  2A6B  	GOTO	label46
0269  09FE  	COMF CompTempVar2217, F
026A  0AFE  	INCF CompTempVar2217, F
026B        label46
026B  087E  	MOVF CompTempVar2217, W
026C  00F8  	MOVWF FCD_LCDDis_00054_1_tmp_byte

			FCD_LCDDisplay0_RawSend('0' + tmp_byte, 0x10);
026D  0878  	MOVF FCD_LCDDis_00054_1_tmp_byte, W
026E  3E30  	ADDLW 0x30
026F  1683  	BSF STATUS, RP0
0270  00AE  	MOVWF FCD_LCDDis_00056_arg_in
0271  3010  	MOVLW 0x10
0272  00AF  	MOVWF FCD_LCDDis_00056_arg_mask
0273  208D  	CALL FCD_LCDDis_00056


			while (tmp_byte > 0)
0274        label47
0274  1283  	BCF STATUS, RP0
0275  0878  	MOVF FCD_LCDDis_00054_1_tmp_byte, W
0276  3C00  	SUBLW 0x00
0277  1803  	BTFSC STATUS,C
0278  2A80  	GOTO	label48
027F  2A74  	GOTO	label47
0280        label48

			{
				tmp_int = tmp_int - 100;
0279  3064  	MOVLW 0x64
027A  02F6  	SUBWF FCD_LCDDis_00054_1_tmp_int, F
027B  08F7  	MOVF FCD_LCDDis_00054_1_tmp_int+D'1', F
027C  1C03  	BTFSS STATUS,C
027D  03F7  	DECF FCD_LCDDis_00054_1_tmp_int+D'1', F

				tmp_byte--;
027E  03F8  	DECF FCD_LCDDis_00054_1_tmp_byte, F

			}
		}
		if (Number >= 10)
0280  0875  	MOVF FCD_LCDDis_00054_arg_Number+D'1', W
0281  3A80  	XORLW 0x80
0282  00F9  	MOVWF CompTempVar2221
0283  3080  	MOVLW 0x80
0284  0279  	SUBWF CompTempVar2221, W
0285  1D03  	BTFSS STATUS,Z
0286  2A89  	GOTO	label49
0287  300A  	MOVLW 0x0A
0288  0274  	SUBWF FCD_LCDDis_00054_arg_Number, W
0289        label49
0289  1C03  	BTFSS STATUS,C
028A  2AB9  	GOTO	label53

		{
			tmp_byte = tmp_int / 10;
028B  01F9  	CLRF CompTempVar2223
028C  0876  	MOVF FCD_LCDDis_00054_1_tmp_int, W
028D  00FC  	MOVWF __div_16_1_00003_arg_a
028E  0877  	MOVF FCD_LCDDis_00054_1_tmp_int+D'1', W
028F  00FD  	MOVWF __div_16_1_00003_arg_a+D'1'
0290  1FF7  	BTFSS FCD_LCDDis_00054_1_tmp_int+D'1',7
0291  2A98  	GOTO	label50
0292  09FC  	COMF __div_16_1_00003_arg_a, F
0293  09FD  	COMF __div_16_1_00003_arg_a+D'1', F
0294  0AFC  	INCF __div_16_1_00003_arg_a, F
0295  1903  	BTFSC STATUS,Z
0296  0AFD  	INCF __div_16_1_00003_arg_a+D'1', F
0297  0AF9  	INCF CompTempVar2223, F
0298        label50
0298  300A  	MOVLW 0x0A
0299  1683  	BSF STATUS, RP0
029A  00A0  	MOVWF __div_16_1_00003_arg_b
029B  01A1  	CLRF __div_16_1_00003_arg_b+D'1'
029C  205E  	CALL __div_16_1_00003
029D  0825  	MOVF CompTempVarRet214, W
029E  1283  	BCF STATUS, RP0
029F  00FE  	MOVWF CompTempVar2222
02A0  1C79  	BTFSS CompTempVar2223,0
02A1  2AA4  	GOTO	label51
02A2  09FE  	COMF CompTempVar2222, F
02A3  0AFE  	INCF CompTempVar2222, F
02A4        label51
02A4  087E  	MOVF CompTempVar2222, W
02A5  00F8  	MOVWF FCD_LCDDis_00054_1_tmp_byte

			FCD_LCDDisplay0_RawSend('0' + tmp_byte, 0x10);
02A6  0878  	MOVF FCD_LCDDis_00054_1_tmp_byte, W
02A7  3E30  	ADDLW 0x30
02A8  1683  	BSF STATUS, RP0
02A9  00AE  	MOVWF FCD_LCDDis_00056_arg_in
02AA  3010  	MOVLW 0x10
02AB  00AF  	MOVWF FCD_LCDDis_00056_arg_mask
02AC  208D  	CALL FCD_LCDDis_00056


			while (tmp_byte > 0)
02AD        label52
02AD  1283  	BCF STATUS, RP0
02AE  0878  	MOVF FCD_LCDDis_00054_1_tmp_byte, W
02AF  3C00  	SUBLW 0x00
02B0  1803  	BTFSC STATUS,C
02B1  2AB9  	GOTO	label53
02B8  2AAD  	GOTO	label52
02B9        label53

			{
				tmp_int = tmp_int - 10;
02B2  300A  	MOVLW 0x0A
02B3  02F6  	SUBWF FCD_LCDDis_00054_1_tmp_int, F
02B4  08F7  	MOVF FCD_LCDDis_00054_1_tmp_int+D'1', F
02B5  1C03  	BTFSS STATUS,C
02B6  03F7  	DECF FCD_LCDDis_00054_1_tmp_int+D'1', F

				tmp_byte--;
02B7  03F8  	DECF FCD_LCDDis_00054_1_tmp_byte, F

			}
		}
		FCD_LCDDisplay0_RawSend('0' + tmp_int, 0x10);
02B9  0876  	MOVF FCD_LCDDis_00054_1_tmp_int, W
02BA  3E30  	ADDLW 0x30
02BB  1683  	BSF STATUS, RP0
02BC  00AE  	MOVWF FCD_LCDDis_00056_arg_in
02BD  3010  	MOVLW 0x10
02BE  00AF  	MOVWF FCD_LCDDis_00056_arg_mask
02BF  208D  	CALL FCD_LCDDis_00056


}
02C0  0008  	RETURN


void FCD_LCDDisplay0_PrintString(MX_STRING String, MX_UINT8 MSZ_String)

{
	
		MX_UINT8 idx = 0;
02C1  1683  	BSF STATUS, RP0
02C2  01AD  	CLRF FCD_LCDDis_00053_1_idx


		for (idx=0; idx<MSZ_String; idx++)
02C3  01AD  	CLRF FCD_LCDDis_00053_1_idx
02C4        label54
02C4  1283  	BCF STATUS, RP0
02C5  087E  	MOVF FCD_LCDDis_00053_arg_MSZ_String, W
02C6  1683  	BSF STATUS, RP0
02C7  022D  	SUBWF FCD_LCDDis_00053_1_idx, W
02C8  1803  	BTFSC STATUS,C
02E2  0AAD  	INCF FCD_LCDDis_00053_1_idx, F
02E3  2AC4  	GOTO	label54

		{
			if (String[idx] == 0)
02CA  1383  	BCF STATUS,IRP
02CB  1283  	BCF STATUS, RP0
02CC  1875  	BTFSC FCD_LCDDis_00053_arg_String+D'1',0
02CD  1783  	BSF STATUS,IRP
02CE  0874  	MOVF FCD_LCDDis_00053_arg_String, W
02CF  1683  	BSF STATUS, RP0
02D0  072D  	ADDWF FCD_LCDDis_00053_1_idx, W
02D1  0084  	MOVWF FSR
02D2  0880  	MOVF INDF, F
02D3  1903  	BTFSC STATUS,Z

			{
				break;

			}
			FCD_LCDDisplay0_RawSend(String[idx], 0x10);
02D5  1383  	BCF STATUS,IRP
02D6  1283  	BCF STATUS, RP0
02D7  1875  	BTFSC FCD_LCDDis_00053_arg_String+D'1',0
02D8  1783  	BSF STATUS,IRP
02D9  0874  	MOVF FCD_LCDDis_00053_arg_String, W
02DA  1683  	BSF STATUS, RP0
02DB  072D  	ADDWF FCD_LCDDis_00053_1_idx, W
02DC  0084  	MOVWF FSR
02DD  0800  	MOVF INDF, W
02DE  00AE  	MOVWF FCD_LCDDis_00056_arg_in
02DF  3010  	MOVLW 0x10
02E0  00AF  	MOVWF FCD_LCDDis_00056_arg_mask
02E1  208D  	CALL FCD_LCDDis_00056

		}

}
02C9  0008  	RETURN
02D4  0008  	RETURN


void FCD_LCDDisplay0_ScrollDisplay(MX_UINT8 Direction, MX_UINT8 Num_Positions)
{
	
		MX_UINT8 cmd = 0;
		MX_UINT8 count;

		//Choose the direction
		switch (Direction)
		{
			case 0:
			case 'l':
			case 'L':

				cmd = 0x18;
				break;

			case 1:
			case 'r':
			case 'R':

				cmd = 0x1C;
				break;

			default:
				break;
		}

		//If direction accepted then scroll the specified amount
		if (cmd)
		{
			for (count = 0; count < Num_Positions; count++)
				FCD_LCDDisplay0_Command(cmd);
		}

}

void FCD_LCDDisplay0_ClearLine(MX_UINT8 Line)

{
	
		MX_UINT8 count;
		MX_UINT8 rowcount;

		//Define number of columns per line
		#if (LCD_1__ROWCNT == 1)
			rowcount=80;
		#endif

		#if (LCD_1__ROWCNT == 2)
			rowcount=40;
		#endif

		#if (LCD_1__ROWCNT == 4)
			#if (LCD_1__COLCNT == 16)
				rowcount=16;
04AC  3010  	MOVLW 0x10
04AD  00F4  	MOVWF FCD_LCDDis_0005D_1_rowcount

			#endif
			#if (LCD_1__COLCNT == 20)
				rowcount=20;
			#endif
		#endif

		//Start at beginning of the line
		FCD_LCDDisplay0_Cursor (0, Line);
04AE  01F5  	CLRF FCD_LCDDis_00052_arg_x
04AF  0872  	MOVF FCD_LCDDis_0005D_arg_Line, W
04B0  00F6  	MOVWF FCD_LCDDis_00052_arg_y
04B1  22E4  	CALL FCD_LCDDis_00052


		//Send out spaces to clear line
		for (count = 0; count < rowcount; count++)
04B2  01F3  	CLRF FCD_LCDDis_0005D_1_count
04B3        label75
04B3  0874  	MOVF FCD_LCDDis_0005D_1_rowcount, W
04B4  0273  	SUBWF FCD_LCDDis_0005D_1_count, W
04B5  1803  	BTFSC STATUS,C
04B6  2CC0  	GOTO	label76
04BD  1283  	BCF STATUS, RP0
04BE  0AF3  	INCF FCD_LCDDis_0005D_1_count, F
04BF  2CB3  	GOTO	label75
04C0        label76

			FCD_LCDDisplay0_RawSend(' ', 0x10);
04B7  3020  	MOVLW 0x20
04B8  1683  	BSF STATUS, RP0
04B9  00AE  	MOVWF FCD_LCDDis_00056_arg_in
04BA  3010  	MOVLW 0x10
04BB  00AF  	MOVWF FCD_LCDDis_00056_arg_mask
04BC  208D  	CALL FCD_LCDDis_00056


		//Move back to the beginning of the line.
		FCD_LCDDisplay0_Cursor (0, Line);
04C0  01F5  	CLRF FCD_LCDDis_00052_arg_x
04C1  0872  	MOVF FCD_LCDDis_0005D_arg_Line, W
04C2  00F6  	MOVWF FCD_LCDDis_00052_arg_y
04C3  22E4  	CALL FCD_LCDDis_00052


}
04C4  0008  	RETURN


void FCD_LCDDisplay0_RAM_Write(MX_UINT8 nIdx, MX_UINT8 d0, MX_UINT8 d1, MX_UINT8 d2, MX_UINT8 d3, MX_UINT8 d4, MX_UINT8 d5, MX_UINT8 d6, MX_UINT8 d7)
{
	   //set CGRAM address

	   FCD_LCDDisplay0_RawSend(64 + (nIdx << 3), 0);
	   delay_ms(2);

	   //write CGRAM data
	   FCD_LCDDisplay0_RawSend(d0, 0x10);
	   FCD_LCDDisplay0_RawSend(d1, 0x10);
	   FCD_LCDDisplay0_RawSend(d2, 0x10);
	   FCD_LCDDisplay0_RawSend(d3, 0x10);
	   FCD_LCDDisplay0_RawSend(d4, 0x10);
	   FCD_LCDDisplay0_RawSend(d5, 0x10);
	   FCD_LCDDisplay0_RawSend(d6, 0x10);
	   FCD_LCDDisplay0_RawSend(d7, 0x10);

	   //Clear the display
	   FCD_LCDDisplay0_RawSend(0x01, 0);
	   delay_ms(2);
	   FCD_LCDDisplay0_RawSend(0x02, 0);
	   delay_ms(2);

}



//ADC(0): //Macro implementations


void FCD_ADC0_SampleADC()
{
	
	    //unused

}

MX_UINT8 FCD_ADC0_ReadAsByte()

{
	
		MX_UINT8 retVal;

		//Configure & Enable ADC Channel
		FC_CAL_Enable_ADC ( ADC_6_MX_ADC_CHANNEL , ADC_6_MX_ADC_CONVSP , ADC_6_MX_ADC_VREFOP , ADC_6_MX_ADC_ACTIME );
053E  1283  	BCF STATUS, RP0
053F  1303  	BCF STATUS, RP1
0540  01F3  	CLRF FC_CAL_Ena_0005F_arg_Channel
0541  3003  	MOVLW 0x03
0542  00F4  	MOVWF FC_CAL_Ena_0005F_arg_Conv_Speed
0543  01F5  	CLRF FC_CAL_Ena_0005F_arg_Vref
0544  3028  	MOVLW 0x28
0545  00F6  	MOVWF FC_CAL_Ena_0005F_arg_T_Charge
0546  2166  	CALL FC_CAL_Ena_0005F


		retVal = FC_CAL_Sample_ADC( 0 );				//Perform Sample - Return as byte
0547  01F3  	CLRF FC_CAL_Sam_00060_arg_Sample_Mode
0548  211A  	CALL FC_CAL_Sam_00060
0549  0876  	MOVF CompTempVarRet2238, W
054A  00F2  	MOVWF FCD_ADC0_R_00063_1_retVal


		FC_CAL_Disable_ADC ();
054B  21AD  	CALL FC_CAL_Dis_00061


		return (retVal);
054C  0872  	MOVF FCD_ADC0_R_00063_1_retVal, W
054D  00F3  	MOVWF CompTempVarRet2244


}
054E  0008  	RETURN


MX_UINT16 FCD_ADC0_ReadAsInt()
{
	
		MX_UINT16 retVal;

		//Configure & Enable ADC Channel
		FC_CAL_Enable_ADC ( ADC_6_MX_ADC_CHANNEL , ADC_6_MX_ADC_CONVSP , ADC_6_MX_ADC_VREFOP , ADC_6_MX_ADC_ACTIME );

		retVal = FC_CAL_Sample_ADC( 1 );				//Perform Sample - Return as MX_UINT16

		FC_CAL_Disable_ADC ();

		return (retVal);

}

MX_FLOAT FCD_ADC0_ReadAsVoltage()
{
	
		MX_UINT16 iSample;
		MX_FLOAT fSample, fVoltage, fVperDiv;

		//Configure & Enable ADC Channel
		FC_CAL_Enable_ADC ( ADC_6_MX_ADC_CHANNEL , ADC_6_MX_ADC_CONVSP , ADC_6_MX_ADC_VREFOP , ADC_6_MX_ADC_ACTIME );

	  #ifdef MX_ADC_BITS_8
		iSample = FC_CAL_Sample_ADC( 0 );								//Perform Sample - Return as byte
	  #else
		iSample = FC_CAL_Sample_ADC( 1 );								//Perform Sample - Return as MX_UINT16
	  #endif

	  	FC_CAL_Disable_ADC ();											//Switch off ADC peripheral
		fVoltage = flt_fromi( ADC_6_MX_ADC_VREFVOL );						//Convert reference voltage count to floating point (0 - 500 x 10mV)
		fVoltage = flt_mul(fVoltage, 0.01);								//Convert reference voltage count to actual voltage (0 - 5)

	  #ifdef MX_ADC_BITS_8
		fVperDiv = flt_mul(fVoltage, 0.00390625);						//Convert actual voltage to voltage per division (VRef / 256)
	  #endif
	  #ifdef MX_ADC_BITS_10
		fVperDiv = flt_mul(fVoltage, 0.000976);							//Convert actual voltage to voltage per division (VRef / 1024)
	  #endif
	  #ifdef MX_ADC_BITS_12
		fVperDiv = flt_mul(fVoltage, 0.00024414);						//Convert actual voltage to voltage per division (VRef / 4096)
	  #endif

		fSample = flt_fromi(iSample);									//Convert to floating point variable
		fVoltage = flt_mul(fSample, fVperDiv);							//Calculate floating point voltage

		return (fVoltage);

}

void FCD_ADC0_ReadAsString(MX_CHAR* FCR_RETVAL, MX_UINT8 FCR_RETVAL_SIZE)
{
	
		MX_FLOAT fVoltage;

		fVoltage = FCD_ADC0_ReadAsVoltage();
		FCI_FLOAT_TO_STRING(fVoltage, 2, FCR_RETVAL, FCR_RETVAL_SIZE);	//Convert to String

}

void FCD_ADC0_ADC_RAW_Configure_Channel()
{
	
		//Configure & Enable ADC Channel
		FC_CAL_Enable_ADC ( ADC_6_MX_ADC_CHANNEL , ADC_6_MX_ADC_CONVSP , ADC_6_MX_ADC_VREFOP , ADC_6_MX_ADC_ACTIME );

}

MX_UINT8 FCD_ADC0_ADC_RAW_Sample_Channel_Byte()
{
	
		return FC_CAL_Sample_ADC( 0 );									//Perform Sample - Return as byte

}

MX_UINT16 FCD_ADC0_ADC_RAW_Sample_Channel_Int()
{
	
		return FC_CAL_Sample_ADC( 1 );									//Perform Sample - Return as MX_UINT16

}

MX_UINT8 FCD_ADC0_ADC_RAW_Average_Channel_Byte(MX_UINT8 NumSamples, MX_UINT8 DelayUs)
{
	
		MX_UINT32 average = 0;
		MX_UINT8 count;

		for (count=0; count<NumSamples; count++)
		{
			average = average + FC_CAL_Sample_ADC( 0 );					//Perform Sample - Return as byte - add to average

			if (DelayUs)
				delay_us(DelayUs);										//If delay is not 0 then pause between samples
		}
		average = average / count;

		return (average & 0xFF);										//Return average as byte

}

MX_UINT16 FCD_ADC0_ADC_RAW_Average_Channel_Int(MX_UINT8 NumSamples, MX_UINT8 DelayUs)
{
	
		MX_UINT32 average = 0;
		MX_UINT8 count;

		for (count=0; count<NumSamples; count++)
		{
			average = average + FC_CAL_Sample_ADC( 1 );					//Perform Sample - Return as MX_UINT16 - add to average

			if (DelayUs)
				delay_us(DelayUs);										//If delay is not 0 then pause between samples
		}
		average = average / count;

		return (average & 0x1FFF);										//Return average as MX_SINT16

}

void FCD_ADC0_ADC_RAW_Disable_Channel()
{
	
		FC_CAL_Disable_ADC ();											//Disable ADC Channel

}



//PWM(0): //Macro implementations


void FCD_PWM0_Enable()

{
	
		PWM_7_PWM_Change_Period (MX_PWM_PERIOD, MX_PWM_PRESCALE1);
04A2  30FF  	MOVLW 0xFF
04A3  1283  	BCF STATUS, RP0
04A4  1303  	BCF STATUS, RP1
04A5  00F2  	MOVWF FC_CAL_PWM_00071_arg_period
04A6  3001  	MOVLW 0x01
04A7  00F3  	MOVWF FC_CAL_PWM_00071_arg_prescaler
04A8  01F4  	CLRF FC_CAL_PWM_00071_arg_prescaler+D'1'
04A9  213E  	CALL FC_CAL_PWM_00071

		PWM_7_PWM_Enable_Channel ();
04AA  215E  	CALL FC_CAL_PWM_0006E


}
04AB  0008  	RETURN


void FCD_PWM0_Disable()
{
	
		PWM_7_PWM_Disable_Channel();

}

void FCD_PWM0_SetDutyCycle(MX_UINT8 nDuty)

{
	
		PWM_7_PWM_Set_Duty_8Bit(nDuty);
01BC  0872  	MOVF FCD_PWM0_S_00055_arg_nDuty, W
01BD  00F3  	MOVWF FC_CAL_PWM_00070_arg_duty
01BE  208A  	CALL FC_CAL_PWM_00070


}
01BF  0008  	RETURN


void FCD_PWM0_ChangePeriod(MX_UINT8 nPeriodVal, MX_UINT8 nPrescalerVal)
{
	
		PWM_7_PWM_Change_Period (nPeriodVal, nPrescalerVal);

}

void FCD_PWM0_SetDutyCycle10bit(MX_SINT16 nDuty)
{
	
		PWM_7_PWM_Set_Duty_10Bit(nDuty);

}



//RS232(0): //Macro implementations


void FCD_RS2320_SendRS232Char(MX_SINT16 nChar)
{
	
		RS232_8_UART_Send ( nChar);

}

void FCD_RS2320_SendRS232String(MX_STRING String, MX_UINT8 MSZ_String)

{
	
		MX_UINT8 idx;
		for(idx = 0; idx < MSZ_String; idx++)
0488  01F8  	CLRF FCD_RS2320_0007E_1_idx
0489        label74
0489  0877  	MOVF FCD_RS2320_0007E_arg_MSZ_String, W
048A  0278  	SUBWF FCD_RS2320_0007E_1_idx, W
048B  1803  	BTFSC STATUS,C
04A0  0AF8  	INCF FCD_RS2320_0007E_1_idx, F
04A1  2C89  	GOTO	label74

		{
			if (String[idx] == 0)
048D  1383  	BCF STATUS,IRP
048E  1873  	BTFSC FCD_RS2320_0007E_arg_String+D'1',0
048F  1783  	BSF STATUS,IRP
0490  0872  	MOVF FCD_RS2320_0007E_arg_String, W
0491  0778  	ADDWF FCD_RS2320_0007E_1_idx, W
0492  0084  	MOVWF FSR
0493  0880  	MOVF INDF, F
0494  1903  	BTFSC STATUS,Z

				break;
			else RS232_8_UART_Send ( String[idx] );
0496  1383  	BCF STATUS,IRP
0497  1873  	BTFSC FCD_RS2320_0007E_arg_String+D'1',0
0498  1783  	BSF STATUS,IRP
0499  0872  	MOVF FCD_RS2320_0007E_arg_String, W
049A  0778  	ADDWF FCD_RS2320_0007E_1_idx, W
049B  0084  	MOVWF FSR
049C  0800  	MOVF INDF, W
049D  00F9  	MOVWF FC_CAL_UAR_00079_arg_nChar
049E  01FA  	CLRF FC_CAL_UAR_00079_arg_nChar+D'1'
049F  2115  	CALL FC_CAL_UAR_00079

		}

}
048C  0008  	RETURN
0495  0008  	RETURN


MX_SINT16 FCD_RS2320_ReceiveRS232Char(MX_UINT8 nTimeout)
{
	
		return ( RS232_8_UART_Receive ( nTimeout) );

}

void FCD_RS2320_ReceiveRS232String(MX_CHAR* FCR_RETVAL, MX_UINT8 FCR_RETVAL_SIZE, MX_UINT8 nTimeout, MX_UINT8 NumBytes)
{
	
		MX_UINT8 idx;
		MX_SINT16 RS232_TO = 255;
		MX_SINT16 in;

		if ( 0 != 0 )
			RS232_TO = 256;

		if (NumBytes > FCR_RETVAL_SIZE)
			NumBytes = FCR_RETVAL_SIZE;

		for (idx = 0; idx < NumBytes; idx++)
		{
			in = RS232_8_UART_Receive ( nTimeout);
			if(in < RS232_TO)
				FCR_RETVAL[idx] = in & 0xFF;
			else
				break;
		}

		if (idx < FCR_RETVAL_SIZE)
			FCR_RETVAL[idx] = 0;

}

void FCD_RS2320_ChangeHWBaud(MX_UINT8 newbaud)
{
	
		RS232_8_UART_Update_Baud (newbaud);

}

#include "C:\Program Files (x86)\Flowcode\v5\CAL\includes.c"

//Macro implementations


void FCM_display()

{

	//Call Component Macro
	//Call Component Macro: Cursor(2, 0)
	FCD_LCDDisplay0_Cursor(2, 0);
0329  3002  	MOVLW 0x02
032A  1283  	BCF STATUS, RP0
032B  1303  	BCF STATUS, RP1
032C  00F5  	MOVWF FCD_LCDDis_00052_arg_x
032D  01F6  	CLRF FCD_LCDDis_00052_arg_y
032E  22E4  	CALL FCD_LCDDis_00052


	//Call Component Macro
	//Call Component Macro: PrintString("HELLO WORLD!")
	FCD_LCDDisplay0_PrintString("HELLO WORLD!", 12);
032F  3020  	MOVLW 0x20
0330  1683  	BSF STATUS, RP0
0331  00A5  	MOVWF CompTempVar2188+D'5'
0332  3021  	MOVLW 0x21
0333  00AB  	MOVWF CompTempVar2188+D'11'
0334  3044  	MOVLW 0x44
0335  00AA  	MOVWF CompTempVar2188+D'10'
0336  3045  	MOVLW 0x45
0337  00A1  	MOVWF CompTempVar2188+D'1'
0338  3048  	MOVLW 0x48
0339  00A0  	MOVWF CompTempVar2188
033A  304C  	MOVLW 0x4C
033B  00A2  	MOVWF CompTempVar2188+D'2'
033C  00A3  	MOVWF CompTempVar2188+D'3'
033D  00A9  	MOVWF CompTempVar2188+D'9'
033E  304F  	MOVLW 0x4F
033F  00A4  	MOVWF CompTempVar2188+D'4'
0340  00A7  	MOVWF CompTempVar2188+D'7'
0341  3052  	MOVLW 0x52
0342  00A8  	MOVWF CompTempVar2188+D'8'
0343  3057  	MOVLW 0x57
0344  00A6  	MOVWF CompTempVar2188+D'6'
0345  01AC  	CLRF CompTempVar2188+D'12'
0346  3000  	MOVLW HIGH(CompTempVar2188+D'0')
0347  1283  	BCF STATUS, RP0
0348  00F5  	MOVWF FCD_LCDDis_00053_arg_String+D'1'
0349  30A0  	MOVLW LOW(CompTempVar2188+D'0')
034A  00F4  	MOVWF FCD_LCDDis_00053_arg_String
034B  300C  	MOVLW 0x0C
034C  00FE  	MOVWF FCD_LCDDis_00053_arg_MSZ_String
034D  22C1  	CALL FCD_LCDDis_00053


	//Call Component Macro
	//Call Component Macro: Cursor(0, 1)
	FCD_LCDDisplay0_Cursor(0, 1);
034E  1283  	BCF STATUS, RP0
034F  01F5  	CLRF FCD_LCDDis_00052_arg_x
0350  3001  	MOVLW 0x01
0351  00F6  	MOVWF FCD_LCDDis_00052_arg_y
0352  22E4  	CALL FCD_LCDDis_00052


	//Call Component Macro
	//Call Component Macro: PrintNumber(b_sw0)
	FCD_LCDDisplay0_PrintNumber(FCV_B_SW0);
0353  01F5  	CLRF FCD_LCDDis_00054_arg_Number+D'1'
0354  01F4  	CLRF FCD_LCDDis_00054_arg_Number
0355  18ED  	BTFSC gbl_FCV_B_SW0,1
0356  0AF4  	INCF FCD_LCDDis_00054_arg_Number, F
0357  21C0  	CALL FCD_LCDDis_00054


	//Call Component Macro
	//Call Component Macro: Cursor(0, 2)
	FCD_LCDDisplay0_Cursor(0, 2);
0358  1283  	BCF STATUS, RP0
0359  01F5  	CLRF FCD_LCDDis_00052_arg_x
035A  3002  	MOVLW 0x02
035B  00F6  	MOVWF FCD_LCDDis_00052_arg_y
035C  22E4  	CALL FCD_LCDDis_00052


	//Call Component Macro
	//Call Component Macro: PrintNumber(b_sw1)
	FCD_LCDDisplay0_PrintNumber(FCV_B_SW1);
035D  01F5  	CLRF FCD_LCDDis_00054_arg_Number+D'1'
035E  01F4  	CLRF FCD_LCDDis_00054_arg_Number
035F  196D  	BTFSC gbl_FCV_B_SW1,2
0360  0AF4  	INCF FCD_LCDDis_00054_arg_Number, F
0361  21C0  	CALL FCD_LCDDis_00054


	//Call Component Macro
	//Call Component Macro: Cursor(0, 3)
	FCD_LCDDisplay0_Cursor(0, 3);
0362  1283  	BCF STATUS, RP0
0363  01F5  	CLRF FCD_LCDDis_00052_arg_x
0364  3003  	MOVLW 0x03
0365  00F6  	MOVWF FCD_LCDDis_00052_arg_y
0366  22E4  	CALL FCD_LCDDis_00052


	//Call Component Macro
	//Call Component Macro: PrintNumber(b_sw2)
	FCD_LCDDisplay0_PrintNumber(FCV_B_SW2);
0367  086C  	MOVF gbl_FCV_B_SW2, W
0368  00F4  	MOVWF FCD_LCDDis_00054_arg_Number
0369  01F5  	CLRF FCD_LCDDis_00054_arg_Number+D'1'
036A  21C0  	CALL FCD_LCDDis_00054


	//Call Component Macro
	//Call Component Macro: Cursor(3, 1)
	FCD_LCDDisplay0_Cursor(3, 1);
036B  3003  	MOVLW 0x03
036C  1283  	BCF STATUS, RP0
036D  00F5  	MOVWF FCD_LCDDis_00052_arg_x
036E  3001  	MOVLW 0x01
036F  00F6  	MOVWF FCD_LCDDis_00052_arg_y
0370  22E4  	CALL FCD_LCDDis_00052


	//Decision
	//Decision: flag0 = 1?
	if (FCV_FLAG0 == 1)
0371  1C6D  	BTFSS gbl_FCV_FLAG0,0
0372  2B9B  	GOTO	label61
039B        label61

	{

		//Call Component Macro
		//Call Component Macro: PrintString("ON")
		FCD_LCDDisplay0_PrintString("ON", 2);
0373  304F  	MOVLW 0x4F
0374  00F6  	MOVWF CompTempVar2190
0375  304E  	MOVLW 0x4E
0376  00F7  	MOVWF CompTempVar2190+D'1'
0377  01F8  	CLRF CompTempVar2190+D'2'
0378  3000  	MOVLW HIGH(CompTempVar2190+D'0')
0379  00F5  	MOVWF FCD_LCDDis_00053_arg_String+D'1'
037A  3076  	MOVLW LOW(CompTempVar2190+D'0')
037B  00F4  	MOVWF FCD_LCDDis_00053_arg_String
037C  3002  	MOVLW 0x02
037D  00FE  	MOVWF FCD_LCDDis_00053_arg_MSZ_String
037E  22C1  	CALL FCD_LCDDis_00053


		//Call Component Macro
		//Call Component Macro: SetDutyCycle(analog0)
		FCD_PWM0_SetDutyCycle(FCV_ANALOG0);
037F  1283  	BCF STATUS, RP0
0380  086E  	MOVF gbl_FCV_ANALOG0, W
0381  00F2  	MOVWF FCD_PWM0_S_00055_arg_nDuty
0382  21BC  	CALL FCD_PWM0_S_00055


		//Call Component Macro
		//Call Component Macro: Cursor(3, 2)
		FCD_LCDDisplay0_Cursor(3, 2);
0383  3003  	MOVLW 0x03
0384  00F5  	MOVWF FCD_LCDDis_00052_arg_x
0385  3002  	MOVLW 0x02
0386  00F6  	MOVWF FCD_LCDDis_00052_arg_y
0387  22E4  	CALL FCD_LCDDis_00052


		//Call Component Macro
		//Call Component Macro: PrintNumber(brightness)
		FCD_LCDDisplay0_PrintNumber(FCV_BRIGHTNESS);
0388  086F  	MOVF gbl_FCV_BRIGHTNESS, W
0389  00F4  	MOVWF FCD_LCDDis_00054_arg_Number
038A  01F5  	CLRF FCD_LCDDis_00054_arg_Number+D'1'
038B  21C0  	CALL FCD_LCDDis_00054


		//Call Component Macro
		//Call Component Macro: PrintString("%  ")
		FCD_LCDDisplay0_PrintString("%  ", 3);
038C  3025  	MOVLW 0x25
038D  1283  	BCF STATUS, RP0
038E  00F6  	MOVWF CompTempVar2192
038F  3020  	MOVLW 0x20
0390  00F7  	MOVWF CompTempVar2192+D'1'
0391  00F8  	MOVWF CompTempVar2192+D'2'
0392  01F9  	CLRF CompTempVar2192+D'3'
0393  3000  	MOVLW HIGH(CompTempVar2192+D'0')
0394  00F5  	MOVWF FCD_LCDDis_00053_arg_String+D'1'
0395  3076  	MOVLW LOW(CompTempVar2192+D'0')
0396  00F4  	MOVWF FCD_LCDDis_00053_arg_String
0397  3003  	MOVLW 0x03
0398  00FE  	MOVWF FCD_LCDDis_00053_arg_MSZ_String
0399  22C1  	CALL FCD_LCDDis_00053


	} else {
039A  2BAB  	GOTO	label62
03AB        label62


		//Call Component Macro
		//Call Component Macro: PrintString("OFF")
		FCD_LCDDisplay0_PrintString("OFF", 3);
039B  304F  	MOVLW 0x4F
039C  00F6  	MOVWF CompTempVar2194
039D  3046  	MOVLW 0x46
039E  00F7  	MOVWF CompTempVar2194+D'1'
039F  00F8  	MOVWF CompTempVar2194+D'2'
03A0  01F9  	CLRF CompTempVar2194+D'3'
03A1  3000  	MOVLW HIGH(CompTempVar2194+D'0')
03A2  00F5  	MOVWF FCD_LCDDis_00053_arg_String+D'1'
03A3  3076  	MOVLW LOW(CompTempVar2194+D'0')
03A4  00F4  	MOVWF FCD_LCDDis_00053_arg_String
03A5  3003  	MOVLW 0x03
03A6  00FE  	MOVWF FCD_LCDDis_00053_arg_MSZ_String
03A7  22C1  	CALL FCD_LCDDis_00053


		//Call Component Macro
		//Call Component Macro: SetDutyCycle(0)
		FCD_PWM0_SetDutyCycle(0);
03A8  1283  	BCF STATUS, RP0
03A9  01F2  	CLRF FCD_PWM0_S_00055_arg_nDuty
03AA  21BC  	CALL FCD_PWM0_S_00055


	}

	//Decision
	//Decision: analog0 < 10?
	if (FCV_ANALOG0 < 10)
03AB  300A  	MOVLW 0x0A
03AC  1283  	BCF STATUS, RP0
03AD  026E  	SUBWF gbl_FCV_ANALOG0, W
03AE  1803  	BTFSC STATUS,C
03AF  2BC6  	GOTO	label63
03C6        label63

	{

		//Call Component Macro
		//Call Component Macro: Cursor(13, 3)
		FCD_LCDDisplay0_Cursor(13, 3);
03B0  300D  	MOVLW 0x0D
03B1  00F5  	MOVWF FCD_LCDDis_00052_arg_x
03B2  3003  	MOVLW 0x03
03B3  00F6  	MOVWF FCD_LCDDis_00052_arg_y
03B4  22E4  	CALL FCD_LCDDis_00052


		//Call Component Macro
		//Call Component Macro: PrintString("  ")
		FCD_LCDDisplay0_PrintString("  ", 2);
03B5  3020  	MOVLW 0x20
03B6  00F6  	MOVWF CompTempVar2196
03B7  00F7  	MOVWF CompTempVar2196+D'1'
03B8  01F8  	CLRF CompTempVar2196+D'2'
03B9  3000  	MOVLW HIGH(CompTempVar2196+D'0')
03BA  00F5  	MOVWF FCD_LCDDis_00053_arg_String+D'1'
03BB  3076  	MOVLW LOW(CompTempVar2196+D'0')
03BC  00F4  	MOVWF FCD_LCDDis_00053_arg_String
03BD  3002  	MOVLW 0x02
03BE  00FE  	MOVWF FCD_LCDDis_00053_arg_MSZ_String
03BF  22C1  	CALL FCD_LCDDis_00053


		//Call Component Macro
		//Call Component Macro: PrintNumber(analog0)
		FCD_LCDDisplay0_PrintNumber(FCV_ANALOG0);
03C0  1283  	BCF STATUS, RP0
03C1  086E  	MOVF gbl_FCV_ANALOG0, W
03C2  00F4  	MOVWF FCD_LCDDis_00054_arg_Number
03C3  01F5  	CLRF FCD_LCDDis_00054_arg_Number+D'1'
03C4  21C0  	CALL FCD_LCDDis_00054


	} else {

		//Decision
		//Decision: analog0 < 100 AND analog0 > 9?
		if (FCV_ANALOG0 < 100 & FCV_ANALOG0 > 9)
03C6  01F3  	CLRF CompTempVar2199
03C7  3064  	MOVLW 0x64
03C8  026E  	SUBWF gbl_FCV_ANALOG0, W
03C9  1C03  	BTFSS STATUS,C
03CA  0AF3  	INCF CompTempVar2199, F
03CB  01F2  	CLRF CompTempVar2198
03CC  086E  	MOVF gbl_FCV_ANALOG0, W
03CD  3C09  	SUBLW 0x09
03CE  1C03  	BTFSS STATUS,C
03CF  0AF2  	INCF CompTempVar2198, F
03D0  0872  	MOVF CompTempVar2198, W
03D1  0573  	ANDWF CompTempVar2199, W
03D2  1903  	BTFSC STATUS,Z
03D3  2BE9  	GOTO	label64
03E9        label64

		{

			//Call Component Macro
			//Call Component Macro: Cursor(13, 3)
			FCD_LCDDisplay0_Cursor(13, 3);
03D4  300D  	MOVLW 0x0D
03D5  00F5  	MOVWF FCD_LCDDis_00052_arg_x
03D6  3003  	MOVLW 0x03
03D7  00F6  	MOVWF FCD_LCDDis_00052_arg_y
03D8  22E4  	CALL FCD_LCDDis_00052


			//Call Component Macro
			//Call Component Macro: PrintString(" ")
			FCD_LCDDisplay0_PrintString(" ", 1);
03D9  3020  	MOVLW 0x20
03DA  00F6  	MOVWF CompTempVar2200
03DB  01F7  	CLRF CompTempVar2200+D'1'
03DC  3000  	MOVLW HIGH(CompTempVar2200+D'0')
03DD  00F5  	MOVWF FCD_LCDDis_00053_arg_String+D'1'
03DE  3076  	MOVLW LOW(CompTempVar2200+D'0')
03DF  00F4  	MOVWF FCD_LCDDis_00053_arg_String
03E0  3001  	MOVLW 0x01
03E1  00FE  	MOVWF FCD_LCDDis_00053_arg_MSZ_String
03E2  22C1  	CALL FCD_LCDDis_00053


			//Call Component Macro
			//Call Component Macro: PrintNumber(analog0)
			FCD_LCDDisplay0_PrintNumber(FCV_ANALOG0);
03E3  1283  	BCF STATUS, RP0
03E4  086E  	MOVF gbl_FCV_ANALOG0, W
03E5  00F4  	MOVWF FCD_LCDDis_00054_arg_Number
03E6  01F5  	CLRF FCD_LCDDis_00054_arg_Number+D'1'
03E7  21C0  	CALL FCD_LCDDis_00054


		} else {

			//Call Component Macro
			//Call Component Macro: Cursor(13, 3)
			FCD_LCDDisplay0_Cursor(13, 3);
03E9  300D  	MOVLW 0x0D
03EA  00F5  	MOVWF FCD_LCDDis_00052_arg_x
03EB  3003  	MOVLW 0x03
03EC  00F6  	MOVWF FCD_LCDDis_00052_arg_y
03ED  22E4  	CALL FCD_LCDDis_00052


			//Call Component Macro
			//Call Component Macro: PrintNumber(analog0)
			FCD_LCDDisplay0_PrintNumber(FCV_ANALOG0);
03EE  086E  	MOVF gbl_FCV_ANALOG0, W
03EF  00F4  	MOVWF FCD_LCDDis_00054_arg_Number
03F0  01F5  	CLRF FCD_LCDDis_00054_arg_Number+D'1'
03F1  21C0  	CALL FCD_LCDDis_00054


		}

	}

}
03C5  0008  	RETURN
03E8  0008  	RETURN
03F2  0008  	RETURN




void main()

{
	//Initialization
	adcon1 = 0x07;
054F  3007  	MOVLW 0x07
0550  1683  	BSF STATUS, RP0
0551  1303  	BCF STATUS, RP1
0552  009F  	MOVWF gbl_adcon1


	
		RS232_8_UART_Init( );		//Call initialise function
0553  231A  	CALL FC_CAL_UAR_00078



	//Interrupt initialization code
	option_reg = 0xC0;
0554  30C0  	MOVLW 0xC0
0555  0081  	MOVWF gbl_option_reg



	//Call Component Macro
	//Call Component Macro: Start()
	FCD_LCDDisplay0_Start();
0556  24D9  	CALL FCD_LCDDis_00057


	//Call Component Macro
	//Call Component Macro: Clear()
	FCD_LCDDisplay0_Clear();
0557  24C5  	CALL FCD_LCDDis_00058


	//Call Component Macro
	//Call Component Macro: Cursor(3, 0)
	FCD_LCDDisplay0_Cursor(3, 0);
0558  3003  	MOVLW 0x03
0559  00F5  	MOVWF FCD_LCDDis_00052_arg_x
055A  01F6  	CLRF FCD_LCDDis_00052_arg_y
055B  22E4  	CALL FCD_LCDDis_00052


	//Call Component Macro
	//Call Component Macro: PrintString("BOOTING")
	FCD_LCDDisplay0_PrintString("BOOTING", 7);
055C  3042  	MOVLW 0x42
055D  00F6  	MOVWF CompTempVar2291
055E  304F  	MOVLW 0x4F
055F  00F7  	MOVWF CompTempVar2291+D'1'
0560  00F8  	MOVWF CompTempVar2291+D'2'
0561  3054  	MOVLW 0x54
0562  00F9  	MOVWF CompTempVar2291+D'3'
0563  3049  	MOVLW 0x49
0564  00FA  	MOVWF CompTempVar2291+D'4'
0565  304E  	MOVLW 0x4E
0566  00FB  	MOVWF CompTempVar2291+D'5'
0567  3047  	MOVLW 0x47
0568  00FC  	MOVWF CompTempVar2291+D'6'
0569  01FD  	CLRF CompTempVar2291+D'7'
056A  3000  	MOVLW HIGH(CompTempVar2291+D'0')
056B  00F5  	MOVWF FCD_LCDDis_00053_arg_String+D'1'
056C  3076  	MOVLW LOW(CompTempVar2291+D'0')
056D  00F4  	MOVWF FCD_LCDDis_00053_arg_String
056E  3007  	MOVLW 0x07
056F  00FE  	MOVWF FCD_LCDDis_00053_arg_MSZ_String
0570  22C1  	CALL FCD_LCDDis_00053


	//Delay
	//Delay: 1 s
	delay_s(1);
0571  3001  	MOVLW 0x01
0572  1283  	BCF STATUS, RP0
0573  00F2  	MOVWF delay_s_00000_arg_del
0574  204F  	CALL delay_s_00000


	//Call Component Macro
	//Call Component Macro: PrintString(".")
	FCD_LCDDisplay0_PrintString(".", 1);
0575  302E  	MOVLW 0x2E
0576  00F6  	MOVWF CompTempVar2293
0577  01F7  	CLRF CompTempVar2293+D'1'
0578  3000  	MOVLW HIGH(CompTempVar2293+D'0')
0579  00F5  	MOVWF FCD_LCDDis_00053_arg_String+D'1'
057A  3076  	MOVLW LOW(CompTempVar2293+D'0')
057B  00F4  	MOVWF FCD_LCDDis_00053_arg_String
057C  3001  	MOVLW 0x01
057D  00FE  	MOVWF FCD_LCDDis_00053_arg_MSZ_String
057E  22C1  	CALL FCD_LCDDis_00053


	//Delay
	//Delay: 1 s
	delay_s(1);
057F  3001  	MOVLW 0x01
0580  1283  	BCF STATUS, RP0
0581  00F2  	MOVWF delay_s_00000_arg_del
0582  204F  	CALL delay_s_00000


	//Call Component Macro
	//Call Component Macro: PrintString(".")
	FCD_LCDDisplay0_PrintString(".", 1);
0583  302E  	MOVLW 0x2E
0584  00F6  	MOVWF CompTempVar2295
0585  01F7  	CLRF CompTempVar2295+D'1'
0586  3000  	MOVLW HIGH(CompTempVar2295+D'0')
0587  00F5  	MOVWF FCD_LCDDis_00053_arg_String+D'1'
0588  3076  	MOVLW LOW(CompTempVar2295+D'0')
0589  00F4  	MOVWF FCD_LCDDis_00053_arg_String
058A  3001  	MOVLW 0x01
058B  00FE  	MOVWF FCD_LCDDis_00053_arg_MSZ_String
058C  22C1  	CALL FCD_LCDDis_00053


	//Delay
	//Delay: 1 s
	delay_s(1);
058D  3001  	MOVLW 0x01
058E  1283  	BCF STATUS, RP0
058F  00F2  	MOVWF delay_s_00000_arg_del
0590  204F  	CALL delay_s_00000


	//Call Component Macro
	//Call Component Macro: PrintString(".")
	FCD_LCDDisplay0_PrintString(".", 1);
0591  302E  	MOVLW 0x2E
0592  00F6  	MOVWF CompTempVar2297
0593  01F7  	CLRF CompTempVar2297+D'1'
0594  3000  	MOVLW HIGH(CompTempVar2297+D'0')
0595  00F5  	MOVWF FCD_LCDDis_00053_arg_String+D'1'
0596  3076  	MOVLW LOW(CompTempVar2297+D'0')
0597  00F4  	MOVWF FCD_LCDDis_00053_arg_String
0598  3001  	MOVLW 0x01
0599  00FE  	MOVWF FCD_LCDDis_00053_arg_MSZ_String
059A  22C1  	CALL FCD_LCDDis_00053


	//Delay
	//Delay: 1 s
	delay_s(1);
059B  3001  	MOVLW 0x01
059C  1283  	BCF STATUS, RP0
059D  00F2  	MOVWF delay_s_00000_arg_del
059E  204F  	CALL delay_s_00000


	//Call Component Macro
	//Call Component Macro: Clear()
	FCD_LCDDisplay0_Clear();
059F  24C5  	CALL FCD_LCDDis_00058


	//Call Component Macro
	//Call Component Macro: Enable()
	FCD_PWM0_Enable();
05A0  24A2  	CALL FCD_PWM0_E_00073


	//Loop
	//Loop: While 1
	while (1)
05A1        label77
0680  2DA1  	GOTO	label77

	{

		//Call Macro
		//Call Macro: display()
		FCM_display();
05A1  2329  	CALL FCM_displa_00051


		//Input
		//Input: A2 -> b_sw2
		trisa = trisa | 0x04;
05A2  3004  	MOVLW 0x04
05A3  0405  	IORWF gbl_trisa, W
05A4  0085  	MOVWF gbl_trisa

		FCV_B_SW2 = ((porta & 0x04) == 0x04);
05A5  3004  	MOVLW 0x04
05A6  1283  	BCF STATUS, RP0
05A7  0505  	ANDWF gbl_porta, W
05A8  00F2  	MOVWF CompTempVar2299
05A9  01EC  	CLRF gbl_FCV_B_SW2
05AA  3004  	MOVLW 0x04
05AB  0272  	SUBWF CompTempVar2299, W
05AC  1903  	BTFSC STATUS,Z
05AD  0AEC  	INCF gbl_FCV_B_SW2, F


		//Input
		//Input: A3 -> b_sw1
		trisa = trisa | 0x08;
05AE  3008  	MOVLW 0x08
05AF  1683  	BSF STATUS, RP0
05B0  0405  	IORWF gbl_trisa, W
05B1  0085  	MOVWF gbl_trisa

		FCV_B_SW1 = ((porta & 0x08) == 0x08);
05B2  3008  	MOVLW 0x08
05B3  1283  	BCF STATUS, RP0
05B4  0505  	ANDWF gbl_porta, W
05B5  00F2  	MOVWF CompTempVar2301
05B6  01F3  	CLRF CompTempVar2302
05B7  3008  	MOVLW 0x08
05B8  0272  	SUBWF CompTempVar2301, W
05B9  1903  	BTFSC STATUS,Z
05BA  0AF3  	INCF CompTempVar2302, F
05BB  116D  	BCF gbl_FCV_B_SW1,2
05BC  0873  	MOVF CompTempVar2302, W
05BD  1D03  	BTFSS STATUS,Z
05BE  156D  	BSF gbl_FCV_B_SW1,2


		//Input
		//Input: A4 -> b_sw0
		trisa = trisa | 0x10;
05BF  3010  	MOVLW 0x10
05C0  1683  	BSF STATUS, RP0
05C1  0405  	IORWF gbl_trisa, W
05C2  0085  	MOVWF gbl_trisa

		FCV_B_SW0 = ((porta & 0x10) == 0x10);
05C3  3010  	MOVLW 0x10
05C4  1283  	BCF STATUS, RP0
05C5  0505  	ANDWF gbl_porta, W
05C6  00F2  	MOVWF CompTempVar2303
05C7  01F3  	CLRF CompTempVar2304
05C8  3010  	MOVLW 0x10
05C9  0272  	SUBWF CompTempVar2303, W
05CA  1903  	BTFSC STATUS,Z
05CB  0AF3  	INCF CompTempVar2304, F
05CC  10ED  	BCF gbl_FCV_B_SW0,1
05CD  0873  	MOVF CompTempVar2304, W
05CE  1D03  	BTFSS STATUS,Z
05CF  14ED  	BSF gbl_FCV_B_SW0,1


		//Call Component Macro
		//Call Component Macro: analog0=ReadAsByte()
		FCV_ANALOG0 = FCD_ADC0_ReadAsByte();
05D0  253E  	CALL FCD_ADC0_R_00063
05D1  0873  	MOVF CompTempVarRet2244, W
05D2  00EE  	MOVWF gbl_FCV_ANALOG0


		//Decision
		//Decision: b_sw2 = 0?
		if (FCV_B_SW2 == 0)
05D3  08EC  	MOVF gbl_FCV_B_SW2, F
05D4  1D03  	BTFSS STATUS,Z
05D5  2DF4  	GOTO	label82
05D6        label78
05F4        label82

		{

			//Loop
			//Loop: While b_sw2 = 0
			while (FCV_B_SW2 == 0)
05D6  08EC  	MOVF gbl_FCV_B_SW2, F
05D7  1D03  	BTFSS STATUS,Z
05D8  2DE9  	GOTO	label79
05E8  2DD6  	GOTO	label78
05E9        label79

			{

				//Input
				//Input: A2 -> b_sw2
				trisa = trisa | 0x04;
05D9  3004  	MOVLW 0x04
05DA  1683  	BSF STATUS, RP0
05DB  0405  	IORWF gbl_trisa, W
05DC  0085  	MOVWF gbl_trisa

				FCV_B_SW2 = ((porta & 0x04) == 0x04);
05DD  3004  	MOVLW 0x04
05DE  1283  	BCF STATUS, RP0
05DF  0505  	ANDWF gbl_porta, W
05E0  00F2  	MOVWF CompTempVar2305
05E1  01F3  	CLRF CompTempVar2306
05E2  3004  	MOVLW 0x04
05E3  0272  	SUBWF CompTempVar2305, W
05E4  1903  	BTFSC STATUS,Z
05E5  0AF3  	INCF CompTempVar2306, F
05E6  0873  	MOVF CompTempVar2306, W
05E7  00EC  	MOVWF gbl_FCV_B_SW2



			}

			//Decision
			//Decision: flag0 = 1?
			if (FCV_FLAG0 == 1)
05E9  1C6D  	BTFSS gbl_FCV_FLAG0,0
05EA  2DED  	GOTO	label80
05ED        label80

			{

				//Calculation
				//Calculation:
				//  flag0 = 0
				FCV_FLAG0 = 0;
05EB  106D  	BCF gbl_FCV_FLAG0,0


			} else {
05EC  2DEE  	GOTO	label81
05EE        label81


				//Calculation
				//Calculation:
				//  flag0 = 1
				FCV_FLAG0 = 1;
05ED  146D  	BSF gbl_FCV_FLAG0,0


			}

			//Call Component Macro
			//Call Component Macro: ClearLine(1)
			FCD_LCDDisplay0_ClearLine(1);
05EE  3001  	MOVLW 0x01
05EF  00F2  	MOVWF FCD_LCDDis_0005D_arg_Line
05F0  24AC  	CALL FCD_LCDDis_0005D


			//Call Component Macro
			//Call Component Macro: ClearLine(2)
			FCD_LCDDisplay0_ClearLine(2);
05F1  3002  	MOVLW 0x02
05F2  00F2  	MOVWF FCD_LCDDis_0005D_arg_Line
05F3  24AC  	CALL FCD_LCDDis_0005D


		// } else {

		}

		//Decision
		//Decision: b_sw1 = 0?
		if (FCV_B_SW1 == 0)
05F4  196D  	BTFSC gbl_FCV_B_SW1,2
05F5  2E15  	GOTO	label87
05F6        label83
0615        label87

		{

			//Loop
			//Loop: While b_sw1 = 0
			while (FCV_B_SW1 == 0)
05F6  196D  	BTFSC gbl_FCV_B_SW1,2
05F7  2E0A  	GOTO	label84
0609  2DF6  	GOTO	label83
060A        label84

			{

				//Input
				//Input: A3 -> b_sw1
				trisa = trisa | 0x08;
05F8  3008  	MOVLW 0x08
05F9  1683  	BSF STATUS, RP0
05FA  0405  	IORWF gbl_trisa, W
05FB  0085  	MOVWF gbl_trisa

				FCV_B_SW1 = ((porta & 0x08) == 0x08);
05FC  3008  	MOVLW 0x08
05FD  1283  	BCF STATUS, RP0
05FE  0505  	ANDWF gbl_porta, W
05FF  00F2  	MOVWF CompTempVar2307
0600  01F3  	CLRF CompTempVar2308
0601  3008  	MOVLW 0x08
0602  0272  	SUBWF CompTempVar2307, W
0603  1903  	BTFSC STATUS,Z
0604  0AF3  	INCF CompTempVar2308, F
0605  116D  	BCF gbl_FCV_B_SW1,2
0606  0873  	MOVF CompTempVar2308, W
0607  1D03  	BTFSS STATUS,Z
0608  156D  	BSF gbl_FCV_B_SW1,2



			}

			//Decision
			//Decision: flag0 = 1?
			if (FCV_FLAG0 == 1)
060A  1C6D  	BTFSS gbl_FCV_FLAG0,0
060B  2E0E  	GOTO	label85
060E        label85

			{

				//Calculation
				//Calculation:
				//  flag0 = 0
				FCV_FLAG0 = 0;
060C  106D  	BCF gbl_FCV_FLAG0,0


			} else {
060D  2E0F  	GOTO	label86
060F        label86


				//Calculation
				//Calculation:
				//  flag0 = 1
				FCV_FLAG0 = 1;
060E  146D  	BSF gbl_FCV_FLAG0,0


			}

			//Call Component Macro
			//Call Component Macro: ClearLine(1)
			FCD_LCDDisplay0_ClearLine(1);
060F  3001  	MOVLW 0x01
0610  00F2  	MOVWF FCD_LCDDis_0005D_arg_Line
0611  24AC  	CALL FCD_LCDDis_0005D


			//Call Component Macro
			//Call Component Macro: ClearLine(2)
			FCD_LCDDisplay0_ClearLine(2);
0612  3002  	MOVLW 0x02
0613  00F2  	MOVWF FCD_LCDDis_0005D_arg_Line
0614  24AC  	CALL FCD_LCDDis_0005D


		// } else {

		}

		//Decision
		//Decision: b_sw0 = 0?
		if (FCV_B_SW0 == 0)
0615  18ED  	BTFSC gbl_FCV_B_SW0,1
0616  2E36  	GOTO	label92
0617        label88
0636        label92

		{

			//Loop
			//Loop: While b_sw0 = 0
			while (FCV_B_SW0 == 0)
0617  18ED  	BTFSC gbl_FCV_B_SW0,1
0618  2E2B  	GOTO	label89
062A  2E17  	GOTO	label88
062B        label89

			{

				//Input
				//Input: A4 -> b_sw0
				trisa = trisa | 0x10;
0619  3010  	MOVLW 0x10
061A  1683  	BSF STATUS, RP0
061B  0405  	IORWF gbl_trisa, W
061C  0085  	MOVWF gbl_trisa

				FCV_B_SW0 = ((porta & 0x10) == 0x10);
061D  3010  	MOVLW 0x10
061E  1283  	BCF STATUS, RP0
061F  0505  	ANDWF gbl_porta, W
0620  00F2  	MOVWF CompTempVar2309
0621  01F3  	CLRF CompTempVar2310
0622  3010  	MOVLW 0x10
0623  0272  	SUBWF CompTempVar2309, W
0624  1903  	BTFSC STATUS,Z
0625  0AF3  	INCF CompTempVar2310, F
0626  10ED  	BCF gbl_FCV_B_SW0,1
0627  0873  	MOVF CompTempVar2310, W
0628  1D03  	BTFSS STATUS,Z
0629  14ED  	BSF gbl_FCV_B_SW0,1



			}

			//Decision
			//Decision: flag0 = 1?
			if (FCV_FLAG0 == 1)
062B  1C6D  	BTFSS gbl_FCV_FLAG0,0
062C  2E2F  	GOTO	label90
062F        label90

			{

				//Calculation
				//Calculation:
				//  flag0 = 0
				FCV_FLAG0 = 0;
062D  106D  	BCF gbl_FCV_FLAG0,0


			} else {
062E  2E30  	GOTO	label91
0630        label91


				//Calculation
				//Calculation:
				//  flag0 = 1
				FCV_FLAG0 = 1;
062F  146D  	BSF gbl_FCV_FLAG0,0


			}

			//Call Component Macro
			//Call Component Macro: ClearLine(1)
			FCD_LCDDisplay0_ClearLine(1);
0630  3001  	MOVLW 0x01
0631  00F2  	MOVWF FCD_LCDDis_0005D_arg_Line
0632  24AC  	CALL FCD_LCDDis_0005D


			//Call Component Macro
			//Call Component Macro: ClearLine(2)
			FCD_LCDDisplay0_ClearLine(2);
0633  3002  	MOVLW 0x02
0634  00F2  	MOVWF FCD_LCDDis_0005D_arg_Line
0635  24AC  	CALL FCD_LCDDis_0005D


		// } else {

		}

		//Calculation
		//Calculation:
		//  brightness = (analog0 * 100) / 255
		FCV_BRIGHTNESS = (FCV_ANALOG0 * 100) / 255;
0636  086E  	MOVF gbl_FCV_ANALOG0, W
0637  00F2  	MOVWF __mul_8u_8_00006_arg_a
0638  3064  	MOVLW 0x64
0639  00F3  	MOVWF __mul_8u_8_00006_arg_b
063A  2304  	CALL __mul_8u_8_00006
063B  0877  	MOVF CompTempVarRet452, W
063C  00FC  	MOVWF __div_16_1_00003_arg_a
063D  0878  	MOVF CompTempVarRet452+D'1', W
063E  00FD  	MOVWF __div_16_1_00003_arg_a+D'1'
063F  30FF  	MOVLW 0xFF
0640  1683  	BSF STATUS, RP0
0641  00A0  	MOVWF __div_16_1_00003_arg_b
0642  01A1  	CLRF __div_16_1_00003_arg_b+D'1'
0643  205E  	CALL __div_16_1_00003
0644  0825  	MOVF CompTempVarRet214, W
0645  1283  	BCF STATUS, RP0
0646  00EF  	MOVWF gbl_FCV_BRIGHTNESS


		//Calculation
		//Calculation:
		//  string_brightness = ToString$ (brightness)
		//  string_flag0 = ToString$ (flag0)
		FCI_TOSTRING(FCV_BRIGHTNESS, FCV_STRING_BRIGHTNESS,FCSZ_STRING_BRIGHTNESS);
0647  086F  	MOVF gbl_FCV_BRIGHTNESS, W
0648  00F2  	MOVWF FCI_TOSTRI_00049_arg_iSrc1
0649  01F3  	CLRF FCI_TOSTRI_00049_arg_iSrc1+D'1'
064A  3000  	MOVLW HIGH(gbl_FCV_STRING_BRIGHTNESS+D'0')
064B  00F5  	MOVWF FCI_TOSTRI_00049_arg_sDst+D'1'
064C  3020  	MOVLW LOW(gbl_FCV_STRING_BRIGHTNESS+D'0')
064D  00F4  	MOVWF FCI_TOSTRI_00049_arg_sDst
064E  3014  	MOVLW 0x14
064F  00F6  	MOVWF FCI_TOSTRI_00049_arg_iDst_len
0650  23F3  	CALL FCI_TOSTRI_00049

		FCI_TOSTRING(FCV_FLAG0, FCV_STRING_FLAG0,FCSZ_STRING_FLAG0);
0651  01F3  	CLRF FCI_TOSTRI_00049_arg_iSrc1+D'1'
0652  01F2  	CLRF FCI_TOSTRI_00049_arg_iSrc1
0653  186D  	BTFSC gbl_FCV_FLAG0,0
0654  0AF2  	INCF FCI_TOSTRI_00049_arg_iSrc1, F
0655  3000  	MOVLW HIGH(gbl_FCV_STRING_FLAG0+D'0')
0656  00F5  	MOVWF FCI_TOSTRI_00049_arg_sDst+D'1'
0657  3034  	MOVLW LOW(gbl_FCV_STRING_FLAG0+D'0')
0658  00F4  	MOVWF FCI_TOSTRI_00049_arg_sDst
0659  3014  	MOVLW 0x14
065A  00F6  	MOVWF FCI_TOSTRI_00049_arg_iDst_len
065B  23F3  	CALL FCI_TOSTRI_00049


		//Call Component Macro
		//Call Component Macro: SendRS232String("AA")
		FCD_RS2320_SendRS232String("AA", 2);
065C  3041  	MOVLW 0x41
065D  00F4  	MOVWF CompTempVar2313
065E  00F5  	MOVWF CompTempVar2313+D'1'
065F  01F6  	CLRF CompTempVar2313+D'2'
0660  3000  	MOVLW HIGH(CompTempVar2313+D'0')
0661  00F3  	MOVWF FCD_RS2320_0007E_arg_String+D'1'
0662  3074  	MOVLW LOW(CompTempVar2313+D'0')
0663  00F2  	MOVWF FCD_RS2320_0007E_arg_String
0664  3002  	MOVLW 0x02
0665  00F7  	MOVWF FCD_RS2320_0007E_arg_MSZ_String
0666  2488  	CALL FCD_RS2320_0007E


		//Call Component Macro
		//Call Component Macro: SendRS232String(string_brightness)
		FCD_RS2320_SendRS232String(FCV_STRING_BRIGHTNESS, FCSZ_STRING_BRIGHTNESS);
0667  3000  	MOVLW HIGH(gbl_FCV_STRING_BRIGHTNESS+D'0')
0668  00F3  	MOVWF FCD_RS2320_0007E_arg_String+D'1'
0669  3020  	MOVLW LOW(gbl_FCV_STRING_BRIGHTNESS+D'0')
066A  00F2  	MOVWF FCD_RS2320_0007E_arg_String
066B  3014  	MOVLW 0x14
066C  00F7  	MOVWF FCD_RS2320_0007E_arg_MSZ_String
066D  2488  	CALL FCD_RS2320_0007E


		//Call Component Macro
		//Call Component Macro: SendRS232String(string_flag0)
		FCD_RS2320_SendRS232String(FCV_STRING_FLAG0, FCSZ_STRING_FLAG0);
066E  3000  	MOVLW HIGH(gbl_FCV_STRING_FLAG0+D'0')
066F  00F3  	MOVWF FCD_RS2320_0007E_arg_String+D'1'
0670  3034  	MOVLW LOW(gbl_FCV_STRING_FLAG0+D'0')
0671  00F2  	MOVWF FCD_RS2320_0007E_arg_String
0672  3014  	MOVLW 0x14
0673  00F7  	MOVWF FCD_RS2320_0007E_arg_MSZ_String
0674  2488  	CALL FCD_RS2320_0007E


		//Call Component Macro
		//Call Component Macro: SendRS232String("BB")
		FCD_RS2320_SendRS232String("BB", 2);
0675  3042  	MOVLW 0x42
0676  00F4  	MOVWF CompTempVar2317
0677  00F5  	MOVWF CompTempVar2317+D'1'
0678  01F6  	CLRF CompTempVar2317+D'2'
0679  3000  	MOVLW HIGH(CompTempVar2317+D'0')
067A  00F3  	MOVWF FCD_RS2320_0007E_arg_String+D'1'
067B  3074  	MOVLW LOW(CompTempVar2317+D'0')
067C  00F2  	MOVWF FCD_RS2320_0007E_arg_String
067D  3002  	MOVLW 0x02
067E  00F7  	MOVWF FCD_RS2320_0007E_arg_MSZ_String
067F  2488  	CALL FCD_RS2320_0007E



	}

	mainendloop: goto mainendloop;
}


void MX_INTERRUPT_MACRO(void)

{
}
06B3  1283  	BCF STATUS, RP0
06B4  1303  	BCF STATUS, RP1
06B5  0E5E  	SWAPF Int1BContext+D'2', W
06B6  0084  	MOVWF FSR
06B7  0E5D  	SWAPF Int1BContext+D'1', W
06B8  008A  	MOVWF PCLATH
06B9  0E5C  	SWAPF Int1BContext, W
06BA  0083  	MOVWF STATUS
06BB  0EFF  	SWAPF Int1Context, F
06BC  0E7F  	SWAPF Int1Context, W
06BD  0009  	RETFIE





/*********************************************************************
 *                  Flowcode CAL ADC File
 *
 * File: PIC_CAL_ADC.c
 *
 * (c) 2011 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * “Company”) for its Flowcode graphical programming language is
 * intended and supplied to you, the Company’s customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 060911 | BR | Created
 * 200911 | BR | Updated to include all ADC type files
 */


//ADC Function Prototypes
void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge);
MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode);
void FC_CAL_Disable_ADC (void);


//ADC Global Variables
MX_UINT8 old_tris, tris_mask;
MX_UINT8 * tris_reg;					//TRIS register pointer


// ADC Type 1 Supported Devices ************************************************************
// 16F818, 16F819, 16F873A, 16F874A, 16F876A, 16F877A,
// *******************************************************************************************/

#ifdef MX_ADC_TYPE_1
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)

	{
		switch (Channel)
0169  297A  	GOTO	label31

		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
0166  0873  	MOVF FC_CAL_Ena_0005F_arg_Channel, W
0167  3A00  	XORLW 0x00
0168  1D03  	BTFSS STATUS,Z

					tris_mask = 0x01;
016A  3001  	MOVLW 0x01
016B  00F1  	MOVWF gbl_tris_mask

					tris_reg = &trisa;
016C  3000  	MOVLW HIGH(gbl_trisa+D'0')
016D  00E2  	MOVWF gbl_tris_reg+D'1'
016E  3085  	MOVLW LOW(gbl_trisa+D'0')
016F  00E1  	MOVWF gbl_tris_reg

					if (Vref == 0)
0170  08F5  	MOVF FC_CAL_Ena_0005F_arg_Vref, F
0171  1D03  	BTFSS STATUS,Z
0172  2977  	GOTO	label30
0177        label30

						adcon1 = 0x0E;
0173  300E  	MOVLW 0x0E
0174  1683  	BSF STATUS, RP0
0175  009F  	MOVWF gbl_adcon1

					else
0176  297A  	GOTO	label31
017A        label31

						adcon1 = 0x05;
0177  3005  	MOVLW 0x05
0178  1683  	BSF STATUS, RP0
0179  009F  	MOVWF gbl_adcon1

					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					if (Vref == 0)
						adcon1 = 0x04;
					else
						adcon1 = 0x05;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					if (Vref == 0)
						adcon1 = 0x02;
					else
						adcon1 = 0x03;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					if (Vref == 0)
						adcon1 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					if (Vref == 0)
						adcon1 = 0x02;
					else
						adcon1 = 0x03;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x01;
					tris_reg = &trise;
					if (Vref == 0)
						adcon1 = 0x09;
					else
						adcon1 = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trise;
					if (Vref == 0)
						adcon1 = 0x00;
					else
						adcon1 = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trise;
					if (Vref == 0)
						adcon1 = 0x00;
					else
						adcon1 = 0x01;
					break;
			#endif
		}

		if (Conv_Speed > 3)										//assign conversion speed
017A  1283  	BCF STATUS, RP0
017B  0874  	MOVF FC_CAL_Ena_0005F_arg_Conv_Speed, W
017C  3C03  	SUBLW 0x03
017D  1803  	BTFSC STATUS,C
017E  2981  	GOTO	label32

			st_bit(adcon1, ADCS2);
017F  1683  	BSF STATUS, RP0
0180  171F  	BSF gbl_adcon1,6


		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
0181  1383  	BCF STATUS,IRP
0182  1283  	BCF STATUS, RP0
0183  1862  	BTFSC gbl_tris_reg+D'1',0
0184  1783  	BSF STATUS,IRP
0185  0861  	MOVF gbl_tris_reg, W
0186  0084  	MOVWF FSR
0187  0800  	MOVF INDF, W
0188  00F0  	MOVWF gbl_old_tris

		*tris_reg = old_tris | tris_mask;
0189  0871  	MOVF gbl_tris_mask, W
018A  0470  	IORWF gbl_old_tris, W
018B  00F7  	MOVWF CompTempVar2232
018C  0080  	MOVWF INDF

		adcon0 = (0x01 | (Conv_Speed << 6)) | (Channel << 3);	//turn ADC on
018D  0874  	MOVF FC_CAL_Ena_0005F_arg_Conv_Speed, W
018E  00F7  	MOVWF CompTempVar2233
018F  01F8  	CLRF CompTempVar2234
0190  0DF7  	RLF CompTempVar2233, F
0191  0DF8  	RLF CompTempVar2234, F
0192  0DF7  	RLF CompTempVar2233, F
0193  0DF8  	RLF CompTempVar2234, F
0194  0DF7  	RLF CompTempVar2233, F
0195  0DF8  	RLF CompTempVar2234, F
0196  0DF7  	RLF CompTempVar2233, F
0197  0DF8  	RLF CompTempVar2234, F
0198  0DF7  	RLF CompTempVar2233, F
0199  0DF8  	RLF CompTempVar2234, F
019A  0DF7  	RLF CompTempVar2233, F
019B  0DF8  	RLF CompTempVar2234, F
019C  30C0  	MOVLW 0xC0
019D  0577  	ANDWF CompTempVar2233, W
019E  3801  	IORLW 0x01
019F  00FA  	MOVWF CompTempVar2237
01A0  0873  	MOVF FC_CAL_Ena_0005F_arg_Channel, W
01A1  00F9  	MOVWF CompTempVar2236
01A2  0DF9  	RLF CompTempVar2236, F
01A3  0DF9  	RLF CompTempVar2236, F
01A4  0DF9  	RLF CompTempVar2236, F
01A5  30F8  	MOVLW 0xF8
01A6  0579  	ANDWF CompTempVar2236, W
01A7  047A  	IORWF CompTempVar2237, W
01A8  009F  	MOVWF gbl_adcon0

		delay_us(T_Charge);										//wait the acquisition time
01A9  0876  	MOVF FC_CAL_Ena_0005F_arg_T_Charge, W
01AA  00F7  	MOVWF delay_us_00000_arg_del
01AB  204A  	CALL delay_us_00000

	}
01AC  0008  	RETURN


	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)

	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x04;									//begin conversion and wait until it has finished
011A  3004  	MOVLW 0x04
011B  041F  	IORWF gbl_adcon0, W
011C  009F  	MOVWF gbl_adcon0

		while (adcon0 & 0x04);
011D        label24
011D  191F  	BTFSC gbl_adcon0,2
011E  291D  	GOTO	label24

		if (Sample_Mode)
011F  08F3  	MOVF FC_CAL_Sam_00060_arg_Sample_Mode, F
0120  1903  	BTFSC STATUS,Z
0121  2936  	GOTO	label25
0136        label25

		{
			iRetVal = (adresh << 2);							//10-bit ADC
0122  081E  	MOVF gbl_adresh, W
0123  00F4  	MOVWF FC_CAL_Sam_00060_1_iRetVal
0124  01F5  	CLRF FC_CAL_Sam_00060_1_iRetVal+D'1'
0125  0DF4  	RLF FC_CAL_Sam_00060_1_iRetVal, F
0126  0DF5  	RLF FC_CAL_Sam_00060_1_iRetVal+D'1', F
0127  0DF4  	RLF FC_CAL_Sam_00060_1_iRetVal, F
0128  0DF5  	RLF FC_CAL_Sam_00060_1_iRetVal+D'1', F
0129  30FC  	MOVLW 0xFC
012A  05F4  	ANDWF FC_CAL_Sam_00060_1_iRetVal, F

			iRetVal = iRetVal | (adresl >> 6);
012B  1683  	BSF STATUS, RP0
012C  0C1E  	RRF gbl_adresl, W
012D  1283  	BCF STATUS, RP0
012E  00F6  	MOVWF CompTempVar2241
012F  0CF6  	RRF CompTempVar2241, F
0130  0EF6  	SWAPF CompTempVar2241, F
0131  3003  	MOVLW 0x03
0132  0576  	ANDWF CompTempVar2241, W
0133  04F4  	IORWF FC_CAL_Sam_00060_1_iRetVal, F
0134  08F5  	MOVF FC_CAL_Sam_00060_1_iRetVal+D'1', F

		}
		else
0135  2939  	GOTO	label26
0139        label26

			iRetVal = adresh;									//8-bit ADC
0136  081E  	MOVF gbl_adresh, W
0137  00F4  	MOVWF FC_CAL_Sam_00060_1_iRetVal
0138  01F5  	CLRF FC_CAL_Sam_00060_1_iRetVal+D'1'


		return (iRetVal);
0139  0874  	MOVF FC_CAL_Sam_00060_1_iRetVal, W
013A  00F6  	MOVWF CompTempVarRet2238
013B  0875  	MOVF FC_CAL_Sam_00060_1_iRetVal+D'1', W
013C  00F7  	MOVWF CompTempVarRet2238+D'1'

	}
013D  0008  	RETURN


	void FC_CAL_Disable_ADC ()

	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
01AD  1383  	BCF STATUS,IRP
01AE  1283  	BCF STATUS, RP0
01AF  1303  	BCF STATUS, RP1
01B0  1862  	BTFSC gbl_tris_reg+D'1',0
01B1  1783  	BSF STATUS,IRP
01B2  0861  	MOVF gbl_tris_reg, W
01B3  0084  	MOVWF FSR
01B4  0870  	MOVF gbl_old_tris, W
01B5  0080  	MOVWF INDF

		adcon1 = 0x07;
01B6  3007  	MOVLW 0x07
01B7  1683  	BSF STATUS, RP0
01B8  009F  	MOVWF gbl_adcon1

		adcon0 = 0x00;
01B9  1283  	BCF STATUS, RP0
01BA  019F  	CLRF gbl_adcon0

	}
01BB  0008  	RETURN

#endif


// ADC Type 2 Supported Devices ************************************************************
// 16F88
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_2
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		if (Vref == 1)											//assign VREF functionality
			st_bit(adcon1, VCFG1);

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ansel = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ansel = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ansel = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					ansel = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x10;
					tris_reg = &trisa;
					ansel = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x20;
					tris_reg = &trisb;
					ansel = 0x20;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x40;
					tris_reg = &trisb;
					ansel = 0x40;
					break;
			#endif
		}

		if (Conv_Speed > 3)										//assign conversion speed
			st_bit(adcon1, ADCS2);

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Conv_Speed << 6)) | (Channel << 3);	//turn ADC on
		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x04;									//begin conversion and wait until it has finished
		while (adcon0 & 0x04);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		ansel = 0x00;
		adcon0 = 0x00;
	}
#endif


// ADC Type 3 Supported Devices ************************************************************
// 16F616, 16F676, 16F677, 16F684, 16F685, 16F687, 16F688, 16F689, 16F690
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_3
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon1 = ((Conv_Speed & 0x07) << 4);				//assign conversion rate

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ansel = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ansel = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ansel = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x10;
					tris_reg = &trisa;
					ansel = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x01;
					tris_reg = &trisc;
					ansel = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x02;
					tris_reg = &trisc;
					ansel = 0x20;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x04;
					tris_reg = &trisc;
					ansel = 0x40;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x08;
					tris_reg = &trisc;
					ansel = 0x80;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x40;
					tris_reg = &trisc;
					anselh = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x80;
					tris_reg = &trisc;
					anselh = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x10;
					tris_reg = &trisb;
					anselh = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x20;
					tris_reg = &trisb;
					anselh = 0x08;
					break;
			#endif
		}

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on

		if (Vref == 1)											//assign VREF functionality
			st_bit(adcon0, VCFG);

		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x02;									//begin conversion and wait until it has finished
		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		ansel = 0x00;
		adcon0 = 0x00;
		#ifdef ANSELH
			anselh = 0x00;
		#endif
	}
#endif


// ADC Type 4 Supported Devices ************************************************************
// 16F737, 16F747, 16F767, 16F777
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_4
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon2 = 0x00;

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					adcon1 = 0x0E;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					adcon1 = 0x0D;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					adcon1 = 0x0C;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					adcon1 = 0x0B;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					adcon1 = 0x0A;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x01;
					tris_reg = &trise;
					adcon1 = 0x09;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trise;
					adcon1 = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trise;
					adcon1 = 0x07;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x04;
					tris_reg = &trisb;
					adcon1 = 0x06;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x08;
					tris_reg = &trisb;
					adcon1 = 0x05;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x02;
					tris_reg = &trisb;
					adcon1 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x10;
					tris_reg = &trisb;
					adcon1 = 0x03;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_12
				case (12):
					tris_mask = 0x01;
					tris_reg = &trisb;
					adcon1 = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_13
				case (13):
					tris_mask = 0x20;
					tris_reg = &trisb;
					adcon1 = 0x01;
					break;
			#endif
		}

		if (Vref == 1)											//assign VREF functionality
			st_bit(adcon1, VCFG0);

		if (Conv_Speed > 3)										//assign conversion speed
			st_bit(adcon1, ADCS2);

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Conv_Speed << 6));					//turn ADC on
		adcon0 = adcon0 | ((Channel & 0x07) << 3);
		adcon0 = adcon0 | ((Channel & 0x08) >> 2);
		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x04;									//begin conversion and wait until it has finished
		while (adcon0 & 0x04);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		adcon1 = 0x07;
		adcon0 = 0x00;
	}
#endif


// ADC Type 5 Supported Devices ************************************************************
// 12F615, 12HV615, 12F675, 12F683
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_5
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		tris_reg = &trisio;

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					ansel = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					ansel = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					ansel = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x10;
					ansel = 0x08;
					break;
			#endif
		}

		ansel = ansel | ((Conv_Speed & 0x07) << 4);				//assign conversion speed

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on

		if (Vref == 1)											//assign VREF functionality
			st_bit(adcon0, VCFG);

		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x02;									//begin conversion and wait until it has finished
		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		ansel = 0x00;
		adcon0 = 0x00;
	}
#endif


// ADC Type 6 Supported Devices ************************************************************
// 16C72, 16C72A, 16CR72, 16F72, 16C73, 16C73A, 16C73B, 16F73, 16C74, 16C74A, 16C74B, 16F74,
// 16C76, 16F76, 16C77, 16F77, 16C716, 16F716
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_6
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					adcon1 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					adcon1 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					adcon1 = 0x00;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					adcon1 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					adcon1 = 0x00;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x01;
					tris_reg = &trise;
					adcon1 = 0x00;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trise;
					adcon1 = 0x00;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trise;
					adcon1 = 0x00;
					break;
			#endif
		}

		if (Vref != 0)											//assign VREF functionality
			adcon1 = adcon1 + 1;

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Conv_Speed << 6)) | (Channel << 3);	//turn ADC on
		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x04;									//begin conversion and wait until it has finished
		while (adcon0 & 0x04);
		if (Sample_Mode)
		{
			iRetVal = (adres << 2);								//10-bit ADC
		}
		else
			iRetVal = adres;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		adcon1 = 0x07;
		adcon0 = 0x00;
	}
#endif



// ADC Type 7 Supported Devices ************************************************************
// 16F883, 16F884, 16F886, 16F887
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_7
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon1 = 0x00;

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ansel = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ansel = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ansel = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					ansel = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					ansel = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x01;
					tris_reg = &trise;
					ansel = 0x20;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trise;
					ansel = 0x40;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trise;
					ansel = 0x80;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x04;
					tris_reg = &trisb;
					anselh = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x08;
					tris_reg = &trisb;
					anselh = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x02;
					tris_reg = &trisb;
					anselh = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x10;
					tris_reg = &trisb;
					anselh = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_12
				case (13):
					tris_mask = 0x01;
					tris_reg = &trisb;
					anselh = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_13
				case (13):
					tris_mask = 0x20;
					tris_reg = &trisb;
					anselh = 0x20;
					break;
			#endif
		}

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Conv_Speed << 6)) | (Channel << 2);	//turn ADC on

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon0, VCFG0);

		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x02;									//begin conversion and wait until it has finished
		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		ansel = 0x00;
		adcon0 = 0x00;
		#ifdef ANSELH
			anselh = 0x00;
		#endif
	}
#endif


// ADC Type 8 Supported Devices ************************************************************
// 16F785
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_8
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ansel0 = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ansel0 = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ansel0 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x10;
					tris_reg = &trisa;
					ansel0 = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x01;
					tris_reg = &trisc;
					ansel0 = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x02;
					tris_reg = &trisc;
					ansel0 = 0x20;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x04;
					tris_reg = &trisc;
					ansel0 = 0x40;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x08;
					tris_reg = &trisc;
					ansel0 = 0x80;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x40;
					tris_reg = &trisc;
					ansel1 = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x80;
					tris_reg = &trisc;
					ansel1 = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x10;
					tris_reg = &trisb;
					ansel1 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x20;
					tris_reg = &trisb;
					ansel1 = 0x08;
					break;
			#endif
		}

		adcon1 = ((Conv_Speed & 0x07) << 4);					//assign conversion rate

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon0, VCFG);

		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x02;									//begin conversion and wait until it has finished
		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		ansel0 = 0x00;
		adcon0 = 0x00;
		#ifdef ANSEL1
			ansel1 = 0x00;
		#endif
	}
#endif


// ADC Type 9 Supported Devices ************************************************************
// 16F913, 16F914, 16F916, 16F917, 16F946
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_9
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ansel = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ansel = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ansel = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					ansel = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					ansel = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x01;
					tris_reg = &trise;
					ansel = 0x20;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trise;
					ansel = 0x40;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trise;
					ansel = 0x80;
					break;
			#endif
		}

		adcon1 = ((Conv_Speed & 0x07) << 4);					//assign conversion rate

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon0, VCFG0);

		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x02;									//begin conversion and wait until it has finished
		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		adcon0 = 0x00;
		ansel = 0x00;
	}
#endif


// ADC Type 10 Supported Devices ***********************************************************
// 12C671, 12C672, 12CE673, 12CE674
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_10
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		tris_reg = &trisio;

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					if (Vref == 0)
						adcon1 = 0x06;
					else
						adcon1 = 0x05;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					adcon1 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					if (Vref == 0)
						adcon1 = 0x02;
					else
						adcon1 = 0x03;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					if (Vref == 0)
						adcon1 = 0x00;
					else
						adcon1 = 0x01;
					break;
			#endif
		}

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Conv_Speed << 6)) | (Channel << 3);	//turn ADC on
		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x02;									//begin conversion and wait until it has finished
		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adres << 2);								//10-bit ADC
		}
		else
			iRetVal = adres;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		adcon1 = 0x07;
		adcon0 = 0x00;
	}
#endif


// ADC Type 11 Supported Devices ***********************************************************
// 16C717, 16C770, 16C771
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_11
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon1 = 0x00;

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ansel = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ansel = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ansel = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					ansel = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x01;
					tris_reg = &trisb;
					ansel = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x02;
					tris_reg = &trisb;
					ansel = 0x20;
					break;
			#endif
		}

		if (Conv_Speed > 3)										//assign conversion speed
			st_bit(adcon1, ADFM);

		if (Vref != 0)											//assign VREF functionality
		{
			st_bit(adcon1, VCFG0);
			st_bit(adcon1, VCFG1);
		}

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Conv_Speed << 6)) | (Channel << 3);	//turn ADC on
		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x04;									//begin conversion and wait until it has finished
		while (adcon0 & 0x04);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		adcon0 = 0x00;
		ansel = 0x00;
	}
#endif


// ADC Type 12 Supported Devices ***********************************************************
// 18F6310, 18F6390, 18F6410, 18F6490, 18F6520, 18F6527, 18F6585, 18F66J60, 18F66J65,
// 18F6620, 18F6622, 18F6627, 18F6680, 18F67J60, 18F6720, 18F6722, 18F8310, 18F8390,
// 18F8410, 18F8490, 18F8520, 18F8527, 18F8585, 18F86J60, 18F86J65, 18F8620, 18F8622,
// 18F8627, 18F8680, 18F87J60, 18F8720, 18F8722, 18F96J60, 18F96J65, 18F97J60
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_12
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon2 = Conv_Speed & 0x07;								//assign conversion rate

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					adcon1 = 0x0E;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					adcon1 = 0x0D;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					adcon1 = 0x0C;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					adcon1 = 0x0B;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					adcon1 = 0x0A;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x01;
					tris_reg = &trisf;
					adcon1 = 0x09;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trisf;
					adcon1 = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trisf;
					adcon1 = 0x07;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x08;
					tris_reg = &trisf;
					adcon1 = 0x06;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x10;
					tris_reg = &trisf;
					adcon1 = 0x05;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x20;
					tris_reg = &trisf;
					adcon1 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x40;
					tris_reg = &trisf;
					adcon1 = 0x03;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_12
				case (12):
					tris_mask = 0x10;
					tris_reg = &trish;
					adcon1 = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_13
				case (13):
					tris_mask = 0x20;
					tris_reg = &trish;
					adcon1 = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_14
				case (14):
					tris_mask = 0x40;
					tris_reg = &trish;
					adcon1 = 0x00;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_15
				case (15):
					tris_mask = 0x80;
					tris_reg = &trish;
					adcon1 = 0x00;
					break;
			#endif
		}

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon0, VCFG0);

		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x02;									//begin conversion and wait until it has finished
		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		adcon1 = 0x0f;
		adcon0 = 0x00;
	}
#endif


// ADC Type 13 Supported Devices ***********************************************************
// 18F2220, 18F2221, 18F2320, 18F2321, 18F24J10, 18F2410, 18F2420, 18F2423, 18F2450,
// 18F2455, 18F2480, 18F25J10, 18F2510, 18F2515, 18F2520, 18F2523, 18F2525, 18F2550,
// 18F2580, 18F2585, 18F2610, 18F2620, 18F2680, 18F4220, 18F4221, 18F4320, 18F4321,
// 18F44J10, 18F4410, 18F4420, 18F4423, 18F4450, 18F4455, 18F4480, 18F45J10, 18F4510,
// 18F4515, 18F4520, 18F4523, 18F4525, 18F4550, 18F4580, 18F4585, 18F4610, 18F4620,
// 18F4680, 18F4682, 18F4685
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_13
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon2 = Conv_Speed & 0x07;								//assign conversion rate

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					adcon1 = 0x0E;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					adcon1 = 0x0D;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					adcon1 = 0x0C;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					adcon1 = 0x0B;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					adcon1 = 0x0A;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x01;
					tris_reg = &trise;
					adcon1 = 0x09;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trise;
					adcon1 = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trise;
					adcon1 = 0x07;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x04;
					tris_reg = &trisb;
					adcon1 = 0x06;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x08;
					tris_reg = &trisb;
					adcon1 = 0x05;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x02;
					tris_reg = &trisb;
					adcon1 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x10;
					tris_reg = &trisb;
					adcon1 = 0x03;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_12
				case (12):
					tris_mask = 0x01;
					tris_reg = &trisb;
					adcon1 = 0x02;
					break;
			#endif
		}

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon0, VCFG0);

		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x02;									//begin conversion and wait until it has finished
		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
		  #ifdef MX_ADC_BITS_12
			iRetVal = (adresh << 4);							//12-bit ADC
			iRetVal = iRetVal | (adresl >> 4);
		  #else
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		  #endif
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		adcon1 = 0x0f;
		adcon0 = 0x00;
	}
#endif


// ADC Type 14 Supported Devices ***********************************************************
// 18F2331, 18F2431, 18F4331, 18F4431
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_14
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon1 = 0x00;											//set up ADC conversion
		adcon2 = Conv_Speed & 0x07;
		adcon3 = 0x00;
		adchs = 0x00;

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					adcon0 = 0x00;
					ansel0 = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					adcon0 = 0x04;
					ansel0 = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					adcon0 = 0x08;
					ansel0 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					adcon0 = 0x0C;
					ansel0 = 0x08;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x10;
					tris_reg = &trisa;
					adcon0 = 0x00;
					adchs = 0x01;
					ansel0 = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x20;
					tris_reg = &trisa;
					adcon0 = 0x04;
					adchs = 0x10;
					ansel0 = 0x20;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x01;
					tris_reg = &trise;
					adcon0 = 0x08;
					adchs = 0x04;
					ansel0 = 0x40;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x02;
					tris_reg = &trise;
					adcon0 = 0x0C;
					adchs = 0x40;
					ansel0 = 0x80;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x04;
					tris_reg = &trisb;
					adcon0 = 0x00;
					adchs = 0x02;
					ansel1 = 0x01;
					break;
			#endif
		}

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = adcon0 | 0x01;									//turn ADC on

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon0, VCFG0);

		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x02;									//begin conversion and wait until it has finished
		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		adcon0 = 0x00;
		ansel0 = 0x00;
		#ifdef ANSEL1
			ansel1 = 0x00;
		#endif
	}
#endif


// ADC Type 15 Supported Devices ***********************************************************
// 18F1220, 18F1320
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_15
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon2 = Conv_Speed & 0x07;								//assign conversion rate

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					adcon1 = 0x7E;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					adcon1 = 0x7D;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					adcon1 = 0x7B;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					adcon1 = 0x77;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x01;
					tris_reg = &trisb;
					adcon1 = 0x6F;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x02;
					tris_reg = &trisb;
					adcon1 = 0x5F;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x10;
					tris_reg = &trisb;
					adcon1 = 0x3F;
					break;
			#endif
		}

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon0, VCFG0);

		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x02;									//begin conversion and wait until it has finished
		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		adcon1 = 0x7f;
		adcon0 = 0x00;
	}
#endif


// ADC Type 16 Supported Devices ***********************************************************
// 18F242, 18F2439, 18F248, 18F252, 18F2539, 18F258, 18F442, 18F4439, 18F448, 18F452,
// 18F4539, 18F458
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_16
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					if (Vref != 0)
						adcon1 = 0x05;
					else
						adcon1 = 0x0E;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					if (Vref != 0)
						adcon1 = 0x05;
					else
						adcon1 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					if (Vref != 0)
						adcon1 = 0x03;
					else
						adcon1 = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					adcon1 = 0x04;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					if (Vref != 0)
						adcon1 = 0x03;
					else
						adcon1 = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x01;
					tris_reg = &trise;
					if (Vref != 0)
						adcon1 = 0x0A;
					else
						adcon1 = 0x09;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trise;
					if (Vref != 0)
						adcon1 = 0x01;
					else
						adcon1 = 0x00;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trise;
					if (Vref != 0)
						adcon1 = 0x01;
					else
						adcon1 = 0x00;
					break;
			#endif
		}

		if (Conv_Speed > 3)										//assign conversion speed
			st_bit(adcon1, ADCS2);

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Conv_Speed << 6)) | (Channel << 3);	//turn ADC on
		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x04;									//begin conversion and wait until it has finished
		while (adcon0 & 0x04);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		adcon1 = 0x07;
		adcon0 = 0x00;
	}
#endif


// ADC Type 17 Supported Devices ***********************************************************
// 18F1230, 18F1330
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_17
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon2 = Conv_Speed & 0x07;
		adcon1 = 0x00 | (0x01 << Channel);

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x10;
					tris_reg = &trisa;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x40;
					tris_reg = &trisa;
					break;
			#endif
		}

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon1, VCFG0);

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on
		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x02;									//begin conversion and wait until it has finished
		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		adcon1 = 0x00;
		adcon0 = 0x00;
	}
#endif


// ADC Type 18 Supported Devices ***********************************************************
// 16F722, 16F723, 16F724, 16F726, 16F727, 16F1933, 16F1934, 16F1936, 16F1937, 16F1939
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_18

	#ifndef ADREF1
		#define ADREF1 ADPREF1
	#endif

	MX_UINT8 * ansel_reg;					//ANSEL register pointer

	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon1 = (Conv_Speed & 0x07) << 4;						//assign conversion rate

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					ansel_reg = &ansela;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x01;
					tris_reg = &trise;
					ansel_reg = &ansele;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trise;
					ansel_reg = &ansele;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trise;
					ansel_reg = &ansele;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x04;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x08;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x02;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x10;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_12
				case (12):
					tris_mask = 0x01;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_13
				case (13):
					tris_mask = 0x20;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
		}

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon1, ADREF1);

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		*ansel_reg = *ansel_reg | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on
		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x02;									//begin conversion and wait until it has finished
		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		*ansel_reg = 0x00;
		adcon0 = 0x00;
	}
#endif


// ADC Type 19 Supported Devices ***********************************************************
// 18F13K50, 18F14K50, 18LF13K50, 18LF14K50
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_19
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon1 = 0;

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					ansel = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					ansel = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					ansel = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x10;
					tris_reg = &trisa;
					ansel = 0x08;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x01;
					tris_reg = &trisc;
					ansel = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x02;
					tris_reg = &trisc;
					ansel = 0x20;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x04;
					tris_reg = &trisc;
					ansel = 0x40;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x08;
					tris_reg = &trisc;
					adcon1 = 0x80;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x40;
					tris_reg = &trisc;
					anselh = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x80;
					tris_reg = &trisc;
					anselh = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x10;
					tris_reg = &trisb;
					anselh = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x20;
					tris_reg = &trisb;
					anselh = 0x08;
					break;
			#endif
		}

		adcon2 = Conv_Speed & 0x07;								//assign conversion rate

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon1, PVCFG0);

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on
		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x02;									//begin conversion and wait until it has finished
		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		ansel = 0;
		adcon0 = 0x00;
		#ifdef ANSELH
			anselh = 0;
		#endif
	}
#endif


// ADC Type 20 Supported Devices ***********************************************************
// 18F23K20, 18F24K20, 18F25K20, 18F26K20, 18F43K20, 18F44K20, 18F45K20, 18F16K20
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_20
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon1 = 0;

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ansel = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ansel = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ansel = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					ansel = 0x08;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					ansel = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x01;
					tris_reg = &trise;
					ansel = 0x20;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trise;
					ansel = 0x40;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trise;
					adcon1 = 0x80;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x04;
					tris_reg = &trisb;
					anselh = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x08;
					tris_reg = &trisb;
					anselh = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x02;
					tris_reg = &trisb;
					anselh = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x10;
					tris_reg = &trisb;
					anselh = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_12
				case (12):
					tris_mask = 0x01;
					tris_reg = &trisb;
					anselh = 0x10;
					break;
			#endif
		}

		adcon2 = Conv_Speed & 0x07;								//assign conversion rate

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon1, VCFG0);

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on
		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x02;									//begin conversion and wait until it has finished
		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		ansel = 0;
		adcon0 = 0x00;
		#ifdef ANSELH
			anselh = 0;
		#endif
	}
#endif


// ADC Type 21 Supported Devices ***********************************************************
// 18F2xJ11, 18F4xJ11
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_21
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon1 = 0;

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ancon0 = 0xFE;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ancon0 = 0xFD;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ancon0 = 0xFB;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					ancon0 = 0xF7;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					ancon0 = 0xEF;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x01;
					tris_reg = &trise;
					ancon0 = 0xDF;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trise;
					ancon0 = 0xBF;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trise;
					ancon0 = 0x7F;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x04;
					tris_reg = &trisb;
					ancon1 = 0x1E;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x08;
					tris_reg = &trisb;
					ancon1 = 0x1D;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x02;
					tris_reg = &trisb;
					ancon1 = 0x1B;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x10;
					tris_reg = &trisb;
					ancon1 = 0x17;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_12
				case (12):
					tris_mask = 0x01;
					tris_reg = &trisb;
					ancon1 = 0x0F;
					break;
			#endif
		}

		adcon1 = Conv_Speed & 0x07;								//assign conversion rate

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon0, VCFG0);

		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x02;									//begin conversion and wait until it has finished
		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		ancon0 = 0xFF;
		ancon1 = 0x1F;
		adcon0 = 0x00;
	}
#endif


// ADC Type 22 Supported Devices ***********************************************************
// 10F220, 10F222
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_22
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon0 = 0x00;

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					asm("movf 1,w");
					asm("tris 6");
					adcon0 = 0x40;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					asm("movf 2,w");
					asm("tris 6");
					adcon0 = 0x84;
					break;
			#endif
		}

		adcon0 = adcon0 | 0x01;									//turn ADC on
		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x02;									//begin conversion and wait until it has finished
		while (adcon0 & 0x02);
		if (Sample_Mode)
			iRetVal = (adres << 2);								//10-bit ADC
		else
			iRetVal = adres;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		adcon0 = 0x00;											//Reset ADC Registers
	}
#endif


// ADC Type 23 Supported Devices ***********************************************************
// 16F1826, 16F1827
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_23

	MX_UINT8 * ansel_reg;					//ANSEL register pointer

	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon1 = (Conv_Speed & 0x07) << 4;						//assign conversion rate

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					ansel_reg = &ansela;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x10;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x40;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x80;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x20;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x10;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x08;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x04;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x02;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
		}

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon1, ADPREF1);

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		*ansel_reg = *ansel_reg | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on
		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x02;									//begin conversion and wait until it has finished
		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		*ansel_reg = 0x00;
		adcon0 = 0x00;
	}
#endif


// ADC Type 24 Supported Devices ***********************************************************
// 18F65J50, 18F66J50, 18F66J55, 18F67J50, 18F85J50, 18F86J50, 18F86J55, 18F87J50
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_24
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon1 = (Conv_Speed & 0x07);

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ancon0 = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ancon0 = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ancon0 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					ancon0 = 0x08;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					ancon0 = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trisf;
					ancon0 = 0x80;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x20;
					tris_reg = &trisf;
					ancon1 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x40;
					tris_reg = &trisf;
					ancon1 = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_12
				case (12):
					tris_mask = 0x10;
					tris_reg = &trish;
					ancon1 = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_13
				case (13):
					tris_mask = 0x20;
					tris_reg = &trish;
					ancon1 = 0x20;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_14
				case (14):
					tris_mask = 0x40;
					tris_reg = &trish;
					ancon1 = 0x40;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_15
				case (15):
					tris_mask = 0x80;
					tris_reg = &trish;
					ancon1 = 0x80;
					break;
			#endif
		}

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon0, VCFG0);

		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x02;									//begin conversion and wait until it has finished
		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		ancon0 = 0x00;
		ancon1 = 0x00;
		adcon0 = 0x00;
	}
#endif


// ADC Type 25 Supported Devices ***********************************************************
// 18F66J93, 18F67J93, 18F86J93, 18F87J93, 18F66J90, 18F67J90, 18F86J90, 18F87J90
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_25
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon2 = Conv_Speed & 0x07;

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					adcon1 = 0x0E;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					adcon1 = 0x0D;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					adcon1 = 0x0C;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					adcon1 = 0x0B;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					adcon1 = 0x0A;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x80;
					tris_reg = &trisf;
					adcon1 = 0x09;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trisf;
					adcon1 = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trisf;
					adcon1 = 0x07;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x08;
					tris_reg = &trisf;
					adcon1 = 0x06;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x10;
					tris_reg = &trisf;
					adcon1 = 0x05;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x20;
					tris_reg = &trisf;
					adcon1 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x40;
					tris_reg = &trisf;
					adcon1 = 0x03;
					break;
			#endif
		}

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon1, VCFG0);

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on

		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x02;									//begin conversion and wait until it has finished
		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		adcon1 = 0x0f;
		adcon0 = 0x00;
	}
#endif


// ADC Type 26 Supported Devices ***********************************************************
// 16F1822, 16F1823, 16F1824, 16F1825, 16F1828, 16F1829
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_26

	MX_UINT8 * ansel_reg;					//ANSEL register pointer

	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon1 = (Conv_Speed & 0x07) << 4;						//assign conversion rate

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x10;
					tris_reg = &trisa;
					ansel_reg = &ansela;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x01;
					tris_reg = &trisc;
					ansel_reg = &anselc;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x02;
					tris_reg = &trisc;
					ansel_reg = &anselc;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x04;
					tris_reg = &trisc;
					ansel_reg = &anselc;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x08;
					tris_reg = &trisc;
					ansel_reg = &anselc;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x40;
					tris_reg = &trisc;
					ansel_reg = &anselc;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x80;
					tris_reg = &trisc;
					ansel_reg = &anselc;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x10;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x20;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
		}

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon1, ADPREF1);

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		*ansel_reg = *ansel_reg | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on
		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x02;									//begin conversion and wait until it has finished
		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		*ansel_reg = 0x00;
		adcon0 = 0x00;
	}
#endif


// ADC Type 27 Supported Devices ***********************************************************
// 16F1946, 16F1947
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_27

	MX_UINT8 * ansel_reg;					//ANSEL register pointer

	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon1 = (Conv_Speed & 0x07) << 4;						//assign conversion rate

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					ansel_reg = &ansela;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x80;
					tris_reg = &trisf;
					ansel_reg = &anself;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trisf;
					ansel_reg = &anself;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trisf;
					ansel_reg = &anself;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x08;
					tris_reg = &trisf;
					ansel_reg = &anself;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x10;
					tris_reg = &trisf;
					ansel_reg = &anself;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x20;
					tris_reg = &trisf;
					ansel_reg = &anself;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x40;
					tris_reg = &trisf;
					ansel_reg = &anself;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_12
				case (11):
					tris_mask = 0x10;
					tris_reg = &trisg;
					ansel_reg = &anselg;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_13
				case (11):
					tris_mask = 0x08;
					tris_reg = &trisg;
					ansel_reg = &anselg;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_14
				case (11):
					tris_mask = 0x04;
					tris_reg = &trisg;
					ansel_reg = &anselg;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_15
				case (11):
					tris_mask = 0x02;
					tris_reg = &trisg;
					ansel_reg = &anselg;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_16
				case (11):
					tris_mask = 0x01;
					tris_reg = &trisg;
					ansel_reg = &anselg;
					break;
			#endif
		}

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon1, ADPREF1);

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		*ansel_reg = *ansel_reg | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on
		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x02;									//begin conversion and wait until it has finished
		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		*ansel_reg = 0x00;
		adcon0 = 0x00;
	}
#endif


// ADC Type 28 Supported Devices ***********************************************************
// 18F65K22, 18F66K22, 18F67K22, 18F85K22, 18F86K22, 18F87K22,
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_28
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon2 = Conv_Speed & 0x07;

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ancon0 = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ancon0 = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ancon0 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					ancon0 = 0x08;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					ancon0 = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x80;
					tris_reg = &trisf;
					ancon0 = 0x20;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trisf;
					ancon0 = 0x40;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trisf;
					ancon0 = 0x80;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x08;
					tris_reg = &trisf;
					ancon1 = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x10;
					tris_reg = &trisf;
					ancon1 = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x20;
					tris_reg = &trisf;
					ancon1 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x40;
					tris_reg = &trisf;
					ancon1 = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_12
				case (12):
					tris_mask = 0x10;
					tris_reg = &trish;
					ancon1 = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_13
				case (13):
					tris_mask = 0x20;
					tris_reg = &trish;
					ancon1 = 0x20;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_14
				case (14):
					tris_mask = 0x40;
					tris_reg = &trish;
					ancon1 = 0x40;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_15
				case (15):
					tris_mask = 0x80;
					tris_reg = &trish;
					ancon1 = 0x80;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_16
				case (16):
					tris_mask = 0x10;
					tris_reg = &trisg;
					ancon2 = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_17
				case (17):
					tris_mask = 0x08;
					tris_reg = &trisg;
					ancon2 = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_18
				case (18):
					tris_mask = 0x04;
					tris_reg = &trisg;
					ancon2 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_19
				case (19):
					tris_mask = 0x02;
					tris_reg = &trisg;
					ancon2 = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_20
				case (20):
					tris_mask = 0x08;
					tris_reg = &trish;
					ancon2 = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_21
				case (21):
					tris_mask = 0x04;
					tris_reg = &trish;
					ancon2 = 0x20;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_22
				case (22):
					tris_mask = 0x02;
					tris_reg = &trish;
					ancon2 = 0x40;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_23
				case (23):
					tris_mask = 0x01;
					tris_reg = &trish;
					ancon2 = 0x80;
					break;
			#endif
		}

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon1, VCFG0);

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on

		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x02;									//begin conversion and wait until it has finished
		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 4);							//12-bit ADC
			iRetVal = iRetVal | (adresl >> 4);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		adcon0 = 0x00;
		ancon0 = 0x00;
		#ifdef ANCON1
			ancon1 = 0x00;
		#endif
		#ifdef ANCON2
			ancon2 = 0x00;
		#endif
	}
#endif


// ADC Type 29 Supported Devices ***********************************************************
// 18F23K22, 18F24K22, 18F25K22, 18F26K22, 18F43K22, 18F44K22, 18F45K22, 18F46K22,
// 18LF23K22, 18LF24K22, 18LF25K22, 18LF26K22, 18LF43K22, 18LF44K22, 18LF45K22, 18LF46K22,
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_29

	MX_UINT8 * ansel_reg;					//ANSEL register pointer

	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon2 = Conv_Speed & 0x07;

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					ansel_reg = &ansela;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x01;
					tris_reg = &trise;
					ansel_reg = &ansele;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trise;
					ansel_reg = &ansele;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trise;
					ansel_reg = &ansele;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x04;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x08;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x02;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x10;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_12
				case (12):
					tris_mask = 0x01;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_13
				case (13):
					tris_mask = 0x20;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_14
				case (14):
					tris_mask = 0x04;
					tris_reg = &trisc;
					ansel_reg = &anselc;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_15
				case (15):
					tris_mask = 0x08;
					tris_reg = &trisc;
					ansel_reg = &anselc;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_16
				case (16):
					tris_mask = 0x10;
					tris_reg = &trisc;
					ansel_reg = &anselc;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_17
				case (17):
					tris_mask = 0x20;
					tris_reg = &trisc;
					ansel_reg = &anselc;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_18
				case (18):
					tris_mask = 0x40;
					tris_reg = &trisc;
					ansel_reg = &anselc;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_19
				case (19):
					tris_mask = 0x80;
					tris_reg = &trisc;
					ansel_reg = &anselc;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_20
				case (20):
					tris_mask = 0x01;
					tris_reg = &trisd;
					ansel_reg = &anseld;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_21
				case (21):
					tris_mask = 0x02;
					tris_reg = &trisd;
					ansel_reg = &anseld;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_22
				case (22):
					tris_mask = 0x04;
					tris_reg = &trisd;
					ansel_reg = &anseld;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_23
				case (23):
					tris_mask = 0x08;
					tris_reg = &trisd;
					ansel_reg = &anseld;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_24
				case (24):
					tris_mask = 0x10;
					tris_reg = &trisd;
					ansel_reg = &anseld;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_25
				case (25):
					tris_mask = 0x20;
					tris_reg = &trisd;
					ansel_reg = &anseld;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_26
				case (26):
					tris_mask = 0x40;
					tris_reg = &trisd;
					ansel_reg = &anseld;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_27
				case (27):
					tris_mask = 0x80;
					tris_reg = &trisd;
					ansel_reg = &anseld;
					break;
			#endif
		}

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon1, PVCFG0);

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		*ansel_reg = ansel_reg | tris_mask;

		adcon0 = (0x01 | (Channel << 2));						//turn ADC on

		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x02;									//begin conversion and wait until it has finished
		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		*ansel_reg = 0x00;
		adcon0 = 0x00;
	}
#endif


// ADC Type 30 Supported Devices ************************************************************
// 16F870, 16F871, 16F872, 16F873, 16F874, 16F876, 16F877
// *******************************************************************************************/

#ifdef MX_ADC_TYPE_30
	void FC_CAL_Enable_ADC (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					if (Vref == 0)
						adcon1 = 0x0E;
					else
						adcon1 = 0x05;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					if (Vref == 0)
						adcon1 = 0x04;
					else
						adcon1 = 0x05;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					if (Vref == 0)
						adcon1 = 0x02;
					else
						adcon1 = 0x03;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					if (Vref == 0)
						adcon1 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					if (Vref == 0)
						adcon1 = 0x02;
					else
						adcon1 = 0x03;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x01;
					tris_reg = &trise;
					if (Vref == 0)
						adcon1 = 0x09;
					else
						adcon1 = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trise;
					if (Vref == 0)
						adcon1 = 0x00;
					else
						adcon1 = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trise;
					if (Vref == 0)
						adcon1 = 0x00;
					else
						adcon1 = 0x01;
					break;
			#endif
		}

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Conv_Speed << 6)) | (Channel << 3);	//turn ADC on
		delay_us(T_Charge);										//wait the acquisition time
	}

	MX_UINT16 FC_CAL_Sample_ADC (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		adcon0 = adcon0 | 0x04;									//begin conversion and wait until it has finished
		while (adcon0 & 0x04);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		return (iRetVal);
	}

	void FC_CAL_Disable_ADC ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		adcon1 = 0x07;
		adcon0 = 0x00;
	}
#endif

/*********************************************************************
 *                  Flowcode CAL PWM File
 *
 * File: PIC_CAL_PWM.c
 *
 * (c) 2011 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * “Company”) for its Flowcode graphical programming language is
 * intended and supplied to you, the Company’s customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 270911 | BR | Created
 * 021211 | BR | Converted to new dynamic defines mechanism
 *
 */


#define MX_PWM_CHANNEL_X		CAL_APPEND(MX_PWM_CHANNEL_, MX_PWM_NUM)
#define MX_PWM_HWALT_X			CAL_APPEND(MX_PWM_HWALT_, MX_PWM_NUM)


//I2C Master Functions
CALFUNCTION(void, FC_CAL_PWM_Enable_Channel_, (void));
CALFUNCTION(void, FC_CAL_PWM_Disable_Channel_, (void));
CALFUNCTION(void, FC_CAL_PWM_Set_Duty_8Bit_, (MX_UINT8 duty));
CALFUNCTION(void, FC_CAL_PWM_Change_Period_, (MX_UINT8 period, MX_UINT16 prescaler));
CALFUNCTION(void, FC_CAL_PWM_Set_Duty_10Bit_, (MX_UINT16 duty));


CALFUNCTION(void, FC_CAL_PWM_Enable_Channel_, (void))

{

 #ifdef MX_PWM

	#if (MX_PWM_CHANNEL_X == 1)
	  #ifdef MX_PWM_REMAPPABLE
	  	RPOR3 = 14;														//PWM1 - 14 - RB0 - RP3
	  #endif

		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
		  #ifndef MX_PWM_1_PORT											//Error checking
			#error "This chip does not have PWM channel 1 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_1_PORT, MX_PWM_1_TRIS, MX_PWM_1_PIN);			//PWM pin is an output
		#else															//Alternate PWM Pin
		  #ifndef MX_PWM_1_PORT_A										//Error checking
			#error "This chip does not have PWM alt channel 1 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_1_PORT_A, MX_PWM_1_TRIS_A, MX_PWM_1_PIN_A);		//PWM pin is an output
		#endif

		ccp1con = 0x0C;													//Enable Capture Compare Channel 1
	#endif

	#if (MX_PWM_CHANNEL_X == 2)
	  #ifdef MX_PWM_REMAPPABLE
	  	RPOR4 = 18;														//PWM2 - 18 - RB1 - RP4
	  #endif

		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
		  #ifndef MX_PWM_2_PORT											//Error checking
			#error "This chip does not have PWM channel 2 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_2_PORT, MX_PWM_2_TRIS, MX_PWM_2_PIN);			//PWM pin is an output
015E  1683  	BSF STATUS, RP0
015F  1303  	BCF STATUS, RP1
0160  1087  	BCF gbl_trisc,1
0161  1283  	BCF STATUS, RP0
0162  1087  	BCF gbl_portc,1

		#else															//Alternate PWM Pin
		  #ifndef MX_PWM_2_PORT_A										//Error checking
			#error "This chip does not have PWM alt channel 2 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_2_PORT_A, MX_PWM_2_TRIS_A, MX_PWM_2_PIN_A);		//PWM pin is an output
		#endif

		ccp2con = 0x0C;													//Enable Capture Compare Channel 2
0163  300C  	MOVLW 0x0C
0164  009D  	MOVWF gbl_ccp2con

	#endif

	#if (MX_PWM_CHANNEL_X == 3)
	  #ifdef MX_PWM_REMAPPABLE
	  	RPOR5 = 22;														//PWM3 - 22 - RB2 - RP5
	  #endif

		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
		  #ifndef MX_PWM_3_PORT											//Error checking
			#error "This chip does not have PWM channel 3 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_3_PORT, MX_PWM_3_TRIS, MX_PWM_3_PIN);			//PWM pin is an output
		#else															//Alternate PWM Pin
		  #ifndef MX_PWM_3_PORT_A										//Error checking
			#error "This chip does not have PWM alt channel 3 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_3_PORT_A, MX_PWM_3_TRIS_A, MX_PWM_3_PIN_A);		//PWM pin is an output
		#endif

		ccp3con = 0x0C;													//Enable Capture Compare Channel 3 *****************************************************************
	#endif

	#if (MX_PWM_CHANNEL_X == 4)
		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
		  #ifndef MX_PWM_4_PORT											//Error checking
			#error "This chip does not have PWM channel 4 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_4_PORT, MX_PWM_4_TRIS, MX_PWM_4_PIN);			//PWM pin is an output
		#else															//Alternate PWM Pin
		  #ifndef MX_PWM_4_PORT_A										//Error checking
			#error "This chip does not have PWM alt channel 4 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_4_PORT_A, MX_PWM_4_TRIS_A, MX_PWM_4_PIN_A);		//PWM pin is an output
		#endif

		ccp4con = 0x0C;													//Enable Capture Compare Channel 4 *****************************************************************
	#endif

	#if (MX_PWM_CHANNEL_X == 5)
		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
		  #ifndef MX_PWM_5_PORT											//Error checking
			#error "This chip does not have PWM channel 5 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_5_PORT, MX_PWM_5_TRIS, MX_PWM_5_PIN);			//PWM pin is an output
		#else															//Alternate PWM Pin
		  #ifndef MX_PWM_5_PORT_A										//Error checking
			#error "This chip does not have PWM alt channel 5 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_5_PORT_A, MX_PWM_5_TRIS_A, MX_PWM_5_PIN_A);		//PWM pin is an output
		#endif

		ccp5con = 0x0C;													//Enable Capture Compare Channel 5 *****************************************************************
	#endif

	#if (MX_PWM_CHANNEL_X == 6)
		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
		  #ifndef MX_PWM_6_PORT											//Error checking
			#error "This chip does not have PWM channel 6 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_6_PORT, MX_PWM_6_TRIS, MX_PWM_6_PIN);			//PWM pin is an output
		#else															//Alternate PWM Pin
		  #ifndef MX_PWM_6_PORT_A										//Error checking
			#error "This chip does not have PWM alt channel 6 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_6_PORT_A, MX_PWM_6_TRIS_A, MX_PWM_6_PIN_A);		//PWM pin is an output
		#endif

		ccp6con = 0x0C;													//Enable Capture Compare Channel 6 *****************************************************************
	#endif

	#if (MX_PWM_CHANNEL_X == 7)
		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
		  #ifndef MX_PWM_7_PORT											//Error checking
			#error "This chip does not have PWM channel 7 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_7_PORT, MX_PWM_7_TRIS, MX_PWM_7_PIN);			//PWM pin is an output
		#else															//Alternate PWM Pin
		  #ifndef MX_PWM_7_PORT_A										//Error checking
			#error "This chip does not have PWM alt channel 7 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_7_PORT_A, MX_PWM_7_TRIS_A, MX_PWM_7_PIN_A);		//PWM pin is an output
		#endif

		ccp7con = 0x0C;													//Enable Capture Compare Channel 5 *****************************************************************
	#endif

	#if (MX_PWM_CHANNEL_X == 8)
		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
		  #ifndef MX_PWM_8_PORT											//Error checking
			#error "This chip does not have PWM channel 8 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_8_PORT, MX_PWM_8_TRIS, MX_PWM_8_PIN);			//PWM pin is an output
		#else															//Alternate PWM Pin
		  #ifndef MX_PWM_8_PORT_A										//Error checking
			#error "This chip does not have PWM alt channel 8 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_8_PORT_A, MX_PWM_8_TRIS_A, MX_PWM_8_PIN_A);		//PWM pin is an output
		#endif

		ccp8con = 0x0C;													//Enable Capture Compare Channel 8 *****************************************************************
	#endif

	#if (MX_PWM_CHANNEL_X == 9)
		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
		  #ifndef MX_PWM_9_PORT											//Error checking
			#error "This chip does not have PWM channel 9 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_9_PORT, MX_PWM_9_TRIS, MX_PWM_9_PIN);			//PWM pin is an output
		#else															//Alternate PWM Pin
		  #ifndef MX_PWM_9_PORT_A										//Error checking
			#error "This chip does not have PWM alt channel 9 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_9_PORT_A, MX_PWM_9_TRIS_A, MX_PWM_9_PIN_A);		//PWM pin is an output
		#endif

		ccp9con = 0x0C;													//Enable Capture Compare Channel 9 *****************************************************************
	#endif

	#if (MX_PWM_CHANNEL_X == 10)
		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
		  #ifndef MX_PWM_10_PORT											//Error checking
			#error "This chip does not have PWM channel 10 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_10_PORT, MX_PWM_10_TRIS, MX_PWM_10_PIN);			//PWM pin is an output
		#else															//Alternate PWM Pin
		  #ifndef MX_PWM_10_PORT_A										//Error checking
			#error "This chip does not have PWM alt channel 10 defined"
		  #endif
			FC_CAL_Bit_Low_DDR (MX_PWM_10_PORT_A, MX_PWM_10_TRIS_A, MX_PWM_10_PIN_A);		//PWM pin is an output
		#endif

		ccp10con = 0x0C;												//Enable Capture Compare Channel 10 *****************************************************************
	#endif

 #else
 	#error "Hardware PWM not supported by Target microcontroller."
 #endif

}
0165  0008  	RETURN



CALFUNCTION(void, FC_CAL_PWM_Disable_Channel_, (void))
{
	#if (MX_PWM_CHANNEL_X == 1)
		ccp1con = 0x00;													//Disable Capture Compare Channel 1
		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_1_PORT, MX_PWM_1_TRIS, MX_PWM_1_PIN);			//PWM pin is an input
		#else															//Alternate PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_1_PORT_A, MX_PWM_1_TRIS_A, MX_PWM_1_PIN_A);		//PWM pin is an input
		#endif
	#endif

	#if (MX_PWM_CHANNEL_X == 2)
		ccp2con = 0x00;													//Disable Capture Compare Channel 2
		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_2_PORT, MX_PWM_2_TRIS, MX_PWM_2_PIN);			//PWM pin is an input
		#else															//Alternate PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_2_PORT_A, MX_PWM_2_TRIS_A, MX_PWM_2_PIN_A);		//PWM pin is an input
		#endif
	#endif

	#if (MX_PWM_CHANNEL_X == 3)
		ccp3con = 0x00;													//Disable Capture Compare Channel 3
		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_3_PORT, MX_PWM_3_TRIS, MX_PWM_3_PIN);			//PWM pin is an input
		#else															//Alternate PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_3_PORT_A, MX_PWM_3_TRIS_A, MX_PWM_3_PIN_A);		//PWM pin is an input
		#endif
	#endif

	#if (MX_PWM_CHANNEL_X == 4)
		ccp4con = 0x00;													//Disable Capture Compare Channel 4
		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_4_PORT, MX_PWM_4_TRIS, MX_PWM_4_PIN);			//PWM pin is an input
		#else															//Alternate PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_4_PORT_A, MX_PWM_4_TRIS_A, MX_PWM_4_PIN_A);		//PWM pin is an input
		#endif
	#endif

	#if (MX_PWM_CHANNEL_X == 5)
		ccp5con = 0x00;													//Disable Capture Compare Channel 5
		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_5_PORT, MX_PWM_5_TRIS, MX_PWM_5_PIN);			//PWM pin is an input
		#else															//Alternate PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_5_PORT_A, MX_PWM_5_TRIS_A, MX_PWM_5_PIN_A);		//PWM pin is an input
		#endif
	#endif

	#if (MX_PWM_CHANNEL_X == 6)
		ccp6con = 0x00;													//Disable Capture Compare Channel 6
		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_6_PORT, MX_PWM_6_TRIS, MX_PWM_6_PIN);			//PWM pin is an input
		#else															//Alternate PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_6_PORT_A, MX_PWM_6_TRIS_A, MX_PWM_6_PIN_A);		//PWM pin is an input
		#endif
	#endif

	#if (MX_PWM_CHANNEL_X == 7)
		ccp7con = 0x00;													//Disable Capture Compare Channel 7
		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_7_PORT, MX_PWM_7_TRIS, MX_PWM_7_PIN);			//PWM pin is an input
		#else															//Alternate PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_7_PORT_A, MX_PWM_7_TRIS_A, MX_PWM_7_PIN_A);		//PWM pin is an input
		#endif
	#endif

	#if (MX_PWM_CHANNEL_X == 8)
		ccp8con = 0x00;													//Disable Capture Compare Channel 8
		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_8_PORT, MX_PWM_8_TRIS, MX_PWM_8_PIN);			//PWM pin is an input
		#else															//Alternate PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_8_PORT_A, MX_PWM_8_TRIS_A, MX_PWM_8_PIN_A);		//PWM pin is an input
		#endif
	#endif

	#if (MX_PWM_CHANNEL_X == 9)
		ccp9con = 0x00;													//Disable Capture Compare Channel 9
		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_9_PORT, MX_PWM_9_TRIS, MX_PWM_9_PIN);			//PWM pin is an input
		#else															//Alternate PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_9_PORT_A, MX_PWM_9_TRIS_A, MX_PWM_9_PIN_A);		//PWM pin is an input
		#endif
	#endif

	#if (MX_PWM_CHANNEL_X == 10)
		ccp10con = 0x00;												//Disable Capture Compare Channel 10
		#if (MX_PWM_HWALT_X == 0)										//Default PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_10_PORT, MX_PWM_10_TRIS, MX_PWM_10_PIN);			//PWM pin is an input
		#else															//Alternate PWM Pin
			FC_CAL_Bit_In_DDR (MX_PWM_10_PORT_A, MX_PWM_10_TRIS_A, MX_PWM_10_PIN_A);		//PWM pin is an input
		#endif
	#endif
}


CALFUNCTION(void, FC_CAL_PWM_Set_Duty_8Bit_, (MX_UINT8 duty))

{
	#if (MX_PWM_CHANNEL_X == 1)
		ccpr1l = duty;													//Update Capture Compare Count 1
	#endif

	#if (MX_PWM_CHANNEL_X == 2)
		ccpr2l = duty;													//Update Capture Compare Count 2
008A  0873  	MOVF FC_CAL_PWM_00070_arg_duty, W
008B  009B  	MOVWF gbl_ccpr2l

	#endif

	#if (MX_PWM_CHANNEL_X == 3)
		ccpr3l = duty;													//Update Capture Compare Count 3
	#endif

	#if (MX_PWM_CHANNEL_X == 4)
		ccpr4l = duty;													//Update Capture Compare Count 4
	#endif

	#if (MX_PWM_CHANNEL_X == 5)
		ccpr5l = duty;													//Update Capture Compare Count 5
	#endif

	#if (MX_PWM_CHANNEL_X == 6)
		ccpr6l = duty;													//Update Capture Compare Count 6
	#endif

	#if (MX_PWM_CHANNEL_X == 7)
		ccpr7l = duty;													//Update Capture Compare Count 7
	#endif

	#if (MX_PWM_CHANNEL_X == 8)
		ccpr8l = duty;													//Update Capture Compare Count 8
	#endif

	#if (MX_PWM_CHANNEL_X == 9)
		ccpr9l = duty;													//Update Capture Compare Count 9
	#endif

	#if (MX_PWM_CHANNEL_X == 10)
		ccpr10l = duty;													//Update Capture Compare Count 10
	#endif
}
008C  0008  	RETURN



CALFUNCTION(void, FC_CAL_PWM_Change_Period_, (MX_UINT8 period, MX_UINT16 prescaler))

{
  #ifdef MX_PWM								//Hardware Mode
	pr2 = period;
013E  0872  	MOVF FC_CAL_PWM_00071_arg_period, W
013F  1683  	BSF STATUS, RP0
0140  0092  	MOVWF gbl_pr2

	switch (prescaler)
	{
	  #ifdef MX_PWM_PSCA1
		case 1:
0141  3001  	MOVLW 0x01
0142  1283  	BCF STATUS, RP0
0143  0673  	XORWF FC_CAL_PWM_00071_arg_prescaler, W
0144  1903  	BTFSC STATUS,Z
0145  0874  	MOVF FC_CAL_PWM_00071_arg_prescaler+D'1', W
0146  1903  	BTFSC STATUS,Z
0147  2955  	GOTO	label27
0155        label27

			t2con = 0x04;
0155  3004  	MOVLW 0x04
0156  0092  	MOVWF gbl_t2con

			break;
	  #endif
	  #ifdef MX_PWM_PSCA4
		case 4:
0148  3004  	MOVLW 0x04
0149  0673  	XORWF FC_CAL_PWM_00071_arg_prescaler, W
014A  1903  	BTFSC STATUS,Z
014B  0874  	MOVF FC_CAL_PWM_00071_arg_prescaler+D'1', W
014C  1903  	BTFSC STATUS,Z
014D  2958  	GOTO	label28
0158        label28

			t2con = 0x05;
0158  3005  	MOVLW 0x05
0159  0092  	MOVWF gbl_t2con

			break;
	  #endif
	  #ifdef MX_PWM_PSCA16
		case 16:
014E  3010  	MOVLW 0x10
014F  0673  	XORWF FC_CAL_PWM_00071_arg_prescaler, W
0150  1903  	BTFSC STATUS,Z
0151  0874  	MOVF FC_CAL_PWM_00071_arg_prescaler+D'1', W
0152  1903  	BTFSC STATUS,Z
0153  295B  	GOTO	label29
015B        label29

			t2con = 0x06;
015B  3006  	MOVLW 0x06
015C  0092  	MOVWF gbl_t2con

			break;
	  #endif
	  #ifdef MX_PWM_PSCA64
		case 64:
			t2con = 0x07;					//Note some earlier devices do not have the /64 option
			break;
	  #endif
	}
  #endif
}
0154  0008  	RETURN
0157  0008  	RETURN
015A  0008  	RETURN
015D  0008  	RETURN



CALFUNCTION(void, FC_CAL_PWM_Set_Duty_10Bit_, (MX_UINT16 duty))
{
	char nCCPxCONtemp;

	#if (MX_PWM_CHANNEL_X == 1)
		ccpr1l = (duty & 0x3FC) >> 2;									//Update Capture Compare Count 1
		duty = (duty & 0x03) << 4;
		nCCPxCONtemp = (ccp1con & 0xCF) | duty;
		ccp1con = nCCPxCONtemp;
	#endif

	#if (MX_PWM_CHANNEL_X == 2)
		ccpr2l = (duty & 0x3FC) >> 2;									//Update Capture Compare Count 2
		duty = (duty & 0x03) << 4;
		nCCPxCONtemp = (ccp2con & 0xCF) | duty;
		ccp2con = nCCPxCONtemp;
	#endif

	#if (MX_PWM_CHANNEL_X == 3)
		ccpr3l = (duty & 0x3FC) >> 2;									//Update Capture Compare Count 3
		duty = (duty & 0x03) << 4;
		nCCPxCONtemp = (ccp3con & 0xCF) | duty;
		ccp3con = nCCPxCONtemp;
	#endif

	#if (MX_PWM_CHANNEL_X == 4)
		ccpr4l = (duty & 0x3FC) >> 2;									//Update Capture Compare Count 4
		duty = (duty & 0x03) << 4;
		nCCPxCONtemp = (ccp4con & 0xCF) | duty;
		ccp4con = nCCPxCONtemp;
	#endif

	#if (MX_PWM_CHANNEL_X == 5)
		ccpr5l = (duty & 0x3FC) >> 2;									//Update Capture Compare Count 5
		duty = (duty & 0x03) << 4;
		nCCPxCONtemp = (ccp5con & 0xCF) | duty;
		ccp5con = nCCPxCONtemp;
	#endif

	#if (MX_PWM_CHANNEL_X == 6)
		ccpr6l = (duty & 0x3FC) >> 2;									//Update Capture Compare Count 6
		duty = (duty & 0x03) << 4;
		nCCPxCONtemp = (ccp6con & 0xCF) | duty;
		ccp6con = nCCPxCONtemp;
	#endif

	#if (MX_PWM_CHANNEL_X == 7)
		ccpr7l = (duty & 0x3FC) >> 2;									//Update Capture Compare Count 7
		duty = (duty & 0x03) << 4;
		nCCPxCONtemp = (ccp7con & 0xCF) | duty;
		ccp7con = nCCPxCONtemp;
	#endif

	#if (MX_PWM_CHANNEL_X == 8)
		ccpr8l = (duty & 0x3FC) >> 2;									//Update Capture Compare Count 8
		duty = (duty & 0x03) << 4;
		nCCPxCONtemp = (ccp8con & 0xCF) | duty;
		ccp8con = nCCPxCONtemp;
	#endif

	#if (MX_PWM_CHANNEL_X == 9)
		ccpr9l = (duty & 0x3FC) >> 2;									//Update Capture Compare Count 9
		duty = (duty & 0x03) << 4;
		nCCPxCONtemp = (ccp9con & 0xCF) | duty;
		ccp9con = nCCPxCONtemp;
	#endif

	#if (MX_PWM_CHANNEL_X == 10)
		ccpr10l = (duty & 0x3FC) >> 2;									//Update Capture Compare Count 10
		duty = (duty & 0x03) << 4;
		nCCPxCONtemp = (ccp10con & 0xCF) | duty;
		ccp10con = nCCPxCONtemp;
	#endif
}


/*********************************************************************
 *                  Flowcode CAL UART File
 *
 * File: PIC_CAL_UART.c
 *
 * (c) 2011 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * “Company”) for its Flowcode graphical programming language is
 * intended and supplied to you, the Company’s customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 010911 | BR | Created
 * 020911 | BR | Updated variables with typedef alternatives
 * 011211 | BR | Converted to new dynamic defines mechanism
 * 160112 | BR | Fixed issues with rx return type and low bauds on fast devices
 * 020212 | ST | Added <MX_UART_2_PIE4> routing to account for differences in 16F and 18F devices with 2 UARTs
 * 270212 | BR | Fixed a bug in the receive functionality
 * 280212 | BR | Sorted out auto echo functionality
 * 160412 | BR | Addition of HW change baud function
 */



#ifndef MX_UART_SW_DEFS
	#define MX_UART_SW_DEFS

	#ifdef _BOOSTC
		#define INST_COUNT	45	//65 for lower speeds or 40 for higher speeds.
	#endif
	#ifdef HI_TECH_C
		#define INST_COUNT	315
	#endif

	//Work out number of nops for software baud rate
	#define MX_INSTRUCTION_SPEED 	(MX_CLK_SPEED / 4)
	#define MX_OVERHEAD				(MX_INSTRUCTION_SPEED / INST_COUNT)
	#define SW_OFFSET				(1000000 / MX_OVERHEAD)

	//Work out software baud rates if required
	#define SW_1200_BAUD	(832 - SW_OFFSET)
	#define SW_2400_BAUD	(416 - SW_OFFSET)
	#define SW_4800_BAUD	(208 - SW_OFFSET)
	#define SW_9600_BAUD	(104 - SW_OFFSET)
	#define SW_19200_BAUD	(52 - SW_OFFSET)
	#define SW_31250_BAUD	(32 - SW_OFFSET)
	#define SW_115200_BAUD	(8 - SW_OFFSET)
#endif

 #if defined(MX_UART_CHANNEL_1) && (MX_UART_NUM==1)
	#if (MX_UART_CHANNEL_1 == 0)
		#if (MX_UART_BAUD_1 == 1200)
			#define MX_SOFT_BAUD_1	SW_1200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 1200 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_1 == 2400)
			#define MX_SOFT_BAUD_1	SW_2400_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 2400 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_1 == 4800)
			#define MX_SOFT_BAUD_1	SW_4800_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 4800 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_1 == 9600)
			#define MX_SOFT_BAUD_1	SW_9600_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 9600 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_1 == 19200)
			#define MX_SOFT_BAUD_1	SW_19200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 19200 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_1 == 31250)
			#define MX_SOFT_BAUD_1	SW_31250_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 31250 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_1 == 115200)
			#define MX_SOFT_BAUD_1	SW_115200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 115200 Not Available At This Clock Speed"
			#endif
		#endif
		#ifndef MX_SOFT_BAUD_1
			#error "UART Baud Rate not supported in Software Mode"
		#endif
	#else
		#define MX_SOFT_BAUD_1	1
		#define MX_HARD_BAUD_1	(((MX_CLK_SPEED / MX_UART_BAUD_1) - 16) / 16)
		#define MX_HARD_SLOW_1	0

		#if (MX_HARD_BAUD_1 > 255)
			#undef MX_HARD_BAUD_1
			#undef MX_HARD_SLOW_1
			#define MX_HARD_BAUD_1	(((MX_CLK_SPEED / MX_UART_BAUD_1) - 16)	/ 64)
			#define MX_HARD_SLOW_1	1
		#endif

	#endif
 #endif
 #if defined(MX_UART_CHANNEL_2) && (MX_UART_NUM==2)
	#if (MX_UART_CHANNEL_2 == 0)
		#if (MX_UART_BAUD_2 == 1200)
			#define MX_SOFT_BAUD_2	SW_1200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 1200 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_2 == 2400)
			#define MX_SOFT_BAUD_2	SW_2400_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 2400 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_2 == 4800)
			#define MX_SOFT_BAUD_2	SW_4800_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 4800 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_2 == 9600)
			#define MX_SOFT_BAUD_2	SW_9600_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 9600 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_2 == 19200)
			#define MX_SOFT_BAUD_2	SW_19200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 19200 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_2 == 31250)
			#define MX_SOFT_BAUD_2	SW_31250_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 31250 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_2 == 115200)
			#define MX_SOFT_BAUD_2	SW_115200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 115200 Not Available At This Clock Speed"
			#endif
		#endif
		#ifndef MX_SOFT_BAUD_2
			#error "UART Baud Rate not supported in Software Mode"
		#endif
	#else
		#define MX_SOFT_BAUD_2	1
		#define MX_HARD_BAUD_2	(((MX_CLK_SPEED / MX_UART_BAUD_2) - 16) / 16)
		#define MX_HARD_SLOW_2	0

		#if (MX_HARD_BAUD_2 > 255)
			#undef MX_HARD_BAUD_2
			#undef MX_HARD_SLOW_2
			#define MX_HARD_BAUD_2	(((MX_CLK_SPEED / MX_UART_BAUD_2) - 16)	/ 64)
			#define MX_HARD_SLOW_2	1
		#endif
 	#endif
 #endif
 #if defined(MX_UART_CHANNEL_3) && (MX_UART_NUM==3)
	#if (MX_UART_CHANNEL_3 == 0)
		#if (MX_UART_BAUD_3 == 1200)
			#define MX_SOFT_BAUD_3	SW_1200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 1200 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_3 == 2400)
			#define MX_SOFT_BAUD_3	SW_2400_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 2400 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_3 == 4800)
			#define MX_SOFT_BAUD_3	SW_4800_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 4800 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_3 == 9600)
			#define MX_SOFT_BAUD_3	SW_9600_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 9600 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_3 == 19200)
			#define MX_SOFT_BAUD_3	SW_19200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 19200 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_3 == 31250)
			#define MX_SOFT_BAUD_3	SW_31250_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 31250 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_3 == 115200)
			#define MX_SOFT_BAUD_3	SW_115200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 115200 Not Available At This Clock Speed"
			#endif
		#endif
		#ifndef MX_SOFT_BAUD_3
			#error "UART Baud Rate not supported in Software Mode"
		#endif
	#else
		#define MX_SOFT_BAUD_3	1
		#define MX_HARD_BAUD_3	(((MX_CLK_SPEED / MX_UART_BAUD_3) - 16) / 16)
		#define MX_HARD_SLOW_3	0

		#if (MX_HARD_BAUD_3 > 255)
			#undef MX_HARD_BAUD_3
			#undef MX_HARD_SLOW_3
			#define MX_HARD_BAUD_3	(((MX_CLK_SPEED / MX_UART_BAUD_3) - 16)	/ 64)
			#define MX_HARD_SLOW_3	1
		#endif
	#endif
 #endif
 #if defined(MX_UART_CHANNEL_4) && (MX_UART_NUM==4)
	#if (MX_UART_CHANNEL_4 == 0)
		#if (MX_UART_BAUD_4 == 1200)
			#define MX_SOFT_BAUD_4	SW_1200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 1200 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_4 == 2400)
			#define MX_SOFT_BAUD_4	SW_2400_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 2400 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_4 == 4800)
			#define MX_SOFT_BAUD_4	SW_4800_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 4800 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_4 == 9600)
			#define MX_SOFT_BAUD_4	SW_9600_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 9600 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_4 == 19200)
			#define MX_SOFT_BAUD_4	SW_19200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 19200 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_4 == 31250)
			#define MX_SOFT_BAUD_4	SW_31250_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 31250 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_4 == 115200)
			#define MX_SOFT_BAUD_4	SW_115200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 115200 Not Available At This Clock Speed"
			#endif
		#endif
		#ifndef MX_SOFT_BAUD_4
			#error "UART Baud Rate not supported in Software Mode"
		#endif
	#else
		#define MX_SOFT_BAUD_4	1
		#define MX_HARD_BAUD_4	(((MX_CLK_SPEED / MX_UART_BAUD_4) - 16) / 16)
		#define MX_HARD_SLOW_4	0

		#if (MX_HARD_BAUD_4 > 255)
			#undef MX_HARD_BAUD_4
			#undef MX_HARD_SLOW_4
			#define MX_HARD_BAUD_4	(((MX_CLK_SPEED / MX_UART_BAUD_4) - 16)	/ 64)
			#define MX_HARD_SLOW_4	1
		#endif
	#endif
 #endif


//Hardware Baud update definitions
#ifndef MX_HARD_BAUD_CHANGE_DEFS
	#define MX_HARD_BAUD_CHANGE_DEFS

	#define MX_HARD_BAUD_1200	(((MX_CLK_SPEED / 1200) - 16) / 16)
	#if (MX_HARD_BAUD_1200 > 255)
		#undef MX_HARD_BAUD_1200
		#define MX_HARD_BAUD_1200	(((MX_CLK_SPEED / 1200) - 16) / 64)
		#define MX_HARD_SLOW_1200	1
	#else
		#define MX_HARD_SLOW_1200	0
	#endif

	#define MX_HARD_BAUD_2400	(((MX_CLK_SPEED / 2400) - 16) / 16)
	#if (MX_HARD_BAUD_2400 > 255)
		#undef MX_HARD_BAUD_2400
		#define MX_HARD_BAUD_2400	(((MX_CLK_SPEED / 2400) - 16) / 64)
		#define MX_HARD_SLOW_2400	1
	#else
		#define MX_HARD_SLOW_2400	0
	#endif

	#define MX_HARD_BAUD_4800	(((MX_CLK_SPEED / 4800) - 16) / 16)
	#if (MX_HARD_BAUD_4800 > 255)
		#undef MX_HARD_BAUD_4800
		#define MX_HARD_BAUD_4800	(((MX_CLK_SPEED / 4800) - 16) / 64)
		#define MX_HARD_SLOW_4800	1
	#else
		#define MX_HARD_SLOW_4800	0
	#endif

	#define MX_HARD_BAUD_9600	(((MX_CLK_SPEED / 9600) - 16) / 16)
	#if (MX_HARD_BAUD_9600 > 255)
		#undef MX_HARD_BAUD_9600
		#define MX_HARD_BAUD_9600	(((MX_CLK_SPEED / 9600) - 16) / 64)
		#define MX_HARD_SLOW_9600	1
	#else
		#define MX_HARD_SLOW_9600	0
	#endif

	#define MX_HARD_BAUD_19200	(((MX_CLK_SPEED / 19200) - 16) / 16)
	#if (MX_HARD_BAUD_19200 > 255)
		#undef MX_HARD_BAUD_19200
		#define MX_HARD_BAUD_19200	(((MX_CLK_SPEED / 19200) - 16) / 64)
		#define MX_HARD_SLOW_19200	1
	#else
		#define MX_HARD_SLOW_19200	0
	#endif

	#define MX_HARD_BAUD_38400	(((MX_CLK_SPEED / 38400) - 16) / 16)
	#if (MX_HARD_BAUD_38400 > 255)
		#undef MX_HARD_BAUD_38400
		#define MX_HARD_BAUD_38400	(((MX_CLK_SPEED / 38400) - 16) / 64)
		#define MX_HARD_SLOW_38400	1
	#else
		#define MX_HARD_SLOW_38400	0
	#endif

	#define MX_HARD_BAUD_57600	(((MX_CLK_SPEED / 57600) - 16) / 16)
	#if (MX_HARD_BAUD_57600 > 255)
		#undef MX_HARD_BAUD_57600
		#define MX_HARD_BAUD_57600	(((MX_CLK_SPEED / 57600) - 16) / 64)
		#define MX_HARD_SLOW_57600	1
	#else
		#define MX_HARD_SLOW_57600	0
	#endif

	#define MX_HARD_BAUD_115200	(((MX_CLK_SPEED / 115200) - 16) / 16)
	#if (MX_HARD_BAUD_115200 > 255)
		#undef MX_HARD_BAUD_115200
		#define MX_HARD_BAUD_115200	(((MX_CLK_SPEED / 115200) - 16) / 64)
		#define MX_HARD_SLOW_115200	1
	#else
		#define MX_HARD_SLOW_115200	0
	#endif
#endif


//Dynamic function naming based on defines and index number
#define MX_UART_CHANNEL_X	CAL_APPEND(MX_UART_CHANNEL_, MX_UART_NUM)
#define MX_UART_TX_PIN_X	CAL_APPEND(MX_UART_TX_PIN_, MX_UART_NUM)
#define MX_UART_TX_PORT_X	CAL_APPEND(MX_UART_TX_PORT_, MX_UART_NUM)
#define MX_UART_TX_TRIS_X	CAL_APPEND(MX_UART_TX_TRIS_, MX_UART_NUM)
#define MX_UART_RX_PIN_X	CAL_APPEND(MX_UART_RX_PIN_, MX_UART_NUM)
#define MX_UART_RX_PORT_X	CAL_APPEND(MX_UART_RX_PORT_, MX_UART_NUM)
#define MX_UART_RX_TRIS_X	CAL_APPEND(MX_UART_RX_TRIS_, MX_UART_NUM)
#define MX_UART_FLOWEN_X	CAL_APPEND(MX_UART_FLOWEN_, MX_UART_NUM)
#define MX_UART_CTS_PIN_X	CAL_APPEND(MX_UART_CTS_PIN_, MX_UART_NUM)
#define MX_UART_CTS_PORT_X	CAL_APPEND(MX_UART_CTS_PORT_, MX_UART_NUM)
#define MX_UART_CTS_TRIS_X	CAL_APPEND(MX_UART_CTS_TRIS_, MX_UART_NUM)
#define MX_UART_RTS_PIN_X	CAL_APPEND(MX_UART_RTS_PIN_, MX_UART_NUM)
#define MX_UART_RTS_PORT_X	CAL_APPEND(MX_UART_RTS_PORT_, MX_UART_NUM)
#define MX_UART_RTS_TRIS_X	CAL_APPEND(MX_UART_RTS_TRIS_, MX_UART_NUM)
#define MX_UART_DBITS_X		CAL_APPEND(MX_UART_DBITS_, MX_UART_NUM)
#define MX_UART_RETURN_X	CAL_APPEND(MX_UART_RETURN_, MX_UART_NUM)
#define MX_UART_ECHO_X		CAL_APPEND(MX_UART_ECHO_, MX_UART_NUM)
#define MX_UART_INT_X		CAL_APPEND(MX_UART_INT_, MX_UART_NUM)
#define MX_UART_BAUD_X		CAL_APPEND(MX_HARD_BAUD_, MX_UART_NUM)
#define MX_SOFT_BAUD_X		CAL_APPEND(MX_SOFT_BAUD_, MX_UART_NUM)
#define MX_HARD_SLOW_X		CAL_APPEND(MX_HARD_SLOW_, MX_UART_NUM)

#define UART_Delay_CAL		CAL_APPEND(FC_CAL_UART_Delay_, MX_UART_NUM)
#define UART_Send			CAL_APPEND(FC_CAL_UART_Send_, MX_UART_NUM)
#define UART_Uninit			CAL_APPEND(FC_CAL_UART_Uninit_, MX_UART_NUM)


//Component Definitions
#define UART_STATUS_LOOP	0
#define UART_STATUS_TIMEOUT	1
#define UART_STATUS_RXBYTE	2


//Interrupt Definitions
#ifdef MX_UART_2_PIE4
  #define MX_UART2_PIE pie4
  #define MX_UART2_PIR pir4
  #define MX_UART2_TXSTA tx2sta
  #define MX_UART2_RCSTA rc2sta
  #define MX_UART2_TXREG tx2reg
  #define MX_UART2_RCREG rc2reg
#else
  #define MX_UART2_PIE pie3
  #define MX_UART2_PIR pir3
  #define MX_UART2_TXSTA txsta2
  #define MX_UART2_RCSTA rcsta2
  #define MX_UART2_TXREG txreg2
  #define MX_UART2_RCREG rcreg2
#endif

#if (MX_UART_INT_X == 1)

	#ifndef MX_UART_INT_DEFS
	#define MX_UART_INT_DEFS

		#define MX_UART_INT_CH1_FUNC
		#define MX_UART_INT_CH2_FUNC
		#define MX_UART_INT_FUNC_END

		#define MX_UART_INT_CH1_DET		ts_bit(pir1, RCIF) && ts_bit(pie1, RCIE)
		#define MX_UART_INT_CH2_DET		ts_bit(MX_UART2_PIR, RC2IF) && ts_bit(MX_UART2_PIE, RC2IE)

		#define MX_UART_INT_CH1_EN		st_bit (pie1, RCIE)
		#define MX_UART_INT_CH2_EN		st_bit (MX_UART2_PIE, RC2IE)

		#define MX_UART_INT_CH1_DIS		cr_bit (pie1, RCIE)
		#define MX_UART_INT_CH2_DIS		cr_bit (MX_UART2_PIE, RC2IE)

		#define MX_UART_INT_CH1_CLR		cr_bit (pir1, RCIF)
		#define MX_UART_INT_CH2_CLR		cr_bit (MX_UART2_PIR, RC2IF)

	#endif
#endif


//Function Prototypes
CALFUNCTION(void, FC_CAL_UART_Init_, (void));
CALFUNCTION(void, FC_CAL_UART_Uninit_, (void));
CALFUNCTION(void, FC_CAL_UART_Send_, (MX_UINT16 nChar));
CALFUNCTION(MX_SINT16, FC_CAL_UART_Receive_, (MX_UINT8 nTimeout));
CALFUNCTION(void, FC_CAL_UART_Delay_, (void));


//Peripheral Functions
CALFUNCTION(void, FC_CAL_UART_Init_, (void))

{

	#if (MX_UART_CHANNEL_X == 0)
		FC_CAL_Bit_In_DDR 	(MX_UART_RX_PORT_X, MX_UART_RX_TRIS_X, MX_UART_RX_PIN_X);		// Receive pin is a input
		FC_CAL_Bit_High_DDR (MX_UART_TX_PORT_X, MX_UART_TX_TRIS_X, MX_UART_TX_PIN_X);		// Transmit pin is default high
	#endif

	#if (MX_UART_CHANNEL_X == 1)
	  #ifndef MX_UART_1
	  	  #error "UART channel 1 not available on this device"
	  #else
		  #if (MX_HARD_SLOW_X == 1)
			cr_bit(txsta, BRGH);						//Low Speed
		  #else
			st_bit(txsta, BRGH);						//High Speed
031A  1683  	BSF STATUS, RP0
031B  1303  	BCF STATUS, RP1
031C  1518  	BSF gbl_txsta,2

		  #endif
			spbrg = MX_UART_BAUD_X;   					// set the baud rate
031D  3081  	MOVLW 0x81
031E  0099  	MOVWF gbl_spbrg

			rcsta = 0;                    				// 8-bit, disabled
031F  1283  	BCF STATUS, RP0
0320  0198  	CLRF gbl_rcsta


			#if(MX_UART_DBITS_X == 9)
				st_bit(txsta, TX9);   					// 9-bit TX
				st_bit(rcsta, RX9);                    	// 9-bit RX
			#endif

			st_bit(rcsta, SPEN);         				// turn on serial interface
0321  1798  	BSF gbl_rcsta,7

			st_bit(txsta, TXEN);
0322  1683  	BSF STATUS, RP0
0323  1698  	BSF gbl_txsta,5

			st_bit(rcsta, CREN);
0324  1283  	BCF STATUS, RP0
0325  1618  	BSF gbl_rcsta,4


			#if (MX_UART_INT_X == 1)
				MX_UART_INT_CH1_EN;
				st_bit(intcon, PEIE);
				st_bit(intcon, GIE);
			#else
				cr_bit (pie1, RCIE);
0326  1683  	BSF STATUS, RP0
0327  128C  	BCF gbl_pie1,5

			#endif
	  #endif
	#endif


	#if (MX_UART_CHANNEL_X == 2)

	  #ifndef MX_UART_2
		  #error "UART channel 2 not available on this device"
	  #else
		  #ifdef MX_UART_2_REMAPPABLE
			RPOR9 = 5;									//TX2 - RP9 - RB6
			RPINR16	= 10;								//RX2 - RP10 - RB7
		  #endif
		  #if (MX_HARD_SLOW_X == 1)
			cr_bit(MX_UART2_TXSTA, BRGH);						//Low Speed
		  #else
			st_bit(MX_UART2_TXSTA, BRGH);						//High Speed
		  #endif
			spbrg2 = MX_UART_BAUD_X;   				// set the baud rate
			MX_UART2_RCSTA = 0;                    				// 8-bit, disabled

			#if(MX_UART_DBITS_X == 9)
				st_bit(MX_UART2_TXSTA, TX9);   					// 9-bit TX
				st_bit(MX_UART2_RCSTA, RX9);                    // 9-bit RX
			#endif

			st_bit(MX_UART2_RCSTA, SPEN);         				// turn on serial interface
			st_bit(MX_UART2_TXSTA, TXEN);
			st_bit(MX_UART2_RCSTA, CREN);

			#if (MX_UART_INT_X == 1)
				MX_UART_INT_CH2_EN;
				st_bit(intcon, PEIE);
				st_bit(intcon, GIE);
			#else
				cr_bit (MX_UART2_PIE, RC2IE);
			#endif
	  #endif
	#endif

	#if (MX_UART_FLOWEN_X == 1)						//Flowcontrol enabled?
		FC_CAL_Bit_In_DDR (MX_UART_CTS_PORT_X, MX_UART_CTS_TRIS_X, MX_UART_CTS_PIN_X);	// CTS pin is a input
		FC_CAL_Bit_High_DDR (MX_UART_RTS_PORT_X, MX_UART_RTS_TRIS_X, MX_UART_RTS_PIN_X);	// RTS not ready to accept data
	#endif

}
0328  0008  	RETURN




CALFUNCTION(void, FC_CAL_UART_Uninit_, (void))
{

	#if (MX_UART_CHANNEL_X == 0)
		FC_CAL_Bit_In_DDR (MX_UART_RX_PORT_X, MX_UART_RX_TRIS_X, MX_UART_RX_PIN_X);		// Receive pin is a input
		FC_CAL_Bit_In_DDR (MX_UART_TX_PORT_X, MX_UART_TX_TRIS_X, MX_UART_TX_PIN_X);		// Transmit pin is default high
	#endif

	#if (MX_UART_CHANNEL_X == 1)
			rcsta = 0;                    								// 8-bit, disabled
			txsta = 0;
		  #ifdef MX_UART_RXINT
			MX_UART_INT_CH1_DIS;
		  #endif
	#endif

	#if (MX_UART_CHANNEL_X == 2)
			MX_UART2_RCSTA = 0;                    								// 8-bit, disabled
			MX_UART2_TXSTA = 0;
		  #ifdef MX_UART_RXINT
			MX_UART_INT_CH2_DIS;
		  #endif
	#endif

	#if (MX_UART_FLOWEN_X == 1)										//Flowcontrol enabled?
		FC_CAL_Bit_In_DDR (MX_UART_CTS_PORT_X, MX_UART_CTS_TRIS_X, MX_UART_CTS_PIN_X);		// CTS pin is a input
		FC_CAL_Bit_In_DDR (MX_UART_RTS_PORT_X, MX_UART_RTS_TRIS_X, MX_UART_RTS_PIN_X);		// RTS not ready to accept data
	#endif
}



CALFUNCTION(void, FC_CAL_UART_Send_, (MX_UINT16 nChar))

{
	#if (MX_UART_FLOWEN_X == 1)
		while (FC_CAL_Bit_In(MX_UART_CTS_PORT_X, MX_UART_CTS_PIN_X) != 0);	// Wait until CTS is low
	#endif

	#if (MX_UART_CHANNEL_X == 0)													// Software UART TX
		MX_UINT8 idx;
		FC_CAL_Bit_Low(MX_UART_TX_PORT_X, MX_UART_TX_PIN_X);					// Send Start bit
		UART_Delay_CAL();
		for (idx = 0; idx < MX_UART_DBITS_X; idx++)
		{
			if (nChar & 0x01)														// Mask off data bit
				FC_CAL_Bit_High(MX_UART_TX_PORT_X, MX_UART_TX_PIN_X);
			else
				FC_CAL_Bit_Low(MX_UART_TX_PORT_X, MX_UART_TX_PIN_X);
			UART_Delay_CAL();
			nChar = nChar >> 1;														// Move to next data bit
		}
		FC_CAL_Bit_High(MX_UART_TX_PORT_X, MX_UART_TX_PIN_X);					// Send Stop bit
		UART_Delay_CAL();
	#endif

	#if (MX_UART_CHANNEL_X == 1)
		while (ts_bit(pir1, TXIF) == 0);
0115        label23
0115  1E0C  	BTFSS gbl_pir1,4
0116  2915  	GOTO	label23


		#if (MX_UART_DBITS_X == 9)
			if (test_bit(nChar, 8))
				st_bit(txsta, TX9D);
			else
				cr_bit(txsta, TX9D);
	  	#endif
		txreg = nChar;
0117  0879  	MOVF FC_CAL_UAR_00079_arg_nChar, W
0118  0099  	MOVWF gbl_txreg

	#endif

	#if (MX_UART_CHANNEL_X == 2)
		while (ts_bit(pir3, TX2IF) == 0);

		#if (MX_UART_DBITS_X == 9)
			if (test_bit(nChar, 8))
				st_bit(MX_UART2_TXSTA, TX9D);
			else
				cr_bit(MX_UART2_TXSTA, TX9D);
		#endif
		MX_UART2_TXREG = nChar;
	#endif
}
0119  0008  	RETURN



CALFUNCTION(MX_SINT16, FC_CAL_UART_Receive_, (MX_UINT8 nTimeout))
{
  #if (MX_UART_RETURN_X == 1)
	MX_UINT16 retVal = 512;
  #else
  	MX_UINT8 retVal = 255;
  #endif

	MX_UINT8 delay1 = 0;
	MX_UINT8 regcheck = 0;
	MX_UINT8 bWaitForever = 0;
	MX_UINT8 rxStatus = UART_STATUS_LOOP;

  #if (MX_UART_CHANNEL_X == 0)
  	MX_UINT8 idx;
  #else
  	MX_UINT8 dummy = 0;
  #endif

	if (nTimeout == 255)
		bWaitForever = 1;

	#if (MX_UART_FLOWEN_X == 1)
		FC_CAL_Bit_Low (MX_UART_RTS_PORT_X, MX_UART_RTS_PIN_X);			// Ready to accept data
	#endif

	while (rxStatus == UART_STATUS_LOOP)
	{
		if (bWaitForever == 0)
		{
			if (nTimeout == 0)							//don't wait forever, so do timeout thing...
			{
				rxStatus = UART_STATUS_TIMEOUT;
			}
			else
			{
				delay_us(10);
				delay1 = delay1 + 1;
				if(delay1 == 100)
				{
					nTimeout = nTimeout - 1;
					MX_CLEAR_WATCHDOG;
					delay1 = 0;
				}
			}
		}

		#if (MX_UART_CHANNEL_X == 0)
			regcheck = FC_CAL_Bit_In(MX_UART_RX_PORT_1, MX_UART_RX_PIN_1);	//Test for start bit
			if (regcheck == 0)
				rxStatus = UART_STATUS_RXBYTE;
		#endif

		#if (MX_UART_CHANNEL_X == 1)
			regcheck = ts_bit(pir1, RCIF);
			if (regcheck != 0)
				rxStatus = UART_STATUS_RXBYTE;
		#endif

		#if (MX_UART_CHANNEL_X == 2)
			regcheck = ts_bit(MX_UART2_PIR, RC2IF);
			if (regcheck != 0)
				rxStatus = UART_STATUS_RXBYTE;
		#endif

	}

	if (rxStatus == UART_STATUS_RXBYTE)
	{
		#if (MX_UART_CHANNEL_X == 0)

			retVal = 0;
			UART_Delay_CAL();

			for (idx = 0; idx < MX_UART_DBITS_X; idx++)
			{
				if (FC_CAL_Bit_In(MX_UART_RX_PORT_X, MX_UART_RX_PIN_X))
					retVal = retVal | (0x01 << idx);

				UART_Delay_CAL();
			}
		#endif

		#if (MX_UART_CHANNEL_X == 1)
			regcheck = ts_bit(rcsta, FERR);
			if (regcheck != 0)
			{
				dummy = rcreg;						//need to read the rcreg to clear FERR
				#if (MX_UART_RETURN_X == 1)
					retVal = 0x400;					//Framing Error Flag
				#endif
			}
			else
			{
				regcheck = ts_bit(rcsta, OERR);
				if (regcheck != 0)
				{
					cr_bit(rcsta, CREN);			//Reset receiver to clear error
					st_bit(rcsta, CREN);

					#if (MX_UART_RETURN_X == 1)
						retVal = 0x800;				//Overrun Error Flag
					#endif
				}
				else
				{
					retVal = 0;

					#if (MX_UART_DBITS_X == 9)
						if(ts_bit(rcsta, RX9D))
							retVal = 0x100;
					#endif

					retVal = retVal | rcreg; 			//no error, so rx byte is valid
				}
			}
		#endif

		#if (MX_UART_CHANNEL_X == 2)
			regcheck = ts_bit(MX_UART2_RCSTA, FERR);
			if (regcheck != 0)
			{
				dummy = MX_UART2_RCREG;			//need to read the rcreg to clear FERR
				#if (MX_UART_RETURN_X == 1)
					retVal = 0x400;					//Framing Error Flag
				#endif
			}
			else
			{
				regcheck = ts_bit(MX_UART2_RCSTA, OERR);
				if (regcheck != 0)
				{
					cr_bit(MX_UART2_RCSTA, CREN);	//Reset receiver to clear error
					st_bit(MX_UART2_RCSTA, CREN);
					#if (MX_UART_RETURN_X == 1)
						retVal = 0x800;				//Overrun Error Flag
					#endif
				}
				else
				{
					retVal = 0;

					#if (MX_UART_DBITS_X == 9)
						if(ts_bit(MX_UART2_RCSTA, RX9D))
							retVal = 0x100;
					#endif

					retVal = retVal | MX_UART2_RCREG; 			//no error, so rx byte is valid
				}
			}

		#endif

		#if (MX_UART_ECHO_X == 1)
			UART_Send(retVal);
		#endif
	}

	#if (MX_UART_FLOWEN_X == 1)
		FC_CAL_Bit_High(MX_UART_RTS_PORT_X, MX_UART_RTS_PIN_X);		//not ready to accept data
	#endif

	return (retVal);
}


CALFUNCTION(void, FC_CAL_UART_Delay_, (void))
{
  #if (MX_UART_CHANNEL_X == 0)

	MX_UINT16 delay = MX_SOFT_BAUD_X;

	while (delay > 255)
	{
		delay_us(255);
		delay = delay - 255;
		MX_CLEAR_WATCHDOG;
	}
	delay_us(delay);
	MX_CLEAR_WATCHDOG;

  #endif
}


CALFUNCTION(void, FC_CAL_UART_Update_Baud_, (MX_UINT8 new_baud))
{
	//Baud Rates - Function compatible with hardware mode only
	/*
	0 - 1200
	1 - 2400
	2 - 4800
	3 - 9600
	4 - 19200
	5 - 38400
	6 - 57600
	7 - 115200
	*/

	MX_UINT8 baudrate, baudmode;

	if (new_baud > 7)
		return;

	if (new_baud == 0)
	{
		baudrate = MX_HARD_BAUD_1200;
		baudmode = MX_HARD_SLOW_1200;
	}
	else if (new_baud == 1)
	{
		baudrate = MX_HARD_BAUD_2400;
		baudmode = MX_HARD_SLOW_2400;
	}
	else if (new_baud == 2)
	{
		baudrate = MX_HARD_BAUD_4800;
		baudmode = MX_HARD_SLOW_4800;
	}
	else if (new_baud == 3)
	{
		baudrate = MX_HARD_BAUD_9600;
		baudmode = MX_HARD_SLOW_9600;
	}
	else if (new_baud == 4)
	{
		baudrate = MX_HARD_BAUD_19200;
		baudmode = MX_HARD_SLOW_19200;
	}
	else if (new_baud == 5)
	{
		baudrate = MX_HARD_BAUD_38400;
		baudmode = MX_HARD_SLOW_38400;
	}
	else if (new_baud == 6)
	{
		baudrate = MX_HARD_BAUD_57600;
		baudmode = MX_HARD_SLOW_57600;
	}
	else if (new_baud == 7)
	{
		baudrate = MX_HARD_BAUD_115200;
		baudmode = MX_HARD_SLOW_115200;
	}

	UART_Uninit();

	#if (MX_UART_CHANNEL_X == 1)

	    if (baudmode == 1)
			cr_bit(txsta, BRGH);					//Low Speed
	    else
			st_bit(txsta, BRGH);					//High Speed

		spbrg = baudrate;   						// set the baud rate
		rcsta = 0;                    				// 8-bit, disabled

		#if(MX_UART_DBITS_X == 9)
			st_bit(txsta, TX9);   					// 9-bit TX
			st_bit(rcsta, RX9);                    	// 9-bit RX
		#endif

		st_bit(rcsta, SPEN);         				// turn on serial interface
		st_bit(txsta, TXEN);
		st_bit(rcsta, CREN);

		#if (MX_UART_INT_X == 1)
			MX_UART_INT_CH1_EN;
			st_bit(intcon, PEIE);
			st_bit(intcon, GIE);
		#else
			cr_bit (pie1, RCIE);
		#endif
	#endif

	#if (MX_UART_CHANNEL_X == 2)

	  	if (baudmode == 1)
			cr_bit(MX_UART2_TXSTA, BRGH);			//Low Speed
	  	else
			st_bit(MX_UART2_TXSTA, BRGH);			//High Speed

		spbrg2 = baudrate;   						// set the baud rate
		MX_UART2_RCSTA = 0;                    		// 8-bit, disabled

		#if(MX_UART_DBITS_X == 9)
			st_bit(MX_UART2_TXSTA, TX9);   			// 9-bit TX
			st_bit(MX_UART2_RCSTA, RX9);            // 9-bit RX
		#endif

		st_bit(MX_UART2_RCSTA, SPEN);         		// turn on serial interface
		st_bit(MX_UART2_TXSTA, TXEN);
		st_bit(MX_UART2_RCSTA, CREN);

		#if (MX_UART_INT_X == 1)
			MX_UART_INT_CH2_EN;
			st_bit(intcon, PEIE);
			st_bit(intcon, GIE);
		#else
			cr_bit (MX_UART2_PIE, RC2IE);
		#endif
	#endif

	#if (MX_UART_FLOWEN_X == 1)						//Flowcontrol enabled?
		FC_CAL_Bit_In_DDR (MX_UART_CTS_PORT_X, MX_UART_CTS_TRIS_X, MX_UART_CTS_PIN_X);	// CTS pin is a input
		FC_CAL_Bit_High_DDR (MX_UART_RTS_PORT_X, MX_UART_RTS_TRIS_X, MX_UART_RTS_PIN_X);	// RTS not ready to accept data
	#endif

}

////////////////////////////////////////
// Code with no source :-)
////////////////////////////////////////
0000  2E81  	GOTO	_startup

0004  00FF  	MOVWF Int1Context
0005  0E03  	SWAPF STATUS, W
0006  1283  	BCF STATUS, RP0
0007  1303  	BCF STATUS, RP1
0008  00DC  	MOVWF Int1BContext
0009  0E0A  	SWAPF PCLATH, W
000A  00DD  	MOVWF Int1BContext+D'1'
000B  0E04  	SWAPF FSR, W
000C  00DE  	MOVWF Int1BContext+D'2'
000D  118A  	BCF PCLATH,3
000E  120A  	BCF PCLATH,4
000F  2EB3  	GOTO	interrupt
0010        delay_ms_00000
0010        ; { delay_ms ; function begin
0010  08F9  	MOVF delay_ms_00000_arg_del, F
0011  1D03  	BTFSS STATUS,Z
0012  2814  	GOTO	label1
0013  0008  	RETURN
0014        label1
0014  30F9  	MOVLW 0xF9
0015        label2
0015  0000  	NOP
0016  0000  	NOP
0017  0000  	NOP
0018  0000  	NOP
0019  0000  	NOP
001A  0000  	NOP
001B  0000  	NOP
001C  0000  	NOP
001D  0000  	NOP
001E  0000  	NOP
001F  0000  	NOP
0020  0000  	NOP
0021  0000  	NOP
0022  0000  	NOP
0023  0000  	NOP
0024  0000  	NOP
0025  3EFF  	ADDLW 0xFF
0026  1D03  	BTFSS STATUS,Z
0027  2815  	GOTO	label2
0028  0000  	NOP
0029  0000  	NOP
002A  0000  	NOP
002B  0000  	NOP
002C  0000  	NOP
002D  0000  	NOP
002E  0000  	NOP
002F  0000  	NOP
0030  0000  	NOP
0031  0000  	NOP
0032  0000  	NOP
0033  0000  	NOP
0034  0000  	NOP
0035  0000  	NOP
0036  0000  	NOP
0037  0000  	NOP
0038  0000  	NOP
0039  0BF9  	DECFSZ delay_ms_00000_arg_del, F
003A  2814  	GOTO	label1
003B  0008  	RETURN
003C        ; } delay_ms function end

003C        delay_10us_00000
003C        ; { delay_10us ; function begin
003C  08B1  	MOVF delay_10us_00000_arg_del, F
003D  1D03  	BTFSS STATUS,Z
003E  2840  	GOTO	label3
003F  0008  	RETURN
0040        label3
0040  3009  	MOVLW 0x09
0041        label4
0041  0000  	NOP
0042  3EFF  	ADDLW 0xFF
0043  1D03  	BTFSS STATUS,Z
0044  2841  	GOTO	label4
0045  0000  	NOP
0046  0000  	NOP
0047  0BB1  	DECFSZ delay_10us_00000_arg_del, F
0048  2840  	GOTO	label3
0049  0008  	RETURN
004A        ; } delay_10us function end

004A        delay_us_00000
004A        ; { delay_us ; function begin
004A        label5
004A  0000  	NOP
004B  0000  	NOP
004C  0BF7  	DECFSZ delay_us_00000_arg_del, F
004D  284A  	GOTO	label5
004E  0008  	RETURN
004F        ; } delay_us function end

004F        delay_s_00000
004F        ; { delay_s ; function begin
004F        label6
004F  30FA  	MOVLW 0xFA
0050  00F9  	MOVWF delay_ms_00000_arg_del
0051  2010  	CALL delay_ms_00000
0052  30FA  	MOVLW 0xFA
0053  00F9  	MOVWF delay_ms_00000_arg_del
0054  2010  	CALL delay_ms_00000
0055  30FA  	MOVLW 0xFA
0056  00F9  	MOVWF delay_ms_00000_arg_del
0057  2010  	CALL delay_ms_00000
0058  30FA  	MOVLW 0xFA
0059  00F9  	MOVWF delay_ms_00000_arg_del
005A  2010  	CALL delay_ms_00000
005B  0BF2  	DECFSZ delay_s_00000_arg_del, F
005C  284F  	GOTO	label6
005D  0008  	RETURN
005E        ; } delay_s function end

005E        __div_16_1_00003
005E        ; { __div_16_16 ; function begin
005E  01A2  	CLRF __div_16_1_00003_1_r
005F  01A3  	CLRF __div_16_1_00003_1_r+D'1'
0060  01A5  	CLRF CompTempVarRet214
0061  01A6  	CLRF CompTempVarRet214+D'1'
0062  01A4  	CLRF __div_16_1_00003_1_i
0063        label7
0063  1A24  	BTFSC __div_16_1_00003_1_i,4
0064  0008  	RETURN
0065  1003  	BCF STATUS,C
0066  0DA5  	RLF CompTempVarRet214, F
0067  0DA6  	RLF CompTempVarRet214+D'1', F
0068  1283  	BCF STATUS, RP0
0069  0DFC  	RLF __div_16_1_00003_arg_a, F
006A  0DFD  	RLF __div_16_1_00003_arg_a+D'1', F
006B  1683  	BSF STATUS, RP0
006C  0DA2  	RLF __div_16_1_00003_1_r, F
006D  0DA3  	RLF __div_16_1_00003_1_r+D'1', F
006E  0821  	MOVF __div_16_1_00003_arg_b+D'1', W
006F  0223  	SUBWF __div_16_1_00003_1_r+D'1', W
0070  1D03  	BTFSS STATUS,Z
0071  2874  	GOTO	label8
0072  0820  	MOVF __div_16_1_00003_arg_b, W
0073  0222  	SUBWF __div_16_1_00003_1_r, W
0074        label8
0074  1C03  	BTFSS STATUS,C
0075  287D  	GOTO	label9
0076  0820  	MOVF __div_16_1_00003_arg_b, W
0077  02A2  	SUBWF __div_16_1_00003_1_r, F
0078  0821  	MOVF __div_16_1_00003_arg_b+D'1', W
0079  1C03  	BTFSS STATUS,C
007A  03A3  	DECF __div_16_1_00003_1_r+D'1', F
007B  02A3  	SUBWF __div_16_1_00003_1_r+D'1', F
007C  1425  	BSF CompTempVarRet214,0
007D        label9
007D  0AA4  	INCF __div_16_1_00003_1_i, F
007E  2863  	GOTO	label7
007F        ; } __div_16_16 function end


00F8        __mul_16u__0000C
00F8        ; { __mul_16u_16u__16 ; function begin
00F8  01A3  	CLRF __mul_16u__0000C_1_i
00F9  01A6  	CLRF CompTempVarRet455
00FA  01A7  	CLRF CompTempVarRet455+D'1'
00FB  1283  	BCF STATUS, RP0
00FC  087C  	MOVF __mul_16u__0000C_arg_a, W
00FD  1683  	BSF STATUS, RP0
00FE  00A4  	MOVWF __mul_16u__0000C_1_t
00FF  1283  	BCF STATUS, RP0
0100  087D  	MOVF __mul_16u__0000C_arg_a+D'1', W
0101  1683  	BSF STATUS, RP0
0102  00A5  	MOVWF __mul_16u__0000C_1_t+D'1'
0103        label21
0103  1A23  	BTFSC __mul_16u__0000C_1_i,4
0104  0008  	RETURN
0105  1C20  	BTFSS __mul_16u__0000C_arg_b,0
0106  290D  	GOTO	label22
0107  0824  	MOVF __mul_16u__0000C_1_t, W
0108  07A6  	ADDWF CompTempVarRet455, F
0109  0825  	MOVF __mul_16u__0000C_1_t+D'1', W
010A  1803  	BTFSC gbl_status,0
010B  0F25  	INCFSZ __mul_16u__0000C_1_t+D'1', W
010C  07A7  	ADDWF CompTempVarRet455+D'1', F
010D        label22
010D  1003  	BCF gbl_status,0
010E  0CA1  	RRF __mul_16u__0000C_arg_b+D'1', F
010F  0CA0  	RRF __mul_16u__0000C_arg_b, F
0110  1003  	BCF gbl_status,0
0111  0DA4  	RLF __mul_16u__0000C_1_t, F
0112  0DA5  	RLF __mul_16u__0000C_1_t+D'1', F
0113  0AA3  	INCF __mul_16u__0000C_1_i, F
0114  2903  	GOTO	label21
0115        ; } __mul_16u_16u__16 function end


0304        __mul_8u_8_00006
0304        ; { __mul_8u_8u ; function begin
0304  01F4  	CLRF __mul_8u_8_00006_1_i
0305  01F7  	CLRF CompTempVarRet452
0306  01F8  	CLRF CompTempVarRet452+D'1'
0307  0872  	MOVF __mul_8u_8_00006_arg_a, W
0308  00F5  	MOVWF __mul_8u_8_00006_1_t
0309  01F6  	CLRF __mul_8u_8_00006_1_t+D'1'
030A        label59
030A  19F4  	BTFSC __mul_8u_8_00006_1_i,3
030B  0008  	RETURN
030C  1C73  	BTFSS __mul_8u_8_00006_arg_b,0
030D  2B14  	GOTO	label60
030E  0875  	MOVF __mul_8u_8_00006_1_t, W
030F  07F7  	ADDWF CompTempVarRet452, F
0310  1803  	BTFSC gbl_status,0
0311  0AF8  	INCF CompTempVarRet452+D'1', F
0312  0876  	MOVF __mul_8u_8_00006_1_t+D'1', W
0313  07F8  	ADDWF CompTempVarRet452+D'1', F
0314        label60
0314  0CF3  	RRF __mul_8u_8_00006_arg_b, F
0315  1003  	BCF gbl_status,0
0316  0DF5  	RLF __mul_8u_8_00006_1_t, F
0317  0DF6  	RLF __mul_8u_8_00006_1_t+D'1', F
0318  0AF4  	INCF __mul_8u_8_00006_1_i, F
0319  2B0A  	GOTO	label59
031A        ; } __mul_8u_8u function end


0681        _startup
0681  30D5  	MOVLW 0xD5
0682  1283  	BCF STATUS, RP0
0683  1303  	BCF STATUS, RP1
0684  00C8  	MOVWF gbl_14_LSR
0685  30C4  	MOVLW 0xC4
0686  00C9  	MOVWF gbl_14_LSR+D'1'
0687  30BB  	MOVLW 0xBB
0688  00CA  	MOVWF gbl_14_LSR+D'2'
0689  30DC  	MOVLW 0xDC
068A  00CB  	MOVWF gbl_14_LSR+D'3'
068B  01CC  	CLRF gbl_15_gbl_aSig
068C  01CD  	CLRF gbl_15_gbl_aSig+D'1'
068D  01CE  	CLRF gbl_15_gbl_aSig+D'2'
068E  01CF  	CLRF gbl_15_gbl_aSig+D'3'
068F  01D0  	CLRF gbl_15_gbl_bSig
0690  01D1  	CLRF gbl_15_gbl_bSig+D'1'
0691  01D2  	CLRF gbl_15_gbl_bSig+D'2'
0692  01D3  	CLRF gbl_15_gbl_bSig+D'3'
0693  01D4  	CLRF gbl_15_gbl_zSig
0694  01D5  	CLRF gbl_15_gbl_zSig+D'1'
0695  01D6  	CLRF gbl_15_gbl_zSig+D'2'
0696  01D7  	CLRF gbl_15_gbl_zSig+D'3'
0697  01E6  	CLRF gbl_15_gbl_aExp
0698  01E7  	CLRF gbl_15_gbl_bExp
0699  01DF  	CLRF gbl_15_gbl_zExp
069A  01E0  	CLRF gbl_15_gbl_zExp+D'1'
069B  01E8  	CLRF gbl_15_gbl_aSign
069C  01E9  	CLRF gbl_15_gbl_bSign
069D  01EA  	CLRF gbl_15_gbl_zSign
069E  01EB  	CLRF gbl_15_gbl_zSigZero
069F  01D8  	CLRF gbl_15_gbl_ret
06A0  01D9  	CLRF gbl_15_gbl_ret+D'1'
06A1  01DA  	CLRF gbl_15_gbl_ret+D'2'
06A2  01DB  	CLRF gbl_15_gbl_ret+D'3'
06A3  01E4  	CLRF gbl_float_rounding_mode
06A4  01E5  	CLRF gbl_float_exception_flags
06A5  01E3  	CLRF gbl_float_detect_tininess

06B0  118A  	BCF PCLATH,3
06B1  120A  	BCF PCLATH,4
06B2  2D4F  	GOTO	main

2007  3F32  	DW 0x3F32
