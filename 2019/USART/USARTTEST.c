//************************************************************************************
//**  
//**  File name:     C:\Users\gerpe\OneDrive\GER-PER 2016\Documents\KennyNeutron\USART\USARTTEST.c
//**  Generated by:  Flowcode v4.2.3.58
//**  Date:          Saturday, July 27, 2019 15:04:23
//**  Licence:       Professional
//**  Registered to: 20ACM8
//**  
//**  
//**  http://www.matrixmultimedia.com
//************************************************************************************


#define MX_PIC

//Defines for microcontroller
#define P16F690
#define MX_EE
#define MX_EE_SIZE 256
#define MX_SPI
#define MX_SPI_BCB
#define MX_SPI_SDI 4
#define MX_SPI_SDO 7
#define MX_SPI_SCK 6
#define MX_UART
#define MX_UART_B
#define MX_UART_TX 7
#define MX_UART_RX 5
#define MX_I2C
#define MX_MI2C
#define MX_I2C_B
#define MX_I2C_SDA 4
#define MX_I2C_SCL 6
#define MX_PWM
#define MX_PWM_CNT 1
#define MX_PWM_TRIS1 trisc
#define MX_PWM_1 5

//Functions
#define MX_CLK_SPEED 20000000
#ifdef _BOOSTC
#include <system.h>
#endif
#ifdef HI_TECH_C
#include <pic.h>
#endif

//Configuration data
#ifdef _BOOSTC
#pragma DATA 0x2007, 0x30f2
#endif
#ifdef HI_TECH_C
__CONFIG(0x30f2);
#endif

//Internal functions
#include "C:\Program Files (x86)\Matrix Multimedia\Flowcode V4\FCD\internals.h"

//Macro function declarations


//Variable declarations
#define FCSZ_DAT 26
char FCV_DAT[FCSZ_DAT];
char FCV_DATBYTE;


//Defines:

/**** Macro Substitutions ****
portc = D1 Port
trisc = D1 Data Direction
portc = D2 Port
trisc = D2 Data Direction
portc = D3 Port
trisc = D3 Data Direction
portc = D4 Port
trisc = D4 Data Direction
portc = RS Port
trisc = RS Data Direction
portc = E Port
trisc = E Data Direction
5 = Data 1_Pin
3 = Data 2 Pin
4 = Data 3 Pin
2 = Data 4 Pin
0 = RS Pin
1 = Enable Pin
LCD_66844 = Unique Component Reference Number
4 = Row Count
16 = Column Count
******************************/

	//component connections
	#define LCD_66844_PORT0    portc
	#define LCD_66844_TRIS0    trisc
	#define LCD_66844_PORT1    portc
	#define LCD_66844_TRIS1    trisc
	#define LCD_66844_PORT2    portc
	#define LCD_66844_TRIS2    trisc
	#define LCD_66844_PORT3    portc
	#define LCD_66844_TRIS3    trisc
	#define LCD_66844_PORT4    portc
	#define LCD_66844_TRIS4    trisc
	#define LCD_66844_PORT5    portc
	#define LCD_66844_TRIS5    trisc
	#define LCD_66844_BIT0    	5
	#define LCD_66844_BIT1    	3
	#define LCD_66844_BIT2    	4
	#define LCD_66844_BIT3    	2
	#define LCD_66844_RS      	0
	#define LCD_66844_E       	1
	#define LCD_66844_ROWCNT	4
	#define LCD_66844_COLCNT	16

	#ifdef _BOOSTC
	  #define LCD_66844_DELAY   delay_10us(10)
	#endif
	#ifdef _C2C_
	  #define LCD_66844_DELAY   delay_us(100)
	#endif
	#ifdef HI_TECH_C
	  #define LCD_66844_DELAY   __delay_us(120)
	#endif
	#ifndef LCD_66844_DELAY
	  #define LCD_66844_DELAY   delay_us(100)
	#endif




//LCDDisplay0: //Macro function declarations

void FCD_LCDDisplay0_RawSend(char in, char mask);
void FCD_LCDDisplay0_Start();
void FCD_LCDDisplay0_Clear();
void FCD_LCDDisplay0_PrintASCII(char Character);
void FCD_LCDDisplay0_Command(char in);
void FCD_LCDDisplay0_Cursor(char x, char y);
void FCD_LCDDisplay0_PrintNumber(short Number);
void FCD_LCDDisplay0_PrintString(char* String, char MSZ_String);
void FCD_LCDDisplay0_ScrollDisplay(char Direction, char Num_Positions);
void FCD_LCDDisplay0_ClearLine(char Line);
void FCD_LCDDisplay0_RAM_Write(char nIdx, char d0, char d1, char d2, char d3, char d4, char d5, char d6, char d7);
//Defines:

/**** Macro Substitutions ****
portc = RTS Port
trisc = RTS Data Direction
portc = CTS Port
trisc = CTS Data Direction
0 = RTS Pin
4 = CTS Pin
1 = UART Selection		(0-SW / 1-UART1 / 2-UART2)
0 = Flow Control		(0-Off / 1-On)
0 = Debug Enable		(0-Off / 1-On)
0 = Echo Enable		(0-Off / 1-On)
4 = UART TXSTA Value
129 = UART SPBRG Value
RS232_66846 = Unique ID
Unused = Bitbanged Receive Port Register
Unused = Bitbanged Receive Data Direction Register
Unused = Bitbanged Receive Pin
Unused = Bitbanged Transmit Pin
38 = Bitbanged BAUD Rate Delay
0 = Timout	Selection	(0-Legacy / 1-MS Timeout)
0 = Data Size			(0-8 bits / 1-9 bits / 2-7 bits & Only available on BitBanged components)
0 = Parity Enable		(0-No Parity / 1-Odd Parity / 2-Even Parity)
0 = Legacy Return		(0-Legacy mode return 255 / 1-New mode return MSB err flags)
Unused = Bitbanged Transmit Port Register
Unused = Bitbanged Transmit Data Direction Register
******************************/

#define RS232_66846_RTS_PORT			portc
#define RS232_66846_RTS_TRIS			trisc
#define RS232_66846_CTS_PORT			portc
#define RS232_66846_CTS_TRIS			trisc
#define RS232_66846_RTS_PIN			0
#define RS232_66846_CTS_PIN			4
#define RS232_66846_UART				1
#define RS232_66846_TOUT  			0
#define RS232_66846_DATASIZE			0
#define RS232_66846_PARITY			0
#define RS232_66846_LEGACY_RV			0

#if (0 == 1)
  	#define RS232_66846_HARDWARE
#endif

#if (0 == 1)
  	#define RS232_66846_DEBUG
#endif

#if (0 == 1)
  	#define RS232_66846_ECHO
#endif

#if (RS232_66846_UART == 0)
	#define RS232_66846_RX_PORT		Unused
	#define RS232_66846_RX_TRIS		Unused
	#define RS232_66846_SW_RX		Unused
	#define RS232_66846_SW_TX		Unused
	#define RS232_66846_SW_BAUD		38
	#define RS232_66846_TX_PORT		Unused
	#define RS232_66846_TX_TRIS		Unused
#else
	#define RS232_66846_TXSTA_VAL  	4
	#define RS232_66846_SPBRG_VAL  	129
	#define RS232_66846_SW_BAUD		0
#endif

#if (RS232_66846_LEGACY_RV == 0)
	#if (RS232_66846_DATASIZE == 1)
		#pragma error "RS232 Component cannot combine 9-bit data mode with legacy return value of 255 please check the Component properties"
	#endif
#endif

#define RS232_66846_STATUS_LOOP		0
#define RS232_66846_STATUS_TIMEOUT	1
#define RS232_66846_STATUS_RXBYTE	2





//RS2320: //Macro function declarations

void FCD_RS2320_SendRS232Char(short nChar);
void FCD_RS2320_SendRS232String(char* String, char MSZ_String);
short FCD_RS2320_ReceiveRS232Char(short nTimeout);
void FCD_RS2320_ReceiveRS232String(char* FCR_RETVAL, char FCR_RETVAL_SIZE, char nTimeout, char NumBytes);
void FCD_RS2320_RS232_Delay(char mode);



//LCDDisplay0: //Macro implementations


void FCD_LCDDisplay0_RawSend(char in, char mask)
{
		unsigned char pt;

		clear_bit(LCD_66844_PORT0, LCD_66844_BIT0);
		clear_bit(LCD_66844_PORT1, LCD_66844_BIT1);
		clear_bit(LCD_66844_PORT2, LCD_66844_BIT2);
		clear_bit(LCD_66844_PORT3, LCD_66844_BIT3);
		clear_bit(LCD_66844_PORT4, LCD_66844_RS);
		clear_bit(LCD_66844_PORT5, LCD_66844_E);
		pt = ((in >> 4) & 0x0f);
		if (pt & 0x01)
		    set_bit(LCD_66844_PORT0, LCD_66844_BIT0);
		if (pt & 0x02)
		    set_bit(LCD_66844_PORT1, LCD_66844_BIT1);
		if (pt & 0x04)
		    set_bit(LCD_66844_PORT2, LCD_66844_BIT2);
		if (pt & 0x08)
		    set_bit(LCD_66844_PORT3, LCD_66844_BIT3);
		if (mask)
		    set_bit(LCD_66844_PORT4, LCD_66844_RS);
		LCD_66844_DELAY;
		set_bit (LCD_66844_PORT5, LCD_66844_E);
		LCD_66844_DELAY;
		clear_bit (LCD_66844_PORT5, LCD_66844_E);
		pt = (in & 0x0f);
		LCD_66844_DELAY;
		clear_bit(LCD_66844_PORT0, LCD_66844_BIT0);
		clear_bit(LCD_66844_PORT1, LCD_66844_BIT1);
		clear_bit(LCD_66844_PORT2, LCD_66844_BIT2);
		clear_bit(LCD_66844_PORT3, LCD_66844_BIT3);
		clear_bit(LCD_66844_PORT4, LCD_66844_RS);
		clear_bit(LCD_66844_PORT5, LCD_66844_E);
		if (pt & 0x01)
		    set_bit(LCD_66844_PORT0, LCD_66844_BIT0);
		if (pt & 0x02)
		    set_bit(LCD_66844_PORT1, LCD_66844_BIT1);
		if (pt & 0x04)
		    set_bit(LCD_66844_PORT2, LCD_66844_BIT2);
		if (pt & 0x08)
		    set_bit(LCD_66844_PORT3, LCD_66844_BIT3);
		if (mask)
		    set_bit(LCD_66844_PORT4, LCD_66844_RS);
		LCD_66844_DELAY;
		set_bit (LCD_66844_PORT5, LCD_66844_E);
		LCD_66844_DELAY;
		clear_bit (LCD_66844_PORT5, LCD_66844_E);
		LCD_66844_DELAY;
}

void FCD_LCDDisplay0_Start()
{
	
		clear_bit(LCD_66844_TRIS0, LCD_66844_BIT0);
		clear_bit(LCD_66844_TRIS1, LCD_66844_BIT1);
		clear_bit(LCD_66844_TRIS2, LCD_66844_BIT2);
		clear_bit(LCD_66844_TRIS3, LCD_66844_BIT3);
		clear_bit(LCD_66844_TRIS4, LCD_66844_RS);
		clear_bit(LCD_66844_TRIS5, LCD_66844_E);

		Wdt_Delay_Ms(12);

		FCD_LCDDisplay0_RawSend(0x33, 0);
		Wdt_Delay_Ms(2);
		FCD_LCDDisplay0_RawSend(0x33, 0);
		Wdt_Delay_Ms(2);
		FCD_LCDDisplay0_RawSend(0x32, 0);
		Wdt_Delay_Ms(2);
		FCD_LCDDisplay0_RawSend(0x2c, 0);
		Wdt_Delay_Ms(2);
		FCD_LCDDisplay0_RawSend(0x06, 0);
		Wdt_Delay_Ms(2);
		FCD_LCDDisplay0_RawSend(0x0c, 0);
		Wdt_Delay_Ms(2);

		//clear the display
		FCD_LCDDisplay0_RawSend(0x01, 0);
		Wdt_Delay_Ms(2);
		FCD_LCDDisplay0_RawSend(0x02, 0);
		Wdt_Delay_Ms(2);

}

void FCD_LCDDisplay0_Clear()
{
	
		FCD_LCDDisplay0_RawSend(0x01, 0);
		Wdt_Delay_Ms(2);
		FCD_LCDDisplay0_RawSend(0x02, 0);
		Wdt_Delay_Ms(2);

}

void FCD_LCDDisplay0_PrintASCII(char Character)
{
	
		FCD_LCDDisplay0_RawSend(Character, 0x10);

}

void FCD_LCDDisplay0_Command(char in)
{
	
		FCD_LCDDisplay0_RawSend(in, 0);
		Wdt_Delay_Ms(2);

}

void FCD_LCDDisplay0_Cursor(char x, char y)
{
	
	  #if (LCD_66844_ROWCNT == 1)
	    y=0x80;
	  #endif

	  #if (LCD_66844_ROWCNT == 2)
		if (y==0)
			y=0x80;
		else
			y=0xc0;
	  #endif

	  #if (LCD_66844_ROWCNT == 4)
		if (y==0)
			y=0x80;
		else if (y==1)
			y=0xc0;

		#if (LCD_66844_COLCNT == 16)
			else if (y==2)
				y=0x90;
			else
				y=0xd0;
		#endif

		#if (LCD_66844_COLCNT == 20)
			else if (y==2)
				y=0x94;
			else
				y=0xd4;
		#endif
	  #endif

		FCD_LCDDisplay0_RawSend(y+x, 0);
		Wdt_Delay_Ms(2);

}

void FCD_LCDDisplay0_PrintNumber(short Number)
{
	
		short tmp_int;
		char tmp_byte;
		if (Number < 0)
		{
			FCD_LCDDisplay0_RawSend('-', 0x10);
			Number = 0 - Number;
		}

		tmp_int = Number;
		if (Number >= 10000)
		{
			tmp_byte = tmp_int / 10000;
			FCD_LCDDisplay0_RawSend('0' + tmp_byte, 0x10);

			while (tmp_byte > 0)
			{
				tmp_int = tmp_int - 10000;
				tmp_byte--;
			}
		}
		if (Number >= 1000)
		{
			tmp_byte = tmp_int / 1000;
			FCD_LCDDisplay0_RawSend('0' + tmp_byte, 0x10);

			while (tmp_byte > 0)
			{
				tmp_int = tmp_int - 1000;
				tmp_byte--;
			}
		}
		if (Number >= 100)
		{
			tmp_byte = tmp_int / 100;
			FCD_LCDDisplay0_RawSend('0' + tmp_byte, 0x10);

			while (tmp_byte > 0)
			{
				tmp_int = tmp_int - 100;
				tmp_byte--;
			}
		}
		if (Number >= 10)
		{
			tmp_byte = tmp_int / 10;
			FCD_LCDDisplay0_RawSend('0' + tmp_byte, 0x10);

			while (tmp_byte > 0)
			{
				tmp_int = tmp_int - 10;
				tmp_byte--;
			}
		}
		FCD_LCDDisplay0_RawSend('0' + tmp_int, 0x10);

}

void FCD_LCDDisplay0_PrintString(char* String, char MSZ_String)
{
	
		char idx = 0;

		for (idx=0; idx<MSZ_String; idx++)
		{
			#ifdef _BOOSTC
				if (String[idx] == 0)
				{
					break;
				}
				FCD_LCDDisplay0_RawSend(String[idx], 0x10);
			#endif

			#ifdef HI_TECH_C
				if (*String == 0)
				{
					break;
				}
				FCD_LCDDisplay0_RawSend(*String, 0x10);
				String++;
			#endif
		}

}

void FCD_LCDDisplay0_ScrollDisplay(char Direction, char Num_Positions)
{
	
		char cmd = 0;
		char count;

		//Choose the direction
		switch (Direction)
		{
			case 0:
			case 'l':
			case 'L':

				cmd = 0x18;
				break;

			case 1:
			case 'r':
			case 'R':

				cmd = 0x1C;
				break;

			default:
				break;
		}

		//If direction accepted then scroll the specified amount
		if (cmd)
		{
			for (count = 0; count < Num_Positions; count++)
				FCD_LCDDisplay0_Command(cmd);
		}

}

void FCD_LCDDisplay0_ClearLine(char Line)
{
	
		char count;
		char rowcount;

		//Define number of columns per line
		#if (LCD_66844_ROWCNT == 1)
			rowcount=80;
		#endif

		#if (LCD_66844_ROWCNT == 2)
			rowcount=40;
		#endif

		#if (LCD_66844_ROWCNT == 4)
			#if (LCD_66844_COLCNT == 16)
				rowcount=16;
			#endif
			#if (LCD_66844_COLCNT == 20)
				rowcount=20;
			#endif
		#endif

		//Start at beginning of the line
		FCD_LCDDisplay0_Cursor (0, Line);

		//Send out spaces to clear line
		for (count = 0; count < rowcount; count++)
			FCD_LCDDisplay0_RawSend(' ', 0x10);

		//Move back to the beginning of the line.
		FCD_LCDDisplay0_Cursor (0, Line);

}

void FCD_LCDDisplay0_RAM_Write(char nIdx, char d0, char d1, char d2, char d3, char d4, char d5, char d6, char d7)
{
	   //set CGRAM address
	   FCD_LCDDisplay0_RawSend(64 + (nIdx << 3), 0);
	   delay_ms(2);

	   //write CGRAM data
	   FCD_LCDDisplay0_RawSend(d0, 0x10);
	   FCD_LCDDisplay0_RawSend(d1, 0x10);
	   FCD_LCDDisplay0_RawSend(d2, 0x10);
	   FCD_LCDDisplay0_RawSend(d3, 0x10);
	   FCD_LCDDisplay0_RawSend(d4, 0x10);
	   FCD_LCDDisplay0_RawSend(d5, 0x10);
	   FCD_LCDDisplay0_RawSend(d6, 0x10);
	   FCD_LCDDisplay0_RawSend(d7, 0x10);

	   //Clear the display
	   FCD_LCDDisplay0_RawSend(0x01, 0);
	   delay_ms(2);
	   FCD_LCDDisplay0_RawSend(0x02, 0);
	   delay_ms(2);
}



//RS2320: //Macro implementations


void FCD_RS2320_SendRS232Char(short nChar)
{
	
	#if (RS232_66846_UART == 0)

		char dMask;
		char idx;
		char count = 8;

		#ifdef RS232_66846_HARDWARE
			//wait until CTS is low
			while (( RS232_66846_CTS_PORT & (1 << RS232_66846_CTS_PIN) ) != 0);
		#endif

		#if(RS232_66846_DATASIZE == 1)
			count = 9;
		#endif
		#if(RS232_66846_DATASIZE == 2)
			count = 7;
		#endif

		clear_bit( RS232_66846_TX_PORT, RS232_66846_SW_TX);		// Send Start bit
		FCD_RS2320_RS232_Delay(0);

		for (idx = 0; idx < count; idx++)
		{
			dMask = nChar & 0x01;							// Mask off data bit

			if (dMask)
				set_bit( RS232_66846_TX_PORT, RS232_66846_SW_TX);
			else
				clear_bit( RS232_66846_TX_PORT, RS232_66846_SW_TX);

			FCD_RS2320_RS232_Delay(0);
			nChar = nChar >> 1;								// Move to next data bit
		}

		set_bit( RS232_66846_TX_PORT, RS232_66846_SW_TX);			// Send Stop bit
		FCD_RS2320_RS232_Delay(0);

	#endif

	#if (RS232_66846_UART == 1)

		#ifndef MX_UART
			#pragma error "Chip does not have UART capability"
		#endif

		st_bit(txsta, TXEN);
		while (ts_bit(pir1, TXIF) == 0);

		#ifdef RS232_66846_HARDWARE
			//wait until CTS is low
			while (( RS232_66846_CTS_PORT & (1 << RS232_66846_CTS_PIN) ) != 0);
		#endif

		#if(RS232_66846_DATASIZE == 1)
			if (test_bit(nChar, 8))
				st_bit(txsta, TX9D);
			else
				cr_bit(txsta, TX9D);
		#endif

		txreg = nChar;

	#endif

	#if (RS232_66846_UART == 2)

		#ifndef MX_UART2
			#pragma error "Chip does not have second UART capability"
		#endif

		st_bit(txsta2, TXEN);
		while (ts_bit(pir3, TX2IF) == 0);

		#ifdef RS232_66846_HARDWARE
			//wait until CTS is low
			while (( RS232_66846_CTS_PORT & (1 << RS232_66846_CTS_PIN) ) != 0);
		#endif

		#if( RS232_66846_DATASIZE == 1)
			if (test_bit(nChar, 8))
				st_bit(txsta2, TX9D);
			else
				cr_bit(txsta2, TX9D);
		#endif

		txreg2 = nChar;

	#endif

}

void FCD_RS2320_SendRS232String(char* String, char MSZ_String)
{
		char idx;
		for(idx = 0; idx < MSZ_String; idx++)
		{
			#ifdef _BOOSTC
				if (String[idx] == 0)
					break;
				else FCD_RS2320_SendRS232Char(String[idx]);
			#endif
			#ifdef HI_TECH_
				if (*String == 0)
					break;
				else FCD_RS2320_SendRS232Char(*String);
				String++;
			#endif
		}
}

short FCD_RS2320_ReceiveRS232Char(short nTimeout)
{
	
		char delay1 = 0;
		char delay2 = 0;
		char regcheck = 0;
		char dummy = 0;
		short retVal = 512;
		char bWaitForever = 0;
		char rxStatus = RS232_66846_STATUS_LOOP;
		char idx;
		char count = 8;

		#if ( RS232_66846_LEGACY_RV == 0)
			retVal = 255;
		#endif

		#if ( RS232_66846_UART == 1)
			#ifndef MX_UART
				#pragma error "Chip does not have UART capability"
			#endif
		#endif

		#if ( RS232_66846_UART == 2)
			#ifndef MX_UART2
				#pragma error "Chip does not have second UART capability"
			#endif
		#endif

		#ifdef RS232_66846_HARDWARE
			//ready to accept data
			clear_bit( RS232_66846_RTS_PORT, RS232_66846_RTS_PIN);
		#endif

		if (nTimeout == 255)
			bWaitForever = 1;

		#if ( RS232_66846_UART == 1)
			st_bit(rcsta, CREN);
		#endif

		#if ( RS232_66846_UART == 2)
			st_bit(rcsta2, CREN);
		#endif

		while (rxStatus == RS232_66846_STATUS_LOOP)
		{
			if (bWaitForever == 0)
			{
				//don't wait forever, so do timeout thing...
				if (nTimeout == 0)
				{
					rxStatus = RS232_66846_STATUS_TIMEOUT;
				}
				else
				{
					if ( RS232_66846_TOUT)
					{
						delay_us(10);
						delay1 = delay1 + 1;
						if(delay1 == 100)
						{
							nTimeout = nTimeout - 1;
							delay1 = 0;
						}
					}
					else
					{
						//decrement timeout
						delay1 = delay1 - 1;
						if (delay1 == 0)
						{
							nTimeout = nTimeout - 1;
						}
					}
				}
			}

			#if ( RS232_66846_UART == 0)
				regcheck = test_bit(RS232_66846_RX_PORT, RS232_66846_SW_RX);	//Test for start bit
				if (regcheck == 0)
					rxStatus = RS232_66846_STATUS_RXBYTE;
			#endif

			#if ( RS232_66846_UART == 1)
				regcheck = ts_bit(pir1, RCIF);
				if (regcheck != 0)
					rxStatus = RS232_66846_STATUS_RXBYTE;
			#endif

			#if ( RS232_66846_UART == 2)
				regcheck = ts_bit(pir3, RC2IF);
				if (regcheck != 0)
					rxStatus = RS232_66846_STATUS_RXBYTE;
			#endif
		}

		if (rxStatus == RS232_66846_STATUS_RXBYTE)
		{
			#if ( RS232_66846_UART > 0)

				#if ( RS232_66846_UART == 1)
					regcheck = ts_bit(rcsta, FERR);
				#endif

				#if ( RS232_66846_UART == 2)
					regcheck = ts_bit(rcsta2, FERR);
				#endif

				if (regcheck != 0)
				{
					#if ( RS232_66846_UART == 1)
						dummy = rcreg;      //need to read the rcreg to clear FERR
					#endif

					#if ( RS232_66846_UART == 2)
						dummy = rcreg2;      //need to read the rcreg to clear FERR
					#endif

					#ifdef RS232_66846_DEBUG
						FCD_RS2320_SendRS232Char('<');
						FCD_RS2320_SendRS232Char('F');
						FCD_RS2320_SendRS232Char('E');
						FCD_RS2320_SendRS232Char('R');
						FCD_RS2320_SendRS232Char('R');
						FCD_RS2320_SendRS232Char('>');
					#endif

					#if ( RS232_66846_LEGACY_RV == 1)
						retVal = 0x400;					//Framing Error Flag
					#endif
				}
				else
				{
					#if ( RS232_66846_UART == 1)
						regcheck = ts_bit(rcsta, OERR);
					#endif

					#if ( RS232_66846_UART == 2)
						regcheck = ts_bit(rcsta2, OERR);
					#endif

					if (regcheck != 0)
					{
						//need to read the rcreg to clear error
						#if ( RS232_66846_UART == 1)
							cr_bit(rcsta, CREN);
							st_bit(rcsta, CREN);
						#endif

						#if ( RS232_66846_UART == 2)
							cr_bit(rcsta2, CREN);
							st_bit(rcsta2, CREN);
						#endif

						#ifdef RS232_66846_DEBUG
							FCD_RS2320_SendRS232Char('<');
							FCD_RS2320_SendRS232Char('O');
							FCD_RS2320_SendRS232Char('E');
							FCD_RS2320_SendRS232Char('R');
							FCD_RS2320_SendRS232Char('R');
							FCD_RS2320_SendRS232Char('>');
						#endif

						#if ( RS232_66846_LEGACY_RV == 1)
							retVal = 0x800;					//Overrun Error Flag
						#endif

					}
					else
					{
						#if ( RS232_66846_UART == 1)
							retVal = rcreg; 			//no error, so rx byte is valid

							#if( RS232_66846_DATASIZE == 1)
								if(ts_bit(rcsta, RX9D));
									retVal = retVal | 0x100;
							#endif

						#endif

						#if ( RS232_66846_UART == 2)
							retVal = rcreg2; 			//no error, so rx byte is valid

							#if( RS232_66846_DATASIZE == 1)
								if(ts_bit(rcsta2, RX9D));
									retVal = retVal | 0x100;
							#endif

						#endif

						#ifdef RS232_66846_ECHO
							FCD_RS2320_SendRS232Char(retVal);
						#endif
					}
				}
			#else
				#if( RS232_66846_DATASIZE == 1)
					count = 9;
				#endif

				FCD_RS2320_RS232_Delay(1);
				for (idx = 0; idx < count; idx++)
				{
					retVal = retVal >> 1;

					if(count == 9)
					{
						if (test_bit( RS232_66846_RX_PORT, RS232_66846_SW_RX))
							retVal = retVal | 0x100;
					}
					else
					{
						if (test_bit( RS232_66846_RX_PORT, RS232_66846_SW_RX))
							retVal = retVal | 0x80;
					}
					FCD_RS2320_RS232_Delay(1);
				}

				#ifdef RS232_66846_ECHO
					FCD_RS2320_SendRS232Char(retVal);
				#endif

			#endif
		}
		#ifdef RS232_66846_HARDWARE
			//not ready to accept data
			set_bit( RS232_66846_RTS_PORT, RS232_66846_RTS_PIN);
		#endif

		return (retVal);
}

void FCD_RS2320_ReceiveRS232String(char* FCR_RETVAL, char FCR_RETVAL_SIZE, char nTimeout, char NumBytes)
{
		char idx;
		short in;

		#if ( RS232_66846_LEGACY_RV == 0 )
			#define RS232_TO 	255
		#else
			#define RS232_TO 	256
		#endif

		if (NumBytes > FCR_RETVAL_SIZE)
			NumBytes = FCR_RETVAL_SIZE;

		for (idx = 0; idx < NumBytes; idx++)
		{
			in = FCD_RS2320_ReceiveRS232Char(nTimeout);
			if(in < RS232_TO)
				FCR_RETVAL[idx] = in & 0xFF;
			else
				break;
		}

		if (idx < FCR_RETVAL_SIZE)
			FCR_RETVAL[idx] = 0;

		#undef RS232_TO
}

void FCD_RS2320_RS232_Delay(char mode)
{
		unsigned int iterations;
		unsigned int delay = RS232_66846_SW_BAUD;

		if (mode)
			delay = delay + 1;

		for (iterations = 0; iterations < delay; iterations++);
}

//Macro implementations

void main()
{
	
	//Initialisation
	ansel = 0;
anselh = 0;

	
	#if (RS232_66846_UART == 0)
		set_bit(RS232_66846_RX_TRIS, RS232_66846_SW_RX);		// Receive pin is a input
		clear_bit(RS232_66846_TX_TRIS, RS232_66846_SW_TX);	// Transmit pin is a output
		set_bit(RS232_66846_TX_PORT, RS232_66846_SW_TX);		// Transmit pin is default high
	#endif

	#if (RS232_66846_UART == 1)
		txsta = RS232_66846_TXSTA_VAL;   					// 8-bit, async, low speed, off
		spbrg = RS232_66846_SPBRG_VAL;   					// set the baud rate
		rcsta = 0;                    				// 8-bit, disabled

		if(RS232_66846_DATASIZE == 1)
		{
			st_bit(txsta, TX9);   						// 9-bit TX
			st_bit(rcsta, RX9);                    	// 9-bit RX
		}

		st_bit(rcsta, SPEN);         					// turn on serial interface
	#endif

	#if (RS232_66846_UART == 2)

		txsta2 = RS232_66846_TXSTA_VAL;   					// 8-bit, async, low speed, off
		spbrg2 = RS232_66846_SPBRG_VAL;   					// set the baud rate
		rcsta2 = 0;                    					// 8-bit, disabled

		if(RS232_66846_DATASIZE == 1)
		{
			st_bit(txsta2, TX9);   					// 9-bit TX
			st_bit(rcsta2, RX9);                    	// 9-bit RX
		}

		st_bit(rcsta2, SPEN);         					// turn on serial interface
	#endif

	#ifdef RS232_66846_HARDWARE
		set_bit( RS232_66846_CTS_TRIS, RS232_66846_CTS_PIN);	//CTS is an input
		clear_bit( RS232_66846_RTS_TRIS, RS232_66846_RTS_PIN);	//RTS is an output
		set_bit( RS232_66846_RTS_PORT, RS232_66846_RTS_PIN); 	//not ready to accept data
	#endif


	//Interrupt initialisation code
	option_reg = 0xC0;


	//Call Component Macro
	//Call Component Macro: LCDDisplay(0)::Start
	FCD_LCDDisplay0_Start();


	//Call Component Macro
	//Call Component Macro: LCDDisplay(0)::Clear
	FCD_LCDDisplay0_Clear();


	//Loop
	//Loop: While 1
	while (1)
	{
		//Call Component Macro
		//Call Component Macro: LCDDisplay(0)::Cursor(1, 0)
		FCD_LCDDisplay0_Cursor(1, 0);


		//Call Component Macro
		//Call Component Macro: LCDDisplay(0)::PrintString("SERIAL MONITOR")
		FCD_LCDDisplay0_PrintString("SERIAL MONITOR",14);


		//Call Component Macro
		//Call Component Macro: datbyte=RS232(0)::ReceiveRS232Char(10)
		FCV_DATBYTE = FCD_RS2320_ReceiveRS232Char(10);


		//Decision
		//Decision: datbyte='A'?
		if (FCV_DATBYTE=='A')
		{
			//Call Component Macro
			//Call Component Macro: datbyte=RS232(0)::ReceiveRS232Char(10)
			FCV_DATBYTE = FCD_RS2320_ReceiveRS232Char(10);


			//Decision
			//Decision: datbyte='A'?
			if (FCV_DATBYTE=='A')
			{
				//Call Component Macro
				//Call Component Macro: datbyte=RS232(0)::ReceiveRS232Char(10)
				FCV_DATBYTE = FCD_RS2320_ReceiveRS232Char(10);


				//Decision
				//Decision: datbyte='5'?
				if (FCV_DATBYTE=='5')
				{
					//Call Component Macro
					//Call Component Macro: datbyte=RS232(0)::ReceiveRS232Char(10)
					FCV_DATBYTE = FCD_RS2320_ReceiveRS232Char(10);


					//Decision
					//Decision: datbyte='5'?
					if (FCV_DATBYTE=='5')
					{
						//Call Component Macro
						//Call Component Macro: dat=RS232(0)::ReceiveRS232String(10, 24)
						FCD_RS2320_ReceiveRS232String(FCV_DAT, 26, 10, 24);


						//Call Component Macro
						//Call Component Macro: LCDDisplay(0)::Cursor(0, 1)
						FCD_LCDDisplay0_Cursor(0, 1);


						//Call Component Macro
						//Call Component Macro: LCDDisplay(0)::PrintString("AA55")
						FCD_LCDDisplay0_PrintString("AA55",4);


						//Call Component Macro
						//Call Component Macro: LCDDisplay(0)::PrintString(dat)
						FCD_LCDDisplay0_PrintString(FCV_DAT,FCSZ_DAT);


						//Loop
						//Loop: While 1
						while (1)
						{
						}


					} else {
						//Goto Connection Point
						//Goto Connection Point: [A]: A
						goto FCC_Main_A;


					}


				} else {
					//Goto Connection Point
					//Goto Connection Point: [A]: A
					goto FCC_Main_A;


				}


			} else {
				//Goto Connection Point
				//Goto Connection Point: [A]: A
				goto FCC_Main_A;


			}


		} else {
			//Connection Point
			//Connection Point: [A]: A
FCC_Main_A:
;


			//Call Component Macro
			//Call Component Macro: LCDDisplay(0)::ClearLine(2)
			FCD_LCDDisplay0_ClearLine(2);


			//Call Component Macro
			//Call Component Macro: LCDDisplay(0)::ClearLine(3)
			FCD_LCDDisplay0_ClearLine(3);


		}


	}


	mainendloop: goto mainendloop;
}

void MX_INTERRUPT_MACRO(void)
{
}



