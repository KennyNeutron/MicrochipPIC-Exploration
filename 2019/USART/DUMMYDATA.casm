;/////////////////////////////////////////////////////////////////////////////////
;// Code Generator: BoostC Compiler - http://www.sourceboost.com
;// Version       : 6.95
;// License Type  : Full License
;// Limitations   : PIC12,PIC16 max code size:Unlimited, max RAM banks:Unlimited, Non commercial use only
;/////////////////////////////////////////////////////////////////////////////////

//************************************************************************************
//**  
//**  File name:     C:\Users\gerpe\OneDrive\GER-PER 2016\Documents\KennyNeutron\USART\DUMMYDATA.c
//**  Generated by:  Flowcode v4.2.3.58
//**  Date:          Saturday, July 27, 2019 14:53:44
//**  Licence:       Professional
//**  Registered to: 20ACM8
//**  
//**  
//**  http://www.matrixmultimedia.com
//************************************************************************************


#define MX_PIC

//Defines for microcontroller
#define P16F690
#define MX_EE
#define MX_EE_SIZE 256
#define MX_SPI
#define MX_SPI_BCB
#define MX_SPI_SDI 4
#define MX_SPI_SDO 7
#define MX_SPI_SCK 6
#define MX_UART
#define MX_UART_B
#define MX_UART_TX 7
#define MX_UART_RX 5
#define MX_I2C
#define MX_MI2C
#define MX_I2C_B
#define MX_I2C_SDA 4
#define MX_I2C_SCL 6
#define MX_PWM
#define MX_PWM_CNT 1
#define MX_PWM_TRIS1 trisc
#define MX_PWM_1 5

//Functions
#define MX_CLK_SPEED 3276800
#ifdef _BOOSTC
#include <system.h>
#endif
#ifdef HI_TECH_C
#include <pic.h>
#endif

//Configuration data
#ifdef _BOOSTC
#pragma DATA 0x2007, 0x30d2
#endif
#ifdef HI_TECH_C
__CONFIG(0x30d2);
#endif

//Internal functions
#include "C:\Program Files (x86)\Matrix Multimedia\Flowcode V4\FCD\internals.h"

//Macro function declarations


//Variable declarations


//Defines:

/**** Macro Substitutions ****
portc = RTS Port
trisc = RTS Data Direction
portc = CTS Port
trisc = CTS Data Direction
0 = RTS Pin
4 = CTS Pin
1 = UART Selection		(0-SW / 1-UART1 / 2-UART2)
0 = Flow Control		(0-Off / 1-On)
0 = Debug Enable		(0-Off / 1-On)
0 = Echo Enable		(0-Off / 1-On)
4 = UART TXSTA Value
20 = UART SPBRG Value
RS232_264744 = Unique ID
Unused = Bitbanged Receive Port Register
Unused = Bitbanged Receive Data Direction Register
Unused = Bitbanged Receive Pin
Unused = Bitbanged Transmit Pin
37 = Bitbanged BAUD Rate Delay
0 = Timout	Selection	(0-Legacy / 1-MS Timeout)
0 = Data Size			(0-8 bits / 1-9 bits / 2-7 bits & Only available on BitBanged components)
0 = Parity Enable		(0-No Parity / 1-Odd Parity / 2-Even Parity)
0 = Legacy Return		(0-Legacy mode return 255 / 1-New mode return MSB err flags)
Unused = Bitbanged Transmit Port Register
Unused = Bitbanged Transmit Data Direction Register
******************************/

#define RS232_264744_RTS_PORT			portc
#define RS232_264744_RTS_TRIS			trisc
#define RS232_264744_CTS_PORT			portc
#define RS232_264744_CTS_TRIS			trisc
#define RS232_264744_RTS_PIN			0
#define RS232_264744_CTS_PIN			4
#define RS232_264744_UART				1
#define RS232_264744_TOUT  			0
#define RS232_264744_DATASIZE			0
#define RS232_264744_PARITY			0
#define RS232_264744_LEGACY_RV			0

#if (0 == 1)
  	#define RS232_264744_HARDWARE
#endif

#if (0 == 1)
  	#define RS232_264744_DEBUG
#endif

#if (0 == 1)
  	#define RS232_264744_ECHO
#endif

#if (RS232_264744_UART == 0)
	#define RS232_264744_RX_PORT		Unused
	#define RS232_264744_RX_TRIS		Unused
	#define RS232_264744_SW_RX		Unused
	#define RS232_264744_SW_TX		Unused
	#define RS232_264744_SW_BAUD		37
	#define RS232_264744_TX_PORT		Unused
	#define RS232_264744_TX_TRIS		Unused
#else
	#define RS232_264744_TXSTA_VAL  	4
	#define RS232_264744_SPBRG_VAL  	20
	#define RS232_264744_SW_BAUD		0
#endif

#if (RS232_264744_LEGACY_RV == 0)
	#if (RS232_264744_DATASIZE == 1)
		#pragma error "RS232 Component cannot combine 9-bit data mode with legacy return value of 255 please check the Component properties"
	#endif
#endif

#define RS232_264744_STATUS_LOOP		0
#define RS232_264744_STATUS_TIMEOUT	1
#define RS232_264744_STATUS_RXBYTE	2





//RS2320: //Macro function declarations

void FCD_RS2320_SendRS232Char(short nChar);
void FCD_RS2320_SendRS232String(char* String, char MSZ_String);
short FCD_RS2320_ReceiveRS232Char(short nTimeout);
void FCD_RS2320_ReceiveRS232String(char* FCR_RETVAL, char FCR_RETVAL_SIZE, char nTimeout, char NumBytes);
void FCD_RS2320_RS232_Delay(char mode);



//RS2320: //Macro implementations


void FCD_RS2320_SendRS232Char(short nChar)

{
	
	#if (RS232_264744_UART == 0)

		char dMask;
		char idx;
		char count = 8;

		#ifdef RS232_264744_HARDWARE
			//wait until CTS is low
			while (( RS232_264744_CTS_PORT & (1 << RS232_264744_CTS_PIN) ) != 0);
		#endif

		#if(RS232_264744_DATASIZE == 1)
			count = 9;
		#endif
		#if(RS232_264744_DATASIZE == 2)
			count = 7;
		#endif

		clear_bit( RS232_264744_TX_PORT, RS232_264744_SW_TX);		// Send Start bit
		FCD_RS2320_RS232_Delay(0);

		for (idx = 0; idx < count; idx++)
		{
			dMask = nChar & 0x01;							// Mask off data bit

			if (dMask)
				set_bit( RS232_264744_TX_PORT, RS232_264744_SW_TX);
			else
				clear_bit( RS232_264744_TX_PORT, RS232_264744_SW_TX);

			FCD_RS2320_RS232_Delay(0);
			nChar = nChar >> 1;								// Move to next data bit
		}

		set_bit( RS232_264744_TX_PORT, RS232_264744_SW_TX);			// Send Stop bit
		FCD_RS2320_RS232_Delay(0);

	#endif

	#if (RS232_264744_UART == 1)

		#ifndef MX_UART
			#pragma error "Chip does not have UART capability"
		#endif

		st_bit(txsta, TXEN);
001C  1683  	BSF STATUS, RP0
001D  1698  	BSF gbl_txsta,5

		while (ts_bit(pir1, TXIF) == 0);
001E        label3
001E  1283  	BCF STATUS, RP0
001F  1E0C  	BTFSS gbl_pir1,4
0020  281E  	GOTO	label3


		#ifdef RS232_264744_HARDWARE
			//wait until CTS is low
			while (( RS232_264744_CTS_PORT & (1 << RS232_264744_CTS_PIN) ) != 0);
		#endif

		#if(RS232_264744_DATASIZE == 1)
			if (test_bit(nChar, 8))
				st_bit(txsta, TX9D);
			else
				cr_bit(txsta, TX9D);
		#endif

		txreg = nChar;
0021  0861  	MOVF FCD_RS2320_00048_arg_nChar, W
0022  0099  	MOVWF gbl_txreg


	#endif

	#if (RS232_264744_UART == 2)

		#ifndef MX_UART2
			#pragma error "Chip does not have second UART capability"
		#endif

		st_bit(txsta2, TXEN);
		while (ts_bit(pir3, TX2IF) == 0);

		#ifdef RS232_264744_HARDWARE
			//wait until CTS is low
			while (( RS232_264744_CTS_PORT & (1 << RS232_264744_CTS_PIN) ) != 0);
		#endif

		#if( RS232_264744_DATASIZE == 1)
			if (test_bit(nChar, 8))
				st_bit(txsta2, TX9D);
			else
				cr_bit(txsta2, TX9D);
		#endif

		txreg2 = nChar;

	#endif

}
0023  0008  	RETURN


void FCD_RS2320_SendRS232String(char* String, char MSZ_String)

{
		char idx;
		for(idx = 0; idx < MSZ_String; idx++)
0024  01E0  	CLRF FCD_RS2320_00049_1_idx
0025        label4
0025  085F  	MOVF FCD_RS2320_00049_arg_MSZ_String, W
0026  0260  	SUBWF FCD_RS2320_00049_1_idx, W
0027  1803  	BTFSC STATUS,C
003C  0AE0  	INCF FCD_RS2320_00049_1_idx, F
003D  2825  	GOTO	label4

		{
			#ifdef _BOOSTC
				if (String[idx] == 0)
0029  1383  	BCF STATUS,IRP
002A  1843  	BTFSC FCD_RS2320_00049_arg_String+D'1',0
002B  1783  	BSF STATUS,IRP
002C  0842  	MOVF FCD_RS2320_00049_arg_String, W
002D  0760  	ADDWF FCD_RS2320_00049_1_idx, W
002E  0084  	MOVWF FSR
002F  0880  	MOVF INDF, F
0030  1903  	BTFSC STATUS,Z

					break;
				else FCD_RS2320_SendRS232Char(String[idx]);
0032  1383  	BCF STATUS,IRP
0033  1843  	BTFSC FCD_RS2320_00049_arg_String+D'1',0
0034  1783  	BSF STATUS,IRP
0035  0842  	MOVF FCD_RS2320_00049_arg_String, W
0036  0760  	ADDWF FCD_RS2320_00049_1_idx, W
0037  0084  	MOVWF FSR
0038  0800  	MOVF INDF, W
0039  00E1  	MOVWF FCD_RS2320_00048_arg_nChar
003A  01E2  	CLRF FCD_RS2320_00048_arg_nChar+D'1'
003B  201C  	CALL FCD_RS2320_00048

			#endif
			#ifdef HI_TECH_
				if (*String == 0)
					break;
				else FCD_RS2320_SendRS232Char(*String);
				String++;
			#endif
		}
}
0028  0008  	RETURN
0031  0008  	RETURN


short FCD_RS2320_ReceiveRS232Char(short nTimeout)
{
	
		char delay1 = 0;
		char delay2 = 0;
		char regcheck = 0;
		char dummy = 0;
		short retVal = 512;
		char bWaitForever = 0;
		char rxStatus = RS232_264744_STATUS_LOOP;
		char idx;
		char count = 8;

		#if ( RS232_264744_LEGACY_RV == 0)
			retVal = 255;
		#endif

		#if ( RS232_264744_UART == 1)
			#ifndef MX_UART
				#pragma error "Chip does not have UART capability"
			#endif
		#endif

		#if ( RS232_264744_UART == 2)
			#ifndef MX_UART2
				#pragma error "Chip does not have second UART capability"
			#endif
		#endif

		#ifdef RS232_264744_HARDWARE
			//ready to accept data
			clear_bit( RS232_264744_RTS_PORT, RS232_264744_RTS_PIN);
		#endif

		if (nTimeout == 255)
			bWaitForever = 1;

		#if ( RS232_264744_UART == 1)
			st_bit(rcsta, CREN);
		#endif

		#if ( RS232_264744_UART == 2)
			st_bit(rcsta2, CREN);
		#endif

		while (rxStatus == RS232_264744_STATUS_LOOP)
		{
			if (bWaitForever == 0)
			{
				//don't wait forever, so do timeout thing...
				if (nTimeout == 0)
				{
					rxStatus = RS232_264744_STATUS_TIMEOUT;
				}
				else
				{
					if ( RS232_264744_TOUT)
					{
						delay_us(10);
						delay1 = delay1 + 1;
						if(delay1 == 100)
						{
							nTimeout = nTimeout - 1;
							delay1 = 0;
						}
					}
					else
					{
						//decrement timeout
						delay1 = delay1 - 1;
						if (delay1 == 0)
						{
							nTimeout = nTimeout - 1;
						}
					}
				}
			}

			#if ( RS232_264744_UART == 0)
				regcheck = test_bit(RS232_264744_RX_PORT, RS232_264744_SW_RX);	//Test for start bit
				if (regcheck == 0)
					rxStatus = RS232_264744_STATUS_RXBYTE;
			#endif

			#if ( RS232_264744_UART == 1)
				regcheck = ts_bit(pir1, RCIF);
				if (regcheck != 0)
					rxStatus = RS232_264744_STATUS_RXBYTE;
			#endif

			#if ( RS232_264744_UART == 2)
				regcheck = ts_bit(pir3, RC2IF);
				if (regcheck != 0)
					rxStatus = RS232_264744_STATUS_RXBYTE;
			#endif
		}

		if (rxStatus == RS232_264744_STATUS_RXBYTE)
		{
			#if ( RS232_264744_UART > 0)

				#if ( RS232_264744_UART == 1)
					regcheck = ts_bit(rcsta, FERR);
				#endif

				#if ( RS232_264744_UART == 2)
					regcheck = ts_bit(rcsta2, FERR);
				#endif

				if (regcheck != 0)
				{
					#if ( RS232_264744_UART == 1)
						dummy = rcreg;      //need to read the rcreg to clear FERR
					#endif

					#if ( RS232_264744_UART == 2)
						dummy = rcreg2;      //need to read the rcreg to clear FERR
					#endif

					#ifdef RS232_264744_DEBUG
						FCD_RS2320_SendRS232Char('<');
						FCD_RS2320_SendRS232Char('F');
						FCD_RS2320_SendRS232Char('E');
						FCD_RS2320_SendRS232Char('R');
						FCD_RS2320_SendRS232Char('R');
						FCD_RS2320_SendRS232Char('>');
					#endif

					#if ( RS232_264744_LEGACY_RV == 1)
						retVal = 0x400;					//Framing Error Flag
					#endif
				}
				else
				{
					#if ( RS232_264744_UART == 1)
						regcheck = ts_bit(rcsta, OERR);
					#endif

					#if ( RS232_264744_UART == 2)
						regcheck = ts_bit(rcsta2, OERR);
					#endif

					if (regcheck != 0)
					{
						//need to read the rcreg to clear error
						#if ( RS232_264744_UART == 1)
							cr_bit(rcsta, CREN);
							st_bit(rcsta, CREN);
						#endif

						#if ( RS232_264744_UART == 2)
							cr_bit(rcsta2, CREN);
							st_bit(rcsta2, CREN);
						#endif

						#ifdef RS232_264744_DEBUG
							FCD_RS2320_SendRS232Char('<');
							FCD_RS2320_SendRS232Char('O');
							FCD_RS2320_SendRS232Char('E');
							FCD_RS2320_SendRS232Char('R');
							FCD_RS2320_SendRS232Char('R');
							FCD_RS2320_SendRS232Char('>');
						#endif

						#if ( RS232_264744_LEGACY_RV == 1)
							retVal = 0x800;					//Overrun Error Flag
						#endif

					}
					else
					{
						#if ( RS232_264744_UART == 1)
							retVal = rcreg; 			//no error, so rx byte is valid

							#if( RS232_264744_DATASIZE == 1)
								if(ts_bit(rcsta, RX9D));
									retVal = retVal | 0x100;
							#endif

						#endif

						#if ( RS232_264744_UART == 2)
							retVal = rcreg2; 			//no error, so rx byte is valid

							#if( RS232_264744_DATASIZE == 1)
								if(ts_bit(rcsta2, RX9D));
									retVal = retVal | 0x100;
							#endif

						#endif

						#ifdef RS232_264744_ECHO
							FCD_RS2320_SendRS232Char(retVal);
						#endif
					}
				}
			#else
				#if( RS232_264744_DATASIZE == 1)
					count = 9;
				#endif

				FCD_RS2320_RS232_Delay(1);
				for (idx = 0; idx < count; idx++)
				{
					retVal = retVal >> 1;

					if(count == 9)
					{
						if (test_bit( RS232_264744_RX_PORT, RS232_264744_SW_RX))
							retVal = retVal | 0x100;
					}
					else
					{
						if (test_bit( RS232_264744_RX_PORT, RS232_264744_SW_RX))
							retVal = retVal | 0x80;
					}
					FCD_RS2320_RS232_Delay(1);
				}

				#ifdef RS232_264744_ECHO
					FCD_RS2320_SendRS232Char(retVal);
				#endif

			#endif
		}
		#ifdef RS232_264744_HARDWARE
			//not ready to accept data
			set_bit( RS232_264744_RTS_PORT, RS232_264744_RTS_PIN);
		#endif

		return (retVal);
}

void FCD_RS2320_ReceiveRS232String(char* FCR_RETVAL, char FCR_RETVAL_SIZE, char nTimeout, char NumBytes)
{
		char idx;
		short in;

		#if ( RS232_264744_LEGACY_RV == 0 )
			#define RS232_TO 	255
		#else
			#define RS232_TO 	256
		#endif

		if (NumBytes > FCR_RETVAL_SIZE)
			NumBytes = FCR_RETVAL_SIZE;

		for (idx = 0; idx < NumBytes; idx++)
		{
			in = FCD_RS2320_ReceiveRS232Char(nTimeout);
			if(in < RS232_TO)
				FCR_RETVAL[idx] = in & 0xFF;
			else
				break;
		}

		if (idx < FCR_RETVAL_SIZE)
			FCR_RETVAL[idx] = 0;

		#undef RS232_TO
}

void FCD_RS2320_RS232_Delay(char mode)
{
		unsigned int iterations;
		unsigned int delay = RS232_264744_SW_BAUD;

		if (mode)
			delay = delay + 1;

		for (iterations = 0; iterations < delay; iterations++);
}

//Macro implementations

void main()

{
	
	//Initialisation
	ansel = 0;
003E  1283  	BCF STATUS, RP0
003F  1703  	BSF STATUS, RP1
0040  019E  	CLRF gbl_ansel

anselh = 0;
0041  019F  	CLRF gbl_anselh


	
	#if (RS232_264744_UART == 0)
		set_bit(RS232_264744_RX_TRIS, RS232_264744_SW_RX);		// Receive pin is a input
		clear_bit(RS232_264744_TX_TRIS, RS232_264744_SW_TX);	// Transmit pin is a output
		set_bit(RS232_264744_TX_PORT, RS232_264744_SW_TX);		// Transmit pin is default high
	#endif

	#if (RS232_264744_UART == 1)
		txsta = RS232_264744_TXSTA_VAL;   					// 8-bit, async, low speed, off
0042  3004  	MOVLW 0x04
0043  1683  	BSF STATUS, RP0
0044  1303  	BCF STATUS, RP1
0045  0098  	MOVWF gbl_txsta

		spbrg = RS232_264744_SPBRG_VAL;   					// set the baud rate
0046  3014  	MOVLW 0x14
0047  0099  	MOVWF gbl_spbrg

		rcsta = 0;                    				// 8-bit, disabled
0048  1283  	BCF STATUS, RP0
0049  0198  	CLRF gbl_rcsta


		if(RS232_264744_DATASIZE == 1)
		{
			st_bit(txsta, TX9);   						// 9-bit TX
			st_bit(rcsta, RX9);                    	// 9-bit RX
		}

		st_bit(rcsta, SPEN);         					// turn on serial interface
004A  1798  	BSF gbl_rcsta,7

	#endif

	#if (RS232_264744_UART == 2)

		txsta2 = RS232_264744_TXSTA_VAL;   					// 8-bit, async, low speed, off
		spbrg2 = RS232_264744_SPBRG_VAL;   					// set the baud rate
		rcsta2 = 0;                    					// 8-bit, disabled

		if(RS232_264744_DATASIZE == 1)
		{
			st_bit(txsta2, TX9);   					// 9-bit TX
			st_bit(rcsta2, RX9);                    	// 9-bit RX
		}

		st_bit(rcsta2, SPEN);         					// turn on serial interface
	#endif

	#ifdef RS232_264744_HARDWARE
		set_bit( RS232_264744_CTS_TRIS, RS232_264744_CTS_PIN);	//CTS is an input
		clear_bit( RS232_264744_RTS_TRIS, RS232_264744_RTS_PIN);	//RTS is an output
		set_bit( RS232_264744_RTS_PORT, RS232_264744_RTS_PIN); 	//not ready to accept data
	#endif


	//Interrupt initialisation code
	option_reg = 0xC0;
004B  30C0  	MOVLW 0xC0
004C  1683  	BSF STATUS, RP0
004D  0081  	MOVWF gbl_option_reg



	//Loop
	//Loop: While 1
	while (1)
004E        label5
0082  284E  	GOTO	label5

	{
		//Call Component Macro
		//Call Component Macro: RS232(0)::SendRS232String("AA5523109367051231342321AB")
		FCD_RS2320_SendRS232String("AA5523109367051231342321AB",26);
004E  3030  	MOVLW 0x30
004F  1283  	BCF STATUS, RP0
0050  00CB  	MOVWF CompTempVar2217+D'7'
0051  00D0  	MOVWF CompTempVar2217+D'12'
0052  3031  	MOVLW 0x31
0053  00CA  	MOVWF CompTempVar2217+D'6'
0054  00D2  	MOVWF CompTempVar2217+D'14'
0055  00D5  	MOVWF CompTempVar2217+D'17'
0056  00DB  	MOVWF CompTempVar2217+D'23'
0057  3032  	MOVLW 0x32
0058  00C8  	MOVWF CompTempVar2217+D'4'
0059  00D3  	MOVWF CompTempVar2217+D'15'
005A  00D8  	MOVWF CompTempVar2217+D'20'
005B  00DA  	MOVWF CompTempVar2217+D'22'
005C  3033  	MOVLW 0x33
005D  00C9  	MOVWF CompTempVar2217+D'5'
005E  00CD  	MOVWF CompTempVar2217+D'9'
005F  00D4  	MOVWF CompTempVar2217+D'16'
0060  00D6  	MOVWF CompTempVar2217+D'18'
0061  00D9  	MOVWF CompTempVar2217+D'21'
0062  3034  	MOVLW 0x34
0063  00D7  	MOVWF CompTempVar2217+D'19'
0064  3035  	MOVLW 0x35
0065  00C6  	MOVWF CompTempVar2217+D'2'
0066  00C7  	MOVWF CompTempVar2217+D'3'
0067  00D1  	MOVWF CompTempVar2217+D'13'
0068  3036  	MOVLW 0x36
0069  00CE  	MOVWF CompTempVar2217+D'10'
006A  3037  	MOVLW 0x37
006B  00CF  	MOVWF CompTempVar2217+D'11'
006C  3039  	MOVLW 0x39
006D  00CC  	MOVWF CompTempVar2217+D'8'
006E  3041  	MOVLW 0x41
006F  00C4  	MOVWF CompTempVar2217
0070  00C5  	MOVWF CompTempVar2217+D'1'
0071  00DC  	MOVWF CompTempVar2217+D'24'
0072  3042  	MOVLW 0x42
0073  00DD  	MOVWF CompTempVar2217+D'25'
0074  01DE  	CLRF CompTempVar2217+D'26'
0075  3000  	MOVLW HIGH(CompTempVar2217+D'0')
0076  00C3  	MOVWF FCD_RS2320_00049_arg_String+D'1'
0077  3044  	MOVLW LOW(CompTempVar2217+D'0')
0078  00C2  	MOVWF FCD_RS2320_00049_arg_String
0079  301A  	MOVLW 0x1A
007A  00DF  	MOVWF FCD_RS2320_00049_arg_MSZ_String
007B  2024  	CALL FCD_RS2320_00049



		//Delay
		//Delay: 500 ms
		delay_ms(255);
007C  30FF  	MOVLW 0xFF
007D  00C2  	MOVWF delay_ms_00000_arg_del
007E  2010  	CALL delay_ms_00000

		delay_ms(245);
007F  30F5  	MOVLW 0xF5
0080  00C2  	MOVWF delay_ms_00000_arg_del
0081  2010  	CALL delay_ms_00000



	}


	mainendloop: goto mainendloop;
}


void MX_INTERRUPT_MACRO(void)

{
}
00AB  1283  	BCF STATUS, RP0
00AC  1303  	BCF STATUS, RP1
00AD  0E36  	SWAPF Int1BContext+D'2', W
00AE  0084  	MOVWF FSR
00AF  0E35  	SWAPF Int1BContext+D'1', W
00B0  008A  	MOVWF PCLATH
00B1  0E34  	SWAPF Int1BContext, W
00B2  0083  	MOVWF STATUS
00B3  0EFF  	SWAPF Int1Context, F
00B4  0E7F  	SWAPF Int1Context, W
00B5  0009  	RETFIE





////////////////////////////////////////
// Code with no source :-)
////////////////////////////////////////
0000  2883  	GOTO	_startup

0004  00FF  	MOVWF Int1Context
0005  0E03  	SWAPF STATUS, W
0006  1283  	BCF STATUS, RP0
0007  1303  	BCF STATUS, RP1
0008  00B4  	MOVWF Int1BContext
0009  0E0A  	SWAPF PCLATH, W
000A  00B5  	MOVWF Int1BContext+D'1'
000B  0E04  	SWAPF FSR, W
000C  00B6  	MOVWF Int1BContext+D'2'
000D  118A  	BCF PCLATH,3
000E  120A  	BCF PCLATH,4
000F  28AB  	GOTO	interrupt
0010        delay_ms_00000
0010        ; { delay_ms ; function begin
0010  08C2  	MOVF delay_ms_00000_arg_del, F
0011  1D03  	BTFSS STATUS,Z
0012  2814  	GOTO	label1
0013  0008  	RETURN
0014        label1
0014  30CC  	MOVLW 0xCC
0015        label2
0015  3EFF  	ADDLW 0xFF
0016  1D03  	BTFSS STATUS,Z
0017  2815  	GOTO	label2
0018  0000  	NOP
0019  0BC2  	DECFSZ delay_ms_00000_arg_del, F
001A  2814  	GOTO	label1
001B  0008  	RETURN
001C        ; } delay_ms function end


0083        _startup
0083  30D5  	MOVLW 0xD5
0084  1283  	BCF STATUS, RP0
0085  1303  	BCF STATUS, RP1
0086  00A0  	MOVWF gbl_16_LSR
0087  30C4  	MOVLW 0xC4
0088  00A1  	MOVWF gbl_16_LSR+D'1'
0089  30BB  	MOVLW 0xBB
008A  00A2  	MOVWF gbl_16_LSR+D'2'
008B  30DC  	MOVLW 0xDC
008C  00A3  	MOVWF gbl_16_LSR+D'3'
008D  01A4  	CLRF gbl_17_gbl_aSig
008E  01A5  	CLRF gbl_17_gbl_aSig+D'1'
008F  01A6  	CLRF gbl_17_gbl_aSig+D'2'
0090  01A7  	CLRF gbl_17_gbl_aSig+D'3'
0091  01A8  	CLRF gbl_17_gbl_bSig
0092  01A9  	CLRF gbl_17_gbl_bSig+D'1'
0093  01AA  	CLRF gbl_17_gbl_bSig+D'2'
0094  01AB  	CLRF gbl_17_gbl_bSig+D'3'
0095  01AC  	CLRF gbl_17_gbl_zSig
0096  01AD  	CLRF gbl_17_gbl_zSig+D'1'
0097  01AE  	CLRF gbl_17_gbl_zSig+D'2'
0098  01AF  	CLRF gbl_17_gbl_zSig+D'3'
0099  01BC  	CLRF gbl_17_gbl_aExp
009A  01BD  	CLRF gbl_17_gbl_bExp
009B  01B7  	CLRF gbl_17_gbl_zExp
009C  01B8  	CLRF gbl_17_gbl_zExp+D'1'
009D  01BE  	CLRF gbl_17_gbl_aSign
009E  01BF  	CLRF gbl_17_gbl_bSign
009F  01C0  	CLRF gbl_17_gbl_zSign
00A0  01C1  	CLRF gbl_17_gbl_zSigZero
00A1  01B0  	CLRF gbl_17_gbl_ret
00A2  01B1  	CLRF gbl_17_gbl_ret+D'1'
00A3  01B2  	CLRF gbl_17_gbl_ret+D'2'
00A4  01B3  	CLRF gbl_17_gbl_ret+D'3'
00A5  01BA  	CLRF gbl_float_rounding_mode
00A6  01BB  	CLRF gbl_float_exception_flags
00A7  01B9  	CLRF gbl_float_detect_tininess
00A8  118A  	BCF PCLATH,3
00A9  120A  	BCF PCLATH,4
00AA  283E  	GOTO	main

2007  30D2  	DW 0x30D2
