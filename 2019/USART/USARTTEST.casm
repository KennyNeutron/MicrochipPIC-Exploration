;/////////////////////////////////////////////////////////////////////////////////
;// Code Generator: BoostC Compiler - http://www.sourceboost.com
;// Version       : 6.95
;// License Type  : Full License
;// Limitations   : PIC12,PIC16 max code size:Unlimited, max RAM banks:Unlimited, Non commercial use only
;/////////////////////////////////////////////////////////////////////////////////

/*********************************************************************
 *                  Flowcode Internals Header File
 *
 * File: internals.h
 *
 * (c) 2009 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * “Company”) for its Flowcode graphical programming language is
 * intended and supplied to you, the Company’s customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 010107 | ST | Created
 * 010108 | SK | Edited for ICD Operation
 * 031108 | BR | Edited for integration with PPP
 * 130309 | BR | Added Floating point, Hex and Decimal String Coversion Functions
 * 160309 | BR | Added ICD Port Definitions
 * 160309 | BR | Added Watchdog Delay routines
 * 090409 | BR | Fixed minor definitions bug
 * 170409 | BR | Optimised Floating / String conversions
 * 210509 | BR | Fixed ICD Stop and wait functionality
 * 110809 | BR | Changed the amount of delay in the watchdog ms delay routine
 * 160909 | BR | Added BoostC and HiTECH definitions
 * 290909 | BR | Altered the Test_bit function and ICD arrays for HITECH
 * 161009 | BR | Added a missing semi colon and added the math.h library for 16F devices
 * 221009 | BR | Removed the FCI_TMP_STR and FCI_TMP_INT variables
 ********************************************************************/

#ifndef internals_h
#define internals_h

//BR 22/10/09 - Are these needed? 10F devices could not allocate enough memory to create array
//unsigned char FCI_TMP_STR[20];
//int FCI_TMP_INT;

//String function definitions
char FCI_GETCHAR(char* sStr1, char iStr1_len, char iPos);
char FCI_GETLENGTH(char* sStr1, char iStr1_len);
char FCI_MIDSTRING(char* sSrc, char iSrc_len, char* sDst, char iDst_len, char iStart, char iCount);
char FCI_LEFTSTRING(char* sSrc, char iSrc_len, char* sDst, char iDst_len, char iCount);
char FCI_RIGHTSTRING(char* sSrc, char iSrc_len, char* sDst, char iDst_len, char iCount);
char FCI_CONCATENATE(char* sSrc1, char iSrc1_len, char* sSrc2, char iSrc2_len, char* sDst, char iDst_len);
char FCI_TOSTRING(int iSrc1, char* sDst, char iDst_len);
void FCI_TOLOWER(char* sSrc, char iSrc_len, char* sDst, char iDst_len);
void FCI_TOUPPER(char* sSrc, char iSrc_len, char* sDst, char iDst_len);
char FCI_COMPARE(char* sSrc1, char iSrc1_len, char* sSrc2, char iSrc2_len, char iNoCase);
char FCI_FLOAT_TO_STRING(float Number, char Precision, char* String, char MSZ_String);
char FCI_NUMBER_TO_HEX(short Number, char* String, char MSZ_String);
short FCI_STRING_TO_INT(char* String, char MSZ_String);
float FCI_STRING_TO_FLOAT(char* String, char MSZ_String);
void Wdt_msDelay(void);
void Wdt_Delay_S(short delay);
void Wdt_Delay_Ms(short delay);
char isinf(float f);

/******************** BOOST C SPECIFICS *****************/
#ifdef _BOOSTC

	#include <float.h>

	#pragma CLOCK_FREQ 				MX_CLK_SPEED
	#define MX_INTERRUPT_MACRO		interrupt
	#define MX_CLEAR_WATCHDOG		clear_wdt()

	#define st_bit(var,bitno) 		set_bit(var,bitno)
	#define cr_bit(var,bitno) 		clear_bit(var,bitno)
	#define ts_bit(var,bitno)		test_bit(var,bitno)

#endif

/******************* HITECH C SPECIFICS *****************/
#ifdef HI_TECH_C

	#include <htc.h> 				//Delay Params
	#include "definitions.h"
	#include <math.h>

	#define _XTAL_FREQ 				MX_CLK_SPEED
	#define MX_INTERRUPT_MACRO		interrupt myisr
	#define MX_CLEAR_WATCHDOG		CLRWDT()

	char ts_bit(char reg, char bt);
	char test_bit(char reg, char bt);
	void delay_10us(char del);
	void delay_us(char del);
	void delay_ms(char del);
	void delay_s(char del);
	void nop(void);
	float float32_add(float a, float b);
	float float32_sub(float a, float b);
	float float32_mul(float a, float b);
	float float32_div(float a, float b);
	float float32_rem(float a, float b);
	char float32_is_signaling_nan(float a);
	char float32_eq(float a, float b);
	char float32_ge(float a, float b);
	char float32_gt(float a, float b);
	char float32_le(float a, float b);
	char float32_lt(float a, float b);
	short float32_to_int32 (float a);
	float float32_from_int32 (short a);

	#define INTE					INT0IE
	#define INTF					INT0IF

	#define st_bit(var,bitno) 		bitno = 1
	#define cr_bit(var,bitno) 		bitno = 0
	#define set_bit(var,bitno) 		var |= (1 << bitno)
	#define clear_bit(var,bitno) 	var &= ~(1 << bitno)

	char ts_bit(char reg, char bt)
	{
		if (bt)
			return 1;
		return 0;
	}

	char test_bit(char reg, char bt)
	{
		if (reg & (1 << bt))
			return (1 << bt);
		return 0;
	}

	void delay_10us(char del)
	{
		char count;
		for(count=0; count<10; count++)
		{
			delay_us(del);
		}
	}

	void delay_us(char del)
	{
		while (del > 1)
		{
			__delay_us(1);
			del = del - 1;
		}
	}

	void delay_ms(char del)
	{
		while (del > 1)
		{
			__delay_ms(1);
			del = del - 1;
		}
	}

	void delay_s(char del)
	{
		char i;
		for(i=0; i<del; i++)
		{
			delay_ms(250);
			delay_ms(250);
			delay_ms(250);
			delay_ms(250);
		}
	}

	void nop()
	{
		asm("NOP");
	}

	float float32_add(float a, float b)
	{
		return (a + b);
	}

	float float32_sub(float a, float b)
	{
		return (a - b);
	}

	float float32_mul(float a, float b)
	{
		return (a * b);
	}

	float float32_div(float a, float b)
	{
		return (a / b);
	}

	float float32_rem(float a, float b)
	{
		return (fmod(a, b));
	}

	char float32_is_signaling_nan(float a)
	{
		return isinf(a);
	}

	char float32_eq(float a, float b)
	{
		return (a == b);
	}

	char float32_ge(float a, float b)
	{
		return (a >= b);
	}

	char float32_gt(float a, float b)
	{
		return (a > b);
	}

	char float32_le(float a, float b)
	{
		return (a <= b);
	}

	char float32_lt(float a, float b)
	{
		return (a < b);
	}

	short float32_to_int32 (float a)
	{
		return ((int)a);
	}

	float float32_from_int32 (short a)
	{
		return ((float)a);
	}

	char FCI_GETCHAR(char* sStr1, char iStr1_len, char iPos)
	{
		char tmp;
		for (tmp = 0; tmp < iStr1_len; tmp++)
		{
			if (*sStr1 == 0)
				break;
			sStr1++;
		}

		if(iPos < tmp)
			tmp = *sStr1;
		else tmp = 0;
		return (tmp);
	}

	char FCI_GETLENGTH(char* sStr1, char iStr1_len)
	{
		char tmp;
		for (tmp = 0; tmp < iStr1_len; tmp++)
		{
			if (*sStr1 == 0)
				break;
			sStr1++;
		}
		return (tmp);
	}

	char FCI_MIDSTRING(char* sSrc, char iSrc_len, char* sDst, char iDst_len, char iStart, char iCount)
	{
		char idx;
		for (idx = 0; idx < iSrc_len; idx++)	//find the length of the source string
		{
			if (*sSrc == 0)
				break;
			sSrc++;
		}

		if (iStart >= idx)
		{
			*sDst = 0;							//starting position is beyond string length, so return a null string
		}
		else
		{
			if ((iStart + iCount) >= idx)		//Make sure the required length is not too big
				iCount = idx - iStart;

			sSrc = 0;

			for (idx = 0; idx < iStart; idx++)	//Move to the correct place in the source string
				sSrc++;

			for (idx = 0; idx < iCount; idx++)	//Copy the contents of the source string
			{
				if (idx < iDst_len)
				{
					*sDst = *sSrc;
					sDst++;
					sSrc++;
				}
				else break;
			}

			if (idx < iDst_len)					//add terminating null (if we can)
				*sDst = 0;
		}
		return (idx);
	}

	char FCI_LEFTSTRING(char* sSrc, char iSrc_len, char* sDst, char iDst_len, char iCount)
	{
		char idx = 0;
		for (idx = 0; idx < iSrc_len; idx++)	//find the length of the source string
		{
			if (*sSrc == 0)
				break;
			sSrc++;
		}

		if (iCount > idx)						//make sure the required length is not too big
			iCount = idx;

		sSrc = 0;

		for (idx = 0; idx < iCount; idx++)		//copy the required characters
		{
			if (idx < iDst_len)
			{
				*sDst = *sSrc;
				sDst++;
				sSrc++;
			}
			else break;
		}

		if (idx < iDst_len)						//add terminating null (if we can)
			*sDst = 0;

		return (idx);
	}

	char FCI_RIGHTSTRING(char* sSrc, char iSrc_len, char* sDst, char iDst_len, char iCount)
	{
		char idx = 0;
		char delta;

		for (idx = 0; idx < iSrc_len; idx++)	//find the length of the source string
		{
			if (*sSrc == 0)
				break;
			sSrc++;
		}

		if (iCount > idx)						//make sure the required length is not too big
			iCount = idx;

		delta = idx - iCount;					//get the offset

		sSrc = 0;
		for (idx = 0; idx < delta; idx++)		//Move to the correct place in the source string
			sSrc++;

		for(idx = 0; idx < iCount; idx++)		//copy the required characters
		{
			if (idx < iDst_len)
			{
				*sDst = *sSrc;
				sDst++;
				sSrc++;
			}
			else break;
		}

		if (idx < iDst_len)						//add terminating null (if we can)
			*sDst = 0;

		return (idx);
	}

	char FCI_CONCATENATE(char* sSrc1, char iSrc1_len, char* sSrc2, char iSrc2_len, char* sDst, char iDst_len)
	{
		char tmp;
		char idx = 0;

		for (tmp=0; tmp<iSrc1_len; tmp++)		//copy source 1 into destination
		{
			if (idx < iDst_len)
			{
				*sDst = *sSrc1;
				sDst++;
				sSrc1++;

				if (*sSrc1 != 0)
					idx++;
				else break;
			}
		}

		for (tmp=0; tmp<iSrc2_len; tmp++)		//copy source 2 into destination
		{
			if (idx < iDst_len)
			{
				*sDst = *sSrc2;
				sDst++;
				sSrc2++;

				if (*sSrc2 != 0)
					idx++;
				else break;
			}
		}

		if (idx < iDst_len)						//add terminating null (if we can)
			*sDst = 0;

		return (idx);
	}

	char FCI_TOSTRING(int iSrc1, char* sDst, char iDst_len)
	{
		char tmp1;
		short tmp2;
		char idx = 0;

		//copy source 1 into destination:
		//minus sign
		if (iSrc1 < 0)
		{
			sDst[0] = '-';
			idx++;
			iSrc1 = 0 - iSrc1;
		}

		tmp2 = iSrc1;
		if (iSrc1 >= 10000)
		{
			if (idx < iDst_len)
			{
				tmp1 = tmp2 / 10000;
				sDst[idx] = '0' + tmp1;
				idx++;
			}

			while (tmp1 > 0)
			{
				tmp2 = tmp2 - 10000;
				tmp1--;
			}
		}

		if (iSrc1 >= 1000)
		{
			if (idx < iDst_len)
			{
				tmp1 = tmp2 / 1000;
				sDst[idx] = '0' + tmp1;
				idx++;
			}

			while (tmp1 > 0)
			{
				tmp2 = tmp2 - 1000;
				tmp1--;
			}
		}

		if (iSrc1 >= 100)
		{
			if (idx < iDst_len)
			{
				tmp1 = tmp2 / 100;
				sDst[idx] = '0' + tmp1;
				idx++;
			}

			while (tmp1 > 0)
			{
				tmp2 = tmp2 - 100;
				tmp1--;
			}
		}

		if (iSrc1 >= 10)
		{
			if (idx < iDst_len)
			{
				tmp1 = tmp2 / 10;
				sDst[idx] = '0' + tmp1;
				idx++;
			}

			while (tmp1 > 0)
			{
				tmp2 = tmp2 - 10;
				tmp1--;
			}
		}

		if (idx < iDst_len)
		{
			sDst[idx] = '0' + tmp2;
			idx++;
		}

		//add terminating null (if we can)
		if (idx < iDst_len)
		{
			sDst[idx] = 0;
		}

		return (idx);
	}

	void FCI_TOLOWER(char* sSrc, char iSrc_len, char* sDst, char iDst_len)
	{
		char idx;
		char ch;

		//copy source into destination and change to lower case
		for (idx=0; idx<iSrc_len; idx++)
		{
			if (idx < iDst_len)
			{
				ch = sSrc[idx];
				sDst[idx] = ch;
				if (ch != 0)
				{
					if ((ch >= 'A') && (ch <= 'Z'))
					{
						sDst[idx] = (ch | 0x20);
					}
				} else {
					break;
				}
			}
		}
	}

	void FCI_TOUPPER(char* sSrc, char iSrc_len, char* sDst, char iDst_len)
	{
		char idx;
		char ch;

		//copy source into destination and change to upper case
		for (idx=0; idx<iSrc_len; idx++)
		{
			if (idx < iDst_len)
			{
				ch = sSrc[idx];
				sDst[idx] = ch;
				if (ch != 0)
				{
					if ((ch >= 'a') && (ch <= 'z'))
					{
						sDst[idx] = (ch & 0xDF);
					}
				} else {
					break;
				}
			}
		}
	}

	char FCI_COMPARE(char* sSrc1, char iSrc1_len, char* sSrc2, char iSrc2_len, char iNoCase)
	{
		char iRetVal = 0;
		char idx;
		char ch1, ch2;

		for (idx=0; idx < iSrc1_len; idx++)	//compare a byte from the strings
		{
			if (idx < iSrc2_len)
			{
				ch1 = *sSrc1;
				ch2 = *sSrc2;

				if (iNoCase)
				{
					if ((ch1 >= 'a') && (ch1 <= 'z'))
						ch1 = (ch1 & 0xDF);

					if ((ch2 >= 'a') && (ch2 <= 'z'))
						ch2 = (ch2 & 0xDF);

				}

				if (ch1 < ch2)
				{
					return(255);
				}
				else if (ch1 > ch2)
				{
					return(1);
				}

				sSrc1++;
				sSrc2++;
			}
			else
			{
				if (*sSrc1 == 0)
					return (0);				//end of source1 as well, so ok
				else
					return (1);				//reached the end of iSrc2, but still more of iSrc1
			}
		}

		if (iSrc1_len == iSrc2_len)			//reached the end of iSrc1.  If we're also at the end of iSrc2, then return 0
			return (0);
		else
		{
			if (*sSrc2 == 0)
				return (0);					//end of source1 as well, so ok
			else
				return (255);				//not at end of source2, so return -1
		}
	}
#endif


/********************* ICD SPECIFICS *******************/
#ifdef USE_FLOWCODE_ICD

	//ICD Clock Port Defines
	#if (ICD_CLK_PORT == 0)
		#ifdef porta
			#define ICD_CLK_PIN_TRIS trisa
			#define ICD_CLK_PIN_PORT porta
		#endif
		#ifdef gpio
			#define ICD_CLK_PIN_PORT gpio
			#ifdef trisgpio
				#define ICD_CLK_PIN_TRIS trisgpio
			#endif
			#ifdef trisio
				#define ICD_CLK_PIN_TRIS trisio
			#endif
			#ifdef tris
				#define ICD_CLK_PIN_TRIS tris
			#endif
		#endif
	#endif
	#if (ICD_CLK_PORT == 1)
	  #define ICD_CLK_PIN_TRIS trisb
	  #define ICD_CLK_PIN_PORT portb
	#endif
	#if (ICD_CLK_PORT == 2)
	  #define ICD_CLK_PIN_TRIS trisc
	  #define ICD_CLK_PIN_PORT portc
	#endif
	#if (ICD_CLK_PORT == 3)
	  #define ICD_CLK_PIN_TRIS trisd
	  #define ICD_CLK_PIN_PORT portd
	#endif
	#if (ICD_CLK_PORT == 4)
	  #define ICD_CLK_PIN_TRIS trise
	  #define ICD_CLK_PIN_PORT porte
	#endif
	#if (ICD_CLK_PORT == 5)
	  #define ICD_CLK_PIN_TRIS trisf
	  #define ICD_CLK_PIN_PORT portf
	#endif
	#if (ICD_CLK_PORT == 6)
	  #define ICD_CLK_PIN_TRIS trisg
	  #define ICD_CLK_PIN_PORT portg
	#endif

	//ICD Data Port Defines
	#if (ICD_DATA_PORT == 0)
		#ifdef PORTA
			#define ICD_DATA_PIN_TRIS trisa
			#define ICD_DATA_PIN_PORT porta
		#endif
		#ifdef GPIO
			#define ICD_DATA_PIN_PORT gpio
			#ifdef trisgpio
				#define ICD_DATA_PIN_TRIS trisgpio
			#endif
			#ifdef trisio
				#define ICD_DATA_PIN_TRIS trisio
			#endif
			#ifdef tris
				#define ICD_DATA_PIN_TRIS tris
			#endif
		#endif
	#endif
	#if (ICD_DATA_PORT == 1)
	  #define ICD_DATA_PIN_TRIS trisb
	  #define ICD_DATA_PIN_PORT portb
	#endif
	#if (ICD_DATA_PORT == 2)
	  #define ICD_DATA_PIN_TRIS trisc
	  #define ICD_DATA_PIN_PORT portc
	#endif
	#if (ICD_DATA_PORT == 3)
	  #define ICD_DATA_PIN_TRIS trisd
	  #define ICD_DATA_PIN_PORT portd
	#endif
	#if (ICD_DATA_PORT == 4)
	  #define ICD_DATA_PIN_TRIS trise
	  #define ICD_DATA_PIN_PORT porte
	#endif
	#if (ICD_DATA_PORT == 5)
	  #define ICD_DATA_PIN_TRIS trisf
	  #define ICD_DATA_PIN_PORT portf
	#endif
	#if (ICD_DATA_PORT == 6)
	  #define ICD_DATA_PIN_TRIS trisg
	  #define ICD_DATA_PIN_PORT portg
	#endif

	#ifndef ICD_CLK_PIN_TRIS
	  #warning "Error: no definition for the ICD clock pin"
	#endif

	#ifndef ICD_DATA_PIN_TRIS
	  #warning "Error: no definition for the ICD data pin"
	#endif

	//ICD Global Defines
	#define ICD_START	  0x80
	#define ICD_SETBP	  0x81
	#define ICD_CLRBP	  0x82
	#define ICD_EN_IBP	  0x83
	#define ICD_DIS_IBP	  0x84
	#define ICD_EN_SBP	  0x85
	#define ICD_DIS_SBP	  0x86
	#define ICD_RD_RAM	  0x87
	#define ICD_WR_RAM	  0x88
	#define ICD_GET_ID    0x8C
	#define ICD_GET_STACK 0x8D
	#define ICD_DIS_BPS	  0x8B
	#define ICD_RESET	  0x8E

	#ifdef MX_EE					//If EEPROM
		#define ICD_RD_EE	  0x89
		#define ICD_WR_EE	  0x8A
	#endif

	//ICD Global Variables
	unsigned char dbg_mode = 0x00;
	unsigned char icd_stack_ptr = 0x00;
	unsigned int ICD_TIMEOUT = 10000;

	//ICD Functions
	void FC_MARKER(signed int block_id);
	void ICD_PUSH(char macro_id);
	void ICD_POP();
	unsigned char icd_byte_tx(char data);
	unsigned char icd_byte_rx(void);
	unsigned char wait_clock(char state, char timeout_inc);
	unsigned char wait_data(char state);
	char read_register(unsigned int address);
	void write_register(unsigned int address, char data);
	void rst_dev(void);

	//ICD Marker Functions - Called at the start of every Flowcode block when ICD is enabled.
	void FC_MARKER(signed int block_id)
	{
		unsigned char dbg_hold = 0;
		unsigned char icd_cmd;
		unsigned int address;
		unsigned char int_store = 0;
		unsigned char idx;
		char tempdata = 0;

		set_bit(ICD_CLK_PIN_TRIS, ICD_CLK_PIN);					//Clock is an input
		clear_bit(ICD_DATA_PIN_TRIS, ICD_DATA_PIN);				//Data is an output
		set_bit(ICD_DATA_PIN_PORT, ICD_DATA_PIN);				//Data is default low	****** inverted

		if(test_bit(ICD_CLK_PIN_PORT, ICD_CLK_PIN))				//Test to see if clock input is 1
			dbg_mode = dbg_mode | 0x04;					//Enable ICD Pause
		else
			dbg_mode = dbg_mode & 0xFB;					//Disable ICD Pause

		if(dbg_mode)									//Is ICD Active?
		{
			int_store = intcon;							//Store interrupt register
			intcon = 0;									//Disable all interrupts

			if(dbg_mode & 0x01) dbg_hold = 0x01;		//Test for Single Step operation
			if(dbg_mode & 0x02)							//Test for Breakpoint operation and match
			{
				for(idx=0; idx<ICD_NUM_BPS; idx++)
				{
					if(block_id == *(brk_pnt + idx)) dbg_hold = dbg_hold | 0x02;		//if(block_id == brk_pnt[idx]) dbg_hold = dbg_hold | 0x02;
				}
			}

			if(dbg_mode & 0x04) 								//Test for Flowcode triggered operation
				dbg_hold = dbg_hold | 0x04;

			if(dbg_mode & 0x08) 								//Test for initial stop condition
			{
				dbg_hold = dbg_hold | 0x08;						//Place target into infinite wait mode
				dbg_mode = dbg_mode & 0xF7;						//Disable infinite wait mode for next iteration.
			}

			if(dbg_hold)										//Enter Debug mode
			{
				set_bit(ICD_DATA_PIN_TRIS, ICD_DATA_PIN);		//Data is an input target stopped

				if (dbg_hold & 0x08)
				{
					delay_us(250);								//Wait for pins to settle after reset
					delay_us(250);								//Wait for pins to settle after reset
					wait_clock(1<<ICD_CLK_PIN, 0);				//Wait indefinitely for the next clock
					wait_clock(0, 0);							//Wait indefinitely for the next clock
					wait_clock(1<<ICD_CLK_PIN, 0);				//Wait indefinitely for the next clock
					icd_byte_tx(dbg_mode);						//Send current ICD mode
					icd_byte_tx(block_id);						//Send block ID
					icd_byte_tx(block_id>>8);

				}
				else
				{
					if (wait_clock(1<<ICD_CLK_PIN, 1))			//Wait for clock to go high
						return;
					if (wait_clock(0, 1))						//Wait for clock to go low
						return;
					if (wait_clock(1<<ICD_CLK_PIN, 1))			//Wait for clock to go high
						return;

					if (icd_byte_tx(dbg_mode)) dbg_hold = 0;	//Send current ICD mode
					if (icd_byte_tx(block_id)) dbg_hold = 0;	//Send block ID
					if (icd_byte_tx(block_id>>8)) dbg_hold = 0;
				}

				while(dbg_hold)
				{
					icd_cmd = icd_byte_rx();							//Receive command byte

					switch(icd_cmd)
					{
						case ICD_START:									//Start Command

							dbg_hold = 0;								//Start the target running
							clear_bit(ICD_DATA_PIN_TRIS, ICD_DATA_PIN);				//Data is an output
							set_bit(ICD_DATA_PIN_PORT, ICD_DATA_PIN);				//Data is default low	**** inverted
							wait_clock(0, 1);
							break;

						case ICD_SETBP:						//Set Breakpoint Command

							address = icd_byte_rx();					//Receive BP ID
							address = address | (icd_byte_rx() << 8);
							idx=0;										//Initialise BP counter
							while(idx < ICD_NUM_BPS && *(brk_pnt + idx) != -1)	//Scan for empty BP slot           //while(idx < ICD_NUM_BPS && brk_pnt[idx] != -1)	//Scan for empty BP slot
								idx = idx + 1;

							if (idx == ICD_NUM_BPS)						//If breakpoint command list full
								icd_byte_tx(255);						//Let the ICD know
							else
							{
								*(brk_pnt + idx) = address;					//Else assign the BP ID to the BP list				//brk_pnt[idx] = address;
								icd_byte_tx(0);							//Transmit an acknowledge
							}
							break;

						case ICD_CLRBP:						//Clear Breakpoint Command

							address = icd_byte_rx();
							address = address | (icd_byte_rx() << 8);
							idx=0;										//Initialise BP counter
							while(idx < ICD_NUM_BPS && *(brk_pnt + idx) != address)	//Scan for slot containing BP				//while(idx < ICD_NUM_BPS && brk_pnt[idx] != address)
								idx = idx + 1;

							if (idx == ICD_NUM_BPS)						//If breakpoint not in the list
								icd_byte_tx(255);						//Let the ICD know
							else
							{
								*(brk_pnt + idx) = -1;						//Else clear the BP ID from the BP list					//brk_pnt[idx] = -1;
								icd_byte_tx(0);							//Transmit an acknowledge
							}
							break;

						case ICD_EN_IBP:					//Enable indexed breakpoints Command

							dbg_mode = dbg_mode | 0x02;					//Enable indexed breakpoints
							break;

						case ICD_DIS_IBP:					//Disable indexed breakpoints Command

							dbg_mode = dbg_mode & 0xFD;					//Disable indexed breakpoints
							break;

						case ICD_EN_SBP:					//Enable step breakpoint Command

							dbg_mode = dbg_mode | 0x01;					//Enable step breakpoint
							break;

						case ICD_DIS_SBP:					//Disable step breakpoint Command

							dbg_mode = dbg_mode & 0xFE;					//Disable step breakpoint
							break;

						case ICD_RD_RAM:					//Read Byte Of RAM Command

							address = icd_byte_rx();
							address = address | (icd_byte_rx() << 8);
							icd_byte_tx(read_register(address));		//&address//Transmit the register value
							break;

						case ICD_WR_RAM:					//Write Byte Of RAM Command

							address = icd_byte_rx();
							address = address | (icd_byte_rx() << 8);
							write_register(address, icd_byte_rx());
							break;

						case ICD_DIS_BPS:					//Clear all breakpoints

							idx=0;	//init BP counter
							while (idx < ICD_NUM_BPS)
							{
								*(brk_pnt + idx) = -1;											//brk_pnt[idx] = -1;
								idx = idx + 1;
							}
							break;

						#ifdef MX_EE						//Is EEPROM Available?
							#ifdef _BOOSTC
								#ifndef MX_EEADR
									#ifdef EEADR
										#define MX_EEADR eeadr
									#endif
									#ifdef EEADRL
										#define MX_EEADR eeadrl
									#endif
								#endif
								#ifndef MX_EEDATA
									#ifdef EEDATA
										#define MX_EEDATA eedata
									#endif
									#ifdef EEDATAL
										#define MX_EEDATA eedatal
									#endif
								#endif
							#endif

							case ICD_RD_EE:					//Read Contents Of EEPROM Command

								address = icd_byte_rx();
								address = address | (icd_byte_rx() << 8);

								#ifdef _BOOSTC
									MX_EEADR = address & 0xff;
									#if (MX_EE_SIZE > 256)
										eeadrh = (address & 0xff00) >> 8;
									#endif
									#ifdef MX_EE_TYPE2
										cr_bit(eecon1, EEPGD);
									#endif
									#ifdef MX_EE_TYPE3
										cr_bit(eecon1, EEPGD);
										cr_bit(eecon1, CFGS);
									#endif
										st_bit(eecon1, RD);

									icd_byte_tx(MX_EEDATA);
								#endif
								#ifdef HI_TECH_C
									icd_byte_tx(eeprom_read(address));
								#endif
								break;

							case ICD_WR_EE:					//Write Byte to EEPROM Command

								address = icd_byte_rx();
								address = address | (icd_byte_rx() << 8);
								tempdata = icd_byte_rx();

								#ifdef _BOOSTC
									while (ts_bit(eecon1, WR));				//wait for previous EE writes to complete...

									#if (MX_EE_SIZE > 256)
										eeadrh = (address & 0xff00) >> 8;
									#endif

									MX_EEADR = address & 0xff;
									MX_EEDATA = tempdata;

									#ifdef MX_EE_TYPE2
										cr_bit(eecon1, EEPGD);
									#endif
									#ifdef MX_EE_TYPE3
										cr_bit(eecon1, EEPGD);
										cr_bit(eecon1, CFGS);
									#endif

									st_bit(eecon1, WREN);
									eecon2 = 0x55;
									eecon2 = 0xAA;
									st_bit(eecon1, WR);
									while (ts_bit(eecon1, WR));				//wait for EE write to complete...
								#endif
								#ifdef HI_TECH_C
									eeprom_write(address, tempdata);
								#endif

								break;

						#endif								//End of EEPROM code

						case ICD_GET_ID:
							icd_byte_tx(ICD_ID0);
							icd_byte_tx(ICD_ID1);
							icd_byte_tx(ICD_ID2);
							icd_byte_tx(ICD_ID3);
							icd_byte_tx(ICD_ID4);
							icd_byte_tx(ICD_ID5);
							icd_byte_tx(ICD_ID6);
							icd_byte_tx(ICD_ID7);
							break;

						case ICD_GET_STACK:
							icd_byte_tx(ICD_STACK_SIZE+1);		//+1 because the PPP firmware does not expect the stack pointer return as well
							icd_byte_tx(icd_stack_ptr);
							for (idx=0; idx<ICD_STACK_SIZE; idx++)
							{
								icd_byte_tx(*(icd_stack + idx));											//icd_byte_tx(icd_stack[idx]);
							}
							break;

						case ICD_RESET:
							rst_dev();
							break;

						default:
							break;
					}
				}
			}
			clear_bit(ICD_DATA_PIN_TRIS,ICD_DATA_PIN);				//Data line as output
			set_bit(ICD_DATA_PIN_PORT,ICD_DATA_PIN);				//Data output low	**** inverted
			intcon = int_store;										//Restore all interrupts
		}
	}


	void ICD_PUSH(char macro_id)
	{
		//note: there is no specific stack overflow test here (there will be at the PC end though)
		if (icd_stack_ptr < ICD_STACK_SIZE)
		{
			*(icd_stack + icd_stack_ptr) = macro_id;			//Assign macro ID				//icd_stack[icd_stack_ptr] = macro_id;
		}
		icd_stack_ptr++;									//Move to next layer of stack
	}


	void ICD_POP()
	{
		//note: there is no specific stack underflow test here (there will be at the PC end though)
		icd_stack_ptr--;
	}


	//ICD transmit byte Function - Bit bangs out a data byte.
	char icd_byte_tx(char data)
	{
		char count, mask;

		set_bit(ICD_CLK_PIN_TRIS,ICD_CLK_PIN);				//Clock line as input
		clear_bit(ICD_DATA_PIN_TRIS,ICD_DATA_PIN);			//Data line as output
		set_bit(ICD_DATA_PIN_PORT,ICD_DATA_PIN);			//Data is 0 RTS		**** inverted

		if (wait_clock(0, 1))							//Wait for clock to go low
			return 255;

		for(count=0; count<8; count++)
		{
			mask = data & 0x01;						//Prepare data
			if(mask)								//Write data onto data line
				clear_bit(ICD_DATA_PIN_PORT,ICD_DATA_PIN);			// **** inverted
			else
				set_bit(ICD_DATA_PIN_PORT,ICD_DATA_PIN);			// **** inverted
			data = data >> 1;
			if (wait_clock(1<<ICD_CLK_PIN, 1))				//Wait for clock to go high
				return 254;
			if (wait_clock(0, 1))						//Wait for clock to go low
				return 253;
		}

		set_bit(ICD_DATA_PIN_TRIS,ICD_DATA_PIN);					//Data line as input end of byte
		if (wait_data(0))							//Wait for byte acknowledge
				return 252;
		if (wait_clock(1<<ICD_CLK_PIN, 1))					//Wait for byte acknowledge end
				return 251;
		return 0;									//Success!
	}



	//ICD receive byte Function - Collects a bit banged serial data byte.
	char icd_byte_rx(void)
	{
		unsigned char data = 0;
		unsigned char count;

		set_bit(ICD_DATA_PIN_TRIS,ICD_DATA_PIN);			//Data line as input
		set_bit(ICD_CLK_PIN_TRIS,ICD_CLK_PIN);				//Clock line as input
		for(count=0; count<8; count++)				//Receive Byte
		{
			data = data >> 1;
			if (wait_clock(0, 1))						//Wait for clock to go low
				return 0;

			if (test_bit(ICD_DATA_PIN_PORT,ICD_DATA_PIN) == 0) 		//Read incoming data on data pin	**** inverted
				data = data | 0x80;

			if (wait_clock(1<<ICD_CLK_PIN, 1))				//Wait for clock to go high
				return 0;
		}

		if (wait_data(1<<ICD_DATA_PIN))					//Wait for data to go high
			return 0;

		if (wait_clock(0, 1))							//Wait for clock to go low
			return 0;

		clear_bit(ICD_DATA_PIN_TRIS, ICD_DATA_PIN);				//ICD data is an output
		set_bit(ICD_DATA_PIN_PORT, ICD_DATA_PIN);				//ICD data 0 send Ack		**** inverted

		if (wait_clock(1<<ICD_CLK_PIN, 1))					//Wait for clock to go high
			return 0;

		set_bit(ICD_DATA_PIN_TRIS, ICD_DATA_PIN);				//ICD data clear ack
		return(data);
	}


	char wait_clock(char state, char timeout_inc)
	{
		unsigned int timeout = 0;

		while ((test_bit(ICD_CLK_PIN_PORT,ICD_CLK_PIN) != state) && (timeout < ICD_TIMEOUT))	//Wait for clk
			timeout = timeout +  timeout_inc;		//Increment time out

		if (timeout == ICD_TIMEOUT)					//Has the routine timed out
			return 1;
		return 0;
	}


	char wait_data(char state)
	{
		unsigned int timeout = 0;
		while ((test_bit(ICD_DATA_PIN_PORT, ICD_DATA_PIN) == state) && (timeout < ICD_TIMEOUT))	//Wait for data		**** inverted
			timeout = timeout +  1;					//Increment time out

		if (timeout == ICD_TIMEOUT)					//Has the routine timed out
			return 1;
		return 0;
	}


	char read_register(unsigned int address)
	{
		char RetVal;

		volatile char* register_ptr = (char*)address;

		RetVal = *register_ptr;

		return RetVal;
	}


	void write_register(unsigned int address, char data)
	{
		volatile char* register_ptr = (char*)address;

		*register_ptr = data;
	}


	void rst_dev()
	{
		//Disable all interrupts
		intcon = 0;
		#ifdef PIE1 | pie1
			pie1 = 0x00;
		#endif
		#ifdef PIE2 | pie2
			pie2 = 0x00;
		#endif

		//Reset all port pins back to inputs
		#ifdef PORTA | porta
			trisa = 0xff;
			porta = 0x00;
		#endif
		#ifdef GPIO | gpio
			gpio = 0x00;
			#ifdef TRISGPIO | trisgpio
				trisgpio = 0xff;
			#endif
			#ifdef TRISIO | trisio
				trisio = 0xff;
			#endif
			#ifdef TRIS | tris
				tris = 0xff;
			#endif
		#endif
		#ifdef PORTB | portb
			trisb = 0xff;
			portb = 0x00;
		#endif
		#ifdef PORTC | portc
			trisc = 0xff;
			portc = 0x00;
		#endif
		#ifdef PORTD | portd
			trisd = 0xff;
			portd = 0x00;
		#endif
		#ifdef PORTE | porte
			trise = 0xff;
			porte = 0x00;
		#endif
		#ifdef PORTF | portf
			trisf = 0xff;
			portf = 0x00;
		#endif

		//Software Reset
		//reset();			//Supported in BoostC & HITECH
	}

//End of ICD functionality
#endif


void Wdt_msDelay(void)

{
	char i;
	for (i=0; i<75; i++)		//(99 x 10us) + Overhead = 1ms
0023  1283  	BCF STATUS, RP0
0024  1303  	BCF STATUS, RP1
0025  01E6  	CLRF Wdt_msDela_00045_1_i
0026        label4
0026  304B  	MOVLW 0x4B
0027  0266  	SUBWF Wdt_msDela_00045_1_i, W
0028  1803  	BTFSC STATUS,C
002E  0AE6  	INCF Wdt_msDela_00045_1_i, F
002F  2826  	GOTO	label4

	{
		MX_CLEAR_WATCHDOG;		//Clear Watchdog Timer
002A  0064  	CLRWDT

		delay_us(10);
002B  300A  	MOVLW 0x0A
002C  00E7  	MOVWF delay_us_00000_arg_del
002D  2010  	CALL delay_us_00000

	}
}
0029  0008  	RETURN



void Wdt_Delay_S(short delay)
{
	short i, j;
	for (i=0; i<delay; i++)
	{
		for (j=0; j<1000; j++)
			Wdt_msDelay();
	}
}


void Wdt_Delay_Ms(short delay)

{
	short i;
	for (i=0; i<delay; i++)
0030  01E4  	CLRF Wdt_Delay__00047_1_i
0031  01E5  	CLRF Wdt_Delay__00047_1_i+D'1'
0032        label5
0032  0865  	MOVF Wdt_Delay__00047_1_i+D'1', W
0033  3A80  	XORLW 0x80
0034  00E6  	MOVWF CompTempVar2178
0035  0863  	MOVF Wdt_Delay__00047_arg_delay+D'1', W
0036  3A80  	XORLW 0x80
0037  0266  	SUBWF CompTempVar2178, W
0038  1D03  	BTFSS STATUS,Z
0039  283C  	GOTO	label6
003A  0862  	MOVF Wdt_Delay__00047_arg_delay, W
003B  0264  	SUBWF Wdt_Delay__00047_1_i, W
003C        label6
003C  1803  	BTFSC STATUS,C
003F  0AE4  	INCF Wdt_Delay__00047_1_i, F
0040  1903  	BTFSC STATUS,Z
0041  0AE5  	INCF Wdt_Delay__00047_1_i+D'1', F
0042  2832  	GOTO	label5

		Wdt_msDelay();
003E  2023  	CALL Wdt_msDela_00045

}
003D  0008  	RETURN



char FCI_FLOAT_TO_STRING(float Number, char Precision, char* String, char MSZ_String)
{
	int whole;
	char str_length;
	char idx;
	char stringidx = 0;
	float real, temp;
	char old;
	char temp_string[10];

	#ifdef _BOOSTC									//BoostC Floating Point

		float_rounding_mode = 3;					//Always round to zero
		whole = float32_to_int32(Number);			//Convert to whole integer
		temp = float32_from_int32(whole);			//Convert whole number back to floating point

		if (float32_ge(Number,0))
		{
			real = float32_sub(Number, temp);		//Subtract whole number from floating point number
		}
		else
		{
			if (whole == 0)							//Fix -0 bug
			{
				String[stringidx] = '-';
				stringidx = stringidx + 1;
			}

			real = float32_sub(temp, Number);		//Subtract floating point number from whole number
		}
	#endif

	#ifdef HI_TECH_C								//HiTECH Floating Point

		whole = (int)Number;						//Convert to whole integer
		temp = whole;								//Convert whole number back to floating point

		if (Number >= 0)
		{
			real = Number - temp;					//Subtract whole number from floating point number
		}
		else
		{
			if (whole == 0)							//Fix -0 bug
			{
				String[stringidx] = '-';
				stringidx = stringidx + 1;
			}

			real = temp - Number;					//Subtract floating point number from whole number
		}
	#endif

	str_length = FCI_TOSTRING(whole, temp_string, 5);		//Convert integer numbers to strings

	for (idx=0; idx<str_length; idx++)						//Copy whole part of number to string
	{
		if(stringidx < MSZ_String)
		{
			String[stringidx] = temp_string[idx];
			stringidx = stringidx + 1;
		}
	}

	if(stringidx < MSZ_String)						//Add decimal point to string
	{
		String[stringidx] = '.';
		stringidx = stringidx + 1;
	}

	for (idx = 0; idx < Precision; idx++)			//Output Real Part Of Number
	{
		if (stringidx >= MSZ_String)
			break;

		#ifdef _BOOSTC								//BoostC Floating Point
			real = float32_mul(real, 10);
			whole = float32_to_int32(real);			//Convert to whole integer
			temp = float32_from_int32(whole);		//Convert whole number back to floating point
			real = float32_sub(real, temp);			//Subtract whole number from floating point number
		#endif
		#ifdef HI_TECH_C							//HiTECH Floating Point
			real = real * 10;
			whole = (int)real;						//Convert to whole integer
			temp = whole;							//Convert whole number back to floating point
			real = real - temp;						//Subtract whole number from floating point number
		#endif

		String[stringidx] = '0' + whole;
		stringidx = stringidx + 1;
	}

	if(stringidx < MSZ_String)									//Add null termination to string
	{
		String[stringidx] = 0;
	}

	return stringidx;
}


char FCI_NUMBER_TO_HEX(short Number, char* String, char MSZ_String)
{
	char stringidx;
	char idx = 0;
	char temp;
	char digit[4] = {0,0,0,0};
	unsigned int num;

	//Check that output string is long enough to store result
	if(Number < 256 && MSZ_String < 4)
		return 0;

	if(Number > 255 && MSZ_String < 6)
		return 0;

	//Initialise start of string with hexadecimal indicator
	String[0] = '0';
	String[1] = 'x';

	//Number is positive
	if(Number < 0)
	{
		num = 0 - Number;
		num = 0xFFFF - (num - 1);
	}
	else
		num = Number;

	//Calculate hex values
	while (num > 0)
	{
		temp = num % 16;
		num = num / 16;

		if(temp > 9)
		{
			temp = temp - 10;
			digit[idx] = temp + 'A';
		}
		else
			digit[idx] = temp + '0';

		idx = idx + 1;
	}

	//Copy Hex values over to output string
	for (stringidx = 2; stringidx < (idx + 2); stringidx++)
		String[stringidx] = digit[idx - (stringidx - 1)];

	//Add null termination to string
	if(stringidx < MSZ_String)
	{
		String[stringidx] = 0;
	}

	return stringidx;
}


short FCI_STRING_TO_INT(char* String, char MSZ_String)
{
	char bNegative = 0;
	char idx = 0;
	short RetVal = 0;

	//Is number negative
	if(String[0] == '-')
	{
		bNegative = 1;
		idx = 1;
	}

	//While string contains a valid number
	while (idx < MSZ_String && String[idx] >= '0' && String[idx] <= '9')
	{
		//Pull character from string and add to running total
		RetVal = RetVal * 10;
		RetVal = RetVal + (String[idx] - '0');
		idx = idx + 1;
	}

	if (bNegative)
		RetVal = 0 - RetVal;

	return RetVal;
}


float FCI_STRING_TO_FLOAT(char* String, char MSZ_String)
{
	float RetVal = 0;
	float real_divider = 1;
	int whole, real;
	char idx = 0;
	char idx2 = 0;
	char offset = 0;
	char bNegative = 0;
	char Comp_String[8];

	//Is number negative
	if(String[0] == '-')
	{
		bNegative = 1;
		offset = 1;
	}

	//Scan for decimal point
	for(idx=offset; idx<MSZ_String; idx++)
	{
		if(String[idx] == '.')
			break;
	}

	//Convert whole portion of number from string
	whole = FCI_STRING_TO_INT (String, idx);

	//No decimal point found
	if(idx == MSZ_String)
	{
		#ifdef _BOOSTC
			RetVal = float32_from_int32(whole);
		#endif
		#ifdef HI_TECH_C
			RetVal = (int)whole;
		#endif
		return RetVal;
	}

	//Collect real portion of number into new string
	offset = idx + 1;
	for(idx=offset; idx<MSZ_String; idx++)
	{
		if(String[idx] >= '0' && String[idx] <= '9')
		{
			Comp_String[idx - offset] = String[idx];
			#ifdef _BOOSTC
				real_divider = float32_mul(real_divider, 0.1);
			#endif
			#ifdef HI_TECH_C
				real_divider = real_divider * 0.1;
			#endif
		}
		else
			break;
	}

	//Convert real portion of number from string
	real = FCI_STRING_TO_INT (Comp_String, (idx - offset));

	//Adjust weighting of values and combine into one float variable
	#ifdef _BOOSTC

		RetVal = float32_from_int32(real);
		RetVal = float32_mul(RetVal, real_divider);
		real_divider = float32_from_int32(whole);
		RetVal = float32_add(RetVal, real_divider);

		if (bNegative)
			RetVal = float32_sub(0, RetVal);

	#endif
	#ifdef HI_TECH_C

		RetVal = (float)real;
		RetVal = RetVal * real_divider;
		real_divider = (float)whole;
		RetVal = RetVal + real_divider;

		if (bNegative)
			RetVal = 0 - RetVal;
	#endif

	return RetVal;
}


char isinf(float f)
{
      char* b;
      b = (char*)&f;
      if ((b[0] == 0)   &&
          (b[1] == 0)   &&
          (b[2] == 128) &&
          ((b[3] & 127) == 127))
      {
            return (255);
      }
      return (0);
}

#endif

//************************************************************************************
//**  
//**  File name:     C:\Users\gerpe\OneDrive\GER-PER 2016\Documents\KennyNeutron\USART\USARTTEST.c
//**  Generated by:  Flowcode v4.2.3.58
//**  Date:          Saturday, July 27, 2019 15:04:23
//**  Licence:       Professional
//**  Registered to: 20ACM8
//**  
//**  
//**  http://www.matrixmultimedia.com
//************************************************************************************


#define MX_PIC

//Defines for microcontroller
#define P16F690
#define MX_EE
#define MX_EE_SIZE 256
#define MX_SPI
#define MX_SPI_BCB
#define MX_SPI_SDI 4
#define MX_SPI_SDO 7
#define MX_SPI_SCK 6
#define MX_UART
#define MX_UART_B
#define MX_UART_TX 7
#define MX_UART_RX 5
#define MX_I2C
#define MX_MI2C
#define MX_I2C_B
#define MX_I2C_SDA 4
#define MX_I2C_SCL 6
#define MX_PWM
#define MX_PWM_CNT 1
#define MX_PWM_TRIS1 trisc
#define MX_PWM_1 5

//Functions
#define MX_CLK_SPEED 20000000
#ifdef _BOOSTC
#include <system.h>
#endif
#ifdef HI_TECH_C
#include <pic.h>
#endif

//Configuration data
#ifdef _BOOSTC
#pragma DATA 0x2007, 0x30f2
#endif
#ifdef HI_TECH_C
__CONFIG(0x30f2);
#endif

//Internal functions
#include "C:\Program Files (x86)\Matrix Multimedia\Flowcode V4\FCD\internals.h"

//Macro function declarations


//Variable declarations
#define FCSZ_DAT 26
char FCV_DAT[FCSZ_DAT];
char FCV_DATBYTE;


//Defines:

/**** Macro Substitutions ****
portc = D1 Port
trisc = D1 Data Direction
portc = D2 Port
trisc = D2 Data Direction
portc = D3 Port
trisc = D3 Data Direction
portc = D4 Port
trisc = D4 Data Direction
portc = RS Port
trisc = RS Data Direction
portc = E Port
trisc = E Data Direction
5 = Data 1_Pin
3 = Data 2 Pin
4 = Data 3 Pin
2 = Data 4 Pin
0 = RS Pin
1 = Enable Pin
LCD_66844 = Unique Component Reference Number
4 = Row Count
16 = Column Count
******************************/

	//component connections
	#define LCD_66844_PORT0    portc
	#define LCD_66844_TRIS0    trisc
	#define LCD_66844_PORT1    portc
	#define LCD_66844_TRIS1    trisc
	#define LCD_66844_PORT2    portc
	#define LCD_66844_TRIS2    trisc
	#define LCD_66844_PORT3    portc
	#define LCD_66844_TRIS3    trisc
	#define LCD_66844_PORT4    portc
	#define LCD_66844_TRIS4    trisc
	#define LCD_66844_PORT5    portc
	#define LCD_66844_TRIS5    trisc
	#define LCD_66844_BIT0    	5
	#define LCD_66844_BIT1    	3
	#define LCD_66844_BIT2    	4
	#define LCD_66844_BIT3    	2
	#define LCD_66844_RS      	0
	#define LCD_66844_E       	1
	#define LCD_66844_ROWCNT	4
	#define LCD_66844_COLCNT	16

	#ifdef _BOOSTC
	  #define LCD_66844_DELAY   delay_10us(10)
	#endif
	#ifdef _C2C_
	  #define LCD_66844_DELAY   delay_us(100)
	#endif
	#ifdef HI_TECH_C
	  #define LCD_66844_DELAY   __delay_us(120)
	#endif
	#ifndef LCD_66844_DELAY
	  #define LCD_66844_DELAY   delay_us(100)
	#endif




//LCDDisplay0: //Macro function declarations

void FCD_LCDDisplay0_RawSend(char in, char mask);
void FCD_LCDDisplay0_Start();
void FCD_LCDDisplay0_Clear();
void FCD_LCDDisplay0_PrintASCII(char Character);
void FCD_LCDDisplay0_Command(char in);
void FCD_LCDDisplay0_Cursor(char x, char y);
void FCD_LCDDisplay0_PrintNumber(short Number);
void FCD_LCDDisplay0_PrintString(char* String, char MSZ_String);
void FCD_LCDDisplay0_ScrollDisplay(char Direction, char Num_Positions);
void FCD_LCDDisplay0_ClearLine(char Line);
void FCD_LCDDisplay0_RAM_Write(char nIdx, char d0, char d1, char d2, char d3, char d4, char d5, char d6, char d7);
//Defines:

/**** Macro Substitutions ****
portc = RTS Port
trisc = RTS Data Direction
portc = CTS Port
trisc = CTS Data Direction
0 = RTS Pin
4 = CTS Pin
1 = UART Selection		(0-SW / 1-UART1 / 2-UART2)
0 = Flow Control		(0-Off / 1-On)
0 = Debug Enable		(0-Off / 1-On)
0 = Echo Enable		(0-Off / 1-On)
4 = UART TXSTA Value
129 = UART SPBRG Value
RS232_66846 = Unique ID
Unused = Bitbanged Receive Port Register
Unused = Bitbanged Receive Data Direction Register
Unused = Bitbanged Receive Pin
Unused = Bitbanged Transmit Pin
38 = Bitbanged BAUD Rate Delay
0 = Timout	Selection	(0-Legacy / 1-MS Timeout)
0 = Data Size			(0-8 bits / 1-9 bits / 2-7 bits & Only available on BitBanged components)
0 = Parity Enable		(0-No Parity / 1-Odd Parity / 2-Even Parity)
0 = Legacy Return		(0-Legacy mode return 255 / 1-New mode return MSB err flags)
Unused = Bitbanged Transmit Port Register
Unused = Bitbanged Transmit Data Direction Register
******************************/

#define RS232_66846_RTS_PORT			portc
#define RS232_66846_RTS_TRIS			trisc
#define RS232_66846_CTS_PORT			portc
#define RS232_66846_CTS_TRIS			trisc
#define RS232_66846_RTS_PIN			0
#define RS232_66846_CTS_PIN			4
#define RS232_66846_UART				1
#define RS232_66846_TOUT  			0
#define RS232_66846_DATASIZE			0
#define RS232_66846_PARITY			0
#define RS232_66846_LEGACY_RV			0

#if (0 == 1)
  	#define RS232_66846_HARDWARE
#endif

#if (0 == 1)
  	#define RS232_66846_DEBUG
#endif

#if (0 == 1)
  	#define RS232_66846_ECHO
#endif

#if (RS232_66846_UART == 0)
	#define RS232_66846_RX_PORT		Unused
	#define RS232_66846_RX_TRIS		Unused
	#define RS232_66846_SW_RX		Unused
	#define RS232_66846_SW_TX		Unused
	#define RS232_66846_SW_BAUD		38
	#define RS232_66846_TX_PORT		Unused
	#define RS232_66846_TX_TRIS		Unused
#else
	#define RS232_66846_TXSTA_VAL  	4
	#define RS232_66846_SPBRG_VAL  	129
	#define RS232_66846_SW_BAUD		0
#endif

#if (RS232_66846_LEGACY_RV == 0)
	#if (RS232_66846_DATASIZE == 1)
		#pragma error "RS232 Component cannot combine 9-bit data mode with legacy return value of 255 please check the Component properties"
	#endif
#endif

#define RS232_66846_STATUS_LOOP		0
#define RS232_66846_STATUS_TIMEOUT	1
#define RS232_66846_STATUS_RXBYTE	2





//RS2320: //Macro function declarations

void FCD_RS2320_SendRS232Char(short nChar);
void FCD_RS2320_SendRS232String(char* String, char MSZ_String);
short FCD_RS2320_ReceiveRS232Char(short nTimeout);
void FCD_RS2320_ReceiveRS232String(char* FCR_RETVAL, char FCR_RETVAL_SIZE, char nTimeout, char NumBytes);
void FCD_RS2320_RS232_Delay(char mode);



//LCDDisplay0: //Macro implementations


void FCD_LCDDisplay0_RawSend(char in, char mask)

{
		unsigned char pt;

		clear_bit(LCD_66844_PORT0, LCD_66844_BIT0);
0043  1283  	BCF STATUS, RP0
0044  1303  	BCF STATUS, RP1
0045  1287  	BCF gbl_portc,5

		clear_bit(LCD_66844_PORT1, LCD_66844_BIT1);
0046  1187  	BCF gbl_portc,3

		clear_bit(LCD_66844_PORT2, LCD_66844_BIT2);
0047  1207  	BCF gbl_portc,4

		clear_bit(LCD_66844_PORT3, LCD_66844_BIT3);
0048  1107  	BCF gbl_portc,2

		clear_bit(LCD_66844_PORT4, LCD_66844_RS);
0049  1007  	BCF gbl_portc,0

		clear_bit(LCD_66844_PORT5, LCD_66844_E);
004A  1087  	BCF gbl_portc,1

		pt = ((in >> 4) & 0x0f);
004B  0E70  	SWAPF FCD_LCDDis_00048_arg_in, W
004C  390F  	ANDLW 0x0F
004D  00F2  	MOVWF FCD_LCDDis_00048_1_pt
004E  300F  	MOVLW 0x0F
004F  05F2  	ANDWF FCD_LCDDis_00048_1_pt, F

		if (pt & 0x01)
0050  1872  	BTFSC FCD_LCDDis_00048_1_pt,0

		    set_bit(LCD_66844_PORT0, LCD_66844_BIT0);
0051  1687  	BSF gbl_portc,5

		if (pt & 0x02)
0052  18F2  	BTFSC FCD_LCDDis_00048_1_pt,1

		    set_bit(LCD_66844_PORT1, LCD_66844_BIT1);
0053  1587  	BSF gbl_portc,3

		if (pt & 0x04)
0054  1972  	BTFSC FCD_LCDDis_00048_1_pt,2

		    set_bit(LCD_66844_PORT2, LCD_66844_BIT2);
0055  1607  	BSF gbl_portc,4

		if (pt & 0x08)
0056  19F2  	BTFSC FCD_LCDDis_00048_1_pt,3

		    set_bit(LCD_66844_PORT3, LCD_66844_BIT3);
0057  1507  	BSF gbl_portc,2

		if (mask)
0058  08F1  	MOVF FCD_LCDDis_00048_arg_mask, F
0059  1D03  	BTFSS STATUS,Z

		    set_bit(LCD_66844_PORT4, LCD_66844_RS);
005A  1407  	BSF gbl_portc,0

		LCD_66844_DELAY;
005B  300A  	MOVLW 0x0A
005C  00F3  	MOVWF delay_10us_00000_arg_del
005D  2015  	CALL delay_10us_00000

		set_bit (LCD_66844_PORT5, LCD_66844_E);
005E  1487  	BSF gbl_portc,1

		LCD_66844_DELAY;
005F  300A  	MOVLW 0x0A
0060  00F3  	MOVWF delay_10us_00000_arg_del
0061  2015  	CALL delay_10us_00000

		clear_bit (LCD_66844_PORT5, LCD_66844_E);
0062  1087  	BCF gbl_portc,1

		pt = (in & 0x0f);
0063  300F  	MOVLW 0x0F
0064  0570  	ANDWF FCD_LCDDis_00048_arg_in, W
0065  00F2  	MOVWF FCD_LCDDis_00048_1_pt

		LCD_66844_DELAY;
0066  300A  	MOVLW 0x0A
0067  00F3  	MOVWF delay_10us_00000_arg_del
0068  2015  	CALL delay_10us_00000

		clear_bit(LCD_66844_PORT0, LCD_66844_BIT0);
0069  1287  	BCF gbl_portc,5

		clear_bit(LCD_66844_PORT1, LCD_66844_BIT1);
006A  1187  	BCF gbl_portc,3

		clear_bit(LCD_66844_PORT2, LCD_66844_BIT2);
006B  1207  	BCF gbl_portc,4

		clear_bit(LCD_66844_PORT3, LCD_66844_BIT3);
006C  1107  	BCF gbl_portc,2

		clear_bit(LCD_66844_PORT4, LCD_66844_RS);
006D  1007  	BCF gbl_portc,0

		clear_bit(LCD_66844_PORT5, LCD_66844_E);
006E  1087  	BCF gbl_portc,1

		if (pt & 0x01)
006F  1872  	BTFSC FCD_LCDDis_00048_1_pt,0

		    set_bit(LCD_66844_PORT0, LCD_66844_BIT0);
0070  1687  	BSF gbl_portc,5

		if (pt & 0x02)
0071  18F2  	BTFSC FCD_LCDDis_00048_1_pt,1

		    set_bit(LCD_66844_PORT1, LCD_66844_BIT1);
0072  1587  	BSF gbl_portc,3

		if (pt & 0x04)
0073  1972  	BTFSC FCD_LCDDis_00048_1_pt,2

		    set_bit(LCD_66844_PORT2, LCD_66844_BIT2);
0074  1607  	BSF gbl_portc,4

		if (pt & 0x08)
0075  19F2  	BTFSC FCD_LCDDis_00048_1_pt,3

		    set_bit(LCD_66844_PORT3, LCD_66844_BIT3);
0076  1507  	BSF gbl_portc,2

		if (mask)
0077  08F1  	MOVF FCD_LCDDis_00048_arg_mask, F
0078  1D03  	BTFSS STATUS,Z

		    set_bit(LCD_66844_PORT4, LCD_66844_RS);
0079  1407  	BSF gbl_portc,0

		LCD_66844_DELAY;
007A  300A  	MOVLW 0x0A
007B  00F3  	MOVWF delay_10us_00000_arg_del
007C  2015  	CALL delay_10us_00000

		set_bit (LCD_66844_PORT5, LCD_66844_E);
007D  1487  	BSF gbl_portc,1

		LCD_66844_DELAY;
007E  300A  	MOVLW 0x0A
007F  00F3  	MOVWF delay_10us_00000_arg_del
0080  2015  	CALL delay_10us_00000

		clear_bit (LCD_66844_PORT5, LCD_66844_E);
0081  1087  	BCF gbl_portc,1

		LCD_66844_DELAY;
0082  300A  	MOVLW 0x0A
0083  00F3  	MOVWF delay_10us_00000_arg_del
0084  2015  	CALL delay_10us_00000

}
0085  0008  	RETURN


void FCD_LCDDisplay0_Start()

{
	
		clear_bit(LCD_66844_TRIS0, LCD_66844_BIT0);
0175  1683  	BSF STATUS, RP0
0176  1303  	BCF STATUS, RP1
0177  1287  	BCF gbl_trisc,5

		clear_bit(LCD_66844_TRIS1, LCD_66844_BIT1);
0178  1187  	BCF gbl_trisc,3

		clear_bit(LCD_66844_TRIS2, LCD_66844_BIT2);
0179  1207  	BCF gbl_trisc,4

		clear_bit(LCD_66844_TRIS3, LCD_66844_BIT3);
017A  1107  	BCF gbl_trisc,2

		clear_bit(LCD_66844_TRIS4, LCD_66844_RS);
017B  1007  	BCF gbl_trisc,0

		clear_bit(LCD_66844_TRIS5, LCD_66844_E);
017C  1087  	BCF gbl_trisc,1


		Wdt_Delay_Ms(12);
017D  300C  	MOVLW 0x0C
017E  1283  	BCF STATUS, RP0
017F  00E2  	MOVWF Wdt_Delay__00047_arg_delay
0180  01E3  	CLRF Wdt_Delay__00047_arg_delay+D'1'
0181  2030  	CALL Wdt_Delay__00047


		FCD_LCDDisplay0_RawSend(0x33, 0);
0182  3033  	MOVLW 0x33
0183  00F0  	MOVWF FCD_LCDDis_00048_arg_in
0184  01F1  	CLRF FCD_LCDDis_00048_arg_mask
0185  2043  	CALL FCD_LCDDis_00048

		Wdt_Delay_Ms(2);
0186  3002  	MOVLW 0x02
0187  00E2  	MOVWF Wdt_Delay__00047_arg_delay
0188  01E3  	CLRF Wdt_Delay__00047_arg_delay+D'1'
0189  2030  	CALL Wdt_Delay__00047

		FCD_LCDDisplay0_RawSend(0x33, 0);
018A  3033  	MOVLW 0x33
018B  00F0  	MOVWF FCD_LCDDis_00048_arg_in
018C  01F1  	CLRF FCD_LCDDis_00048_arg_mask
018D  2043  	CALL FCD_LCDDis_00048

		Wdt_Delay_Ms(2);
018E  3002  	MOVLW 0x02
018F  00E2  	MOVWF Wdt_Delay__00047_arg_delay
0190  01E3  	CLRF Wdt_Delay__00047_arg_delay+D'1'
0191  2030  	CALL Wdt_Delay__00047

		FCD_LCDDisplay0_RawSend(0x32, 0);
0192  3032  	MOVLW 0x32
0193  00F0  	MOVWF FCD_LCDDis_00048_arg_in
0194  01F1  	CLRF FCD_LCDDis_00048_arg_mask
0195  2043  	CALL FCD_LCDDis_00048

		Wdt_Delay_Ms(2);
0196  3002  	MOVLW 0x02
0197  00E2  	MOVWF Wdt_Delay__00047_arg_delay
0198  01E3  	CLRF Wdt_Delay__00047_arg_delay+D'1'
0199  2030  	CALL Wdt_Delay__00047

		FCD_LCDDisplay0_RawSend(0x2c, 0);
019A  302C  	MOVLW 0x2C
019B  00F0  	MOVWF FCD_LCDDis_00048_arg_in
019C  01F1  	CLRF FCD_LCDDis_00048_arg_mask
019D  2043  	CALL FCD_LCDDis_00048

		Wdt_Delay_Ms(2);
019E  3002  	MOVLW 0x02
019F  00E2  	MOVWF Wdt_Delay__00047_arg_delay
01A0  01E3  	CLRF Wdt_Delay__00047_arg_delay+D'1'
01A1  2030  	CALL Wdt_Delay__00047

		FCD_LCDDisplay0_RawSend(0x06, 0);
01A2  3006  	MOVLW 0x06
01A3  00F0  	MOVWF FCD_LCDDis_00048_arg_in
01A4  01F1  	CLRF FCD_LCDDis_00048_arg_mask
01A5  2043  	CALL FCD_LCDDis_00048

		Wdt_Delay_Ms(2);
01A6  3002  	MOVLW 0x02
01A7  00E2  	MOVWF Wdt_Delay__00047_arg_delay
01A8  01E3  	CLRF Wdt_Delay__00047_arg_delay+D'1'
01A9  2030  	CALL Wdt_Delay__00047

		FCD_LCDDisplay0_RawSend(0x0c, 0);
01AA  300C  	MOVLW 0x0C
01AB  00F0  	MOVWF FCD_LCDDis_00048_arg_in
01AC  01F1  	CLRF FCD_LCDDis_00048_arg_mask
01AD  2043  	CALL FCD_LCDDis_00048

		Wdt_Delay_Ms(2);
01AE  3002  	MOVLW 0x02
01AF  00E2  	MOVWF Wdt_Delay__00047_arg_delay
01B0  01E3  	CLRF Wdt_Delay__00047_arg_delay+D'1'
01B1  2030  	CALL Wdt_Delay__00047


		//clear the display
		FCD_LCDDisplay0_RawSend(0x01, 0);
01B2  3001  	MOVLW 0x01
01B3  00F0  	MOVWF FCD_LCDDis_00048_arg_in
01B4  01F1  	CLRF FCD_LCDDis_00048_arg_mask
01B5  2043  	CALL FCD_LCDDis_00048

		Wdt_Delay_Ms(2);
01B6  3002  	MOVLW 0x02
01B7  00E2  	MOVWF Wdt_Delay__00047_arg_delay
01B8  01E3  	CLRF Wdt_Delay__00047_arg_delay+D'1'
01B9  2030  	CALL Wdt_Delay__00047

		FCD_LCDDisplay0_RawSend(0x02, 0);
01BA  3002  	MOVLW 0x02
01BB  00F0  	MOVWF FCD_LCDDis_00048_arg_in
01BC  01F1  	CLRF FCD_LCDDis_00048_arg_mask
01BD  2043  	CALL FCD_LCDDis_00048

		Wdt_Delay_Ms(2);
01BE  3002  	MOVLW 0x02
01BF  00E2  	MOVWF Wdt_Delay__00047_arg_delay
01C0  01E3  	CLRF Wdt_Delay__00047_arg_delay+D'1'
01C1  2030  	CALL Wdt_Delay__00047


}
01C2  0008  	RETURN


void FCD_LCDDisplay0_Clear()

{
	
		FCD_LCDDisplay0_RawSend(0x01, 0);
0164  3001  	MOVLW 0x01
0165  00F0  	MOVWF FCD_LCDDis_00048_arg_in
0166  01F1  	CLRF FCD_LCDDis_00048_arg_mask
0167  2043  	CALL FCD_LCDDis_00048

		Wdt_Delay_Ms(2);
0168  3002  	MOVLW 0x02
0169  00E2  	MOVWF Wdt_Delay__00047_arg_delay
016A  01E3  	CLRF Wdt_Delay__00047_arg_delay+D'1'
016B  2030  	CALL Wdt_Delay__00047

		FCD_LCDDisplay0_RawSend(0x02, 0);
016C  3002  	MOVLW 0x02
016D  00F0  	MOVWF FCD_LCDDis_00048_arg_in
016E  01F1  	CLRF FCD_LCDDis_00048_arg_mask
016F  2043  	CALL FCD_LCDDis_00048

		Wdt_Delay_Ms(2);
0170  3002  	MOVLW 0x02
0171  00E2  	MOVWF Wdt_Delay__00047_arg_delay
0172  01E3  	CLRF Wdt_Delay__00047_arg_delay+D'1'
0173  2030  	CALL Wdt_Delay__00047


}
0174  0008  	RETURN


void FCD_LCDDisplay0_PrintASCII(char Character)
{
	
		FCD_LCDDisplay0_RawSend(Character, 0x10);

}

void FCD_LCDDisplay0_Command(char in)
{
	
		FCD_LCDDisplay0_RawSend(in, 0);
		Wdt_Delay_Ms(2);

}

void FCD_LCDDisplay0_Cursor(char x, char y)

{
	
	  #if (LCD_66844_ROWCNT == 1)
	    y=0x80;
	  #endif

	  #if (LCD_66844_ROWCNT == 2)
		if (y==0)
			y=0x80;
		else
			y=0xc0;
	  #endif

	  #if (LCD_66844_ROWCNT == 4)
		if (y==0)
00DD  08E1  	MOVF FCD_LCDDis_0004D_arg_y, F
00DE  1D03  	BTFSS STATUS,Z
00DF  28E3  	GOTO	label15
00E3        label15

			y=0x80;
00E0  3080  	MOVLW 0x80
00E1  00E1  	MOVWF FCD_LCDDis_0004D_arg_y

		else if (y==1)
00E2  28F2  	GOTO	label18
00E3  0361  	DECF FCD_LCDDis_0004D_arg_y, W
00E4  1D03  	BTFSS STATUS,Z
00E5  28E9  	GOTO	label16
00E9        label16

			y=0xc0;
00E6  30C0  	MOVLW 0xC0
00E7  00E1  	MOVWF FCD_LCDDis_0004D_arg_y


		#if (LCD_66844_COLCNT == 16)
			else if (y==2)
00E8  28F2  	GOTO	label18
00E9  0861  	MOVF FCD_LCDDis_0004D_arg_y, W
00EA  3A02  	XORLW 0x02
00EB  1D03  	BTFSS STATUS,Z
00EC  28F0  	GOTO	label17
00F0        label17

				y=0x90;
00ED  3090  	MOVLW 0x90
00EE  00E1  	MOVWF FCD_LCDDis_0004D_arg_y

			else
00EF  28F2  	GOTO	label18
00F2        label18

				y=0xd0;
00F0  30D0  	MOVLW 0xD0
00F1  00E1  	MOVWF FCD_LCDDis_0004D_arg_y

		#endif

		#if (LCD_66844_COLCNT == 20)
			else if (y==2)
				y=0x94;
			else
				y=0xd4;
		#endif
	  #endif

		FCD_LCDDisplay0_RawSend(y+x, 0);
00F2  0860  	MOVF FCD_LCDDis_0004D_arg_x, W
00F3  0761  	ADDWF FCD_LCDDis_0004D_arg_y, W
00F4  00F0  	MOVWF FCD_LCDDis_00048_arg_in
00F5  01F1  	CLRF FCD_LCDDis_00048_arg_mask
00F6  2043  	CALL FCD_LCDDis_00048

		Wdt_Delay_Ms(2);
00F7  3002  	MOVLW 0x02
00F8  00E2  	MOVWF Wdt_Delay__00047_arg_delay
00F9  01E3  	CLRF Wdt_Delay__00047_arg_delay+D'1'
00FA  2030  	CALL Wdt_Delay__00047


}
00FB  0008  	RETURN


void FCD_LCDDisplay0_PrintNumber(short Number)
{
	
		short tmp_int;
		char tmp_byte;
		if (Number < 0)
		{
			FCD_LCDDisplay0_RawSend('-', 0x10);
			Number = 0 - Number;
		}

		tmp_int = Number;
		if (Number >= 10000)
		{
			tmp_byte = tmp_int / 10000;
			FCD_LCDDisplay0_RawSend('0' + tmp_byte, 0x10);

			while (tmp_byte > 0)
			{
				tmp_int = tmp_int - 10000;
				tmp_byte--;
			}
		}
		if (Number >= 1000)
		{
			tmp_byte = tmp_int / 1000;
			FCD_LCDDisplay0_RawSend('0' + tmp_byte, 0x10);

			while (tmp_byte > 0)
			{
				tmp_int = tmp_int - 1000;
				tmp_byte--;
			}
		}
		if (Number >= 100)
		{
			tmp_byte = tmp_int / 100;
			FCD_LCDDisplay0_RawSend('0' + tmp_byte, 0x10);

			while (tmp_byte > 0)
			{
				tmp_int = tmp_int - 100;
				tmp_byte--;
			}
		}
		if (Number >= 10)
		{
			tmp_byte = tmp_int / 10;
			FCD_LCDDisplay0_RawSend('0' + tmp_byte, 0x10);

			while (tmp_byte > 0)
			{
				tmp_int = tmp_int - 10;
				tmp_byte--;
			}
		}
		FCD_LCDDisplay0_RawSend('0' + tmp_int, 0x10);

}

void FCD_LCDDisplay0_PrintString(char* String, char MSZ_String)

{
	
		char idx = 0;
0148  01EF  	CLRF FCD_LCDDis_0004F_1_idx


		for (idx=0; idx<MSZ_String; idx++)
0149  01EF  	CLRF FCD_LCDDis_0004F_1_idx
014A        label26
014A  086E  	MOVF FCD_LCDDis_0004F_arg_MSZ_String, W
014B  026F  	SUBWF FCD_LCDDis_0004F_1_idx, W
014C  1803  	BTFSC STATUS,C
0162  0AEF  	INCF FCD_LCDDis_0004F_1_idx, F
0163  294A  	GOTO	label26

		{
			#ifdef _BOOSTC
				if (String[idx] == 0)
014E  1383  	BCF STATUS,IRP
014F  185E  	BTFSC FCD_LCDDis_0004F_arg_String+D'1',0
0150  1783  	BSF STATUS,IRP
0151  085D  	MOVF FCD_LCDDis_0004F_arg_String, W
0152  076F  	ADDWF FCD_LCDDis_0004F_1_idx, W
0153  0084  	MOVWF FSR
0154  0880  	MOVF INDF, F
0155  1903  	BTFSC STATUS,Z

				{
					break;

				}
				FCD_LCDDisplay0_RawSend(String[idx], 0x10);
0157  1383  	BCF STATUS,IRP
0158  185E  	BTFSC FCD_LCDDis_0004F_arg_String+D'1',0
0159  1783  	BSF STATUS,IRP
015A  085D  	MOVF FCD_LCDDis_0004F_arg_String, W
015B  076F  	ADDWF FCD_LCDDis_0004F_1_idx, W
015C  0084  	MOVWF FSR
015D  0800  	MOVF INDF, W
015E  00F0  	MOVWF FCD_LCDDis_00048_arg_in
015F  3010  	MOVLW 0x10
0160  00F1  	MOVWF FCD_LCDDis_00048_arg_mask
0161  2043  	CALL FCD_LCDDis_00048

			#endif

			#ifdef HI_TECH_C
				if (*String == 0)
				{
					break;
				}
				FCD_LCDDisplay0_RawSend(*String, 0x10);
				String++;
			#endif
		}

}
014D  0008  	RETURN
0156  0008  	RETURN


void FCD_LCDDisplay0_ScrollDisplay(char Direction, char Num_Positions)
{
	
		char cmd = 0;
		char count;

		//Choose the direction
		switch (Direction)
		{
			case 0:
			case 'l':
			case 'L':

				cmd = 0x18;
				break;

			case 1:
			case 'r':
			case 'R':

				cmd = 0x1C;
				break;

			default:
				break;
		}

		//If direction accepted then scroll the specified amount
		if (cmd)
		{
			for (count = 0; count < Num_Positions; count++)
				FCD_LCDDisplay0_Command(cmd);
		}

}

void FCD_LCDDisplay0_ClearLine(char Line)

{
	
		char count;
		char rowcount;

		//Define number of columns per line
		#if (LCD_66844_ROWCNT == 1)
			rowcount=80;
		#endif

		#if (LCD_66844_ROWCNT == 2)
			rowcount=40;
		#endif

		#if (LCD_66844_ROWCNT == 4)
			#if (LCD_66844_COLCNT == 16)
				rowcount=16;
0131  3010  	MOVLW 0x10
0132  00DF  	MOVWF FCD_LCDDis_00052_1_rowcount

			#endif
			#if (LCD_66844_COLCNT == 20)
				rowcount=20;
			#endif
		#endif

		//Start at beginning of the line
		FCD_LCDDisplay0_Cursor (0, Line);
0133  01E0  	CLRF FCD_LCDDis_0004D_arg_x
0134  085D  	MOVF FCD_LCDDis_00052_arg_Line, W
0135  00E1  	MOVWF FCD_LCDDis_0004D_arg_y
0136  20DD  	CALL FCD_LCDDis_0004D


		//Send out spaces to clear line
		for (count = 0; count < rowcount; count++)
0137  01DE  	CLRF FCD_LCDDis_00052_1_count
0138        label24
0138  085F  	MOVF FCD_LCDDis_00052_1_rowcount, W
0139  025E  	SUBWF FCD_LCDDis_00052_1_count, W
013A  1803  	BTFSC STATUS,C
013B  2943  	GOTO	label25
0141  0ADE  	INCF FCD_LCDDis_00052_1_count, F
0142  2938  	GOTO	label24
0143        label25

			FCD_LCDDisplay0_RawSend(' ', 0x10);
013C  3020  	MOVLW 0x20
013D  00F0  	MOVWF FCD_LCDDis_00048_arg_in
013E  3010  	MOVLW 0x10
013F  00F1  	MOVWF FCD_LCDDis_00048_arg_mask
0140  2043  	CALL FCD_LCDDis_00048


		//Move back to the beginning of the line.
		FCD_LCDDisplay0_Cursor (0, Line);
0143  01E0  	CLRF FCD_LCDDis_0004D_arg_x
0144  085D  	MOVF FCD_LCDDis_00052_arg_Line, W
0145  00E1  	MOVWF FCD_LCDDis_0004D_arg_y
0146  20DD  	CALL FCD_LCDDis_0004D


}
0147  0008  	RETURN


void FCD_LCDDisplay0_RAM_Write(char nIdx, char d0, char d1, char d2, char d3, char d4, char d5, char d6, char d7)
{
	   //set CGRAM address
	   FCD_LCDDisplay0_RawSend(64 + (nIdx << 3), 0);
	   delay_ms(2);

	   //write CGRAM data
	   FCD_LCDDisplay0_RawSend(d0, 0x10);
	   FCD_LCDDisplay0_RawSend(d1, 0x10);
	   FCD_LCDDisplay0_RawSend(d2, 0x10);
	   FCD_LCDDisplay0_RawSend(d3, 0x10);
	   FCD_LCDDisplay0_RawSend(d4, 0x10);
	   FCD_LCDDisplay0_RawSend(d5, 0x10);
	   FCD_LCDDisplay0_RawSend(d6, 0x10);
	   FCD_LCDDisplay0_RawSend(d7, 0x10);

	   //Clear the display
	   FCD_LCDDisplay0_RawSend(0x01, 0);
	   delay_ms(2);
	   FCD_LCDDisplay0_RawSend(0x02, 0);
	   delay_ms(2);
}



//RS2320: //Macro implementations


void FCD_RS2320_SendRS232Char(short nChar)
{
	
	#if (RS232_66846_UART == 0)

		char dMask;
		char idx;
		char count = 8;

		#ifdef RS232_66846_HARDWARE
			//wait until CTS is low
			while (( RS232_66846_CTS_PORT & (1 << RS232_66846_CTS_PIN) ) != 0);
		#endif

		#if(RS232_66846_DATASIZE == 1)
			count = 9;
		#endif
		#if(RS232_66846_DATASIZE == 2)
			count = 7;
		#endif

		clear_bit( RS232_66846_TX_PORT, RS232_66846_SW_TX);		// Send Start bit
		FCD_RS2320_RS232_Delay(0);

		for (idx = 0; idx < count; idx++)
		{
			dMask = nChar & 0x01;							// Mask off data bit

			if (dMask)
				set_bit( RS232_66846_TX_PORT, RS232_66846_SW_TX);
			else
				clear_bit( RS232_66846_TX_PORT, RS232_66846_SW_TX);

			FCD_RS2320_RS232_Delay(0);
			nChar = nChar >> 1;								// Move to next data bit
		}

		set_bit( RS232_66846_TX_PORT, RS232_66846_SW_TX);			// Send Stop bit
		FCD_RS2320_RS232_Delay(0);

	#endif

	#if (RS232_66846_UART == 1)

		#ifndef MX_UART
			#pragma error "Chip does not have UART capability"
		#endif

		st_bit(txsta, TXEN);
		while (ts_bit(pir1, TXIF) == 0);

		#ifdef RS232_66846_HARDWARE
			//wait until CTS is low
			while (( RS232_66846_CTS_PORT & (1 << RS232_66846_CTS_PIN) ) != 0);
		#endif

		#if(RS232_66846_DATASIZE == 1)
			if (test_bit(nChar, 8))
				st_bit(txsta, TX9D);
			else
				cr_bit(txsta, TX9D);
		#endif

		txreg = nChar;

	#endif

	#if (RS232_66846_UART == 2)

		#ifndef MX_UART2
			#pragma error "Chip does not have second UART capability"
		#endif

		st_bit(txsta2, TXEN);
		while (ts_bit(pir3, TX2IF) == 0);

		#ifdef RS232_66846_HARDWARE
			//wait until CTS is low
			while (( RS232_66846_CTS_PORT & (1 << RS232_66846_CTS_PIN) ) != 0);
		#endif

		#if( RS232_66846_DATASIZE == 1)
			if (test_bit(nChar, 8))
				st_bit(txsta2, TX9D);
			else
				cr_bit(txsta2, TX9D);
		#endif

		txreg2 = nChar;

	#endif

}

void FCD_RS2320_SendRS232String(char* String, char MSZ_String)
{
		char idx;
		for(idx = 0; idx < MSZ_String; idx++)
		{
			#ifdef _BOOSTC
				if (String[idx] == 0)
					break;
				else FCD_RS2320_SendRS232Char(String[idx]);
			#endif
			#ifdef HI_TECH_
				if (*String == 0)
					break;
				else FCD_RS2320_SendRS232Char(*String);
				String++;
			#endif
		}
}

short FCD_RS2320_ReceiveRS232Char(short nTimeout)

{
	
		char delay1 = 0;
0086  01E7  	CLRF FCD_RS2320_00056_1_delay1

		char delay2 = 0;
0087  01E8  	CLRF FCD_RS2320_00056_1_delay2

		char regcheck = 0;
0088  01E9  	CLRF FCD_RS2320_00056_1_regcheck

		char dummy = 0;
0089  01EA  	CLRF FCD_RS2320_00056_1_dummy

		short retVal = 512;
008A  01EB  	CLRF FCD_RS2320_00056_1_retVal
008B  3002  	MOVLW 0x02
008C  00EC  	MOVWF FCD_RS2320_00056_1_retVal+D'1'

		char bWaitForever = 0;
008D  01ED  	CLRF FCD_RS2320_00056_1_bWaitForever

		char rxStatus = RS232_66846_STATUS_LOOP;
008E  01EE  	CLRF FCD_RS2320_00056_1_rxStatus

		char idx;
		char count = 8;
008F  3008  	MOVLW 0x08
0090  00EF  	MOVWF FCD_RS2320_00056_1_count


		#if ( RS232_66846_LEGACY_RV == 0)
			retVal = 255;
0091  30FF  	MOVLW 0xFF
0092  00EB  	MOVWF FCD_RS2320_00056_1_retVal
0093  01EC  	CLRF FCD_RS2320_00056_1_retVal+D'1'

		#endif

		#if ( RS232_66846_UART == 1)
			#ifndef MX_UART
				#pragma error "Chip does not have UART capability"
			#endif
		#endif

		#if ( RS232_66846_UART == 2)
			#ifndef MX_UART2
				#pragma error "Chip does not have second UART capability"
			#endif
		#endif

		#ifdef RS232_66846_HARDWARE
			//ready to accept data
			clear_bit( RS232_66846_RTS_PORT, RS232_66846_RTS_PIN);
		#endif

		if (nTimeout == 255)
0094  30FF  	MOVLW 0xFF
0095  0665  	XORWF FCD_RS2320_00056_arg_nTimeout, W
0096  1903  	BTFSC STATUS,Z
0097  0866  	MOVF FCD_RS2320_00056_arg_nTimeout+D'1', W
0098  1D03  	BTFSS STATUS,Z
0099  289C  	GOTO	label7
009C        label7

			bWaitForever = 1;
009A  3001  	MOVLW 0x01
009B  00ED  	MOVWF FCD_RS2320_00056_1_bWaitForever


		#if ( RS232_66846_UART == 1)
			st_bit(rcsta, CREN);
009C  1618  	BSF gbl_rcsta,4

		#endif

		#if ( RS232_66846_UART == 2)
			st_bit(rcsta2, CREN);
		#endif

		while (rxStatus == RS232_66846_STATUS_LOOP)
009D        label8
009D  08EE  	MOVF FCD_RS2320_00056_1_rxStatus, F
009E  1D03  	BTFSS STATUS,Z
009F  28BF  	GOTO	label11
00BE  289D  	GOTO	label8
00BF        label11

		{
			if (bWaitForever == 0)
00A0  08ED  	MOVF FCD_RS2320_00056_1_bWaitForever, F
00A1  1D03  	BTFSS STATUS,Z
00A2  28B6  	GOTO	label10

			{
				//don't wait forever, so do timeout thing...
				if (nTimeout == 0)
00A3  08E5  	MOVF FCD_RS2320_00056_arg_nTimeout, F
00A4  1D03  	BTFSS STATUS,Z
00A5  28AC  	GOTO	label9
00A6  08E6  	MOVF FCD_RS2320_00056_arg_nTimeout+D'1', F
00A7  1D03  	BTFSS STATUS,Z
00A8  28AC  	GOTO	label9
00AC        label9

				{
					rxStatus = RS232_66846_STATUS_TIMEOUT;
00A9  3001  	MOVLW 0x01
00AA  00EE  	MOVWF FCD_RS2320_00056_1_rxStatus

				}
				else
00AB  28B6  	GOTO	label10

				{
					if ( RS232_66846_TOUT)
					{
						delay_us(10);
						delay1 = delay1 + 1;
						if(delay1 == 100)
						{
							nTimeout = nTimeout - 1;
							delay1 = 0;
						}
					}
					else
					{
						//decrement timeout
						delay1 = delay1 - 1;
00AC  0367  	DECF FCD_RS2320_00056_1_delay1, W
00AD  00E7  	MOVWF FCD_RS2320_00056_1_delay1

						if (delay1 == 0)
00AE  08E7  	MOVF FCD_RS2320_00056_1_delay1, F
00AF  1D03  	BTFSS STATUS,Z
00B0  28B6  	GOTO	label10

						{
							nTimeout = nTimeout - 1;
00B1  3001  	MOVLW 0x01
00B2  02E5  	SUBWF FCD_RS2320_00056_arg_nTimeout, F
00B3  08E6  	MOVF FCD_RS2320_00056_arg_nTimeout+D'1', F
00B4  1C03  	BTFSS STATUS,C
00B5  03E6  	DECF FCD_RS2320_00056_arg_nTimeout+D'1', F
00B6        label10

						}
					}
				}
			}

			#if ( RS232_66846_UART == 0)
				regcheck = test_bit(RS232_66846_RX_PORT, RS232_66846_SW_RX);	//Test for start bit
				if (regcheck == 0)
					rxStatus = RS232_66846_STATUS_RXBYTE;
			#endif

			#if ( RS232_66846_UART == 1)
				regcheck = ts_bit(pir1, RCIF);
00B6  3020  	MOVLW 0x20
00B7  050C  	ANDWF gbl_pir1, W
00B8  00E9  	MOVWF FCD_RS2320_00056_1_regcheck

				if (regcheck != 0)
00B9  08E9  	MOVF FCD_RS2320_00056_1_regcheck, F
00BA  1903  	BTFSC STATUS,Z
00BB  289D  	GOTO	label8

					rxStatus = RS232_66846_STATUS_RXBYTE;
00BC  3002  	MOVLW 0x02
00BD  00EE  	MOVWF FCD_RS2320_00056_1_rxStatus

			#endif

			#if ( RS232_66846_UART == 2)
				regcheck = ts_bit(pir3, RC2IF);
				if (regcheck != 0)
					rxStatus = RS232_66846_STATUS_RXBYTE;
			#endif
		}

		if (rxStatus == RS232_66846_STATUS_RXBYTE)
00BF  086E  	MOVF FCD_RS2320_00056_1_rxStatus, W
00C0  3A02  	XORLW 0x02
00C1  1D03  	BTFSS STATUS,Z
00C2  28D8  	GOTO	label14

		{
			#if ( RS232_66846_UART > 0)

				#if ( RS232_66846_UART == 1)
					regcheck = ts_bit(rcsta, FERR);
00C3  3004  	MOVLW 0x04
00C4  0518  	ANDWF gbl_rcsta, W
00C5  00E9  	MOVWF FCD_RS2320_00056_1_regcheck

				#endif

				#if ( RS232_66846_UART == 2)
					regcheck = ts_bit(rcsta2, FERR);
				#endif

				if (regcheck != 0)
00C6  08E9  	MOVF FCD_RS2320_00056_1_regcheck, F
00C7  1903  	BTFSC STATUS,Z
00C8  28CC  	GOTO	label12
00CC        label12

				{
					#if ( RS232_66846_UART == 1)
						dummy = rcreg;      //need to read the rcreg to clear FERR
00C9  081A  	MOVF gbl_rcreg, W
00CA  00EA  	MOVWF FCD_RS2320_00056_1_dummy

					#endif

					#if ( RS232_66846_UART == 2)
						dummy = rcreg2;      //need to read the rcreg to clear FERR
					#endif

					#ifdef RS232_66846_DEBUG
						FCD_RS2320_SendRS232Char('<');
						FCD_RS2320_SendRS232Char('F');
						FCD_RS2320_SendRS232Char('E');
						FCD_RS2320_SendRS232Char('R');
						FCD_RS2320_SendRS232Char('R');
						FCD_RS2320_SendRS232Char('>');
					#endif

					#if ( RS232_66846_LEGACY_RV == 1)
						retVal = 0x400;					//Framing Error Flag
					#endif
				}
				else
00CB  28D8  	GOTO	label14

				{
					#if ( RS232_66846_UART == 1)
						regcheck = ts_bit(rcsta, OERR);
00CC  3002  	MOVLW 0x02
00CD  0518  	ANDWF gbl_rcsta, W
00CE  00E9  	MOVWF FCD_RS2320_00056_1_regcheck

					#endif

					#if ( RS232_66846_UART == 2)
						regcheck = ts_bit(rcsta2, OERR);
					#endif

					if (regcheck != 0)
00CF  08E9  	MOVF FCD_RS2320_00056_1_regcheck, F
00D0  1903  	BTFSC STATUS,Z
00D1  28D5  	GOTO	label13
00D5        label13

					{
						//need to read the rcreg to clear error
						#if ( RS232_66846_UART == 1)
							cr_bit(rcsta, CREN);
00D2  1218  	BCF gbl_rcsta,4

							st_bit(rcsta, CREN);
00D3  1618  	BSF gbl_rcsta,4

						#endif

						#if ( RS232_66846_UART == 2)
							cr_bit(rcsta2, CREN);
							st_bit(rcsta2, CREN);
						#endif

						#ifdef RS232_66846_DEBUG
							FCD_RS2320_SendRS232Char('<');
							FCD_RS2320_SendRS232Char('O');
							FCD_RS2320_SendRS232Char('E');
							FCD_RS2320_SendRS232Char('R');
							FCD_RS2320_SendRS232Char('R');
							FCD_RS2320_SendRS232Char('>');
						#endif

						#if ( RS232_66846_LEGACY_RV == 1)
							retVal = 0x800;					//Overrun Error Flag
						#endif

					}
					else
00D4  28D8  	GOTO	label14
00D8        label14

					{
						#if ( RS232_66846_UART == 1)
							retVal = rcreg; 			//no error, so rx byte is valid
00D5  081A  	MOVF gbl_rcreg, W
00D6  00EB  	MOVWF FCD_RS2320_00056_1_retVal
00D7  01EC  	CLRF FCD_RS2320_00056_1_retVal+D'1'


							#if( RS232_66846_DATASIZE == 1)
								if(ts_bit(rcsta, RX9D));
									retVal = retVal | 0x100;
							#endif

						#endif

						#if ( RS232_66846_UART == 2)
							retVal = rcreg2; 			//no error, so rx byte is valid

							#if( RS232_66846_DATASIZE == 1)
								if(ts_bit(rcsta2, RX9D));
									retVal = retVal | 0x100;
							#endif

						#endif

						#ifdef RS232_66846_ECHO
							FCD_RS2320_SendRS232Char(retVal);
						#endif
					}
				}
			#else
				#if( RS232_66846_DATASIZE == 1)
					count = 9;
				#endif

				FCD_RS2320_RS232_Delay(1);
				for (idx = 0; idx < count; idx++)
				{
					retVal = retVal >> 1;

					if(count == 9)
					{
						if (test_bit( RS232_66846_RX_PORT, RS232_66846_SW_RX))
							retVal = retVal | 0x100;
					}
					else
					{
						if (test_bit( RS232_66846_RX_PORT, RS232_66846_SW_RX))
							retVal = retVal | 0x80;
					}
					FCD_RS2320_RS232_Delay(1);
				}

				#ifdef RS232_66846_ECHO
					FCD_RS2320_SendRS232Char(retVal);
				#endif

			#endif
		}
		#ifdef RS232_66846_HARDWARE
			//not ready to accept data
			set_bit( RS232_66846_RTS_PORT, RS232_66846_RTS_PIN);
		#endif

		return (retVal);
00D8  086B  	MOVF FCD_RS2320_00056_1_retVal, W
00D9  00F0  	MOVWF CompTempVarRet2238
00DA  086C  	MOVF FCD_RS2320_00056_1_retVal+D'1', W
00DB  00F1  	MOVWF CompTempVarRet2238+D'1'

}
00DC  0008  	RETURN


void FCD_RS2320_ReceiveRS232String(char* FCR_RETVAL, char FCR_RETVAL_SIZE, char nTimeout, char NumBytes)

{
		char idx;
		short in;

		#if ( RS232_66846_LEGACY_RV == 0 )
			#define RS232_TO 	255
		#else
			#define RS232_TO 	256
		#endif

		if (NumBytes > FCR_RETVAL_SIZE)
00FC  0861  	MOVF FCD_RS2320_00057_arg_NumBytes, W
00FD  025F  	SUBWF FCD_RS2320_00057_arg_FCR_R_00058, W
00FE  1803  	BTFSC STATUS,C
00FF  2902  	GOTO	label19
0102        label19

			NumBytes = FCR_RETVAL_SIZE;
0100  085F  	MOVF FCD_RS2320_00057_arg_FCR_R_00058, W
0101  00E1  	MOVWF FCD_RS2320_00057_arg_NumBytes


		for (idx = 0; idx < NumBytes; idx++)
0102  01E2  	CLRF FCD_RS2320_00057_1_idx
0103        label20
0103  0861  	MOVF FCD_RS2320_00057_arg_NumBytes, W
0104  0262  	SUBWF FCD_RS2320_00057_1_idx, W
0105  1803  	BTFSC STATUS,C
0106  2924  	GOTO	label23
0122  0AE2  	INCF FCD_RS2320_00057_1_idx, F
0123  2903  	GOTO	label20
0124        label23

		{
			in = FCD_RS2320_ReceiveRS232Char(nTimeout);
0107  0860  	MOVF FCD_RS2320_00057_arg_nTimeout, W
0108  00E5  	MOVWF FCD_RS2320_00056_arg_nTimeout
0109  01E6  	CLRF FCD_RS2320_00056_arg_nTimeout+D'1'
010A  2086  	CALL FCD_RS2320_00056
010B  0870  	MOVF CompTempVarRet2238, W
010C  00E3  	MOVWF FCD_RS2320_00057_1_in
010D  0871  	MOVF CompTempVarRet2238+D'1', W
010E  00E4  	MOVWF FCD_RS2320_00057_1_in+D'1'

			if(in < RS232_TO)
010F  30FF  	MOVLW 0xFF
0110  0263  	SUBWF FCD_RS2320_00057_1_in, W
0111  0864  	MOVF FCD_RS2320_00057_1_in+D'1', W
0112  1803  	BTFSC STATUS,C
0113  2916  	GOTO	label21
0114  1903  	BTFSC STATUS,Z
0115  2918  	GOTO	label22
0116        label21
0116  1FE4  	BTFSS FCD_RS2320_00057_1_in+D'1',7
0117  2924  	GOTO	label23
0118        label22

				FCR_RETVAL[idx] = in & 0xFF;
0118  0863  	MOVF FCD_RS2320_00057_1_in, W
0119  00E5  	MOVWF CompTempVar2242
011A  1383  	BCF STATUS,IRP
011B  185E  	BTFSC FCD_RS2320_00057_arg_FCR_RETVAL+D'1',0
011C  1783  	BSF STATUS,IRP
011D  085D  	MOVF FCD_RS2320_00057_arg_FCR_RETVAL, W
011E  0762  	ADDWF FCD_RS2320_00057_1_idx, W
011F  0084  	MOVWF FSR
0120  0865  	MOVF CompTempVar2242, W
0121  0080  	MOVWF INDF

			else
				break;

		}

		if (idx < FCR_RETVAL_SIZE)
0124  085F  	MOVF FCD_RS2320_00057_arg_FCR_R_00058, W
0125  0262  	SUBWF FCD_RS2320_00057_1_idx, W
0126  1803  	BTFSC STATUS,C

			FCR_RETVAL[idx] = 0;
0128  1383  	BCF STATUS,IRP
0129  185E  	BTFSC FCD_RS2320_00057_arg_FCR_RETVAL+D'1',0
012A  1783  	BSF STATUS,IRP
012B  085D  	MOVF FCD_RS2320_00057_arg_FCR_RETVAL, W
012C  0762  	ADDWF FCD_RS2320_00057_1_idx, W
012D  0084  	MOVWF FSR
012E  3000  	MOVLW 0x00
012F  0080  	MOVWF INDF


		#undef RS232_TO
}
0127  0008  	RETURN
0130  0008  	RETURN


void FCD_RS2320_RS232_Delay(char mode)
{
		unsigned int iterations;
		unsigned int delay = RS232_66846_SW_BAUD;

		if (mode)
			delay = delay + 1;

		for (iterations = 0; iterations < delay; iterations++);
}

//Macro implementations

void main()

{
	
	//Initialisation
	ansel = 0;
01C3  1283  	BCF STATUS, RP0
01C4  1703  	BSF STATUS, RP1
01C5  019E  	CLRF gbl_ansel

anselh = 0;
01C6  019F  	CLRF gbl_anselh


	
	#if (RS232_66846_UART == 0)
		set_bit(RS232_66846_RX_TRIS, RS232_66846_SW_RX);		// Receive pin is a input
		clear_bit(RS232_66846_TX_TRIS, RS232_66846_SW_TX);	// Transmit pin is a output
		set_bit(RS232_66846_TX_PORT, RS232_66846_SW_TX);		// Transmit pin is default high
	#endif

	#if (RS232_66846_UART == 1)
		txsta = RS232_66846_TXSTA_VAL;   					// 8-bit, async, low speed, off
01C7  3004  	MOVLW 0x04
01C8  1683  	BSF STATUS, RP0
01C9  1303  	BCF STATUS, RP1
01CA  0098  	MOVWF gbl_txsta

		spbrg = RS232_66846_SPBRG_VAL;   					// set the baud rate
01CB  3081  	MOVLW 0x81
01CC  0099  	MOVWF gbl_spbrg

		rcsta = 0;                    				// 8-bit, disabled
01CD  1283  	BCF STATUS, RP0
01CE  0198  	CLRF gbl_rcsta


		if(RS232_66846_DATASIZE == 1)
		{
			st_bit(txsta, TX9);   						// 9-bit TX
			st_bit(rcsta, RX9);                    	// 9-bit RX
		}

		st_bit(rcsta, SPEN);         					// turn on serial interface
01CF  1798  	BSF gbl_rcsta,7

	#endif

	#if (RS232_66846_UART == 2)

		txsta2 = RS232_66846_TXSTA_VAL;   					// 8-bit, async, low speed, off
		spbrg2 = RS232_66846_SPBRG_VAL;   					// set the baud rate
		rcsta2 = 0;                    					// 8-bit, disabled

		if(RS232_66846_DATASIZE == 1)
		{
			st_bit(txsta2, TX9);   					// 9-bit TX
			st_bit(rcsta2, RX9);                    	// 9-bit RX
		}

		st_bit(rcsta2, SPEN);         					// turn on serial interface
	#endif

	#ifdef RS232_66846_HARDWARE
		set_bit( RS232_66846_CTS_TRIS, RS232_66846_CTS_PIN);	//CTS is an input
		clear_bit( RS232_66846_RTS_TRIS, RS232_66846_RTS_PIN);	//RTS is an output
		set_bit( RS232_66846_RTS_PORT, RS232_66846_RTS_PIN); 	//not ready to accept data
	#endif


	//Interrupt initialisation code
	option_reg = 0xC0;
01D0  30C0  	MOVLW 0xC0
01D1  1683  	BSF STATUS, RP0
01D2  0081  	MOVWF gbl_option_reg



	//Call Component Macro
	//Call Component Macro: LCDDisplay(0)::Start
	FCD_LCDDisplay0_Start();
01D3  2175  	CALL FCD_LCDDis_00049



	//Call Component Macro
	//Call Component Macro: LCDDisplay(0)::Clear
	FCD_LCDDisplay0_Clear();
01D4  2164  	CALL FCD_LCDDis_0004A



	//Loop
	//Loop: While 1
	while (1)
01D5        label27
024D  29D5  	GOTO	label27

	{
		//Call Component Macro
		//Call Component Macro: LCDDisplay(0)::Cursor(1, 0)
		FCD_LCDDisplay0_Cursor(1, 0);
01D5  3001  	MOVLW 0x01
01D6  00E0  	MOVWF FCD_LCDDis_0004D_arg_x
01D7  01E1  	CLRF FCD_LCDDis_0004D_arg_y
01D8  20DD  	CALL FCD_LCDDis_0004D



		//Call Component Macro
		//Call Component Macro: LCDDisplay(0)::PrintString("SERIAL MONITOR")
		FCD_LCDDisplay0_PrintString("SERIAL MONITOR",14);
01D9  3020  	MOVLW 0x20
01DA  00E5  	MOVWF CompTempVar2246+D'6'
01DB  3041  	MOVLW 0x41
01DC  00E3  	MOVWF CompTempVar2246+D'4'
01DD  3045  	MOVLW 0x45
01DE  00E0  	MOVWF CompTempVar2246+D'1'
01DF  3049  	MOVLW 0x49
01E0  00E2  	MOVWF CompTempVar2246+D'3'
01E1  00E9  	MOVWF CompTempVar2246+D'10'
01E2  304C  	MOVLW 0x4C
01E3  00E4  	MOVWF CompTempVar2246+D'5'
01E4  304D  	MOVLW 0x4D
01E5  00E6  	MOVWF CompTempVar2246+D'7'
01E6  304E  	MOVLW 0x4E
01E7  00E8  	MOVWF CompTempVar2246+D'9'
01E8  304F  	MOVLW 0x4F
01E9  00E7  	MOVWF CompTempVar2246+D'8'
01EA  00EB  	MOVWF CompTempVar2246+D'12'
01EB  3052  	MOVLW 0x52
01EC  00E1  	MOVWF CompTempVar2246+D'2'
01ED  00EC  	MOVWF CompTempVar2246+D'13'
01EE  3053  	MOVLW 0x53
01EF  00DF  	MOVWF CompTempVar2246
01F0  3054  	MOVLW 0x54
01F1  00EA  	MOVWF CompTempVar2246+D'11'
01F2  01ED  	CLRF CompTempVar2246+D'14'
01F3  3000  	MOVLW HIGH(CompTempVar2246+D'0')
01F4  00DE  	MOVWF FCD_LCDDis_0004F_arg_String+D'1'
01F5  305F  	MOVLW LOW(CompTempVar2246+D'0')
01F6  00DD  	MOVWF FCD_LCDDis_0004F_arg_String
01F7  300E  	MOVLW 0x0E
01F8  00EE  	MOVWF FCD_LCDDis_0004F_arg_MSZ_String
01F9  2148  	CALL FCD_LCDDis_0004F



		//Call Component Macro
		//Call Component Macro: datbyte=RS232(0)::ReceiveRS232Char(10)
		FCV_DATBYTE = FCD_RS2320_ReceiveRS232Char(10);
01FA  300A  	MOVLW 0x0A
01FB  00E5  	MOVWF FCD_RS2320_00056_arg_nTimeout
01FC  01E6  	CLRF FCD_RS2320_00056_arg_nTimeout+D'1'
01FD  2086  	CALL FCD_RS2320_00056
01FE  0870  	MOVF CompTempVarRet2238, W
01FF  00DC  	MOVWF gbl_FCV_DATBYTE



		//Decision
		//Decision: datbyte='A'?
		if (FCV_DATBYTE=='A')
0200  085C  	MOVF gbl_FCV_DATBYTE, W
0201  3A41  	XORLW 0x41
0202  1D03  	BTFSS STATUS,Z
0203  2A47  	GOTO	label29

		{
			//Call Component Macro
			//Call Component Macro: datbyte=RS232(0)::ReceiveRS232Char(10)
			FCV_DATBYTE = FCD_RS2320_ReceiveRS232Char(10);
0204  300A  	MOVLW 0x0A
0205  00E5  	MOVWF FCD_RS2320_00056_arg_nTimeout
0206  01E6  	CLRF FCD_RS2320_00056_arg_nTimeout+D'1'
0207  2086  	CALL FCD_RS2320_00056
0208  0870  	MOVF CompTempVarRet2238, W
0209  00DC  	MOVWF gbl_FCV_DATBYTE



			//Decision
			//Decision: datbyte='A'?
			if (FCV_DATBYTE=='A')
020A  085C  	MOVF gbl_FCV_DATBYTE, W
020B  3A41  	XORLW 0x41
020C  1D03  	BTFSS STATUS,Z
020D  2A47  	GOTO	label29

			{
				//Call Component Macro
				//Call Component Macro: datbyte=RS232(0)::ReceiveRS232Char(10)
				FCV_DATBYTE = FCD_RS2320_ReceiveRS232Char(10);
020E  300A  	MOVLW 0x0A
020F  00E5  	MOVWF FCD_RS2320_00056_arg_nTimeout
0210  01E6  	CLRF FCD_RS2320_00056_arg_nTimeout+D'1'
0211  2086  	CALL FCD_RS2320_00056
0212  0870  	MOVF CompTempVarRet2238, W
0213  00DC  	MOVWF gbl_FCV_DATBYTE



				//Decision
				//Decision: datbyte='5'?
				if (FCV_DATBYTE=='5')
0214  085C  	MOVF gbl_FCV_DATBYTE, W
0215  3A35  	XORLW 0x35
0216  1D03  	BTFSS STATUS,Z
0217  2A47  	GOTO	label29

				{
					//Call Component Macro
					//Call Component Macro: datbyte=RS232(0)::ReceiveRS232Char(10)
					FCV_DATBYTE = FCD_RS2320_ReceiveRS232Char(10);
0218  300A  	MOVLW 0x0A
0219  00E5  	MOVWF FCD_RS2320_00056_arg_nTimeout
021A  01E6  	CLRF FCD_RS2320_00056_arg_nTimeout+D'1'
021B  2086  	CALL FCD_RS2320_00056
021C  0870  	MOVF CompTempVarRet2238, W
021D  00DC  	MOVWF gbl_FCV_DATBYTE



					//Decision
					//Decision: datbyte='5'?
					if (FCV_DATBYTE=='5')
021E  085C  	MOVF gbl_FCV_DATBYTE, W
021F  3A35  	XORLW 0x35
0220  1D03  	BTFSS STATUS,Z
0221  2A47  	GOTO	label29
0247        label29

					{
						//Call Component Macro
						//Call Component Macro: dat=RS232(0)::ReceiveRS232String(10, 24)
						FCD_RS2320_ReceiveRS232String(FCV_DAT, 26, 10, 24);
0222  3000  	MOVLW HIGH(gbl_FCV_DAT+D'0')
0223  00DE  	MOVWF FCD_RS2320_00057_arg_FCR_RETVAL+D'1'
0224  3020  	MOVLW LOW(gbl_FCV_DAT+D'0')
0225  00DD  	MOVWF FCD_RS2320_00057_arg_FCR_RETVAL
0226  301A  	MOVLW 0x1A
0227  00DF  	MOVWF FCD_RS2320_00057_arg_FCR_R_00058
0228  300A  	MOVLW 0x0A
0229  00E0  	MOVWF FCD_RS2320_00057_arg_nTimeout
022A  3018  	MOVLW 0x18
022B  00E1  	MOVWF FCD_RS2320_00057_arg_NumBytes
022C  20FC  	CALL FCD_RS2320_00057



						//Call Component Macro
						//Call Component Macro: LCDDisplay(0)::Cursor(0, 1)
						FCD_LCDDisplay0_Cursor(0, 1);
022D  01E0  	CLRF FCD_LCDDis_0004D_arg_x
022E  3001  	MOVLW 0x01
022F  00E1  	MOVWF FCD_LCDDis_0004D_arg_y
0230  20DD  	CALL FCD_LCDDis_0004D



						//Call Component Macro
						//Call Component Macro: LCDDisplay(0)::PrintString("AA55")
						FCD_LCDDisplay0_PrintString("AA55",4);
0231  3041  	MOVLW 0x41
0232  00DF  	MOVWF CompTempVar2249
0233  00E0  	MOVWF CompTempVar2249+D'1'
0234  3035  	MOVLW 0x35
0235  00E1  	MOVWF CompTempVar2249+D'2'
0236  00E2  	MOVWF CompTempVar2249+D'3'
0237  01E3  	CLRF CompTempVar2249+D'4'
0238  3000  	MOVLW HIGH(CompTempVar2249+D'0')
0239  00DE  	MOVWF FCD_LCDDis_0004F_arg_String+D'1'
023A  305F  	MOVLW LOW(CompTempVar2249+D'0')
023B  00DD  	MOVWF FCD_LCDDis_0004F_arg_String
023C  3004  	MOVLW 0x04
023D  00EE  	MOVWF FCD_LCDDis_0004F_arg_MSZ_String
023E  2148  	CALL FCD_LCDDis_0004F



						//Call Component Macro
						//Call Component Macro: LCDDisplay(0)::PrintString(dat)
						FCD_LCDDisplay0_PrintString(FCV_DAT,FCSZ_DAT);
023F  3000  	MOVLW HIGH(gbl_FCV_DAT+D'0')
0240  00DE  	MOVWF FCD_LCDDis_0004F_arg_String+D'1'
0241  3020  	MOVLW LOW(gbl_FCV_DAT+D'0')
0242  00DD  	MOVWF FCD_LCDDis_0004F_arg_String
0243  301A  	MOVLW 0x1A
0244  00EE  	MOVWF FCD_LCDDis_0004F_arg_MSZ_String
0245  2148  	CALL FCD_LCDDis_0004F



						//Loop
						//Loop: While 1
						while (1)
0246        label28
0246  2A46  	GOTO	label28

						{
						}


					} else {
						//Goto Connection Point
						//Goto Connection Point: [A]: A
						goto FCC_Main_A;



					}


				} else {
					//Goto Connection Point
					//Goto Connection Point: [A]: A
					goto FCC_Main_A;



				}


			} else {
				//Goto Connection Point
				//Goto Connection Point: [A]: A
				goto FCC_Main_A;



			}


		} else {
			//Connection Point
			//Connection Point: [A]: A
FCC_Main_A:

;


			//Call Component Macro
			//Call Component Macro: LCDDisplay(0)::ClearLine(2)
			FCD_LCDDisplay0_ClearLine(2);
0247  3002  	MOVLW 0x02
0248  00DD  	MOVWF FCD_LCDDis_00052_arg_Line
0249  2131  	CALL FCD_LCDDis_00052



			//Call Component Macro
			//Call Component Macro: LCDDisplay(0)::ClearLine(3)
			FCD_LCDDisplay0_ClearLine(3);
024A  3003  	MOVLW 0x03
024B  00DD  	MOVWF FCD_LCDDis_00052_arg_Line
024C  2131  	CALL FCD_LCDDis_00052



		}


	}


	mainendloop: goto mainendloop;
}


void MX_INTERRUPT_MACRO(void)

{
}
0276  1283  	BCF STATUS, RP0
0277  1303  	BCF STATUS, RP1
0278  0E50  	SWAPF Int1BContext+D'2', W
0279  0084  	MOVWF FSR
027A  0E4F  	SWAPF Int1BContext+D'1', W
027B  008A  	MOVWF PCLATH
027C  0E4E  	SWAPF Int1BContext, W
027D  0083  	MOVWF STATUS
027E  0EFF  	SWAPF Int1Context, F
027F  0E7F  	SWAPF Int1Context, W
0280  0009  	RETFIE





////////////////////////////////////////
// Code with no source :-)
////////////////////////////////////////
0000  2A4E  	GOTO	_startup

0004  00FF  	MOVWF Int1Context
0005  0E03  	SWAPF STATUS, W
0006  1283  	BCF STATUS, RP0
0007  1303  	BCF STATUS, RP1
0008  00CE  	MOVWF Int1BContext
0009  0E0A  	SWAPF PCLATH, W
000A  00CF  	MOVWF Int1BContext+D'1'
000B  0E04  	SWAPF FSR, W
000C  00D0  	MOVWF Int1BContext+D'2'
000D  118A  	BCF PCLATH,3
000E  120A  	BCF PCLATH,4
000F  2A76  	GOTO	interrupt
0010        delay_us_00000
0010        ; { delay_us ; function begin
0010        label1
0010  0000  	NOP
0011  0000  	NOP
0012  0BE7  	DECFSZ delay_us_00000_arg_del, F
0013  2810  	GOTO	label1
0014  0008  	RETURN
0015        ; } delay_us function end

0015        delay_10us_00000
0015        ; { delay_10us ; function begin
0015  08F3  	MOVF delay_10us_00000_arg_del, F
0016  1D03  	BTFSS STATUS,Z
0017  2819  	GOTO	label2
0018  0008  	RETURN
0019        label2
0019  3009  	MOVLW 0x09
001A        label3
001A  0000  	NOP
001B  3EFF  	ADDLW 0xFF
001C  1D03  	BTFSS STATUS,Z
001D  281A  	GOTO	label3
001E  0000  	NOP
001F  0000  	NOP
0020  0BF3  	DECFSZ delay_10us_00000_arg_del, F
0021  2819  	GOTO	label2
0022  0008  	RETURN
0023        ; } delay_10us function end


024E        _startup
024E  30D5  	MOVLW 0xD5
024F  1283  	BCF STATUS, RP0
0250  1303  	BCF STATUS, RP1
0251  00BA  	MOVWF gbl_16_LSR
0252  30C4  	MOVLW 0xC4
0253  00BB  	MOVWF gbl_16_LSR+D'1'
0254  30BB  	MOVLW 0xBB
0255  00BC  	MOVWF gbl_16_LSR+D'2'
0256  30DC  	MOVLW 0xDC
0257  00BD  	MOVWF gbl_16_LSR+D'3'
0258  01BE  	CLRF gbl_17_gbl_aSig
0259  01BF  	CLRF gbl_17_gbl_aSig+D'1'
025A  01C0  	CLRF gbl_17_gbl_aSig+D'2'
025B  01C1  	CLRF gbl_17_gbl_aSig+D'3'
025C  01C2  	CLRF gbl_17_gbl_bSig
025D  01C3  	CLRF gbl_17_gbl_bSig+D'1'
025E  01C4  	CLRF gbl_17_gbl_bSig+D'2'
025F  01C5  	CLRF gbl_17_gbl_bSig+D'3'
0260  01C6  	CLRF gbl_17_gbl_zSig
0261  01C7  	CLRF gbl_17_gbl_zSig+D'1'
0262  01C8  	CLRF gbl_17_gbl_zSig+D'2'
0263  01C9  	CLRF gbl_17_gbl_zSig+D'3'
0264  01D6  	CLRF gbl_17_gbl_aExp
0265  01D7  	CLRF gbl_17_gbl_bExp
0266  01D1  	CLRF gbl_17_gbl_zExp
0267  01D2  	CLRF gbl_17_gbl_zExp+D'1'
0268  01D8  	CLRF gbl_17_gbl_aSign
0269  01D9  	CLRF gbl_17_gbl_bSign
026A  01DA  	CLRF gbl_17_gbl_zSign
026B  01DB  	CLRF gbl_17_gbl_zSigZero
026C  01CA  	CLRF gbl_17_gbl_ret
026D  01CB  	CLRF gbl_17_gbl_ret+D'1'
026E  01CC  	CLRF gbl_17_gbl_ret+D'2'
026F  01CD  	CLRF gbl_17_gbl_ret+D'3'
0270  01D4  	CLRF gbl_float_rounding_mode
0271  01D5  	CLRF gbl_float_exception_flags
0272  01D3  	CLRF gbl_float_detect_tininess
0273  118A  	BCF PCLATH,3
0274  120A  	BCF PCLATH,4
0275  29C3  	GOTO	main

2007  30F2  	DW 0x30F2
