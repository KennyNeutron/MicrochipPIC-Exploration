//************************************************************************************
//**  
//**  File name:     C:\Users\gerpe\OneDrive\GER-PER 2016\Documents\KennyNeutron\USART\DUMMYDATA.c
//**  Generated by:  Flowcode v4.2.3.58
//**  Date:          Saturday, July 27, 2019 14:53:44
//**  Licence:       Professional
//**  Registered to: 20ACM8
//**  
//**  
//**  http://www.matrixmultimedia.com
//************************************************************************************


#define MX_PIC

//Defines for microcontroller
#define P16F690
#define MX_EE
#define MX_EE_SIZE 256
#define MX_SPI
#define MX_SPI_BCB
#define MX_SPI_SDI 4
#define MX_SPI_SDO 7
#define MX_SPI_SCK 6
#define MX_UART
#define MX_UART_B
#define MX_UART_TX 7
#define MX_UART_RX 5
#define MX_I2C
#define MX_MI2C
#define MX_I2C_B
#define MX_I2C_SDA 4
#define MX_I2C_SCL 6
#define MX_PWM
#define MX_PWM_CNT 1
#define MX_PWM_TRIS1 trisc
#define MX_PWM_1 5

//Functions
#define MX_CLK_SPEED 3276800
#ifdef _BOOSTC
#include <system.h>
#endif
#ifdef HI_TECH_C
#include <pic.h>
#endif

//Configuration data
#ifdef _BOOSTC
#pragma DATA 0x2007, 0x30d2
#endif
#ifdef HI_TECH_C
__CONFIG(0x30d2);
#endif

//Internal functions
#include "C:\Program Files (x86)\Matrix Multimedia\Flowcode V4\FCD\internals.h"

//Macro function declarations


//Variable declarations


//Defines:

/**** Macro Substitutions ****
portc = RTS Port
trisc = RTS Data Direction
portc = CTS Port
trisc = CTS Data Direction
0 = RTS Pin
4 = CTS Pin
1 = UART Selection		(0-SW / 1-UART1 / 2-UART2)
0 = Flow Control		(0-Off / 1-On)
0 = Debug Enable		(0-Off / 1-On)
0 = Echo Enable		(0-Off / 1-On)
4 = UART TXSTA Value
20 = UART SPBRG Value
RS232_264744 = Unique ID
Unused = Bitbanged Receive Port Register
Unused = Bitbanged Receive Data Direction Register
Unused = Bitbanged Receive Pin
Unused = Bitbanged Transmit Pin
37 = Bitbanged BAUD Rate Delay
0 = Timout	Selection	(0-Legacy / 1-MS Timeout)
0 = Data Size			(0-8 bits / 1-9 bits / 2-7 bits & Only available on BitBanged components)
0 = Parity Enable		(0-No Parity / 1-Odd Parity / 2-Even Parity)
0 = Legacy Return		(0-Legacy mode return 255 / 1-New mode return MSB err flags)
Unused = Bitbanged Transmit Port Register
Unused = Bitbanged Transmit Data Direction Register
******************************/

#define RS232_264744_RTS_PORT			portc
#define RS232_264744_RTS_TRIS			trisc
#define RS232_264744_CTS_PORT			portc
#define RS232_264744_CTS_TRIS			trisc
#define RS232_264744_RTS_PIN			0
#define RS232_264744_CTS_PIN			4
#define RS232_264744_UART				1
#define RS232_264744_TOUT  			0
#define RS232_264744_DATASIZE			0
#define RS232_264744_PARITY			0
#define RS232_264744_LEGACY_RV			0

#if (0 == 1)
  	#define RS232_264744_HARDWARE
#endif

#if (0 == 1)
  	#define RS232_264744_DEBUG
#endif

#if (0 == 1)
  	#define RS232_264744_ECHO
#endif

#if (RS232_264744_UART == 0)
	#define RS232_264744_RX_PORT		Unused
	#define RS232_264744_RX_TRIS		Unused
	#define RS232_264744_SW_RX		Unused
	#define RS232_264744_SW_TX		Unused
	#define RS232_264744_SW_BAUD		37
	#define RS232_264744_TX_PORT		Unused
	#define RS232_264744_TX_TRIS		Unused
#else
	#define RS232_264744_TXSTA_VAL  	4
	#define RS232_264744_SPBRG_VAL  	20
	#define RS232_264744_SW_BAUD		0
#endif

#if (RS232_264744_LEGACY_RV == 0)
	#if (RS232_264744_DATASIZE == 1)
		#pragma error "RS232 Component cannot combine 9-bit data mode with legacy return value of 255 please check the Component properties"
	#endif
#endif

#define RS232_264744_STATUS_LOOP		0
#define RS232_264744_STATUS_TIMEOUT	1
#define RS232_264744_STATUS_RXBYTE	2





//RS2320: //Macro function declarations

void FCD_RS2320_SendRS232Char(short nChar);
void FCD_RS2320_SendRS232String(char* String, char MSZ_String);
short FCD_RS2320_ReceiveRS232Char(short nTimeout);
void FCD_RS2320_ReceiveRS232String(char* FCR_RETVAL, char FCR_RETVAL_SIZE, char nTimeout, char NumBytes);
void FCD_RS2320_RS232_Delay(char mode);



//RS2320: //Macro implementations


void FCD_RS2320_SendRS232Char(short nChar)
{
	
	#if (RS232_264744_UART == 0)

		char dMask;
		char idx;
		char count = 8;

		#ifdef RS232_264744_HARDWARE
			//wait until CTS is low
			while (( RS232_264744_CTS_PORT & (1 << RS232_264744_CTS_PIN) ) != 0);
		#endif

		#if(RS232_264744_DATASIZE == 1)
			count = 9;
		#endif
		#if(RS232_264744_DATASIZE == 2)
			count = 7;
		#endif

		clear_bit( RS232_264744_TX_PORT, RS232_264744_SW_TX);		// Send Start bit
		FCD_RS2320_RS232_Delay(0);

		for (idx = 0; idx < count; idx++)
		{
			dMask = nChar & 0x01;							// Mask off data bit

			if (dMask)
				set_bit( RS232_264744_TX_PORT, RS232_264744_SW_TX);
			else
				clear_bit( RS232_264744_TX_PORT, RS232_264744_SW_TX);

			FCD_RS2320_RS232_Delay(0);
			nChar = nChar >> 1;								// Move to next data bit
		}

		set_bit( RS232_264744_TX_PORT, RS232_264744_SW_TX);			// Send Stop bit
		FCD_RS2320_RS232_Delay(0);

	#endif

	#if (RS232_264744_UART == 1)

		#ifndef MX_UART
			#pragma error "Chip does not have UART capability"
		#endif

		st_bit(txsta, TXEN);
		while (ts_bit(pir1, TXIF) == 0);

		#ifdef RS232_264744_HARDWARE
			//wait until CTS is low
			while (( RS232_264744_CTS_PORT & (1 << RS232_264744_CTS_PIN) ) != 0);
		#endif

		#if(RS232_264744_DATASIZE == 1)
			if (test_bit(nChar, 8))
				st_bit(txsta, TX9D);
			else
				cr_bit(txsta, TX9D);
		#endif

		txreg = nChar;

	#endif

	#if (RS232_264744_UART == 2)

		#ifndef MX_UART2
			#pragma error "Chip does not have second UART capability"
		#endif

		st_bit(txsta2, TXEN);
		while (ts_bit(pir3, TX2IF) == 0);

		#ifdef RS232_264744_HARDWARE
			//wait until CTS is low
			while (( RS232_264744_CTS_PORT & (1 << RS232_264744_CTS_PIN) ) != 0);
		#endif

		#if( RS232_264744_DATASIZE == 1)
			if (test_bit(nChar, 8))
				st_bit(txsta2, TX9D);
			else
				cr_bit(txsta2, TX9D);
		#endif

		txreg2 = nChar;

	#endif

}

void FCD_RS2320_SendRS232String(char* String, char MSZ_String)
{
		char idx;
		for(idx = 0; idx < MSZ_String; idx++)
		{
			#ifdef _BOOSTC
				if (String[idx] == 0)
					break;
				else FCD_RS2320_SendRS232Char(String[idx]);
			#endif
			#ifdef HI_TECH_
				if (*String == 0)
					break;
				else FCD_RS2320_SendRS232Char(*String);
				String++;
			#endif
		}
}

short FCD_RS2320_ReceiveRS232Char(short nTimeout)
{
	
		char delay1 = 0;
		char delay2 = 0;
		char regcheck = 0;
		char dummy = 0;
		short retVal = 512;
		char bWaitForever = 0;
		char rxStatus = RS232_264744_STATUS_LOOP;
		char idx;
		char count = 8;

		#if ( RS232_264744_LEGACY_RV == 0)
			retVal = 255;
		#endif

		#if ( RS232_264744_UART == 1)
			#ifndef MX_UART
				#pragma error "Chip does not have UART capability"
			#endif
		#endif

		#if ( RS232_264744_UART == 2)
			#ifndef MX_UART2
				#pragma error "Chip does not have second UART capability"
			#endif
		#endif

		#ifdef RS232_264744_HARDWARE
			//ready to accept data
			clear_bit( RS232_264744_RTS_PORT, RS232_264744_RTS_PIN);
		#endif

		if (nTimeout == 255)
			bWaitForever = 1;

		#if ( RS232_264744_UART == 1)
			st_bit(rcsta, CREN);
		#endif

		#if ( RS232_264744_UART == 2)
			st_bit(rcsta2, CREN);
		#endif

		while (rxStatus == RS232_264744_STATUS_LOOP)
		{
			if (bWaitForever == 0)
			{
				//don't wait forever, so do timeout thing...
				if (nTimeout == 0)
				{
					rxStatus = RS232_264744_STATUS_TIMEOUT;
				}
				else
				{
					if ( RS232_264744_TOUT)
					{
						delay_us(10);
						delay1 = delay1 + 1;
						if(delay1 == 100)
						{
							nTimeout = nTimeout - 1;
							delay1 = 0;
						}
					}
					else
					{
						//decrement timeout
						delay1 = delay1 - 1;
						if (delay1 == 0)
						{
							nTimeout = nTimeout - 1;
						}
					}
				}
			}

			#if ( RS232_264744_UART == 0)
				regcheck = test_bit(RS232_264744_RX_PORT, RS232_264744_SW_RX);	//Test for start bit
				if (regcheck == 0)
					rxStatus = RS232_264744_STATUS_RXBYTE;
			#endif

			#if ( RS232_264744_UART == 1)
				regcheck = ts_bit(pir1, RCIF);
				if (regcheck != 0)
					rxStatus = RS232_264744_STATUS_RXBYTE;
			#endif

			#if ( RS232_264744_UART == 2)
				regcheck = ts_bit(pir3, RC2IF);
				if (regcheck != 0)
					rxStatus = RS232_264744_STATUS_RXBYTE;
			#endif
		}

		if (rxStatus == RS232_264744_STATUS_RXBYTE)
		{
			#if ( RS232_264744_UART > 0)

				#if ( RS232_264744_UART == 1)
					regcheck = ts_bit(rcsta, FERR);
				#endif

				#if ( RS232_264744_UART == 2)
					regcheck = ts_bit(rcsta2, FERR);
				#endif

				if (regcheck != 0)
				{
					#if ( RS232_264744_UART == 1)
						dummy = rcreg;      //need to read the rcreg to clear FERR
					#endif

					#if ( RS232_264744_UART == 2)
						dummy = rcreg2;      //need to read the rcreg to clear FERR
					#endif

					#ifdef RS232_264744_DEBUG
						FCD_RS2320_SendRS232Char('<');
						FCD_RS2320_SendRS232Char('F');
						FCD_RS2320_SendRS232Char('E');
						FCD_RS2320_SendRS232Char('R');
						FCD_RS2320_SendRS232Char('R');
						FCD_RS2320_SendRS232Char('>');
					#endif

					#if ( RS232_264744_LEGACY_RV == 1)
						retVal = 0x400;					//Framing Error Flag
					#endif
				}
				else
				{
					#if ( RS232_264744_UART == 1)
						regcheck = ts_bit(rcsta, OERR);
					#endif

					#if ( RS232_264744_UART == 2)
						regcheck = ts_bit(rcsta2, OERR);
					#endif

					if (regcheck != 0)
					{
						//need to read the rcreg to clear error
						#if ( RS232_264744_UART == 1)
							cr_bit(rcsta, CREN);
							st_bit(rcsta, CREN);
						#endif

						#if ( RS232_264744_UART == 2)
							cr_bit(rcsta2, CREN);
							st_bit(rcsta2, CREN);
						#endif

						#ifdef RS232_264744_DEBUG
							FCD_RS2320_SendRS232Char('<');
							FCD_RS2320_SendRS232Char('O');
							FCD_RS2320_SendRS232Char('E');
							FCD_RS2320_SendRS232Char('R');
							FCD_RS2320_SendRS232Char('R');
							FCD_RS2320_SendRS232Char('>');
						#endif

						#if ( RS232_264744_LEGACY_RV == 1)
							retVal = 0x800;					//Overrun Error Flag
						#endif

					}
					else
					{
						#if ( RS232_264744_UART == 1)
							retVal = rcreg; 			//no error, so rx byte is valid

							#if( RS232_264744_DATASIZE == 1)
								if(ts_bit(rcsta, RX9D));
									retVal = retVal | 0x100;
							#endif

						#endif

						#if ( RS232_264744_UART == 2)
							retVal = rcreg2; 			//no error, so rx byte is valid

							#if( RS232_264744_DATASIZE == 1)
								if(ts_bit(rcsta2, RX9D));
									retVal = retVal | 0x100;
							#endif

						#endif

						#ifdef RS232_264744_ECHO
							FCD_RS2320_SendRS232Char(retVal);
						#endif
					}
				}
			#else
				#if( RS232_264744_DATASIZE == 1)
					count = 9;
				#endif

				FCD_RS2320_RS232_Delay(1);
				for (idx = 0; idx < count; idx++)
				{
					retVal = retVal >> 1;

					if(count == 9)
					{
						if (test_bit( RS232_264744_RX_PORT, RS232_264744_SW_RX))
							retVal = retVal | 0x100;
					}
					else
					{
						if (test_bit( RS232_264744_RX_PORT, RS232_264744_SW_RX))
							retVal = retVal | 0x80;
					}
					FCD_RS2320_RS232_Delay(1);
				}

				#ifdef RS232_264744_ECHO
					FCD_RS2320_SendRS232Char(retVal);
				#endif

			#endif
		}
		#ifdef RS232_264744_HARDWARE
			//not ready to accept data
			set_bit( RS232_264744_RTS_PORT, RS232_264744_RTS_PIN);
		#endif

		return (retVal);
}

void FCD_RS2320_ReceiveRS232String(char* FCR_RETVAL, char FCR_RETVAL_SIZE, char nTimeout, char NumBytes)
{
		char idx;
		short in;

		#if ( RS232_264744_LEGACY_RV == 0 )
			#define RS232_TO 	255
		#else
			#define RS232_TO 	256
		#endif

		if (NumBytes > FCR_RETVAL_SIZE)
			NumBytes = FCR_RETVAL_SIZE;

		for (idx = 0; idx < NumBytes; idx++)
		{
			in = FCD_RS2320_ReceiveRS232Char(nTimeout);
			if(in < RS232_TO)
				FCR_RETVAL[idx] = in & 0xFF;
			else
				break;
		}

		if (idx < FCR_RETVAL_SIZE)
			FCR_RETVAL[idx] = 0;

		#undef RS232_TO
}

void FCD_RS2320_RS232_Delay(char mode)
{
		unsigned int iterations;
		unsigned int delay = RS232_264744_SW_BAUD;

		if (mode)
			delay = delay + 1;

		for (iterations = 0; iterations < delay; iterations++);
}

//Macro implementations

void main()
{
	
	//Initialisation
	ansel = 0;
anselh = 0;

	
	#if (RS232_264744_UART == 0)
		set_bit(RS232_264744_RX_TRIS, RS232_264744_SW_RX);		// Receive pin is a input
		clear_bit(RS232_264744_TX_TRIS, RS232_264744_SW_TX);	// Transmit pin is a output
		set_bit(RS232_264744_TX_PORT, RS232_264744_SW_TX);		// Transmit pin is default high
	#endif

	#if (RS232_264744_UART == 1)
		txsta = RS232_264744_TXSTA_VAL;   					// 8-bit, async, low speed, off
		spbrg = RS232_264744_SPBRG_VAL;   					// set the baud rate
		rcsta = 0;                    				// 8-bit, disabled

		if(RS232_264744_DATASIZE == 1)
		{
			st_bit(txsta, TX9);   						// 9-bit TX
			st_bit(rcsta, RX9);                    	// 9-bit RX
		}

		st_bit(rcsta, SPEN);         					// turn on serial interface
	#endif

	#if (RS232_264744_UART == 2)

		txsta2 = RS232_264744_TXSTA_VAL;   					// 8-bit, async, low speed, off
		spbrg2 = RS232_264744_SPBRG_VAL;   					// set the baud rate
		rcsta2 = 0;                    					// 8-bit, disabled

		if(RS232_264744_DATASIZE == 1)
		{
			st_bit(txsta2, TX9);   					// 9-bit TX
			st_bit(rcsta2, RX9);                    	// 9-bit RX
		}

		st_bit(rcsta2, SPEN);         					// turn on serial interface
	#endif

	#ifdef RS232_264744_HARDWARE
		set_bit( RS232_264744_CTS_TRIS, RS232_264744_CTS_PIN);	//CTS is an input
		clear_bit( RS232_264744_RTS_TRIS, RS232_264744_RTS_PIN);	//RTS is an output
		set_bit( RS232_264744_RTS_PORT, RS232_264744_RTS_PIN); 	//not ready to accept data
	#endif


	//Interrupt initialisation code
	option_reg = 0xC0;


	//Loop
	//Loop: While 1
	while (1)
	{
		//Call Component Macro
		//Call Component Macro: RS232(0)::SendRS232String("AA5523109367051231342321AB")
		FCD_RS2320_SendRS232String("AA5523109367051231342321AB",26);


		//Delay
		//Delay: 500 ms
		delay_ms(255);
		delay_ms(245);


	}


	mainendloop: goto mainendloop;
}

void MX_INTERRUPT_MACRO(void)
{
}



