;/////////////////////////////////////////////////////////////////////////////////
;// Code Generator: BoostC Compiler - http://www.sourceboost.com
;// Version       : 7.03
;// License Type  : Pro License
;// Limitations   : PIC12,PIC16 max code size:Unlimited, max RAM banks:Unlimited
;/////////////////////////////////////////////////////////////////////////////////

/*********************************************************************
 *                  Flowcode CAL Delays File
 *
 * File: PIC_CAL_Delay.c
 *
 * (c) 2011 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * “Company”) for its Flowcode graphical programming language is
 * intended and supplied to you, the Company’s customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 010911 | BR | Created
 *
 *
 *
 */

//Original Byte Delays
void Wdt_Delay_S(char delay);
void Wdt_Delay_Ms(char delay);

//New Int Delays
void FCI_DELAYINT_US(MX_UINT16 Delay);

void FCI_DELAYINT_MS(MX_UINT16 Delay);
void FCI_DELAYINTWDT_MS(MX_UINT16 Delay);

void FCI_DELAYINT_S(MX_UINT16 Delay);
void FCI_DELAYINTWDT_S(MX_UINT16 Delay);


#ifdef HI_TECH_C

	#define nop()	asm("NOP")

	void delay_10us(char del);
	void delay_us(char del);
	void delay_ms(char del);
	void delay_s(char del);

	void delay_10us(char del)
	{
		char count;
		for(count=0; count<10; count++)
		{
			delay_us(del);
		}
	}

	void delay_us(char del)
	{
		while (del > 1)
		{
			__delay_us(1);
			del = del - 1;
		}
	}

	void delay_ms(char del)
	{
		while (del > 1)
		{
			__delay_ms(1);
			del = del - 1;
		}
	}

	void delay_s(char del)
	{
		char i;
		for(i=0; i<del; i++)
		{
			delay_ms(250);
			delay_ms(250);
			delay_ms(250);
			delay_ms(250);
		}
	}

#endif

void Wdt_Delay_S(char delay)
{
    char i;
    short j;
    for (i=0; i<delay; i++)
    {
        for (j=0; j<999; j++)
        {
            Wdt_Delay_Ms(1);
        }
    }
}

void Wdt_Delay_Ms(char delay)

{
    char i;
    for (i=0; i<delay; i++)
0021  01C6  	CLRF Wdt_Delay__0003E_1_i
0022        label4
0022  0845  	MOVF Wdt_Delay__0003E_arg_delay, W
0023  0246  	SUBWF Wdt_Delay__0003E_1_i, W
0024  1803  	BTFSC STATUS,C
002A  0AC6  	INCF Wdt_Delay__0003E_1_i, F
002B  2822  	GOTO	label4

    {
        MX_CLEAR_WATCHDOG;        //Clear Watchdog Timer
0026  0064  	CLRWDT

        delay_ms(1);
0027  3001  	MOVLW 0x01
0028  00C7  	MOVWF delay_ms_00000_arg_del
0029  2010  	CALL delay_ms_00000

    }
}
0025  0008  	RETURN



void FCI_DELAYINT_US(MX_UINT16 Delay)
{
  	while (Delay > 255)
  	{
	  	delay_us(255);
	  	Delay = Delay - 255;
  	}
  	if (Delay > 0)
  		delay_us(Delay & 0xFF);
}

void FCI_DELAYINT_MS(MX_UINT16 Delay)
{
  	while (Delay > 255)
  	{
	  	delay_ms(255);
	  	Delay = Delay - 255;
  	}
  	if (Delay > 0)
  		delay_ms(Delay & 0xFF);
}

void FCI_DELAYINTWDT_MS(MX_UINT16 Delay)
{
  	while (Delay > 255)
  	{
	  	Wdt_Delay_Ms(255);
	  	Delay = Delay - 255;
  	}
  	if (Delay > 0)
  		Wdt_Delay_Ms(Delay & 0xFF);
}

void FCI_DELAYINT_S(MX_UINT16 Delay)
{
  	while (Delay > 255)
  	{
	  	delay_s(255);
	  	Delay = Delay - 255;
  	}
  	if (Delay > 0)
  		delay_s(Delay & 0xFF);
}

void FCI_DELAYINTWDT_S(MX_UINT16 Delay)
{
  	while (Delay > 255)
  	{
	  	Wdt_Delay_S(255);
	  	Delay = Delay - 255;
  	}
  	if (Delay > 0)
  		Wdt_Delay_S(Delay & 0xFF);
}



//************************************************************************************
//**  
//**  File name:     C:\Users\gerpe\OneDrive\GER-PER 2016\Documents\KennyNeutron\dotHex\I2C\I2C.c
//**  Title:         
//**  Description:   
//**  
//**  Generated by:  Flowcode v5.2.0.0
//**  Date:          Tuesday, December 17, 2019 15:39:07
//**  Licence:       Professional
//**  Registered to: xyz
//**  Licence key:   WUK7B9
//**  
//**  
//**  http://www.matrixmultimedia.com
//**  
//************************************************************************************


#define MX_PIC

#define MX_USES_UINT8 1
#define MX_USES_SINT16 0
#define MX_USES_CHAR 0
#define MX_USES_FLOAT 0
#define MX_USES_SINT32 0
#define MX_USES_BOOL 1
#define MX_USES_UINT16 0
#define MX_USES_UINT32 0
//Defines for microcontroller
#define P16F873A
#define FC_CAL_PIC
#define MX_ADC
#define MX_ADC_TYPE_1
#define MX_ADC_BITS_10
#define MX_EE
#define MX_EE_TYPE2
#define MX_EE_SIZE 128
#define MX_SPI_1
#define MX_SPI_1_MISO_PORT portc
#define MX_SPI_1_MISO_TRIS trisc
#define MX_SPI_1_MISO_PIN 4
#define MX_SPI_1_MOSI_PORT portc
#define MX_SPI_1_MOSI_TRIS trisc
#define MX_SPI_1_MOSI_PIN 5
#define MX_SPI_1_CLK_PORT portc
#define MX_SPI_1_CLK_TRIS trisc
#define MX_SPI_1_CLK_PIN 3
#define MX_SPI_1_SS_PORT portc
#define MX_SPI_1_SS_TRIS trisc
#define MX_UART_1
#define MX_UART_1_TX_PORT portc
#define MX_UART_1_TX_TRIS trisc
#define MX_UART_1_TX_PIN 6
#define MX_UART_1_RX_PORT portc
#define MX_UART_1_RX_TRIS trisc
#define MX_UART_1_RX_PIN 7
#define MX_I2C
#define MX_MI2C
#define MX_I2C_1
#define MX_I2C_1_SDA_PORT portc
#define MX_I2C_1_SDA_TRIS trisc
#define MX_I2C_1_SDA_PIN 4
#define MX_I2C_1_SCL_PORT portc
#define MX_I2C_1_SCL_TRIS trisc
#define MX_I2C_1_SCL_PIN 3
#define MX_PWM
#define MX_PWM_CNT 2
#define MX_PWM_PSCA1
#define MX_PWM_PSCA4
#define MX_PWM_PSCA16
#define MX_PWM_1_PORT portc
#define MX_PWM_1_TRIS trisc
#define MX_PWM_1_PIN 2
#define MX_PWM_2_PORT portc
#define MX_PWM_2_TRIS trisc
#define MX_PWM_2_PIN 1

//Functions
#define MX_CLK_SPEED 2000000
#ifdef _BOOSTC
#include <system.h>
#endif
#ifdef HI_TECH_C
#include <pic.h>
#endif

//Configuration data
#ifdef _BOOSTC
#pragma DATA 0x2007, 0x3f3a
#endif
#ifdef HI_TECH_C
__CONFIG(0x3f3a);
#endif

//Internal functions
#include "C:\Program Files (x86)\Flowcode\v5\FCD\internals.c"

//Macro function declarations
void FCM_IIC_START();
void FCM_IIC_STOP();
void FCM_IIC_CLKP();
void FCM_IIC_WRITEID_W();
void FCM_IIC_SACK();


//Variable declarations
#define FCV_TRUE (1)
#define FCV_FALSE (0)
MX_UINT8 FCV_RETURN = (0x1);
0161  3001  	MOVLW 0x01
0162  00C2  	MOVWF gbl_FCV_RETURN

MX_BOOL FCV_ACK;




//LCDDisplay(0): //Defines:

/**** Macro Substitutions ****
a = Unique Component Reference Number
b = D1 Port Letter
c = D2 Port Letter
d = D3 Port Letter
e = D4 Port Letter
f = RS Port Letter
g = E Port Letter
h = Data 1_Pin
i = Data 2 Pin
j = Data 3 Pin
k = Data 4 Pin
l = RS Pin
m = Enable Pin
n = Row Count
o = Column Count
******************************/

	//component connections
	#define LCD_1__PORT0    portc
	#define LCD_1__PORT1    portb
	#define LCD_1__PORT2    portb
	#define LCD_1__PORT3    portc
	#define LCD_1__PORT4    portc
	#define LCD_1__PORT5    portc
	#define LCD_1__TRIS0    trisc
	#define LCD_1__TRIS1    trisb
	#define LCD_1__TRIS2    trisb
	#define LCD_1__TRIS3    trisc
	#define LCD_1__TRIS4    trisc
	#define LCD_1__TRIS5    trisc
	#define LCD_1__BIT0    	2
	#define LCD_1__BIT1    	3
	#define LCD_1__BIT2    	4
	#define LCD_1__BIT3    	5
	#define LCD_1__RS      	0
	#define LCD_1__E       	1
	#define LCD_1__ROWCNT	4
	#define LCD_1__COLCNT	20

	#ifdef _BOOSTC
	  #define LCD_1__DELAY   delay_10us(10)
	#endif
	#ifdef _C2C_
	  #define LCD_1__DELAY   delay_us(100)
	#endif
	#ifdef HI_TECH_C
	  #define LCD_1__DELAY   __delay_us(120)
	#endif
	#ifndef LCD_1__DELAY
	  #define LCD_1__DELAY   delay_us(100)
	#endif




//LCDDisplay(0): //Macro function declarations

void FCD_LCDDisplay0_RawSend(MX_UINT8 in, MX_UINT8 mask);
void FCD_LCDDisplay0_Start();
void FCD_LCDDisplay0_Clear();
void FCD_LCDDisplay0_PrintASCII(MX_UINT8 Character);
void FCD_LCDDisplay0_Command(MX_UINT8 in);
void FCD_LCDDisplay0_Cursor(MX_UINT8 x, MX_UINT8 y);
void FCD_LCDDisplay0_PrintNumber(MX_SINT16 Number);
void FCD_LCDDisplay0_PrintString(MX_STRING String, MX_UINT8 MSZ_String);
void FCD_LCDDisplay0_ScrollDisplay(MX_UINT8 Direction, MX_UINT8 Num_Positions);
void FCD_LCDDisplay0_ClearLine(MX_UINT8 Line);
void FCD_LCDDisplay0_RAM_Write(MX_UINT8 nIdx, MX_UINT8 d0, MX_UINT8 d1, MX_UINT8 d2, MX_UINT8 d3, MX_UINT8 d4, MX_UINT8 d5, MX_UINT8 d6, MX_UINT8 d7);


//I2C_Master(0): //Defines:

/**** Macro Substitutions ****
a = Unique component ID
b = I2C Channel - 0=SW, 1-4=HW
c = Baud Rate
d = SM BUS Enable 0/2
e = Slew Rate Enable 0/1
f = Bitbanged Data Port Letter
g = Bitbanged Data Pin
h = Bitbanged Clock Port Letter
i = Bitbanged Clock Pin
******************************/

//BMODE
//Bit 0 - Slew Control
//Bit 1 - SMBus Control

//Definitions for I2C slot allocation
#ifndef	MX_I2C_REF1
	#define MX_I2C_REF1
	#define I2CMASTER_2_MX_I2C_UREF			1
	#define MX_I2C_CHANNEL_1		0
	#define MX_I2C_SDA_PIN_1		4
	#define MX_I2C_SDA_PORT_1		portc
	#define MX_I2C_SDA_TRIS_1		trisc
	#define MX_I2C_SCL_PIN_1		3
	#define MX_I2C_SCL_PORT_1		portc
	#define MX_I2C_SCL_TRIS_1		trisc
	#define MX_I2C_BMODE_1			1 | 0
	#define MX_I2C_BAUD_1			100000
	#define MX_I2C_INT_1			0
#else
 #ifndef MX_I2C_REF2
	#define MX_I2C_REF2
	#define I2CMASTER_2_MX_I2C_UREF			2
	#define MX_I2C_CHANNEL_2		0
	#define MX_I2C_SDA_PIN_2		4
	#define MX_I2C_SDA_PORT_2		portc
	#define MX_I2C_SDA_TRIS_2		trisc
	#define MX_I2C_SCL_PIN_2		3
	#define MX_I2C_SCL_PORT_2		portc
	#define MX_I2C_SCL_TRIS_2		trisc
	#define MX_I2C_BMODE_2			1 | 0
	#define MX_I2C_BAUD_2			100000
	#define MX_I2C_INT_2			0
 #else
  #ifndef MX_I2C_REF3
	#define MX_I2C_REF3
	#define I2CMASTER_2_MX_I2C_UREF			3
	#define MX_I2C_CHANNEL_3		0
	#define MX_I2C_SDA_PIN_3		4
	#define MX_I2C_SDA_PORT_3		portc
	#define MX_I2C_SDA_TRIS_3		trisc
	#define MX_I2C_SCL_PIN_3		3
	#define MX_I2C_SCL_PORT_3		portc
	#define MX_I2C_SCL_TRIS_3		trisc
	#define MX_I2C_BMODE_3			1 | 0
	#define MX_I2C_BAUD_3			100000
	#define MX_I2C_INT_3			0
  #else
   #ifndef MX_I2C_REF4
	#define MX_I2C_REF4
	#define I2CMASTER_2_MX_I2C_UREF			4
	#define MX_I2C_CHANNEL_4		0
	#define MX_I2C_SDA_PIN_4		4
	#define MX_I2C_SDA_PORT_4		portc
	#define MX_I2C_SDA_TRIS_4		trisc
	#define MX_I2C_SCL_PIN_4		3
	#define MX_I2C_SCL_PORT_4		portc
	#define MX_I2C_SCL_TRIS_4		trisc
	#define MX_I2C_BMODE_4			1 | 0
	#define MX_I2C_BAUD_4			100000
	#define MX_I2C_INT_4			0
   #endif
  #endif
 #endif
#endif

#define I2CMASTER_2_I2C_Master_Init		CAL_APPEND(FC_CAL_I2C_Master_Init_, I2CMASTER_2_MX_I2C_UREF)
#define I2CMASTER_2_I2C_Master_Uninit	CAL_APPEND(FC_CAL_I2C_Master_Uninit_, I2CMASTER_2_MX_I2C_UREF)
#define I2CMASTER_2_I2C_Master_Start		CAL_APPEND(FC_CAL_I2C_Master_Start_, I2CMASTER_2_MX_I2C_UREF)
#define I2CMASTER_2_I2C_Master_Restart	CAL_APPEND(FC_CAL_I2C_Master_Restart_, I2CMASTER_2_MX_I2C_UREF)
#define I2CMASTER_2_I2C_Master_Stop		CAL_APPEND(FC_CAL_I2C_Master_Stop_, I2CMASTER_2_MX_I2C_UREF)
#define I2CMASTER_2_I2C_Master_TX_Byte	CAL_APPEND(FC_CAL_I2C_Master_TX_Byte_, I2CMASTER_2_MX_I2C_UREF)
#define I2CMASTER_2_I2C_Master_RX_Byte	CAL_APPEND(FC_CAL_I2C_Master_RX_Byte_, I2CMASTER_2_MX_I2C_UREF)

extern void I2CMASTER_2_I2C_Master_Init ();
extern void I2CMASTER_2_I2C_Master_Uninit ();
extern void I2CMASTER_2_I2C_Master_Start ();
extern void I2CMASTER_2_I2C_Master_Restart ();
extern void I2CMASTER_2_I2C_Master_Stop ();
extern MX_UINT8 I2CMASTER_2_I2C_Master_TX_Byte (MX_UINT8 Data);
extern MX_UINT8 I2CMASTER_2_I2C_Master_RX_Byte (MX_UINT8 Last);




//I2C_Master(0): //Macro function declarations

void FCD_I2C_Master0_MI2C_Init();
void FCD_I2C_Master0_MI2C_Start();
void FCD_I2C_Master0_MI2C_Restart();
void FCD_I2C_Master0_MI2C_Stop();
MX_UINT8 FCD_I2C_Master0_MI2C_Transmit_Byte(MX_UINT8 Data);
MX_UINT8 FCD_I2C_Master0_MI2C_Receive_Byte(MX_UINT8 Last);
void FCD_I2C_Master0_MI2C_Send_Byte_Transaction(MX_UINT8 Device_ID, MX_UINT8 AddrH, MX_UINT8 AddrL, MX_UINT8 Data);
MX_UINT8 FCD_I2C_Master0_MI2C_Receive_Byte_Transaction(MX_UINT8 Device_ID, MX_UINT8 AddrH, MX_UINT8 AddrL);



//LCDDisplay(0): //Macro implementations


void FCD_LCDDisplay0_RawSend(MX_UINT8 in, MX_UINT8 mask)

{
	
		MX_UINT8 pt;

		FC_CAL_Bit_Low(LCD_1__PORT0, LCD_1__BIT0);
0031  1107  	BCF gbl_portc,2

		FC_CAL_Bit_Low(LCD_1__PORT1, LCD_1__BIT1);
0032  1186  	BCF gbl_portb,3

		FC_CAL_Bit_Low(LCD_1__PORT2, LCD_1__BIT2);
0033  1206  	BCF gbl_portb,4

		FC_CAL_Bit_Low(LCD_1__PORT3, LCD_1__BIT3);
0034  1287  	BCF gbl_portc,5

		FC_CAL_Bit_Low(LCD_1__PORT4, LCD_1__RS);
0035  1007  	BCF gbl_portc,0

		FC_CAL_Bit_Low(LCD_1__PORT5, LCD_1__E);
0036  1087  	BCF gbl_portc,1

		pt = ((in >> 4) & 0x0f);
0037  0E53  	SWAPF FCD_LCDDis_00056_arg_in, W
0038  390F  	ANDLW 0x0F
0039  00D5  	MOVWF FCD_LCDDis_00056_1_pt
003A  300F  	MOVLW 0x0F
003B  05D5  	ANDWF FCD_LCDDis_00056_1_pt, F

		if (pt & 0x01)
003C  1855  	BTFSC FCD_LCDDis_00056_1_pt,0

		    FC_CAL_Bit_High(LCD_1__PORT0, LCD_1__BIT0);
003D  1507  	BSF gbl_portc,2

		if (pt & 0x02)
003E  18D5  	BTFSC FCD_LCDDis_00056_1_pt,1

		    FC_CAL_Bit_High(LCD_1__PORT1, LCD_1__BIT1);
003F  1586  	BSF gbl_portb,3

		if (pt & 0x04)
0040  1955  	BTFSC FCD_LCDDis_00056_1_pt,2

		    FC_CAL_Bit_High(LCD_1__PORT2, LCD_1__BIT2);
0041  1606  	BSF gbl_portb,4

		if (pt & 0x08)
0042  19D5  	BTFSC FCD_LCDDis_00056_1_pt,3

		    FC_CAL_Bit_High(LCD_1__PORT3, LCD_1__BIT3);
0043  1687  	BSF gbl_portc,5

		if (mask)
0044  08D4  	MOVF FCD_LCDDis_00056_arg_mask, F
0045  1D03  	BTFSS STATUS,Z

		    FC_CAL_Bit_High(LCD_1__PORT4, LCD_1__RS);
0046  1407  	BSF gbl_portc,0

		LCD_1__DELAY;
0047  300A  	MOVLW 0x0A
0048  00D6  	MOVWF delay_10us_00000_arg_del
0049  201C  	CALL delay_10us_00000

		FC_CAL_Bit_High (LCD_1__PORT5, LCD_1__E);
004A  1487  	BSF gbl_portc,1

		LCD_1__DELAY;
004B  300A  	MOVLW 0x0A
004C  00D6  	MOVWF delay_10us_00000_arg_del
004D  201C  	CALL delay_10us_00000

		FC_CAL_Bit_Low (LCD_1__PORT5, LCD_1__E);
004E  1087  	BCF gbl_portc,1

		pt = (in & 0x0f);
004F  300F  	MOVLW 0x0F
0050  0553  	ANDWF FCD_LCDDis_00056_arg_in, W
0051  00D5  	MOVWF FCD_LCDDis_00056_1_pt

		LCD_1__DELAY;
0052  300A  	MOVLW 0x0A
0053  00D6  	MOVWF delay_10us_00000_arg_del
0054  201C  	CALL delay_10us_00000

		FC_CAL_Bit_Low(LCD_1__PORT0, LCD_1__BIT0);
0055  1107  	BCF gbl_portc,2

		FC_CAL_Bit_Low(LCD_1__PORT1, LCD_1__BIT1);
0056  1186  	BCF gbl_portb,3

		FC_CAL_Bit_Low(LCD_1__PORT2, LCD_1__BIT2);
0057  1206  	BCF gbl_portb,4

		FC_CAL_Bit_Low(LCD_1__PORT3, LCD_1__BIT3);
0058  1287  	BCF gbl_portc,5

		FC_CAL_Bit_Low(LCD_1__PORT4, LCD_1__RS);
0059  1007  	BCF gbl_portc,0

		FC_CAL_Bit_Low(LCD_1__PORT5, LCD_1__E);
005A  1087  	BCF gbl_portc,1

		if (pt & 0x01)
005B  1855  	BTFSC FCD_LCDDis_00056_1_pt,0

		    FC_CAL_Bit_High(LCD_1__PORT0, LCD_1__BIT0);
005C  1507  	BSF gbl_portc,2

		if (pt & 0x02)
005D  18D5  	BTFSC FCD_LCDDis_00056_1_pt,1

		    FC_CAL_Bit_High(LCD_1__PORT1, LCD_1__BIT1);
005E  1586  	BSF gbl_portb,3

		if (pt & 0x04)
005F  1955  	BTFSC FCD_LCDDis_00056_1_pt,2

		    FC_CAL_Bit_High(LCD_1__PORT2, LCD_1__BIT2);
0060  1606  	BSF gbl_portb,4

		if (pt & 0x08)
0061  19D5  	BTFSC FCD_LCDDis_00056_1_pt,3

		    FC_CAL_Bit_High(LCD_1__PORT3, LCD_1__BIT3);
0062  1687  	BSF gbl_portc,5

		if (mask)
0063  08D4  	MOVF FCD_LCDDis_00056_arg_mask, F
0064  1D03  	BTFSS STATUS,Z

		    FC_CAL_Bit_High(LCD_1__PORT4, LCD_1__RS);
0065  1407  	BSF gbl_portc,0

		LCD_1__DELAY;
0066  300A  	MOVLW 0x0A
0067  00D6  	MOVWF delay_10us_00000_arg_del
0068  201C  	CALL delay_10us_00000

		FC_CAL_Bit_High (LCD_1__PORT5, LCD_1__E);
0069  1487  	BSF gbl_portc,1

		LCD_1__DELAY;
006A  300A  	MOVLW 0x0A
006B  00D6  	MOVWF delay_10us_00000_arg_del
006C  201C  	CALL delay_10us_00000

		FC_CAL_Bit_Low (LCD_1__PORT5, LCD_1__E);
006D  1087  	BCF gbl_portc,1

		LCD_1__DELAY;
006E  300A  	MOVLW 0x0A
006F  00D6  	MOVWF delay_10us_00000_arg_del
0070  201C  	CALL delay_10us_00000


}
0071  0008  	RETURN


void FCD_LCDDisplay0_Start()

{
	
		FC_CAL_Bit_Low_DDR(LCD_1__PORT0, LCD_1__TRIS0, LCD_1__BIT0);
00BD  1683  	BSF STATUS, RP0
00BE  1303  	BCF STATUS, RP1
00BF  1107  	BCF gbl_trisc,2
00C0  1283  	BCF STATUS, RP0
00C1  1107  	BCF gbl_portc,2

		FC_CAL_Bit_Low_DDR(LCD_1__PORT1, LCD_1__TRIS1, LCD_1__BIT1);
00C2  1683  	BSF STATUS, RP0
00C3  1186  	BCF gbl_trisb,3
00C4  1283  	BCF STATUS, RP0
00C5  1186  	BCF gbl_portb,3

		FC_CAL_Bit_Low_DDR(LCD_1__PORT2, LCD_1__TRIS2, LCD_1__BIT2);
00C6  1683  	BSF STATUS, RP0
00C7  1206  	BCF gbl_trisb,4
00C8  1283  	BCF STATUS, RP0
00C9  1206  	BCF gbl_portb,4

		FC_CAL_Bit_Low_DDR(LCD_1__PORT3, LCD_1__TRIS3, LCD_1__BIT3);
00CA  1683  	BSF STATUS, RP0
00CB  1287  	BCF gbl_trisc,5
00CC  1283  	BCF STATUS, RP0
00CD  1287  	BCF gbl_portc,5

		FC_CAL_Bit_Low_DDR(LCD_1__PORT4, LCD_1__TRIS4, LCD_1__RS);
00CE  1683  	BSF STATUS, RP0
00CF  1007  	BCF gbl_trisc,0
00D0  1283  	BCF STATUS, RP0
00D1  1007  	BCF gbl_portc,0

		FC_CAL_Bit_Low_DDR(LCD_1__PORT5, LCD_1__TRIS5, LCD_1__E);
00D2  1683  	BSF STATUS, RP0
00D3  1087  	BCF gbl_trisc,1
00D4  1283  	BCF STATUS, RP0
00D5  1087  	BCF gbl_portc,1


		Wdt_Delay_Ms(12);
00D6  300C  	MOVLW 0x0C
00D7  00C5  	MOVWF Wdt_Delay__0003E_arg_delay
00D8  2021  	CALL Wdt_Delay__0003E


		FCD_LCDDisplay0_RawSend(0x33, 0);
00D9  3033  	MOVLW 0x33
00DA  00D3  	MOVWF FCD_LCDDis_00056_arg_in
00DB  01D4  	CLRF FCD_LCDDis_00056_arg_mask
00DC  2031  	CALL FCD_LCDDis_00056

		Wdt_Delay_Ms(2);
00DD  3002  	MOVLW 0x02
00DE  00C5  	MOVWF Wdt_Delay__0003E_arg_delay
00DF  2021  	CALL Wdt_Delay__0003E

		FCD_LCDDisplay0_RawSend(0x33, 0);
00E0  3033  	MOVLW 0x33
00E1  00D3  	MOVWF FCD_LCDDis_00056_arg_in
00E2  01D4  	CLRF FCD_LCDDis_00056_arg_mask
00E3  2031  	CALL FCD_LCDDis_00056

		Wdt_Delay_Ms(2);
00E4  3002  	MOVLW 0x02
00E5  00C5  	MOVWF Wdt_Delay__0003E_arg_delay
00E6  2021  	CALL Wdt_Delay__0003E

		FCD_LCDDisplay0_RawSend(0x32, 0);
00E7  3032  	MOVLW 0x32
00E8  00D3  	MOVWF FCD_LCDDis_00056_arg_in
00E9  01D4  	CLRF FCD_LCDDis_00056_arg_mask
00EA  2031  	CALL FCD_LCDDis_00056

		Wdt_Delay_Ms(2);
00EB  3002  	MOVLW 0x02
00EC  00C5  	MOVWF Wdt_Delay__0003E_arg_delay
00ED  2021  	CALL Wdt_Delay__0003E

		FCD_LCDDisplay0_RawSend(0x2c, 0);
00EE  302C  	MOVLW 0x2C
00EF  00D3  	MOVWF FCD_LCDDis_00056_arg_in
00F0  01D4  	CLRF FCD_LCDDis_00056_arg_mask
00F1  2031  	CALL FCD_LCDDis_00056

		Wdt_Delay_Ms(2);
00F2  3002  	MOVLW 0x02
00F3  00C5  	MOVWF Wdt_Delay__0003E_arg_delay
00F4  2021  	CALL Wdt_Delay__0003E

		FCD_LCDDisplay0_RawSend(0x06, 0);
00F5  3006  	MOVLW 0x06
00F6  00D3  	MOVWF FCD_LCDDis_00056_arg_in
00F7  01D4  	CLRF FCD_LCDDis_00056_arg_mask
00F8  2031  	CALL FCD_LCDDis_00056

		Wdt_Delay_Ms(2);
00F9  3002  	MOVLW 0x02
00FA  00C5  	MOVWF Wdt_Delay__0003E_arg_delay
00FB  2021  	CALL Wdt_Delay__0003E

		FCD_LCDDisplay0_RawSend(0x0c, 0);
00FC  300C  	MOVLW 0x0C
00FD  00D3  	MOVWF FCD_LCDDis_00056_arg_in
00FE  01D4  	CLRF FCD_LCDDis_00056_arg_mask
00FF  2031  	CALL FCD_LCDDis_00056

		Wdt_Delay_Ms(2);
0100  3002  	MOVLW 0x02
0101  00C5  	MOVWF Wdt_Delay__0003E_arg_delay
0102  2021  	CALL Wdt_Delay__0003E


		//clear the display
		FCD_LCDDisplay0_RawSend(0x01, 0);
0103  3001  	MOVLW 0x01
0104  00D3  	MOVWF FCD_LCDDis_00056_arg_in
0105  01D4  	CLRF FCD_LCDDis_00056_arg_mask
0106  2031  	CALL FCD_LCDDis_00056

		Wdt_Delay_Ms(2);
0107  3002  	MOVLW 0x02
0108  00C5  	MOVWF Wdt_Delay__0003E_arg_delay
0109  2021  	CALL Wdt_Delay__0003E

		FCD_LCDDisplay0_RawSend(0x02, 0);
010A  3002  	MOVLW 0x02
010B  00D3  	MOVWF FCD_LCDDis_00056_arg_in
010C  01D4  	CLRF FCD_LCDDis_00056_arg_mask
010D  2031  	CALL FCD_LCDDis_00056

		Wdt_Delay_Ms(2);
010E  3002  	MOVLW 0x02
010F  00C5  	MOVWF Wdt_Delay__0003E_arg_delay
0110  2021  	CALL Wdt_Delay__0003E


}
0111  0008  	RETURN


void FCD_LCDDisplay0_Clear()

{
	
		FCD_LCDDisplay0_RawSend(0x01, 0);
00AC  3001  	MOVLW 0x01
00AD  1283  	BCF STATUS, RP0
00AE  1303  	BCF STATUS, RP1
00AF  00D3  	MOVWF FCD_LCDDis_00056_arg_in
00B0  01D4  	CLRF FCD_LCDDis_00056_arg_mask
00B1  2031  	CALL FCD_LCDDis_00056

		Wdt_Delay_Ms(2);
00B2  3002  	MOVLW 0x02
00B3  00C5  	MOVWF Wdt_Delay__0003E_arg_delay
00B4  2021  	CALL Wdt_Delay__0003E

		FCD_LCDDisplay0_RawSend(0x02, 0);
00B5  3002  	MOVLW 0x02
00B6  00D3  	MOVWF FCD_LCDDis_00056_arg_in
00B7  01D4  	CLRF FCD_LCDDis_00056_arg_mask
00B8  2031  	CALL FCD_LCDDis_00056

		Wdt_Delay_Ms(2);
00B9  3002  	MOVLW 0x02
00BA  00C5  	MOVWF Wdt_Delay__0003E_arg_delay
00BB  2021  	CALL Wdt_Delay__0003E


}
00BC  0008  	RETURN


void FCD_LCDDisplay0_PrintASCII(MX_UINT8 Character)
{
	
		FCD_LCDDisplay0_RawSend(Character, 0x10);

}

void FCD_LCDDisplay0_Command(MX_UINT8 in)
{
	
		FCD_LCDDisplay0_RawSend(in, 0);
		Wdt_Delay_Ms(2);

}

void FCD_LCDDisplay0_Cursor(MX_UINT8 x, MX_UINT8 y)

{
	
	  #if (LCD_1__ROWCNT == 1)
	    y=0x80;
	  #endif

	  #if (LCD_1__ROWCNT == 2)
		if (y==0)
			y=0x80;
		else
			y=0xc0;
	  #endif

	  #if (LCD_1__ROWCNT == 4)
		if (y==0)
008E  08C4  	MOVF FCD_LCDDis_0005B_arg_y, F
008F  1D03  	BTFSS STATUS,Z
0090  2894  	GOTO	label6
0094        label6

			y=0x80;
0091  3080  	MOVLW 0x80
0092  00C4  	MOVWF FCD_LCDDis_0005B_arg_y

		else if (y==1)
0093  28A3  	GOTO	label9
0094  0344  	DECF FCD_LCDDis_0005B_arg_y, W
0095  1D03  	BTFSS STATUS,Z
0096  289A  	GOTO	label7
009A        label7

			y=0xc0;
0097  30C0  	MOVLW 0xC0
0098  00C4  	MOVWF FCD_LCDDis_0005B_arg_y


		#if (LCD_1__COLCNT == 16)
			else if (y==2)
				y=0x90;
			else
				y=0xd0;
		#endif

		#if (LCD_1__COLCNT == 20)
			else if (y==2)
0099  28A3  	GOTO	label9
009A  0844  	MOVF FCD_LCDDis_0005B_arg_y, W
009B  3A02  	XORLW 0x02
009C  1D03  	BTFSS STATUS,Z
009D  28A1  	GOTO	label8
00A1        label8

				y=0x94;
009E  3094  	MOVLW 0x94
009F  00C4  	MOVWF FCD_LCDDis_0005B_arg_y

			else
00A0  28A3  	GOTO	label9
00A3        label9

				y=0xd4;
00A1  30D4  	MOVLW 0xD4
00A2  00C4  	MOVWF FCD_LCDDis_0005B_arg_y

		#endif
	  #endif

		FCD_LCDDisplay0_RawSend(y+x, 0);
00A3  0843  	MOVF FCD_LCDDis_0005B_arg_x, W
00A4  0744  	ADDWF FCD_LCDDis_0005B_arg_y, W
00A5  00D3  	MOVWF FCD_LCDDis_00056_arg_in
00A6  01D4  	CLRF FCD_LCDDis_00056_arg_mask
00A7  2031  	CALL FCD_LCDDis_00056

		Wdt_Delay_Ms(2);
00A8  3002  	MOVLW 0x02
00A9  00C5  	MOVWF Wdt_Delay__0003E_arg_delay
00AA  2021  	CALL Wdt_Delay__0003E


}
00AB  0008  	RETURN


void FCD_LCDDisplay0_PrintNumber(MX_SINT16 Number)
{
	
		MX_SINT16 tmp_int;
		MX_UINT8 tmp_byte;

		if (Number < 0)
		{
			FCD_LCDDisplay0_RawSend('-', 0x10);
			Number = 0 - Number;
		}

		tmp_int = Number;
		if (Number >= 10000)
		{
			tmp_byte = tmp_int / 10000;
			FCD_LCDDisplay0_RawSend('0' + tmp_byte, 0x10);

			while (tmp_byte > 0)
			{
				tmp_int = tmp_int - 10000;
				tmp_byte--;
			}
		}
		if (Number >= 1000)
		{
			tmp_byte = tmp_int / 1000;
			FCD_LCDDisplay0_RawSend('0' + tmp_byte, 0x10);

			while (tmp_byte > 0)
			{
				tmp_int = tmp_int - 1000;
				tmp_byte--;
			}
		}
		if (Number >= 100)
		{
			tmp_byte = tmp_int / 100;
			FCD_LCDDisplay0_RawSend('0' + tmp_byte, 0x10);

			while (tmp_byte > 0)
			{
				tmp_int = tmp_int - 100;
				tmp_byte--;
			}
		}
		if (Number >= 10)
		{
			tmp_byte = tmp_int / 10;
			FCD_LCDDisplay0_RawSend('0' + tmp_byte, 0x10);

			while (tmp_byte > 0)
			{
				tmp_int = tmp_int - 10;
				tmp_byte--;
			}
		}
		FCD_LCDDisplay0_RawSend('0' + tmp_int, 0x10);

}

void FCD_LCDDisplay0_PrintString(MX_STRING String, MX_UINT8 MSZ_String)

{
	
		MX_UINT8 idx = 0;
0072  01D2  	CLRF FCD_LCDDis_0005D_1_idx


		for (idx=0; idx<MSZ_String; idx++)
0073  01D2  	CLRF FCD_LCDDis_0005D_1_idx
0074        label5
0074  0851  	MOVF FCD_LCDDis_0005D_arg_MSZ_String, W
0075  0252  	SUBWF FCD_LCDDis_0005D_1_idx, W
0076  1803  	BTFSC STATUS,C
008C  0AD2  	INCF FCD_LCDDis_0005D_1_idx, F
008D  2874  	GOTO	label5

		{
			if (String[idx] == 0)
0078  1383  	BCF STATUS,IRP
0079  1844  	BTFSC FCD_LCDDis_0005D_arg_String+D'1',0
007A  1783  	BSF STATUS,IRP
007B  0843  	MOVF FCD_LCDDis_0005D_arg_String, W
007C  0752  	ADDWF FCD_LCDDis_0005D_1_idx, W
007D  0084  	MOVWF FSR
007E  0880  	MOVF INDF, F
007F  1903  	BTFSC STATUS,Z

			{
				break;

			}
			FCD_LCDDisplay0_RawSend(String[idx], 0x10);
0081  1383  	BCF STATUS,IRP
0082  1844  	BTFSC FCD_LCDDis_0005D_arg_String+D'1',0
0083  1783  	BSF STATUS,IRP
0084  0843  	MOVF FCD_LCDDis_0005D_arg_String, W
0085  0752  	ADDWF FCD_LCDDis_0005D_1_idx, W
0086  0084  	MOVWF FSR
0087  0800  	MOVF INDF, W
0088  00D3  	MOVWF FCD_LCDDis_00056_arg_in
0089  3010  	MOVLW 0x10
008A  00D4  	MOVWF FCD_LCDDis_00056_arg_mask
008B  2031  	CALL FCD_LCDDis_00056

		}

}
0077  0008  	RETURN
0080  0008  	RETURN


void FCD_LCDDisplay0_ScrollDisplay(MX_UINT8 Direction, MX_UINT8 Num_Positions)
{
	
		MX_UINT8 cmd = 0;
		MX_UINT8 count;

		//Choose the direction
		switch (Direction)
		{
			case 0:
			case 'l':
			case 'L':

				cmd = 0x18;
				break;

			case 1:
			case 'r':
			case 'R':

				cmd = 0x1C;
				break;

			default:
				break;
		}

		//If direction accepted then scroll the specified amount
		if (cmd)
		{
			for (count = 0; count < Num_Positions; count++)
				FCD_LCDDisplay0_Command(cmd);
		}

}

void FCD_LCDDisplay0_ClearLine(MX_UINT8 Line)
{
	
		MX_UINT8 count;
		MX_UINT8 rowcount;

		//Define number of columns per line
		#if (LCD_1__ROWCNT == 1)
			rowcount=80;
		#endif

		#if (LCD_1__ROWCNT == 2)
			rowcount=40;
		#endif

		#if (LCD_1__ROWCNT == 4)
			#if (LCD_1__COLCNT == 16)
				rowcount=16;
			#endif
			#if (LCD_1__COLCNT == 20)
				rowcount=20;
			#endif
		#endif

		//Start at beginning of the line
		FCD_LCDDisplay0_Cursor (0, Line);

		//Send out spaces to clear line
		for (count = 0; count < rowcount; count++)
			FCD_LCDDisplay0_RawSend(' ', 0x10);

		//Move back to the beginning of the line.
		FCD_LCDDisplay0_Cursor (0, Line);

}

void FCD_LCDDisplay0_RAM_Write(MX_UINT8 nIdx, MX_UINT8 d0, MX_UINT8 d1, MX_UINT8 d2, MX_UINT8 d3, MX_UINT8 d4, MX_UINT8 d5, MX_UINT8 d6, MX_UINT8 d7)
{
	   //set CGRAM address

	   FCD_LCDDisplay0_RawSend(64 + (nIdx << 3), 0);
	   delay_ms(2);

	   //write CGRAM data
	   FCD_LCDDisplay0_RawSend(d0, 0x10);
	   FCD_LCDDisplay0_RawSend(d1, 0x10);
	   FCD_LCDDisplay0_RawSend(d2, 0x10);
	   FCD_LCDDisplay0_RawSend(d3, 0x10);
	   FCD_LCDDisplay0_RawSend(d4, 0x10);
	   FCD_LCDDisplay0_RawSend(d5, 0x10);
	   FCD_LCDDisplay0_RawSend(d6, 0x10);
	   FCD_LCDDisplay0_RawSend(d7, 0x10);

	   //Clear the display
	   FCD_LCDDisplay0_RawSend(0x01, 0);
	   delay_ms(2);
	   FCD_LCDDisplay0_RawSend(0x02, 0);
	   delay_ms(2);

}



//I2C_Master(0): //Macro implementations


void FCD_I2C_Master0_MI2C_Init()

{
	
		I2CMASTER_2_I2C_Master_Init();
0112  202C  	CALL FC_CAL_I2C_00062


}
0113  0008  	RETURN


void FCD_I2C_Master0_MI2C_Start()
{
	
		I2CMASTER_2_I2C_Master_Start();

}

void FCD_I2C_Master0_MI2C_Restart()
{
	
		I2CMASTER_2_I2C_Master_Restart();

}

void FCD_I2C_Master0_MI2C_Stop()
{
	
		I2CMASTER_2_I2C_Master_Stop();

}

MX_UINT8 FCD_I2C_Master0_MI2C_Transmit_Byte(MX_UINT8 Data)
{
	
		return I2CMASTER_2_I2C_Master_TX_Byte(Data);

}

MX_UINT8 FCD_I2C_Master0_MI2C_Receive_Byte(MX_UINT8 Last)
{
	
		return I2CMASTER_2_I2C_Master_RX_Byte(Last);

}

void FCD_I2C_Master0_MI2C_Send_Byte_Transaction(MX_UINT8 Device_ID, MX_UINT8 AddrH, MX_UINT8 AddrL, MX_UINT8 Data)
{
	
		Device_ID = Device_ID << 1;					//Shift Device ID to enable write mode

		I2CMASTER_2_I2C_Master_Start();						//Start transaction
		I2CMASTER_2_I2C_Master_TX_Byte(Device_ID);			//Transmit Device Address
		I2CMASTER_2_I2C_Master_TX_Byte(AddrH);				//Transmit Internal Address
		I2CMASTER_2_I2C_Master_TX_Byte(AddrL);
		I2CMASTER_2_I2C_Master_TX_Byte(Data);				//Send Data byte
		I2CMASTER_2_I2C_Master_Stop();						//Stop Transaction

}

MX_UINT8 FCD_I2C_Master0_MI2C_Receive_Byte_Transaction(MX_UINT8 Device_ID, MX_UINT8 AddrH, MX_UINT8 AddrL)
{
	
		MX_UINT8 RetVal = 0;
		Device_ID = Device_ID << 1;					//Shift Device ID to enable write mode

		I2CMASTER_2_I2C_Master_Start();						//Start transaction
		I2CMASTER_2_I2C_Master_TX_Byte(Device_ID);			//Transmit Device Address
		I2CMASTER_2_I2C_Master_TX_Byte(AddrH);				//Transmit Internal Address
		I2CMASTER_2_I2C_Master_TX_Byte(AddrL);
		I2CMASTER_2_I2C_Master_Restart();					//Restart transaction

		Device_ID = Device_ID | 0x01;				//Change Device ID to read mode
		I2CMASTER_2_I2C_Master_TX_Byte(Device_ID);			//Transmit Device Address
		RetVal = I2CMASTER_2_I2C_Master_RX_Byte(1);			//Read data at address
		I2CMASTER_2_I2C_Master_Stop();						//Stop Transaction

		return RetVal;								//Return data

}

#include "C:\Program Files (x86)\Flowcode\v5\CAL\includes.c"

//Macro implementations


void FCM_IIC_START()
{

	//I2C_DAT
	//Output: 1 -> C4
	trisc = trisc & 0xEF;
	if ((1))
		portc = (portc & 0xEF) | 0x10;
	else
		portc = portc & 0xEF;

	//CLK
	//Output: 1 -> C3
	trisc = trisc & 0xF7;
	if ((1))
		portc = (portc & 0xF7) | 0x08;
	else
		portc = portc & 0xF7;

	//Delay
	//Delay: 1 us
	delay_us(1);

	//I2C_DAT
	//Output: 0 -> C4
	trisc = trisc & 0xEF;
	if ((0))
		portc = (portc & 0xEF) | 0x10;
	else
		portc = portc & 0xEF;

	//CLK
	//Output: 0 -> C3
	trisc = trisc & 0xF7;
	if ((0))
		portc = (portc & 0xF7) | 0x08;
	else
		portc = portc & 0xF7;

}


void FCM_IIC_STOP()
{

	//I2C_DAT
	//Output: 0 -> C4
	trisc = trisc & 0xEF;
	if ((0))
		portc = (portc & 0xEF) | 0x10;
	else
		portc = portc & 0xEF;

	//CLK
	//Output: 0 -> C3
	trisc = trisc & 0xF7;
	if ((0))
		portc = (portc & 0xF7) | 0x08;
	else
		portc = portc & 0xF7;

	//Delay
	//Delay: 1 us
	delay_us(1);

	//CLK
	//Output: 1 -> C3
	trisc = trisc & 0xF7;
	if ((1))
		portc = (portc & 0xF7) | 0x08;
	else
		portc = portc & 0xF7;

	//I2C_DAT
	//Output: 1 -> C4
	trisc = trisc & 0xEF;
	if ((1))
		portc = (portc & 0xEF) | 0x10;
	else
		portc = portc & 0xEF;

}


void FCM_IIC_CLKP()
{

	//CLK
	//Output: 1 -> C3
	trisc = trisc & 0xF7;
	if ((1))
		portc = (portc & 0xF7) | 0x08;
	else
		portc = portc & 0xF7;

	//CLK
	//Output: 0 -> C3
	trisc = trisc & 0xF7;
	if ((0))
		portc = (portc & 0xF7) | 0x08;
	else
		portc = portc & 0xF7;

}


void FCM_IIC_WRITEID_W()
{

	//Call Macro
	//Call Macro: IIC_START()
	FCM_IIC_START();

	//I2C_DAT
	//Output: 1 -> C4
	trisc = trisc & 0xEF;
	if ((1))
		portc = (portc & 0xEF) | 0x10;
	else
		portc = portc & 0xEF;

	//Call Macro
	//Call Macro: IIC_CLKP()
	FCM_IIC_CLKP();

	//I2C_DAT
	//Output: 1 -> C4
	trisc = trisc & 0xEF;
	if ((1))
		portc = (portc & 0xEF) | 0x10;
	else
		portc = portc & 0xEF;

	//Call Macro
	//Call Macro: IIC_CLKP()
	FCM_IIC_CLKP();

	//I2C_DAT
	//Output: 0 -> C4
	trisc = trisc & 0xEF;
	if ((0))
		portc = (portc & 0xEF) | 0x10;
	else
		portc = portc & 0xEF;

	//Call Macro
	//Call Macro: IIC_CLKP()
	FCM_IIC_CLKP();

	//I2C_DAT
	//Output: 1 -> C4
	trisc = trisc & 0xEF;
	if ((1))
		portc = (portc & 0xEF) | 0x10;
	else
		portc = portc & 0xEF;

	//Call Macro
	//Call Macro: IIC_CLKP()
	FCM_IIC_CLKP();

	//I2C_DAT
	//Output: 0 -> C4
	trisc = trisc & 0xEF;
	if ((0))
		portc = (portc & 0xEF) | 0x10;
	else
		portc = portc & 0xEF;

	//Call Macro
	//Call Macro: IIC_CLKP()
	FCM_IIC_CLKP();

	//I2C_DAT
	//Output: 0 -> C4
	trisc = trisc & 0xEF;
	if ((0))
		portc = (portc & 0xEF) | 0x10;
	else
		portc = portc & 0xEF;

	//Call Macro
	//Call Macro: IIC_CLKP()
	FCM_IIC_CLKP();

	//I2C_DAT
	//Output: 0 -> C4
	trisc = trisc & 0xEF;
	if ((0))
		portc = (portc & 0xEF) | 0x10;
	else
		portc = portc & 0xEF;

	//Call Macro
	//Call Macro: IIC_CLKP()
	FCM_IIC_CLKP();

	//I2C_DAT
	//Output: 0 -> C4
	trisc = trisc & 0xEF;
	if ((0))
		portc = (portc & 0xEF) | 0x10;
	else
		portc = portc & 0xEF;

	//Call Macro
	//Call Macro: IIC_CLKP()
	FCM_IIC_CLKP();

	//Call Macro
	//Call Macro: IIC_SACK()
	FCM_IIC_SACK();

	//Call Macro
	//Call Macro: IIC_STOP()
	FCM_IIC_STOP();

}


void FCM_IIC_SACK()
{

	//Connection Point
	//Connection Point: [A]: A
FCC_IIC_SACK_A:
;

	//DATA
	//Input: C4 -> ack
	trisc = trisc | 0x10;
	FCV_ACK = ((portc & 0x10) == 0x10);

	//Decision
	//Decision: ack = 1?
	if (FCV_ACK == 1)
	{

		//Goto Connection Point
		//Goto Connection Point: [A]: A
		goto FCC_IIC_SACK_A;

	// } else {

	}

	//Call Macro
	//Call Macro: IIC_CLKP()
	FCM_IIC_CLKP();

}



void main()

{
	//Initialization
	adcon1 = 0x07;
0114  3007  	MOVLW 0x07
0115  1683  	BSF STATUS, RP0
0116  1303  	BCF STATUS, RP1
0117  009F  	MOVWF gbl_adcon1



	//Interrupt initialization code
	option_reg = 0xC0;
0118  30C0  	MOVLW 0xC0
0119  0081  	MOVWF gbl_option_reg



	//Call Component Macro
	//Call Component Macro: MI2C_Init()
	FCD_I2C_Master0_MI2C_Init();
011A  2112  	CALL FCD_I2C_Ma_00069


	//Call Component Macro
	//Call Component Macro: Start()
	FCD_LCDDisplay0_Start();
011B  20BD  	CALL FCD_LCDDis_00057


	//Call Component Macro
	//Call Component Macro: Clear()
	FCD_LCDDisplay0_Clear();
011C  20AC  	CALL FCD_LCDDis_00058


	//Loop
	//Loop: While 1
	while (1)
011D        label10
013B  291D  	GOTO	label10

	{

		//Call Component Macro
		//Call Component Macro: Cursor(0, 0)
		FCD_LCDDisplay0_Cursor(0, 0);
011D  01C3  	CLRF FCD_LCDDis_0005B_arg_x
011E  01C4  	CLRF FCD_LCDDis_0005B_arg_y
011F  208E  	CALL FCD_LCDDis_0005B


		//Call Component Macro
		//Call Component Macro: PrintString("hello world")
		FCD_LCDDisplay0_PrintString("hello world", 11);
0120  3020  	MOVLW 0x20
0121  00CA  	MOVWF CompTempVar2237+D'5'
0122  3064  	MOVLW 0x64
0123  00CF  	MOVWF CompTempVar2237+D'10'
0124  3065  	MOVLW 0x65
0125  00C6  	MOVWF CompTempVar2237+D'1'
0126  3068  	MOVLW 0x68
0127  00C5  	MOVWF CompTempVar2237
0128  306C  	MOVLW 0x6C
0129  00C7  	MOVWF CompTempVar2237+D'2'
012A  00C8  	MOVWF CompTempVar2237+D'3'
012B  00CE  	MOVWF CompTempVar2237+D'9'
012C  306F  	MOVLW 0x6F
012D  00C9  	MOVWF CompTempVar2237+D'4'
012E  00CC  	MOVWF CompTempVar2237+D'7'
012F  3072  	MOVLW 0x72
0130  00CD  	MOVWF CompTempVar2237+D'8'
0131  3077  	MOVLW 0x77
0132  00CB  	MOVWF CompTempVar2237+D'6'
0133  01D0  	CLRF CompTempVar2237+D'11'
0134  3000  	MOVLW HIGH(CompTempVar2237+D'0')
0135  00C4  	MOVWF FCD_LCDDis_0005D_arg_String+D'1'
0136  3045  	MOVLW LOW(CompTempVar2237+D'0')
0137  00C3  	MOVWF FCD_LCDDis_0005D_arg_String
0138  300B  	MOVLW 0x0B
0139  00D1  	MOVWF FCD_LCDDis_0005D_arg_MSZ_String
013A  2072  	CALL FCD_LCDDis_0005D



	}

	mainendloop: goto mainendloop;
}


void MX_INTERRUPT_MACRO(void)

{
}
0166  1283  	BCF STATUS, RP0
0167  1303  	BCF STATUS, RP1
0168  0E36  	SWAPF Int1BContext+D'2', W
0169  0084  	MOVWF FSR
016A  0E35  	SWAPF Int1BContext+D'1', W
016B  008A  	MOVWF PCLATH
016C  0E34  	SWAPF Int1BContext, W
016D  0083  	MOVWF STATUS
016E  0EFF  	SWAPF Int1Context, F
016F  0E7F  	SWAPF Int1Context, W
0170  0009  	RETFIE





/*********************************************************************
 *                  Flowcode CAL I2C File
 *
 * File: PIC_CAL_I2C.c
 *
 * (c) 2011 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * “Company”) for its Flowcode graphical programming language is
 * intended and supplied to you, the Company’s customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 210911 | BR | Created
 * 021211 | BR | Converted to new dynamic defines mechanism
 *
 */


//When using hardware I2C channels override port and pin conns with FCD conn definitions
#ifdef MX_I2C_REF1
	#if MX_I2C_CHANNEL_1 > 0
		#undef MX_I2C_SDA_PIN_1
		#undef MX_I2C_SDA_PORT_1
		#undef MX_I2C_SDA_TRIS_1
		#undef MX_I2C_SCL_PIN_1
		#undef MX_I2C_SCL_PORT_1
		#undef MX_I2C_SCL_TRIS_1
	#endif
	#if MX_I2C_CHANNEL_1 == 1
		#define MX_I2C_SDA_PIN_1		MX_I2C_1_SDA_PIN
		#define MX_I2C_SDA_PORT_1		MX_I2C_1_SDA_PORT
		#define MX_I2C_SDA_TRIS_1		MX_I2C_1_SDA_TRIS
		#define MX_I2C_SCL_PIN_1		MX_I2C_1_SCL_PIN
		#define MX_I2C_SCL_PORT_1		MX_I2C_1_SCL_PORT
		#define MX_I2C_SCL_TRIS_1		MX_I2C_1_SCL_TRIS
	#endif
	#if MX_I2C_CHANNEL_1 == 2
		#define MX_I2C_SDA_PIN_1		MX_I2C_2_SDA_PIN
		#define MX_I2C_SDA_PORT_1		MX_I2C_2_SDA_PORT
		#define MX_I2C_SDA_TRIS_1		MX_I2C_2_SDA_TRIS
		#define MX_I2C_SCL_PIN_1		MX_I2C_2_SCL_PIN
		#define MX_I2C_SCL_PORT_1		MX_I2C_2_SCL_PORT
		#define MX_I2C_SCL_TRIS_1		MX_I2C_2_SCL_TRIS
	#endif
	#if MX_I2C_CHANNEL_1 == 3
		#define MX_I2C_SDA_PIN_1		MX_I2C_3_SDA_PIN
		#define MX_I2C_SDA_PORT_1		MX_I2C_3_SDA_PORT
		#define MX_I2C_SDA_TRIS_1		MX_I2C_3_SDA_TRIS
		#define MX_I2C_SCL_PIN_1		MX_I2C_3_SCL_PIN
		#define MX_I2C_SCL_PORT_1		MX_I2C_3_SCL_PORT
		#define MX_I2C_SCL_TRIS_1		MX_I2C_3_SCL_TRIS
	#endif
	#if MX_I2C_CHANNEL_1 == 4
		#define MX_I2C_SDA_PIN_1		MX_I2C_4_SDA_PIN
		#define MX_I2C_SDA_PORT_1		MX_I2C_4_SDA_PORT
		#define MX_I2C_SDA_TRIS_1		MX_I2C_4_SDA_TRIS
		#define MX_I2C_SCL_PIN_1		MX_I2C_4_SCL_PIN
		#define MX_I2C_SCL_PORT_1		MX_I2C_4_SCL_PORT
		#define MX_I2C_SCL_TRIS_1		MX_I2C_4_SCL_TRIS
	#endif
#endif
#ifdef MX_I2C_REF2
	#if MX_I2C_CHANNEL_2 > 0
		#undef MX_I2C_SDA_PIN_2
		#undef MX_I2C_SDA_PORT_2
		#undef MX_I2C_SDA_TRIS_2
		#undef MX_I2C_SCL_PIN_2
		#undef MX_I2C_SCL_PORT_2
		#undef MX_I2C_SCL_TRIS_2
	#endif
	#if MX_I2C_CHANNEL_2 == 1
		#define MX_I2C_SDA_PIN_2		MX_I2C_1_SDA_PIN
		#define MX_I2C_SDA_PORT_2		MX_I2C_1_SDA_PORT
		#define MX_I2C_SDA_TRIS_2		MX_I2C_1_SDA_TRIS
		#define MX_I2C_SCL_PIN_2		MX_I2C_1_SCL_PIN
		#define MX_I2C_SCL_PORT_2		MX_I2C_1_SCL_PORT
		#define MX_I2C_SCL_TRIS_2		MX_I2C_1_SCL_TRIS
	#endif
	#if MX_I2C_CHANNEL_2 == 2
		#define MX_I2C_SDA_PIN_2		MX_I2C_2_SDA_PIN
		#define MX_I2C_SDA_PORT_2		MX_I2C_2_SDA_PORT
		#define MX_I2C_SDA_TRIS_2		MX_I2C_2_SDA_TRIS
		#define MX_I2C_SCL_PIN_2		MX_I2C_2_SCL_PIN
		#define MX_I2C_SCL_PORT_2		MX_I2C_2_SCL_PORT
		#define MX_I2C_SCL_TRIS_2		MX_I2C_2_SCL_TRIS
	#endif
	#if MX_I2C_CHANNEL_2 == 3
		#define MX_I2C_SDA_PIN_2		MX_I2C_3_SDA_PIN
		#define MX_I2C_SDA_PORT_2		MX_I2C_3_SDA_PORT
		#define MX_I2C_SDA_TRIS_2		MX_I2C_3_SDA_TRIS
		#define MX_I2C_SCL_PIN_2		MX_I2C_3_SCL_PIN
		#define MX_I2C_SCL_PORT_2		MX_I2C_3_SCL_PORT
		#define MX_I2C_SCL_TRIS_2		MX_I2C_3_SCL_TRIS
	#endif
	#if MX_I2C_CHANNEL_2 == 4
		#define MX_I2C_SDA_PIN_2		MX_I2C_4_SDA_PIN
		#define MX_I2C_SDA_PORT_2		MX_I2C_4_SDA_PORT
		#define MX_I2C_SDA_TRIS_2		MX_I2C_4_SDA_TRIS
		#define MX_I2C_SCL_PIN_2		MX_I2C_4_SCL_PIN
		#define MX_I2C_SCL_PORT_2		MX_I2C_4_SCL_PORT
		#define MX_I2C_SCL_TRIS_2		MX_I2C_4_SCL_TRIS
	#endif
#endif
#ifdef MX_I2C_REF3
	#if MX_I2C_CHANNEL_3 > 0
		#undef MX_I2C_SDA_PIN_3
		#undef MX_I2C_SDA_PORT_3
		#undef MX_I2C_SDA_TRIS_3
		#undef MX_I2C_SCL_PIN_3
		#undef MX_I2C_SCL_PORT_3
		#undef MX_I2C_SCL_TRIS_3
	#endif
	#if MX_I2C_CHANNEL_3 == 1
		#define MX_I2C_SDA_PIN_3		MX_I2C_1_SDA_PIN
		#define MX_I2C_SDA_PORT_3		MX_I2C_1_SDA_PORT
		#define MX_I2C_SDA_TRIS_3		MX_I2C_1_SDA_TRIS
		#define MX_I2C_SCL_PIN_3		MX_I2C_1_SCL_PIN
		#define MX_I2C_SCL_PORT_3		MX_I2C_1_SCL_PORT
		#define MX_I2C_SCL_TRIS_3		MX_I2C_1_SCL_TRIS
	#endif
	#if MX_I2C_CHANNEL_3 == 2
		#define MX_I2C_SDA_PIN_3		MX_I2C_2_SDA_PIN
		#define MX_I2C_SDA_PORT_3		MX_I2C_2_SDA_PORT
		#define MX_I2C_SDA_TRIS_3		MX_I2C_2_SDA_TRIS
		#define MX_I2C_SCL_PIN_3		MX_I2C_2_SCL_PIN
		#define MX_I2C_SCL_PORT_3		MX_I2C_2_SCL_PORT
		#define MX_I2C_SCL_TRIS_3		MX_I2C_2_SCL_TRIS
	#endif
	#if MX_I2C_CHANNEL_3 == 3
		#define MX_I2C_SDA_PIN_3		MX_I2C_3_SDA_PIN
		#define MX_I2C_SDA_PORT_3		MX_I2C_3_SDA_PORT
		#define MX_I2C_SDA_TRIS_3		MX_I2C_3_SDA_TRIS
		#define MX_I2C_SCL_PIN_3		MX_I2C_3_SCL_PIN
		#define MX_I2C_SCL_PORT_3		MX_I2C_3_SCL_PORT
		#define MX_I2C_SCL_TRIS_3		MX_I2C_3_SCL_TRIS
	#endif
	#if MX_I2C_CHANNEL_3 == 4
		#define MX_I2C_SDA_PIN_3		MX_I2C_4_SDA_PIN
		#define MX_I2C_SDA_PORT_3		MX_I2C_4_SDA_PORT
		#define MX_I2C_SDA_TRIS_3		MX_I2C_4_SDA_TRIS
		#define MX_I2C_SCL_PIN_3		MX_I2C_4_SCL_PIN
		#define MX_I2C_SCL_PORT_3		MX_I2C_4_SCL_PORT
		#define MX_I2C_SCL_TRIS_3		MX_I2C_4_SCL_TRIS
	#endif
#endif
#ifdef MX_I2C_REF4
	#if MX_I2C_CHANNEL_4 > 0
		#undef MX_I2C_SDA_PIN_4
		#undef MX_I2C_SDA_PORT_4
		#undef MX_I2C_SDA_TRIS_4
		#undef MX_I2C_SCL_PIN_4
		#undef MX_I2C_SCL_PORT_4
		#undef MX_I2C_SCL_TRIS_4
	#endif
	#if MX_I2C_CHANNEL_4 == 1
		#define MX_I2C_SDA_PIN_4		MX_I2C_1_SDA_PIN
		#define MX_I2C_SDA_PORT_4		MX_I2C_1_SDA_PORT
		#define MX_I2C_SDA_TRIS_4		MX_I2C_1_SDA_TRIS
		#define MX_I2C_SCL_PIN_4		MX_I2C_1_SCL_PIN
		#define MX_I2C_SCL_PORT_4		MX_I2C_1_SCL_PORT
		#define MX_I2C_SCL_TRIS_4		MX_I2C_1_SCL_TRIS
	#endif
	#if MX_I2C_CHANNEL_4 == 2
		#define MX_I2C_SDA_PIN_4		MX_I2C_2_SDA_PIN
		#define MX_I2C_SDA_PORT_4		MX_I2C_2_SDA_PORT
		#define MX_I2C_SDA_TRIS_4		MX_I2C_2_SDA_TRIS
		#define MX_I2C_SCL_PIN_4		MX_I2C_2_SCL_PIN
		#define MX_I2C_SCL_PORT_4		MX_I2C_2_SCL_PORT
		#define MX_I2C_SCL_TRIS_4		MX_I2C_2_SCL_TRIS
	#endif
	#if MX_I2C_CHANNEL_4 == 3
		#define MX_I2C_SDA_PIN_4		MX_I2C_3_SDA_PIN
		#define MX_I2C_SDA_PORT_4		MX_I2C_3_SDA_PORT
		#define MX_I2C_SDA_TRIS_4		MX_I2C_3_SDA_TRIS
		#define MX_I2C_SCL_PIN_4		MX_I2C_3_SCL_PIN
		#define MX_I2C_SCL_PORT_4		MX_I2C_3_SCL_PORT
		#define MX_I2C_SCL_TRIS_4		MX_I2C_3_SCL_TRIS
	#endif
	#if MX_I2C_CHANNEL_4 == 4
		#define MX_I2C_SDA_PIN_4		MX_I2C_4_SDA_PIN
		#define MX_I2C_SDA_PORT_4		MX_I2C_4_SDA_PORT
		#define MX_I2C_SDA_TRIS_4		MX_I2C_4_SDA_TRIS
		#define MX_I2C_SCL_PIN_4		MX_I2C_4_SCL_PIN
		#define MX_I2C_SCL_PORT_4		MX_I2C_4_SCL_PORT
		#define MX_I2C_SCL_TRIS_4		MX_I2C_4_SCL_TRIS
	#endif
#endif

#define MX_I2C_CHANNEL_X		CAL_APPEND(MX_I2C_CHANNEL_, MX_I2C_NUM)
#define MX_I2C_SDA_PIN_X		CAL_APPEND(MX_I2C_SDA_PIN_, MX_I2C_NUM)
#define MX_I2C_SDA_PORT_X		CAL_APPEND(MX_I2C_SDA_PORT_, MX_I2C_NUM)
#define MX_I2C_SDA_TRIS_X		CAL_APPEND(MX_I2C_SDA_TRIS_, MX_I2C_NUM)
#define MX_I2C_SCL_PIN_X		CAL_APPEND(MX_I2C_SCL_PIN_, MX_I2C_NUM)
#define MX_I2C_SCL_PORT_X		CAL_APPEND(MX_I2C_SCL_PORT_, MX_I2C_NUM)
#define MX_I2C_SCL_TRIS_X		CAL_APPEND(MX_I2C_SCL_TRIS_, MX_I2C_NUM)
#define MX_I2C_BMODE_X			CAL_APPEND(MX_I2C_BMODE_, MX_I2C_NUM)
#define MX_I2C_BAUD_X			CAL_APPEND(MX_I2C_BAUD_, MX_I2C_NUM)
#define MX_I2C_INT_X			CAL_APPEND(MX_I2C_INT_, MX_I2C_NUM)


//Function Prototypes
CALFUNCTION(void, FC_CAL_I2C_Master_Init_, (void));
CALFUNCTION(void, FC_CAL_I2C_Master_Uninit_, (void));
CALFUNCTION(void, FC_CAL_I2C_Master_Start_, (void));
CALFUNCTION(void, FC_CAL_I2C_Master_Restart_, (void));
CALFUNCTION(void, FC_CAL_I2C_Master_Stop_, (void));
CALFUNCTION(MX_UINT8, FC_CAL_I2C_Master_TX_Byte_, (MX_UINT8 Data));
CALFUNCTION(MX_UINT8, FC_CAL_I2C_Master_RX_Byte_, (MX_UINT8 Last));

CALFUNCTION(void, FC_CAL_I2C_Slave_Init_, (void));
CALFUNCTION(void, FC_CAL_I2C_Slave_Uninit_, (void));
CALFUNCTION(void, FC_CAL_I2C_Slave_SetTxData_, (MX_UINT8 Data));
CALFUNCTION(MX_UINT8, FC_CAL_I2C_Slave_GetRxData_, (MX_UINT8 Last));


//Ensure SSPCON register is defined correctly
#ifndef SSPCON
  #ifdef SSPCON1
	#define sspcon	sspcon1
  #else
	#ifdef SSP1CON1
		#define sspcon	ssp1con1
	#endif
  #endif
#endif

//Ensure SSPIF register is defined correctly
#ifndef SSPIF
  #ifdef SSP1IF
	#define SSPIF	SSP1IF
  #else
	#error "I2C does not have the SSPIF defined on this chip - does your chip support this feature?"
  #endif
#endif


//Ensure SSPCON2 register is defined correctly
#ifndef SSPCON2
  #ifdef SSP1CON2
	#define sspcon2	ssp1con2
  #endif
#endif


//Ensure SSPSTAT register is defined correctly
#ifndef SSPSTAT
  #ifdef SSP1STAT
	#define sspstat	ssp1stat
  #endif
#endif


//Ensure SSPADD register is defined correctly
#ifndef SSPADD
  #ifdef SSP1ADD
	#define sspadd	ssp1add
  #endif
#endif


//Ensure SSPBUFF register is defined correctly
#ifndef SSPBUFF
  #ifdef SSP1BUFF
	#define sspbuff	ssp1buff
  #endif
#endif


//If software channel is enabled then define bit delay.
#if (MX_I2C_CHANNEL_X == 0)
  #ifndef MX_I2C_SW_DEL
	#define MX_I2C_SW_DEL
	#define MX_I2C_DELAY	delay_us(20);
  #endif
#endif


CALFUNCTION(void, FC_CAL_I2C_Master_Init_, (void))

{

	#if (MX_I2C_CHANNEL_X == 0)															//Use Master I2C Software
		FC_CAL_Bit_In_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);		//Configure SDA as Input
002C  1683  	BSF STATUS, RP0
002D  1303  	BCF STATUS, RP1
002E  1607  	BSF gbl_trisc,4

		FC_CAL_Bit_In_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);		//Configure SCL as Input
002F  1587  	BSF gbl_trisc,3

	#endif

	#if (MX_I2C_CHANNEL_X == 1)												//Use Master I2C Hardware 1
		#ifndef MX_MI2C
			#error "This chip does not have Master I2C capability"
		#else

			#ifndef MX_I2C_1
				#error "This chip does not have Master I2C channel 1"
			#endif

			#if (MX_I2C_BMODE_X & 0x01)
				cr_bit (sspstat,SMP);										//Slew Rate Control Enabled
			#else
				st_bit (sspstat,SMP);										//Slew Rate Control Disabled
		    #endif

			#if (MX_I2C_BMODE_X & 0x02)
				st_bit (sspstat,CKE);										//Enable SMBus specific inputs
			#else
				cr_bit (sspstat,CKE);										//Disable SMBus specific inputs
			#endif

			sspcon = 0x28;													//Setup I2C into Master Mode
			sspadd = MX_I2C_BAUD_X;											//Set the Baud Rate
			sspcon2 = 0x00;													//Clear the control bits
			st_bit(intcon, GIE);
			FC_CAL_Bit_In_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);		//Configure SDA as Input
			FC_CAL_Bit_In_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);		//Configure SCL as Input
		#endif
	#endif

	#if (MX_I2C_CHANNEL_X == 2)												//Use Master I2C Hardware 2
		#ifndef MX_MI2C
			#error "This chip does not have Master I2C capability"
		#else

			#ifndef MX_I2C_2
				#error "This chip does not have Master I2C channel 2"
			#endif

		  #ifdef MX_I2C_2_REMAPPABLE
			RPOR4 = 9;														//SDA2 - RB1 - RP4
			RPOR5 = 10;														//SCL2 - RB2 - RP5
		  #endif

			#if (MX_I2C_BMODE_X & 0x01)
				cr_bit (ssp2stat,SMP);										//Slew Rate Control Enabled
			#else
				st_bit (ssp2stat,SMP);										//Slew Rate Control Disabled
			#endif

			#if (MX_I2C_BMODE_X & 0x02)
				st_bit (ssp2stat,CKE);										//Enable SMBus specific inputs
			#else
				cr_bit (ssp2stat,CKE);										//Disable SMBus specific inputs
			#endif

			ssp2con = 0x28;													//Setup I2C into Master Mode
			ssp2add = MX_I2C_BAUD_X;										//Set the Baud Rate
			ssp2con2 = 0x00;												//Clear the control bits
			st_bit(intcon, GIE);
			FC_CAL_Bit_In_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);			//Configure SDA as Input
			FC_CAL_Bit_In_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);			//Configure SCL as Input
		#endif
	#endif
}
0030  0008  	RETURN


CALFUNCTION(void, FC_CAL_I2C_Master_Uninit_, (void))
{
	#if (MX_I2C_CHANNEL_X == 0)																//Use Master I2C Software
		FC_CAL_Bit_In_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);			//Configure SDA as Input
		FC_CAL_Bit_In_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);			//Configure SCL as Input
	#endif

	#if (MX_I2C_CHANNEL_X == 1)												//Use Master I2C Hardware 1
		cr_bit(sspcon, SSPEN);												//Disable SSP
	#endif

	#if (MX_I2C_CHANNEL_X == 2)												//Use Master I2C Hardware 2
		cr_bit(ssp2con, SSPEN);												//Disable SSP
	#endif
}

CALFUNCTION(void, FC_CAL_I2C_Master_Start_, (void))
{
	#if (MX_I2C_CHANNEL_X == 0)															//Use Master I2C Software
		FC_CAL_Bit_In_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);		//Make Sure SCL is Set
		FC_CAL_Bit_In_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);		//Make Sure SDA is Set
		MX_I2C_DELAY;																	//Small Delay
		FC_CAL_Bit_Low_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);		//Clear SDA
		MX_I2C_DELAY;																	//Small Delay
		FC_CAL_Bit_Low_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);		//Clear SCL
		MX_I2C_DELAY;																	//Small Delay
	#endif

	#if (MX_I2C_CHANNEL_X == 1)												//Use Master I2C Hardware 1
		cr_bit(pir1, SSPIF);												//Clear SSP interrupt flag
		st_bit(sspcon2,SEN);												//Initiate start condition
		while(ts_bit(sspcon2,SEN));											//Wait for start bit to be generated
	#endif

	#if (MX_I2C_CHANNEL_X == 2)												//Use Master I2C Hardware 2
		cr_bit(pir3, SSP2IF);												//Clear SSP interrupt flag
		st_bit(ssp2con2,SEN);												//Initiate start condition
		while(ts_bit(ssp2con2,SEN));										//Wait for start bit to be generated
	#endif
}

CALFUNCTION(void, FC_CAL_I2C_Master_Restart_, (void))
{
	#if (MX_I2C_CHANNEL_X == 0)															//Use Master I2C Software
		FC_CAL_Bit_In_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);		//Set SDA High
		MX_I2C_DELAY;
		FC_CAL_Bit_In_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);		//Set SCL High
		MX_I2C_DELAY;
		FC_CAL_Bit_Low_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);		//Set SDA Low
		MX_I2C_DELAY;
		FC_CAL_Bit_Low_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);		//Set SCL Low
		MX_I2C_DELAY;
	#endif

	#if (MX_I2C_CHANNEL_X == 1)												//Use Master I2C Hardware 1
		cr_bit(pir1, SSPIF);												//Clear SSP interrupt flag
		st_bit(sspcon2,RSEN);												//Initiate restart condition
		while(ts_bit(sspcon2,RSEN));										//Wait for restart bit to be generated
	#endif

	#if (MX_I2C_CHANNEL_X == 2)												//Use Master I2C Hardware 2
		cr_bit(pir3, SSP2IF);												//Clear SSP interrupt flag
		st_bit(ssp2con2,RSEN);												//Initiate restart condition
		while(ts_bit(ssp2con2,RSEN));										//Wait for restart bit to be generated
	#endif
}

CALFUNCTION(void, FC_CAL_I2C_Master_Stop_, (void))
{
	#if (MX_I2C_CHANNEL_X == 0)															//Use Master I2C Software
		FC_CAL_Bit_Low_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);		//Set SCL Low
		FC_CAL_Bit_Low_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);		//Set SDA Low
		MX_I2C_DELAY;
		FC_CAL_Bit_In_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);		//Set SCL High
		MX_I2C_DELAY;
		FC_CAL_Bit_In_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);		//Set SDA High
	#endif

	#if (MX_I2C_CHANNEL_X == 1)												//Use Master I2C Hardware 1
		cr_bit(pir1,SSPIF);													//Clear SSP interrupt flag
		st_bit(sspcon2,PEN);												//Initiate stop condition
		while(ts_bit(sspcon2,PEN));											//Wait for stop bit to be generated
	#endif

	#if (MX_I2C_CHANNEL_X == 2)												//Use Master I2C Hardware 2
		cr_bit(pir3,SSP2IF);												//Clear SSP interrupt flag
		st_bit(ssp2con2,PEN);												//Initiate stop condition
		while(ts_bit(ssp2con2,PEN));										//Wait for stop bit to be generated
	#endif

  delay_ms(10);																//Wait before reusing the I2C BUS
}

CALFUNCTION(MX_UINT8, FC_CAL_I2C_Master_TX_Byte_, (MX_UINT8 Data))
{
	#if (MX_I2C_CHANNEL_X == 0)												//Use Master I2C Software
		char bit_mask;
		char local_ack = 0;
		for(bit_mask=0x80;bit_mask;bit_mask=bit_mask>>1)
		{
			if(Data & bit_mask)
			{
				FC_CAL_Bit_In_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);	//Set SDA High
			}
			else
			{
				FC_CAL_Bit_Low_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);	//Set SDA Low
			}
			MX_I2C_DELAY;
			FC_CAL_Bit_In_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);		//Set SCL High
			MX_I2C_DELAY;
			FC_CAL_Bit_Low_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);		//Set SCL Low
			MX_I2C_DELAY;
		}
		FC_CAL_Bit_In_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);			//Set SDA High
		MX_I2C_DELAY;
		FC_CAL_Bit_In_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);			//Set SCL High
		MX_I2C_DELAY;
		FC_CAL_Bit_In_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);
		if (FC_CAL_Bit_In(MX_I2C_SDA_PORT_X, MX_I2C_SDA_PIN_X))		//Get the Status Bit
			local_ack = 1;
		MX_I2C_DELAY;
		FC_CAL_Bit_Low_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);			//Set SCL Low
		MX_I2C_DELAY;
		return (local_ack);													//0 = Ack received : 1 = Ack not received
	#endif

	#if (MX_I2C_CHANNEL_X == 1)												//Use Master I2C Hardware 1
		cr_bit(pir1,SSPIF);													//Clear SSP interrupt flag
		sspbuf=Data;														//Send byte
		while(ts_bit(pir1,SSPIF) == 0);										//Wait for control bit to be sent
		if(ts_bit(sspcon2,ACKSTAT))											//Check Acknowledgement
			return (1);														//No Acknowledgement
		else return (0);													//Acknowledgement received
	#endif

	#if (MX_I2C_CHANNEL_X == 2)												//Use Master I2C Hardware 2
		cr_bit(pir3,SSP2IF);												//Clear SSP interrupt flag
		ssp2buf=Data;														//Send byte
		while(ts_bit(pir3,SSP2IF) == 0);									//Wait for control bit to be sent
		if(ts_bit(ssp2con2,ACKSTAT))										//Check Acknowledgement
			return (1);														//No Acknowledgement
		else return (0);													//Acknowledgement received
	#endif
}

CALFUNCTION(MX_UINT8, FC_CAL_I2C_Master_RX_Byte_, (MX_UINT8 Last))
{
	#if (MX_I2C_CHANNEL_X == 0)												//Use Master I2C Software
		char bit_mask;
		char Data = 0;
		char local_ack;
		FC_CAL_Bit_In_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);			//Set SDA High
		MX_I2C_DELAY;
		for(bit_mask=0x80;bit_mask;bit_mask=bit_mask>>1)
		{
			FC_CAL_Bit_In_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);		//Set SCL High
			MX_I2C_DELAY;
			FC_CAL_Bit_In_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);
			if(FC_CAL_Bit_In(MX_I2C_SDA_PORT_X, MX_I2C_SDA_PIN_X))	//Read Incoming Bit
				Data = Data | bit_mask;														//Add data to variable
			FC_CAL_Bit_Low_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);		//Set SCL Low
			MX_I2C_DELAY;
		}
		if (Last)																		//Acknowledge?
		{
			FC_CAL_Bit_In_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);	//Send Nack
		}
		else
		{
			FC_CAL_Bit_Low_DDR(MX_I2C_SDA_PORT_X, MX_I2C_SDA_TRIS_X, MX_I2C_SDA_PIN_X);	//Send Ack
		}
		MX_I2C_DELAY;
		FC_CAL_Bit_In_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);		//Set SCL High
		MX_I2C_DELAY;
		FC_CAL_Bit_Low_DDR(MX_I2C_SCL_PORT_X, MX_I2C_SCL_TRIS_X, MX_I2C_SCL_PIN_X);		//Set SCL Low
		MX_I2C_DELAY;
		return (Data);
	#endif

	#if (MX_I2C_CHANNEL_X == 1)						//Use Master I2C Hardware 1
		cr_bit(pir1,SSPIF);							//Clear SSP interrupt flag
		st_bit(sspcon2,RCEN);						//Initiate Read
		while(ts_bit(pir1,3) == 0);					//Wait for data read
		if (Last)
			st_bit(sspcon2,ACKDT);					//Send Nack
		else cr_bit(sspcon2,ACKDT);					//Send Ack
		st_bit(sspcon2,ACKEN);						//Initiate Nack
		while(ts_bit(sspcon2,ACKEN));				//Wait for data read
		return(sspbuf);								//Store incoming data
	#endif

	#if (MX_I2C_CHANNEL_X == 2)						//Use Master I2C Hardware 2
		cr_bit(pir3,SSP2IF);						//Clear SSP interrupt flag
		st_bit(ssp2con2,RCEN);						//Initiate Read
		while(ts_bit(pir3,SSP2IF) == 0);			//Wait for data read
		if (Last)
			st_bit(ssp2con2,ACKDT);					//Send Nack
		else cr_bit(ssp2con2,ACKDT);				//Send Ack
		st_bit(ssp2con2,ACKEN);						//Initiate Nack
		while(ts_bit(ssp2con2,ACKEN));				//Wait for data read
		return(ssp2buf);							//Store incoming data
	#endif
}




//Slave functions currently not implemented
CALFUNCTION(void, FC_CAL_I2C_Slave_Init_, (void))
{

}

CALFUNCTION(void, FC_CAL_I2C_Slave_Uninit_, (void))
{

}

CALFUNCTION(void, FC_CAL_I2C_Slave_SetTxData_, (MX_UINT8 Data))
{

}

CALFUNCTION(MX_UINT8, FC_CAL_I2C_Slave_GetRxData_, (MX_UINT8 Last))
{

}


////////////////////////////////////////
// Code with no source :-)
////////////////////////////////////////
0000  293C  	GOTO	_startup

0004  00FF  	MOVWF Int1Context
0005  0E03  	SWAPF STATUS, W
0006  1283  	BCF STATUS, RP0
0007  1303  	BCF STATUS, RP1
0008  00B4  	MOVWF Int1BContext
0009  0E0A  	SWAPF PCLATH, W
000A  00B5  	MOVWF Int1BContext+D'1'
000B  0E04  	SWAPF FSR, W
000C  00B6  	MOVWF Int1BContext+D'2'
000D  118A  	BCF PCLATH,3
000E  120A  	BCF PCLATH,4
000F  2966  	GOTO	interrupt
0010        delay_ms_00000
0010        ; { delay_ms ; function begin
0010  08C7  	MOVF delay_ms_00000_arg_del, F
0011  1D03  	BTFSS STATUS,Z
0012  2814  	GOTO	label1
0013  0008  	RETURN
0014        label1
0014  307C  	MOVLW 0x7C
0015        label2
0015  3EFF  	ADDLW 0xFF
0016  1D03  	BTFSS STATUS,Z
0017  2815  	GOTO	label2
0018  0000  	NOP
0019  0BC7  	DECFSZ delay_ms_00000_arg_del, F
001A  2814  	GOTO	label1
001B  0008  	RETURN
001C        ; } delay_ms function end

001C        delay_10us_00000
001C        ; { delay_10us ; function begin
001C        label3
001C  0000  	NOP
001D  0000  	NOP
001E  0BD6  	DECFSZ delay_10us_00000_arg_del, F
001F  281C  	GOTO	label3
0020  0008  	RETURN
0021        ; } delay_10us function end


013C        _startup
013C  30D5  	MOVLW 0xD5
013D  1283  	BCF STATUS, RP0
013E  1303  	BCF STATUS, RP1
013F  00A0  	MOVWF gbl_14_LSR
0140  30C4  	MOVLW 0xC4
0141  00A1  	MOVWF gbl_14_LSR+D'1'
0142  30BB  	MOVLW 0xBB
0143  00A2  	MOVWF gbl_14_LSR+D'2'
0144  30DC  	MOVLW 0xDC
0145  00A3  	MOVWF gbl_14_LSR+D'3'
0146  01A4  	CLRF gbl_15_gbl_aSig
0147  01A5  	CLRF gbl_15_gbl_aSig+D'1'
0148  01A6  	CLRF gbl_15_gbl_aSig+D'2'
0149  01A7  	CLRF gbl_15_gbl_aSig+D'3'
014A  01A8  	CLRF gbl_15_gbl_bSig
014B  01A9  	CLRF gbl_15_gbl_bSig+D'1'
014C  01AA  	CLRF gbl_15_gbl_bSig+D'2'
014D  01AB  	CLRF gbl_15_gbl_bSig+D'3'
014E  01AC  	CLRF gbl_15_gbl_zSig
014F  01AD  	CLRF gbl_15_gbl_zSig+D'1'
0150  01AE  	CLRF gbl_15_gbl_zSig+D'2'
0151  01AF  	CLRF gbl_15_gbl_zSig+D'3'
0152  01BC  	CLRF gbl_15_gbl_aExp
0153  01BD  	CLRF gbl_15_gbl_bExp
0154  01B7  	CLRF gbl_15_gbl_zExp
0155  01B8  	CLRF gbl_15_gbl_zExp+D'1'
0156  01BE  	CLRF gbl_15_gbl_aSign
0157  01BF  	CLRF gbl_15_gbl_bSign
0158  01C0  	CLRF gbl_15_gbl_zSign
0159  01C1  	CLRF gbl_15_gbl_zSigZero
015A  01B0  	CLRF gbl_15_gbl_ret
015B  01B1  	CLRF gbl_15_gbl_ret+D'1'
015C  01B2  	CLRF gbl_15_gbl_ret+D'2'
015D  01B3  	CLRF gbl_15_gbl_ret+D'3'
015E  01BA  	CLRF gbl_float_rounding_mode
015F  01BB  	CLRF gbl_float_exception_flags
0160  01B9  	CLRF gbl_float_detect_tininess

0163  118A  	BCF PCLATH,3
0164  120A  	BCF PCLATH,4
0165  2914  	GOTO	main

2007  3F3A  	DW 0x3F3A
