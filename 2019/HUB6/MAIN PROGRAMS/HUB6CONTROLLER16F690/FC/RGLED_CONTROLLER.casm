;/////////////////////////////////////////////////////////////////////////////////
;// Code Generator: BoostC Compiler - http://www.sourceboost.com
;// Version       : 7.03
;// License Type  : Pro License
;// Limitations   : PIC12,PIC16 max code size:Unlimited, max RAM banks:Unlimited
;/////////////////////////////////////////////////////////////////////////////////

/*********************************************************************
 *                  Flowcode CAL Delays File
 *
 * File: PIC_CAL_Delay.c
 *
 * (c) 2011 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * “Company”) for its Flowcode graphical programming language is
 * intended and supplied to you, the Company’s customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 010911 | BR | Created
 *
 *
 *
 */

//Original Byte Delays
void Wdt_Delay_S(char delay);
void Wdt_Delay_Ms(char delay);

//New Int Delays
void FCI_DELAYINT_US(MX_UINT16 Delay);

void FCI_DELAYINT_MS(MX_UINT16 Delay);
void FCI_DELAYINTWDT_MS(MX_UINT16 Delay);

void FCI_DELAYINT_S(MX_UINT16 Delay);
void FCI_DELAYINTWDT_S(MX_UINT16 Delay);


#ifdef HI_TECH_C

	#define nop()	asm("NOP")

	void delay_10us(char del);
	void delay_us(char del);
	void delay_ms(char del);
	void delay_s(char del);

	void delay_10us(char del)
	{
		char count;
		for(count=0; count<10; count++)
		{
			delay_us(del);
		}
	}

	void delay_us(char del)
	{
		while (del > 1)
		{
			__delay_us(1);
			del = del - 1;
		}
	}

	void delay_ms(char del)
	{
		while (del > 1)
		{
			__delay_ms(1);
			del = del - 1;
		}
	}

	void delay_s(char del)
	{
		char i;
		for(i=0; i<del; i++)
		{
			delay_ms(250);
			delay_ms(250);
			delay_ms(250);
			delay_ms(250);
		}
	}

#endif

void Wdt_Delay_S(char delay)
{
    char i;
    short j;
    for (i=0; i<delay; i++)
    {
        for (j=0; j<999; j++)
        {
            Wdt_Delay_Ms(1);
        }
    }
}

void Wdt_Delay_Ms(char delay)

{
    char i;
    for (i=0; i<delay; i++)
00BA  01B6  	CLRF Wdt_Delay__0003E_1_i
00BB        label15
00BB  0835  	MOVF Wdt_Delay__0003E_arg_delay, W
00BC  0236  	SUBWF Wdt_Delay__0003E_1_i, W
00BD  1803  	BTFSC STATUS,C
00C3  0AB6  	INCF Wdt_Delay__0003E_1_i, F
00C4  28BB  	GOTO	label15

    {
        MX_CLEAR_WATCHDOG;        //Clear Watchdog Timer
00BF  0064  	CLRWDT

        delay_ms(1);
00C0  3001  	MOVLW 0x01
00C1  00B7  	MOVWF delay_ms_00000_arg_del
00C2  2010  	CALL delay_ms_00000

    }
}
00BE  0008  	RETURN



void FCI_DELAYINT_US(MX_UINT16 Delay)
{
  	while (Delay > 255)
  	{
	  	delay_us(255);
	  	Delay = Delay - 255;
  	}
  	if (Delay > 0)
  		delay_us(Delay & 0xFF);
}

void FCI_DELAYINT_MS(MX_UINT16 Delay)
{
  	while (Delay > 255)
  	{
	  	delay_ms(255);
	  	Delay = Delay - 255;
  	}
  	if (Delay > 0)
  		delay_ms(Delay & 0xFF);
}

void FCI_DELAYINTWDT_MS(MX_UINT16 Delay)
{
  	while (Delay > 255)
  	{
	  	Wdt_Delay_Ms(255);
	  	Delay = Delay - 255;
  	}
  	if (Delay > 0)
  		Wdt_Delay_Ms(Delay & 0xFF);
}

void FCI_DELAYINT_S(MX_UINT16 Delay)
{
  	while (Delay > 255)
  	{
	  	delay_s(255);
	  	Delay = Delay - 255;
  	}
  	if (Delay > 0)
  		delay_s(Delay & 0xFF);
}

void FCI_DELAYINTWDT_S(MX_UINT16 Delay)
{
  	while (Delay > 255)
  	{
	  	Wdt_Delay_S(255);
	  	Delay = Delay - 255;
  	}
  	if (Delay > 0)
  		Wdt_Delay_S(Delay & 0xFF);
}



//************************************************************************************
//**  
//**  File name:     C:\Users\gerpe\OneDrive\GER-PER 2016\Documents\KennyNeutron\HUB6\MAIN PROGRAMS\HUB6CONTROLLER16F690\FC\RGLED_CONTROLLER.c
//**  Title:         
//**  Description:   
//**  
//**  Generated by:  Flowcode v5.2.0.0
//**  Date:          Tuesday, December 03, 2019 19:01:15
//**  Licence:       Professional
//**  Registered to: xyz
//**  Licence key:   WUK7B9
//**  
//**  
//**  http://www.matrixmultimedia.com
//**  
//************************************************************************************


#define MX_PIC

#define MX_USES_UINT8 3
#define MX_USES_SINT16 0
#define MX_USES_CHAR 0
#define MX_USES_FLOAT 0
#define MX_USES_SINT32 0
#define MX_USES_BOOL 1
#define MX_USES_UINT16 0
#define MX_USES_UINT32 0
//Defines for microcontroller
#define P16F690
#define FC_CAL_PIC
#define MX_ADC
#define MX_ADC_TYPE_3
#define MX_ADC_BITS_10
#define MX_EE
#define MX_EE_TYPE2
#define MX_EE_SIZE 256
#define MX_SPI_1
#define MX_SPI_1_MISO_PORT portb
#define MX_SPI_1_MISO_TRIS trisb
#define MX_SPI_1_MISO_PIN 4
#define MX_SPI_1_MOSI_PORT portc
#define MX_SPI_1_MOSI_TRIS trisc
#define MX_SPI_1_MOSI_PIN 7
#define MX_SPI_1_CLK_PORT portb
#define MX_SPI_1_CLK_TRIS trisb
#define MX_SPI_1_CLK_PIN 6
#define MX_SPI_1_SS_PORT portb
#define MX_SPI_1_SS_TRIS trisb
#define MX_UART_1
#define MX_UART_1_TX_PORT portb
#define MX_UART_1_TX_TRIS trisb
#define MX_UART_1_TX_PIN 7
#define MX_UART_1_RX_PORT portb
#define MX_UART_1_RX_TRIS trisb
#define MX_UART_1_RX_PIN 5
#define MX_I2C
#define MX_MI2C
#define MX_I2C_1
#define MX_I2C_1_SDA_PORT portb
#define MX_I2C_1_SDA_TRIS trisb
#define MX_I2C_1_SDA_PIN 4
#define MX_I2C_1_SCL_PORT portb
#define MX_I2C_1_SCL_TRIS trisb
#define MX_I2C_1_SCL_PIN 6
#define MX_PWM
#define MX_PWM_CNT 1
#define MX_PWM_PSCA1
#define MX_PWM_PSCA4
#define MX_PWM_PSCA16
#define MX_PWM_1_PORT portc
#define MX_PWM_1_TRIS trisc
#define MX_PWM_1_PIN 5

//Functions
#define MX_CLK_SPEED 20000000
#ifdef _BOOSTC
#include <system.h>
#endif
#ifdef HI_TECH_C
#include <pic.h>
#endif

//Configuration data
#ifdef _BOOSTC
#pragma DATA 0x2007, 0x30d2
#endif
#ifdef HI_TECH_C
__CONFIG(0x30d2);
#endif

//Internal functions
#include "C:\Program Files (x86)\Flowcode\v5\FCD\internals.c"

//Macro function declarations
void FCM_sample_ins();
void FCM_clr_char();
void FCM_print_char_onlcd();
void FCM_keypad_con();
void FCM_clr_color();
void FCM_keypadtest();
void FCM_sendtocpu();


//Variable declarations
#define FCV_FALSE (0)
#define FCV_TRUE (1)
MX_UINT8 FCV_KEYPAD_READ = (0xff);
06D9  30FF  	MOVLW 0xFF
06DA  00A3  	MOVWF gbl_FCV_KEYPAD_READ

MX_UINT8 FCV_TX_CHAR;
MX_UINT8 FCV_CHAR[32];
MX_BOOL FCV_BUT_PLUS = (0);
06DB  1025  	BCF gbl_FCV_BUT_PLUS,0

MX_UINT8 FCV_NEXT_IDX = (0x0);
06DC  01A6  	CLRF gbl_FCV_NEXT_IDX

MX_BOOL FCV_BUT_MINUS = (1);
06DD  14A5  	BSF gbl_FCV_BUT_MINUS,1

MX_UINT8 FCV_CURSORX = (0x0);
06DE  01A7  	CLRF gbl_FCV_CURSORX

MX_UINT8 FCV_WRREG_TEMP;
MX_BOOL FCV_SCROLL = (0);
06DF  1125  	BCF gbl_FCV_SCROLL,2

MX_BOOL FCV_BUT_NEXT = (1);
06E0  15A5  	BSF gbl_FCV_BUT_NEXT,3

MX_UINT8 FCV_COLOR[32];

MX_UINT8 FCLV_LOOP1;
MX_UINT8 FCLV_LOOP2;
MX_UINT8 FCLV_LOOP3;
MX_UINT8 FCLV_LOOP4;
MX_UINT8 FCLV_LOOP5;



//RS232(0): //Defines:

/**** Macro Substitutions ****
a = Unique Reference
b = Uart Channel		(0-software / 1-4 hardware)
c = tx pin
d = tx port
e = rx pin
f = rx port
g = flow control		(0-Off / 1-On)
h = cts pin
i = cts port
j = rts pin
k = rts port
l = baud rate
m = data bits			(7/8/9) (7 only supported in software modes)
n = return type		(0-byte / 1-MX_UINT16)
o = echo enable		(0-Off / 1-On)
******************************/

//Definitions for RS232 UART slot allocation
#ifndef	MX_UART_REF1
	#define MX_UART_REF1
	#define RS232_1_MX_UART_UREF			1
	#define MX_UART_CHANNEL_1		1
	#define MX_UART_TX_PIN_1		0
	#define MX_UART_TX_PORT_1		porta
	#define MX_UART_TX_TRIS_1		trisa
	#define MX_UART_RX_PIN_1		0
	#define MX_UART_RX_PORT_1		porta
	#define MX_UART_RX_TRIS_1		trisa
	#define MX_UART_FLOWEN_1		0
	#define MX_UART_CTS_PIN_1		4
	#define MX_UART_CTS_PORT_1		porta
	#define MX_UART_CTS_TRIS_1		trisa
	#define MX_UART_RTS_PIN_1		0
	#define MX_UART_RTS_PORT_1		porta
	#define MX_UART_RTS_TRIS_1		trisa
	#define MX_UART_BAUD_1			9600
	#define MX_UART_DBITS_1			8
	#define MX_UART_RETURN_1		0
	#define MX_UART_ECHO_1			0
	#define MX_UART_INT_1			0
#else
 #ifndef	MX_UART_REF2
	#define MX_UART_REF2
	#define RS232_1_MX_UART_UREF			2
	#define MX_UART_CHANNEL_2		1
	#define MX_UART_TX_PIN_2		0
	#define MX_UART_TX_PORT_2		porta
	#define MX_UART_TX_TRIS_2		trisa
	#define MX_UART_RX_PIN_2		0
	#define MX_UART_RX_PORT_2		porta
	#define MX_UART_RX_TRIS_2		trisa
	#define MX_UART_FLOWEN_2		0
	#define MX_UART_CTS_PIN_2		4
	#define MX_UART_CTS_PORT_2		porta
	#define MX_UART_CTS_TRIS_2		trisa
	#define MX_UART_RTS_PIN_2		0
	#define MX_UART_RTS_PORT_2		porta
	#define MX_UART_RTS_TRIS_2		trisa
	#define MX_UART_BAUD_2			9600
	#define MX_UART_DBITS_2			8
	#define MX_UART_RETURN_2		0
	#define MX_UART_ECHO_2			0
	#define MX_UART_INT_2			0
 #else
  #ifndef	MX_UART_REF3
	#define MX_UART_REF3
	#define RS232_1_MX_UART_UREF			3
	#define MX_UART_CHANNEL_3		1
	#define MX_UART_TX_PIN_3		0
	#define MX_UART_TX_PORT_3		porta
	#define MX_UART_TX_TRIS_3		trisa
	#define MX_UART_RX_PIN_3		0
	#define MX_UART_RX_PORT_3		porta
	#define MX_UART_RX_TRIS_3		trisa
	#define MX_UART_FLOWEN_3		0
	#define MX_UART_CTS_PIN_3		4
	#define MX_UART_CTS_PORT_3		porta
	#define MX_UART_CTS_TRIS_3		trisa
	#define MX_UART_RTS_PIN_3		0
	#define MX_UART_RTS_PORT_3		porta
	#define MX_UART_RTS_TRIS_3		trisa
	#define MX_UART_BAUD_3			9600
	#define MX_UART_DBITS_3			8
	#define MX_UART_RETURN_3		0
	#define MX_UART_ECHO_3			0
	#define MX_UART_INT_3			0
  #else
   #ifndef	MX_UART_REF4
	#define MX_UART_REF4
	#define RS232_1_MX_UART_UREF			4
	#define MX_UART_CHANNEL_4		1
	#define MX_UART_TX_PIN_4		0
	#define MX_UART_TX_PORT_4		porta
	#define MX_UART_TX_TRIS_4		trisa
	#define MX_UART_RX_PIN_4		0
	#define MX_UART_RX_PORT_4		porta
	#define MX_UART_RX_TRIS_4		trisa
	#define MX_UART_FLOWEN_4		0
	#define MX_UART_CTS_PIN_4		4
	#define MX_UART_CTS_PORT_4		porta
	#define MX_UART_CTS_TRIS_4		trisa
	#define MX_UART_RTS_PIN_4		0
	#define MX_UART_RTS_PORT_4		porta
	#define MX_UART_RTS_TRIS_4		trisa
	#define MX_UART_BAUD_4			9600
	#define MX_UART_DBITS_4			8
	#define MX_UART_RETURN_4		0
	#define MX_UART_ECHO_4			0
	#define MX_UART_INT_4			0
   #endif
  #endif
 #endif
#endif

#define RS232_1_UART_Init		CAL_APPEND(FC_CAL_UART_Init_, RS232_1_MX_UART_UREF)
#define RS232_1_UART_Send		CAL_APPEND(FC_CAL_UART_Send_, RS232_1_MX_UART_UREF)
#define RS232_1_UART_Receive		CAL_APPEND(FC_CAL_UART_Receive_, RS232_1_MX_UART_UREF)
#define RS232_1_UART_Update_Baud CAL_APPEND(FC_CAL_UART_Update_Baud_, RS232_1_MX_UART_UREF)

extern void RS232_1_UART_Init();
extern void RS232_1_UART_Send(MX_UINT16 nChar);
extern MX_SINT16 RS232_1_UART_Receive(MX_UINT8 nTimeout);
extern void RS232_1_UART_Update_Baud(MX_UINT8 newbaud);




//RS232(0): //Macro function declarations

void FCD_RS2320_SendRS232Char(MX_SINT16 nChar);
void FCD_RS2320_SendRS232String(MX_STRING String, MX_UINT8 MSZ_String);
MX_SINT16 FCD_RS2320_ReceiveRS232Char(MX_UINT8 nTimeout);
void FCD_RS2320_ReceiveRS232String(MX_CHAR* FCR_RETVAL, MX_UINT8 FCR_RETVAL_SIZE, MX_UINT8 nTimeout, MX_UINT8 NumBytes);
void FCD_RS2320_ChangeHWBaud(MX_UINT8 newbaud);


//LCDDisplay(0): //Defines:

/**** Macro Substitutions ****
a = Unique Component Reference Number
b = D1 Port Letter
c = D2 Port Letter
d = D3 Port Letter
e = D4 Port Letter
f = RS Port Letter
g = E Port Letter
h = Data 1_Pin
i = Data 2 Pin
j = Data 3 Pin
k = Data 4 Pin
l = RS Pin
m = Enable Pin
n = Row Count
o = Column Count
******************************/

	//component connections
	#define LCD_2__PORT0    porta
	#define LCD_2__PORT1    porta
	#define LCD_2__PORT2    porta
	#define LCD_2__PORT3    portb
	#define LCD_2__PORT4    portc
	#define LCD_2__PORT5    portc
	#define LCD_2__TRIS0    trisa
	#define LCD_2__TRIS1    trisa
	#define LCD_2__TRIS2    trisa
	#define LCD_2__TRIS3    trisb
	#define LCD_2__TRIS4    trisc
	#define LCD_2__TRIS5    trisc
	#define LCD_2__BIT0    	0
	#define LCD_2__BIT1    	1
	#define LCD_2__BIT2    	2
	#define LCD_2__BIT3    	4
	#define LCD_2__RS      	6
	#define LCD_2__E       	7
	#define LCD_2__ROWCNT	4
	#define LCD_2__COLCNT	16

	#ifdef _BOOSTC
	  #define LCD_2__DELAY   delay_10us(10)
	#endif
	#ifdef _C2C_
	  #define LCD_2__DELAY   delay_us(100)
	#endif
	#ifdef HI_TECH_C
	  #define LCD_2__DELAY   __delay_us(120)
	#endif
	#ifndef LCD_2__DELAY
	  #define LCD_2__DELAY   delay_us(100)
	#endif




//LCDDisplay(0): //Macro function declarations

void FCD_LCDDisplay0_RawSend(MX_UINT8 in, MX_UINT8 mask);
void FCD_LCDDisplay0_Start();
void FCD_LCDDisplay0_Clear();
void FCD_LCDDisplay0_PrintASCII(MX_UINT8 Character);
void FCD_LCDDisplay0_Command(MX_UINT8 in);
void FCD_LCDDisplay0_Cursor(MX_UINT8 x, MX_UINT8 y);
void FCD_LCDDisplay0_PrintNumber(MX_SINT16 Number);
void FCD_LCDDisplay0_PrintString(MX_STRING String, MX_UINT8 MSZ_String);
void FCD_LCDDisplay0_ScrollDisplay(MX_UINT8 Direction, MX_UINT8 Num_Positions);
void FCD_LCDDisplay0_ClearLine(MX_UINT8 Line);
void FCD_LCDDisplay0_RAM_Write(MX_UINT8 nIdx, MX_UINT8 d0, MX_UINT8 d1, MX_UINT8 d2, MX_UINT8 d3, MX_UINT8 d4, MX_UINT8 d5, MX_UINT8 d6, MX_UINT8 d7);


//KeyPad(0): //Defines:

/**** Macro Substitutions ****

a = Unique Reference
b = Key List (Numbers)
c = Key List (Characters)
d = Number of Columns
e = Column Port Letter
f = Column Pin Number 0
g = Column Pin Number 1
h = Column Pin Number 2
i = Column Pin Number 3
j = Number of Rows
k = Row Port Letter
l = Row Pin Number 0
m = Row Pin Number 1
n = Row Pin Number 2
o = Row Pin Number 3

******************************/

//Keypad Common Defines

#define Keypad_3_MX_KEYPAD_COL_NUM	3
#define Keypad_3_MX_KEYPAD_COL_PORT	portc
#define Keypad_3_MX_KEYPAD_COL_TRIS	trisc
#define Keypad_3_MX_KEYPAD_COL_PIN0	3
#define Keypad_3_MX_KEYPAD_COL_PIN1	4
#define Keypad_3_MX_KEYPAD_COL_PIN2	5
#define Keypad_3_MX_KEYPAD_COL_PIN3	0
#define Keypad_3_MX_KEYPAD_ROW_NUM	3
#define Keypad_3_MX_KEYPAD_ROW_PORT	portc
#define Keypad_3_MX_KEYPAD_ROW_TRIS	trisc
#define Keypad_3_MX_KEYPAD_ROW_PIN0	2
#define Keypad_3_MX_KEYPAD_ROW_PIN1	1
#define Keypad_3_MX_KEYPAD_ROW_PIN2	0
#define Keypad_3_MX_KEYPAD_ROW_PIN3	0

//Keypad Pin Arrays

ROMARRAY_S Keypad_3_MX_KEYPAD_COL ROMARRAY_E = {
06E1  3000  	MOVLW 0x00
06E2  00AE  	MOVWF gbl_Keypad_3_MX_KEYPAD_COL

	#if (Keypad_3_MX_KEYPAD_COL_NUM >= 1)
		Keypad_3_MX_KEYPAD_COL_PIN0
	#endif
	#if (Keypad_3_MX_KEYPAD_COL_NUM >= 2)
		,Keypad_3_MX_KEYPAD_COL_PIN1
	#endif
	#if (Keypad_3_MX_KEYPAD_COL_NUM >= 3)
		,Keypad_3_MX_KEYPAD_COL_PIN2
	#endif
	#if (Keypad_3_MX_KEYPAD_COL_NUM >= 4)
		,Keypad_3_MX_KEYPAD_COL_PIN3
	#endif
	};

ROMARRAY_S Keypad_3_MX_KEYPAD_ROW ROMARRAY_E = {
06E3  3001  	MOVLW 0x01
06E4  00AF  	MOVWF gbl_Keypad_3_MX_KEYPAD_ROW

	#if (Keypad_3_MX_KEYPAD_ROW_NUM >= 1)
		Keypad_3_MX_KEYPAD_ROW_PIN0
	#endif
	#if (Keypad_3_MX_KEYPAD_ROW_NUM >= 2)
		,Keypad_3_MX_KEYPAD_ROW_PIN1
	#endif
	#if (Keypad_3_MX_KEYPAD_ROW_NUM >= 3)
		,Keypad_3_MX_KEYPAD_ROW_PIN2
	#endif
	#if (Keypad_3_MX_KEYPAD_ROW_NUM >= 4)
		,Keypad_3_MX_KEYPAD_ROW_PIN3
	#endif
	};

//Keypad Keypress Data Arrays

ROMARRAY_S Keypad_3_mtxKeysAsNumbers ROMARRAY_E = {1,4,7,2,5,8,3,6,9};
06E5  3002  	MOVLW 0x02
06E6  00B0  	MOVWF gbl_Keypad_3_mtxKeysAsNumbers

ROMARRAY_S Keypad_3_mtxKeysAsChars ROMARRAY_E = {'1','4','7','2','5','8','3','6','9'};
06E7  3003  	MOVLW 0x03
06E8  00B1  	MOVWF gbl_Keypad_3_mtxKeysAsChars





//KeyPad(0): //Macro function declarations

MX_UINT8 FCD_KeyPad0_GetKeypadNumber();
MX_UINT8 FCD_KeyPad0_GetKeypadAscii();



//RS232(0): //Macro implementations


void FCD_RS2320_SendRS232Char(MX_SINT16 nChar)

{
	
		RS232_1_UART_Send ( nChar);
00C5  0833  	MOVF FCD_RS2320_00052_arg_nChar, W
00C6  00B5  	MOVWF FC_CAL_UAR_00060_arg_nChar
00C7  0834  	MOVF FCD_RS2320_00052_arg_nChar+D'1', W
00C8  00B6  	MOVWF FC_CAL_UAR_00060_arg_nChar+D'1'
00C9  209C  	CALL FC_CAL_UAR_00060


}
00CA  0008  	RETURN


void FCD_RS2320_SendRS232String(MX_STRING String, MX_UINT8 MSZ_String)
{
	
		MX_UINT8 idx;
		for(idx = 0; idx < MSZ_String; idx++)
		{
			if (String[idx] == 0)
				break;
			else RS232_1_UART_Send ( String[idx] );
		}

}

MX_SINT16 FCD_RS2320_ReceiveRS232Char(MX_UINT8 nTimeout)
{
	
		return ( RS232_1_UART_Receive ( nTimeout) );

}

void FCD_RS2320_ReceiveRS232String(MX_CHAR* FCR_RETVAL, MX_UINT8 FCR_RETVAL_SIZE, MX_UINT8 nTimeout, MX_UINT8 NumBytes)
{
	
		MX_UINT8 idx;
		MX_SINT16 RS232_TO = 255;
		MX_SINT16 in;

		if ( 0 != 0 )
			RS232_TO = 256;

		if (NumBytes > FCR_RETVAL_SIZE)
			NumBytes = FCR_RETVAL_SIZE;

		for (idx = 0; idx < NumBytes; idx++)
		{
			in = RS232_1_UART_Receive ( nTimeout);
			if(in < RS232_TO)
				FCR_RETVAL[idx] = in & 0xFF;
			else
				break;
		}

		if (idx < FCR_RETVAL_SIZE)
			FCR_RETVAL[idx] = 0;

}

void FCD_RS2320_ChangeHWBaud(MX_UINT8 newbaud)
{
	
		RS232_1_UART_Update_Baud (newbaud);

}



//LCDDisplay(0): //Macro implementations


void FCD_LCDDisplay0_RawSend(MX_UINT8 in, MX_UINT8 mask)

{
	
		MX_UINT8 pt;

		FC_CAL_Bit_Low(LCD_2__PORT0, LCD_2__BIT0);
00CB  1283  	BCF STATUS, RP0
00CC  1005  	BCF gbl_porta,0

		FC_CAL_Bit_Low(LCD_2__PORT1, LCD_2__BIT1);
00CD  1085  	BCF gbl_porta,1

		FC_CAL_Bit_Low(LCD_2__PORT2, LCD_2__BIT2);
00CE  1105  	BCF gbl_porta,2

		FC_CAL_Bit_Low(LCD_2__PORT3, LCD_2__BIT3);
00CF  1206  	BCF gbl_portb,4

		FC_CAL_Bit_Low(LCD_2__PORT4, LCD_2__RS);
00D0  1307  	BCF gbl_portc,6

		FC_CAL_Bit_Low(LCD_2__PORT5, LCD_2__E);
00D1  1387  	BCF gbl_portc,7

		pt = ((in >> 4) & 0x0f);
00D2  1683  	BSF STATUS, RP0
00D3  0E42  	SWAPF FCD_LCDDis_00069_arg_in, W
00D4  390F  	ANDLW 0x0F
00D5  00C4  	MOVWF FCD_LCDDis_00069_1_pt
00D6  300F  	MOVLW 0x0F
00D7  05C4  	ANDWF FCD_LCDDis_00069_1_pt, F

		if (pt & 0x01)
00D8  1C44  	BTFSS FCD_LCDDis_00069_1_pt,0
00D9  28DC  	GOTO	label16

		    FC_CAL_Bit_High(LCD_2__PORT0, LCD_2__BIT0);
00DA  1283  	BCF STATUS, RP0
00DB  1405  	BSF gbl_porta,0

		if (pt & 0x02)
00DC  1683  	BSF STATUS, RP0
00DD  1CC4  	BTFSS FCD_LCDDis_00069_1_pt,1
00DE  28E1  	GOTO	label17

		    FC_CAL_Bit_High(LCD_2__PORT1, LCD_2__BIT1);
00DF  1283  	BCF STATUS, RP0
00E0  1485  	BSF gbl_porta,1

		if (pt & 0x04)
00E1  1683  	BSF STATUS, RP0
00E2  1D44  	BTFSS FCD_LCDDis_00069_1_pt,2
00E3  28E6  	GOTO	label18

		    FC_CAL_Bit_High(LCD_2__PORT2, LCD_2__BIT2);
00E4  1283  	BCF STATUS, RP0
00E5  1505  	BSF gbl_porta,2

		if (pt & 0x08)
00E6  1683  	BSF STATUS, RP0
00E7  1DC4  	BTFSS FCD_LCDDis_00069_1_pt,3
00E8  28EB  	GOTO	label19

		    FC_CAL_Bit_High(LCD_2__PORT3, LCD_2__BIT3);
00E9  1283  	BCF STATUS, RP0
00EA  1606  	BSF gbl_portb,4

		if (mask)
00EB  1683  	BSF STATUS, RP0
00EC  08C3  	MOVF FCD_LCDDis_00069_arg_mask, F
00ED  1903  	BTFSC STATUS,Z
00EE  28F1  	GOTO	label20

		    FC_CAL_Bit_High(LCD_2__PORT4, LCD_2__RS);
00EF  1283  	BCF STATUS, RP0
00F0  1707  	BSF gbl_portc,6

		LCD_2__DELAY;
00F1  300A  	MOVLW 0x0A
00F2  1683  	BSF STATUS, RP0
00F3  00C5  	MOVWF delay_10us_00000_arg_del
00F4  203C  	CALL delay_10us_00000

		FC_CAL_Bit_High (LCD_2__PORT5, LCD_2__E);
00F5  1283  	BCF STATUS, RP0
00F6  1787  	BSF gbl_portc,7

		LCD_2__DELAY;
00F7  300A  	MOVLW 0x0A
00F8  1683  	BSF STATUS, RP0
00F9  00C5  	MOVWF delay_10us_00000_arg_del
00FA  203C  	CALL delay_10us_00000

		FC_CAL_Bit_Low (LCD_2__PORT5, LCD_2__E);
00FB  1283  	BCF STATUS, RP0
00FC  1387  	BCF gbl_portc,7

		pt = (in & 0x0f);
00FD  300F  	MOVLW 0x0F
00FE  1683  	BSF STATUS, RP0
00FF  0542  	ANDWF FCD_LCDDis_00069_arg_in, W
0100  00C4  	MOVWF FCD_LCDDis_00069_1_pt

		LCD_2__DELAY;
0101  300A  	MOVLW 0x0A
0102  00C5  	MOVWF delay_10us_00000_arg_del
0103  203C  	CALL delay_10us_00000

		FC_CAL_Bit_Low(LCD_2__PORT0, LCD_2__BIT0);
0104  1283  	BCF STATUS, RP0
0105  1005  	BCF gbl_porta,0

		FC_CAL_Bit_Low(LCD_2__PORT1, LCD_2__BIT1);
0106  1085  	BCF gbl_porta,1

		FC_CAL_Bit_Low(LCD_2__PORT2, LCD_2__BIT2);
0107  1105  	BCF gbl_porta,2

		FC_CAL_Bit_Low(LCD_2__PORT3, LCD_2__BIT3);
0108  1206  	BCF gbl_portb,4

		FC_CAL_Bit_Low(LCD_2__PORT4, LCD_2__RS);
0109  1307  	BCF gbl_portc,6

		FC_CAL_Bit_Low(LCD_2__PORT5, LCD_2__E);
010A  1387  	BCF gbl_portc,7

		if (pt & 0x01)
010B  1683  	BSF STATUS, RP0
010C  1C44  	BTFSS FCD_LCDDis_00069_1_pt,0
010D  2910  	GOTO	label21

		    FC_CAL_Bit_High(LCD_2__PORT0, LCD_2__BIT0);
010E  1283  	BCF STATUS, RP0
010F  1405  	BSF gbl_porta,0

		if (pt & 0x02)
0110  1683  	BSF STATUS, RP0
0111  1CC4  	BTFSS FCD_LCDDis_00069_1_pt,1
0112  2915  	GOTO	label22

		    FC_CAL_Bit_High(LCD_2__PORT1, LCD_2__BIT1);
0113  1283  	BCF STATUS, RP0
0114  1485  	BSF gbl_porta,1

		if (pt & 0x04)
0115  1683  	BSF STATUS, RP0
0116  1D44  	BTFSS FCD_LCDDis_00069_1_pt,2
0117  291A  	GOTO	label23

		    FC_CAL_Bit_High(LCD_2__PORT2, LCD_2__BIT2);
0118  1283  	BCF STATUS, RP0
0119  1505  	BSF gbl_porta,2

		if (pt & 0x08)
011A  1683  	BSF STATUS, RP0
011B  1DC4  	BTFSS FCD_LCDDis_00069_1_pt,3
011C  291F  	GOTO	label24

		    FC_CAL_Bit_High(LCD_2__PORT3, LCD_2__BIT3);
011D  1283  	BCF STATUS, RP0
011E  1606  	BSF gbl_portb,4

		if (mask)
011F  1683  	BSF STATUS, RP0
0120  08C3  	MOVF FCD_LCDDis_00069_arg_mask, F
0121  1903  	BTFSC STATUS,Z
0122  2925  	GOTO	label25

		    FC_CAL_Bit_High(LCD_2__PORT4, LCD_2__RS);
0123  1283  	BCF STATUS, RP0
0124  1707  	BSF gbl_portc,6

		LCD_2__DELAY;
0125  300A  	MOVLW 0x0A
0126  1683  	BSF STATUS, RP0
0127  00C5  	MOVWF delay_10us_00000_arg_del
0128  203C  	CALL delay_10us_00000

		FC_CAL_Bit_High (LCD_2__PORT5, LCD_2__E);
0129  1283  	BCF STATUS, RP0
012A  1787  	BSF gbl_portc,7

		LCD_2__DELAY;
012B  300A  	MOVLW 0x0A
012C  1683  	BSF STATUS, RP0
012D  00C5  	MOVWF delay_10us_00000_arg_del
012E  203C  	CALL delay_10us_00000

		FC_CAL_Bit_Low (LCD_2__PORT5, LCD_2__E);
012F  1283  	BCF STATUS, RP0
0130  1387  	BCF gbl_portc,7

		LCD_2__DELAY;
0131  300A  	MOVLW 0x0A
0132  1683  	BSF STATUS, RP0
0133  00C5  	MOVWF delay_10us_00000_arg_del
0134  203C  	CALL delay_10us_00000


}
0135  0008  	RETURN


void FCD_LCDDisplay0_Start()

{
	
		FC_CAL_Bit_Low_DDR(LCD_2__PORT0, LCD_2__TRIS0, LCD_2__BIT0);
0613  1683  	BSF STATUS, RP0
0614  1303  	BCF STATUS, RP1
0615  1005  	BCF gbl_trisa,0
0616  1283  	BCF STATUS, RP0
0617  1005  	BCF gbl_porta,0

		FC_CAL_Bit_Low_DDR(LCD_2__PORT1, LCD_2__TRIS1, LCD_2__BIT1);
0618  1683  	BSF STATUS, RP0
0619  1085  	BCF gbl_trisa,1
061A  1283  	BCF STATUS, RP0
061B  1085  	BCF gbl_porta,1

		FC_CAL_Bit_Low_DDR(LCD_2__PORT2, LCD_2__TRIS2, LCD_2__BIT2);
061C  1683  	BSF STATUS, RP0
061D  1105  	BCF gbl_trisa,2
061E  1283  	BCF STATUS, RP0
061F  1105  	BCF gbl_porta,2

		FC_CAL_Bit_Low_DDR(LCD_2__PORT3, LCD_2__TRIS3, LCD_2__BIT3);
0620  1683  	BSF STATUS, RP0
0621  1206  	BCF gbl_trisb,4
0622  1283  	BCF STATUS, RP0
0623  1206  	BCF gbl_portb,4

		FC_CAL_Bit_Low_DDR(LCD_2__PORT4, LCD_2__TRIS4, LCD_2__RS);
0624  1683  	BSF STATUS, RP0
0625  1307  	BCF gbl_trisc,6
0626  1283  	BCF STATUS, RP0
0627  1307  	BCF gbl_portc,6

		FC_CAL_Bit_Low_DDR(LCD_2__PORT5, LCD_2__TRIS5, LCD_2__E);
0628  1683  	BSF STATUS, RP0
0629  1387  	BCF gbl_trisc,7
062A  1283  	BCF STATUS, RP0
062B  1387  	BCF gbl_portc,7


		Wdt_Delay_Ms(12);
062C  300C  	MOVLW 0x0C
062D  1683  	BSF STATUS, RP0
062E  00B5  	MOVWF Wdt_Delay__0003E_arg_delay
062F  20BA  	CALL Wdt_Delay__0003E


		FCD_LCDDisplay0_RawSend(0x33, 0);
0630  3033  	MOVLW 0x33
0631  00C2  	MOVWF FCD_LCDDis_00069_arg_in
0632  01C3  	CLRF FCD_LCDDis_00069_arg_mask
0633  20CB  	CALL FCD_LCDDis_00069

		Wdt_Delay_Ms(2);
0634  3002  	MOVLW 0x02
0635  00B5  	MOVWF Wdt_Delay__0003E_arg_delay
0636  20BA  	CALL Wdt_Delay__0003E

		FCD_LCDDisplay0_RawSend(0x33, 0);
0637  3033  	MOVLW 0x33
0638  00C2  	MOVWF FCD_LCDDis_00069_arg_in
0639  01C3  	CLRF FCD_LCDDis_00069_arg_mask
063A  20CB  	CALL FCD_LCDDis_00069

		Wdt_Delay_Ms(2);
063B  3002  	MOVLW 0x02
063C  00B5  	MOVWF Wdt_Delay__0003E_arg_delay
063D  20BA  	CALL Wdt_Delay__0003E

		FCD_LCDDisplay0_RawSend(0x32, 0);
063E  3032  	MOVLW 0x32
063F  00C2  	MOVWF FCD_LCDDis_00069_arg_in
0640  01C3  	CLRF FCD_LCDDis_00069_arg_mask
0641  20CB  	CALL FCD_LCDDis_00069

		Wdt_Delay_Ms(2);
0642  3002  	MOVLW 0x02
0643  00B5  	MOVWF Wdt_Delay__0003E_arg_delay
0644  20BA  	CALL Wdt_Delay__0003E

		FCD_LCDDisplay0_RawSend(0x2c, 0);
0645  302C  	MOVLW 0x2C
0646  00C2  	MOVWF FCD_LCDDis_00069_arg_in
0647  01C3  	CLRF FCD_LCDDis_00069_arg_mask
0648  20CB  	CALL FCD_LCDDis_00069

		Wdt_Delay_Ms(2);
0649  3002  	MOVLW 0x02
064A  00B5  	MOVWF Wdt_Delay__0003E_arg_delay
064B  20BA  	CALL Wdt_Delay__0003E

		FCD_LCDDisplay0_RawSend(0x06, 0);
064C  3006  	MOVLW 0x06
064D  00C2  	MOVWF FCD_LCDDis_00069_arg_in
064E  01C3  	CLRF FCD_LCDDis_00069_arg_mask
064F  20CB  	CALL FCD_LCDDis_00069

		Wdt_Delay_Ms(2);
0650  3002  	MOVLW 0x02
0651  00B5  	MOVWF Wdt_Delay__0003E_arg_delay
0652  20BA  	CALL Wdt_Delay__0003E

		FCD_LCDDisplay0_RawSend(0x0c, 0);
0653  300C  	MOVLW 0x0C
0654  00C2  	MOVWF FCD_LCDDis_00069_arg_in
0655  01C3  	CLRF FCD_LCDDis_00069_arg_mask
0656  20CB  	CALL FCD_LCDDis_00069

		Wdt_Delay_Ms(2);
0657  3002  	MOVLW 0x02
0658  00B5  	MOVWF Wdt_Delay__0003E_arg_delay
0659  20BA  	CALL Wdt_Delay__0003E


		//clear the display
		FCD_LCDDisplay0_RawSend(0x01, 0);
065A  3001  	MOVLW 0x01
065B  00C2  	MOVWF FCD_LCDDis_00069_arg_in
065C  01C3  	CLRF FCD_LCDDis_00069_arg_mask
065D  20CB  	CALL FCD_LCDDis_00069

		Wdt_Delay_Ms(2);
065E  3002  	MOVLW 0x02
065F  00B5  	MOVWF Wdt_Delay__0003E_arg_delay
0660  20BA  	CALL Wdt_Delay__0003E

		FCD_LCDDisplay0_RawSend(0x02, 0);
0661  3002  	MOVLW 0x02
0662  00C2  	MOVWF FCD_LCDDis_00069_arg_in
0663  01C3  	CLRF FCD_LCDDis_00069_arg_mask
0664  20CB  	CALL FCD_LCDDis_00069

		Wdt_Delay_Ms(2);
0665  3002  	MOVLW 0x02
0666  00B5  	MOVWF Wdt_Delay__0003E_arg_delay
0667  20BA  	CALL Wdt_Delay__0003E


}
0668  0008  	RETURN


void FCD_LCDDisplay0_Clear()

{
	
		FCD_LCDDisplay0_RawSend(0x01, 0);
0234  3001  	MOVLW 0x01
0235  1683  	BSF STATUS, RP0
0236  1303  	BCF STATUS, RP1
0237  00C2  	MOVWF FCD_LCDDis_00069_arg_in
0238  01C3  	CLRF FCD_LCDDis_00069_arg_mask
0239  20CB  	CALL FCD_LCDDis_00069

		Wdt_Delay_Ms(2);
023A  3002  	MOVLW 0x02
023B  00B5  	MOVWF Wdt_Delay__0003E_arg_delay
023C  20BA  	CALL Wdt_Delay__0003E

		FCD_LCDDisplay0_RawSend(0x02, 0);
023D  3002  	MOVLW 0x02
023E  00C2  	MOVWF FCD_LCDDis_00069_arg_in
023F  01C3  	CLRF FCD_LCDDis_00069_arg_mask
0240  20CB  	CALL FCD_LCDDis_00069

		Wdt_Delay_Ms(2);
0241  3002  	MOVLW 0x02
0242  00B5  	MOVWF Wdt_Delay__0003E_arg_delay
0243  20BA  	CALL Wdt_Delay__0003E


}
0244  0008  	RETURN


void FCD_LCDDisplay0_PrintASCII(MX_UINT8 Character)

{
	
		FCD_LCDDisplay0_RawSend(Character, 0x10);
0245  0833  	MOVF FCD_LCDDis_00056_arg_Character, W
0246  00C2  	MOVWF FCD_LCDDis_00069_arg_in
0247  3010  	MOVLW 0x10
0248  00C3  	MOVWF FCD_LCDDis_00069_arg_mask
0249  20CB  	CALL FCD_LCDDis_00069


}
024A  0008  	RETURN


void FCD_LCDDisplay0_Command(MX_UINT8 in)
{
	
		FCD_LCDDisplay0_RawSend(in, 0);
		Wdt_Delay_Ms(2);

}

void FCD_LCDDisplay0_Cursor(MX_UINT8 x, MX_UINT8 y)

{
	
	  #if (LCD_2__ROWCNT == 1)
	    y=0x80;
	  #endif

	  #if (LCD_2__ROWCNT == 2)
		if (y==0)
			y=0x80;
		else
			y=0xc0;
	  #endif

	  #if (LCD_2__ROWCNT == 4)
		if (y==0)
024B  08B4  	MOVF FCD_LCDDis_00055_arg_y, F
024C  1D03  	BTFSS STATUS,Z
024D  2A51  	GOTO	label32
0251        label32

			y=0x80;
024E  3080  	MOVLW 0x80
024F  00B4  	MOVWF FCD_LCDDis_00055_arg_y

		else if (y==1)
0250  2A60  	GOTO	label35
0251  0334  	DECF FCD_LCDDis_00055_arg_y, W
0252  1D03  	BTFSS STATUS,Z
0253  2A57  	GOTO	label33
0257        label33

			y=0xc0;
0254  30C0  	MOVLW 0xC0
0255  00B4  	MOVWF FCD_LCDDis_00055_arg_y


		#if (LCD_2__COLCNT == 16)
			else if (y==2)
0256  2A60  	GOTO	label35
0257  0834  	MOVF FCD_LCDDis_00055_arg_y, W
0258  3A02  	XORLW 0x02
0259  1D03  	BTFSS STATUS,Z
025A  2A5E  	GOTO	label34
025E        label34

				y=0x90;
025B  3090  	MOVLW 0x90
025C  00B4  	MOVWF FCD_LCDDis_00055_arg_y

			else
025D  2A60  	GOTO	label35
0260        label35

				y=0xd0;
025E  30D0  	MOVLW 0xD0
025F  00B4  	MOVWF FCD_LCDDis_00055_arg_y

		#endif

		#if (LCD_2__COLCNT == 20)
			else if (y==2)
				y=0x94;
			else
				y=0xd4;
		#endif
	  #endif

		FCD_LCDDisplay0_RawSend(y+x, 0);
0260  0833  	MOVF FCD_LCDDis_00055_arg_x, W
0261  0734  	ADDWF FCD_LCDDis_00055_arg_y, W
0262  00C2  	MOVWF FCD_LCDDis_00069_arg_in
0263  01C3  	CLRF FCD_LCDDis_00069_arg_mask
0264  20CB  	CALL FCD_LCDDis_00069

		Wdt_Delay_Ms(2);
0265  3002  	MOVLW 0x02
0266  00B5  	MOVWF Wdt_Delay__0003E_arg_delay
0267  20BA  	CALL Wdt_Delay__0003E


}
0268  0008  	RETURN


void FCD_LCDDisplay0_PrintNumber(MX_SINT16 Number)
{
	
		MX_SINT16 tmp_int;
		MX_UINT8 tmp_byte;

		if (Number < 0)
		{
			FCD_LCDDisplay0_RawSend('-', 0x10);
			Number = 0 - Number;
		}

		tmp_int = Number;
		if (Number >= 10000)
		{
			tmp_byte = tmp_int / 10000;
			FCD_LCDDisplay0_RawSend('0' + tmp_byte, 0x10);

			while (tmp_byte > 0)
			{
				tmp_int = tmp_int - 10000;
				tmp_byte--;
			}
		}
		if (Number >= 1000)
		{
			tmp_byte = tmp_int / 1000;
			FCD_LCDDisplay0_RawSend('0' + tmp_byte, 0x10);

			while (tmp_byte > 0)
			{
				tmp_int = tmp_int - 1000;
				tmp_byte--;
			}
		}
		if (Number >= 100)
		{
			tmp_byte = tmp_int / 100;
			FCD_LCDDisplay0_RawSend('0' + tmp_byte, 0x10);

			while (tmp_byte > 0)
			{
				tmp_int = tmp_int - 100;
				tmp_byte--;
			}
		}
		if (Number >= 10)
		{
			tmp_byte = tmp_int / 10;
			FCD_LCDDisplay0_RawSend('0' + tmp_byte, 0x10);

			while (tmp_byte > 0)
			{
				tmp_int = tmp_int - 10;
				tmp_byte--;
			}
		}
		FCD_LCDDisplay0_RawSend('0' + tmp_int, 0x10);

}

void FCD_LCDDisplay0_PrintString(MX_STRING String, MX_UINT8 MSZ_String)

{
	
		MX_UINT8 idx = 0;
0218  01C1  	CLRF FCD_LCDDis_0005A_1_idx


		for (idx=0; idx<MSZ_String; idx++)
0219  01C1  	CLRF FCD_LCDDis_0005A_1_idx
021A        label31
021A  0840  	MOVF FCD_LCDDis_0005A_arg_MSZ_String, W
021B  0241  	SUBWF FCD_LCDDis_0005A_1_idx, W
021C  1803  	BTFSC STATUS,C
0232  0AC1  	INCF FCD_LCDDis_0005A_1_idx, F
0233  2A1A  	GOTO	label31

		{
			if (String[idx] == 0)
021E  1383  	BCF STATUS,IRP
021F  1834  	BTFSC FCD_LCDDis_0005A_arg_String+D'1',0
0220  1783  	BSF STATUS,IRP
0221  0833  	MOVF FCD_LCDDis_0005A_arg_String, W
0222  0741  	ADDWF FCD_LCDDis_0005A_1_idx, W
0223  0084  	MOVWF FSR
0224  0880  	MOVF INDF, F
0225  1903  	BTFSC STATUS,Z

			{
				break;

			}
			FCD_LCDDisplay0_RawSend(String[idx], 0x10);
0227  1383  	BCF STATUS,IRP
0228  1834  	BTFSC FCD_LCDDis_0005A_arg_String+D'1',0
0229  1783  	BSF STATUS,IRP
022A  0833  	MOVF FCD_LCDDis_0005A_arg_String, W
022B  0741  	ADDWF FCD_LCDDis_0005A_1_idx, W
022C  0084  	MOVWF FSR
022D  0800  	MOVF INDF, W
022E  00C2  	MOVWF FCD_LCDDis_00069_arg_in
022F  3010  	MOVLW 0x10
0230  00C3  	MOVWF FCD_LCDDis_00069_arg_mask
0231  20CB  	CALL FCD_LCDDis_00069

		}

}
021D  0008  	RETURN
0226  0008  	RETURN


void FCD_LCDDisplay0_ScrollDisplay(MX_UINT8 Direction, MX_UINT8 Num_Positions)
{
	
		MX_UINT8 cmd = 0;
		MX_UINT8 count;

		//Choose the direction
		switch (Direction)
		{
			case 0:
			case 'l':
			case 'L':

				cmd = 0x18;
				break;

			case 1:
			case 'r':
			case 'R':

				cmd = 0x1C;
				break;

			default:
				break;
		}

		//If direction accepted then scroll the specified amount
		if (cmd)
		{
			for (count = 0; count < Num_Positions; count++)
				FCD_LCDDisplay0_Command(cmd);
		}

}

void FCD_LCDDisplay0_ClearLine(MX_UINT8 Line)
{
	
		MX_UINT8 count;
		MX_UINT8 rowcount;

		//Define number of columns per line
		#if (LCD_2__ROWCNT == 1)
			rowcount=80;
		#endif

		#if (LCD_2__ROWCNT == 2)
			rowcount=40;
		#endif

		#if (LCD_2__ROWCNT == 4)
			#if (LCD_2__COLCNT == 16)
				rowcount=16;
			#endif
			#if (LCD_2__COLCNT == 20)
				rowcount=20;
			#endif
		#endif

		//Start at beginning of the line
		FCD_LCDDisplay0_Cursor (0, Line);

		//Send out spaces to clear line
		for (count = 0; count < rowcount; count++)
			FCD_LCDDisplay0_RawSend(' ', 0x10);

		//Move back to the beginning of the line.
		FCD_LCDDisplay0_Cursor (0, Line);

}

void FCD_LCDDisplay0_RAM_Write(MX_UINT8 nIdx, MX_UINT8 d0, MX_UINT8 d1, MX_UINT8 d2, MX_UINT8 d3, MX_UINT8 d4, MX_UINT8 d5, MX_UINT8 d6, MX_UINT8 d7)
{
	   //set CGRAM address

	   FCD_LCDDisplay0_RawSend(64 + (nIdx << 3), 0);
	   delay_ms(2);

	   //write CGRAM data
	   FCD_LCDDisplay0_RawSend(d0, 0x10);
	   FCD_LCDDisplay0_RawSend(d1, 0x10);
	   FCD_LCDDisplay0_RawSend(d2, 0x10);
	   FCD_LCDDisplay0_RawSend(d3, 0x10);
	   FCD_LCDDisplay0_RawSend(d4, 0x10);
	   FCD_LCDDisplay0_RawSend(d5, 0x10);
	   FCD_LCDDisplay0_RawSend(d6, 0x10);
	   FCD_LCDDisplay0_RawSend(d7, 0x10);

	   //Clear the display
	   FCD_LCDDisplay0_RawSend(0x01, 0);
	   delay_ms(2);
	   FCD_LCDDisplay0_RawSend(0x02, 0);
	   delay_ms(2);

}



//KeyPad(0): //Macro implementations


MX_UINT8 FCD_KeyPad0_GetKeypadNumber()

{
	
		MX_UINT8 iCol, iRow, idx;

		for (iCol = 0; iCol < Keypad_3_MX_KEYPAD_COL_NUM; iCol++)
0269  1683  	BSF STATUS, RP0
026A  1303  	BCF STATUS, RP1
026B  01B3  	CLRF FCD_KeyPad_00058_1_iCol
026C        label36
026C  3003  	MOVLW 0x03
026D  0233  	SUBWF FCD_KeyPad_00058_1_iCol, W
026E  1803  	BTFSC STATUS,C
026F  2B11  	GOTO	label52
030F  0AB3  	INCF FCD_KeyPad_00058_1_iCol, F
0310  2A6C  	GOTO	label36
0311        label52

		{
			FC_CAL_Bit_High_DDR ( Keypad_3_MX_KEYPAD_COL_PORT, Keypad_3_MX_KEYPAD_COL_TRIS, Keypad_3_MX_KEYPAD_COL[iCol] ); 		//output the appropriate column high
0270  082E  	MOVF gbl_Keypad_3_MX_KEYPAD_COL, W
0271  00B6  	MOVWF __rom_get_00000_arg_objNumb
0272  0833  	MOVF FCD_KeyPad_00058_1_iCol, W
0273  00B7  	MOVWF __rom_get_00000_arg_idx
0274  204F  	CALL __rom_get_00000
0275  00B8  	MOVWF CompTempVar2250
0276  3001  	MOVLW 0x01
0277  00B9  	MOVWF CompTempVar2251
0278  01BA  	CLRF CompTempVar2252
0279  0838  	MOVF CompTempVar2250, W
027A        label37
027A  39FF  	ANDLW 0xFF
027B  118A  	BCF PCLATH,3
027C  120A  	BCF PCLATH,4
027D  1903  	BTFSC STATUS,Z
027E  2A84  	GOTO	label38
027F  1003  	BCF STATUS,C
0280  0DB9  	RLF CompTempVar2251, F
0281  0DBA  	RLF CompTempVar2252, F
0282  3EFF  	ADDLW 0xFF
0283  2A7A  	GOTO	label37
0284        label38
0284  0939  	COMF CompTempVar2251, W
0285  0587  	ANDWF gbl_trisc, F
0286  082E  	MOVF gbl_Keypad_3_MX_KEYPAD_COL, W
0287  00B6  	MOVWF __rom_get_00000_arg_objNumb
0288  0833  	MOVF FCD_KeyPad_00058_1_iCol, W
0289  00B7  	MOVWF __rom_get_00000_arg_idx
028A  204F  	CALL __rom_get_00000
028B  00B8  	MOVWF CompTempVar2254
028C  3001  	MOVLW 0x01
028D  00B9  	MOVWF CompTempVar2255
028E  0838  	MOVF CompTempVar2254, W
028F        label39
028F  39FF  	ANDLW 0xFF
0290  118A  	BCF PCLATH,3
0291  120A  	BCF PCLATH,4
0292  1903  	BTFSC STATUS,Z
0293  2A98  	GOTO	label40
0294  1003  	BCF STATUS,C
0295  0DB9  	RLF CompTempVar2255, F
0296  3EFF  	ADDLW 0xFF
0297  2A8F  	GOTO	label39
0298        label40
0298  0839  	MOVF CompTempVar2255, W
0299  1283  	BCF STATUS, RP0
029A  0487  	IORWF gbl_portc, F

			delay_us(10);																//delay to allow input to settle
029B  300A  	MOVLW 0x0A
029C  1683  	BSF STATUS, RP0
029D  00B6  	MOVWF delay_us_00000_arg_del
029E  204A  	CALL delay_us_00000


			for (iRow = 0; iRow < Keypad_3_MX_KEYPAD_ROW_NUM; iRow++)
029F  01B4  	CLRF FCD_KeyPad_00058_1_iRow
02A0        label41
02A0  3003  	MOVLW 0x03
02A1  0234  	SUBWF FCD_KeyPad_00058_1_iRow, W
02A2  1803  	BTFSC STATUS,C
02A3  2AFB  	GOTO	label49
02F8  1683  	BSF STATUS, RP0
02F9  0AB4  	INCF FCD_KeyPad_00058_1_iRow, F
02FA  2AA0  	GOTO	label41
02FB        label49

			{
				FC_CAL_Bit_In_DDR ( Keypad_3_MX_KEYPAD_ROW_PORT, Keypad_3_MX_KEYPAD_ROW_TRIS, Keypad_3_MX_KEYPAD_ROW[iRow] );
02A4  082F  	MOVF gbl_Keypad_3_MX_KEYPAD_ROW, W
02A5  00B6  	MOVWF __rom_get_00000_arg_objNumb
02A6  0834  	MOVF FCD_KeyPad_00058_1_iRow, W
02A7  00B7  	MOVWF __rom_get_00000_arg_idx
02A8  204F  	CALL __rom_get_00000
02A9  00BB  	MOVWF CompTempVar2260
02AA  3001  	MOVLW 0x01
02AB  00BC  	MOVWF CompTempVar2261
02AC  083B  	MOVF CompTempVar2260, W
02AD        label42
02AD  39FF  	ANDLW 0xFF
02AE  118A  	BCF PCLATH,3
02AF  120A  	BCF PCLATH,4
02B0  1903  	BTFSC STATUS,Z
02B1  2AB6  	GOTO	label43
02B2  1003  	BCF STATUS,C
02B3  0DBC  	RLF CompTempVar2261, F
02B4  3EFF  	ADDLW 0xFF
02B5  2AAD  	GOTO	label42
02B6        label43
02B6  083C  	MOVF CompTempVar2261, W
02B7  0487  	IORWF gbl_trisc, F

				if ( FC_CAL_Bit_In ( Keypad_3_MX_KEYPAD_ROW_PORT, Keypad_3_MX_KEYPAD_ROW[iRow] ))
02B8  082F  	MOVF gbl_Keypad_3_MX_KEYPAD_ROW, W
02B9  00B6  	MOVWF __rom_get_00000_arg_objNumb
02BA  0834  	MOVF FCD_KeyPad_00058_1_iRow, W
02BB  00B7  	MOVWF __rom_get_00000_arg_idx
02BC  204F  	CALL __rom_get_00000
02BD  00B8  	MOVWF CompTempVar2257
02BE  3001  	MOVLW 0x01
02BF  00B9  	MOVWF CompTempVar2258
02C0  01BA  	CLRF CompTempVar2259
02C1  0838  	MOVF CompTempVar2257, W
02C2        label44
02C2  39FF  	ANDLW 0xFF
02C3  118A  	BCF PCLATH,3
02C4  120A  	BCF PCLATH,4
02C5  1903  	BTFSC STATUS,Z
02C6  2ACC  	GOTO	label45
02C7  1003  	BCF STATUS,C
02C8  0DB9  	RLF CompTempVar2258, F
02C9  0DBA  	RLF CompTempVar2259, F
02CA  3EFF  	ADDLW 0xFF
02CB  2AC2  	GOTO	label44
02CC        label45
02CC  0839  	MOVF CompTempVar2258, W
02CD  1283  	BCF STATUS, RP0
02CE  0507  	ANDWF gbl_portc, W
02CF  1903  	BTFSC STATUS,Z
02D0  2AF8  	GOTO	label48
02F8        label48

				{
					idx = (iCol * Keypad_3_MX_KEYPAD_ROW_NUM) + iRow;
02D1  1683  	BSF STATUS, RP0
02D2  0833  	MOVF FCD_KeyPad_00058_1_iCol, W
02D3  00BB  	MOVWF __mul_8u_8_00006_arg_a
02D4  3003  	MOVLW 0x03
02D5  00BC  	MOVWF __mul_8u_8_00006_arg_b
02D6  20A4  	CALL __mul_8u_8_00006
02D7  0841  	MOVF CompTempVarRet452, W
02D8  00B5  	MOVWF FCD_KeyPad_00058_1_idx
02D9  0842  	MOVF CompTempVarRet452+D'1', W
02DA  00BD  	MOVWF CompTempVar2267
02DB  0834  	MOVF FCD_KeyPad_00058_1_iRow, W
02DC  07B5  	ADDWF FCD_KeyPad_00058_1_idx, F

					FC_CAL_Bit_In_DDR ( Keypad_3_MX_KEYPAD_COL_PORT, Keypad_3_MX_KEYPAD_COL_TRIS, Keypad_3_MX_KEYPAD_COL[iCol] ); 	//Allow the column pin to float
02DD  082E  	MOVF gbl_Keypad_3_MX_KEYPAD_COL, W
02DE  00B6  	MOVWF __rom_get_00000_arg_objNumb
02DF  0833  	MOVF FCD_KeyPad_00058_1_iCol, W
02E0  00B7  	MOVWF __rom_get_00000_arg_idx
02E1  204F  	CALL __rom_get_00000
02E2  00BB  	MOVWF CompTempVar2268
02E3  3001  	MOVLW 0x01
02E4  00BC  	MOVWF CompTempVar2269
02E5  083B  	MOVF CompTempVar2268, W
02E6        label46
02E6  39FF  	ANDLW 0xFF
02E7  118A  	BCF PCLATH,3
02E8  120A  	BCF PCLATH,4
02E9  1903  	BTFSC STATUS,Z
02EA  2AEF  	GOTO	label47
02EB  1003  	BCF STATUS,C
02EC  0DBC  	RLF CompTempVar2269, F
02ED  3EFF  	ADDLW 0xFF
02EE  2AE6  	GOTO	label46
02EF        label47
02EF  083C  	MOVF CompTempVar2269, W
02F0  0487  	IORWF gbl_trisc, F

					return (Keypad_3_mtxKeysAsNumbers[idx]);
02F1  0830  	MOVF gbl_Keypad_3_mtxKeysAsNumbers, W
02F2  00B6  	MOVWF __rom_get_00000_arg_objNumb
02F3  0835  	MOVF FCD_KeyPad_00058_1_idx, W
02F4  00B7  	MOVWF __rom_get_00000_arg_idx
02F5  204F  	CALL __rom_get_00000
02F6  00BB  	MOVWF CompTempVarRet2249

				}
			}
			FC_CAL_Bit_In_DDR ( Keypad_3_MX_KEYPAD_COL_PORT, Keypad_3_MX_KEYPAD_COL_TRIS, Keypad_3_MX_KEYPAD_COL[iCol] ); 		//Allow the column pin to float
02FB  082E  	MOVF gbl_Keypad_3_MX_KEYPAD_COL, W
02FC  00B6  	MOVWF __rom_get_00000_arg_objNumb
02FD  0833  	MOVF FCD_KeyPad_00058_1_iCol, W
02FE  00B7  	MOVWF __rom_get_00000_arg_idx
02FF  204F  	CALL __rom_get_00000
0300  00B8  	MOVWF CompTempVar2271
0301  3001  	MOVLW 0x01
0302  00B9  	MOVWF CompTempVar2272
0303  0838  	MOVF CompTempVar2271, W
0304        label50
0304  39FF  	ANDLW 0xFF
0305  118A  	BCF PCLATH,3
0306  120A  	BCF PCLATH,4
0307  1903  	BTFSC STATUS,Z
0308  2B0D  	GOTO	label51
0309  1003  	BCF STATUS,C
030A  0DB9  	RLF CompTempVar2272, F
030B  3EFF  	ADDLW 0xFF
030C  2B04  	GOTO	label50
030D        label51
030D  0839  	MOVF CompTempVar2272, W
030E  0487  	IORWF gbl_trisc, F

		}
		return (255);																	//if it gets here, it has not been found...
0311  30FF  	MOVLW 0xFF
0312  00BB  	MOVWF CompTempVarRet2249


}
02F7  0008  	RETURN
0313  0008  	RETURN


MX_UINT8 FCD_KeyPad0_GetKeypadAscii()
{
	
		MX_UINT8 iCol, iRow, idx;

		for (iCol = 0; iCol < Keypad_3_MX_KEYPAD_COL_NUM; iCol++)
		{
			FC_CAL_Bit_High_DDR ( Keypad_3_MX_KEYPAD_COL_PORT, Keypad_3_MX_KEYPAD_COL_TRIS, Keypad_3_MX_KEYPAD_COL[iCol] ); 		//output the appropriate column high
			delay_us(10);																//delay to allow input to settle

			for (iRow = 0; iRow < Keypad_3_MX_KEYPAD_ROW_NUM; iRow++)
			{
				FC_CAL_Bit_In_DDR ( Keypad_3_MX_KEYPAD_ROW_PORT, Keypad_3_MX_KEYPAD_ROW_TRIS, Keypad_3_MX_KEYPAD_ROW[iRow] );
				if ( FC_CAL_Bit_In ( Keypad_3_MX_KEYPAD_ROW_PORT, Keypad_3_MX_KEYPAD_ROW[iRow] ))
				{
					idx = (iCol * Keypad_3_MX_KEYPAD_ROW_NUM) + iRow;
					FC_CAL_Bit_In_DDR ( Keypad_3_MX_KEYPAD_COL_PORT, Keypad_3_MX_KEYPAD_COL_TRIS, Keypad_3_MX_KEYPAD_COL[iCol] ); 	//Allow the column pin to float
					return (Keypad_3_mtxKeysAsChars[idx]);
				}
			}
			FC_CAL_Bit_In_DDR ( Keypad_3_MX_KEYPAD_COL_PORT, Keypad_3_MX_KEYPAD_COL_TRIS, Keypad_3_MX_KEYPAD_COL[iCol] ); 		//Allow the column pin to float
		}
		return (255);																	//if it gets here, it has not been found...

}

#include "C:\Program Files (x86)\Flowcode\v5\CAL\includes.c"

//Macro implementations


void FCM_sample_ins()
{

	//Calculation
	//Calculation:
	//  TX_CHAR = 170
	FCV_TX_CHAR = 170;

	//Call Component Macro
	//Call Component Macro: SendRS232Char(TX_CHAR)
	FCD_RS2320_SendRS232Char(FCV_TX_CHAR);

	//Delay
	//Delay: 5 ms
	delay_ms(5);

	//Calculation
	//Calculation:
	//  TX_CHAR = 160
	FCV_TX_CHAR = 160;

	//Call Component Macro
	//Call Component Macro: SendRS232Char(TX_CHAR)
	FCD_RS2320_SendRS232Char(FCV_TX_CHAR);

	//Delay
	//Delay: 5 ms
	delay_ms(5);

	//Calculation
	//Calculation:
	//  TX_CHAR = 4
	FCV_TX_CHAR = 4;

	//Call Component Macro
	//Call Component Macro: SendRS232Char(TX_CHAR)
	FCD_RS2320_SendRS232Char(FCV_TX_CHAR);

	//Delay
	//Delay: 5 ms
	delay_ms(5);

	//Calculation
	//Calculation:
	//  TX_CHAR = 4
	FCV_TX_CHAR = 4;

	//Call Component Macro
	//Call Component Macro: SendRS232Char(TX_CHAR)
	FCD_RS2320_SendRS232Char(FCV_TX_CHAR);

	//Delay
	//Delay: 5 ms
	delay_ms(5);

	//Calculation
	//Calculation:
	//  TX_CHAR = 161
	FCV_TX_CHAR = 161;

	//Call Component Macro
	//Call Component Macro: SendRS232Char(TX_CHAR)
	FCD_RS2320_SendRS232Char(FCV_TX_CHAR);

	//Delay
	//Delay: 5 ms
	delay_ms(5);

	//Calculation
	//Calculation:
	//  TX_CHAR = 2
	FCV_TX_CHAR = 2;

	//Call Component Macro
	//Call Component Macro: SendRS232Char(TX_CHAR)
	FCD_RS2320_SendRS232Char(FCV_TX_CHAR);

	//Delay
	//Delay: 5 ms
	delay_ms(5);

	//Calculation
	//Calculation:
	//  TX_CHAR = 162
	FCV_TX_CHAR = 162;

	//Call Component Macro
	//Call Component Macro: SendRS232Char(TX_CHAR)
	FCD_RS2320_SendRS232Char(FCV_TX_CHAR);

	//Delay
	//Delay: 5 ms
	delay_ms(5);

	//Calculation
	//Calculation:
	//  TX_CHAR = 22
	FCV_TX_CHAR = 22;

	//Call Component Macro
	//Call Component Macro: SendRS232Char(TX_CHAR)
	FCD_RS2320_SendRS232Char(FCV_TX_CHAR);

	//Delay
	//Delay: 5 ms
	delay_ms(5);

	//Calculation
	//Calculation:
	//  TX_CHAR = 163
	FCV_TX_CHAR = 163;

	//Call Component Macro
	//Call Component Macro: SendRS232Char(TX_CHAR)
	FCD_RS2320_SendRS232Char(FCV_TX_CHAR);

	//Delay
	//Delay: 5 ms
	delay_ms(5);

	//Calculation
	//Calculation:
	//  TX_CHAR = 0
	FCV_TX_CHAR = 0;

	//Call Component Macro
	//Call Component Macro: SendRS232Char(TX_CHAR)
	FCD_RS2320_SendRS232Char(FCV_TX_CHAR);

	//Delay
	//Delay: 5 ms
	delay_ms(5);

	//Calculation
	//Calculation:
	//  TX_CHAR = 254
	FCV_TX_CHAR = 254;

	//Call Component Macro
	//Call Component Macro: SendRS232Char(TX_CHAR)
	FCD_RS2320_SendRS232Char(FCV_TX_CHAR);

	//Delay
	//Delay: 5 ms
	delay_ms(5);

	//Calculation
	//Calculation:
	//  TX_CHAR = 187
	FCV_TX_CHAR = 187;

	//Call Component Macro
	//Call Component Macro: SendRS232Char(TX_CHAR)
	FCD_RS2320_SendRS232Char(FCV_TX_CHAR);

	//Delay
	//Delay: 5 ms
	delay_ms(5);

}


void FCM_clr_char()

{

	//Calculation
	//Calculation:
	//  wrreg_temp = 0
	FCV_WRREG_TEMP = 0;
05FE  1683  	BSF STATUS, RP0
05FF  1303  	BCF STATUS, RP1
0600  01A8  	CLRF gbl_FCV_WRREG_TEMP


	//Loop
	//Loop: Loop 32 times
	for (FCLV_LOOP1=0; FCLV_LOOP1<32; FCLV_LOOP1++)
0601  01A9  	CLRF gbl_FCLV_LOOP1
0602        label105
0602  3020  	MOVLW 0x20
0603  0229  	SUBWF gbl_FCLV_LOOP1, W
0604  1803  	BTFSC STATUS,C
0611  0AA9  	INCF gbl_FCLV_LOOP1, F
0612  2E02  	GOTO	label105

	{

		//Calculation
		//Calculation:
		//  char[wrreg_temp] = 255
		FCV_CHAR[FCV_WRREG_TEMP] = 255;
0606  1283  	BCF STATUS, RP0
0607  1383  	BCF	STATUS,IRP
0608  3020  	MOVLW LOW(gbl_FCV_CHAR+D'0')
0609  0084  	MOVWF FSR
060A  1683  	BSF STATUS, RP0
060B  0828  	MOVF gbl_FCV_WRREG_TEMP, W
060C  0784  	ADDWF FSR, F
060D  30FF  	MOVLW 0xFF
060E  0080  	MOVWF INDF


		//Calculation
		//Calculation:
		//  wrreg_temp = wrreg_temp + 1
		FCV_WRREG_TEMP = FCV_WRREG_TEMP + 1;
060F  0A28  	INCF gbl_FCV_WRREG_TEMP, W
0610  00A8  	MOVWF gbl_FCV_WRREG_TEMP



	}

}
0605  0008  	RETURN



void FCM_print_char_onlcd()

{

	//Calculation
	//Calculation:
	//  wrreg_temp = 0
	//  cursorx = 0
	FCV_WRREG_TEMP = 0;
0323  1683  	BSF STATUS, RP0
0324  1303  	BCF STATUS, RP1
0325  01A8  	CLRF gbl_FCV_WRREG_TEMP

	FCV_CURSORX = 0;
0326  01A7  	CLRF gbl_FCV_CURSORX


	//Loop
	//Loop: Loop 16 times
	for (FCLV_LOOP2=0; FCLV_LOOP2<16; FCLV_LOOP2++)
0327  01AA  	CLRF gbl_FCLV_LOOP2
0328        label53
0328  3010  	MOVLW 0x10
0329  022A  	SUBWF gbl_FCLV_LOOP2, W
032A  1803  	BTFSC STATUS,C
032B  2B6E  	GOTO	label59
036C  0AAA  	INCF gbl_FCLV_LOOP2, F
036D  2B28  	GOTO	label53
036E        label59

	{

		//Decision
		//Decision: char[wrreg_temp] = 255?
		if (FCV_CHAR[FCV_WRREG_TEMP] == 255)
032C  1283  	BCF STATUS, RP0
032D  1383  	BCF	STATUS,IRP
032E  3020  	MOVLW LOW(gbl_FCV_CHAR+D'0')
032F  0084  	MOVWF FSR
0330  1683  	BSF STATUS, RP0
0331  0828  	MOVF gbl_FCV_WRREG_TEMP, W
0332  0784  	ADDWF FSR, F
0333  0A00  	INCF INDF, W
0334  1903  	BTFSC STATUS,Z
0368        label58
03B1        label65

		{

		} else {
0335  2B44  	GOTO	label54
0344        label54


			//Call Component Macro
			//Call Component Macro: Cursor(cursorx, 0)
			FCD_LCDDisplay0_Cursor(FCV_CURSORX, 0);
0336  0827  	MOVF gbl_FCV_CURSORX, W
0337  00B3  	MOVWF FCD_LCDDis_00055_arg_x
0338  01B4  	CLRF FCD_LCDDis_00055_arg_y
0339  224B  	CALL FCD_LCDDis_00055


			//Call Component Macro
			//Call Component Macro: PrintASCII(char[wrreg_temp])
			FCD_LCDDisplay0_PrintASCII(FCV_CHAR[FCV_WRREG_TEMP]);
033A  1283  	BCF STATUS, RP0
033B  1383  	BCF	STATUS,IRP
033C  3020  	MOVLW LOW(gbl_FCV_CHAR+D'0')
033D  0084  	MOVWF FSR
033E  1683  	BSF STATUS, RP0
033F  0828  	MOVF gbl_FCV_WRREG_TEMP, W
0340  0784  	ADDWF FSR, F
0341  0800  	MOVF INDF, W
0342  00B3  	MOVWF FCD_LCDDis_00056_arg_Character
0343  2245  	CALL FCD_LCDDis_00056


		}

		//Call Component Macro
		//Call Component Macro: Cursor(cursorx, 1)
		FCD_LCDDisplay0_Cursor(FCV_CURSORX, 1);
0344  0827  	MOVF gbl_FCV_CURSORX, W
0345  00B3  	MOVWF FCD_LCDDis_00055_arg_x
0346  3001  	MOVLW 0x01
0347  00B4  	MOVWF FCD_LCDDis_00055_arg_y
0348  224B  	CALL FCD_LCDDis_00055


		//Switch
		//Switch: color[wrreg_temp]?
		switch (FCV_COLOR[FCV_WRREG_TEMP])
0349  1283  	BCF STATUS, RP0
034A  1383  	BCF	STATUS,IRP
034B  3040  	MOVLW LOW(gbl_FCV_COLOR+D'0')
034C  0084  	MOVWF FSR
034D  1683  	BSF STATUS, RP0
034E  0828  	MOVF gbl_FCV_WRREG_TEMP, W
034F  0784  	ADDWF FSR, F
0350  0800  	MOVF INDF, W
0351  00B2  	MOVWF CompTempVar2191
035C  2B68  	GOTO	label58

		{
			case 0:
0352  0832  	MOVF CompTempVar2191, W
0353  3A00  	XORLW 0x00
0354  1903  	BTFSC STATUS,Z
0355  2B5D  	GOTO	label55
035D        label55

			{
				//Call Component Macro
				//Call Component Macro: PrintASCII('R')
				FCD_LCDDisplay0_PrintASCII('R');
035D  3052  	MOVLW 0x52
035E  00B3  	MOVWF FCD_LCDDis_00056_arg_Character
035F  2245  	CALL FCD_LCDDis_00056


				break;
0360  2B68  	GOTO	label58

			}
			case 1:
0356  3A01  	XORLW 0x01
0357  1903  	BTFSC STATUS,Z
0358  2B61  	GOTO	label56
0361        label56

			{
				//Call Component Macro
				//Call Component Macro: PrintASCII('G')
				FCD_LCDDisplay0_PrintASCII('G');
0361  3047  	MOVLW 0x47
0362  00B3  	MOVWF FCD_LCDDis_00056_arg_Character
0363  2245  	CALL FCD_LCDDis_00056


				break;
0364  2B68  	GOTO	label58

			}
			case 2:
0359  3A03  	XORLW 0x03
035A  1903  	BTFSC STATUS,Z
035B  2B65  	GOTO	label57
0365        label57

			{
				//Call Component Macro
				//Call Component Macro: PrintASCII('Y')
				FCD_LCDDisplay0_PrintASCII('Y');
0365  3059  	MOVLW 0x59
0366  00B3  	MOVWF FCD_LCDDis_00056_arg_Character
0367  2245  	CALL FCD_LCDDis_00056


				break;

			}
			// default:

		}

		//Calculation
		//Calculation:
		//  cursorx = cursorx + 1
		//  wrreg_temp = wrreg_temp + 1
		FCV_CURSORX = FCV_CURSORX + 1;
0368  0A27  	INCF gbl_FCV_CURSORX, W
0369  00A7  	MOVWF gbl_FCV_CURSORX

		FCV_WRREG_TEMP = FCV_WRREG_TEMP + 1;
036A  0A28  	INCF gbl_FCV_WRREG_TEMP, W
036B  00A8  	MOVWF gbl_FCV_WRREG_TEMP



	}

	//Calculation
	//Calculation:
	//  cursorx = 0
	FCV_CURSORX = 0;
036E  01A7  	CLRF gbl_FCV_CURSORX


	//Loop
	//Loop: Loop 16 times
	for (FCLV_LOOP3=0; FCLV_LOOP3<16; FCLV_LOOP3++)
036F  01AB  	CLRF gbl_FCLV_LOOP3
0370        label60
0370  3010  	MOVLW 0x10
0371  022B  	SUBWF gbl_FCLV_LOOP3, W
0372  1803  	BTFSC STATUS,C
03B5  0AAB  	INCF gbl_FCLV_LOOP3, F
03B6  2B70  	GOTO	label60

	{

		//Decision
		//Decision: char[wrreg_temp] = 255?
		if (FCV_CHAR[FCV_WRREG_TEMP] == 255)
0374  1283  	BCF STATUS, RP0
0375  1383  	BCF	STATUS,IRP
0376  3020  	MOVLW LOW(gbl_FCV_CHAR+D'0')
0377  0084  	MOVWF FSR
0378  1683  	BSF STATUS, RP0
0379  0828  	MOVF gbl_FCV_WRREG_TEMP, W
037A  0784  	ADDWF FSR, F
037B  0A00  	INCF INDF, W
037C  1903  	BTFSC STATUS,Z

		{

		} else {
037D  2B8D  	GOTO	label61
038D        label61


			//Call Component Macro
			//Call Component Macro: Cursor(cursorx, 2)
			FCD_LCDDisplay0_Cursor(FCV_CURSORX, 2);
037E  0827  	MOVF gbl_FCV_CURSORX, W
037F  00B3  	MOVWF FCD_LCDDis_00055_arg_x
0380  3002  	MOVLW 0x02
0381  00B4  	MOVWF FCD_LCDDis_00055_arg_y
0382  224B  	CALL FCD_LCDDis_00055


			//Call Component Macro
			//Call Component Macro: PrintASCII(char[wrreg_temp])
			FCD_LCDDisplay0_PrintASCII(FCV_CHAR[FCV_WRREG_TEMP]);
0383  1283  	BCF STATUS, RP0
0384  1383  	BCF	STATUS,IRP
0385  3020  	MOVLW LOW(gbl_FCV_CHAR+D'0')
0386  0084  	MOVWF FSR
0387  1683  	BSF STATUS, RP0
0388  0828  	MOVF gbl_FCV_WRREG_TEMP, W
0389  0784  	ADDWF FSR, F
038A  0800  	MOVF INDF, W
038B  00B3  	MOVWF FCD_LCDDis_00056_arg_Character
038C  2245  	CALL FCD_LCDDis_00056


		}

		//Call Component Macro
		//Call Component Macro: Cursor(cursorx, 3)
		FCD_LCDDisplay0_Cursor(FCV_CURSORX, 3);
038D  0827  	MOVF gbl_FCV_CURSORX, W
038E  00B3  	MOVWF FCD_LCDDis_00055_arg_x
038F  3003  	MOVLW 0x03
0390  00B4  	MOVWF FCD_LCDDis_00055_arg_y
0391  224B  	CALL FCD_LCDDis_00055


		//Switch
		//Switch: color[wrreg_temp]?
		switch (FCV_COLOR[FCV_WRREG_TEMP])
0392  1283  	BCF STATUS, RP0
0393  1383  	BCF	STATUS,IRP
0394  3040  	MOVLW LOW(gbl_FCV_COLOR+D'0')
0395  0084  	MOVWF FSR
0396  1683  	BSF STATUS, RP0
0397  0828  	MOVF gbl_FCV_WRREG_TEMP, W
0398  0784  	ADDWF FSR, F
0399  0800  	MOVF INDF, W
039A  00B2  	MOVWF CompTempVar2197
03A5  2BB1  	GOTO	label65

		{
			case 0:
039B  0832  	MOVF CompTempVar2197, W
039C  3A00  	XORLW 0x00
039D  1903  	BTFSC STATUS,Z
039E  2BA6  	GOTO	label62
03A6        label62

			{
				//Call Component Macro
				//Call Component Macro: PrintASCII('R')
				FCD_LCDDisplay0_PrintASCII('R');
03A6  3052  	MOVLW 0x52
03A7  00B3  	MOVWF FCD_LCDDis_00056_arg_Character
03A8  2245  	CALL FCD_LCDDis_00056


				break;
03A9  2BB1  	GOTO	label65

			}
			case 1:
039F  3A01  	XORLW 0x01
03A0  1903  	BTFSC STATUS,Z
03A1  2BAA  	GOTO	label63
03AA        label63

			{
				//Call Component Macro
				//Call Component Macro: PrintASCII('G')
				FCD_LCDDisplay0_PrintASCII('G');
03AA  3047  	MOVLW 0x47
03AB  00B3  	MOVWF FCD_LCDDis_00056_arg_Character
03AC  2245  	CALL FCD_LCDDis_00056


				break;
03AD  2BB1  	GOTO	label65

			}
			case 2:
03A2  3A03  	XORLW 0x03
03A3  1903  	BTFSC STATUS,Z
03A4  2BAE  	GOTO	label64
03AE        label64

			{
				//Call Component Macro
				//Call Component Macro: PrintASCII('Y')
				FCD_LCDDisplay0_PrintASCII('Y');
03AE  3059  	MOVLW 0x59
03AF  00B3  	MOVWF FCD_LCDDis_00056_arg_Character
03B0  2245  	CALL FCD_LCDDis_00056


				break;

			}
			// default:

		}

		//Calculation
		//Calculation:
		//  cursorx = cursorx + 1
		//  wrreg_temp = wrreg_temp + 1
		FCV_CURSORX = FCV_CURSORX + 1;
03B1  0A27  	INCF gbl_FCV_CURSORX, W
03B2  00A7  	MOVWF gbl_FCV_CURSORX

		FCV_WRREG_TEMP = FCV_WRREG_TEMP + 1;
03B3  0A28  	INCF gbl_FCV_WRREG_TEMP, W
03B4  00A8  	MOVWF gbl_FCV_WRREG_TEMP



	}

}
0373  0008  	RETURN



void FCM_keypad_con()

{

	//Decision
	//Decision: keypad_read = 3?
	if (FCV_KEYPAD_READ == 3)
03B7  1683  	BSF STATUS, RP0
03B8  1303  	BCF STATUS, RP1
03B9  0823  	MOVF gbl_FCV_KEYPAD_READ, W
03BA  3A03  	XORLW 0x03
03BB  1D03  	BTFSS STATUS,Z
03BC  2C70  	GOTO	label78
03BD        label66
0438        label73
0470        label78
04C6        label86

	{

		//Loop
		//Loop: While keypad_read = 3
		while (FCV_KEYPAD_READ == 3)
03BD  0823  	MOVF gbl_FCV_KEYPAD_READ, W
03BE  3A03  	XORLW 0x03
03BF  1D03  	BTFSS STATUS,Z
03C0  2BC7  	GOTO	label67
03C4  118A  	BCF PCLATH,3
03C5  120A  	BCF PCLATH,4
03C6  2BBD  	GOTO	label66
03C7        label67

		{

			//Call Component Macro
			//Call Component Macro: keypad_read=GetKeypadNumber()
			FCV_KEYPAD_READ = FCD_KeyPad0_GetKeypadNumber();
03C1  2269  	CALL FCD_KeyPad_00058
03C2  083B  	MOVF CompTempVarRet2249, W
03C3  00A3  	MOVWF gbl_FCV_KEYPAD_READ



		}

		//Call Component Macro
		//Call Component Macro: Clear()
		FCD_LCDDisplay0_Clear();
03C7  2234  	CALL FCD_LCDDis_00059


		//Call Component Macro
		//Call Component Macro: Cursor(0, 0)
		FCD_LCDDisplay0_Cursor(0, 0);
03C8  01B3  	CLRF FCD_LCDDis_00055_arg_x
03C9  01B4  	CLRF FCD_LCDDis_00055_arg_y
03CA  224B  	CALL FCD_LCDDis_00055


		//Call Component Macro
		//Call Component Macro: PrintString("SCROLL=")
		FCD_LCDDisplay0_PrintString("SCROLL=", 7);
03CB  3053  	MOVLW 0x53
03CC  00B5  	MOVWF CompTempVar2201
03CD  3043  	MOVLW 0x43
03CE  00B6  	MOVWF CompTempVar2201+D'1'
03CF  3052  	MOVLW 0x52
03D0  00B7  	MOVWF CompTempVar2201+D'2'
03D1  304F  	MOVLW 0x4F
03D2  00B8  	MOVWF CompTempVar2201+D'3'
03D3  304C  	MOVLW 0x4C
03D4  00B9  	MOVWF CompTempVar2201+D'4'
03D5  00BA  	MOVWF CompTempVar2201+D'5'
03D6  303D  	MOVLW 0x3D
03D7  00BB  	MOVWF CompTempVar2201+D'6'
03D8  01BC  	CLRF CompTempVar2201+D'7'
03D9  3000  	MOVLW HIGH(CompTempVar2201+D'0')
03DA  00B4  	MOVWF FCD_LCDDis_0005A_arg_String+D'1'
03DB  30B5  	MOVLW LOW(CompTempVar2201+D'0')
03DC  00B3  	MOVWF FCD_LCDDis_0005A_arg_String
03DD  3007  	MOVLW 0x07
03DE  00C0  	MOVWF FCD_LCDDis_0005A_arg_MSZ_String
03DF  2218  	CALL FCD_LCDDis_0005A


		//Call Component Macro
		//Call Component Macro: Cursor(8, 0)
		FCD_LCDDisplay0_Cursor(8, 0);
03E0  3008  	MOVLW 0x08
03E1  00B3  	MOVWF FCD_LCDDis_00055_arg_x
03E2  01B4  	CLRF FCD_LCDDis_00055_arg_y
03E3  224B  	CALL FCD_LCDDis_00055


		//Call Component Macro
		//Call Component Macro: PrintString("NO")
		FCD_LCDDisplay0_PrintString("NO", 2);
03E4  304E  	MOVLW 0x4E
03E5  00B5  	MOVWF CompTempVar2203
03E6  304F  	MOVLW 0x4F
03E7  00B6  	MOVWF CompTempVar2203+D'1'
03E8  01B7  	CLRF CompTempVar2203+D'2'
03E9  3000  	MOVLW HIGH(CompTempVar2203+D'0')
03EA  00B4  	MOVWF FCD_LCDDis_0005A_arg_String+D'1'
03EB  30B5  	MOVLW LOW(CompTempVar2203+D'0')
03EC  00B3  	MOVWF FCD_LCDDis_0005A_arg_String
03ED  3002  	MOVLW 0x02
03EE  00C0  	MOVWF FCD_LCDDis_0005A_arg_MSZ_String
03EF  2218  	CALL FCD_LCDDis_0005A


		//Loop
		//Loop: While keypad_read = 3
		while (1)
03F0        label68
043F  2BF0  	GOTO	label68
0440        label74

		{

			//Call Component Macro
			//Call Component Macro: keypad_read=GetKeypadNumber()
			FCV_KEYPAD_READ = FCD_KeyPad0_GetKeypadNumber();
03F0  2269  	CALL FCD_KeyPad_00058
03F1  083B  	MOVF CompTempVarRet2249, W
03F2  00A3  	MOVWF gbl_FCV_KEYPAD_READ


			//Switch
			//Switch: keypad_read?
			switch (FCV_KEYPAD_READ)
03FC  2C38  	GOTO	label73

			{
				case 6:
03F3  0823  	MOVF gbl_FCV_KEYPAD_READ, W
03F4  3A06  	XORLW 0x06
03F5  118A  	BCF PCLATH,3
03F6  120A  	BCF PCLATH,4
03F7  1903  	BTFSC STATUS,Z
03F8  2BFD  	GOTO	label69
03FD        label69

				{
					//Loop
					//Loop: While keypad_read = 6
					while (FCV_KEYPAD_READ == 6)
03FD  0823  	MOVF gbl_FCV_KEYPAD_READ, W
03FE  3A06  	XORLW 0x06
03FF  1D03  	BTFSS STATUS,Z
0400  2C07  	GOTO	label70
0404  118A  	BCF PCLATH,3
0405  120A  	BCF PCLATH,4
0406  2BFD  	GOTO	label69
0407        label70

					{

						//Call Component Macro
						//Call Component Macro: keypad_read=GetKeypadNumber()
						FCV_KEYPAD_READ = FCD_KeyPad0_GetKeypadNumber();
0401  2269  	CALL FCD_KeyPad_00058
0402  083B  	MOVF CompTempVarRet2249, W
0403  00A3  	MOVWF gbl_FCV_KEYPAD_READ



					}

					//Call Component Macro
					//Call Component Macro: Cursor(8, 0)
					FCD_LCDDisplay0_Cursor(8, 0);
0407  3008  	MOVLW 0x08
0408  00B3  	MOVWF FCD_LCDDis_00055_arg_x
0409  01B4  	CLRF FCD_LCDDis_00055_arg_y
040A  224B  	CALL FCD_LCDDis_00055


					//Call Component Macro
					//Call Component Macro: PrintString("YES")
					FCD_LCDDisplay0_PrintString("YES", 3);
040B  3059  	MOVLW 0x59
040C  00B5  	MOVWF CompTempVar2206
040D  3045  	MOVLW 0x45
040E  00B6  	MOVWF CompTempVar2206+D'1'
040F  3053  	MOVLW 0x53
0410  00B7  	MOVWF CompTempVar2206+D'2'
0411  01B8  	CLRF CompTempVar2206+D'3'
0412  3000  	MOVLW HIGH(CompTempVar2206+D'0')
0413  00B4  	MOVWF FCD_LCDDis_0005A_arg_String+D'1'
0414  30B5  	MOVLW LOW(CompTempVar2206+D'0')
0415  00B3  	MOVWF FCD_LCDDis_0005A_arg_String
0416  3003  	MOVLW 0x03
0417  00C0  	MOVWF FCD_LCDDis_0005A_arg_MSZ_String
0418  2218  	CALL FCD_LCDDis_0005A


					//Calculation
					//Calculation:
					//  scroll = 1
					FCV_SCROLL = 1;
0419  1525  	BSF gbl_FCV_SCROLL,2


					break;
041A  2C38  	GOTO	label73

				}
				case 9:
03F9  3A0F  	XORLW 0x0F
03FA  1903  	BTFSC STATUS,Z
03FB  2C1B  	GOTO	label71
041B        label71

				{
					//Loop
					//Loop: While keypad_read = 9
					while (FCV_KEYPAD_READ == 9)
041B  0823  	MOVF gbl_FCV_KEYPAD_READ, W
041C  3A09  	XORLW 0x09
041D  1D03  	BTFSS STATUS,Z
041E  2C25  	GOTO	label72
0422  118A  	BCF PCLATH,3
0423  120A  	BCF PCLATH,4
0424  2C1B  	GOTO	label71
0425        label72

					{

						//Call Component Macro
						//Call Component Macro: keypad_read=GetKeypadNumber()
						FCV_KEYPAD_READ = FCD_KeyPad0_GetKeypadNumber();
041F  2269  	CALL FCD_KeyPad_00058
0420  083B  	MOVF CompTempVarRet2249, W
0421  00A3  	MOVWF gbl_FCV_KEYPAD_READ



					}

					//Call Component Macro
					//Call Component Macro: Cursor(8, 0)
					FCD_LCDDisplay0_Cursor(8, 0);
0425  3008  	MOVLW 0x08
0426  00B3  	MOVWF FCD_LCDDis_00055_arg_x
0427  01B4  	CLRF FCD_LCDDis_00055_arg_y
0428  224B  	CALL FCD_LCDDis_00055


					//Call Component Macro
					//Call Component Macro: PrintString("NO ")
					FCD_LCDDisplay0_PrintString("NO ", 3);
0429  304E  	MOVLW 0x4E
042A  00B5  	MOVWF CompTempVar2208
042B  304F  	MOVLW 0x4F
042C  00B6  	MOVWF CompTempVar2208+D'1'
042D  3020  	MOVLW 0x20
042E  00B7  	MOVWF CompTempVar2208+D'2'
042F  01B8  	CLRF CompTempVar2208+D'3'
0430  3000  	MOVLW HIGH(CompTempVar2208+D'0')
0431  00B4  	MOVWF FCD_LCDDis_0005A_arg_String+D'1'
0432  30B5  	MOVLW LOW(CompTempVar2208+D'0')
0433  00B3  	MOVWF FCD_LCDDis_0005A_arg_String
0434  3003  	MOVLW 0x03
0435  00C0  	MOVWF FCD_LCDDis_0005A_arg_MSZ_String
0436  2218  	CALL FCD_LCDDis_0005A


					//Calculation
					//Calculation:
					//  scroll = 0
					FCV_SCROLL = 0;
0437  1125  	BCF gbl_FCV_SCROLL,2


					break;

				}
				// default:

			}


			if ((FCV_KEYPAD_READ == 3) != 0) break;
0438  01B2  	CLRF CompTempVar2205
0439  3003  	MOVLW 0x03
043A  0223  	SUBWF gbl_FCV_KEYPAD_READ, W
043B  1903  	BTFSC STATUS,Z
043C  0AB2  	INCF CompTempVar2205, F
043D  08B2  	MOVF CompTempVar2205, F
043E  1903  	BTFSC STATUS,Z

		}

		//Loop
		//Loop: While keypad_read = 3
		while (FCV_KEYPAD_READ == 3)
0440  0823  	MOVF gbl_FCV_KEYPAD_READ, W
0441  3A03  	XORLW 0x03
0442  1D03  	BTFSS STATUS,Z
0443  2C4A  	GOTO	label75
0447  118A  	BCF PCLATH,3
0448  120A  	BCF PCLATH,4
0449  2C40  	GOTO	label74
044A        label75

		{

			//Call Component Macro
			//Call Component Macro: keypad_read=GetKeypadNumber()
			FCV_KEYPAD_READ = FCD_KeyPad0_GetKeypadNumber();
0444  2269  	CALL FCD_KeyPad_00058
0445  083B  	MOVF CompTempVarRet2249, W
0446  00A3  	MOVWF gbl_FCV_KEYPAD_READ



		}

		//Call Component Macro
		//Call Component Macro: Clear()
		FCD_LCDDisplay0_Clear();
044A  2234  	CALL FCD_LCDDis_00059


		//Call Component Macro
		//Call Component Macro: Cursor(0, 0)
		FCD_LCDDisplay0_Cursor(0, 0);
044B  01B3  	CLRF FCD_LCDDis_00055_arg_x
044C  01B4  	CLRF FCD_LCDDis_00055_arg_y
044D  224B  	CALL FCD_LCDDis_00055


		//Call Component Macro
		//Call Component Macro: PrintString("SENDING...")
		FCD_LCDDisplay0_PrintString("SENDING...", 10);
044E  302E  	MOVLW 0x2E
044F  00BC  	MOVWF CompTempVar2210+D'7'
0450  00BD  	MOVWF CompTempVar2210+D'8'
0451  00BE  	MOVWF CompTempVar2210+D'9'
0452  3044  	MOVLW 0x44
0453  00B8  	MOVWF CompTempVar2210+D'3'
0454  3045  	MOVLW 0x45
0455  00B6  	MOVWF CompTempVar2210+D'1'
0456  3047  	MOVLW 0x47
0457  00BB  	MOVWF CompTempVar2210+D'6'
0458  3049  	MOVLW 0x49
0459  00B9  	MOVWF CompTempVar2210+D'4'
045A  304E  	MOVLW 0x4E
045B  00B7  	MOVWF CompTempVar2210+D'2'
045C  00BA  	MOVWF CompTempVar2210+D'5'
045D  3053  	MOVLW 0x53
045E  00B5  	MOVWF CompTempVar2210
045F  01BF  	CLRF CompTempVar2210+D'10'
0460  3000  	MOVLW HIGH(CompTempVar2210+D'0')
0461  00B4  	MOVWF FCD_LCDDis_0005A_arg_String+D'1'
0462  30B5  	MOVLW LOW(CompTempVar2210+D'0')
0463  00B3  	MOVWF FCD_LCDDis_0005A_arg_String
0464  300A  	MOVLW 0x0A
0465  00C0  	MOVWF FCD_LCDDis_0005A_arg_MSZ_String
0466  2218  	CALL FCD_LCDDis_0005A


		//Loop
		//Loop: Loop 3 times
		for (FCLV_LOOP4=0; FCLV_LOOP4<3; FCLV_LOOP4++)
0467  01AC  	CLRF gbl_FCLV_LOOP4
0468        label76
0468  3003  	MOVLW 0x03
0469  022C  	SUBWF gbl_FCLV_LOOP4, W
046A  1803  	BTFSC STATUS,C
046B  2C6F  	GOTO	label77
046D  0AAC  	INCF gbl_FCLV_LOOP4, F
046E  2C68  	GOTO	label76
046F        label77

		{

			//Call Macro
			//Call Macro: sendtocpu()
			FCM_sendtocpu();
046C  2136  	CALL FCM_sendto_0005B



		}

		//Call Component Macro
		//Call Component Macro: Clear()
		FCD_LCDDisplay0_Clear();
046F  2234  	CALL FCD_LCDDis_00059


	// } else {

	}

	//Decision
	//Decision: keypad_read = 1?
	if (FCV_KEYPAD_READ == 1)
0470  0323  	DECF gbl_FCV_KEYPAD_READ, W
0471  1D03  	BTFSS STATUS,Z
0472  2C7E  	GOTO	label81
0473        label79
047E        label81

	{

		//Loop
		//Loop: While keypad_read = 1
		while (FCV_KEYPAD_READ == 1)
0473  0323  	DECF gbl_FCV_KEYPAD_READ, W
0474  1D03  	BTFSS STATUS,Z
0475  2C7C  	GOTO	label80
0479  118A  	BCF PCLATH,3
047A  120A  	BCF PCLATH,4
047B  2C73  	GOTO	label79
047C        label80

		{

			//Call Component Macro
			//Call Component Macro: keypad_read=GetKeypadNumber()
			FCV_KEYPAD_READ = FCD_KeyPad0_GetKeypadNumber();
0476  2269  	CALL FCD_KeyPad_00058
0477  083B  	MOVF CompTempVarRet2249, W
0478  00A3  	MOVWF gbl_FCV_KEYPAD_READ



		}

		//Calculation
		//Calculation:
		//  next_idx = next_idx + 1
		FCV_NEXT_IDX = FCV_NEXT_IDX + 1;
047C  0A26  	INCF gbl_FCV_NEXT_IDX, W
047D  00A6  	MOVWF gbl_FCV_NEXT_IDX


	// } else {

	}

	//Decision
	//Decision: keypad_read = 5?
	if (FCV_KEYPAD_READ == 5)
047E  0823  	MOVF gbl_FCV_KEYPAD_READ, W
047F  3A05  	XORLW 0x05
0480  1D03  	BTFSS STATUS,Z
0481  2CC6  	GOTO	label86
0482        label82

	{

		//Loop
		//Loop: While keypad_read = 5
		while (FCV_KEYPAD_READ == 5)
0482  0823  	MOVF gbl_FCV_KEYPAD_READ, W
0483  3A05  	XORLW 0x05
0484  1D03  	BTFSS STATUS,Z
0485  2C8C  	GOTO	label83
0489  118A  	BCF PCLATH,3
048A  120A  	BCF PCLATH,4
048B  2C82  	GOTO	label82
048C        label83

		{

			//Call Component Macro
			//Call Component Macro: keypad_read=GetKeypadNumber()
			FCV_KEYPAD_READ = FCD_KeyPad0_GetKeypadNumber();
0486  2269  	CALL FCD_KeyPad_00058
0487  083B  	MOVF CompTempVarRet2249, W
0488  00A3  	MOVWF gbl_FCV_KEYPAD_READ



		}

		//Calculation
		//Calculation:
		//  color[next_idx] = color[next_idx] + 1
		FCV_COLOR[FCV_NEXT_IDX] = FCV_COLOR[FCV_NEXT_IDX] + 1;
048C  1283  	BCF STATUS, RP0
048D  1383  	BCF	STATUS,IRP
048E  3040  	MOVLW LOW(gbl_FCV_COLOR+D'0')
048F  0084  	MOVWF FSR
0490  1683  	BSF STATUS, RP0
0491  0826  	MOVF gbl_FCV_NEXT_IDX, W
0492  0784  	ADDWF FSR, F
0493  0A00  	INCF INDF, W
0494  00B3  	MOVWF CompTempVar2217
0495  3040  	MOVLW LOW(gbl_FCV_COLOR+D'0')
0496  0084  	MOVWF FSR
0497  0826  	MOVF gbl_FCV_NEXT_IDX, W
0498  0784  	ADDWF FSR, F
0499  0833  	MOVF CompTempVar2217, W
049A  0080  	MOVWF INDF


		//Decision
		//Decision: color[next_idx] = 3?
		if (FCV_COLOR[FCV_NEXT_IDX] == 3)
049B  3040  	MOVLW LOW(gbl_FCV_COLOR+D'0')
049C  0084  	MOVWF FSR
049D  0826  	MOVF gbl_FCV_NEXT_IDX, W
049E  0784  	ADDWF FSR, F
049F  0800  	MOVF INDF, W
04A0  3A03  	XORLW 0x03
04A1  1D03  	BTFSS STATUS,Z
04A2  2CAC  	GOTO	label84
04AC        label84

		{

			//Calculation
			//Calculation:
			//  color[next_idx] = 0
			FCV_COLOR[FCV_NEXT_IDX] = 0;
04A3  1283  	BCF STATUS, RP0
04A4  1383  	BCF	STATUS,IRP
04A5  3040  	MOVLW LOW(gbl_FCV_COLOR+D'0')
04A6  0084  	MOVWF FSR
04A7  1683  	BSF STATUS, RP0
04A8  0826  	MOVF gbl_FCV_NEXT_IDX, W
04A9  0784  	ADDWF FSR, F
04AA  3000  	MOVLW 0x00
04AB  0080  	MOVWF INDF


		// } else {

		}

		//Switch
		//Switch: color[next_idx]?
		switch (FCV_COLOR[FCV_NEXT_IDX])
04AC  1283  	BCF STATUS, RP0
04AD  1383  	BCF	STATUS,IRP
04AE  3040  	MOVLW LOW(gbl_FCV_COLOR+D'0')
04AF  0084  	MOVWF FSR
04B0  1683  	BSF STATUS, RP0
04B1  0826  	MOVF gbl_FCV_NEXT_IDX, W
04B2  0784  	ADDWF FSR, F
04B3  0800  	MOVF INDF, W
04B4  00B2  	MOVWF CompTempVar2214
04BC  2CC6  	GOTO	label86

		{
			case 255:
04B5  0832  	MOVF CompTempVar2214, W
04B6  3AFF  	XORLW 0xFF
04B7  1903  	BTFSC STATUS,Z
04B8  2CBD  	GOTO	label85
04BD        label85

			{
				//Calculation
				//Calculation:
				//  color[next_idx] = 2
				FCV_COLOR[FCV_NEXT_IDX] = 2;
04BD  1283  	BCF STATUS, RP0
04BE  1383  	BCF	STATUS,IRP
04BF  3040  	MOVLW LOW(gbl_FCV_COLOR+D'0')
04C0  0084  	MOVWF FSR
04C1  1683  	BSF STATUS, RP0
04C2  0826  	MOVF gbl_FCV_NEXT_IDX, W
04C3  0784  	ADDWF FSR, F
04C4  3002  	MOVLW 0x02
04C5  0080  	MOVWF INDF


				break;

			}
			case 3:
04B9  3AFC  	XORLW 0xFC
04BA  1903  	BTFSC STATUS,Z
04BB  2CC6  	GOTO	label86

			{
				break;

			}
			// default:

		}

	// } else {

	}

	//Decision
	//Decision: keypad_read = 8?
	if (FCV_KEYPAD_READ == 8)
04C6  0823  	MOVF gbl_FCV_KEYPAD_READ, W
04C7  3A08  	XORLW 0x08
04C8  1D03  	BTFSS STATUS,Z
04C9  2CF3  	GOTO	label89
04CA        label87

	{

		//Loop
		//Loop: While keypad_read = 5
		while (FCV_KEYPAD_READ == 5)
04CA  0823  	MOVF gbl_FCV_KEYPAD_READ, W
04CB  3A05  	XORLW 0x05
04CC  1D03  	BTFSS STATUS,Z
04CD  2CD4  	GOTO	label88
04D1  118A  	BCF PCLATH,3
04D2  120A  	BCF PCLATH,4
04D3  2CCA  	GOTO	label87
04D4        label88

		{

			//Call Component Macro
			//Call Component Macro: keypad_read=GetKeypadNumber()
			FCV_KEYPAD_READ = FCD_KeyPad0_GetKeypadNumber();
04CE  2269  	CALL FCD_KeyPad_00058
04CF  083B  	MOVF CompTempVarRet2249, W
04D0  00A3  	MOVWF gbl_FCV_KEYPAD_READ



		}

		//Calculation
		//Calculation:
		//  color[next_idx] = color[next_idx] - 1
		FCV_COLOR[FCV_NEXT_IDX] = FCV_COLOR[FCV_NEXT_IDX] - 1;
04D4  1283  	BCF STATUS, RP0
04D5  1383  	BCF	STATUS,IRP
04D6  3040  	MOVLW LOW(gbl_FCV_COLOR+D'0')
04D7  0084  	MOVWF FSR
04D8  1683  	BSF STATUS, RP0
04D9  0826  	MOVF gbl_FCV_NEXT_IDX, W
04DA  0784  	ADDWF FSR, F
04DB  0300  	DECF INDF, W
04DC  00B2  	MOVWF CompTempVar2223
04DD  3040  	MOVLW LOW(gbl_FCV_COLOR+D'0')
04DE  0084  	MOVWF FSR
04DF  0826  	MOVF gbl_FCV_NEXT_IDX, W
04E0  0784  	ADDWF FSR, F
04E1  0832  	MOVF CompTempVar2223, W
04E2  0080  	MOVWF INDF


		//Decision
		//Decision: color[next_idx] = 255?
		if (FCV_COLOR[FCV_NEXT_IDX] == 255)
04E3  3040  	MOVLW LOW(gbl_FCV_COLOR+D'0')
04E4  0084  	MOVWF FSR
04E5  0826  	MOVF gbl_FCV_NEXT_IDX, W
04E6  0784  	ADDWF FSR, F
04E7  0A00  	INCF INDF, W
04E8  1D03  	BTFSS STATUS,Z
04E9  2CF3  	GOTO	label89
04F3        label89

		{

			//Calculation
			//Calculation:
			//  color[next_idx] = 2
			FCV_COLOR[FCV_NEXT_IDX] = 2;
04EA  1283  	BCF STATUS, RP0
04EB  1383  	BCF	STATUS,IRP
04EC  3040  	MOVLW LOW(gbl_FCV_COLOR+D'0')
04ED  0084  	MOVWF FSR
04EE  1683  	BSF STATUS, RP0
04EF  0826  	MOVF gbl_FCV_NEXT_IDX, W
04F0  0784  	ADDWF FSR, F
04F1  3002  	MOVLW 0x02
04F2  0080  	MOVWF INDF


		// } else {

		}

	// } else {

	}

	//Decision
	//Decision: keypad_read = 4?
	if (FCV_KEYPAD_READ == 4)
04F3  0823  	MOVF gbl_FCV_KEYPAD_READ, W
04F4  3A04  	XORLW 0x04
04F5  1D03  	BTFSS STATUS,Z
04F6  2D78  	GOTO	label97
04F7        label90

	{

		//Loop
		//Loop: While keypad_read = 4
		while (FCV_KEYPAD_READ == 4)
04F7  0823  	MOVF gbl_FCV_KEYPAD_READ, W
04F8  3A04  	XORLW 0x04
04F9  1D03  	BTFSS STATUS,Z
04FA  2D01  	GOTO	label91
04FE  118A  	BCF PCLATH,3
04FF  120A  	BCF PCLATH,4
0500  2CF7  	GOTO	label90
0501        label91

		{

			//Call Component Macro
			//Call Component Macro: keypad_read=GetKeypadNumber()
			FCV_KEYPAD_READ = FCD_KeyPad0_GetKeypadNumber();
04FB  2269  	CALL FCD_KeyPad_00058
04FC  083B  	MOVF CompTempVarRet2249, W
04FD  00A3  	MOVWF gbl_FCV_KEYPAD_READ



		}

		//Decision
		//Decision: char[next_idx] = 255?
		if (FCV_CHAR[FCV_NEXT_IDX] == 255)
0501  1283  	BCF STATUS, RP0
0502  1383  	BCF	STATUS,IRP
0503  3020  	MOVLW LOW(gbl_FCV_CHAR+D'0')
0504  0084  	MOVWF FSR
0505  1683  	BSF STATUS, RP0
0506  0826  	MOVF gbl_FCV_NEXT_IDX, W
0507  0784  	ADDWF FSR, F
0508  0A00  	INCF INDF, W
0509  1D03  	BTFSS STATUS,Z
050A  2D15  	GOTO	label92
0515        label92

		{

			//Calculation
			//Calculation:
			//  char[next_idx] = 65
			FCV_CHAR[FCV_NEXT_IDX] = 65;
050B  1283  	BCF STATUS, RP0
050C  1383  	BCF	STATUS,IRP
050D  3020  	MOVLW LOW(gbl_FCV_CHAR+D'0')
050E  0084  	MOVWF FSR
050F  1683  	BSF STATUS, RP0
0510  0826  	MOVF gbl_FCV_NEXT_IDX, W
0511  0784  	ADDWF FSR, F
0512  3041  	MOVLW 0x41
0513  0080  	MOVWF INDF


		} else {
0514  2D78  	GOTO	label97


			//Decision
			//Decision: char[next_idx] = 122?
			if (FCV_CHAR[FCV_NEXT_IDX] == 122)
0515  1283  	BCF STATUS, RP0
0516  1383  	BCF	STATUS,IRP
0517  3020  	MOVLW LOW(gbl_FCV_CHAR+D'0')
0518  0084  	MOVWF FSR
0519  1683  	BSF STATUS, RP0
051A  0826  	MOVF gbl_FCV_NEXT_IDX, W
051B  0784  	ADDWF FSR, F
051C  0800  	MOVF INDF, W
051D  3A7A  	XORLW 0x7A
051E  1D03  	BTFSS STATUS,Z
051F  2D2A  	GOTO	label93
052A        label93

			{

				//Calculation
				//Calculation:
				//  char[next_idx] = 48
				FCV_CHAR[FCV_NEXT_IDX] = 48;
0520  1283  	BCF STATUS, RP0
0521  1383  	BCF	STATUS,IRP
0522  3020  	MOVLW LOW(gbl_FCV_CHAR+D'0')
0523  0084  	MOVWF FSR
0524  1683  	BSF STATUS, RP0
0525  0826  	MOVF gbl_FCV_NEXT_IDX, W
0526  0784  	ADDWF FSR, F
0527  3030  	MOVLW 0x30
0528  0080  	MOVWF INDF


			} else {
0529  2D78  	GOTO	label97


				//Decision
				//Decision: char[next_idx] = 90?
				if (FCV_CHAR[FCV_NEXT_IDX] == 90)
052A  1283  	BCF STATUS, RP0
052B  1383  	BCF	STATUS,IRP
052C  3020  	MOVLW LOW(gbl_FCV_CHAR+D'0')
052D  0084  	MOVWF FSR
052E  1683  	BSF STATUS, RP0
052F  0826  	MOVF gbl_FCV_NEXT_IDX, W
0530  0784  	ADDWF FSR, F
0531  0800  	MOVF INDF, W
0532  3A5A  	XORLW 0x5A
0533  1D03  	BTFSS STATUS,Z
0534  2D3F  	GOTO	label94
053F        label94

				{

					//Calculation
					//Calculation:
					//  char[next_idx] = 97
					FCV_CHAR[FCV_NEXT_IDX] = 97;
0535  1283  	BCF STATUS, RP0
0536  1383  	BCF	STATUS,IRP
0537  3020  	MOVLW LOW(gbl_FCV_CHAR+D'0')
0538  0084  	MOVWF FSR
0539  1683  	BSF STATUS, RP0
053A  0826  	MOVF gbl_FCV_NEXT_IDX, W
053B  0784  	ADDWF FSR, F
053C  3061  	MOVLW 0x61
053D  0080  	MOVWF INDF


				} else {
053E  2D78  	GOTO	label97


					//Decision
					//Decision: char[next_idx] = 59?
					if (FCV_CHAR[FCV_NEXT_IDX] == 59)
053F  1283  	BCF STATUS, RP0
0540  1383  	BCF	STATUS,IRP
0541  3020  	MOVLW LOW(gbl_FCV_CHAR+D'0')
0542  0084  	MOVWF FSR
0543  1683  	BSF STATUS, RP0
0544  0826  	MOVF gbl_FCV_NEXT_IDX, W
0545  0784  	ADDWF FSR, F
0546  0800  	MOVF INDF, W
0547  3A3B  	XORLW 0x3B
0548  1D03  	BTFSS STATUS,Z
0549  2D54  	GOTO	label95
0554        label95

					{

						//Calculation
						//Calculation:
						//  char[next_idx] = 65
						FCV_CHAR[FCV_NEXT_IDX] = 65;
054A  1283  	BCF STATUS, RP0
054B  1383  	BCF	STATUS,IRP
054C  3020  	MOVLW LOW(gbl_FCV_CHAR+D'0')
054D  0084  	MOVWF FSR
054E  1683  	BSF STATUS, RP0
054F  0826  	MOVF gbl_FCV_NEXT_IDX, W
0550  0784  	ADDWF FSR, F
0551  3041  	MOVLW 0x41
0552  0080  	MOVWF INDF


					} else {
0553  2D78  	GOTO	label97


						//Decision
						//Decision: char[next_idx] = 64?
						if (FCV_CHAR[FCV_NEXT_IDX] == 64)
0554  1283  	BCF STATUS, RP0
0555  1383  	BCF	STATUS,IRP
0556  3020  	MOVLW LOW(gbl_FCV_CHAR+D'0')
0557  0084  	MOVWF FSR
0558  1683  	BSF STATUS, RP0
0559  0826  	MOVF gbl_FCV_NEXT_IDX, W
055A  0784  	ADDWF FSR, F
055B  0800  	MOVF INDF, W
055C  3A40  	XORLW 0x40
055D  1D03  	BTFSS STATUS,Z
055E  2D69  	GOTO	label96
0569        label96

						{

							//Calculation
							//Calculation:
							//  char[next_idx] = 32
							FCV_CHAR[FCV_NEXT_IDX] = 32;
055F  1283  	BCF STATUS, RP0
0560  1383  	BCF	STATUS,IRP
0561  3020  	MOVLW LOW(gbl_FCV_CHAR+D'0')
0562  0084  	MOVWF FSR
0563  1683  	BSF STATUS, RP0
0564  0826  	MOVF gbl_FCV_NEXT_IDX, W
0565  0784  	ADDWF FSR, F
0566  3020  	MOVLW 0x20
0567  0080  	MOVWF INDF


						} else {
0568  2D78  	GOTO	label97
0578        label97


							//Calculation
							//Calculation:
							//  char[next_idx] = char[next_idx] + 1
							FCV_CHAR[FCV_NEXT_IDX] = FCV_CHAR[FCV_NEXT_IDX] + 1;
0569  1283  	BCF STATUS, RP0
056A  1383  	BCF	STATUS,IRP
056B  3020  	MOVLW LOW(gbl_FCV_CHAR+D'0')
056C  0084  	MOVWF FSR
056D  1683  	BSF STATUS, RP0
056E  0826  	MOVF gbl_FCV_NEXT_IDX, W
056F  0784  	ADDWF FSR, F
0570  0A00  	INCF INDF, W
0571  00B2  	MOVWF CompTempVar2237
0572  3020  	MOVLW LOW(gbl_FCV_CHAR+D'0')
0573  0084  	MOVWF FSR
0574  0826  	MOVF gbl_FCV_NEXT_IDX, W
0575  0784  	ADDWF FSR, F
0576  0832  	MOVF CompTempVar2237, W
0577  0080  	MOVWF INDF


						}

					}

				}

			}

		}

	// } else {

	}

	//Decision
	//Decision: keypad_read = 7?
	if (FCV_KEYPAD_READ == 7)
0578  0823  	MOVF gbl_FCV_KEYPAD_READ, W
0579  3A07  	XORLW 0x07
057A  1D03  	BTFSS STATUS,Z

	{

		//Loop
		//Loop: While keypad_read = 7
		while (FCV_KEYPAD_READ == 7)
057C  0823  	MOVF gbl_FCV_KEYPAD_READ, W
057D  3A07  	XORLW 0x07
057E  1D03  	BTFSS STATUS,Z
057F  2D86  	GOTO	label99
0583  118A  	BCF PCLATH,3
0584  120A  	BCF PCLATH,4
0585  2D7C  	GOTO	label98
0586        label99

		{

			//Call Component Macro
			//Call Component Macro: keypad_read=GetKeypadNumber()
			FCV_KEYPAD_READ = FCD_KeyPad0_GetKeypadNumber();
0580  2269  	CALL FCD_KeyPad_00058
0581  083B  	MOVF CompTempVarRet2249, W
0582  00A3  	MOVWF gbl_FCV_KEYPAD_READ



		}

		//Decision
		//Decision: char[next_idx] = 255?
		if (FCV_CHAR[FCV_NEXT_IDX] == 255)
0586  1283  	BCF STATUS, RP0
0587  1383  	BCF	STATUS,IRP
0588  3020  	MOVLW LOW(gbl_FCV_CHAR+D'0')
0589  0084  	MOVWF FSR
058A  1683  	BSF STATUS, RP0
058B  0826  	MOVF gbl_FCV_NEXT_IDX, W
058C  0784  	ADDWF FSR, F
058D  0A00  	INCF INDF, W
058E  1D03  	BTFSS STATUS,Z
058F  2D9A  	GOTO	label100
059A        label100

		{

			//Calculation
			//Calculation:
			//  char[next_idx] = 65
			FCV_CHAR[FCV_NEXT_IDX] = 65;
0590  1283  	BCF STATUS, RP0
0591  1383  	BCF	STATUS,IRP
0592  3020  	MOVLW LOW(gbl_FCV_CHAR+D'0')
0593  0084  	MOVWF FSR
0594  1683  	BSF STATUS, RP0
0595  0826  	MOVF gbl_FCV_NEXT_IDX, W
0596  0784  	ADDWF FSR, F
0597  3041  	MOVLW 0x41
0598  0080  	MOVWF INDF


		} else {

			//Decision
			//Decision: char[next_idx] = 122?
			if (FCV_CHAR[FCV_NEXT_IDX] == 122)
059A  1283  	BCF STATUS, RP0
059B  1383  	BCF	STATUS,IRP
059C  3020  	MOVLW LOW(gbl_FCV_CHAR+D'0')
059D  0084  	MOVWF FSR
059E  1683  	BSF STATUS, RP0
059F  0826  	MOVF gbl_FCV_NEXT_IDX, W
05A0  0784  	ADDWF FSR, F
05A1  0800  	MOVF INDF, W
05A2  3A7A  	XORLW 0x7A
05A3  1D03  	BTFSS STATUS,Z
05A4  2DAF  	GOTO	label101
05AF        label101

			{

				//Calculation
				//Calculation:
				//  char[next_idx] = 48
				FCV_CHAR[FCV_NEXT_IDX] = 48;
05A5  1283  	BCF STATUS, RP0
05A6  1383  	BCF	STATUS,IRP
05A7  3020  	MOVLW LOW(gbl_FCV_CHAR+D'0')
05A8  0084  	MOVWF FSR
05A9  1683  	BSF STATUS, RP0
05AA  0826  	MOVF gbl_FCV_NEXT_IDX, W
05AB  0784  	ADDWF FSR, F
05AC  3030  	MOVLW 0x30
05AD  0080  	MOVWF INDF


			} else {

				//Decision
				//Decision: char[next_idx] = 90?
				if (FCV_CHAR[FCV_NEXT_IDX] == 90)
05AF  1283  	BCF STATUS, RP0
05B0  1383  	BCF	STATUS,IRP
05B1  3020  	MOVLW LOW(gbl_FCV_CHAR+D'0')
05B2  0084  	MOVWF FSR
05B3  1683  	BSF STATUS, RP0
05B4  0826  	MOVF gbl_FCV_NEXT_IDX, W
05B5  0784  	ADDWF FSR, F
05B6  0800  	MOVF INDF, W
05B7  3A5A  	XORLW 0x5A
05B8  1D03  	BTFSS STATUS,Z
05B9  2DC4  	GOTO	label102
05C4        label102

				{

					//Calculation
					//Calculation:
					//  char[next_idx] = 97
					FCV_CHAR[FCV_NEXT_IDX] = 97;
05BA  1283  	BCF STATUS, RP0
05BB  1383  	BCF	STATUS,IRP
05BC  3020  	MOVLW LOW(gbl_FCV_CHAR+D'0')
05BD  0084  	MOVWF FSR
05BE  1683  	BSF STATUS, RP0
05BF  0826  	MOVF gbl_FCV_NEXT_IDX, W
05C0  0784  	ADDWF FSR, F
05C1  3061  	MOVLW 0x61
05C2  0080  	MOVWF INDF


				} else {

					//Decision
					//Decision: char[next_idx] = 65?
					if (FCV_CHAR[FCV_NEXT_IDX] == 65)
05C4  1283  	BCF STATUS, RP0
05C5  1383  	BCF	STATUS,IRP
05C6  3020  	MOVLW LOW(gbl_FCV_CHAR+D'0')
05C7  0084  	MOVWF FSR
05C8  1683  	BSF STATUS, RP0
05C9  0826  	MOVF gbl_FCV_NEXT_IDX, W
05CA  0784  	ADDWF FSR, F
05CB  0800  	MOVF INDF, W
05CC  3A41  	XORLW 0x41
05CD  1D03  	BTFSS STATUS,Z
05CE  2DD9  	GOTO	label103
05D9        label103

					{

						//Calculation
						//Calculation:
						//  char[next_idx] = 32
						FCV_CHAR[FCV_NEXT_IDX] = 32;
05CF  1283  	BCF STATUS, RP0
05D0  1383  	BCF	STATUS,IRP
05D1  3020  	MOVLW LOW(gbl_FCV_CHAR+D'0')
05D2  0084  	MOVWF FSR
05D3  1683  	BSF STATUS, RP0
05D4  0826  	MOVF gbl_FCV_NEXT_IDX, W
05D5  0784  	ADDWF FSR, F
05D6  3020  	MOVLW 0x20
05D7  0080  	MOVWF INDF


					} else {

						//Calculation
						//Calculation:
						//  char[next_idx] = char[next_idx] - 1
						FCV_CHAR[FCV_NEXT_IDX] = FCV_CHAR[FCV_NEXT_IDX] - 1;
05D9  1283  	BCF STATUS, RP0
05DA  1383  	BCF	STATUS,IRP
05DB  3020  	MOVLW LOW(gbl_FCV_CHAR+D'0')
05DC  0084  	MOVWF FSR
05DD  1683  	BSF STATUS, RP0
05DE  0826  	MOVF gbl_FCV_NEXT_IDX, W
05DF  0784  	ADDWF FSR, F
05E0  0300  	DECF INDF, W
05E1  00B2  	MOVWF CompTempVar2248
05E2  3020  	MOVLW LOW(gbl_FCV_CHAR+D'0')
05E3  0084  	MOVWF FSR
05E4  0826  	MOVF gbl_FCV_NEXT_IDX, W
05E5  0784  	ADDWF FSR, F
05E6  0832  	MOVF CompTempVar2248, W
05E7  0080  	MOVWF INDF


					}

				}

			}

		}

	// } else {

	}

}
057B  0008  	RETURN
057C        label98
0599  0008  	RETURN
05AE  0008  	RETURN
05C3  0008  	RETURN
05D8  0008  	RETURN
05E8  0008  	RETURN



void FCM_clr_color()

{

	//Calculation
	//Calculation:
	//  wrreg_temp = 0
	FCV_WRREG_TEMP = 0;
05E9  1683  	BSF STATUS, RP0
05EA  1303  	BCF STATUS, RP1
05EB  01A8  	CLRF gbl_FCV_WRREG_TEMP


	//Loop
	//Loop: Loop 32 times
	for (FCLV_LOOP5=0; FCLV_LOOP5<32; FCLV_LOOP5++)
05EC  01AD  	CLRF gbl_FCLV_LOOP5
05ED        label104
05ED  3020  	MOVLW 0x20
05EE  022D  	SUBWF gbl_FCLV_LOOP5, W
05EF  1803  	BTFSC STATUS,C
05FC  0AAD  	INCF gbl_FCLV_LOOP5, F
05FD  2DED  	GOTO	label104

	{

		//Calculation
		//Calculation:
		//  color[wrreg_temp] = 0
		FCV_COLOR[FCV_WRREG_TEMP] = 0;
05F1  1283  	BCF STATUS, RP0
05F2  1383  	BCF	STATUS,IRP
05F3  3040  	MOVLW LOW(gbl_FCV_COLOR+D'0')
05F4  0084  	MOVWF FSR
05F5  1683  	BSF STATUS, RP0
05F6  0828  	MOVF gbl_FCV_WRREG_TEMP, W
05F7  0784  	ADDWF FSR, F
05F8  3000  	MOVLW 0x00
05F9  0080  	MOVWF INDF


		//Calculation
		//Calculation:
		//  wrreg_temp = wrreg_temp + 1
		FCV_WRREG_TEMP = FCV_WRREG_TEMP + 1;
05FA  0A28  	INCF gbl_FCV_WRREG_TEMP, W
05FB  00A8  	MOVWF gbl_FCV_WRREG_TEMP



	}

}
05F0  0008  	RETURN



void FCM_keypadtest()
{

	//Loop
	//Loop: While 1
	while (1)
	{

		//Call Component Macro
		//Call Component Macro: keypad_read=GetKeypadNumber()
		FCV_KEYPAD_READ = FCD_KeyPad0_GetKeypadNumber();

		//Decision
		//Decision: keypad_read = 255?
		if (FCV_KEYPAD_READ == 255)
		{

			//Call Component Macro
			//Call Component Macro: Cursor(0, 0)
			FCD_LCDDisplay0_Cursor(0, 0);

			//Call Component Macro
			//Call Component Macro: PrintNumber(keypad_read)
			FCD_LCDDisplay0_PrintNumber(FCV_KEYPAD_READ);

		} else {

			//Call Component Macro
			//Call Component Macro: Clear()
			FCD_LCDDisplay0_Clear();

			//Call Component Macro
			//Call Component Macro: Cursor(0, 0)
			FCD_LCDDisplay0_Cursor(0, 0);

			//Call Component Macro
			//Call Component Macro: PrintNumber(keypad_read)
			FCD_LCDDisplay0_PrintNumber(FCV_KEYPAD_READ);

			//Delay
			//Delay: 500 ms
			delay_ms(255);
			delay_ms(245);

		}


	}

}


void FCM_sendtocpu()

{

	//Calculation
	//Calculation:
	//  next_idx = 0
	//  wrreg_temp = 0
	FCV_NEXT_IDX = 0;
0136  1683  	BSF STATUS, RP0
0137  1303  	BCF STATUS, RP1
0138  01A6  	CLRF gbl_FCV_NEXT_IDX

	FCV_WRREG_TEMP = 0;
0139  01A8  	CLRF gbl_FCV_WRREG_TEMP


	//Calculation
	//Calculation:
	//  TX_CHAR = 170
	FCV_TX_CHAR = 170;
013A  30AA  	MOVLW 0xAA
013B  00A4  	MOVWF gbl_FCV_TX_CHAR


	//Call Component Macro
	//Call Component Macro: SendRS232Char(TX_CHAR)
	FCD_RS2320_SendRS232Char(FCV_TX_CHAR);
013C  0824  	MOVF gbl_FCV_TX_CHAR, W
013D  00B3  	MOVWF FCD_RS2320_00052_arg_nChar
013E  01B4  	CLRF FCD_RS2320_00052_arg_nChar+D'1'
013F  20C5  	CALL FCD_RS2320_00052


	//Delay
	//Delay: 5 ms
	delay_ms(5);
0140  3005  	MOVLW 0x05
0141  1683  	BSF STATUS, RP0
0142  00B7  	MOVWF delay_ms_00000_arg_del
0143  2010  	CALL delay_ms_00000


	//Decision
	//Decision: scroll = 1?
	if (FCV_SCROLL == 1)
0144  1D25  	BTFSS gbl_FCV_SCROLL,2
0145  2965  	GOTO	label26
0165        label26

	{

		//Calculation
		//Calculation:
		//  TX_CHAR = 160
		FCV_TX_CHAR = 160;
0146  30A0  	MOVLW 0xA0
0147  00A4  	MOVWF gbl_FCV_TX_CHAR


		//Call Component Macro
		//Call Component Macro: SendRS232Char(TX_CHAR)
		FCD_RS2320_SendRS232Char(FCV_TX_CHAR);
0148  0824  	MOVF gbl_FCV_TX_CHAR, W
0149  00B3  	MOVWF FCD_RS2320_00052_arg_nChar
014A  01B4  	CLRF FCD_RS2320_00052_arg_nChar+D'1'
014B  20C5  	CALL FCD_RS2320_00052


		//Delay
		//Delay: 5 ms
		delay_ms(5);
014C  3005  	MOVLW 0x05
014D  1683  	BSF STATUS, RP0
014E  00B7  	MOVWF delay_ms_00000_arg_del
014F  2010  	CALL delay_ms_00000


		//Calculation
		//Calculation:
		//  TX_CHAR = 127
		FCV_TX_CHAR = 127;
0150  307F  	MOVLW 0x7F
0151  00A4  	MOVWF gbl_FCV_TX_CHAR


		//Call Component Macro
		//Call Component Macro: SendRS232Char(TX_CHAR)
		FCD_RS2320_SendRS232Char(FCV_TX_CHAR);
0152  0824  	MOVF gbl_FCV_TX_CHAR, W
0153  00B3  	MOVWF FCD_RS2320_00052_arg_nChar
0154  01B4  	CLRF FCD_RS2320_00052_arg_nChar+D'1'
0155  20C5  	CALL FCD_RS2320_00052


		//Delay
		//Delay: 5 ms
		delay_ms(5);
0156  3005  	MOVLW 0x05
0157  1683  	BSF STATUS, RP0
0158  00B7  	MOVWF delay_ms_00000_arg_del
0159  2010  	CALL delay_ms_00000


		//Calculation
		//Calculation:
		//  TX_CHAR = 4
		FCV_TX_CHAR = 4;
015A  3004  	MOVLW 0x04
015B  00A4  	MOVWF gbl_FCV_TX_CHAR


		//Call Component Macro
		//Call Component Macro: SendRS232Char(TX_CHAR)
		FCD_RS2320_SendRS232Char(FCV_TX_CHAR);
015C  0824  	MOVF gbl_FCV_TX_CHAR, W
015D  00B3  	MOVWF FCD_RS2320_00052_arg_nChar
015E  01B4  	CLRF FCD_RS2320_00052_arg_nChar+D'1'
015F  20C5  	CALL FCD_RS2320_00052


		//Delay
		//Delay: 5 ms
		delay_ms(5);
0160  3005  	MOVLW 0x05
0161  1683  	BSF STATUS, RP0
0162  00B7  	MOVWF delay_ms_00000_arg_del
0163  2010  	CALL delay_ms_00000


	} else {
0164  2983  	GOTO	label27
0183        label27


		//Calculation
		//Calculation:
		//  TX_CHAR = 160
		FCV_TX_CHAR = 160;
0165  30A0  	MOVLW 0xA0
0166  00A4  	MOVWF gbl_FCV_TX_CHAR


		//Call Component Macro
		//Call Component Macro: SendRS232Char(TX_CHAR)
		FCD_RS2320_SendRS232Char(FCV_TX_CHAR);
0167  0824  	MOVF gbl_FCV_TX_CHAR, W
0168  00B3  	MOVWF FCD_RS2320_00052_arg_nChar
0169  01B4  	CLRF FCD_RS2320_00052_arg_nChar+D'1'
016A  20C5  	CALL FCD_RS2320_00052


		//Delay
		//Delay: 5 ms
		delay_ms(5);
016B  3005  	MOVLW 0x05
016C  1683  	BSF STATUS, RP0
016D  00B7  	MOVWF delay_ms_00000_arg_del
016E  2010  	CALL delay_ms_00000


		//Calculation
		//Calculation:
		//  TX_CHAR = 1
		FCV_TX_CHAR = 1;
016F  3001  	MOVLW 0x01
0170  00A4  	MOVWF gbl_FCV_TX_CHAR


		//Call Component Macro
		//Call Component Macro: SendRS232Char(TX_CHAR)
		FCD_RS2320_SendRS232Char(FCV_TX_CHAR);
0171  0824  	MOVF gbl_FCV_TX_CHAR, W
0172  00B3  	MOVWF FCD_RS2320_00052_arg_nChar
0173  01B4  	CLRF FCD_RS2320_00052_arg_nChar+D'1'
0174  20C5  	CALL FCD_RS2320_00052


		//Delay
		//Delay: 5 ms
		delay_ms(5);
0175  3005  	MOVLW 0x05
0176  1683  	BSF STATUS, RP0
0177  00B7  	MOVWF delay_ms_00000_arg_del
0178  2010  	CALL delay_ms_00000


		//Calculation
		//Calculation:
		//  TX_CHAR = 4
		FCV_TX_CHAR = 4;
0179  3004  	MOVLW 0x04
017A  00A4  	MOVWF gbl_FCV_TX_CHAR


		//Call Component Macro
		//Call Component Macro: SendRS232Char(TX_CHAR)
		FCD_RS2320_SendRS232Char(FCV_TX_CHAR);
017B  0824  	MOVF gbl_FCV_TX_CHAR, W
017C  00B3  	MOVWF FCD_RS2320_00052_arg_nChar
017D  01B4  	CLRF FCD_RS2320_00052_arg_nChar+D'1'
017E  20C5  	CALL FCD_RS2320_00052


		//Delay
		//Delay: 5 ms
		delay_ms(5);
017F  3005  	MOVLW 0x05
0180  1683  	BSF STATUS, RP0
0181  00B7  	MOVWF delay_ms_00000_arg_del
0182  2010  	CALL delay_ms_00000


	}

	//Loop
	//Loop: While char[next_idx] = 255
	while (1)
01B0  2983  	GOTO	label27

	{

		//Calculation
		//Calculation:
		//  TX_CHAR = 162
		FCV_TX_CHAR = 162;
0183  30A2  	MOVLW 0xA2
0184  00A4  	MOVWF gbl_FCV_TX_CHAR


		//Call Component Macro
		//Call Component Macro: SendRS232Char(TX_CHAR)
		FCD_RS2320_SendRS232Char(FCV_TX_CHAR);
0185  0824  	MOVF gbl_FCV_TX_CHAR, W
0186  00B3  	MOVWF FCD_RS2320_00052_arg_nChar
0187  01B4  	CLRF FCD_RS2320_00052_arg_nChar+D'1'
0188  20C5  	CALL FCD_RS2320_00052


		//Delay
		//Delay: 5 ms
		delay_ms(5);
0189  3005  	MOVLW 0x05
018A  1683  	BSF STATUS, RP0
018B  00B7  	MOVWF delay_ms_00000_arg_del
018C  2010  	CALL delay_ms_00000


		//Calculation
		//Calculation:
		//  TX_CHAR = char[next_idx] - 65
		FCV_TX_CHAR = FCV_CHAR[FCV_NEXT_IDX] - 65;
018D  1283  	BCF STATUS, RP0
018E  1383  	BCF	STATUS,IRP
018F  3020  	MOVLW LOW(gbl_FCV_CHAR+D'0')
0190  0084  	MOVWF FSR
0191  1683  	BSF STATUS, RP0
0192  0826  	MOVF gbl_FCV_NEXT_IDX, W
0193  0784  	ADDWF FSR, F
0194  3041  	MOVLW 0x41
0195  0200  	SUBWF INDF, W
0196  00A4  	MOVWF gbl_FCV_TX_CHAR


		//Call Component Macro
		//Call Component Macro: SendRS232Char(TX_CHAR)
		FCD_RS2320_SendRS232Char(FCV_TX_CHAR);
0197  0824  	MOVF gbl_FCV_TX_CHAR, W
0198  00B3  	MOVWF FCD_RS2320_00052_arg_nChar
0199  01B4  	CLRF FCD_RS2320_00052_arg_nChar+D'1'
019A  20C5  	CALL FCD_RS2320_00052


		//Delay
		//Delay: 5 ms
		delay_ms(5);
019B  3005  	MOVLW 0x05
019C  1683  	BSF STATUS, RP0
019D  00B7  	MOVWF delay_ms_00000_arg_del
019E  2010  	CALL delay_ms_00000


		//Calculation
		//Calculation:
		//  next_idx = next_idx + 1
		FCV_NEXT_IDX = FCV_NEXT_IDX + 1;
019F  0A26  	INCF gbl_FCV_NEXT_IDX, W
01A0  00A6  	MOVWF gbl_FCV_NEXT_IDX


		//Calculation
		//Calculation:
		//  wrreg_temp = next_idx
		FCV_WRREG_TEMP = FCV_NEXT_IDX;
01A1  0826  	MOVF gbl_FCV_NEXT_IDX, W
01A2  00A8  	MOVWF gbl_FCV_WRREG_TEMP



		if ((FCV_CHAR[FCV_NEXT_IDX] == 255) != 0) break;
01A3  1283  	BCF STATUS, RP0
01A4  1383  	BCF	STATUS,IRP
01A5  3020  	MOVLW LOW(gbl_FCV_CHAR+D'0')
01A6  0084  	MOVWF FSR
01A7  1683  	BSF STATUS, RP0
01A8  0826  	MOVF gbl_FCV_NEXT_IDX, W
01A9  0784  	ADDWF FSR, F
01AA  01B2  	CLRF CompTempVar2279
01AB  0A00  	INCF INDF, W
01AC  1903  	BTFSC STATUS,Z
01AD  0AB2  	INCF CompTempVar2279, F
01AE  08B2  	MOVF CompTempVar2279, F
01AF  1903  	BTFSC STATUS,Z

	}

	//Calculation
	//Calculation:
	//  next_idx = 0
	FCV_NEXT_IDX = 0;
01B1  01A6  	CLRF gbl_FCV_NEXT_IDX


	//Loop
	//Loop: While wrreg_temp = 0
	while (1)
01B2        label28
01D8  29B2  	GOTO	label28

	{

		//Calculation
		//Calculation:
		//  TX_CHAR = 161
		FCV_TX_CHAR = 161;
01B2  30A1  	MOVLW 0xA1
01B3  00A4  	MOVWF gbl_FCV_TX_CHAR


		//Call Component Macro
		//Call Component Macro: SendRS232Char(TX_CHAR)
		FCD_RS2320_SendRS232Char(FCV_TX_CHAR);
01B4  0824  	MOVF gbl_FCV_TX_CHAR, W
01B5  00B3  	MOVWF FCD_RS2320_00052_arg_nChar
01B6  01B4  	CLRF FCD_RS2320_00052_arg_nChar+D'1'
01B7  20C5  	CALL FCD_RS2320_00052


		//Delay
		//Delay: 5 ms
		delay_ms(5);
01B8  3005  	MOVLW 0x05
01B9  1683  	BSF STATUS, RP0
01BA  00B7  	MOVWF delay_ms_00000_arg_del
01BB  2010  	CALL delay_ms_00000


		//Calculation
		//Calculation:
		//  TX_CHAR = color[next_idx]
		FCV_TX_CHAR = FCV_COLOR[FCV_NEXT_IDX];
01BC  1283  	BCF STATUS, RP0
01BD  1383  	BCF	STATUS,IRP
01BE  3040  	MOVLW LOW(gbl_FCV_COLOR+D'0')
01BF  0084  	MOVWF FSR
01C0  1683  	BSF STATUS, RP0
01C1  0826  	MOVF gbl_FCV_NEXT_IDX, W
01C2  0784  	ADDWF FSR, F
01C3  0800  	MOVF INDF, W
01C4  00A4  	MOVWF gbl_FCV_TX_CHAR


		//Call Component Macro
		//Call Component Macro: SendRS232Char(TX_CHAR)
		FCD_RS2320_SendRS232Char(FCV_TX_CHAR);
01C5  0824  	MOVF gbl_FCV_TX_CHAR, W
01C6  00B3  	MOVWF FCD_RS2320_00052_arg_nChar
01C7  01B4  	CLRF FCD_RS2320_00052_arg_nChar+D'1'
01C8  20C5  	CALL FCD_RS2320_00052


		//Delay
		//Delay: 5 ms
		delay_ms(5);
01C9  3005  	MOVLW 0x05
01CA  1683  	BSF STATUS, RP0
01CB  00B7  	MOVWF delay_ms_00000_arg_del
01CC  2010  	CALL delay_ms_00000


		//Calculation
		//Calculation:
		//  next_idx = next_idx + 1
		FCV_NEXT_IDX = FCV_NEXT_IDX + 1;
01CD  0A26  	INCF gbl_FCV_NEXT_IDX, W
01CE  00A6  	MOVWF gbl_FCV_NEXT_IDX


		//Calculation
		//Calculation:
		//  wrreg_temp = wrreg_temp - 1
		FCV_WRREG_TEMP = FCV_WRREG_TEMP - 1;
01CF  0328  	DECF gbl_FCV_WRREG_TEMP, W
01D0  00A8  	MOVWF gbl_FCV_WRREG_TEMP



		if ((FCV_WRREG_TEMP == 0) != 0) break;
01D1  01B2  	CLRF CompTempVar2281
01D2  0AB2  	INCF CompTempVar2281, F
01D3  08A8  	MOVF gbl_FCV_WRREG_TEMP, F
01D4  1D03  	BTFSS STATUS,Z
01D5  1032  	BCF CompTempVar2281,0
01D6  08B2  	MOVF CompTempVar2281, F
01D7  1903  	BTFSC STATUS,Z

	}

	//Decision
	//Decision: scroll = 1?
	if (FCV_SCROLL == 1)
01D9  1D25  	BTFSS gbl_FCV_SCROLL,2
01DA  29F0  	GOTO	label29
01F0        label29

	{

		//Calculation
		//Calculation:
		//  TX_CHAR = 163
		FCV_TX_CHAR = 163;
01DB  30A3  	MOVLW 0xA3
01DC  00A4  	MOVWF gbl_FCV_TX_CHAR


		//Call Component Macro
		//Call Component Macro: SendRS232Char(TX_CHAR)
		FCD_RS2320_SendRS232Char(FCV_TX_CHAR);
01DD  0824  	MOVF gbl_FCV_TX_CHAR, W
01DE  00B3  	MOVWF FCD_RS2320_00052_arg_nChar
01DF  01B4  	CLRF FCD_RS2320_00052_arg_nChar+D'1'
01E0  20C5  	CALL FCD_RS2320_00052


		//Delay
		//Delay: 5 ms
		delay_ms(5);
01E1  3005  	MOVLW 0x05
01E2  1683  	BSF STATUS, RP0
01E3  00B7  	MOVWF delay_ms_00000_arg_del
01E4  2010  	CALL delay_ms_00000


		//Calculation
		//Calculation:
		//  TX_CHAR = 1
		FCV_TX_CHAR = 1;
01E5  3001  	MOVLW 0x01
01E6  00A4  	MOVWF gbl_FCV_TX_CHAR


		//Call Component Macro
		//Call Component Macro: SendRS232Char(TX_CHAR)
		FCD_RS2320_SendRS232Char(FCV_TX_CHAR);
01E7  0824  	MOVF gbl_FCV_TX_CHAR, W
01E8  00B3  	MOVWF FCD_RS2320_00052_arg_nChar
01E9  01B4  	CLRF FCD_RS2320_00052_arg_nChar+D'1'
01EA  20C5  	CALL FCD_RS2320_00052


		//Delay
		//Delay: 5 ms
		delay_ms(5);
01EB  3005  	MOVLW 0x05
01EC  1683  	BSF STATUS, RP0
01ED  00B7  	MOVWF delay_ms_00000_arg_del
01EE  2010  	CALL delay_ms_00000


	} else {
01EF  2A03  	GOTO	label30
0203        label30


		//Calculation
		//Calculation:
		//  TX_CHAR = 163
		FCV_TX_CHAR = 163;
01F0  30A3  	MOVLW 0xA3
01F1  00A4  	MOVWF gbl_FCV_TX_CHAR


		//Call Component Macro
		//Call Component Macro: SendRS232Char(TX_CHAR)
		FCD_RS2320_SendRS232Char(FCV_TX_CHAR);
01F2  0824  	MOVF gbl_FCV_TX_CHAR, W
01F3  00B3  	MOVWF FCD_RS2320_00052_arg_nChar
01F4  01B4  	CLRF FCD_RS2320_00052_arg_nChar+D'1'
01F5  20C5  	CALL FCD_RS2320_00052


		//Delay
		//Delay: 5 ms
		delay_ms(5);
01F6  3005  	MOVLW 0x05
01F7  1683  	BSF STATUS, RP0
01F8  00B7  	MOVWF delay_ms_00000_arg_del
01F9  2010  	CALL delay_ms_00000


		//Calculation
		//Calculation:
		//  TX_CHAR = 0
		FCV_TX_CHAR = 0;
01FA  01A4  	CLRF gbl_FCV_TX_CHAR


		//Call Component Macro
		//Call Component Macro: SendRS232Char(TX_CHAR)
		FCD_RS2320_SendRS232Char(FCV_TX_CHAR);
01FB  0824  	MOVF gbl_FCV_TX_CHAR, W
01FC  00B3  	MOVWF FCD_RS2320_00052_arg_nChar
01FD  01B4  	CLRF FCD_RS2320_00052_arg_nChar+D'1'
01FE  20C5  	CALL FCD_RS2320_00052


		//Delay
		//Delay: 5 ms
		delay_ms(5);
01FF  3005  	MOVLW 0x05
0200  1683  	BSF STATUS, RP0
0201  00B7  	MOVWF delay_ms_00000_arg_del
0202  2010  	CALL delay_ms_00000


	}

	//Calculation
	//Calculation:
	//  TX_CHAR = 254
	FCV_TX_CHAR = 254;
0203  30FE  	MOVLW 0xFE
0204  00A4  	MOVWF gbl_FCV_TX_CHAR


	//Call Component Macro
	//Call Component Macro: SendRS232Char(TX_CHAR)
	FCD_RS2320_SendRS232Char(FCV_TX_CHAR);
0205  0824  	MOVF gbl_FCV_TX_CHAR, W
0206  00B3  	MOVWF FCD_RS2320_00052_arg_nChar
0207  01B4  	CLRF FCD_RS2320_00052_arg_nChar+D'1'
0208  20C5  	CALL FCD_RS2320_00052


	//Delay
	//Delay: 5 ms
	delay_ms(5);
0209  3005  	MOVLW 0x05
020A  1683  	BSF STATUS, RP0
020B  00B7  	MOVWF delay_ms_00000_arg_del
020C  2010  	CALL delay_ms_00000


	//Calculation
	//Calculation:
	//  TX_CHAR = 187
	FCV_TX_CHAR = 187;
020D  30BB  	MOVLW 0xBB
020E  00A4  	MOVWF gbl_FCV_TX_CHAR


	//Call Component Macro
	//Call Component Macro: SendRS232Char(TX_CHAR)
	FCD_RS2320_SendRS232Char(FCV_TX_CHAR);
020F  0824  	MOVF gbl_FCV_TX_CHAR, W
0210  00B3  	MOVWF FCD_RS2320_00052_arg_nChar
0211  01B4  	CLRF FCD_RS2320_00052_arg_nChar+D'1'
0212  20C5  	CALL FCD_RS2320_00052


	//Delay
	//Delay: 5 ms
	delay_ms(5);
0213  3005  	MOVLW 0x05
0214  1683  	BSF STATUS, RP0
0215  00B7  	MOVWF delay_ms_00000_arg_del
0216  2010  	CALL delay_ms_00000


}
0217  0008  	RETURN




void main()

{
	//Initialization
	ansel = 0;
0669  1283  	BCF STATUS, RP0
066A  1703  	BSF STATUS, RP1
066B  019E  	CLRF gbl_ansel

anselh = 0;
066C  019F  	CLRF gbl_anselh


	
		RS232_1_UART_Init( );		//Call initialise function
066D  2314  	CALL FC_CAL_UAR_0005F



	//Interrupt initialization code
	option_reg = 0xC0;
066E  30C0  	MOVLW 0xC0
066F  0081  	MOVWF gbl_option_reg



	//Connection Point
	//Connection Point: [A]: A
FCC_Main_A:
0670        label106

;

	//Call Macro
	//Call Macro: clr_char()
	FCM_clr_char();
0670  25FE  	CALL FCM_clr_ch_00053


	//Call Macro
	//Call Macro: clr_color()
	FCM_clr_color();
0671  25E9  	CALL FCM_clr_co_0005C


	//Call Component Macro
	//Call Component Macro: Start()
	FCD_LCDDisplay0_Start();
0672  2613  	CALL FCD_LCDDis_0006A


	//Call Component Macro
	//Call Component Macro: Clear()
	FCD_LCDDisplay0_Clear();
0673  2234  	CALL FCD_LCDDis_00059


	//Calculation
	//Calculation:
	//  cursorx = 0
	//  next_idx = 0
	FCV_CURSORX = 0;
0674  01A7  	CLRF gbl_FCV_CURSORX

	FCV_NEXT_IDX = 0;
0675  01A6  	CLRF gbl_FCV_NEXT_IDX


	//Loop
	//Loop: While 1
	while (1)
0676        label107

	{

		//Decision
		//Decision: char[next_idx] = 255?
		if (FCV_CHAR[FCV_NEXT_IDX] == 255)
0676  1283  	BCF STATUS, RP0
0677  1383  	BCF	STATUS,IRP
0678  3020  	MOVLW LOW(gbl_FCV_CHAR+D'0')
0679  0084  	MOVWF FSR
067A  1683  	BSF STATUS, RP0
067B  0826  	MOVF gbl_FCV_NEXT_IDX, W
067C  0784  	ADDWF FSR, F
067D  0A00  	INCF INDF, W
067E  1D03  	BTFSS STATUS,Z
067F  2E8A  	GOTO	label108
068A        label108

		{

			//Calculation
			//Calculation:
			//  char[next_idx] = 65
			FCV_CHAR[FCV_NEXT_IDX] = 65;
0680  1283  	BCF STATUS, RP0
0681  1383  	BCF	STATUS,IRP
0682  3020  	MOVLW LOW(gbl_FCV_CHAR+D'0')
0683  0084  	MOVWF FSR
0684  1683  	BSF STATUS, RP0
0685  0826  	MOVF gbl_FCV_NEXT_IDX, W
0686  0784  	ADDWF FSR, F
0687  3041  	MOVLW 0x41
0688  0080  	MOVWF INDF


		} else {
0689  2E9E  	GOTO	label109
06B0  118A  	BCF PCLATH,3
06B1  120A  	BCF PCLATH,4
06B2  2EA9  	GOTO	label110


			//Decision
			//Decision: char[next_idx] = 33?
			if (FCV_CHAR[FCV_NEXT_IDX] == 33)
068A  1283  	BCF STATUS, RP0
068B  1383  	BCF	STATUS,IRP
068C  3020  	MOVLW LOW(gbl_FCV_CHAR+D'0')
068D  0084  	MOVWF FSR
068E  1683  	BSF STATUS, RP0
068F  0826  	MOVF gbl_FCV_NEXT_IDX, W
0690  0784  	ADDWF FSR, F
0691  0800  	MOVF INDF, W
0692  3A21  	XORLW 0x21
0693  1D03  	BTFSS STATUS,Z
0694  2E9E  	GOTO	label109
069E        label109

			{

				//Calculation
				//Calculation:
				//  char[next_idx] = 65
				FCV_CHAR[FCV_NEXT_IDX] = 65;
0695  1283  	BCF STATUS, RP0
0696  1383  	BCF	STATUS,IRP
0697  3020  	MOVLW LOW(gbl_FCV_CHAR+D'0')
0698  0084  	MOVWF FSR
0699  1683  	BSF STATUS, RP0
069A  0826  	MOVF gbl_FCV_NEXT_IDX, W
069B  0784  	ADDWF FSR, F
069C  3041  	MOVLW 0x41
069D  0080  	MOVWF INDF


			// } else {

			}

		}

		//Call Macro
		//Call Macro: print_char_onlcd()
		FCM_print_char_onlcd();
069E  2323  	CALL FCM_print__00054


		//Call Component Macro
		//Call Component Macro: keypad_read=GetKeypadNumber()
		FCV_KEYPAD_READ = FCD_KeyPad0_GetKeypadNumber();
069F  2269  	CALL FCD_KeyPad_00058
06A0  083B  	MOVF CompTempVarRet2249, W
06A1  00A3  	MOVWF gbl_FCV_KEYPAD_READ


		//Call Macro
		//Call Macro: keypad_con()
		FCM_keypad_con();
06A2  118A  	BCF PCLATH,3
06A3  120A  	BCF PCLATH,4
06A4  23B7  	CALL FCM_keypad_00057


		//Decision
		//Decision: keypad_read = 2?
		if (FCV_KEYPAD_READ == 2)
06A5  0823  	MOVF gbl_FCV_KEYPAD_READ, W
06A6  3A02  	XORLW 0x02
06A7  1D03  	BTFSS STATUS,Z
06A8  2E76  	GOTO	label107
06A9        label110

		{

			//Loop
			//Loop: While keypad_read = 2
			while (FCV_KEYPAD_READ == 2)
06A9  0823  	MOVF gbl_FCV_KEYPAD_READ, W
06AA  3A02  	XORLW 0x02
06AB  1D03  	BTFSS STATUS,Z
06AC  2E70  	GOTO	label106

			{

				//Call Component Macro
				//Call Component Macro: keypad_read=GetKeypadNumber()
				FCV_KEYPAD_READ = FCD_KeyPad0_GetKeypadNumber();
06AD  2269  	CALL FCD_KeyPad_00058
06AE  083B  	MOVF CompTempVarRet2249, W
06AF  00A3  	MOVWF gbl_FCV_KEYPAD_READ



			}

			//Goto Connection Point
			//Goto Connection Point: [A]: A
			goto FCC_Main_A;


		// } else {

		}


	}

	//Comment:
	//SAMPLE DISPLAY W(Y), e(R) @CSRX=0404

	//Loop
	//Loop: While 1
	while (1)
	{

		//Call Macro
		//Call Macro: sample_ins()
		FCM_sample_ins();


		//Call Component Macro
		//Call Component Macro: Cursor(0, 0)
		FCD_LCDDisplay0_Cursor(0, 0);


		//Call Component Macro
		//Call Component Macro: PrintString("SAMPLE")
		FCD_LCDDisplay0_PrintString("SAMPLE", 6);



	}

	mainendloop: goto mainendloop;
}


void MX_INTERRUPT_MACRO(void)

{
}
06EC  0E76  	SWAPF Int1BContext+D'2', W
06ED  0084  	MOVWF FSR
06EE  0E75  	SWAPF Int1BContext+D'1', W
06EF  008A  	MOVWF PCLATH
06F0  0E74  	SWAPF Int1BContext, W
06F1  0083  	MOVWF STATUS
06F2  0EFF  	SWAPF Int1Context, F
06F3  0E7F  	SWAPF Int1Context, W
06F4  0009  	RETFIE





/*********************************************************************
 *                  Flowcode CAL UART File
 *
 * File: PIC_CAL_UART.c
 *
 * (c) 2011 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * “Company”) for its Flowcode graphical programming language is
 * intended and supplied to you, the Company’s customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 010911 | BR | Created
 * 020911 | BR | Updated variables with typedef alternatives
 * 011211 | BR | Converted to new dynamic defines mechanism
 * 160112 | BR | Fixed issues with rx return type and low bauds on fast devices
 * 020212 | ST | Added <MX_UART_2_PIE4> routing to account for differences in 16F and 18F devices with 2 UARTs
 * 270212 | BR | Fixed a bug in the receive functionality
 * 280212 | BR | Sorted out auto echo functionality
 * 160412 | BR | Addition of HW change baud function
 */



#ifndef MX_UART_SW_DEFS
	#define MX_UART_SW_DEFS

	#ifdef _BOOSTC
		#define INST_COUNT	45	//65 for lower speeds or 40 for higher speeds.
	#endif
	#ifdef HI_TECH_C
		#define INST_COUNT	315
	#endif

	//Work out number of nops for software baud rate
	#define MX_INSTRUCTION_SPEED 	(MX_CLK_SPEED / 4)
	#define MX_OVERHEAD				(MX_INSTRUCTION_SPEED / INST_COUNT)
	#define SW_OFFSET				(1000000 / MX_OVERHEAD)

	//Work out software baud rates if required
	#define SW_1200_BAUD	(832 - SW_OFFSET)
	#define SW_2400_BAUD	(416 - SW_OFFSET)
	#define SW_4800_BAUD	(208 - SW_OFFSET)
	#define SW_9600_BAUD	(104 - SW_OFFSET)
	#define SW_19200_BAUD	(52 - SW_OFFSET)
	#define SW_31250_BAUD	(32 - SW_OFFSET)
	#define SW_115200_BAUD	(8 - SW_OFFSET)
#endif

 #if defined(MX_UART_CHANNEL_1) && (MX_UART_NUM==1)
	#if (MX_UART_CHANNEL_1 == 0)
		#if (MX_UART_BAUD_1 == 1200)
			#define MX_SOFT_BAUD_1	SW_1200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 1200 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_1 == 2400)
			#define MX_SOFT_BAUD_1	SW_2400_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 2400 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_1 == 4800)
			#define MX_SOFT_BAUD_1	SW_4800_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 4800 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_1 == 9600)
			#define MX_SOFT_BAUD_1	SW_9600_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 9600 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_1 == 19200)
			#define MX_SOFT_BAUD_1	SW_19200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 19200 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_1 == 31250)
			#define MX_SOFT_BAUD_1	SW_31250_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 31250 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_1 == 115200)
			#define MX_SOFT_BAUD_1	SW_115200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 115200 Not Available At This Clock Speed"
			#endif
		#endif
		#ifndef MX_SOFT_BAUD_1
			#error "UART Baud Rate not supported in Software Mode"
		#endif
	#else
		#define MX_SOFT_BAUD_1	1
		#define MX_HARD_BAUD_1	(((MX_CLK_SPEED / MX_UART_BAUD_1) - 16) / 16)
		#define MX_HARD_SLOW_1	0

		#if (MX_HARD_BAUD_1 > 255)
			#undef MX_HARD_BAUD_1
			#undef MX_HARD_SLOW_1
			#define MX_HARD_BAUD_1	(((MX_CLK_SPEED / MX_UART_BAUD_1) - 16)	/ 64)
			#define MX_HARD_SLOW_1	1
		#endif

	#endif
 #endif
 #if defined(MX_UART_CHANNEL_2) && (MX_UART_NUM==2)
	#if (MX_UART_CHANNEL_2 == 0)
		#if (MX_UART_BAUD_2 == 1200)
			#define MX_SOFT_BAUD_2	SW_1200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 1200 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_2 == 2400)
			#define MX_SOFT_BAUD_2	SW_2400_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 2400 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_2 == 4800)
			#define MX_SOFT_BAUD_2	SW_4800_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 4800 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_2 == 9600)
			#define MX_SOFT_BAUD_2	SW_9600_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 9600 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_2 == 19200)
			#define MX_SOFT_BAUD_2	SW_19200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 19200 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_2 == 31250)
			#define MX_SOFT_BAUD_2	SW_31250_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 31250 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_2 == 115200)
			#define MX_SOFT_BAUD_2	SW_115200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 115200 Not Available At This Clock Speed"
			#endif
		#endif
		#ifndef MX_SOFT_BAUD_2
			#error "UART Baud Rate not supported in Software Mode"
		#endif
	#else
		#define MX_SOFT_BAUD_2	1
		#define MX_HARD_BAUD_2	(((MX_CLK_SPEED / MX_UART_BAUD_2) - 16) / 16)
		#define MX_HARD_SLOW_2	0

		#if (MX_HARD_BAUD_2 > 255)
			#undef MX_HARD_BAUD_2
			#undef MX_HARD_SLOW_2
			#define MX_HARD_BAUD_2	(((MX_CLK_SPEED / MX_UART_BAUD_2) - 16)	/ 64)
			#define MX_HARD_SLOW_2	1
		#endif
 	#endif
 #endif
 #if defined(MX_UART_CHANNEL_3) && (MX_UART_NUM==3)
	#if (MX_UART_CHANNEL_3 == 0)
		#if (MX_UART_BAUD_3 == 1200)
			#define MX_SOFT_BAUD_3	SW_1200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 1200 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_3 == 2400)
			#define MX_SOFT_BAUD_3	SW_2400_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 2400 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_3 == 4800)
			#define MX_SOFT_BAUD_3	SW_4800_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 4800 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_3 == 9600)
			#define MX_SOFT_BAUD_3	SW_9600_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 9600 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_3 == 19200)
			#define MX_SOFT_BAUD_3	SW_19200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 19200 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_3 == 31250)
			#define MX_SOFT_BAUD_3	SW_31250_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 31250 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_3 == 115200)
			#define MX_SOFT_BAUD_3	SW_115200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 115200 Not Available At This Clock Speed"
			#endif
		#endif
		#ifndef MX_SOFT_BAUD_3
			#error "UART Baud Rate not supported in Software Mode"
		#endif
	#else
		#define MX_SOFT_BAUD_3	1
		#define MX_HARD_BAUD_3	(((MX_CLK_SPEED / MX_UART_BAUD_3) - 16) / 16)
		#define MX_HARD_SLOW_3	0

		#if (MX_HARD_BAUD_3 > 255)
			#undef MX_HARD_BAUD_3
			#undef MX_HARD_SLOW_3
			#define MX_HARD_BAUD_3	(((MX_CLK_SPEED / MX_UART_BAUD_3) - 16)	/ 64)
			#define MX_HARD_SLOW_3	1
		#endif
	#endif
 #endif
 #if defined(MX_UART_CHANNEL_4) && (MX_UART_NUM==4)
	#if (MX_UART_CHANNEL_4 == 0)
		#if (MX_UART_BAUD_4 == 1200)
			#define MX_SOFT_BAUD_4	SW_1200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 1200 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_4 == 2400)
			#define MX_SOFT_BAUD_4	SW_2400_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 2400 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_4 == 4800)
			#define MX_SOFT_BAUD_4	SW_4800_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 4800 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_4 == 9600)
			#define MX_SOFT_BAUD_4	SW_9600_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 9600 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_4 == 19200)
			#define MX_SOFT_BAUD_4	SW_19200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 19200 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_4 == 31250)
			#define MX_SOFT_BAUD_4	SW_31250_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 31250 Not Available At This Clock Speed"
			#endif
		#endif
		#if (MX_UART_BAUD_4 == 115200)
			#define MX_SOFT_BAUD_4	SW_115200_BAUD
			#if (SW_OFFSET < 1)
				#error "Software UART Baud Rate 115200 Not Available At This Clock Speed"
			#endif
		#endif
		#ifndef MX_SOFT_BAUD_4
			#error "UART Baud Rate not supported in Software Mode"
		#endif
	#else
		#define MX_SOFT_BAUD_4	1
		#define MX_HARD_BAUD_4	(((MX_CLK_SPEED / MX_UART_BAUD_4) - 16) / 16)
		#define MX_HARD_SLOW_4	0

		#if (MX_HARD_BAUD_4 > 255)
			#undef MX_HARD_BAUD_4
			#undef MX_HARD_SLOW_4
			#define MX_HARD_BAUD_4	(((MX_CLK_SPEED / MX_UART_BAUD_4) - 16)	/ 64)
			#define MX_HARD_SLOW_4	1
		#endif
	#endif
 #endif


//Hardware Baud update definitions
#ifndef MX_HARD_BAUD_CHANGE_DEFS
	#define MX_HARD_BAUD_CHANGE_DEFS

	#define MX_HARD_BAUD_1200	(((MX_CLK_SPEED / 1200) - 16) / 16)
	#if (MX_HARD_BAUD_1200 > 255)
		#undef MX_HARD_BAUD_1200
		#define MX_HARD_BAUD_1200	(((MX_CLK_SPEED / 1200) - 16) / 64)
		#define MX_HARD_SLOW_1200	1
	#else
		#define MX_HARD_SLOW_1200	0
	#endif

	#define MX_HARD_BAUD_2400	(((MX_CLK_SPEED / 2400) - 16) / 16)
	#if (MX_HARD_BAUD_2400 > 255)
		#undef MX_HARD_BAUD_2400
		#define MX_HARD_BAUD_2400	(((MX_CLK_SPEED / 2400) - 16) / 64)
		#define MX_HARD_SLOW_2400	1
	#else
		#define MX_HARD_SLOW_2400	0
	#endif

	#define MX_HARD_BAUD_4800	(((MX_CLK_SPEED / 4800) - 16) / 16)
	#if (MX_HARD_BAUD_4800 > 255)
		#undef MX_HARD_BAUD_4800
		#define MX_HARD_BAUD_4800	(((MX_CLK_SPEED / 4800) - 16) / 64)
		#define MX_HARD_SLOW_4800	1
	#else
		#define MX_HARD_SLOW_4800	0
	#endif

	#define MX_HARD_BAUD_9600	(((MX_CLK_SPEED / 9600) - 16) / 16)
	#if (MX_HARD_BAUD_9600 > 255)
		#undef MX_HARD_BAUD_9600
		#define MX_HARD_BAUD_9600	(((MX_CLK_SPEED / 9600) - 16) / 64)
		#define MX_HARD_SLOW_9600	1
	#else
		#define MX_HARD_SLOW_9600	0
	#endif

	#define MX_HARD_BAUD_19200	(((MX_CLK_SPEED / 19200) - 16) / 16)
	#if (MX_HARD_BAUD_19200 > 255)
		#undef MX_HARD_BAUD_19200
		#define MX_HARD_BAUD_19200	(((MX_CLK_SPEED / 19200) - 16) / 64)
		#define MX_HARD_SLOW_19200	1
	#else
		#define MX_HARD_SLOW_19200	0
	#endif

	#define MX_HARD_BAUD_38400	(((MX_CLK_SPEED / 38400) - 16) / 16)
	#if (MX_HARD_BAUD_38400 > 255)
		#undef MX_HARD_BAUD_38400
		#define MX_HARD_BAUD_38400	(((MX_CLK_SPEED / 38400) - 16) / 64)
		#define MX_HARD_SLOW_38400	1
	#else
		#define MX_HARD_SLOW_38400	0
	#endif

	#define MX_HARD_BAUD_57600	(((MX_CLK_SPEED / 57600) - 16) / 16)
	#if (MX_HARD_BAUD_57600 > 255)
		#undef MX_HARD_BAUD_57600
		#define MX_HARD_BAUD_57600	(((MX_CLK_SPEED / 57600) - 16) / 64)
		#define MX_HARD_SLOW_57600	1
	#else
		#define MX_HARD_SLOW_57600	0
	#endif

	#define MX_HARD_BAUD_115200	(((MX_CLK_SPEED / 115200) - 16) / 16)
	#if (MX_HARD_BAUD_115200 > 255)
		#undef MX_HARD_BAUD_115200
		#define MX_HARD_BAUD_115200	(((MX_CLK_SPEED / 115200) - 16) / 64)
		#define MX_HARD_SLOW_115200	1
	#else
		#define MX_HARD_SLOW_115200	0
	#endif
#endif


//Dynamic function naming based on defines and index number
#define MX_UART_CHANNEL_X	CAL_APPEND(MX_UART_CHANNEL_, MX_UART_NUM)
#define MX_UART_TX_PIN_X	CAL_APPEND(MX_UART_TX_PIN_, MX_UART_NUM)
#define MX_UART_TX_PORT_X	CAL_APPEND(MX_UART_TX_PORT_, MX_UART_NUM)
#define MX_UART_TX_TRIS_X	CAL_APPEND(MX_UART_TX_TRIS_, MX_UART_NUM)
#define MX_UART_RX_PIN_X	CAL_APPEND(MX_UART_RX_PIN_, MX_UART_NUM)
#define MX_UART_RX_PORT_X	CAL_APPEND(MX_UART_RX_PORT_, MX_UART_NUM)
#define MX_UART_RX_TRIS_X	CAL_APPEND(MX_UART_RX_TRIS_, MX_UART_NUM)
#define MX_UART_FLOWEN_X	CAL_APPEND(MX_UART_FLOWEN_, MX_UART_NUM)
#define MX_UART_CTS_PIN_X	CAL_APPEND(MX_UART_CTS_PIN_, MX_UART_NUM)
#define MX_UART_CTS_PORT_X	CAL_APPEND(MX_UART_CTS_PORT_, MX_UART_NUM)
#define MX_UART_CTS_TRIS_X	CAL_APPEND(MX_UART_CTS_TRIS_, MX_UART_NUM)
#define MX_UART_RTS_PIN_X	CAL_APPEND(MX_UART_RTS_PIN_, MX_UART_NUM)
#define MX_UART_RTS_PORT_X	CAL_APPEND(MX_UART_RTS_PORT_, MX_UART_NUM)
#define MX_UART_RTS_TRIS_X	CAL_APPEND(MX_UART_RTS_TRIS_, MX_UART_NUM)
#define MX_UART_DBITS_X		CAL_APPEND(MX_UART_DBITS_, MX_UART_NUM)
#define MX_UART_RETURN_X	CAL_APPEND(MX_UART_RETURN_, MX_UART_NUM)
#define MX_UART_ECHO_X		CAL_APPEND(MX_UART_ECHO_, MX_UART_NUM)
#define MX_UART_INT_X		CAL_APPEND(MX_UART_INT_, MX_UART_NUM)
#define MX_UART_BAUD_X		CAL_APPEND(MX_HARD_BAUD_, MX_UART_NUM)
#define MX_SOFT_BAUD_X		CAL_APPEND(MX_SOFT_BAUD_, MX_UART_NUM)
#define MX_HARD_SLOW_X		CAL_APPEND(MX_HARD_SLOW_, MX_UART_NUM)

#define UART_Delay_CAL		CAL_APPEND(FC_CAL_UART_Delay_, MX_UART_NUM)
#define UART_Send			CAL_APPEND(FC_CAL_UART_Send_, MX_UART_NUM)
#define UART_Uninit			CAL_APPEND(FC_CAL_UART_Uninit_, MX_UART_NUM)


//Component Definitions
#define UART_STATUS_LOOP	0
#define UART_STATUS_TIMEOUT	1
#define UART_STATUS_RXBYTE	2


//Interrupt Definitions
#ifdef MX_UART_2_PIE4
  #define MX_UART2_PIE pie4
  #define MX_UART2_PIR pir4
  #define MX_UART2_TXSTA tx2sta
  #define MX_UART2_RCSTA rc2sta
  #define MX_UART2_TXREG tx2reg
  #define MX_UART2_RCREG rc2reg
#else
  #define MX_UART2_PIE pie3
  #define MX_UART2_PIR pir3
  #define MX_UART2_TXSTA txsta2
  #define MX_UART2_RCSTA rcsta2
  #define MX_UART2_TXREG txreg2
  #define MX_UART2_RCREG rcreg2
#endif

#if (MX_UART_INT_X == 1)

	#ifndef MX_UART_INT_DEFS
	#define MX_UART_INT_DEFS

		#define MX_UART_INT_CH1_FUNC
		#define MX_UART_INT_CH2_FUNC
		#define MX_UART_INT_FUNC_END

		#define MX_UART_INT_CH1_DET		ts_bit(pir1, RCIF) && ts_bit(pie1, RCIE)
		#define MX_UART_INT_CH2_DET		ts_bit(MX_UART2_PIR, RC2IF) && ts_bit(MX_UART2_PIE, RC2IE)

		#define MX_UART_INT_CH1_EN		st_bit (pie1, RCIE)
		#define MX_UART_INT_CH2_EN		st_bit (MX_UART2_PIE, RC2IE)

		#define MX_UART_INT_CH1_DIS		cr_bit (pie1, RCIE)
		#define MX_UART_INT_CH2_DIS		cr_bit (MX_UART2_PIE, RC2IE)

		#define MX_UART_INT_CH1_CLR		cr_bit (pir1, RCIF)
		#define MX_UART_INT_CH2_CLR		cr_bit (MX_UART2_PIR, RC2IF)

	#endif
#endif


//Function Prototypes
CALFUNCTION(void, FC_CAL_UART_Init_, (void));
CALFUNCTION(void, FC_CAL_UART_Uninit_, (void));
CALFUNCTION(void, FC_CAL_UART_Send_, (MX_UINT16 nChar));
CALFUNCTION(MX_SINT16, FC_CAL_UART_Receive_, (MX_UINT8 nTimeout));
CALFUNCTION(void, FC_CAL_UART_Delay_, (void));


//Peripheral Functions
CALFUNCTION(void, FC_CAL_UART_Init_, (void))

{

	#if (MX_UART_CHANNEL_X == 0)
		FC_CAL_Bit_In_DDR 	(MX_UART_RX_PORT_X, MX_UART_RX_TRIS_X, MX_UART_RX_PIN_X);		// Receive pin is a input
		FC_CAL_Bit_High_DDR (MX_UART_TX_PORT_X, MX_UART_TX_TRIS_X, MX_UART_TX_PIN_X);		// Transmit pin is default high
	#endif

	#if (MX_UART_CHANNEL_X == 1)
	  #ifndef MX_UART_1
	  	  #error "UART channel 1 not available on this device"
	  #else
		  #if (MX_HARD_SLOW_X == 1)
			cr_bit(txsta, BRGH);						//Low Speed
		  #else
			st_bit(txsta, BRGH);						//High Speed
0314  1683  	BSF STATUS, RP0
0315  1303  	BCF STATUS, RP1
0316  1518  	BSF gbl_txsta,2

		  #endif
			spbrg = MX_UART_BAUD_X;   					// set the baud rate
0317  3081  	MOVLW 0x81
0318  0099  	MOVWF gbl_spbrg

			rcsta = 0;                    				// 8-bit, disabled
0319  1283  	BCF STATUS, RP0
031A  0198  	CLRF gbl_rcsta


			#if(MX_UART_DBITS_X == 9)
				st_bit(txsta, TX9);   					// 9-bit TX
				st_bit(rcsta, RX9);                    	// 9-bit RX
			#endif

			st_bit(rcsta, SPEN);         				// turn on serial interface
031B  1798  	BSF gbl_rcsta,7

			st_bit(txsta, TXEN);
031C  1683  	BSF STATUS, RP0
031D  1698  	BSF gbl_txsta,5

			st_bit(rcsta, CREN);
031E  1283  	BCF STATUS, RP0
031F  1618  	BSF gbl_rcsta,4


			#if (MX_UART_INT_X == 1)
				MX_UART_INT_CH1_EN;
				st_bit(intcon, PEIE);
				st_bit(intcon, GIE);
			#else
				cr_bit (pie1, RCIE);
0320  1683  	BSF STATUS, RP0
0321  128C  	BCF gbl_pie1,5

			#endif
	  #endif
	#endif


	#if (MX_UART_CHANNEL_X == 2)

	  #ifndef MX_UART_2
		  #error "UART channel 2 not available on this device"
	  #else
		  #ifdef MX_UART_2_REMAPPABLE
			RPOR9 = 5;									//TX2 - RP9 - RB6
			RPINR16	= 10;								//RX2 - RP10 - RB7
		  #endif
		  #if (MX_HARD_SLOW_X == 1)
			cr_bit(MX_UART2_TXSTA, BRGH);						//Low Speed
		  #else
			st_bit(MX_UART2_TXSTA, BRGH);						//High Speed
		  #endif
			spbrg2 = MX_UART_BAUD_X;   				// set the baud rate
			MX_UART2_RCSTA = 0;                    				// 8-bit, disabled

			#if(MX_UART_DBITS_X == 9)
				st_bit(MX_UART2_TXSTA, TX9);   					// 9-bit TX
				st_bit(MX_UART2_RCSTA, RX9);                    // 9-bit RX
			#endif

			st_bit(MX_UART2_RCSTA, SPEN);         				// turn on serial interface
			st_bit(MX_UART2_TXSTA, TXEN);
			st_bit(MX_UART2_RCSTA, CREN);

			#if (MX_UART_INT_X == 1)
				MX_UART_INT_CH2_EN;
				st_bit(intcon, PEIE);
				st_bit(intcon, GIE);
			#else
				cr_bit (MX_UART2_PIE, RC2IE);
			#endif
	  #endif
	#endif

	#if (MX_UART_FLOWEN_X == 1)						//Flowcontrol enabled?
		FC_CAL_Bit_In_DDR (MX_UART_CTS_PORT_X, MX_UART_CTS_TRIS_X, MX_UART_CTS_PIN_X);	// CTS pin is a input
		FC_CAL_Bit_High_DDR (MX_UART_RTS_PORT_X, MX_UART_RTS_TRIS_X, MX_UART_RTS_PIN_X);	// RTS not ready to accept data
	#endif

}
0322  0008  	RETURN




CALFUNCTION(void, FC_CAL_UART_Uninit_, (void))
{

	#if (MX_UART_CHANNEL_X == 0)
		FC_CAL_Bit_In_DDR (MX_UART_RX_PORT_X, MX_UART_RX_TRIS_X, MX_UART_RX_PIN_X);		// Receive pin is a input
		FC_CAL_Bit_In_DDR (MX_UART_TX_PORT_X, MX_UART_TX_TRIS_X, MX_UART_TX_PIN_X);		// Transmit pin is default high
	#endif

	#if (MX_UART_CHANNEL_X == 1)
			rcsta = 0;                    								// 8-bit, disabled
			txsta = 0;
		  #ifdef MX_UART_RXINT
			MX_UART_INT_CH1_DIS;
		  #endif
	#endif

	#if (MX_UART_CHANNEL_X == 2)
			MX_UART2_RCSTA = 0;                    								// 8-bit, disabled
			MX_UART2_TXSTA = 0;
		  #ifdef MX_UART_RXINT
			MX_UART_INT_CH2_DIS;
		  #endif
	#endif

	#if (MX_UART_FLOWEN_X == 1)										//Flowcontrol enabled?
		FC_CAL_Bit_In_DDR (MX_UART_CTS_PORT_X, MX_UART_CTS_TRIS_X, MX_UART_CTS_PIN_X);		// CTS pin is a input
		FC_CAL_Bit_In_DDR (MX_UART_RTS_PORT_X, MX_UART_RTS_TRIS_X, MX_UART_RTS_PIN_X);		// RTS not ready to accept data
	#endif
}



CALFUNCTION(void, FC_CAL_UART_Send_, (MX_UINT16 nChar))

{
	#if (MX_UART_FLOWEN_X == 1)
		while (FC_CAL_Bit_In(MX_UART_CTS_PORT_X, MX_UART_CTS_PIN_X) != 0);	// Wait until CTS is low
	#endif

	#if (MX_UART_CHANNEL_X == 0)													// Software UART TX
		MX_UINT8 idx;
		FC_CAL_Bit_Low(MX_UART_TX_PORT_X, MX_UART_TX_PIN_X);					// Send Start bit
		UART_Delay_CAL();
		for (idx = 0; idx < MX_UART_DBITS_X; idx++)
		{
			if (nChar & 0x01)														// Mask off data bit
				FC_CAL_Bit_High(MX_UART_TX_PORT_X, MX_UART_TX_PIN_X);
			else
				FC_CAL_Bit_Low(MX_UART_TX_PORT_X, MX_UART_TX_PIN_X);
			UART_Delay_CAL();
			nChar = nChar >> 1;														// Move to next data bit
		}
		FC_CAL_Bit_High(MX_UART_TX_PORT_X, MX_UART_TX_PIN_X);					// Send Stop bit
		UART_Delay_CAL();
	#endif

	#if (MX_UART_CHANNEL_X == 1)
		while (ts_bit(pir1, TXIF) == 0);
009C        label12
009C  1283  	BCF STATUS, RP0
009D  1E0C  	BTFSS gbl_pir1,4
009E  289C  	GOTO	label12


		#if (MX_UART_DBITS_X == 9)
			if (test_bit(nChar, 8))
				st_bit(txsta, TX9D);
			else
				cr_bit(txsta, TX9D);
	  	#endif
		txreg = nChar;
009F  1683  	BSF STATUS, RP0
00A0  0835  	MOVF FC_CAL_UAR_00060_arg_nChar, W
00A1  1283  	BCF STATUS, RP0
00A2  0099  	MOVWF gbl_txreg

	#endif

	#if (MX_UART_CHANNEL_X == 2)
		while (ts_bit(pir3, TX2IF) == 0);

		#if (MX_UART_DBITS_X == 9)
			if (test_bit(nChar, 8))
				st_bit(MX_UART2_TXSTA, TX9D);
			else
				cr_bit(MX_UART2_TXSTA, TX9D);
		#endif
		MX_UART2_TXREG = nChar;
	#endif
}
00A3  0008  	RETURN



CALFUNCTION(MX_SINT16, FC_CAL_UART_Receive_, (MX_UINT8 nTimeout))
{
  #if (MX_UART_RETURN_X == 1)
	MX_UINT16 retVal = 512;
  #else
  	MX_UINT8 retVal = 255;
  #endif

	MX_UINT8 delay1 = 0;
	MX_UINT8 regcheck = 0;
	MX_UINT8 bWaitForever = 0;
	MX_UINT8 rxStatus = UART_STATUS_LOOP;

  #if (MX_UART_CHANNEL_X == 0)
  	MX_UINT8 idx;
  #else
  	MX_UINT8 dummy = 0;
  #endif

	if (nTimeout == 255)
		bWaitForever = 1;

	#if (MX_UART_FLOWEN_X == 1)
		FC_CAL_Bit_Low (MX_UART_RTS_PORT_X, MX_UART_RTS_PIN_X);			// Ready to accept data
	#endif

	while (rxStatus == UART_STATUS_LOOP)
	{
		if (bWaitForever == 0)
		{
			if (nTimeout == 0)							//don't wait forever, so do timeout thing...
			{
				rxStatus = UART_STATUS_TIMEOUT;
			}
			else
			{
				delay_us(10);
				delay1 = delay1 + 1;
				if(delay1 == 100)
				{
					nTimeout = nTimeout - 1;
					MX_CLEAR_WATCHDOG;
					delay1 = 0;
				}
			}
		}

		#if (MX_UART_CHANNEL_X == 0)
			regcheck = FC_CAL_Bit_In(MX_UART_RX_PORT_1, MX_UART_RX_PIN_1);	//Test for start bit
			if (regcheck == 0)
				rxStatus = UART_STATUS_RXBYTE;
		#endif

		#if (MX_UART_CHANNEL_X == 1)
			regcheck = ts_bit(pir1, RCIF);
			if (regcheck != 0)
				rxStatus = UART_STATUS_RXBYTE;
		#endif

		#if (MX_UART_CHANNEL_X == 2)
			regcheck = ts_bit(MX_UART2_PIR, RC2IF);
			if (regcheck != 0)
				rxStatus = UART_STATUS_RXBYTE;
		#endif

	}

	if (rxStatus == UART_STATUS_RXBYTE)
	{
		#if (MX_UART_CHANNEL_X == 0)

			retVal = 0;
			UART_Delay_CAL();

			for (idx = 0; idx < MX_UART_DBITS_X; idx++)
			{
				if (FC_CAL_Bit_In(MX_UART_RX_PORT_X, MX_UART_RX_PIN_X))
					retVal = retVal | (0x01 << idx);

				UART_Delay_CAL();
			}
		#endif

		#if (MX_UART_CHANNEL_X == 1)
			regcheck = ts_bit(rcsta, FERR);
			if (regcheck != 0)
			{
				dummy = rcreg;						//need to read the rcreg to clear FERR
				#if (MX_UART_RETURN_X == 1)
					retVal = 0x400;					//Framing Error Flag
				#endif
			}
			else
			{
				regcheck = ts_bit(rcsta, OERR);
				if (regcheck != 0)
				{
					cr_bit(rcsta, CREN);			//Reset receiver to clear error
					st_bit(rcsta, CREN);

					#if (MX_UART_RETURN_X == 1)
						retVal = 0x800;				//Overrun Error Flag
					#endif
				}
				else
				{
					retVal = 0;

					#if (MX_UART_DBITS_X == 9)
						if(ts_bit(rcsta, RX9D))
							retVal = 0x100;
					#endif

					retVal = retVal | rcreg; 			//no error, so rx byte is valid
				}
			}
		#endif

		#if (MX_UART_CHANNEL_X == 2)
			regcheck = ts_bit(MX_UART2_RCSTA, FERR);
			if (regcheck != 0)
			{
				dummy = MX_UART2_RCREG;			//need to read the rcreg to clear FERR
				#if (MX_UART_RETURN_X == 1)
					retVal = 0x400;					//Framing Error Flag
				#endif
			}
			else
			{
				regcheck = ts_bit(MX_UART2_RCSTA, OERR);
				if (regcheck != 0)
				{
					cr_bit(MX_UART2_RCSTA, CREN);	//Reset receiver to clear error
					st_bit(MX_UART2_RCSTA, CREN);
					#if (MX_UART_RETURN_X == 1)
						retVal = 0x800;				//Overrun Error Flag
					#endif
				}
				else
				{
					retVal = 0;

					#if (MX_UART_DBITS_X == 9)
						if(ts_bit(MX_UART2_RCSTA, RX9D))
							retVal = 0x100;
					#endif

					retVal = retVal | MX_UART2_RCREG; 			//no error, so rx byte is valid
				}
			}

		#endif

		#if (MX_UART_ECHO_X == 1)
			UART_Send(retVal);
		#endif
	}

	#if (MX_UART_FLOWEN_X == 1)
		FC_CAL_Bit_High(MX_UART_RTS_PORT_X, MX_UART_RTS_PIN_X);		//not ready to accept data
	#endif

	return (retVal);
}


CALFUNCTION(void, FC_CAL_UART_Delay_, (void))
{
  #if (MX_UART_CHANNEL_X == 0)

	MX_UINT16 delay = MX_SOFT_BAUD_X;

	while (delay > 255)
	{
		delay_us(255);
		delay = delay - 255;
		MX_CLEAR_WATCHDOG;
	}
	delay_us(delay);
	MX_CLEAR_WATCHDOG;

  #endif
}


CALFUNCTION(void, FC_CAL_UART_Update_Baud_, (MX_UINT8 new_baud))
{
	//Baud Rates - Function compatible with hardware mode only
	/*
	0 - 1200
	1 - 2400
	2 - 4800
	3 - 9600
	4 - 19200
	5 - 38400
	6 - 57600
	7 - 115200
	*/

	MX_UINT8 baudrate, baudmode;

	if (new_baud > 7)
		return;

	if (new_baud == 0)
	{
		baudrate = MX_HARD_BAUD_1200;
		baudmode = MX_HARD_SLOW_1200;
	}
	else if (new_baud == 1)
	{
		baudrate = MX_HARD_BAUD_2400;
		baudmode = MX_HARD_SLOW_2400;
	}
	else if (new_baud == 2)
	{
		baudrate = MX_HARD_BAUD_4800;
		baudmode = MX_HARD_SLOW_4800;
	}
	else if (new_baud == 3)
	{
		baudrate = MX_HARD_BAUD_9600;
		baudmode = MX_HARD_SLOW_9600;
	}
	else if (new_baud == 4)
	{
		baudrate = MX_HARD_BAUD_19200;
		baudmode = MX_HARD_SLOW_19200;
	}
	else if (new_baud == 5)
	{
		baudrate = MX_HARD_BAUD_38400;
		baudmode = MX_HARD_SLOW_38400;
	}
	else if (new_baud == 6)
	{
		baudrate = MX_HARD_BAUD_57600;
		baudmode = MX_HARD_SLOW_57600;
	}
	else if (new_baud == 7)
	{
		baudrate = MX_HARD_BAUD_115200;
		baudmode = MX_HARD_SLOW_115200;
	}

	UART_Uninit();

	#if (MX_UART_CHANNEL_X == 1)

	    if (baudmode == 1)
			cr_bit(txsta, BRGH);					//Low Speed
	    else
			st_bit(txsta, BRGH);					//High Speed

		spbrg = baudrate;   						// set the baud rate
		rcsta = 0;                    				// 8-bit, disabled

		#if(MX_UART_DBITS_X == 9)
			st_bit(txsta, TX9);   					// 9-bit TX
			st_bit(rcsta, RX9);                    	// 9-bit RX
		#endif

		st_bit(rcsta, SPEN);         				// turn on serial interface
		st_bit(txsta, TXEN);
		st_bit(rcsta, CREN);

		#if (MX_UART_INT_X == 1)
			MX_UART_INT_CH1_EN;
			st_bit(intcon, PEIE);
			st_bit(intcon, GIE);
		#else
			cr_bit (pie1, RCIE);
		#endif
	#endif

	#if (MX_UART_CHANNEL_X == 2)

	  	if (baudmode == 1)
			cr_bit(MX_UART2_TXSTA, BRGH);			//Low Speed
	  	else
			st_bit(MX_UART2_TXSTA, BRGH);			//High Speed

		spbrg2 = baudrate;   						// set the baud rate
		MX_UART2_RCSTA = 0;                    		// 8-bit, disabled

		#if(MX_UART_DBITS_X == 9)
			st_bit(MX_UART2_TXSTA, TX9);   			// 9-bit TX
			st_bit(MX_UART2_RCSTA, RX9);            // 9-bit RX
		#endif

		st_bit(MX_UART2_RCSTA, SPEN);         		// turn on serial interface
		st_bit(MX_UART2_TXSTA, TXEN);
		st_bit(MX_UART2_RCSTA, CREN);

		#if (MX_UART_INT_X == 1)
			MX_UART_INT_CH2_EN;
			st_bit(intcon, PEIE);
			st_bit(intcon, GIE);
		#else
			cr_bit (MX_UART2_PIE, RC2IE);
		#endif
	#endif

	#if (MX_UART_FLOWEN_X == 1)						//Flowcontrol enabled?
		FC_CAL_Bit_In_DDR (MX_UART_CTS_PORT_X, MX_UART_CTS_TRIS_X, MX_UART_CTS_PIN_X);	// CTS pin is a input
		FC_CAL_Bit_High_DDR (MX_UART_RTS_PORT_X, MX_UART_RTS_TRIS_X, MX_UART_RTS_PIN_X);	// RTS not ready to accept data
	#endif

}

////////////////////////////////////////
// Code with no source :-)
////////////////////////////////////////
0000  2EB3  	GOTO	_startup

0004  00FF  	MOVWF Int1Context
0005  0E03  	SWAPF STATUS, W
0006  00F4  	MOVWF Int1BContext
0007  0E0A  	SWAPF PCLATH, W
0008  00F5  	MOVWF Int1BContext+D'1'
0009  0E04  	SWAPF FSR, W
000A  00F6  	MOVWF Int1BContext+D'2'
000B  118A  	BCF PCLATH,3
000C  120A  	BCF PCLATH,4
000D  2EEC  	GOTO	interrupt

0010        delay_ms_00000
0010        ; { delay_ms ; function begin
0010  08B7  	MOVF delay_ms_00000_arg_del, F
0011  1D03  	BTFSS STATUS,Z
0012  2814  	GOTO	label1
0013  0008  	RETURN
0014        label1
0014  30F9  	MOVLW 0xF9
0015        label2
0015  0000  	NOP
0016  0000  	NOP
0017  0000  	NOP
0018  0000  	NOP
0019  0000  	NOP
001A  0000  	NOP
001B  0000  	NOP
001C  0000  	NOP
001D  0000  	NOP
001E  0000  	NOP
001F  0000  	NOP
0020  0000  	NOP
0021  0000  	NOP
0022  0000  	NOP
0023  0000  	NOP
0024  0000  	NOP
0025  3EFF  	ADDLW 0xFF
0026  1D03  	BTFSS STATUS,Z
0027  2815  	GOTO	label2
0028  0000  	NOP
0029  0000  	NOP
002A  0000  	NOP
002B  0000  	NOP
002C  0000  	NOP
002D  0000  	NOP
002E  0000  	NOP
002F  0000  	NOP
0030  0000  	NOP
0031  0000  	NOP
0032  0000  	NOP
0033  0000  	NOP
0034  0000  	NOP
0035  0000  	NOP
0036  0000  	NOP
0037  0000  	NOP
0038  0000  	NOP
0039  0BB7  	DECFSZ delay_ms_00000_arg_del, F
003A  2814  	GOTO	label1
003B  0008  	RETURN
003C        ; } delay_ms function end

003C        delay_10us_00000
003C        ; { delay_10us ; function begin
003C  08C5  	MOVF delay_10us_00000_arg_del, F
003D  1D03  	BTFSS STATUS,Z
003E  2840  	GOTO	label3
003F  0008  	RETURN
0040        label3
0040  3009  	MOVLW 0x09
0041        label4
0041  0000  	NOP
0042  3EFF  	ADDLW 0xFF
0043  1D03  	BTFSS STATUS,Z
0044  2841  	GOTO	label4
0045  0000  	NOP
0046  0000  	NOP
0047  0BC5  	DECFSZ delay_10us_00000_arg_del, F
0048  2840  	GOTO	label3
0049  0008  	RETURN
004A        ; } delay_10us function end

004A        delay_us_00000
004A        ; { delay_us ; function begin
004A        label5
004A  0000  	NOP
004B  0000  	NOP
004C  0BB6  	DECFSZ delay_us_00000_arg_del, F
004D  284A  	GOTO	label5
004E  0008  	RETURN
004F        ; } delay_us function end

004F        __rom_get_00000
004F        ; { __rom_get ; function begin
004F  0836  	MOVF __rom_get_00000_arg_objNumb, W
0050  00BE  	MOVWF __rom_get_00000_1_romAddr+D'1'
0051  01BD  	CLRF __rom_get_00000_1_romAddr
0052  1003  	BCF STATUS,C
0053  0DBE  	RLF __rom_get_00000_1_romAddr+D'1', F
0054  0DBD  	RLF __rom_get_00000_1_romAddr, F
0055  0DBE  	RLF __rom_get_00000_1_romAddr+D'1', F
0056  0DBD  	RLF __rom_get_00000_1_romAddr, F
0057  07BE  	ADDWF __rom_get_00000_1_romAddr+D'1', F
0058  1803  	BTFSC STATUS,C
0059  0ABD  	INCF __rom_get_00000_1_romAddr, F
005A  07BE  	ADDWF __rom_get_00000_1_romAddr+D'1', F
005B  1803  	BTFSC STATUS,C
005C  0ABD  	INCF __rom_get_00000_1_romAddr, F
005D  3068  	MOVLW	LOW( label6 )
005E  07BE  	ADDWF __rom_get_00000_1_romAddr+D'1', F
005F  1803  	BTFSC STATUS,C
0060  0ABD  	INCF __rom_get_00000_1_romAddr, F
0061  3000  	MOVLW	HIGH( label6 )
0062  073D  	ADDWF __rom_get_00000_1_romAddr, W
0063  008A  	MOVWF PCLATH
0064  0837  	MOVF __rom_get_00000_arg_idx, W
0065  00BD  	MOVWF __rom_get_00000_1_romAddr
0066  083E  	MOVF __rom_get_00000_1_romAddr+D'1', W
0067  0082  	MOVWF PCL
0068        label6
0068  3000  	MOVLW	HIGH( label7 )
0069  008A  	MOVWF PCLATH
006A  3000  	MOVLW	HIGH( label8 )
006B  00BE  	MOVWF __rom_get_00000_1_romAddr+D'1'
006C  3084  	MOVLW	LOW( label8 )
006D  287D  	GOTO	label7
006E  3000  	MOVLW	HIGH( label7 )
006F  008A  	MOVWF PCLATH
0070  3000  	MOVLW	HIGH( label9 )
0071  00BE  	MOVWF __rom_get_00000_1_romAddr+D'1'
0072  3087  	MOVLW	LOW( label9 )
0073  287D  	GOTO	label7
0074  3000  	MOVLW	HIGH( label7 )
0075  008A  	MOVWF PCLATH
0076  3000  	MOVLW	HIGH( label10 )
0077  00BE  	MOVWF __rom_get_00000_1_romAddr+D'1'
0078  308A  	MOVLW	LOW( label10 )
0079  287D  	GOTO	label7
007A  3000  	MOVLW	HIGH( label11 )
007B  00BE  	MOVWF __rom_get_00000_1_romAddr+D'1'
007C  3093  	MOVLW	LOW( label11 )
007D        label7
007D  07BD  	ADDWF __rom_get_00000_1_romAddr, F
007E  1803  	BTFSC STATUS,C
007F  0ABE  	INCF __rom_get_00000_1_romAddr+D'1', F
0080  083E  	MOVF __rom_get_00000_1_romAddr+D'1', W
0081  008A  	MOVWF PCLATH
0082  083D  	MOVF __rom_get_00000_1_romAddr, W
0083  0082  	MOVWF PCL
0084        label8
0084  3403  	RETLW 0x03
0085  3404  	RETLW 0x04
0086  3405  	RETLW 0x05
0087        label9
0087  3402  	RETLW 0x02
0088  3401  	RETLW 0x01
0089  3400  	RETLW 0x00
008A        label10
008A  3401  	RETLW 0x01
008B  3404  	RETLW 0x04
008C  3407  	RETLW 0x07
008D  3402  	RETLW 0x02
008E  3405  	RETLW 0x05
008F  3408  	RETLW 0x08
0090  3403  	RETLW 0x03
0091  3406  	RETLW 0x06
0092  3409  	RETLW 0x09
0093        label11
0093  3431  	RETLW 0x31
0094  3434  	RETLW 0x34
0095  3437  	RETLW 0x37
0096  3432  	RETLW 0x32
0097  3435  	RETLW 0x35
0098  3438  	RETLW 0x38
0099  3433  	RETLW 0x33
009A  3436  	RETLW 0x36
009B  3439  	RETLW 0x39
009C        ; } __rom_get function end


00A4        __mul_8u_8_00006
00A4        ; { __mul_8u_8u ; function begin
00A4  01BE  	CLRF __mul_8u_8_00006_1_i
00A5  01C1  	CLRF CompTempVarRet452
00A6  01C2  	CLRF CompTempVarRet452+D'1'
00A7  083B  	MOVF __mul_8u_8_00006_arg_a, W
00A8  00BF  	MOVWF __mul_8u_8_00006_1_t
00A9  01C0  	CLRF __mul_8u_8_00006_1_t+D'1'
00AA        label13
00AA  19BE  	BTFSC __mul_8u_8_00006_1_i,3
00AB  0008  	RETURN
00AC  1C3C  	BTFSS __mul_8u_8_00006_arg_b,0
00AD  28B4  	GOTO	label14
00AE  083F  	MOVF __mul_8u_8_00006_1_t, W
00AF  07C1  	ADDWF CompTempVarRet452, F
00B0  1803  	BTFSC gbl_status,0
00B1  0AC2  	INCF CompTempVarRet452+D'1', F
00B2  0840  	MOVF __mul_8u_8_00006_1_t+D'1', W
00B3  07C2  	ADDWF CompTempVarRet452+D'1', F
00B4        label14
00B4  0CBC  	RRF __mul_8u_8_00006_arg_b, F
00B5  1003  	BCF gbl_status,0
00B6  0DBF  	RLF __mul_8u_8_00006_1_t, F
00B7  0DC0  	RLF __mul_8u_8_00006_1_t+D'1', F
00B8  0ABE  	INCF __mul_8u_8_00006_1_i, F
00B9  28AA  	GOTO	label13
00BA        ; } __mul_8u_8u function end


06B3        _startup
06B3  30D5  	MOVLW 0xD5
06B4  1283  	BCF STATUS, RP0
06B5  1303  	BCF STATUS, RP1
06B6  00E0  	MOVWF gbl_14_LSR
06B7  30C4  	MOVLW 0xC4
06B8  00E1  	MOVWF gbl_14_LSR+D'1'
06B9  30BB  	MOVLW 0xBB
06BA  00E2  	MOVWF gbl_14_LSR+D'2'
06BB  30DC  	MOVLW 0xDC
06BC  00E3  	MOVWF gbl_14_LSR+D'3'
06BD  01E4  	CLRF gbl_15_gbl_aSig
06BE  01E5  	CLRF gbl_15_gbl_aSig+D'1'
06BF  01E6  	CLRF gbl_15_gbl_aSig+D'2'
06C0  01E7  	CLRF gbl_15_gbl_aSig+D'3'
06C1  01E8  	CLRF gbl_15_gbl_bSig
06C2  01E9  	CLRF gbl_15_gbl_bSig+D'1'
06C3  01EA  	CLRF gbl_15_gbl_bSig+D'2'
06C4  01EB  	CLRF gbl_15_gbl_bSig+D'3'
06C5  01EC  	CLRF gbl_15_gbl_zSig
06C6  01ED  	CLRF gbl_15_gbl_zSig+D'1'
06C7  01EE  	CLRF gbl_15_gbl_zSig+D'2'
06C8  01EF  	CLRF gbl_15_gbl_zSig+D'3'
06C9  01FC  	CLRF gbl_15_gbl_aExp
06CA  01FD  	CLRF gbl_15_gbl_bExp
06CB  01F7  	CLRF gbl_15_gbl_zExp
06CC  01F8  	CLRF gbl_15_gbl_zExp+D'1'
06CD  01FE  	CLRF gbl_15_gbl_aSign
06CE  1683  	BSF STATUS, RP0
06CF  01A0  	CLRF gbl_15_gbl_bSign
06D0  01A1  	CLRF gbl_15_gbl_zSign
06D1  01A2  	CLRF gbl_15_gbl_zSigZero
06D2  01F0  	CLRF gbl_15_gbl_ret
06D3  01F1  	CLRF gbl_15_gbl_ret+D'1'
06D4  01F2  	CLRF gbl_15_gbl_ret+D'2'
06D5  01F3  	CLRF gbl_15_gbl_ret+D'3'
06D6  01FA  	CLRF gbl_float_rounding_mode
06D7  01FB  	CLRF gbl_float_exception_flags
06D8  01F9  	CLRF gbl_float_detect_tininess

06E9  118A  	BCF PCLATH,3
06EA  120A  	BCF PCLATH,4
06EB  2E69  	GOTO	main

2007  30D2  	DW 0x30D2
